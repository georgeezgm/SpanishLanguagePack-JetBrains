#
# Copyright 2000-2007 JetBrains s.r.o.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

########################################################################################################################
# Introduce variable
########################################################################################################################
introduce.variable.title=Introducir variable
only.in.groovy.files=Esta refactorización solo está disponible en archivos Groovy
selected.block.should.represent.an.expression=El bloque seleccionado debe representar una expresión
refactoring.is.not.supported.in.the.current.context=La refactorización no es compatible en el contexto actual
refactoring.is.not.supported.in.method.parameters=No se admite la refactorización en los parámetros de cierre o método
replace.all.occurrences=Reemplazar todas las ocurrencias
declare.final=Declare final
press.escape.to.remove.the.highlighting=Presione Escape para eliminar el resaltado
specify.the.type.explicitly=Especifique el tipo explícitamente
variable.of.type=Variable de tipo:
selected.expression.has.void.type=La expresión seleccionada tiene un tipo vacío
selected.expression.in.command.expression=La expresión seleccionada es parte de la expresión de comando
introduced.variable.conflicts.with.parameter.0=La variable introducida entrará en conflicto con el parámetro {0}
introduced.variable.conflicts.with.variable.0=La variable introducida entrará en conflicto con la variable local {0}

########################################################################################################################
# Inline variable
########################################################################################################################
inline.variable.title=Variable en línea
variable.is.never.used.0=La variable ''{0}'' nunca se usa
field.is.never.used.0=El campo ''{0}'' nunca se usa
wrong.element.to.inline=El signo de intercalación debe colocarse en el nombre del método Groovy o variable local
cannot.find.a.single.definition.to.inline.local.var=No se puede encontrar una única definición para la variable local en línea
cannot.find.a.single.definition.to.inline.field=No hay inicializador presente para el campo
inline.local.command=Variable en línea
local.varaible.is.lvalue=La variable que se va a insertar tiene una ocurrencia como lvalue en la asignación
inline.local.variable.prompt.0.1=Variable local en línea ''{0}''?

########################################################################################################################
# Extract method
########################################################################################################################
extract.method.title=Método de extracción
selected.block.should.represent.a.statement.set=El bloque seleccionado debe representar un conjunto de declaraciones o una expresión
multiple.output.values=Hay varios valores de salida para el fragmento de código seleccionado
selected.block.contains.invocation.of.another.class.constructor=El bloque seleccionado contiene la invocación de otro constructor de clase
specify.type.label=Especificar retorno y tipo explícitamente
name.label=&Nombre:
signature.preview.border.title=Vista previa de la firma
parameters.border.title=Parámetros
visibility.border.title=Visibilidad
method.border.title=Método
visibility.private=Privado
visibility.public=Público
visibility.protected=Protegido
row.move.up=Subir
row.move.down=Mover hacia abajo
method.is.already.defined.in.class=El método {0} ya está definido en la clase {1}.
method.is.already.defined.in.script=El método {0} ya está definido en el script {1}.

########################################################################################################################
# Inline method
########################################################################################################################
inline.refactoring.title=En línea
inline.method.title=Método en línea
inline.method.border.title=Inline
inline.method.label=Método {0}
all.invocations.and.remove.the.method=Inline &all invocations y elimine el método
all.invocations.in.project=Inline y todas las invocaciones en el proyecto
this.invocation.only.and.keep.the.method=Inline &this invocation only and keep the method
refactoring.cannot.be.applied.to.abstract.methods=La refactorización no se puede aplicar a métodos abstractos
refactoring.cannot.be.applied.no.sources.attached=No se puede aplicar la refactorización: no se adjuntan fuentes
refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=No se admite la refactorización cuando la declaración de retorno interrumpe el flujo de ejecución
refactoring.is.not.supported.for.recursive.methods=La refactorización no es compatible con métodos recursivos
refactoring.cannot.be.applied.to.constructors=La refactorización no se puede aplicar a constructores
refactoring.is.not.supported.in.parameter.initializers=La refactorización no es compatible con inicializadores de parámetros
inline.method.prompt.0=¿Invocación del método en línea ''{0}''?
refactoring.is.available.only.for.method.calls=La refactorización está disponible solo para llamadas a métodos
method.is.not.accessible.form.context.0=El método {0} utilizado en el método en línea no es accesible desde el sitio de llamada
field.is.not.accessible.form.context.0=El campo {0} utilizado en el método en línea no es accesible desde el sitio de llamada
super.reference.is.used=La super llamada utilizada en el método inline no será válida después de inline.

########################################################################################################################
# Inline method
########################################################################################################################
variable.conflicts.with.parameter.0=El nombre elegido entra en conflicto con el parámetro {0}
variable.conflicts.with.variable.0=El nombre elegido entrará en conflicto con la variable local {0}
variable.conflicts.with.field.0=El nombre elegido entrará en conflicto con el campo {0}

########################################################################################################################
# Introduce Parameter
########################################################################################################################
introduce.parameter.title=Introducir parámetro
groovy.does.not.support.inner.classes.but.it.is.used.in.parameter.initializer=Groovy no admite clases internas pero se usa en el inicializador de parámetros.
groovy.does.not.support.anonymous.classes.but.it.is.used.in.parameter.initializer=Groovy no admite clases anónimas pero se usa en el inicializador de parámetros.
error.wrong.caret.position.method.name=El signo de intercalación debe colocarse en el nombre del método que se va a refactorizar.

########################################################################################################################
# Change signature
########################################################################################################################
changeSignature.refactoring.name=Cambiar firma
column.name.type=Tipo
column.name.name=Nombre
column.name.default.initializer=Inicializador
column.name.default.value=Valor predeterminado
method.duplicate=El método con la firma {0} ya está definido en {1}
replace.setter.for.property=Se sobrescribirá el configurador predeterminado de la propiedad ''{0}''
replace.getter.for.property=Se sobrescribirá el captador predeterminado para la propiedad ''{0}''
name.is.wrong=El nombre ''{0}'' es incorrecto
incorrect.data=Datos incorrectos
return.type.is.wrong=El tipo de retorno es incorrecto
type.for.parameter.is.incorrect=El tipo de parámetro ''{0}'' es incorrecto
specify.default.value=Especifique el valor predeterminado o inicializador para el parámetro ''{0}''
changing.signature.of.0=Cambiando la firma de {0}
refactored.method.will.cover.closure.property=El método refactorado anulará la propiedad de cierre ''{0}'' en {1}
changeSignature.not.throwable.type=Tipo incorrecto: ''{0}'' para la excepción, debería extender java.lang.Throwable
changeSignature.wrong.type.for.exception=Tipo incorrecto: ''{0}'' para excepción
changeSignature.no.type.for.exception=Especifique un tipo para la excepción
no.occurrences.found=No se encontraron ocurrencias
expression.is.not.constant=La expresión seleccionada no es una constante
class.does.not.exists=La clase {0} no existe
class.does.not.exist.in.the.module=La clase no existe en el módulo. ¿Quieres crearlo?
closure.uses.external.variables=El cierre usa variables externas no constantes
expression.invokes.not.static.methods=La expresión no invoca métodos estáticos
class.language.is.not.groovy=El lenguaje de la clase de destino no es Groovy
implicit.getter.will.by.overriden.by.method=El método {1} anulará el captador implícito de la propiedad {0}
implicit.setter.will.by.overriden.by.method=El setter implícito de la propiedad {0} será anulado por el método {1}
usage.of.field.will.be.overriden.by.method=El método {0} anulará el uso del campo
usage.will.be.overriden.by.method=El método {1} anulará el uso {0}
target.class.is.not.specified=La clase de destino no está especificada
is.not.class.name=''{0}'' no es un nombre de clase
target.class.must.not.be.script=La clase de destino no debe ser un script
rename.is.not.applicable.to.implicit.elements=No se puede cambiar el nombre de los elementos implícitos
rename.member=Renombrar {0}
rename.property=Cambiar el nombre de la propiedad ''{0}''
cannot.introduce.field.in.script=No hay ninguna clase en el alcance
cannot.introduce.field.in.interface=No se puede introducir un campo en la interfaz
expression.contains.errors=La expresión contiene errores
field.0.is.already.defined=El campo {0} ya está definido
access.to.created.field.0.will.be.overriden.by.method.1=El acceso al campo {0} será anulado por {1}
final.field.cant.be.initialized.in.cur.method=El campo final no se puede inicializar en el método actual
Field.cannot.be.final.because.replaced.variable.has.lhs.usages=La variable seleccionada se usa para escribir
field.cannot.be.initialized.in.field.declaration=El campo no se puede inicializar en la declaración
field.cannot.be.initialized.in.constructor(s)=El campo no se puede inicializar en constructor (s)
selected.variable.is.used.for.write=La variable seleccionada se usa para escribir
there.is.no.method.or.closure=No hay método de contención o cierre
remove.parameter.0.no.longer.used=Eliminar el parámetro ''{0}'' ya no se usa
convert.to.java.refactoring.name=Convertir a Java
convert.to.java.can.work.only.with.groovy=La refactorización de Convertir a Java funciona solo con archivos Groovy
files.to.be.converted=Archivos a convertir
converting.files.to.java=Conversión de archivos a Java
convert.to.static.refactoring.name=Convertir a @CompileStatic
convert.to.static.can.work.only.with.groovy=Convertir a @Compile La refactorización estática solo funciona con archivos Groovy
converting.files.to.static=Conversión de archivos a @CompileStatic
intention.converting.to.static=Aplicar convertir a @CompileStatic
intention.converting.to.static.family=Convertir a @CompileStatic
rename.groovy.property=Cambiar el nombre de la propiedad &Groovy
change.usages.of.var=¿Cambiar usos de la variable ''{0}''?
reference.to.accessor.0.is.used=La referencia al descriptor de acceso <bold>{0}<bold> no se puede incluir.
variable.is.accessed.for.writing=Se accede a la variable ''{0}'' para escribir
introduce.closure.parameter.elements.header=Añadiendo parámetro a un cierre
extract.closure.title=Extraer cierre
cannot.process.usage.in.language.{0}=No se puede procesar el uso en {0}
you.cannot.pass.as.parameter.0.because.you.remove.1.from.base.method=No puede pasar ''{0}'' como parámetro porque elimina el parámetro ''{1}'' asociado con él del método. Debe anular la selección de "Eliminar parámetro ''{0}'' ya no se utiliza" o anular la selección del parámetro ''{1}'' en la tabla de parámetros.
rename.groovy.implicit.closure.parameter=Cambiar el nombre del parámetro de cierre implícito
rename.implicit.closure.parameter.to=Cambiar el nombre del parámetro de cierre implícito a\:
implicit.closure.parameter=Parámetro de cierre implícito
selected.expression.should.not.be.lvalue=La expresión seleccionada no debe estar en el lado izquierdo de la asignación
column.name.use.any.var=Use cualquier var
rename.groovy.method=Cambiar el nombre del método Groovy
cannot.inline.0.=No se puede insertar {0}
ref.0.will.not.be.resolved.outside.of.current.context=La referencia ''{0}'' no se resolverá fuera del contexto actual
cannot.rename.property.0=No se puede cambiar el nombre de la propiedad <bold>''{0}''</bold> que anula el método <bold> ''{1}''</bold>
cannot.inline.reference.0=No se puede hacer referencia en línea ''{0}''
cannot.rename.script.class.to.0=No se puede cambiar el nombre de la clase de script ''{0}'' a ''{1}''
