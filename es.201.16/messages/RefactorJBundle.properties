add.property=Agregar propiedad
add.property.dialog.title=Agregar propiedad a {0}
property.name.field.label=Nombre de la propiedad\:
property.type.field.label=Tipo de propiedad\:
create.property.getter.checkbox=Crear captador de propiedad
create.property.setter.checkbox=Crear definidor de propiedades
add.property.to.constructors.checkbox=Agregar propiedades al constructor
make.property.final.checkbox=Crear propiedad final
initialization.expression.checkbox=Inicializar expresión (opcional)\:
cannot.perform.the.refactoring=No se puede realizar la refactorización.
refactor.j.is.not.licensed=Refactor-J no tiene licencia.
the.caret.should.be.positioned.in.the.class.to.add.to.property.to=El cursor debe colocarse en la clase donde desea agregar la propiedad.
class.to.be.add.property.to=Clase a la que agregar propiedades
constructor.calls.to.be.updated.view.descriptor=Llamada del constructor para actualizar {0}
unable.to.find.the.requested.class=No se pudo encontrar la clase solicitada.
no.class.found=Clase no encontrada.
search.for.class.text=Búsqueda de clase
search.for.class.family.name=Búsqueda de clase
add.global.library=Agregar dependencia de la biblioteca
global.library.source=Biblioteca global\: {0}
add.module.dependency=Agregar dependencias de módulos
module.source=Módulo\: {0}
project.library.source=Biblioteca de proyectos\: {0}
add.project.library=Agregar dependencia de la biblioteca
class.found.column.header=Clase encontrada
source.column.header=Salsa
action.column.header=Acción
class.search.results.title=Resultados de la búsqueda de clases
extract.class.title=Extraiga al delegado.
extract.class.from.label=Extraer delegador de {0}
name.for.new.class.label=Nuevo nombre de clase (&N)\:
choose.destination.package.label=Seleccionar paquete de destino
package.for.new.class.label=&Nombre del paquete\:
name.for.wrapper.class.label=Nombre de la clase\:
package.for.wrapper.class.label=Nombre del paquete\:
members.to.extract.label=Miembros a extraer (&B)
generate.array.access.methods.title=Seleccione un miembro para crear un método de acceso a la matriz
generate.collection.access.methods.title=Seleccione el miembro para el que desea crear un método de acceso a la colección.
generate.array.methods.undo.string=Crear método de matriz
generate.collection.methods.undo.string=Crear método de colección
there.already.exists.a.class.with.the.chosen.name=Ya existe una clase con el nombre que seleccionaste.
introduce.parameter.object=Introducción a los objetos de parámetros
introduce.type.parameter=Insertar parámetro de tipo
the.caret.should.be.positioned.at.on.a.type.to.be.parameterized=El cursor debe colocarse sobre el tipo a parametrizar.
type.selected.is.not.in.class.context=El tipo seleccionado no existe en el contexto de la clase.
type.parameters.can.not.be.introduced.as.type.parameters=Los parámetros de tipo no se pueden insertar como parámetros de tipo.
primitive.types.can.not.be.introduced.as.type.parameters=Los tipos base no se pueden insertar como parámetros de tipo.
conflicts.found=Conflicto encontrado
there.are.non.genericizable.instances.of.the.type.you.selected=Algunas instancias del tipo seleccionado no se pueden generalizar.\n
do.you.wish.to.continue=¿Quieres continuar?
introduce.type.parameter.title=Insertar parámetro de tipo
name.for.new.type.parameter.label=Nuevo nombre de parámetro de tipo\:
the.caret.should.be.positioned.within.a.class.to.be.refactored=El cursor debe estar ubicado dentro de la clase que se va a refactorizar.
push.javadoc.down=Mover Javadoc hacia abajo
the.selected.class.is.an.enumeration=La clase que seleccionó es una enumeración.
the.selected.class.has.no.overridden.methods.with.javadoc=La clase seleccionada no tiene ningún método anulado en el javadoc.
push.javadoc.down.title=Mover Javadoc hacia abajo
replace.existing.comments.checkbox=Reemplazar anotación existente
use.inheritdoc.comments=Utilice la anotación @inheritdoc
push.javadoc.down.from.label=Mover Javadoc hacia abajo desde\:
methods.to.copy.javadoc.from=Método para copiar javadoc desde
remove.property=Quitar propiedad
the.caret.should.be.positioned.at.on.a.property.to.be.removed=El símbolo de intercalación debe colocarse en la propiedad a eliminar.
remove.property.getter.checkbox=Eliminar captador de propiedad
remove.property.setter.checkbox=Quitar definidor de propiedades
remove.property.title=Quitar propiedad
remove.property.border=Eliminar propiedad {0}
replacement.expression.label=Reemplazar expresión (opcional)\:
remove.middleman=Eliminar intermediario
the.caret.should.be.positioned.at.the.name.of.the.field.to.be.refactored=El cursor debe colocarse en el nombre del campo que se va a refactorizar.
field.selected.is.not.used.as.a.delegate=El campo seleccionado no se utilizará como delegado.
wrap.return.value=Salto de línea del valor de retorno
the.caret.should.be.positioned.at.the.name.of.the.method.to.be.refactored=El símbolo de intercalación debe colocarse dentro del nombre del método que se va a refactorizar, dentro de la lista de parámetros o dentro de la llamada al método.
method.selected.returns.void=El método seleccionado devuelve 'nulo'.
constructor.returns.can.not.be.wrapped=Las devoluciones del constructor no se pueden empaquetar.
wrap.return.value.title=Salto de línea del valor de retorno
the.caret.should.be.positioned.at.an.annotation.to.be.refactored.to.be.refactored=El cursor debe estar ubicado en la anotación que se va a refactorizar.
pull.annotation.up=Subir anotación
pull.annotation.up.title=Subir anotación
replace.existing.annotations.checkbox=Reemplazar anotaciones existentes
pull.up.annotation.from.label=Mover la anotación hacia arriba desde {0}\:
pull.javadoc.up.title=Mover Javadoc hacia arriba
pull.up.javadoc.from.label=Mueva el javadoc de {0} hasta\:
methods.to.pull.up.javadoc.from.panel=Método para subir javadoc desde:
remove.type.parameter=Eliminar parámetro de tipo
the.caret.should.be.positioned.at.the.name.of.the.type.parameter.to.be.refactored=El cursor debe colocarse en el nombre del parámetro de tipo que se va a refactorizar.
type.parameter.selected.extends.multiple.types=El parámetro de tipo seleccionado abarca varios tipos.
type.parameter.question.label=¿Está seguro de que desea eliminar el parámetro de tipo {0} y todos los usos asociados?
method.to.wrap.returns.from.label=El método cuya devolución desea envolver\:
method.whose.return.are.to.wrapped=Método para envolver la devolución interna
references.to.be.modified.usage.view=Referencia para modificar {0}
reference=Referencia
type.parameter.to.be.remove=Escriba el parámetro a eliminar
references.to.be.changed.usage.view=Referencia para cambiar {0}
references.to.be.made.removed.usage.view=La referencia que se va a crear ha eliminado {0}.
property.to.be.removed=Propiedades para eliminar
remove.middleman.field.header=Eliminar campo intermediario\:
references.to.expose.usage.view=Referencias para exponer {0}
retain.all.delegating.methods.radio.button=Preservar todos los métodos delegados
remove.middleman.title=Eliminar intermediario
delete.all.delegating.methods.radio.button=Eliminar todos los métodos delegados
field.label=Campo {0}
delete.delegating.methods.border=Eliminar método delegado
make.class.inner.title=Hacer de una clase una clase interna
make.class.an.inner.class.border=Hacer de la clase {0} una clase interna
outer.class.label=Clase externa\:
choose.destination.class.label=Seleccionar clase objetivo
add.property.command=Agregue la propiedad {0} a {1}
refactor=Refactorización
preview=Avance
wrapped.return.command.name=\ return envuelto en {0} para {1}{2}{3}()
split.loop.text=División de bucle
split.loop.family.name=División de bucle
removed.type.parameter.from.class.command.name=Escriba el parámetro {0} eliminado de la clase {1}
removed.type.parameter.from.method.command.name=Escriba el parámetro {0} eliminado del método {1}()
remove.property.command.name=Eliminar propiedad {0}
exposed.delegation.command.name=Delegador expuesto a {0}{1}{2}
push.up.javadoc.command.name=Mover Javadoc hacia arriba
javadoced.class=Clase generada a partir de Javadoc
superclass.methods.to.be.javadoced=Clase principal generada a partir de Javadoc
push.annotation.down=Bajar anotaciones
0.refactor.j.is.not.licensed={0}Refactor-J no tiene licencia.
0.the.caret.should.be.positioned.at.an.annotation.to.be.refactored.to.be.refactored=El {0}carácter debe estar ubicado en la anotación que se va a refactorizar.
push.down.annotation.command.name=Bajar anotaciones
annotation=Anotación
subclass.elements.to.be.annotated=Elementos de subclase para anotar
push.annotation.down.title=Bajar anotaciones
pull.up.annotation.command.name=Subir anotación
superclass.elements.to.be.annotated=Elemento de clase principal para anotar
pull.javadoc.up=Mover Javadoc hacia arriba
pull.up.javadoc.command.name=Mover Javadoc hacia arriba
merge.loops.text=Fusión de bucle
merge.loops.family.name=Fusión de bucle
make.class.inner=Hacer de una clase una clase interna
the.caret.should.be.positioned.at.on.a.class.to.be.made.into.an.inner.class=El símbolo de intercalación debe colocarse en la clase que se creará como clase interna.
only.outer.classes.and.static.inner.classes.may.be.made.inner=Solo se pueden crear clases externas y clases internas estáticas como clases internas.
a.class.can.not.be.made.an.inner.class.of.itself=Una clase no puede crearse como una clase interna de sí misma.
a.class.can.not.be.made.an.inner.class.of.one.of.it.s.decendents=No se puede crear una clase como clase interna de una subclase.
make.class.inner.command.name=Mover la clase {0} dentro de la clase {1}
invert.boolean=Inversión booleana
the.caret.should.be.positioned.at.the.name.of.the.variable.or.parameter.to.be.refactored=El símbolo de intercalación debe colocarse en el nombre de la variable o parámetro que se va a refactorizar.
variable.selected.is.not.boolean=La variable que seleccionó no es booleana.
invert.boolean.title=Inversión booleana
do.you.wish.to.invert.all.uses.of.variable=¿Quiere invertir todos los usos de la variable {0}?
parameter.selected.is.not.boolean=El parámetro seleccionado no es booleano.
do.you.wish.to.invert.all.uses.of.parameter=¿Quiere invertir todos los usos del parámetro {0}?
invert.parameter.command.name=Invertido {0}({1})
invert.variable.command.name=Invertido
variable.to.be.inverted=Variable para invertir
references.to.be.inverted.0=Referencia a invertir {0}
parameterize.class.radio.button=Clase parametrizada {0}
parameterize.method.radio.button=Método parametrizado {0}()
genericize.uses.border={0} Generalización de uso
introduced.type.parameter.command.name=Escriba {0} insertado como parámetro en la clase {1}
type.parameter.to.be.introduced=Escriba el parámetro a insertar
class.references.to.be.made.inner=Haga referencia a la clase que desea convertir en una clase interna
references.to.be.made.inner.usage.view=Referencia {0} para crear como clase interna
control.flow.category=Flujo de control
other.category=Otros
genericize.uses.in.border=Generalizando el uso de {0} en {1}
extract.class=Extracción de clases
the.selected.class.is.an.interface=La clase que elijas es una interfaz.
the.selected.class.is.an.annotation.type=La clase seleccionada es un tipo de anotación.
the.refactoring.is.not.supported.on.non.static.inner.classes=La refactorización no se admite en clases internas no "estáticas".
the.selected.class.has.no.members.to.extract=La clase seleccionada no tiene miembros para extraer.
references.to.extract=Referencias para extraer
extracting.from.class=Extracto de clase\:
extracted.class.command.name=Clase extraída {0}
method.to.extract.parameters.from.label=Método para extraer parámetros de
name.for.new.parameter.label=Nuevo nombre de parámetro\:
method.selected.has.no.parameters=El método seleccionado no tiene parámetros.
parameters.to.extract.border=Parámetros a extraer
parameter=Parámetro
your.evaluation.license.for.refactor.j.will.expire.in.less.than.n.days=Quedan {0} días hasta que caduque su licencia de evaluación de Refactor-J.\n
refactor.j.licensed.to=Refactor-J\ con licencia de:
can.only.pull.annotations.up.on.methods.parameters.and.classes=Puede subir anotaciones solo en métodos, parámetros y clases.
can.not.find.any.available.superclasses.for.the.selected.class=No se encontraron clases para padres disponibles para la clase seleccionada.
can.not.find.any.available.super.methods.for.the.selected.method=No se pudo encontrar un método principal disponible para el método seleccionado.
can.only.push.annotations.down.on.methods.parameters.and.classes=Puede mover anotaciones hacia abajo solo en métodos, parámetros y clases.
can.not.find.any.available.subclasses.for.the.selected.class=No se encontraron subclases disponibles para la clase seleccionada.
can.not.find.any.available.overriding.methods.for.the.selected.method=No se encontraron métodos de anulación disponibles para el método seleccionado.
delete.selected.annotation.checkbox=Eliminar anotación seleccionada
push.annotation.down.from.label=Mueve la anotación hacia abajo desde\:
there.already.exists.an.incompatible.class.with.the.chosen.name=Ya existe una clase incompatible con el nombre seleccionado.
weaken.type=Tipo Debilitamiento
weaken.type.label=Debilitar el tipo ''{0}'' de {1} a\:
weaken.type.command.name=Tipo debilitamiento
weaken.type.refactoring.is.not.supported.for.primitive.types=El debilitamiento de la refactorización de tipos no se admite para tipos primitivos.
weaken.type.refactoring.is.not.supported.for.arrays=El debilitamiento de la refactorización de tipos no es compatible con las matrices.
weaken.type.refactoring.is.not.supported.for.type.parameters=No se admite el debilitamiento de la refactorización de tipos para los parámetros de tipo.
invalid.type.for.weaken.type.refactoring=Tipo no válido para el debilitamiento de la refactorización de tipos
weaken.type.refactoring.is.not.supported.for.constructors=Los constructores no admiten el debilitamiento de la refactorización de tipos.
the.selected.type.cannot.be.weakened=El tipo seleccionado no se puede debilitar.
the.selected.type.cannot.be.weakened.because.the.method.is.declared.in.a.non.project.class=Dado que el método se declara en una clase que no es de proyecto, el tipo seleccionado no se puede debilitar.
the.selected.method.cannot.be.wrapped.because.it.is.defined.in.a.non.project.class=El método seleccionado no se puede empaquetar porque está declarado en una clase que no pertenece al proyecto.
existing.wrapper.class.label=Usar una clase de parámetro existente
select.wrapper.class=Seleccionar clase de parámetro
could.not.find.selected.wrapping.class=No se pudo encontrar la clase de envoltura que seleccionó.
there.already.exists.a.class.with.the.selected.name=Ya existe una clase con el nombre que seleccionaste.
pull.annotation.up.from.label=Mover la anotación hacia arriba desde \:
convert.equality.disjunction.to.set.contains=Convertir igualdad OR a Set.contains()
convert.to.set.contains=Convertir a Set.contains()
the.caret.should.be.positioned.at.the.name.of.the.variable.parameter.or.method.to.be.refactored=El símbolo de intercalación debe colocarse en la variable, parámetro o nombre del método que se va a refactorizar.
convert.to.String.format=Convertir a formato String.
convert.to.printf=Convertir a printf
convert.to.MessageFormat.format=Convertir a MessageFormat.format
split.string=División de cuerdas
copy.javadoc.to.inheritors=Copiar Javadoc al heredero
copy.javadoc.to.ancestors=Copiar Javadoc al elemento padre
