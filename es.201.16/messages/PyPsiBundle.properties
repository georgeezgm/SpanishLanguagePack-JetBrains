# Message we display for inspection if user uses custom class type members that do not exist
custom.type.mimic.name=Clase dinámica basada en {0}

### Refactorización

refactoring.extract.method.error.interrupted.execution.flow=No se puede realizar la refactorización cuando se interrumpe el flujo de ejecución
refactoring.extract.method.error.star.import=No se puede realizar la refactorización con la declaración de importación en estrella dentro del bloque de código
refactoring.extract.method.error.yield=No se puede realizar la refactorización con la declaración 'yield' dentro del bloque de código

### Anotadores ###
ANN.deleting.none=Eliminando ninguno
ANN.assign.to.none=Asignación a Ninguno
ANN.cant.assign.to.call=No se puede asignar a la llamada de función
ANN.cant.delete.call=No se puede eliminar la llamada a la función
ANN.cant.aug.assign.to.generator=No es posible la asignación aumentada a la expresión del generador
ANN.cant.aug.assign.to.tuple.or.generator=Asignación aumentada a literal de tupla o expresión generadora no posible
ANN.cant.assign.to.generator=Asignar a la expresión del generador no es posible
ANN.cant.assign.to.operator=No se puede asignar al operador
ANN.cant.assign.to.parens=No se puede asignar a()
ANN.cant.aug.assign.to.list.or.comprh=Asignación aumentada a literal de lista o no es posible la comprensión
ANN.cant.assign.to.comprh=No se puede asignar a la comprensión de la lista
ANN.cant.assign.to.dict.comprh=No se puede asignar a la comprensión de dict
ANN.cant.assign.to.set.comprh=No se puede asignar para establecer la comprensión
ANN.cant.aug.assign.to.comprh=Asignación aumentada a la comprensión de la lista no es posible
ANN.cant.aug.assign.to.dict.comprh=Asignación aumentada a comprensión de dictado no es posible
ANN.cant.aug.assign.to.set.comprh=No es posible la asignación aumentada para establecer la comprensión
ANN.cant.assign.to.literal=No se puede asignar a literal
ANN.cant.delete.literal=No se puede eliminar literal
ANN.cant.assign.to.lambda=No se puede asignar a lambda

ANN.break.outside.loop='break' fuera del bucle
ANN.continue.outside.loop='continue' fuera del bucle

ANN.$0.assigned.before.global.decl=El nombre ''{0}'' se asigna antes de la declaración global

ANN.duplicate.param.name=nombre de parámetro duplicado
ANN.starred.param.after.kwparam=* parámetro después de ** parámetro
ANN.regular.param.after.vararg=parámetro regular después de * parámetro
ANN.regular.param.after.keyword=parámetro regular después de ** parámetro
ANN.non.default.param.after.default=el parámetro no predeterminado sigue al parámetro predeterminado
ANN.named.parameters.after.star=los parámetros con nombre deben seguir al desnudo *
ANN.named.parameters.before.slash=los parámetros con nombre deben preceder a bare /
ANN.tuple.py3=??el desempaquetado del parámetro tuple no es compatible con Python 3
ANN.multiple.args=varios * parámetros no están permitidos
ANN.multiple.kwargs=múltiples ** parámetros no están permitidos
ANN.multiple.slash=no se permiten varios/parámetros
ANN.slash.param.after.vararg=/ parámetro debe preceder * parámetro
ANN.slash.param.after.keyword=/ parámetro debe preceder ** parámetro

ANN.star.import.at.top.only='importar *' solo se permite a nivel de módulo

ANN.missing.closing.quote=Falta la comilla de cierre [{0}]
ANN.missing.closing.triple.quotes=Faltan comillas triples de cierre

ANN.method.$0.removed.use.$1=El método ''{0}'' ha sido eliminado, use ''{1}'' en su lugar
ANN.method.$0.removed=Método ''{0}'' eliminado

### análisis
PARSE.expected.expression=expresión esperada
PARSE.expected.rbracket=Se esperaba ']'
PARSE.expected.expr.or.comma.or.bracket=expresión esperada, ',' o ']'
PARSE.expected.in=Se esperaba 'in'
PARSE.expected.for.or.bracket=Se esperaba ']' o 'for'
PARSE.expected.comma=Se esperaba ','
PARSE.expected.colon=Se esperaba ':'
PARSE.expected.rpar=Se esperaba ')'
PARSE.expected.lpar=Se esperaba '('
PARSE.expected.rbrace=Se esperaba '}'
PARSE.expected.tick=Se esperaba '`' (comilla invertida)
PARSE.expected.name=nombre esperado
PARSE.expected.colon.or.rbracket=Se esperaba ':' o ']'
PARSE.expected.comma.or.rpar=Se esperaba ',' o ')'
PARSE.expected.else=Se esperaba 'else'

PARSE.expected.identifier=Identificador esperado
PARSE.expected.comma.lpar.rpar=Se esperaba ',' o '(' o ')'
PARSE.expected.statement.break=Se espera una interrupción de la declaración
PARSE.expected.@.or.def=Se esperaba '@' o 'def'
PARSE.expected.formal.param.name=nombre de parámetro formal esperado
PARSE.0.expected=Se esperaba {0}
PARSE.expected.ellipsis=Se esperaba '...'

statement.expected.found.0=Se esperaba una declaración, se encontró {0}
unexpected.indent=sangría inesperada
unindent.does.not.match.any.outer.indent=Unindent no coincide con ningún nivel de sangría exterior
except.or.finally.expected=Se esperaba 'except' o 'finally'
expected.statement=Declaración esperada
dedent.expected=Dedent esperado
indent.expected=Se esperaba Sangría
indented.block.expected=Se espera un bloque con sangría
cannot.assign.to.yield.expression=No se puede asignar a la expresión 'yield'
end.of.statement.expected=Fin de la declaración esperado
import.expected=Se esperaba 'import'
def.or.with.or.for.expected=Se esperaba 'def' o 'with' o 'for'
rbracket.or.comma.expected=Se esperaba ']' o ','
unexpected.expression.syntax=Sintaxis de expresión inesperada
tuple.expression.expected=expresión de tupla esperada
value.expression.expected=expresión de valor esperada
unexpected.expression.part=parte de expresión inesperada
unexpected.f.string.token=token de cadena f inesperado
can.t.assign.to.await.expression=No se puede asignar a una expresión en await
for.expected=Se esperaba 'for'
rarrow.expected=Se esperaba '->'
unexpected.tokens=tokens inesperados

PARSE.function.type.annotations.py2=Las anotaciones de tipo no son compatibles con Python 2
PARSE.function.return.type.annotations.py2=Las anotaciones de tipo de retorno no son compatibles con Python 2

PARSE.console.multiline.magic.warn=La magia multilínea no se puede usar como expresión
PARSE.console.identifier.expected=Identificador esperado.
PARSE.console.help.request.warn=Las solicitudes de ayuda deben seguir su nombre.

### generador de documentos rápido
QDOC.module.path.unknown=(Se desconoce la ruta del módulo)
QDOC.epydoc.python2.sdk.not.found=Necesita configurar Python 2 SDK para renderizar <a href='http://epydoc.sourceforge.net/'> Epydoc </a> docstrings
QDOC.local.sdk.not.found=Necesita un SDK de Python local configurado para renderizar cadenas de documentos.
QDOC.assigned.to=Asignado a:
QDOC.documentation.is.copied.from=La documentación se copia de:
QDOC.accessor.kind=Tipo de acceso:
QDOC.raises=Aumentos:
QDOC.keyword.args=Argumentos de palabras clave:
QDOC.returns=Devoluciones:
QDOC.params=Parámetro:

### Formateador
formatter.panel.dict.alignment.do.not.align=No alinear
formatter.panel.dict.alignment.align.on.colon=Alinear en dos puntos
formatter.panel.dict.alignment.align.on.value=Alinear en valor

### Arreglos rápidos ###
QFIX.auto.import.family=Importar
QFIX.auto.import.import.this.name=Importar este nombre
QFIX.auto.import.import.name=Importar ''{0}''
QFIX.local.auto.import.family=Importar localmente
QFIX.local.auto.import.import.locally={0} localmente

QFIX.add.field.to.class=Agregar campo a la clase
QFIX.added.constructor.$0.for.field.$1=Se agregó un __init__a la clase <code>{0}</code><br/>para acomodar el nuevo campo <code>{1}</code>
QFIX.NAME.remove.parameter=Eliminar parámetro
QFIX.rename.parameter.to.$0=Renombrar a ''{0}''
QFIX.NAME.add.field.$0.to.class.$1=Agregar campo ''{0}'' a la clase {1}
QFIX.NAME.remove.statement=Eliminar declaración
QFIX.failed.to.add.field=<br/>¡Error al agregar un campo!<br/><br/>
QFIX.redundant.parentheses=Eliminar paréntesis redundantes
QFIX.simplify.boolean.expression=Simplificar expresión booleana
QFIX.simplify.$0=Reemplazar expresión booleana con ''{0}''
QFIX.chained.comparison=Simplifique la comparación encadenada

#PyDefaultArgumentQuickFix
QFIX.default.argument=Reemplazar el argumento predeterminado mutable

# Acciones y comandos asociados
ACT.CMD.use.import=Usar un módulo importado
ACT.qualify.with.module=Calificar con un módulo importado
ACT.from.some.module.import=Importar desde...

python.docstring.file.type=python docstring
python.function.type.annotation.file.type.description=Comentario del tipo de función Python PEP-484

INSP.GROUP.python=Python

# PyUnusedLocalInspection
INSP.NAME.unused=Local no utilizado
INSP.unused.locals.parameter.isnot.used=El valor del parámetro ''{0}'' no se utiliza
INSP.unused.locals.local.variable.isnot.used=El valor de la variable local ''{0}'' no se utiliza
INSP.unused.locals.replace.with.wildcard=Reemplazar con _
INSP.unused.locals.local.function.isnot.used=La función local ''{0}'' no se utiliza
INSP.unused.locals.local.class.isnot.used=La clase local ''{0}'' no se usa

INSP.unused.locals.ignore.variables.starting.with=Ignorar las variables que comienzan con '_'
INSP.unused.locals.ignore.range.iteration.variables=Ignorar variables de iteración de rango
INSP.unused.locals.ignore.lambda.parameters=Ignorar los parámetros lambda
INSP.unused.locals.ignore.variables.used.in.tuple.unpacking=Ignorar las variables utilizadas en el desempaquetado de tuplas

# PyUnresolvedReferencesInspection
INSP.NAME.unresolved.refs=Referencias no resueltas
INSP.module.$0.not.found=Módulo ''{0}'' no encontrado
INSP.unresolved.ref.$0=Referencia no resuelta ''{0}''
INSP.unresolved.ref.$0.for.class.$1=Referencia de atributo no resuelto ''{0}'' para la clase ''{1}''
INSP.cannot.find.$0.in.$1=No se puede encontrar la referencia ''{0}'' en ''{1}''
INSP.unresolved.operator.ref=La clase ''{0}'' no define ''{1}'', por lo que el operador ''{2}'' no se puede utilizar en sus instancias
python.stub=Código auxiliar de Python

# PyRedundantParenthesesInspection
INSP.NAME.redundant.parentheses=Paréntesis redundantes
INSP.redundant.parens.ignore.empty.lists.of.base.classes=Ignorar listas vacías de clases base
INSP.redundant.parens.ignore.tuples=Ignorar tuplas
INSP.redundant.parens.ignore.argument.of.operator=Ignorar el argumento del operador %

# PySimplifyBooleanCheckInspection
INSP.NAME.check.can.be.simplified=La verificación de variables booleanas se puede simplificar
INSP.expression.can.be.simplified=La expresión se puede simplificar
INSP.simplify.boolean.check.ignore.comparison.to.zero=Ignorar comparación a cero




find.usages.unnamed=<sin nombre>
find.usages.keyword.argument=argumento de palabra clave
find.usages.variable=variable
find.usages.imported.module.alias=alias del módulo importado
find.usages.class=clase
find.usages.function=función
find.usages.method=método
find.usages.parameter=parámetro

python.find.usages=Buscar usos
python.find.usages.base.method.question=El método {0} anula el método de la clase {1}.\n¿Desea encontrar usos del método base?
python.find.usages.usage.in.superclass.list=Uso en la lista de superclase
python.find.usages.usage.in.isinstance=Uso en isinstance()
python.find.usages.untyped.probable.usage=Uso sin tipo (probable)
python.find.usages.usage.in.import.statement=Uso en declaración de importación
