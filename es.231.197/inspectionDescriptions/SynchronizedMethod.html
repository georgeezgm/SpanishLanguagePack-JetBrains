<html>
<body>
메서드에 사용된 <code>synchronized</code> 제어자를 보고합니다.
<p>
  메서드에 <code>synchronized</code> 제어자를 사용하는 것이 좋지 않은 이유로는 다음과 같은 몇 가지가 있습니다.
</p>
<ol>
  <li>
    잠금 상태에서는 최대한 적은 작업이 수행되어야 합니다. 그러므로 보통 <code>synchronized</code> 블록을 사용하여 공유 상태에서 작동하는 코드만 유지하는 것이 더 낫습니다.
  </li>
  <li>
    동기화는 메서드의 인터페이스의 일부가 됩니다. 다른 잠금 메커니즘으로의 전환이 어려워집니다.
  </li>
  <li>
    무엇이 특정 객체를 잠그고 있는지 추적하기가 힘들어집니다.
  </li>
  <li>
    DoS(서비스 거부) 공격은 메서드의 클래스를 상속받을 때 의도적으로 또는 자신도 모르게 실행이 가능해집니다.
  </li>
</ol>
<p>
  그 대신 액세스를 완전히 제어할 수 있는 <code>private final</code> lock 객체에서 동기화를 고려할 수 있습니다.
</p>
<p><code>synchronized(this)</code>으로 메서드 본문을 래핑하는 빠른 수정이 제공됩니다.</p>
<p><b>예:</b></p>
<pre><code>
  class Main {
    public synchronized void fooBar() {
    }
  }
</code></pre>
<p>빠른 수정 적용 후:</p>
<pre><code>
  class Main {
    public void fooBar() {
      synchronized (this) {
      }
    }
  }
</code></pre>

<!-- tooltip end -->
<p>이 검사에서 다음 옵션을 구성할 수 있습니다.</p>
<ol>
  <li><strong>네이티브 메서드 포함</strong>- 네이티브 메서드를 검사의 범위로 포함합니다.</li>
  <li><strong>동기화된 메서드를 재정의하는 메서드 무시</strong> - <code>synchronized</code> 메서드를 재정의하는 메서드를 보고하지 않습니다.</li>
</ol>

</body>
</html>