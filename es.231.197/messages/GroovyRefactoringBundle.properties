introduce.variable.title=변수 삽입
only.in.groovy.files=이 리팩터링은 Groovy 파일에서만 사용할 수 있습니다.
selected.block.should.represent.an.expression=선택한 블록이 표현식을 나타내야 합니다
refactoring.is.not.supported.in.the.current.context=리팩터링이 현재 컨텍스트에서 지원되지 않습니다.
refactoring.is.not.supported.in.method.parameters=리팩터링이 클로저 또는 메서드 매개변수에서 지원되지 않습니다.
declare.final.checkbox=final 선언(&F)
press.escape.to.remove.the.highlighting=강조 표시를 제거하려면 ESC를 누릅니다
selected.expression.has.void.type=선택한 표현식에 void 타입이 있습니다
introduced.variable.conflicts.with.parameter.0=삽입된 변수가 매개변수 {0}와(과) 충돌합니다.
introduced.variable.conflicts.with.variable.0=삽입된 변수가 지역 변수 {0}와(과) 충돌합니다.
cannot.find.a.single.definition.to.inline.local.var=지역 변수를 인라인화할 단일 정의를 찾을 수 없습니다.
cannot.find.a.single.definition.to.inline.field=해당 필드에 대한 이니셜라이저가 없습니다
local.variable.is.lvalue=인라인화할 변수가 대입의 lvalue로서 사용됩니다
inline.local.variable.prompt.0.1=지역 변수 ''{0}''을(를) 인라인화하시겠어요?
extract.method.title=메서드 추출
selected.block.should.represent.a.statement.set=선택한 블록은 구문 또는 표현식 세트를 나타내야 합니다.
multiple.output.values=선택한 코드 조각에 여러 출력 값이 있습니다.
selected.block.contains.invocation.of.another.class.constructor=선택한 블록에 다른 클래스 생성자의 호출이 포함되어 있습니다
specify.type.label=반환 타입을 명시적으로 지정(&T)
signature.preview.border.title=시그니처 미리보기
method.is.already.defined.in.class=메서드 {0}은(는) 클래스 {1}에 이미 정의되어 있습니다.
method.is.already.defined.in.script=메서드 {0}은(는) 스크립트 {1}에 이미 정의되어 있습니다.
inline.method.title=메서드 인라인화
inline.method.border.title=인라인화
inline.method.label=메서드 {0}
all.invocations.and.remove.the.method=모든 호출 인라인화 및 메서드 제거(&A)
all.invocations.in.project=프로젝트 내 모든 호출 인라인화(&A)
this.invocation.only.and.keep.the.method=이 호출만 인라인화 및 메서드 유지(&T)
refactoring.cannot.be.applied.to.abstract.methods=리팩터링은 추상 메서드에 적용할 수 없습니다.
refactoring.cannot.be.applied.no.sources.attached=연결된 소스가 없어 리팩터링을 적용할 수 없습니다.
refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=Return 문이 실행 흐름을 방해할 때 리팩터링이 지원되지 않습니다.
refactoring.cannot.be.applied.to.constructors=리팩터링은 생성자에 적용할 수 없습니다.
refactoring.is.not.supported.in.parameter.initializers=리팩터링이 매개변수 이니셜라이저에서 지원되지 않습니다.
refactoring.is.available.only.for.method.calls=리팩터링은 메서드 호출에서만 사용할 수 있습니다.
method.is.not.accessible.form.context.0=인라인화된 메서드에 사용되는 메서드 {0}은(는) 호출 사이트에서 액세스할 수 없습니다.
field.is.not.accessible.form.context.0=인라인화된 메서드에 사용되는 필드 {0}은(는) 호출 사이트에서 액세스할 수 없습니다.
super.reference.is.used=인라인화된 메서드에서 사용된 상위 호출은 인라인화 후에 유효하지 않게 됩니다.
variable.conflicts.with.parameter.0=선택한 이름이 매개변수 {0}와(과) 충돌합니다
variable.conflicts.with.variable.0=선택한 이름이 지역 변수 {0}와(과) 충돌합니다.
variable.conflicts.with.field.0=선택한 이름이 필드 {0}와(과) 충돌합니다.
error.wrong.caret.position.method.name=캐럿이 리팩터링할 메서드의 이름에 있어야 합니다
method.duplicate=시그니처 {0}이(가) 포함된 메서드는 {1}에 이미 정의되어 있습니다
replace.setter.for.property=프로퍼티 ''{0}''에 대한 디폴트 setter가 덮어쓰기됩니다.
replace.getter.for.property=프로퍼티 ''{0}''에 대한 디폴트 getter가 덮어쓰기됩니다
name.is.wrong=이름 ''{0}''이(가) 잘못되었습니다.
return.type.is.wrong=반환 타입이 잘못되었습니다.
type.for.parameter.is.incorrect=매개변수 ''{0}''의 타입이 잘못되었습니다.
specify.default.value=매개변수 ''{0}''에 대한 디폴트 값 또는 이니셜라이저 지정
refactored.method.will.cover.closure.property=리팩터링된 메서드가 {1} 내 클로저 프로퍼티 ''{0}''을(를) 재정의합니다.
changeSignature.not.throwable.type=잘못된 타입: 예외에 대한 ''{0}''이(가) java.lang.Throwable을 확장해야 합니다.
changeSignature.wrong.type.for.exception=잘못된 타입: 예외의 ''{0}''
changeSignature.no.type.for.exception=예외에 대한 타입을 지정해야 합니다.
no.occurrences.found=항목을 찾을 수 없습니다
class.does.not.exist.in.the.module=모듈에 클래스가 없습니다. 클래스를 생성하시겠어요?
closure.uses.external.variables=클로저가 상수가 아닌 외부 변수를 사용합니다.
class.language.is.not.groovy=타깃 클래스 언어가 Groovy가 아닙니다.
implicit.getter.will.by.overridden.by.method=메서드 {1}이(가) 프로퍼티 {0}의 묵시적 getter를 재정의합니다
implicit.setter.will.by.overridden.by.method=메서드 {1}이(가) 프로퍼티 {0}의 묵시적 setter를 재정의합니다
usage.will.be.overridden.by.method=메서드 {1}이(가) 사용 위치 {0}을(를) 재정의합니다
target.class.must.not.be.script=타깃 클래스는 스크립트여서는 안 됩니다.
rename.is.not.applicable.to.implicit.elements=묵시적 요소의 이름을 변경할 수 없습니다.
rename.member={0} 이름 변경
rename.property=프로퍼티 ''{0}''의 이름 변경
cannot.introduce.field.in.script=범위에 클래스가 없습니다.
cannot.introduce.field.in.interface=인터페이스에 필드를 삽입할 수 없습니다.
expression.contains.errors=표현식에 오류가 포함되어 있습니다.
field.0.is.already.defined=필드 {0}은(는) 이미 정의되어 있습니다.
access.to.created.field.0.will.be.overridden.by.method.1={1}이(가) 필드 {0}에 대한 액세스를 재정의합니다
final.field.cant.be.initialized.in.cur.method=최종 필드는 현재 메서드에서 초기화할 수 없습니다
Field.cannot.be.final.because.replaced.variable.has.lhs.usages=선택한 변수는 쓰기에 사용됩니다.
field.cannot.be.initialized.in.field.declaration=필드는 선언에서 초기화할 수 없습니다.
field.cannot.be.initialized.in.constructor(s)=필드는 생성자에서 초기화할 수 없습니다.
selected.variable.is.used.for.write=선택한 변수는 쓰기에 사용됩니다.
there.is.no.method.or.closure=포함된 메서드 또는 클로저가 없습니다.
remove.parameter.0.no.longer.used=곧 사용할 수 없게 될 매개변수 ''{0}'' 제거
convert.to.java.refactoring.name=Java로 변환
convert.to.java.can.work.only.with.groovy=Java로 변환 리팩터링은 Groovy 파일에서만 작동합니다.
files.to.be.converted=변환할 파일
converting.files.to.java=파일을 Java로 변환 중
converting.files.to.static=파일을 @CompileStatic으로 변환 중
intention.converting.to.static=@CompileStatic으로 변환 적용
intention.converting.to.static.family=@CompileStatic으로 변환
rename.groovy.property=Groovy 프로퍼티 이름 변경(&G)
reference.to.accessor.0.is.used=접근자 <bold>{0}<bold>에 대한 참조는 인라인화할 수 없습니다.
variable.is.accessed.for.writing=변수 ''{0}''은(는) 쓰기용으로 액세스됩니다
introduce.closure.parameter.elements.header=클로저에 매개변수 추가 중
cannot.process.usage.in.language.{0}={0} 내 사용 위치를 처리할 수 없습니다.
you.cannot.pass.as.parameter.0.because.you.remove.1.from.base.method=메서드에서 관련 매개변수 ''{1}''을(를) 제거하므로 ''{0}''을(를) 매개변수로 전달할 수 없습니다. "이제 사용되지 않는 매개변수 ''{0}''을(를) 제거"를 선택 해제하거나 매개변수 테이블에서 매개변수 ''{1}''을(를) 선택 해제해야 합니다.
selected.expression.should.not.be.lvalue=선택한 표현식이 대입의 왼쪽에 있어서는 안 됩니다.
cannot.inline.0.={0}을(를) 인라인화할 수 없습니다.
ref.0.will.not.be.resolved.outside.of.current.context=참조 ''{0}''은(는) 현재 컨텍스트 외에서는 해결되지 않습니다.
cannot.rename.property.0=메서드 <bold>''{1}''</bold>을(를) 재정의하는 프로퍼티 <bold>''{0}''</bold>의 이름을 변경할 수 없습니다.
cannot.inline.reference.0=참조 ''{0}''을(를) 인라인화할 수 없습니다.
cannot.rename.script.class.to.0=스크립트 클래스 ''{0}''의 이름을 ''{1}''(으)로 변경할 수 없습니다.
extract.method.dialog.explicit.return.checkbox=명시적 return 문 사용(&X)
inplace.introduce.constant.move.checkbox=다른 클래스로 이동(&M)
type.label=타입(&T):
name.label=이름(&N):
introduce.constant.class.label=클래스(정규화된 이름)로 삽입(&C):
replace.all.occurrences.checkbox=모든 찾은 항목 바꾸기(&A)
initialize.in.label=다음에서 초기화(&I):
initialize.in.border.title=다음에서 초기화
initialize.in.current.method.choice=현재 메서드(&M)
initialize.in.field.declaration.choice=필드 선언(&D)
initialize.in.class.constructor.choice=클래스 생성자(&C)
initialize.in.setup.method.choice=setUp 메서드
visibility.border.title=가시성
visibility.private.choice=비공개(&V)
visibility.public.choice=Public(&B)
visibility.protected.choice=보호됨(&O)
visibility.property.choice=프로퍼티(&R)
