cast.to.concrete.class.problem.descriptor=구체 클래스 <code>{0}</code>(으)로 형 변환합니다 #loc
class.references.subclass.display.name=클래스가 하위 클래스 중 하나를 참조
class.references.subclass.problem.descriptor=클래스 ''{0}''이(가) 하위 클래스 <code>#ref</code>을(를) 참조합니다 #loc
class.references.subclass.problem.descriptor.anonymous=익명 클래스가 하위 클래스 <code>#ref</code>을(를) 참조합니다 #loc
collection.declared.by.class.display.name=인터페이스가 아닌 클래스로 선언된 컬렉션
collection.declared.by.class.problem.descriptor=<code>#ref</code>의 선언이 ''{0}''(으)로 약화될 것입니다 #loc
collection.declared.by.class.ignore.locals.option=지역 변수 무시
collection.declared.by.class.ignore.private.members.option='private' 필드 및 메서드 무시
feature.envy.display.name=기능에 대한 욕심
feature.envy.problem.descriptor=클래스 ''{0}''이(가) 메서드 <code>#ref()</code>에서 반복적으로 액세스됩니다 #loc
bounded.wildcard.display.name=바운드된 와일드카드 사용 가능
bounded.wildcard.contravariant.descriptor=<code>? super #ref</code>(으)로 일반화할 수 있습니다 #loc
bounded.wildcard.covariant.descriptor=<code>? extends #ref</code>(으)로 일반화할 수 있습니다 #loc
bounded.wildcard.report.invariant.option=불변 클래스 보고
bounded.wildcard.report.private.option=private 메서드 보고
bounded.wildcard.report.instance.option=인스턴스 메서드 보고
instance.variable.of.concrete.class.problem.descriptor=구체 클래스 <code>#ref</code>의 인스턴스 필드 ''{0}'' #loc
chain.of.instanceof.checks.display.name='instanceof' 검사 체인
chain.of.instanceof.checks.problem.descriptor='instanceof' 검사 체인은 추상화 실패를 표시합니다 #loc
chain.of.class.equality.checks.problem.descriptor=클래스 상등 검사 체인은 추상화 실패를 표시합니다 #loc
instanceof.concrete.class.problem.descriptor=구체 클래스 <code>#ref</code>에 대한 'instanceof' #loc
instanceof.concrete.class.equality.problem.descriptor=구체 클래스 <code>#ref</code>와(과) 클래스를 비교합니다 #loc
instanceof.check.for.this.display.name='this'에 대한 'instanceof' 검사
instanceof.check.for.this.problem.descriptor=<code>#ref</code>에 대한 'instanceof' 검사 #loc
instanceof.check.for.this.equality.problem.descriptor='this'에 대한 클래스 비교 #loc
local.variable.of.concrete.class.problem.descriptor=구체 클래스 <code>#ref</code>의 지역 변수 ''{0}'' #loc
magic.number.display.name=매직 넘버
magic.number.problem.descriptor=매직 넘버 <code>#ref</code> #loc
concrete.class.use.display.name=구체 클래스 사용
method.return.concrete.class.problem.descriptor=메서드가 구체 클래스 <code>#ref</code>을(를) 반환합니다 #loc
overly.strong.type.cast.display.name=지나치게 강한 타입 형 변환
overly.strong.type.cast.weaken.quickfix=지나치게 강한 형 변환을 약화합니다.
concrete.class.method.parameter.problem.descriptor=구체 클래스 <code>#ref</code>의 매개변수 ''{0}'' #loc
public.method.not.in.interface.display.name=인터페이스에 노출되지 않는 'public' 메서드
public.method.not.in.interface.problem.descriptor='public' 메서드 <code>#ref()</code>이(가) 인터페이스를 통해 노출되지 않습니다 #loc
public.method.not.in.interface.option=<html>포함된 클래스가 비 라이브러리 인터페이스를 구현하지 않는 경우 무시</html>
static.variable.of.concrete.class.problem.descriptor=구체 클래스 <code>#ref</code>의 static 필드 ''{0}'' #loc
incompatible.mask.operation.display.name=호환되지 않는 비트 마스크 연산
incompatible.mask.operation.problem.descriptor.always.false=<code>#ref</code>이(가) 항상 false입니다 #loc
incompatible.mask.operation.problem.descriptor.always.true=<code>#ref</code>이(가) 항상 true입니다 #loc
pointless.bitwise.expression.display.name=무의미한 비트 표현식
pointless.bitwise.expression.simplify.quickfix=단순화
shift.operation.by.inappropriate.constant.display.name=부적절한 상수에의한 시프트 연산
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=지나치게 큰 상수값에의한 시프트 연산 <code>#ref</code> {0} #loc
shift.operation.by.inappropriate.constant.problem.descriptor.negative=음수값에의한 시프트 연산 <code>#ref</code> {0} #loc
shift.operation.by.inappropriate.constant.problem.descriptor.out.of.bounds=아웃바운드 값에의한 시프트 연산 <code>#ref</code> {0} #loc
equals.called.on.array.display.name=배열에서 'equals()' 호출
equals.called.on.array.problem.descriptor=배열 사이의 <code>#ref()</code>은(는) 'Arrays.equals()'여야 할 것입니다 #loc
assignment.to.null.display.name='null' 대입
assignment.to.null.problem.descriptor='null'이 변수 <code>#ref</code>에 대입되었습니다 #loc
assignment.to.null.option=필드에 대한 대입 무시
assignment.to.static.field.from.instance.method.display.name=인스턴스 컨텍스트의 static 필드에 대입
assignment.to.static.field.from.instance.method.problem.descriptor=인스턴스 컨텍스트의 static 필드 <code>#ref</code>에 대입합니다 #loc
assignment.used.as.condition.display.name=조건으로 사용된 대입
assignment.used.as.condition.problem.descriptor=<code>#ref</code> 대입이 조건으로 사용되었습니다 #loc 사용
cast.conflicts.with.instanceof.display.name='instanceof'와의 충돌 형 변환
cast.conflicts.with.instanceof.problem.descriptor=''{0}'' 타입으로의 형 변환이 선행된 ''instanceof {1}'' 검사와 충돌합니다
casting.to.incompatible.interface.display.name=호환되지 않는 인터페이스로 형 변환
casting.to.incompatible.interface.problem.descriptor=호환되지 않는 인터페이스 <code>#ref</code>(으)로 형 변환합니다 #loc
collection.added.to.self.display.name=컬렉션이 컬렉션 자신에게 추가됨
collection.added.to.self.problem.descriptor=''{0}()''이(가) 자신을 인수로 가진 컬렉션 <code>#ref</code>에서 호출됩니다 #loc
non.final.field.compareto.display.name=최종이 아닌 필드가 'compareTo()'에서 참조됨
non.final.field.compareto.problem.descriptor=비 final 필드 <code>#ref</code>이(가) 'compareTo()'에서 액세스되었습니다 #loc
covariant.equals.display.name=공분산 'equals()'
covariant.equals.problem.descriptor=<code>#ref()</code>이(가) 'Object'를 인수로 취해야 합니다 #loc
empty.class.initializer.display.name=빈 클래스 이니셜라이저
empty.class.initializer.problem.descriptor=빈 클래스 이니셜라이저 #loc
empty.class.initializer.delete.quickfix=빈 클래스 이니셜라이저 삭제
statement.with.empty.body.display.name=본문이 비어 있는 구문
statement.with.empty.body.problem.descriptor=<code>#ref</code> 문에 본문이 비어 있습니다 #loc
statement.with.empty.body.include.option=빈 코드 블록인 구문 본문 포함
equals.between.inconvertible.types.display.name=변환할 수 없는 타입의 객체 간의 'equals()'
equals.between.inconvertible.types.problem.descriptor=<code>#ref</code>이(가) 변환할 수 없는 타입인 ''{0}'' 및 ''{1}''의 객체 사이에 있습니다 #loc
equals.between.inconvertible.types.no.mutual.subclass.problem.descriptor=''{0}'' 및 ''{1}''의 공통 하위 타입인 클래스를 찾을 수 없습니다 #loc
equals.between.inconvertible.types.mutual.subclass.option=상호 하위 클래스가 발견되지 않으면 경고
equals.called.on.suspicious.object.display.name='StringBuilder'에서 'equals()' 호출
equals.called.on.suspicious.object.problem.descriptor=''{0}'' 객체에서의의심스러운 ''equals'' 호출
non.final.field.in.equals.display.name=최종이 아닌 필드가 'equals()'에서 참조됨
non.final.field.in.equals.problem.descriptor=비 final 필드 <code>#ref</code>이(가) 'equals()'에서 액세스되었습니다 #loc
equals.doesnt.check.class.parameter.display.name=매개변수의 클래스를 검사하지 않는 'equals()' 메서드
equals.doesnt.check.class.parameter.problem.descriptor=<code>#ref()</code>은(는) 자체 매개변수를 검사해야 합니다 #loc
non.final.field.in.hashcode.display.name=최종이 아닌 필드가 'hashCode()'에서 참조됨
non.final.field.in.hashcode.problem.descriptor=비 final 필드 <code>#ref</code>이(가) 'hashCode()'에서 액세스되었습니다 #loc
result.of.method.call.ignored.display.name=메서드 호출의 결과가 무시됨
write.only.object.display.name=쓰기 전용 객체
write.only.object.option.ignore.impure.constructors=순수하지 않은 생성자 무시
result.of.method.call.ignored.problem.descriptor=<code>{0}.#ref()</code>의 결과가 무시되었습니다 #loc
result.of.method.call.ignored.class.column.title=클래스 이름
result.of.method.call.ignored.method.column.title=메서드 이름 정규식
result.of.method.call.ignored.non.library.option=무시된 모든 비 라이브러리 호출 보고
infinite.recursion.display.name=무한 재귀
infinite.recursion.problem.descriptor=메서드 <code>#ref()</code>이(가) 무한 반복되며 예외를 던져야 종료됩니다 #loc
instanceof.with.incompatible.interface.display.name=호환되지 않는 인터페이스가 있는 'instanceof'
instanceof.with.incompatible.interface.problem.descriptor=호환되지 않는 인터페이스 <code>#ref</code>에 대한 'instanceof' #loc
instantiation.utility.class.display.name=유틸리티 클래스의 인스턴스화
instantiation.utility.class.problem.descriptor=유틸리티 클래스 <code>#ref</code>의 인스턴스화 #loc
iterator.hasnext.which.calls.next.display.name='next()'를 호출하는 'Iterator.hasNext()'
iterator.hasnext.which.calls.next.problem.descriptor=<code>Iterator.{0}()</code>에 ''#ref()'' 호출이 포함되어 있습니다 #loc
iterator.next.does.not.throw.nosuchelementexception.display.name='NosuchElementException'을 던질 수 없는 'Iterator.next()'
malformed.format.string.display.name=형식이 잘못된 서식 문자열
malformed.format.string.problem.descriptor.malformed=서식 문자열 <code>#ref</code>의 서식이 올바르지 않습니다 #loc
malformed.format.string.problem.descriptor.illegal=잘못된 서식 문자열 지정자: {0} #loc
malformed.format.string.problem.descriptor.too.many.arguments=서식 문자열에 대한 인수가 너무 많습니다(발견된 개수: {0}개, 필요한 개수: {1}개) #loc
malformed.format.string.problem.descriptor.too.few.arguments=서식 문자열에 대한 인수가 너무 적습니다(발견된 개수: {0}개, 필요한 개수: {1}개) #loc
malformed.format.string.problem.descriptor.arguments.do.not.match.type=인수 타입 ''{0}'' 서식 지정자 ''{1}''의 타입과 일치하지 않습니다 #loc
format.string.error.flags.not.allowed=''{1}''에서 {2, choice, 1#플래그|1<플래그} ''{0}''이(가) 허용되지 않습니다
format.string.error.unexpected.flag=''{1}''에 예기치 않은 문자 ''{0}''이(가) 있습니다
format.string.error.duplicate.flag=''{1}''에 중복 플래그 ''{0}''이(가) 있습니다
format.string.error.width.not.allowed=''{1}''에서는 너비(''{0}'')가 허용되지 않습니다
format.string.error.precision.not.allowed=''{1}''에서는 정밀도(''{0}'')가 허용되지 않습니다
format.string.error.unnecessary.position.specifier=''{1}''에 불필요한 인수 위치 지정자 ''{0}''이(가) 있습니다
format.string.error.illegal.position.specifier=''{1}'' 내 잘못된 위치 지정자 ''{0}''이(가) 있습니다
format.string.error.previous.element.not.found=기존 플래그 '<'가 사용되지만 ''{0}''에 대한 기존 형식 지정자는 찾을 수 없습니다
format.string.error.unknown.conversion=''{0}''에 알 수 없는 변환이 있습니다
format.string.error.invalid.precision=''{0}''에 잘못된 정밀도가 지정되어 있습니다
format.string.error.illegal.flag.combination=''{2}''에 ''{0}'' 및 ''{1}''의 잘못된 플래그 조합이 있습니다
format.string.error.left.justify.no.width=왼쪽 정렬 플래그 ''-''가 사용되지만 너비가 ''{0}''에서 지정되지 않았습니다
format.string.error.zero.padding.no.width=제로 패딩 플래그 ''0''이 사용되지만 너비가 ''{0}''에서 지정되지 않았습니다
mismatched.read.write.array.display.name=배열의 일치하지 않는 읽기 및 쓰기
mismatched.read.write.array.problem.descriptor.write.not.read=배열 <code>#ref</code>의 내용은 쓰기는 되지만 읽기는 되지 않습니다 #loc
mismatched.read.write.array.problem.descriptor.read.not.write=배열 <code>#ref</code>의 내용은 읽기는 되지만 쓰기는 되지 않습니다 #loc
mismatched.update.collection.display.name=컬렉션의 쿼리 및 업데이트 불일치
mismatched.update.collection.problem.descriptor.updated.not.queried=컬렉션 <code>#ref</code>의 내용은 업데이트되지만 쿼리되지 않습니다 #loc
mismatched.update.collection.problem.description.queried.not.updated=컬렉션 <code>#ref</code>의 내용은 쿼리되지만 업데이트되지 않습니다 #loc
rename.quickfix=이름 변경
renameto.quickfix=''{0}''(으)로 이름 변경
misspelled.equals.display.name='equals()' 대신 'equal()'
misspelled.equals.problem.descriptor=<code>#ref()</code> 메서드는 'equals()'여야 할 것입니다 #loc
non.short.circuit.boolean.expression.display.name=쇼트 서킷이 아닌 부울 표현식
non.short.circuit.boolean.expression.problem.descriptor=쇼트 서킷이 아닌 부울 표현식 <code>#ref</code> #loc
non.short.circuit.boolean.expression.replace.quickfix=단락 표현식으로 바꿉니다.
null.argument.to.var.arg.method.display.name=가변인수 메서드에 대한 혼란스러운 인수
null.argument.to.var.arg.method.problem.descriptor=인수 <code>#ref</code>이(가) 혼동됩니다. vararg 호출이 기대되는지, 비 vararg 호출이 기대되는지 명확하지 않습니다 #loc
primitive.array.argument.to.var.arg.method.display.name=가변인수 메서드에 대한 기본형 배열 인수가 혼동됩니다.
primitive.array.argument.to.var.arg.method.problem.descriptor=가변인수 메서드에 대한 기본형 배열 인수가 혼동됩니다. #loc
object.comparison.display.name='equals()' 대신 '=='를 사용하여 객체 비교
object.comparison.enumerated.ignore.option=열거형 변수 간 '==' 무시
object.comparison.klass.ignore.option='equals()' 구현이 없는 final 클래스 타입 간 '==' 무시
object.comparison.problem.description=객체 값을 'equals()'가 아닌 <code>#ref</code>을(를) 사용하여 비교합니다 #loc
equality.to.safe.equals.quickfix='=='를 null 안전 'equals()'로 바꿉니다.
inequality.to.safe.not.equals.quickfix='!='를 null 안전 '!equals()'로 바꿉니다.
default.tostring.call.display.name=디폴트 값 'toString()' 호출
default.tostring.call.problem.descriptor=<code>#ref</code>의 디폴트 값 'toString()' 호출 #loc
octal.and.decimal.integers.in.same.array.display.name=동일한 배열의 8진 및 10진 정수
octal.and.decimal.integers.in.same.array.problem.descriptor=동일한 배열 이니셜라이저의 8진 및 10진 정수 #loc
result.of.object.allocation.ignored.display.name=객체 대입의 결과가 무시됨
result.of.object.allocation.ignored.problem.descriptor=<code>new #ref()</code>의 결과가 무시되었습니다 #loc
result.of.object.allocation.ignored.options.chooserTitle=객체 할당을 무시할 수 있는 클래스 선택
result.of.object.allocation.fix.name=타입이 ''{0}''인 객체 할당 무시
use.0index.in.jdbc.resultset.display.name=JDBC ResultSet의 색인 0 사용
use.0index.in.jdbc.resultset.problem.descriptor=JDBC ResultSet의 색인 '0' 사용 #loc
use.0index.in.jdbc.prepared.statement.problem.descriptor=JDBC PreparedStatement의 색인 '0' 사용 #loc
return.of.null.display.name='null' 반환
return.of.null.problem.descriptor=<code>#ref</code> 반환 #loc
return.of.null.arrays.option=배열을 반환하는 메서드 보고
return.of.null.objects.option=객체를 반환하는 메서드 보고
return.of.null.collections.option=컬렉션 객체를 반환하는 메서드 보고
return.of.null.ignore.private.option='private' 메서드, 익명 클래스, 람다 무시
static.method.via.subclass.display.name=static 메서드가 하위 클래스를 통해 참조됨
static.method.via.subclass.problem.descriptor=static 메서드 <code>#ref()</code>이(가) 클래스 ''{0}''에서 선언되었지만 하위 클래스 ''{1}''을(를) 통해 참조되었습니다 #loc
static.method.via.subclass.rationalize.quickfix=static 메서드 호출 합리화
static.field.via.subclass.display.name=static 필드가 하위 클래스를 통해 참조됨
static.field.via.subclass.problem.descriptor=static 필드 <code>#ref</code>이(가) 클래스 ''{0}''에서 선언되었지만 하위 클래스 ''{1}''을(를) 통해 참조되었습니다 #loc
static.field.via.subclass.rationalize.quickfix=static 필드 액세스를 합리화합니다.
string.comparison.display.name='equals()' 대신 '=='를 사용하여 문자열 비교
number.comparison.display.name='equals()' 대신 '=='를 사용하여 숫자 비교
string.comparison.problem.descriptor=문자열 값을 'equals()'가 아닌 <code>#ref</code>을(를) 사용하여 비교합니다 #loc
number.comparison.problem.descriptor=숫자 객체를 'equals()'가 아닌 <code>#ref</code>을(를) 사용하여 비교합니다 #loc
subtraction.in.compareto.display.name='compareTo()'의 뺄셈
subtraction.in.compareto.problem.descriptor='compareTo()'의 뺄셈 <code>#ref</code>이(가) 오버플로 또는 정확성 손실을 낳을 수 있습니다 #loc
text.label.in.switch.statement.display.name='switch' 문의 텍스트 라벨
text.label.in.switch.statement.problem.descriptor='switch' {0, choice, 1#문|2#식}의 텍스트 라벨 <code>#ref:</code> #loc
properties.object.as.hashtable.display.name='프로퍼티' 객체를 '해시테이블'로 사용
properties.object.as.hashtable.problem.descriptor=프로퍼티 객체에서 <code>Hashtable.#ref()</code>이(가) 호출됩니다 #loc
assignment.replaceable.with.operator.assignment.display.name=대입을 연산자 대입으로 바꿀 수 있음
unnecessary.code.block.display.name=불필요한 코드 블록
unnecessary.code.block.unwrap.quickfix=블록 줄 바꿈을 해제합니다.
redundant.local.variable.display.name=중복 지역 변수
redundant.local.variable.ignore.option=즉시 반환되거나 던져된 변수 무시
redundant.local.variable.annotation.option=어노테이션이 있는 변수 무시
static.collection.display.name=static 컬렉션
static.collection.problem.descriptor=static 컬렉션 <code>#ref</code> #loc
static.collection.ignore.option=약한 static 컬렉션 또는 맵 무시
stringbuffer.field.display.name='StringBuilder' 필드
stringbuffer.field.problem.descriptor=''{0}'' 필드 <code>#ref</code> #loc
gc.call.display.name='System.gc()' 또는 'Runtime.gc()' 호출
gc.call.problem.descriptor=<code>#ref</code>을(를) 프로덕션 코드에서 호출하면 안 됩니다 #loc
array.allocation.zero.length.display.name=제로 길이 배열 대입
array.allocation.zero.length.problem.descriptor=제로 길이 배열 대입 #loc
constant.for.zero.length.array.display.name=길이가 0인 배열의 불필요한 사용
constant.for.zero.length.array.problem.descriptor=제로 길이 배열은 상수로 변경할 수 있습니다 #loc
constant.for.zero.length.array.quickfix.family=상수로 바꾸기
multiple.loggers.display.name=여러 로거가 있는 클래스
logger.name.option=로거 클래스 이름(&C):
multiple.loggers.problem.descriptor=클래스 <code>#ref</code>이(가) 여러 로거를 선언합니다 #loc
no.logger.display.name=로거가 없는 클래스
no.logger.problem.descriptor=클래스 <code>#ref</code>이(가) 로거를 선언하지 않습니다 #loc
non.constant.logger.display.name=비상수 로거
non.constant.logger.problem.descriptor=비상수 로거 필드 <code>#ref</code> #loc
public.method.without.logging.display.name=로깅 없는 'public' 메서드
public.method.without.logging.problem.descriptor='public' 메서드 <code>#ref()</code>에 로깅 호출이 없습니다 #loc
ignore.trivial.finalizers.option=자명한 'finalize()' 구현 무시
finalize.declaration.display.name='finalize()'는 재정의 불가
finalize.declaration.problem.descriptor='finalize()'는 재정의하면 안 됩니다 #loc
finalize.not.declared.protected.display.name='finalize()'는 public이 아닌 protected여야 함
finalize.not.declared.protected.problem.descriptor='finalize()'는 public이 아니라 protected여야 합니다 #loc
finalize.called.explicitly.display.name=명시적으로 'finalize()' 호출
finalize.called.explicitly.problem.descriptor=<code>#ref()</code>이(가) 명시적으로 호출됩니다 #loc
java.lang.import.display.name='java.lang' 패키지의 불필요한 import 문
java.lang.import.problem.descriptor='java.lang' 패키지의 불필요한 import 문 #loc
import.display.name='*' 가져오기
import.problem.descriptor=패키지 import 문 <code>#ref</code> #loc
import.from.same.package.display.name=동일한 패키지의 불필요한 import 문
import.from.same.package.problem.descriptor=동일한 패키지 <code>#ref</code>의 불필요한 import 문 #loc
single.class.import.display.name=단일 클래스 import 문
single.class.import.problem.descriptor=단일 클래스 import 문 <code>#ref</code> #loc
static.import.display.name=static import 문
static.import.problem.descriptor=static import 문 <code>#ref</code> #loc
static.import.replace.quickfix=비 static import 문으로 바꿉니다.
static.import.fix.ignore.class=클래스 ''{0}''의 static import 문 허용
static.import.options.border.title=정적으로 가져올 수 있는 클래스:
static.import.options.chooserTitle=정적으로 가져올 수 있는 클래스 선택
unused.import.problem.descriptor=사용되지 않는 import 문 <code>#ref</code> #loc
clone.instantiates.objects.with.constructor.display.name='clone()'이 생성자로 객체 인스턴스화
clone.instantiates.objects.with.constructor.problem.descriptor='clone()'이 새 <code>#ref</code> 인스턴스를 생성합니다 #loc
clone.instantiates.new.array.problem.descriptor=''clone()''이 새 {0} 배열을 생성합니다 #loc
clone.doesnt.declare.clonenotsupportedexception.display.name='clone()'이 'CloneNotSupportedException'을 선언하지 않음
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=<code>#ref()</code>에서 'CloneNotSupportedException'을 선언하지 않습니다 #loc
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=throw 절에 'CloneNotSupportedException'을 추가합니다.
clone.method.in.non.cloneable.class.display.name=복제할 수 없는 클래스의 'clone()' 메서드
clone.method.in.non.cloneable.class.problem.descriptor=<code>#ref()</code>이(가) 비 cloneable 클래스 ''{0}''에 정의되었습니다 #loc
clone.method.in.non.cloneable.anonymous.class.problem.descriptor=<code>#ref()</code>이(가) ''{0}''에서 파생된 비 cloneable 익명 클래스에 정의되었습니다 #loc
clone.method.in.non.cloneable.interface.problem.descriptor=<code>#ref()</code>이(가) 비 cloneable 인터페이스 ''{0}''에 정의되었습니다 #loc
cloneable.class.without.clone.display.name='clone()' 메서드가 없는 cloneable 클래스
cloneable.class.without.clone.problem.descriptor=<code>#ref</code>이(가) 'Cloneable'이지만 'clone()' 메서드를 정의하지 않습니다 #loc
cloneable.class.without.clone.ignore.option=상속으로 인해 cloneable 클래스 무시
cloneable.class.without.clone.quickfix='clone()' 메서드를 생성합니다.
use.obsolete.collection.type.display.name=곧 사용할 수 없게 될 컬렉션 타입 사용
use.obsolete.collection.type.problem.descriptor=곧 사용할 수 없게 될 컬렉션 타입 <code>#ref</code>이(가) 사용되었습니다 #loc
use.obsolete.collection.type.ignore.library.arguments.option=필요한 경우 곧 사용할 수 없게 될 컬렉션 타입 무시
inspection.suppression.annotation.display.name=검사 숨기기 어노테이션
inspection.suppression.annotation.problem.descriptor=검사 억제 어노테이션 <code>#ref</code> #loc
use.system.out.err.display.name='System.out' 또는 'System.err' 사용
use.system.out.err.problem.descriptor=<code>#ref</code>의 사용을 더 강력한 로깅으로 바꿔야 할 것입니다 #loc
dumpstack.call.display.name='Thread.dumpStack()' 호출
dumpstack.call.problem.descriptor=<code>Thread.#ref()</code>의 호출을 더 강력한 로깅으로 바꿔야 할 것입니다 #loc
printstacktrace.call.display.name='printStackTrace()' 호출
printstacktrace.call.problem.descriptor=<code>#ref()</code>의 호출을 더 강력한 로깅으로 바꿔야 할 것입니다 #loc
abstract.method.call.in.constructor.display.name=객체 생성 중에 추상 메서드 호출
abstract.method.call.in.constructor.problem.descriptor='abstract' 메서드 <code>#ref()</code>을(를) 객체 생성 중에 호출합니다 #loc
instance.variable.may.not.be.initialized.display.name=인스턴스 필드가 초기화되지 않을 수 있음
instance.variable.may.not.be.initialized.problem.descriptor=인스턴스 필드 <code>#ref</code>은(는) 객체 생성 중에 초기화할 수 없습니다 #loc
instance.Variable.may.not.be.initialized.problem.descriptor.junit=인스턴스 필드 <code>#ref</code>은(는) 객체 생성이나 'setUp()' 호출 중에 초기화할 수 없습니다 #loc
primitive.fields.ignore.option=기본 필드 무시
instance.variable.used.before.initialized.display.name=초기화 전에 사용된 인스턴스 필드
instance.variable.used.before.initialized.problem.descriptor=인스턴스 필드 <code>#ref</code>이(가) 초기화 전에 사용되었습니다 #loc
non.final.static.variable.initialization.display.name=클래스 초기화 중에 비 final static 필드가 사용됨
non.final.static.variable.initialization.problem.descriptor=비 final static 필드 <code>#ref</code>이(가) 클래스 초기화 중에 사용되었습니다 #loc
overridable.method.call.in.constructor.display.name=객체 생성 중에 재정의 가능한 메서드 호출
overridable.method.call.in.constructor.problem.descriptor=재정의 가능한 메서드 <code>#ref()</code>을(를) 객체 생성 중에 호출합니다 #loc
overridden.method.call.in.constructor.display.name=객체 생성 중에 재정의된 메서드 호출
overridden.method.call.in.constructor.problem.descriptor=재정의된 메서드 <code>#ref()</code>을(를) 객체 생성 중에 호출합니다 #loc
static.variable.may.not.be.initialized.display.name=static 필드가 초기화되지 않을 수 있음
static.variable.may.not.be.initialized.problem.descriptor=static 필드 <code>#ref</code>은(는) 클래스 초기화 중에 초기화할 수 없습니다 #loc
static.variable.used.before.initialization.display.name=초기화 전에 사용된 static 필드
static.variable.used.before.initialization.problem.descriptor=static 필드 <code>#ref</code>이(가) 초기화 전에 사용되었습니다 #loc
this.reference.escaped.in.construction.display.name=객체 생성에서 'this' 참조 이스케이프
this.reference.escaped.in.construction.problem.descriptor=<code>#ref</code>이(가) 객체 생성 중에 이스케이프되었습니다 #loc
assignment.to.catch.block.parameter.display.name='catch' 블록 매개변수에 대입
extract.parameter.as.local.variable.quickfix=매개변수를 지역 변수로 추출합니다.
assignment.to.for.loop.parameter.display.name='for' 루프 매개변수에 대입
assignment.to.for.loop.parameter.check.foreach.option=향상된 'for' 루프 매개변수 검사
assignment.to.for.loop.parameter.problem.descriptor=for 루프 매개변수 <code>#ref</code>에 대입되었습니다 #loc
assignment.to.method.parameter.display.name=메서드 매개변수에 대입
chained.equality.comparisons.display.name=체인 상등 비교
confusing.octal.escape.sequence.display.name=혼동되는 8진 이스케이프 시퀀스
increment.decrement.display.name='++' 또는 '--' 결과가 사용됨
nested.assignment.display.name=중첩된 대입
nested.assignment.problem.descriptor=대입 표현식의 결과가 사용되었습니다 #loc
overloaded.methods.with.same.number.parameters.display.name=매개변수 수가 동일한 오버로드된 메서드
overloaded.vararg.method.display.name=오버로드된 vararg 메서드
refused.bequest.display.name=메서드가 상위 메서드를 호출하지 않음
reuse.of.local.variable.display.name=지역 변수 재사용
reuse.of.local.variable.split.quickfix=지역 변수를 분할합니다.
character.comparison.display.name=문자 비교
character.comparison.problem.descriptor=국제화된 컨텍스트의 문자 비교 <code>#ref</code> #loc
package.visible.field.display.name=Package-visible 필드
package.visible.field.problem.descriptor=Package-visible 필드 <code>#ref</code> #loc
package.visible.inner.class.display.name=패키지 표시 중첩 클래스
package.visible.inner.class.problem.descriptor=패키지 표시 중첩 클래스 <code>#ref</code> #loc
package.visible.inner.class.ignore.enum.option=패키지 표시 내부 열거형 무시
package.visible.inner.class.ignore.interface.option=패키지 표시 내부 인터페이스 무시
protected.field.display.name=protected 필드
protected.field.problem.descriptor=protected 필드 <code>#ref</code> #loc
protected.inner.class.display.name=protected 중첩 필드
protected.inner.class.problem.descriptor=protected 중첩 필드 <code>#ref</code> #loc
protected.inner.class.ignore.enum.option='protected' 내부 열거형 무시
protected.inner.class.ignore.interface.option='protected' 내부 인터페이스 무시
public.field.display.name='public' 필드
public.field.problem.descriptor='public' 필드 <code>#ref</code> #loc
public.field.ignore.enum.type.fields.option=열거형의 'public final' 필드 무시
public.inner.class.display.name='public' 중첩 클래스
public.inner.class.problem.descriptor='public' 중첩 클래스 <code>#ref</code> #loc
public.inner.class.ignore.enum.option='public' 내부 열거형 무시
public.inner.class.ignore.interface.option='public' 내부 인터페이스 무시
accessing.non.public.field.of.another.object.display.name=다른 객체의 비 public 필드에 액세스
accessing.non.public.field.of.another.object.problem.descriptor=다른 객체의 비 public 필드 <code>#ref</code>에 바로 액세스 #loc
call.to.date.tostring.display.name='Date.toString()' 호출
call.to.date.tostring.problem.descriptor=<code>Date.#ref()</code>이(가) 국제화된 컨텍스트에서 사용되었습니다 #loc
magic.character.display.name=매직 문자
magic.character.problem.descriptor=국제화된 컨텍스트의 매직 문자 <code>#ref</code> #loc
call.to.numeric.tostring.display.name='Number.toString()' 호출
call.to.numeric.tostring.problem.descriptor=국제화된 컨텍스트에서 <code>Number.#ref()</code>이(가) 호출되었습니다 #loc
instantiating.simpledateformat.without.locale.display.name=로케일이 없는 'SimpleDateFormat'
instantiating.simpledateformat.without.locale.problem.descriptor=국제화된 컨텍스트에서 로케일을 지정하지 않은 상태로 <code>#ref</code>을(를) 초기화합니다 #loc
string.concatenation.display.name=문자열 연결
string.concatenation.problem.descriptor=국제화된 컨텍스트의 문자열 연결 <code>#ref</code> #loc
inspection.option.ignore.system.out='System.out.print'인수 무시
inspection.option.ignore.system.err='System.err.print'인수 무시
inspection.option.ignore.assert=어설션 문 설명 인수 무시
inspection.option.ignore.exceptions=Throwable 하위 클래스의 생성자 인수 무시
inspection.option.ignore.nonnls=@NonNls로 어노테이션이 추가된 경우 무시
inspection.option.ignore.constant.initializers=상수 필드의 이니셜라이저 무시
inspection.option.ignore.in.annotations=어노테이션에서 무시
inspection.option.ignore.in.tostring=toString() 메소두 내부 무시
inspection.option.ignore.as.initial.capacity=StringBuilders 및 Collections의 초기 용량 무시
inspection.option.ignore.in.hashcode='hashCode()' 메서드에서 상수 무시
string.touppercase.tolowercase.without.locale.display.name=로케일이 없는 'String.toUpperCase()' 또는 'toLowerCase()' 호출
string.touppercase.tolowercase.without.locale.problem.descriptor=국제화된 문자열을 사용하는 로케일을 지정하지 않은 상태에서 <code>String.#ref()</code>이(가) 호출됩니다 #loc
use.stringtokenizer.display.name='StringTokenizer' 사용
use.stringtokenizer.problem.descriptor=국제화된 컨텍스트의 <code>#ref</code> #loc
time.tostring.call.display.name='Time.toString()' 호출
time.tostring.call.problem.descriptor=국제화된 컨텍스트의 <code>Time.#ref()</code> #loc
class.escapes.defined.scope.display.name=액세스할 수 없는 클래스가 노출됨
class.escapes.defined.scope.display.module.option=모듈의 API가 내보내지 않은 클래스를 노출(Java 9+)
class.escapes.defined.scope.display.public.option=공용 API가 액세스할 수 없는 클래스를 노출
class.escapes.defined.scope.display.package.option=패키지 로컬 API가 private 클래스를 노출
class.escapes.defined.scope.problem.descriptor=클래스 <code>#ref</code>이(가) 정의된 범위 외부에 노출됩니다 #loc
class.escapes.defined.scope.java9.modules.descriptor=클래스 <code>#ref</code>이(가) 모듈 ''{0}''에서 노출되지 않습니다 #loc
field.name.hides.in.superclass.display.name=하위 클래스 필드가 상위 클래스 필드를 숨김
field.name.hides.in.superclass.problem.descriptor=필드 <code>#ref</code>이(가) 상위 클래스를 숨깁니다 #loc
field.name.hides.in.superclass.ignore.option=액세스할 수 없는 필드 무시
field.name.hides.in.superclass.ignore.static.field.option=static 필드를 숨기는 static 필드 무시
inner.class.field.hides.outer.display.name=내부 클래스 필드가 외부 클래스 필드를 숨김
inner.class.field.hides.outer.ignore.option=내부 클래스에서 표시되지 않는 외부 필드 무시
inner.class.field.hides.outer.problem.descriptor=내부 클래스 필드 <code>#ref</code>이(가) 외부 클래스 필드를 숨깁니다 #loc
local.variable.hides.member.variable.display.name=지역 변수가 필드를 숨김
local.variable.hides.member.variable.problem.descriptor=지역 변수 <code>#ref</code>이(가) 클래스 ''{0}''의 필드를 숨깁니다 #loc
local.variable.hides.member.variable.ignore.option=비 static 필드를 숨기는 static 컨텍스트의 지역 변수 무시
method.overloads.display.name=의도하지 않았을 수 있는 상위 클래스 메서드의 오버로드
method.overloads.problem.descriptor=재정의가 의도된 경우 메서드 <code>#ref()</code>이(가) 상위 클래스의 호환되는 메서드를 오버로드합니다 #loc
method.overloads.report.incompatible.option=매개변수 타입이 호환되지 않는 경우에도 보고
method.overrides.private.display.name.problem.descriptor=메서드 <code>#ref()</code>이(가) 상위 클래스의 'private' 메서드를 재정의합니다 #loc
method.overrides.static.display.name=메서드가 상위 클래스의 'static' 메서드를 재정의하려고 함
method.overrides.static.problem.descriptor=메서드 <code>#ref()</code>이(가) 상위 클래스의 static 메서드를 재정의하려고 합니다 #loc
parameter.hides.member.variable.display.name=매개변수가 필드를 숨김
parameter.hides.member.variable.problem.descriptor=매개변수 <code>#ref</code>이(가) 클래스 ''{0}''의 필드를 숨깁니다 #loc
parameter.hides.member.variable.ignore.setters.option=프로퍼티 setter 무시
parameter.hides.member.variable.ignore.superclass.option=하위 클래스에서 표시되지 않는 상위 클래스 필드 무시
parameter.hides.member.variable.ignore.constructors.option=생성자 무시
parameter.hides.member.variable.ignore.abstract.methods.option=추상 메서드 무시
parameter.hides.member.variable.ignore.static.parameters.option=인스턴스 필드를 숨기는 static 메서드 매개변수 무시
type.parameter.hides.visible.type.display.name=타입 매개변수가 표시되는 타입을 숨김
type.parameter.hides.visible.type.problem.descriptor=타입 매개변수 <code>#ref</code>이(가) 표시되는 타입 ''{0}''을(를) 숨깁니다 #loc
type.parameter.hides.type.parameter.problem.descriptor=타입 매개변수 <code>#ref</code>이(가) 타입 매개변수 ''{0}''을(를) 숨깁니다 #loc
anonymous.class.variable.hides.containing.method.variable.display.name=익명의 클래스 변수가 메서드 포함 시 변수를 숨김
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor=익명의 클래스 매개변수 <code>#ref</code>이(가) 메서드 포함 시 변수를 숨깁니다 #loc
anonymous.class.field.hides.containing.method.variable.problem.descriptor=익명의 클래스 필드 <code>#ref</code>이(가) 메서드 포함 시 변수를 숨깁니다 #loc
anonymous.class.variable.hides.containing.method.variable.problem.descriptor=익명의 클래스 지역 변수 <code>#ref</code>이(가) 메서드 포함 시 변수를 숨깁니다 #loc
channel.opened.not.closed.display.name='Channel'이 열렸으나 안전하게 닫히지 않음
drivermanager.call.display.name=JDBC 연결을 얻기 위한 'DriverManager' 사용
drivermanager.call.problem.descriptor=<code>DriverManager.#ref()</code> 호출 #loc
hibernate.resource.opened.not.closed.display.name=Hibernate 리소스가 열렸으나 안전하게 닫히지 않음
i.o.resource.opened.not.closed.display.name=I/O 리소스가 열렸으나 안전하게 닫히지 않음
resource.opened.not.closed.problem.descriptor=''{0}''은(는) ''try'' 블록 앞에서 열고 해당하는 ''finally'' 블록에서 닫아야 합니다 #loc
jdbc.resource.opened.not.closed.display.name=JDBC 리소스가 열렸으나 안전하게 닫히지 않음
jndi.resource.opened.not.closed.display.name=JNDI 리소스가 열렸으나 안전하게 닫히지 않음
socket.opened.not.closed.display.name=소켓이 열렸으나 안전하게 닫히지 않음
annotation.class.display.name=어노테이션 인터페이스
annotation.class.problem.descriptor=어노테이션 인터페이스 <code>#ref</code> #loc
annotation.display.name=어노테이션
annotation.problem.descriptor=어노테이션 <code>#ref</code> #loc
assert.statement.display.name='assert' 문
statement.problem.descriptor=<code>#ref</code> 문 #loc
auto.boxing.display.name=자동 박싱
auto.boxing.problem.descriptor=자동 박싱 <code>#ref</code> #loc
auto.boxing.make.boxing.explicit.quickfix=박싱을 명시적으로 만듭니다.
auto.boxing.ignore.added.to.collection.option=컬렉션에 추가된 표현식 무시
auto.unboxing.display.name=자동 언박싱
auto.unboxing.problem.descriptor=자동 언박싱 <code>#ref</code> #loc
auto.unboxing.make.unboxing.explicit.quickfix=언박싱을 명시적으로 만듭니다.
enumerated.class.display.name=열거형 클래스
enumerated.class.problem.descriptor=열거형 클래스 <code>#ref</code> #loc
extended.for.statement.display.name=향상된 'for' 문
extended.for.statement.replace.quickfix=이전 스타일의 'for' 문으로 바꿉니다.
variable.argument.method.display.name=vararg 메서드
variable.argument.method.problem.descriptor=vararg 메서드 <code>#ref()</code> #loc
variable.argument.method.quickfix=vararg 매개변수를 배열로 변환합니다
hardcoded.file.separator.display.name=하드코딩된 파일 구분 기호
hardcoded.file.separator.problem.descriptor=하드코딩된 파일 구분 기호 <code>#ref</code> #loc
hardcoded.file.separator.include.option=인지된 MIME 미디어 타입에 "example/*" 포함
hardcoded.line.separator.display.name=하드코딩된 줄 구분 기호
hardcoded.line.separator.problem.descriptor=하드코딩된 줄 구분 기호 <code>#ref</code> #loc
native.method.display.name=네이티브 메서드
native.method.problem.descriptor=<code>#ref</code>(으)로 선언된 메서드는 이식 불가능합니다 #loc
runtime.exec.call.display.name='Runtime.exec()' 호출
runtime.exec.call.problem.descriptor=<code>Runtime.#ref()</code> 호출은 이식 불가능합니다 #loc
system.exit.call.display.name='System.exit()' 또는 관련 메서드 호출
system.exit.call.problem.descriptor=<code>{0}.#ref()</code> 호출은 이식 불가능합니다 #loc
system.exit.call.ignore.option=메인 메서드에서 무시
system.getenv.call.display.name='System.getenv()' 호출
system.getenv.call.problem.descriptor=<code>System.#ref()</code> 호출은 이식 불가능합니다 #loc
use.of.awt.peer.class.display.name=AWT 피어 클래스 사용
use.of.awt.peer.class.problem.descriptor=AWT 피어 클래스 <code>#ref</code>의 사용은 이식 불가능합니다 #loc
use.of.concrete.jdbc.driver.class.display.name=구체 JDBC 드라이버 클래스 사용
use.of.concrete.jdbc.driver.class.problem.descriptor=구체 JDBC 드라이버 클래스 <code>#ref</code>의 사용은 이식 불가능합니다 #loc
use.processbuilder.class.display.name='java.lang.ProcessBuilder' 클래스 사용
use.processbuilder.class.problem.descriptor=<code>#ref</code>의 사용은 이식 불가능합니다 #loc
use.sun.classes.display.name='sun.*' 클래스 사용
use.sun.classes.problem.descriptor=Sun 제공 클래스 <code>#ref</code>의 사용은 이식 불가능합니다 #loc
abstract.class.with.only.one.direct.inheritor.display.name=직접 상속자가 하나인 추상 클래스
anonymous.inner.may.be.named.static.inner.class.display.name=익명 클래스가 이름 지정된 'static' 내부 클래스가 될 수 있음
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=익명 클래스 <code>#ref</code>이(가) 이름 지정된 'static' 내부 클래스가 될 수 있습니다 #loc
array.length.in.loop.condition.display.name=루프 조건의 Array.length
array.length.in.loop.condition.problem.descriptor=루프 조건의 배열 <code>#ref</code>을(를) 검사합니다 #loc
large.array.allocation.no.outofmemoryerror.display.name=OutOfMemoryError 검사 없이 대규모 배열 대입
large.array.allocation.no.outofmemoryerror.problem.descriptor=메모리 부족 조건에 대해 검사되지 않은 대규모 배열 대입 #loc
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=최대 요소 수:
connection.opened.not.safely.closed.display.name=연결이 열렸으나 안전하게 닫히지 않음
interface.one.inheritor.display.name=직접 상속자가 하나인 인터페이스
interface.one.inheritor.problem.descriptor=인터페이스 <code>#ref</code>에 직접 상속자가 하나만 있습니다 #loc
method.call.in.loop.condition.display.name=루프 조건의 메서드 호출
method.call.in.loop.condition.problem.descriptor=루프 조건의 메서드 <code>#ref</code>을(를) 호출합니다 #loc
large.initializer.primitive.type.array.display.name=기본 타입 배열에 지나치게 큰 이니셜라이저
large.initializer.primitive.type.array.problem.descriptor=요소가 너무 많은({0}) 기본 배열 이니셜라이저 #loc
large.initializer.primitive.type.array.maximum.number.of.elements.option=최대 요소 수:
private.member.access.between.outer.and.inner.classes.display.name=통합 접근자 호출
private.member.access.between.outer.and.inner.classes.problem.descriptor=클래스 ''{0}''의 ''private'' 멤버에 액세스하려면 통합 접근자가 필요합니다 #loc
private.member.access.between.outer.and.inner.classes.make.local.quickfix=''{0}''을(를) package-private으로 만듭니다.
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix=''{0}'' 생성자를 package-private으로 만듭니다.
recordstore.opened.not.safely.closed.display.name='RecordStore'가 열렸으나 안전하게 닫히지 않음
overly.complex.anonymous.inner.class.display.name=지나치게 복잡한 익명 클래스
cyclomatic.complexity.limit.option=순환 복잡성 제한:
overly.complex.anonymous.inner.class.problem.descriptor=지나치게 복잡한 익명 클래스(순환 복잡도 = {0}) #loc
anonymous.inner.class.with.too.many.methods.display.name=메서드가 너무 많은 익명의 내부 클래스
method.count.limit.option=메서드 수 제한:
anonymous.inner.class.with.too.many.methods.problem.descriptor=메서드가 너무 많은 익명의 내부 클래스(메서드 수 = {0}) #loc
overly.complex.class.display.name=지나치게 복잡한 클래스
overly.complex.class.problem.descriptor=지나치게 복잡한 클래스 <code>#ref</code>(순환 복잡도 = {0}) #loc
overly.coupled.class.display.name=지나치게 결합된 클래스
overly.coupled.class.class.coupling.limit.option=클래스 결합 제한:
include.java.system.classes.option=Java 시스템 클래스에 대한 결합 포함
include.library.classes.option=라이브러리 클래스에 대한 결합 포함
overly.coupled.class.problem.descriptor=<code>#ref</code>이(가) 지나치게 결합되었습니다(종속성 = {0}) #loc
class.too.deep.display.name=상속 트리에서 너무 깊이 있는 클래스
class.too.deep.inheritance.depth.limit.option=상속 깊이 제한:
class.too.deep.problem.descriptor=<code>#ref</code>의 상속 트리가 너무 깊습니다(상속 깊이 = {0}) #loc
inner.class.too.deeply.nested.display.name=내부 클래스가 너무 깊게 중첩
inner.class.too.deeply.nested.nesting.limit.option=중첩 제한:
inner.class.too.deeply.nested.problem.descriptor=<code>#ref</code>이(가) 지나치게 중첩되었습니다(중첩 수준 = {0}) #loc
too.many.constructors.display.name=생성자가 너무 많은 클래스
too.many.constructors.count.limit.option=생성자 수 제한:
too.many.constructors.ignore.deprecated.option=곧 사용할 수 없게 될 생성자 무시
too.many.constructors.problem.descriptor=<code>#ref</code>에 생성자가 너무 많습니다(생성자 수 = {0}) #loc
too.many.fields.display.name=필드가 너무 많은 클래스
too.many.fields.count.limit.option=필드 수 제한:
too.many.fields.problem.descriptor=<code>#ref</code>에 생성자가 너무 많습니다(생성자 수 = {0}) #loc
too.many.methods.display.name=메서드가 너무 많은 클래스
too.many.methods.problem.descriptor=<code>#ref</code>에 생성자가 너무 많습니다(생성자 수 = {0}) #loc
externalizable.with.serialization.methods.display.name='readObject()' 또는 'writeObject()'가 있는 externalizable 클래스
externalizable.with.serialization.methods.problem.descriptor.both=Externalizable <code>#ref</code>{0, choice, 1# 클래스|2# 인터페이스|3#에서 파생된 익명 클래스|4# 어노테이션 타입|5# 열거형|6# 레코드}이(가) 'readObject()' 및 'writeObject()'를 정의합니다 #loc
externalizable.with.serialization.methods.problem.descriptor.write=Externalizable <code>#ref</code>{0, choice, 1# 클래스|2# 인터페이스|3#에서 파생된 익명 클래스|4# 어노테이션 타입|5# 열거형|6# 레코드}이(가) 'writeObject()'를 정의합니다 #loc
externalizable.with.serialization.methods.problem.descriptor.read=Externalizable <code>#ref</code>{0, choice, 1# 클래스|2# 인터페이스|3#에서 파생된 익명 클래스|4# 어노테이션 타입|5# 열거형|6# 레코드}이(가) 'readObject()'를 정의합니다 #loc
non.serializable.with.serialversionuid.display.name='serialVersionUID'가 있는 비 serializable 클래스
non.serializable.class.with.serialversionuid.problem.descriptor=직렬화되지 않는 클래스 <code>#ref</code>이(가) 'serialVersionUID' 필드를 정의합니다 #loc
non.serializable.interface.with.serialversionuid.problem.descriptor=직렬화되지 않는 인터페이스 <code>#ref</code>이(가) 'serialVersionUID' 필드를 정의합니다 #loc
non.serializable.@interface.with.serialversionuid.problem.descriptor=직렬화되지 않는 @interface <code>#ref</code>이(가) 'serialVersionUID' 필드를 정의합니다 #loc
non.serializable.anonymous.with.serialversionuid.problem.descriptor=<code>#ref</code>에서 파생된 비 Serializable 익명 클래스가 'serialVersionUID' 필드를 정의합니다 #loc
non.serializable.class.with.readwriteobject.display.name='readObject()' 또는 'writeObject()'가 있는 비 serializable 클래스
non.serializable.class.with.readwriteobject.problem.descriptor.both=비 Serializable <code>#ref</code>{0, choice, 1# 클래스|2# 인터페이스|3#에서 파생된 익명 클래스|4# 어노테이션 타입|5# 열거형|6# 레코드}이(가) 'readObject()' 및 'writeObject()'를 정의합니다 #loc
non.serializable.class.with.readwriteobject.problem.descriptor.write=비 Serializable <code>#ref</code>{0, choice, 1# 클래스|2# 인터페이스|3#에서 파생된 익명 클래스|4# 어노테이션 타입|5# 열거형|6# 레코드}이(가) 'writeObject()'를 정의합니다 #loc
non.serializable.class.with.readwriteobject.problem.descriptor.read=비 Serializable <code>#ref</code>{0, choice, 1# 클래스|2# 인터페이스|3#에서 파생된 익명 클래스|4# 어노테이션 타입|5# 열거형|6# 레코드}이(가) 'readObject()'를 정의합니다 #loc
readwriteobject.private.display.name='readObject()' 또는 'writeObject()'가 'private'으로 선언되지 않음
readwriteobject.private.problem.descriptor=<code>#ref()</code>이(가) 'private'으로 선언되지 않았습니다 #loc
readobject.initialization.display.name='readObject()'로 인스턴스 필드가 초기화되지 않을 수 있음
readobject.initialization.problem.descriptor=인스턴스 필드 <code>#ref</code>은(는) 'readObject()' 호출 중에 초기화할 수 없습니다 #loc
readresolve.writereplace.protected.display.name='readResolve()' 또는 'writeReplace()'가 'protected'로 선언되지 않음
readresolve.writereplace.protected.problem.descriptor=<code>#ref()</code>이(가) 'protected'로 선언되지 않았습니다 #loc
missing.serial.annotation.display.name='@Serial' 어노테이션 사용 가능
missing.serial.annotation.on.field.problem.descriptor=<code>#ref</code>에 '@Serial' 어노테이션을 추가할 수 있습니다
missing.serial.annotation.on.method.problem.descriptor=<code>#ref()</code>에 '@Serial' 어노테이션을 추가할 수 있습니다
serial.annotation.used.on.wrong.member.display.name='@Serial' 어노테이션이 잘못된 멤버에 사용됨
serial.annotation.used.on.wrong.member.problem.descriptor=어노테이션이 추가된 멤버가 직렬화 메커니즘에 포함되지 않습니다
serializable.record.contains.ignored.members.display.name='record'가 무시된 멤버 포함
serializable.record.contains.ignored.field.problem.descriptor=<code>#ref</code>은(는) 레코드 직렬화가 진행되는 동안 무시됩니다
serializable.record.contains.ignored.method.problem.descriptor=<code>#ref()</code>은(는) 레코드 직렬화가 진행되는 동안 무시됩니다
serialpersistentfields.with.wrong.signature.display.name='serialPersistentFields' 필드가 'private static final ObjectStreamField[]'로 선언되지 않음
serialpersistentfields.with.wrong.signature.problem.descriptor=serializable 클래스의 <code>#ref</code> 필드가 'private static final ObjectStreamField[]'로 선언되지 않았습니다 #loc
serialversionuid.private.static.final.long.display.name='serialVersionUID' 필드가 'private static final long'으로 선언되지 않음
serialversionuid.private.static.final.long.problem.descriptor=serializable 클래스의 <code>#ref</code> 필드가 'private static final long'으로 선언되지 않았습니다 #loc
serialversionuid.private.static.final.long.quickfix=serialVersionUID를 'private static final'로 만듭니다.

#dynamic
non.protected.constructor.in.abstract.class.display.name=Abstract 클래스의 public 생성자
unnecessary.qualifier.for.this.display.name='this' 또는 'super'에 불필요한 한정자
multiple.declaration.display.name=하나의 선언 내 여러 변수
thread.priority.display.name='Thread.setPriority()' 호출
too.broad.scope.display.name=변수의 범위가 너무 넓음
infinite.loop.statement.display.name=무한 루프 문
asserts.without.messages.display.name=어설션에서 메시지 누락
constant.naming.convention.element.description=상수
constant.with.mutable.field.naming.convention.element.description=가변 타입이 있는 상수
random.double.for.random.integer.display.name='Random.nextDouble()'을 사용하여 임의의 정수 얻기
test.method.without.assertion.display.name=어설션 없는 JUnit 테스트 메서드
string.buffer.replaceable.by.string.builder.display.name='StringBuffer'가 'StringBuilder'가 될 수 있음
comparison.of.short.and.char.display.name='short' 및 'char' 값 비교
unnecessary.fully.qualified.name.display.name=불필요한 정규화된 이름
ignore.in.module.statements.option=Java 9 모듈 구문에서 무시
unnecessary.label.on.break.statement.display.name='break' 문의 불필요한 라벨
exception.name.doesnt.end.with.exception.display.name=예외 클래스 이름이 'Exception'으로 끝나지 않음
bad.exception.declared.display.name=금지된 예외 선언
pointless.boolean.expression.display.name=무의미한 구문 또는 부울 표현식
class.without.constructor.display.name=생성자가 없는 클래스
break.statement.display.name='break' 문
unconditional.wait.display.name=조건 없는 'wait()' 호출
cyclomatic.complexity.display.name=지나치게 복잡한 메서드
final.class.display.name=클래스는 상속할 수 없습니다
labeled.statement.display.name=라벨 지정된 구문
notify.called.on.condition.display.name='java.util.concurrent.locks.locks.Condition' 객체에서 'notify()' 또는 'notifyAll()' 호출
loop.statements.that.dont.loop.display.name=루프를 실행하지 않는 루프 문
ignore.enhanced.for.loop.statements=향상된 for 루프 무시
non.synchronized.method.overrides.synchronized.method.display.name=비동기화된 메서드가 'synchronized' 메서드를 재정의합니다.
synchronize.on.this.display.name='this' 동기화
switch.statement.with.too.many.branches.display.name=최대 'switch' 브랜치
utility.class.without.private.constructor.display.name='private' 생성자가 없는 유틸리티 클래스
throw.caught.locally.display.name='try' 문을 포함하여 'throw' 포착
exception.from.catch.which.doesnt.wrap.display.name=포착한 예외를 무시하는 'catch' 블록 내 'throw'
type.parameter.naming.convention.element.description=타입 매개변수
multiply.or.divide.by.power.of.two.display.name=2의 거듭제곱으로 곱하기 또는 나누기
multiply.or.divide.by.power.of.two.divide.option=2의 거듭제곱으로 나누기 검사
serializable.with.unconstructable.ancestor.display.name=생성할 수 없는 조상을 가진 Serializable 클래스
missorted.modifiers.display.name=잘못 정렬된 제어자
sleep.while.holding.lock.display.name='Thread.sleep()'을 동기화 중에 호출 #loc
singleton.display.name=싱글턴
thread.death.rethrown.display.name='ThreadDeath'가 다시 던져지지 않음
if.statement.with.too.many.branches.display.name=브랜치가 너무 많은 'if' 문
redundant.implements.display.name=중복 인터페이스 선언
nesting.depth.display.name=지나치게 중첩된 메서드
return.this.display.name='this' 반환
busy.wait.display.name=바쁜 대기
utility.class.display.name=유틸리티 클래스
instantiating.object.to.get.class.object.display.name='Class' 객체를 얻기 위해 객체를 인스턴스화
abstract.class.extends.concrete.class.display.name=추상 클래스가 구체 클래스를 확장
parameter.naming.convention.display.name=메서드 매개변수 이름 지정 규칙
parameter.naming.convention.element.description=매개변수
integer.division.in.floating.point.context.display.name=부동소수점 컨텍스트의 정수 나누기
interface.naming.convention.element.description=인터페이스
length.one.strings.in.concatenation.display.name=단일 문자 문자열 연결
length.one.string.in.indexof.display.name= 'String.indexOf()' 호출의 단일 문자열 인수
thread.yield.display.name='Thread.yield()' 호출
confusing.floating.point.literal.display.name=혼동되는 부동소수점 리터럴
wait.not.in.loop.display.name='wait()'가 루프에서 호출되지 않음
string.concatenation.inside.string.buffer.append.display.name='StringBuilder.append()' 호출에 대한 인수로서의 문자열 연결
class.initializer.display.name=비 'static' 이니셜라이저
enumerated.class.naming.convention.element.description=열거형 클래스
non.thread.safe.lazy.initialization.display.name='static' 필드의 안전하지 않은 지연 초기화
call.to.simple.setter.in.class.display.name=클래스 내에서 간단한 setter 호출
comparison.to.nan.display.name='Double.NaN' 또는 'Float.NaN'과 비교
new.method.naming.convention.display.name=메서드 이름 지정 규칙
instance.method.naming.convention.element.description=인스턴스 메서드
unnecessary.semicolon.display.name=불필요한 세미콜론
fallthru.in.switch.statement.display.name='switch' 문의 폴스루
call.to.native.method.while.locked.display.name='native' 메서드가 잠긴 상태에서 해당 메서드 호출
switch.statement.display.name='switch' 문
custom.classloader.display.name=사용자 지정 'ClassLoader'가 선언됨
nested.conditional.expression.display.name=중첩된 조건식
duplicate.condition.display.name=중복 조건
method.with.multiple.loops.display.name=여러 루프가 있는 메서드
non.comment.source.statements.display.name=지나치게 긴 메서드
local.variable.naming.convention.display.name=지역 변수 이름 지정 규칙
local.variable.naming.convention.element.description=지역 변수
negated.if.else.display.name=부정된 조건이 있는 'if' 문
class.naming.convention.display.name=클래스 이름 지정 규칙
class.naming.convention.element.description=클래스
abstract.class.naming.convention.element.description=추상 클래스
serializable.inner.class.with.non.serializable.outer.class.display.name=직렬화할 수 없는 외부 클래스와 직렬화 가능한 <0>static</0>이 아닌 내부 클래스
pointless.arithmetic.expression.display.name=무의미한 산술 표현식
method.name.same.as.class.name.display.name=클래스 이름과 동일한 메서드 이름
unnecessary.temporary.on.conversion.to.string.display.name='String'으로 변환 시 불필요한 임시 객체
unnecessary.continue.display.name=불필요한 'continue' 문
inner.class.on.interface.display.name=인터페이스의 내부 클래스
unused.label.display.name=사용되지 않는 라벨
overly.complex.boolean.expression.display.name=지나치게 복잡한 부울 표현식
continue.statement.with.label.display.name=라벨이 있는 'continue' 문
class.loader.instantiation.display.name='ClassLoader' 인스턴스화
return.from.finally.block.display.name='finally' 블록 내 'return'
unnecessary.boxing.display.name=불필요한 박싱
annotation.naming.convention.element.description=어노테이션 인터페이스
checked.exception.class.display.name=검사된 예외 클래스
switch.statement.with.confusing.declaration.display.name=지역 변수가 다른 'switch' 브랜치에서 사용 및 선언됨
cast.that.loses.precision.display.name=정밀도를 잃는 숫자 형 변환
manual.array.copy.display.name=수동 배열 복사
manual.array.to.collection.copy.display.name=수동으로 배열에서 컬렉션으로 복사
long.literals.ending.with.lowercase.l.display.name='L' 대신 'l'로 끝나는 'long' 리터럴
overly.complex.arithmetic.expression.display.name=지나치게 복잡한 산술 표현식
junit.abstract.test.class.naming.convention.element.description=추상 테스트 클래스
unnecessary.parentheses.display.name=불필요한 소괄호
test.case.in.product.code.display.name=제품 소스의 JUnit 'TestCase'
test.method.in.product.code.display.name=제품 소스의 JUnit 테스트 메서드
serializable.class.in.secure.context.display.name=안전한 컨텍스트의 Serializable 클래스
static.variable.naming.convention.element.description='static' 필드
nested.method.call.display.name=중첩된 메서드 호출
throw.from.finally.block.display.name='finally' 블록 내 'throw'
field.accessed.synchronized.and.unsynchronized.display.name='synchronized' 및 비동기화 컨텍스트 모두에서 액세스되는 필드
abstract.method.overrides.abstract.method.display.name=추상 메서드가 추상 메서드를 재정의
static.non.final.field.display.name='static' 및 비 'final' 필드
static.non.final.field.option='public' 필드만 보고
class.without.no.arg.constructor.display.name=비인수 생성자가 없는 클래스
unnecessary.return.display.name=불필요한 'return' 문
final.static.method.display.name='static' 메서드를 'final'로 선언
constant.declared.in.abstract.class.display.name=상수를 'abstract' 클래스로 선언
too.broad.catch.display.name=지나치게 넓은 'catch' 블록
floating.point.equality.display.name=부동소수점 상등 비교
thrown.exceptions.per.method.display.name=예외가 너무 많은 메서드 선언
public.static.array.field.display.name='public static' 배열 필드
await.not.in.loop.display.name='await()'가 루프에서 호출되지 않음
method.names.differ.only.by.case.display.name=대/소문자만 다른 메서드 이름
unsecure.random.number.generation.display.name=안전하지 않은 난수 생성
parameters.per.method.display.name=매개변수가 너무 많은 메서드
parameters.per.constructor.display.name=매개변수가 너무 많은 생성자
unnecessary.unboxing.display.name=불필요한 언박싱
extends.thread.display.name=클래스가 'Thread'를 바로 확장
test.case.with.constructor.display.name=자명하지 않은 생성자가 있는 JUnit TestCase
parameter.name.differs.from.overridden.parameter.display.name=매개변수 이름이 재정의되거나 오버로드된 메서드의 매개변수와 다름
final.private.method.display.name='private' 메서드를 'final'로 선언
enum.switch.statement.which.misses.cases.display.name=case가 누락된 열거형 'switch' 문
enum.switch.statement.which.misses.cases.option=디폴트 브랜치가 있는 switch 문 무시
string.buffer.must.have.initial.capacity.display.name=초기 용량이 없는 'StringBuilder'
method.may.be.static.display.name=메서드를 'static'으로 만들 수 있음
class.initializer.may.be.static.display.name=클래스 이니셜라이저가 'static'이 될 수 있음
class.initializer.option=클래스에 하나 이상의 생성자가 있는 경우에만 경고
class.initializer.move.code.to.constructor.quickfix=이니셜라이저 코드를 생성자로 이동합니다.
nested.switch.statement.display.name=중첩된 'switch' 문
c.style.array.declaration.display.name=C 스타일 배열 선언
final.method.in.final.class.display.name='final' 클래스의 'final' 메서드
extends.annotation.display.name=클래스가 어노테이션 인터페이스를 확장
naked.notify.display.name=해당하는 상태 변경 없는 'notify()' 또는 'notifyAll()'
switch.statement.density.display.name=브랜치 밀도가 너무 낮은 'switch' 문
switch.statement.with.too.few.branches.display.name=최소 'switch' 브랜치
upper.case.field.name.not.constant.display.name=대문자 이름을 가진 상수가 아닌 필드
unnecessary.label.on.continue.statement.display.name='continue' 문의 불필요한 라벨
jdbc.prepare.statement.with.non.constant.string.display.name=비상수 문자열이 있는 'Connection.prepare*()' 호출
synchronize.on.non.final.field.display.name=final이 아닌 필드 동기화
noop.method.in.abstract.class.display.name=추상 클래스에 NOP 메서드 사용
non.final.field.of.exception.display.name='Exception' 클래스의 비 final 필드
nested.try.statement.display.name=중첩된 'try' 문
condition.signal.display.name='signalAll()' 대신 'signal()' 호출
jdbc.execute.with.non.constant.string.display.name=비상수 문자열이 있는 'Statement.execute()' 호출
system.set.security.manager.display.name='System.setSecurityManager()' 호출
system.set.security.manager.problem.descriptor=<code>System.#ref()</code> 호출로 보안 문제가 발생할 수 있습니다 #loc
control.flow.statement.without.braces.display.name=중괄호가 없는 흐름 제어문
trivial.if.display.name=중복 'if' 문
trivial.if.fix.family.name='if else' 단순화
trivial.if.option.ignore.chained=체인 'if' 문 무시
thread.with.default.run.method.display.name=디폴트 'run()' 메서드로 스레드 초기화
while.loop.spins.on.field.display.name=필드에서 'while' 루프 스핀
while.loop.spins.on.field.fix.family.name=스핀 루프 수정
while.loop.spins.on.field.fix.volatile=''{0}''을(를) volatile으로 만듭니다.
while.loop.spins.on.field.fix.spinwait=Thread.onSpinWait() 추가
while.loop.spins.on.field.fix.volatile.spinwait=''{0}''을(를) volatile으로 만들고 Thread.onSpinWait()를 추가합니다
if.statement.with.identical.branches.display.name=브랜치가 동일한 'if' 문
inspection.common.if.parts.message.variables.only=''if''에서 변수를 추출합니다{0}
inspection.common.if.parts.message.with.variables.extract=''if''에서 변수를 가진 공통 부분 추출{0}
inspection.common.if.parts.message.without.variables.extract=''if''에서 공통 부분 추출{0}
inspection.common.if.parts.message.whole.branch=브랜치를 제거하여 공통 부분 추출{0}
inspection.common.if.parts.message.complete.duplicate=''if'' 구문{0} 접기
inspection.common.if.parts.message.complete.duplicate.side.effect='if' 문을 접고 부수 효과를 추출
inspection.common.if.parts.description.variables.only=''if''에서 변수 추출 가능{0}
inspection.common.if.parts.description.with.variables.extract=''if''에서 변수가 포함된 공통 부분 추출 가능{0}
inspection.common.if.parts.description.without.variables.extract=''if''에서 공통 부분 추출 가능{0}
inspection.common.if.parts.description.whole.branch=브랜치를 제거하여 공통 부분을 추출할 수 있습니다{0}
inspection.common.if.parts.description.complete.duplicate=''if'' 문을 접을 수 있습니다{0}
inspection.common.if.parts.description.complete.duplicate.side.effect=부수 효과 추출을 활용해 'if' 문을 접을 수 있습니다
inspection.note.may.change.semantics=의미가 변경될 수 있습니다
multiple.return.points.per.method.display.name=여러 반환점이 있는 메서드
break.statement.with.label.display.name=라벨이 있는 'break' 문
public.constructor.in.non.public.class.display.name=비 public 클래스의 'public' 생성자
questionable.name.display.name=의심스러운 이름
empty.finally.block.display.name=빈 'finally' 블록
abstract.method.overrides.concrete.method.display.name=추상 메서드가 구체 메서드를 재정의
thread.stop.suspend.resume.display.name='Thread.stop()', 'suspend()' 또는 'resume()' 호출
constant.math.call.display.name=지속적 'Math' 호출
volatile.array.field.display.name=volatile 배열 필드
literal.as.arg.to.string.equals.display.name=문자열 리터럴은 'equals()' 한정자일 수 있습니다
inner.class.may.be.static.display.name=내부 클래스가 'static'이 될 수 있음
redundant.field.initialization.display.name=중복 필드 초기화
string.buffer.to.string.in.concatenation.display.name=연결된 'StringBuilder.toString()'
utility.class.with.public.constructor.display.name='public' 생성자가 있는 유틸리티 클래스
for.loop.replaceable.by.while.display.name='for' 루프를 'while' 루프로 바꿀 수 있음
missing.deprecated.annotation.display.name='@Deprecated' 어노테이션 누락
cloneable.class.in.secure.context.display.name=안전한 컨텍스트의 cloneable 클래스
static.inheritance.display.name=정적 상속
class.name.prefixed.with.package.name.display.name=패키지 이름 앞에 붙어 있는 클래스 이름
call.to.simple.getter.in.class.display.name=클래스 내에서 간단한 getter 호출
class.name.differs.from.file.name.display.name=클래스 이름이 파일 이름과 다름
protected.member.in.final.class.display.name='final' 클래스의 'protected' 멤버
load.library.with.non.constant.string.display.name=비상수 문자열이 있는 'Statement.loadLibrary()' 호출
instanceof.catch.parameter.display.name='catch' 매개변수에 대한 'instanceof'
implicit.numeric.conversion.display.name=묵시적 숫자 변환
confusing.main.method.display.name=혼동되는 'main()' 메서드
octal.literal.display.name=8진 정수
misordered.assert.equals.arguments.display.name=잘못 정렬된 'assertequals()'인수
unnecessary.constructor.display.name=중복 비인수 생성자
method.name.same.as.parent.name.display.name=상위 클래스 이름과 동일한 메서드 이름
while.can.be.foreach.display.name='while' 루프를 향상된 'for' 루프로 바꿀 수 있음
big.decimal.equals.display.name='BigDecimal'에서 'equals()' 호출
implicit.call.to.super.display.name='super()'를 묵시적으로 호출
unqualified.static.usage.display.name=정규화되지 않은 정적 액세스
simplifiable.junit.assertion.display.name=단순화 가능한 어설션
object.notify.display.name='notifyAll()' 대신 'notify()' 호출
thread.start.in.construction.display.name=객체 생성 중에 'Thread.start()' 호출
non.final.clone.display.name=안전한 컨텍스트의 비 final 'clone()'
unnecessary.temporary.on.conversion.from.string.display.name='String'에서 변환할 때 불필요한 임시 객체
unnecessary.this.display.name=불필요한 'this' 한정자
unnecessary.this.ignore.assignments.option=필드 대입 무시
runtime.exec.with.non.constant.string.display.name=비상수 문자열이 있는 'Runtime.exec()' 호출
system.properties.display.name=시스템 프로퍼티의 액세스
chained.method.call.display.name=체인 메서드 호출
safe.lock.display.name=락을 획득 했지만 안전하게 언락되지 않음
system.run.finalizers.on.exit.display.name='System.runFinalizersOnExit()' 호출
for.can.be.foreach.display.name='for' 루프를 향상된 루프로 바꿀 수 있음
type.parameter.extends.object.display.name=타입 매개변수가 명시적으로 'Object'를 확장
type.parameter.extends.object.ignore.annotated=java.lang.Object에 어노테이션이 추가된 경우 무시
marker.interface.display.name=마커 인터페이스
limited.scope.inner.class.display.name=지역 클래스
switch.statements.without.default.display.name='default' 브랜치가 없는 'switch' 문
unchecked.exception.class.display.name=검사되지 않은 'Exception' 클래스
for.loop.with.missing.component.display.name=구성 요소가 누락된 'for' 루프
for.loop.with.missing.component.collection.loop.option=컬렉션 반복 무시
double.checked.locking.display.name=이중 검사된 락
double.checked.locking.problem.descriptor=이중 검사된 락 #loc
string.buffer.replaceable.by.string.display.name='StringBuilder'를 'String'로 바꾸기 가능
boolean.method.name.must.start.with.question.display.name=부울 메서드 이름은 질문 단어로 시작해야 함
class.name.same.as.ancestor.name.display.name=조상의 이름과 동일한 클래스 이름
error.rethrown.display.name='Error'가 다시 던져지지 않음
serializable.has.serialization.methods.display.name='readObject()' 또는 'writeObject()'가 없는 serializable 클래스
serializable.has.serialization.methods.ignore.option=인스턴스 필드를 정의하지 않는 클래스 무시
missing.override.annotation.display.name='@Override' 어노테이션 누락
wait.while.holding.two.locks.display.name=두 개의 잠금을 유지하면서 'wait()'
empty.class.display.name=불필요한 빈 클래스
trivial.string.concatenation.display.name=빈 문자열과 연결
empty.synchronized.statement.display.name=빈 'synchronized' 문
unnecessary.default.display.name=열거형 'switch' 문의 불필요한 'default'
simplifiable.conditional.expression.display.name=단순화 가능한 조건식
unnecessary.super.constructor.display.name=불필요한 'super()' 호출
unnecessarily.qualified.static.usage.display.name=정적 액세스가 불필요하게 정규화되었습니다.
bad.exception.caught.display.name=금지된 'Exception' 포착
custom.security.manager.display.name=사용자 지정 'SecurityManager'
string.concatenation.in.loops.display.name=루프 내 문자열 연결
boolean.constructor.display.name=부울 생성자 호출
continue.statement.display.name='continue' 문
extends.object.display.name=클래스가 'Object'를 명시적으로 확장
serializable.inner.class.has.serial.version.uid.field.display.name='serialVersionUID'가 없는 Serializable 비 static 내부 클래스
static.method.naming.convention.element.description='static' 메서드
empty.try.block.display.name=빈 'try' 블록
field.has.setter.but.no.getter.display.name=필드에 setter는 있지만 getter가 없음
three.negations.per.method.display.name=3개 이상의 부정이 있는 메서드
conditional.expression.display.name=조건식
string.equals.empty.string.display.name='String.equals()'를 'String.isEmpty()'로 바꿀 수 있습니다
synchronize.on.lock.display.name='Lock' 객체 동기화
synchronized.on.literal.object.name=리터럴로 초기화된 객체 동기화
field.may.be.static.display.name=필드를 'static'으로 만들 수 있음
class.may.be.interface.display.name=추상 'class'가 'interface'가 될 수 있음
abstract.class.without.abstract.methods.display.name='abstract' 메서드가 없는 추상 클래스
divide.by.zero.display.name=0으로 나누기
default.not.last.case.in.switch.display.name='default'가 'switch'의 마지막 case가 아님
nested.synchronized.statement.display.name=중첩된 'synchronized' 문
constant.conditional.expression.display.name=상수 조건식
redundant.else.display.name=중복 'else'
public.field.accessed.in.synchronized.context.display.name='synchronized' 컨텍스트에서 비 private 필드 액세스
string.replaceable.by.string.buffer.display.name=비상수 'String'을 StringBuilder로 바꿀 수 있음
junit.test.class.naming.convention.element.description=테스트 클래스
junit.test.suite.naming.convention.element.description=테스트 스위트
method.coupling.display.name=지나치게 결합된 메서드
collections.must.have.initial.capacity.display.name=초기 용량이 없는 컬렉션
anonymous.inner.class.display.name=익명 내부 클래스는 내부 클래스로 대체될 수 있습니다
negated.conditional.display.name=부정된 조건이 있는 조건식
non.reproducible.math.call.display.name=재현 불가능한 'Math' 호출
multiple.top.level.classes.in.file.display.name=단일 파일 내 여러 최상위 클래스
set.replaceable.by.enum.set.display.name='Set'을 'EnumSet'으로 바꿀 수 있음
tail.recursion.display.name=꼬리 재귀
finally.block.cannot.complete.normally.display.name=정상적으로 완료되지 않는 'finally' 블록
non.atomic.operation.on.volatile.field.display.name='volatile' 필드에 대한 아토믹이 아닌 연산
public.static.collection.field.display.name='public static' 컬렉션 필드
non.exception.name.ends.with.exception.display.name=비예외 클래스 이름이 'Exception'으로 끝남
synchronized.method.display.name='synchronized' 메서드
enumerated.constant.naming.convention.element.description=열거형 상수
final.method.display.name=메서드가 재정의될 수 없습니다
transient.field.in.non.serializable.class.display.name=비 Serializable 클래스의 transient 필드
bad.exception.thrown.display.name=금지된 예외가 던져짐
conditional.expression.with.identical.branches.display.name=동일한 브랜치가 있는 조건식
conditional.can.be.pushed.inside.expression.display.name=조건을 브랜치 표현식 내부로 넣을 수 있음
conditional.can.be.pushed.inside.expression.option=조건이 메서드 호출의 인수일 뿐인 경우 무시
conditional.can.be.pushed.inside.expression.quickfix=브랜치 내부로 조건식을 푸시합니다.
raw.use.of.parameterized.type.display.name=매개변수화된 클래스의 원시 사용
standard.variable.names.display.name=표준 변수 이름
field.naming.convention.display.name=필드 이름 지정 규칙
instance.variable.naming.convention.element.description=인스턴스 필드
dollar.sign.in.name.display.name=식별자에서 '$' 사용
map.replaceable.by.enum.map.display.name='Map'을 'EnumMap'으로 바꿀 수 있음
extends.concrete.collection.display.name=클래스가 'Collection' 클래스를 명시적으로 확장
continue.or.break.from.finally.block.display.name='finally' 블록 내 'continue' 또는 'break'
abstract.method.with.missing.implementations.display.name=구현이 누락된 추상 메서드
object.allocation.in.loop.display.name=루프 내 객체 대입
wait.called.on.condition.display.name='java.util.concurrent.locks.locks.Condition' 객체에서 'wait()' 호출
test.case.with.no.test.methods.display.name=테스트가 없는 테스트 클래스
abstract.class.never.implemented.display.name=구체 하위 클래스가 없는 추상 클래스
interface.never.implemented.display.name=구체 하위 클래스가 없는 인터페이스
constant.declared.in.interface.display.name=인터페이스에서 선언된 상수


#problem descriptors
exception.name.doesnt.end.with.exception.problem.descriptor=예외 클래스 이름 <code>#ref</code>이(가) 'Exception'으로 끝나지 않습니다 #loc
non.exception.name.ends.with.exception.problem.descriptor=비예외 클래스 이름 <code>#ref</code>이(가) 'Exception'으로 끝납니다 #loc
class.name.prefixed.with.package.name.problem.descriptor=클래스 이름 <code>#ref</code>이(가) 패키지 이름으로 시작합니다 #loc
class.name.same.as.ancestor.name.problem.descriptor=클래스 이름 <code>#ref</code>이(가) 해당 상위 클래스의 이름 중 하나와 동일합니다 #loc
method.name.same.as.class.name.problem.descriptor=메서드 이름 <code>#ref</code>이(가) 해당 상위 클래스의 이름 중 하나와 동일합니다 #loc
method.name.same.as.parent.name.problem.descriptor=메서드 이름 <code>#ref</code>이(가) 해당 상위 클래스의 이름 중 하나와 동일합니다 #loc
boolean.method.name.must.start.with.question.problem.descriptor=부울 메서드 이름 <code>#ref</code>이(가) 질문 단어로 시작하지 않습니다 #loc
questionable.name.problem.descriptor=의심스러운 이름 <code>#ref</code> #loc
confusing.main.method.problem.descriptor='public static void main(String[])'이라는 시그니처 없이 <code>#ref</code>(으)로 이름 지정된 메서드 #loc
upper.case.field.name.not.constant.problem.descriptor=상수 스타일 이름을 가진 비상수 필드 <code>#ref</code> #loc
dollar.sign.in.name.problem.descriptor=식별자 <code>#ref</code>에 '$'가 포함되어 있습니다 #loc
integer.division.in.floating.point.context.problem.descriptor=<code>#ref</code>: 부동소수점 컨텍스트의 정수 나누기 #loc
comparison.of.short.and.char.problem.descriptor=short 및 char 값의 상등 비교 <code>#ref</code> #loc
big.decimal.equals.problem.descriptor=BigDecimal 값 사이의 <code>#ref()</code>은(는) 'compareTo()'여야 할 것입니다 #loc
divide.by.zero.problem.descriptor=0으로 나누기 #loc
non.reproducible.math.call.problem.descriptor=<code>Math.#ref()</code>이(가) 재현 불가능한 결과를 생성할 수 있습니다 #loc
constant.math.call.problem.descriptor=지속적인 <code>#ref()</code> 호출을 단순화할 수 있습니다 #loc
floating.point.equality.problem.descriptor=<code>#ref</code>: 부동소수점 값의 정확한 상등 비교 #loc
fallthru.in.switch.statement.problem.descriptor='switch' 문의 폴스루 #loc
switch.statements.without.default.problem.descriptor='default' 브랜치가 없는 <code>#ref</code> 문 #loc
default.not.last.case.in.switch.problem.descriptor=<code>#ref</code> 브랜치가 ''switch'' {0}의 마지막 case가 아닙니다 #loc
loop.statements.that.dont.loop.problem.descriptor=<code>#ref</code> 문에 루프가 없습니다 #loc
conditional.expression.with.identical.branches.problem.descriptor=동일한 브랜치가 있는 조건식 <code>#ref</code> #loc
conditional.can.be.pushed.inside.expression.problem.descriptor=조건식은 브랜치 내부로 푸시할 수 있습니다 #loc
duplicate.condition.problem.descriptor=중복 조건 <code>#ref</code> #loc
duplicate.condition.ignore.method.calls.option=부수 효과가 있는 조건 무시
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor='NoSuchElementException'을 던질 수 없는 <code>Iterator.#ref()</code> #loc
infinite.loop.statement.problem.descriptor=<code>#ref</code> 문은 예외를 던지지 않으면 완료되지 않습니다 #loc
confusing.floating.point.literal.problem.descriptor=부동소수점 리터럴 <code>#ref</code>이(가) 혼동됩니다 #loc
overly.complex.arithmetic.expression.problem.descriptor=지나치게 복잡한 산술 표현식 #loc
overly.complex.boolean.expression.problem.descriptor=지나치게 복잡한 부울 표현식({0}개 항) #loc
labeled.statement.problem.descriptor=라벨 지정된 구문 <code>#ref:</code> #loc
break.statement.with.label.problem.descriptor=라벨 지정된 <code>#ref</code> 문 #loc
continue.statement.with.label.problem.descriptor=라벨 지정된 <code>#ref</code> 문 #loc
conditional.expression.problem.descriptor=조건식 <code>#ref</code> #loc
conditional.expression.option=간단한 대입 및 반환 무시
conditional.expression.expression.context.option=if 문이 불가능한 위치 무시
conditional.expression.quickfix='if' 문으로 바꿉니다.
nested.conditional.expression.problem.descriptor=중첩된 조건식 <code>#ref</code> #loc
long.literals.ending.with.lowercase.l.problem.descriptor='long' 리터럴 <code>#ref</code>이(가) 소문자 'l'로 끝납니다 #loc
nested.switch.statement.problem.descriptor=중첩된 <code>#ref</code> {0} #loc
chained.method.call.problem.descriptor=체인 메서드 호출 <code>#ref()</code> #loc
nested.method.call.problem.descriptor=중첩된 메서드 호출 <code>#ref()</code> #loc
octal.literal.problem.descriptor=8진 정수 <code>#ref</code> #loc
implicit.call.to.super.problem.descriptor='super()'를 묵시적으로 호출합니다 #loc
negated.if.else.problem.descriptor=부정된 조건이 있는 <code>#ref</code> 문 #loc
negated.conditional.problem.descriptor=부정된 조건이 있는 조건식 #loc
redundant.else.problem.descriptor='if' 브랜치가 보통 절대 완료되지 않기 때문에 <code>#ref</code> 브랜치가 줄 바꿈 해제될 수 있습니다 #loc
switch.statement.with.confusing.declaration.problem.descriptor=지역 변수 <code>#ref</code>이(가) 한 'switch' 브랜치에서 선언되고 다른 브랜치에서 사용됩니다 #loc
final.class.problem.descriptor=<code>#ref</code>(으)로 선언된 클래스 #loc
empty.class.problem.descriptor=클래스 <code>#ref</code>이(가) 비어 있습니다 #loc
empty.enum.problem.descriptor=열거형 <code>#ref</code>이(가) 비어 있습니다 #loc
empty.class.file.without.class.problem.descriptor=Java 파일이 어떤 클래스도 선언하지 않습니다 #loc
empty.anonymous.class.problem.descriptor=익명 클래스가 비어 있습니다 #loc
anonymous.inner.class.problem.descriptor=익명의 내부 클래스 <code>#ref</code> #loc
limited.scope.inner.class.problem.descriptor=지역 클래스 <code>#ref</code> #loc
final.method.problem.descriptor=메서드가 <code>#ref</code>(으)로 선언되었습니다 #loc
class.initializer.problem.descriptor=비 'static' 이니셜라이저 #loc
class.may.be.interface.problem.descriptor=추상 클래스 <code>#ref</code>이(가) 인터페이스가 될 수 있습니다 #loc
non.protected.constructor.in.abstract.class.problem.descriptor=추상 클래스의 생성자 <code>#ref()</code>이(가) 'public'으로 선언되지 않았습니다 #loc
class.without.constructor.problem.descriptor=클래스 <code>#ref</code>에 생성자가 없습니다 #loc
abstract.class.without.abstract.methods.problem.descriptor=클래스 <code>#ref</code>이(가) 'abstract'로 선언되었으나 'abstract' 메서드가 없습니다 #loc
final.method.in.final.class.problem.descriptor=메서드가 'final' 클래스에서 <code>#ref</code>(으)로 선언되었습니다 #loc
protected.member.in.final.class.problem.descriptor='final' 클래스에서 <code>#ref</code>(으)로 선언된 클래스 멤버 #loc
utility.class.with.public.constructor.problem.descriptor=클래스 <code>#ref</code>에 'static' 멤버만 있고 'public' 생성자가 1개 있습니다 #loc
utility.class.without.private.constructor.problem.descriptor=클래스 <code>#ref</code>에 'static' 멤버만 있고 'private' 생성자가 없습니다 #loc
abstract.method.overrides.concrete.method.problem.descriptor=추상 메서드 <code>#ref()</code>이(가) 구체 메서드를 재정의합니다 #loc
abstract.method.with.missing.implementations.problem.descriptor=추상 메서드 <code>#ref()</code>이(가) 모든 하위 클래스에서 구현되어 있지 않습니다 #loc
abstract.method.overrides.abstract.method.problem.descriptor=추상 메서드 <code>#ref()</code>이(가) 추상 메서드를 재정의합니다 #loc
abstract.method.overrides.abstract.method.ignore.different.javadoc.option=해당하는 상위 메서드가 아닌 다른 Javadoc이 있는 메서드 무시
abstract.class.extends.concrete.class.problem.descriptor=클래스 <code>#ref</code>이(가) 'abstract'로 선언되고 구체 클래스를 확장합니다 #loc
static.non.final.field.problem.descriptor='static' 및 비 'final' 필드 <code>#ref</code> #loc
constant.declared.in.abstract.class.problem.descriptor=상수 <code>#ref</code>이(가) 추상 클래스에 선언되었습니다 #loc
constant.declared.in.interface.problem.descriptor=상수 <code>#ref</code>이(가) 인터페이스로 선언되었습니다 #loc
static.inheritance.problem.descriptor=인터페이스 <code>#ref</code>이(가) static 상수에 대해서만 구현됩니다 #loc
utility.class.problem.descriptor=클래스 <code>#ref</code>에 'static' 멤버만 있고 절차적 생성을 표시합니다 #loc
singleton.problem.descriptor=클래스 <code>#ref</code>는 싱글턴입니다 #loc
enum.singleton.problem.descriptor=열거형 <code>#ref</code>는 싱글턴입니다 #loc
final.private.method.problem.descriptor='private' 메서드가 <code>#ref</code>(으)로 선언되었습니다 #loc
noop.method.in.abstract.class.problem.descriptor=비 op 메서드 <code>#ref()</code>은(는) 추상으로 만들어야 합니다 #loc
final.static.method.problem.descriptor='static' 메서드가 <code>#ref</code>(으)로 선언되었습니다 #loc
class.without.no.arg.constructor.problem.descriptor=<code>#ref</code>에 비인수 생성자가 없습니다 #loc
multiple.top.level.classes.in.file.problem.descriptor=파일 내 여러 최상위 클래스
class.name.differs.from.file.name.problem.descriptor=클래스 이름 <code>#ref</code>이(가) 파일 이름과 다릅니다 #loc
marker.interface.problem.descriptor=마커 인터페이스 <code>#ref</code> #loc
field.has.setter.but.no.getter.problem.descriptor=필드 <code>#ref</code>에 setter는 있지만 getter가 없습니다 #loc
abstract.class.never.implemented.problem.descriptor=추상 클래스 <code>#ref</code>에 구체 하위 클래스가 없습니다 #loc
interface.never.implemented.problem.descriptor=인터페이스 <code>#ref</code>에 구체 하위 클래스가 없습니다 #loc
missing.deprecated.annotation.problem.descriptor='@Deprecated' 어노테이션 누락 #loc
missing.deprecated.tag.problem.descriptor='@deprecated' Javadoc 태그 설명 누락 #loc
missing.deprecated.tag.option=@deprecated Javadoc 태그 설명 누락 시 경고
missing.override.annotation.problem.descriptor=<code>#ref()</code>에 관한 '@Override' 어노테이션 누락 #loc
missing.override.annotation.in.overriding.problem.descriptor=재정의되는 메서드가 '@Override'로 어노테이션이 추가되지 않았습니다
non.thread.safe.lazy.initialization.problem.descriptor='static' 필드 <code>#ref</code>의 지연 초기화가 스레드 안전이 아닙니다 #loc
empty.finally.block.problem.descriptor=빈 <code>#ref</code> 블록 #loc
finally.block.cannot.complete.normally.problem.descriptor=<code>#ref</code> 블록이 정상적으로 완료되지 않습니다 #loc
empty.try.block.problem.descriptor=빈 <code>#ref</code> 블록 #loc
throw.from.finally.block.problem.descriptor='finally' 블록 내 <code>#ref</code> #loc
possible.throw.from.finally.block.problem.descriptor=<code>{0}</code>이(가) ''finally'' 블록 내에서 던져질 수 있습니다 #loc
throw,from.finally.block.everywhere.option=선언된 예외가 던져질 수 있는 모든 곳에 대해 경고
throw.caught.locally.problem.descriptor=포함하는 'try' 문에 <code>#ref</code>이(가) 포착되었습니다 #loc
throw.caught.locally.ignore.option=다시 던져진 예외 무시
return.from.finally.block.problem.descriptor='finally' 블록 내 'return' #loc
continue.or.break.from.finally.block.problem.descriptor='finally' 블록 내 <code>#ref</code> #loc
bad.exception.declared.problem.descriptor=금지된 예외 <code>#ref</code>이(가) 선언되었습니다 #loc
bad.exception.caught.problem.descriptor=금지된 예외 <code>#ref</code>이(가) 포착되었습니다 #loc
checked.exception.class.problem.descriptor=검사된 예외 클래스 <code>#ref</code> #loc
unchecked.exception.class.problem.descriptor=검사되지 않은 예외 클래스 <code>#ref</code> #loc
thread.death.rethrown.problem.descriptor=ThreadDeath <code>#ref</code>이(가) 다시 던져지지 않습니다 #loc
error.rethrown.problem.descriptor=오류 <code>#ref</code>이(가) 다시 던져지지 않습니다 #loc
nested.try.statement.problem.descriptor=중첩된 <code>#ref</code> 문 #loc
exception.from.catch.which.doesnt.wrap.problem.descriptor='catch' 블록 내부의 <code>#ref</code>이(가) 포착된 예외를 무시합니다 #loc
instanceof.catch.parameter.problem.descriptor='catch' 매개변수 <code>#ref</code>에 대한 'instanceof' #loc
non.final.field.of.exception.problem.descriptor=예외 클래스의 비 final 필드 <code>#ref</code> #loc
unnecessary.label.on.break.statement.problem.descriptor=Break 문에 불필요한 라벨 <code>#ref</code>이(가) 있습니다 #loc
unnecessary.label.on.continue.statement.problem.descriptor=Continue 문에 불필요한 라벨 <code>#ref</code>이(가) 있습니다 #loc
trivial.if.problem.descriptor=<code>#ref</code> 문을 단순화할 수 있습니다 #loc
unnecessary.parentheses.problem.descriptor=<code>#ref</code> 주변의 소괄호가 불필요합니다 #loc
unnecessary.local.variable.problem.descriptor=지역 변수 <code>#ref</code>이(가) 중복됩니다 #loc
unnecessary.this.problem.descriptor=<code>#ref</code>은(는) 이 컨텍스트에서 불필요합니다 #loc
unnecessary.block.statement.problem.descriptor=이 구문 주위에는 중괄호가 불필요합니다 #loc
unnecessary.continue.problem.descriptor=루프의 마지막 구문으로서 <code>#ref</code>은(는) 불필요합니다 #loc
unnecessary.semicolon.problem.descriptor=불필요한 세미콜론 <code>#ref</code> #loc
unnecessary.semicolon.ignore.after.enum.constants.option=열거형 상수 뒤의 불필요한 세미콜론 무시
unnecessary.fully.qualified.name.problem.descriptor1=한정자 <code>#ref</code>는 불필요하며 import 문으로 바꿀수 있습니다 #loc
unnecessary.fully.qualified.name.problem.descriptor2=한정자 <code>#ref</code>는 불필요하며 제거할 수 있습니다 #loc
unnecessary.qualifier.for.this.problem.descriptor='this'에 있는 한정자 <code>#ref</code>은(는) 이 컨텍스트에서 불필요합니다 #loc
unnecessary.qualifier.for.super.problem.descriptor='super'에 있는 한정자 <code>#ref</code>은(는) 이 컨텍스트에서 불필요합니다 #loc
unused.label.problem.descriptor=사용되지 않는 라벨 <code>#ref</code> #loc
redundant.field.initialization.problem.descriptor=<code>#ref</code>의 필드 초기화가 중복됩니다 #loc
redundant.implements.problem.descriptor=중복 인터페이스 선언 <code>#ref</code> #loc
extends.object.problem.descriptor=클래스 <code>#ref</code>이(가) 명시적으로 'java.lang.Object'를 확장합니다 #loc
type.parameter.extends.object.problem.descriptor1=타입 매개변수 <code>#ref</code>이(가) 명시적으로 'java.lang.Object'를 확장합니다 #loc
type.parameter.extends.object.problem.descriptor2=와일드카드 타입 인수 <code>#ref</code>이(가) 명시적으로 'java.lang.Object'를 확장합니다 #loc
unnecessary.super.constructor.problem.descriptor=<code>#ref</code>은(는) 불필요합니다 #loc
unnecessary.constructor.problem.descriptor=비인수 생성자 <code>#ref()</code>이(가) 중복됩니다 #loc
unnecessary.constructor.annotation.option=어노테이션이 있는 생성자 무시
for.loop.replaceable.by.while.problem.descriptor=<code>#ref</code> 루프 문은 'while' 루프로 바꿀수 있습니다 #loc
unnecessary.default.problem.descriptor=<code>#ref</code> 브랜치는 불필요합니다 #loc
unnecessary.default.expressions.option=switch 식만 보고
unnecessary.default.quickfix='default' 브랜치를 제거합니다.
unnecessary.boxing.problem.descriptor=불필요한 박싱 <code>#ref</code> #loc
unnecessary.boxing.inside.value.of.problem.descriptor=<code>#ref</code> 내 중복 박싱 #loc
unnecessary.unboxing.problem.descriptor=불필요한 언박싱 <code>#ref</code> #loc
unnecessary.boxing.superfluous.option=진정으로 불필요한 박싱된 표현식만 보고
unnecessary.unboxing.superfluous.option=진정으로 불필요한 언박싱된 표현식만 보고
for.can.be.foreach.problem.descriptor=<code>#ref</code> 루프를 향상된 'for'로 바꿀 수 있습니다 #loc
while.can.be.foreach.problem.descriptor=<code>#ref</code> 루프를 향상된 'for'로 바꿀 수 있습니다 #loc
too.broad.scope.problem.descriptor=변수 <code>#ref</code>의 범위가 너무 넓습니다 #loc
return.this.problem.descriptor=<code>#ref</code> 반환 #loc
constant.on.side.of.comparison.display.name=비교 시 잘못된 쪽에 있는 상수
constant.on.lhs.of.comparison.problem.descriptor=비교 중인 왼쪽의 상수 <code>#ref</code> #loc
constant.on.rhs.of.comparison.problem.descriptor=비교 중인 오른쪽의 상수 <code>#ref</code> #loc
control.flow.statement.without.braces.problem.descriptor=중괄호 없는 <code>{0}</code> #loc
missorted.modifiers.problem.descriptor=잘못 정렬된 제어자 <code>{0}</code> #loc
cstyle.array.variable.declaration.problem.descriptor={0, choice, 1#필드|2#매개변수|3#레코드 구성 요소|4#지역 변수} <code>#ref</code>의 C 스타일 배열 선언 #loc
cstyle.array.method.declaration.problem.descriptor=메서드 <code>#ref()</code>의 반환 타입의 C 스타일 배열 선언 #loc
multiple.declaration.problem.descriptor=하나의 선언 내 여러 변수 #loc
multiple.typed.declaration.problem.descriptor=하나의 선언 내 배열 크기가 다른 변수 #loc
serializable.inner.class.has.serial.version.uid.field.problem.descriptor=내부 클래스 <code>#ref</code>이(가) 'serialVersionUID' 필드를 정의하지 않습니다 #loc
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor=내부 클래스 <code>#ref</code>이(가) 직렬화되었으나 해당 외부 클래스는 그렇지 않습니다 #loc
busy.wait.problem.descriptor=루프 내 <code>Thread.#ref()</code>에 대한 호출이 바쁜 대기 중일 수 있습니다 #loc
sleep.while.holding.lock.problem.descriptor=<code>Thread.#ref()</code>이(가) 동기화 중에 호출됩니다 #loc
non.atomic.operation.on.volatile.field.problem.descriptor=volatile 필드 <code>#ref</code>의 비원자 연산 #loc
call.to.native.method.while.locked.problem.descriptor=동기화된 컨텍스트에서 기본 메서드 <code>#ref()</code>을(를) 호출합니다 #loc
object.notify.problem.descriptor=<code>#ref</code>을(를) 'notifyAll()'로 바꿔야 할 것입니다 #loc
condition.signal.problem.descriptor=<code>#ref</code>을(를) 'signalAll()'로 바꿔야 할 것입니다 #loc
thread.with.default.run.method.problem.descriptor=디폴트 'run()' 메서드로 <code>#ref</code>을(를) 초기화합니다 #loc
extends.thread.problem.descriptor=클래스 <code>#ref</code>이(가) 'java.lang.Thread'를 바로 확장합니다 #loc
anonymous.extends.thread.problem.descriptor=익명의 클래스가 'java.lang.Thread'를 바로 확장합니다 #loc
naked.notify.problem.descriptor=해당하는 상태 변경 없이 <code>#ref()</code>을(를) 호출합니다 #loc
unconditional.wait.problem.descriptor=<code>#ref()</code>을(를) 조건 없이 호출합니다 #loc
system.run.finalizers.on.exit.problem.descriptor=<code>System.#ref()</code>을(를) 호출합니다 #loc
thread.priority.problem.descriptor=<code>Thread.#ref()</code>을(를) 호출합니다 #loc
thread.yield.problem.descriptor=<code>Thread.#ref()</code>을(를) 호출합니다 #loc
thread.stop.suspend.resume.problem.descriptor=<code>Thread.#ref()</code>을(를) 호출합니다 #loc
while.loop.spins.on.field.problem.descriptor=<code>#ref</code> 루프가 필드에서 스핀합니다 #loc
wait.not.in.loop.problem.descriptor=<code>#ref()</code> 호출이 루프에 없습니다 #loc
await.not.in.loop.problem.descriptor=<code>#ref()</code> 호출이 루프에 없습니다 #loc
wait.called.on.condition.problem.descriptor=조건 객체에서 <code>#ref()</code>이(가) 호출됩니다 #loc
notify.called.on.condition.problem.descriptor=조건 객체에서 <code>#ref()</code>이(가) 호출됩니다 #loc
wait.while.holding.two.locks.problem.descriptor=<code>#ref()</code>이(가) 2개의 잠금을 유지하는 동안 호출됩니다 #loc
thread.run.problem.descriptor=<code>#ref()</code> 호출을 'start()'로 바꿔야 할 것입니다 #loc
thread.start.in.construction.problem.descriptor=<code>#ref()</code>이(가) 객체 생성 중에 호출되었습니다 #loc
synchronize.on.lock.problem.descriptor={0}'' 객체의 동기화가 의도된 것 같지 않습니다 #loc
synchronized.on.literal.object.problem.descriptor=리터럴로 초기화된 {0} <code>#ref</code> 동기화 #loc
synchronized.on.direct.literal.object.problem.descriptor={0} 리터럴 <code>#ref</code> 동기화 #loc
synchronized.on.possibly.literal.object.problem.descriptor={0} <code>#ref</code> 동기화 #loc
synchronize.on.non.final.field.problem.descriptor=final이 아닌 필드 <code>#ref</code> 동기화 #loc
synchronized.on.literal.object.warn.on.all.option=가능한 모든 리터럴에 대해 경고
synchronize.on.this.problem.descriptor='this'에 대한 잠금 작업으로 예기치 않은 부수 효과가 발생할 수 있습니다 #loc
synchronize.on.class.problem.descriptor=클래스에 대한 잠금 작업으로 예기치 않은 부수 효과가 발생할 수 있습니다 #loc
nested.synchronized.statement.problem.descriptor=중첩된 <code>#ref</code> 문 #loc
empty.synchronized.statement.problem.descriptor=빈 <code>#ref</code> 문 #loc
non.synchronized.method.overrides.synchronized.method.problem.descriptor=비동기화된 메서드 <code>#ref()</code>이(가) 동기화된 메서드를 재정의합니다 #loc
public.field.accessed.in.synchronized.context.problem.descriptor=동기화된 컨텍스트에서 비 private 필드 <code>#ref</code>이(가) 액세스됩니다 #loc
field.accessed.synchronized.and.unsynchronized.problem.descriptor=필드 <code>#ref</code>이(가) 동기화된 컨텍스트와 동기화되지 않은 컨텍스트 모두에서 액세스됩니다 #loc
extended.for.statement.problem.descriptor=확장된 <code>#ref</code> 문 #loc
object.allocation.in.loop.new.descriptor=루프 내 객체 대입 <code>new #ref()</code> #loc
object.allocation.in.loop.problem.array.initializer.descriptor=루프 내 배열 대입 #loc
object.allocation.in.loop.problem.call.descriptor=루프 내 <code>#ref()</code>을(를) 통한 객체 대입 #loc
object.allocation.in.loop.problem.methodref.descriptor=루프 내 인스턴스 바인드된 메서드 참조 <code>#ref()</code>을(를) 통한 객체 대입 #loc
object.allocation.in.loop.problem.lambda.descriptor=루프 내 람다 캡처를 통한 객체 대입 #loc
object.allocation.in.loop.problem.string.concat=루프 내 문자열 연결을 통한 객체 대입 #loc
instantiating.object.to.get.class.object.problem.descriptor=클래스 객체를 얻기 위해 객체를 인스턴스화합니다 #loc
field.may.be.static.problem.descriptor=필드 <code>#ref</code>이(가) 'static'이 될 수 있습니다 #loc
method.may.be.static.problem.descriptor=메서드 <code>#ref()</code>이(가) 'static'이 될 수 있습니다 #loc
class.initializer.may.be.static.problem.descriptor=클래스 이니셜라이저가 'static'이 될 수 있습니다 #loc
map.replaceable.by.enum.map.problem.descriptor=<code>#ref</code>을(를) 'EnumMap'으로 바꿀수 있습니다 #loc
set.replaceable.by.enum.set.problem.descriptor=<code>#ref</code>을(를) 'EnumSet'으로 바꿀수 있습니다 #loc
inner.class.may.be.static.problem.descriptor=내부 클래스 <code>#ref</code>이(가) 'static'이 될 수 있습니다 #loc
string.buffer.must.have.initial.capacity.problem.descriptor=초기 용량이 없는 <code>new #ref()</code> #loc
string.buffer.replaceable.by.string.builder.problem.descriptor=<code>StringBuffer #ref</code>은(는) 'StringBuilder'로 선언할 수 있습니다 #loc
string.buffer.replaceable.by.string.problem.descriptor=<code>{0} #ref</code>을(를) ''String''으로 바꿀수 있습니다 #loc
new.string.buffer.replaceable.by.string.problem.descriptor=<code>#ref</code>을(를) 'String'으로 바꿀수 있습니다 #loc
string.replaceable.by.string.buffer.problem.descriptor=비상수 <code>String #ref</code>은(는) 'StringBuilder'로 선언해야 할 것입니다.
collections.must.have.initial.capacity.problem.descriptor=초기 용량이 없는 <code>new #ref()</code> #loc
string.concatenation.in.loops.problem.descriptor=루프 내 문자열 연결 <code>#ref</code> #loc
string.concatenation.inside.string.buffer.append.problem.descriptor=<code>{0}.#ref()</code> 호출에 대한 인수로서의 문자열 연결 #loc
boolean.constructor.problem.descriptor=부울 생성자 호출 #loc
string.buffer.to.string.in.concatenation.problem.descriptor=연결에서 <code>{0}.#ref()</code>이(가) 호출됩니다 #loc
tail.recursion.problem.descriptor=꼬리 재귀 호출 <code>#ref()</code> #loc
string.equals.empty.string.problem.descriptor=<code>#ref("")</code>을(를) 'length()==0'(으)로 바꿀수 있습니다 #loc
string.equals.empty.string.is.empty.problem.descriptor=<code>#ref("")</code>을(를) 'isEmpty()'로 바꿀수 있습니다 #loc
random.double.for.random.integer.problem.descriptor=<code>Random.#ref</code>을(를) 사용하여 임의의 정수를 생성합니다 #loc
manual.array.copy.problem.descriptor=수동 배열 복사 #loc
manual.array.to.collection.copy.problem.descriptor=수동 배열로 컬렉션 복사 #loc
call.to.simple.getter.in.class.problem.descriptor=클래스 내에서 간단한 getter <code>#ref()</code>을(를) 호출합니다 #loc
call.to.simple.setter.in.class.problem.descriptor=클래스 내에서 간단한 setter <code>#ref()</code>을(를) 호출합니다 #loc
assert.without.message.problem.descriptor=메시지 없는 <code>#ref()</code> #loc
assert.without.message.quick.fix.family.name=오류 메시지 추가
test.case.with.constructor.problem.descriptor='setUp()'이 아닌 생성자 <code>#ref()</code>의 초기화 논리 #loc
test.case.with.constructor.problem.descriptor.initializer='setUp()'이 아닌 이니셜라이저의 초기화 논리
misordered.assert.equals.arguments.problem.descriptor=순서가 잘못된 <code>#ref()</code>에 대한 인수 #loc
simplifiable.junit.assertion.problem.descriptor=<code>#ref()</code>을(를) ''{0}''(으)로 단순화할 수 있습니다 #loc
test.method.without.assertion.problem.descriptor=JUnit 테스트 메서드 <code>#ref()</code>에 어설션이 없습니다 #loc
test.case.with.no.test.methods.problem.descriptor=테스트 클래스 <code>#ref</code>에 테스트가 없습니다 #loc
test.case.in.product.code.problem.descriptor=테스트 케이스 <code>#ref</code>을(를) 테스트 소스 트리에서 바꿔야 할 것입니다 #loc
test.method.in.product.code.problem.descriptor=테스트 메서드 <code>#ref()</code>을(를) 테스트 소스 트리에서 바꿔야 할 것입니다 #loc
deserializable.class.in.secure.context.problem.descriptor=클래스 <code>#ref</code>이(가) 비직렬화되어 보안이 취약해질 수 있습니다 #loc
serializable.class.in.secure.context.problem.descriptor=클래스 <code>#ref</code>이(가) 직렬화되어 보안이 취약해질 수 있습니다 #loc
serializable.deserializable.class.in.secure.context.problem.descriptor=클래스 <code>#ref</code>이(가) 직렬화 및 비직렬화되어 보안이 취약해질 수 있습니다 #loc
cloneable.class.in.secure.context.problem.descriptor=클래스 <code>#ref</code>이(가) 복제되어 보안이 취약해질 수 있습니다 #loc
cloneable.class.in.secure.context.quickfix=항상 예외를 던지는 'clone()' 메서드를 생성합니다.
remove.cloneable.quickfix='implements' 절에서 'Cloneable'을 제거
non.final.clone.problem.descriptor=비 final <code>#ref()</code> 메서드로 인해 보안이 취약해질 수 있습니다 #loc
runtime.exec.with.non.constant.string.problem.descriptor=비상수 인수가 있는 <code>Runtime.#ref()</code>을(를) 호출합니다 #loc
load.library.with.non.constant.string.problem.descriptor=비상수 인수가 있는 <code>{0}.#ref()</code>을(를) 호출합니다 #loc
jdbc.execute.with.non.constant.string.problem.descriptor=비상수 인수가 있는 <code>Statement.#ref()</code>을(를) 호출합니다 #loc
jdbc.prepare.statement.with.non.constant.string.problem.descriptor=비상수 인수가 있는 <code>Connection.#ref()</code>을(를) 호출합니다 #loc
custom.classloader.problem.descriptor=사용자 지정 ClassLoader 클래스 <code>#ref</code> #loc
custom.security.manager.problem.descriptor=사용자 지정 SecurityManager 클래스 <code>#ref</code> #loc
system.set.problem.descriptor=<code>System.#ref()</code> 호출로 보안 문제가 발생할 수 있습니다 #loc
class.loader.instantiation.problem.descriptor=<code>#ref</code> 인스턴스화로 보안 문제가 발생할 수 있습니다 #loc
public.static.array.field.problem.descriptor='public static' 배열 필드 <code>#ref</code>(으)로 인해 보안이 취약해질 수 있습니다 #loc
public.static.collection.field.problem.descriptor='public static' 컬렉션 필드 <code>#ref</code>(으)로 인해 보안이 취약해질 수 있습니다 #loc
abstract.class.with.only.one.direct.inheritor.problem.descriptor=추상 클래스 <code>#ref</code>에 직접 상속자가 하나만 있습니다 #loc

#other
abstract.method.overrides.abstract.method.remove.quickfix=중복 추상 메서드 선언을 제거합니다.
class.may.be.interface.convert.quickfix=클래스를 인터페이스로 변환합니다.
class.without.constructor.create.quickfix=빈 생성자를 생성합니다.
class.without.no.arg.constructor.ignore.option=클래스에 디폴트 생성자가 있는 경우 무시
extends.annotation.problem.descriptor=클래스 ''{0}''이(가) 어노테이션 인터페이스 <code>#ref</code>을(를) 구현합니다 #loc
extends.annotation.interface.problem.descriptor=인터페이스 ''{0}''이(가) 어노테이션 인터페이스 <code>#ref</code>을(를) 확장합니다 #loc
extends.concrete.collection.problem.descriptor=클래스 <code>#ref</code>이(가) 명시적으로 ''{0}''을(를) 확장합니다 #loc
anonymous.extends.concrete.collection.problem.descriptor=익명의 클래스가 ''{0}''을(를) 명시적으로 확장합니다 #loc
inner.class.on.interface.ignore.option=인터페이스의 내부 인터페이스 무시
inner.class.on.interface.problem.descriptor=인터페이스 ''{0}''에 내부 클래스 <code>#ref</code>이(가) 있습니다 #loc
missing.deprecated.annotation.add.quickfix=@Deprecated 어노테이션을 추가합니다
missing.add.deprecated.javadoc.tag.quickfix='@deprecated' Javadoc 태그를 추가합니다.
non.protected.constructor.in.abstract.class.ignore.option=비 public 클래스 무시
public.constructor.in.non.public.class.problem.descriptor=생성자가 비 public 클래스 ''{0}''에서 <code>#ref</code>(으)로 선언되었습니다 #loc
static.inheritance.replace.quickfix=상속을 {0}의 정규화된 참조로 바꿉니다.
utility.class.with.public.constructor.make.quickfix={0, choice, 1#생성자|2#생성자}를 'private'으로 만듭니다
utility.class.without.private.constructor.create.quickfix=빈 'private' 생성자를 생성합니다.
utility.class.without.private.constructor.make.quickfix=생성자를 'private'으로 만듭니다.
naming.convention.problem.descriptor.short={0} 이름 <code>#ref</code>이(가) 너무 짧습니다({1} < {2}) #loc
naming.convention.problem.descriptor.long={0} 이름 <code>#ref</code>이(가) 너무 깁니다({1} > {2}) #loc
naming.convention.problem.descriptor.regex.mismatch={0} 이름 <code>#ref</code>이(가) 정규식 ''{1}''와(과) 일치하지 않습니다 #loc
local.variable.naming.convention.ignore.option=for 루프 매개변수 무시
local.variable.naming.convention.ignore.catch.option='catch' 블록 매개변수 무시
method.names.differ.only.by.case.problem.descriptor=메서드 이름 <code>#ref</code>와(과) 메서드 이름 ''{0}''이(가) 대/소문자만 다릅니다 #loc
parameter.name.differs.from.overridden.parameter.ignore.character.option=재정의된 매개변수에 문자가 하나만 있는 경우 무시
parameter.name.differs.from.overridden.parameter.ignore.library.option=재정의된 매개변수가 라이브러리에서 온 경우 무시
parameter.name.differs.from.overridden.parameter.problem.descriptor=매개변수 이름 <code>#ref</code>이(가) {1, choice, 1#상위 메서드|2#오버로드된 메서드|3#상위 생성자|4#오버로드된 생성자}의 매개변수 ''{0}''와(과) 다릅니다 #loc
questionable.name.column.title=이름
questionable.name.list.label=보고된 이름:
standard.variable.names.problem.descriptor=이름이 <code>#ref</code>인 변수에 타입 ''{0}''이(가) 없습니다 #loc
standard.variable.names.problem.descriptor2=이름이 <code>#ref</code>인 변수에 타입 ''{0}'' 또는 ''{1}''이(가) 없습니다 #loc
standard.variable.names.ignore.override.option=상위 메서드 매개변수와 동일한 매개변수 이름 무시
boolean.method.name.must.start.with.question.table.column.name=부울 메서드 이름 접두사
boolean.method.name.must.start.with.question.table.label=부울 메서드 이름 접두사:
conditional.expression.with.identical.branches.collapse.quickfix=조건식을 접습니다.
redundant.else.unwrap.quickfix=중복 'else'를 제거합니다.
constant.conditional.expression.problem.descriptor=<code>#ref</code>을(를) ''{0}''(으)로 단순화할 수 있습니다 #loc
constant.conditional.expression.simplify.quickfix=단순화
constant.conditional.expression.simplify.quickfix.sideEffect=부수 효과를 추출하고 단순화
enum.switch.statement.which.misses.cases.problem.descriptor.single=열거형 ''{0}''에 대한 <code>#ref</code> 문에 case ''{1}''이(가) 없습니다 #loc
enum.switch.statement.which.misses.cases.problem.descriptor=열거형 ''{0}''에 대한 <code>#ref</code> 문에 case {1}이(가) 없습니다 #loc
for.loop.replaceable.by.while.ignore.option=조건 없는 루프의 'infinite' 무시
for.loop.with.missing.component.problem.descriptor1=<code>#ref</code> 문에 이니셜라이저가 없습니다 #loc
for.loop.with.missing.component.problem.descriptor2=<code>#ref</code> 문에 조건이 없습니다 #loc
for.loop.with.missing.component.problem.descriptor3=<code>#ref</code> 문에 업데이트가 없습니다 #loc
for.loop.with.missing.component.problem.descriptor4=<code>#ref</code> 문에 이니셜라이저 및 조건이 없습니다 #loc
for.loop.with.missing.component.problem.descriptor5=<code>#ref</code> 문에 이니셜라이저 및 업데이트가 없습니다 #loc
for.loop.with.missing.component.problem.descriptor6=<code>#ref</code> 문에 조건 및 업데이트가 없습니다 #loc
for.loop.with.missing.component.problem.descriptor7=<code>#ref</code> 문에 이니셜라이저, 조건 및 업데이트가 없습니다 #loc
foreach.replace.quickfix=향상된 'for'로 바꿉니다.
unnecessary.boxing.remove.quickfix=박싱을 제거합니다.
unnecessary.unboxing.remove.quickfix=언박싱 제거
misordered.assert.equals.arguments.flip.quickfix=비교된 인수 반전
simplify.junit.assertion.simplify.quickfix=어설션을 단순화합니다
system.properties.problem.descriptor=<code>Integer.#ref()</code> 호출로 보안 문제가 발생할 수 있습니다 #loc
system.properties.problem.descriptor1=<code>Boolean.#ref()</code> 호출로 보안 문제가 발생할 수 있습니다 #loc
unsecure.random.number.generation.problem.descriptor1=보안을 위해 <code>java.lang.Math.#ref()</code> 대신 'java.security.SecureRandom'을 사용합니다 #loc
unsecure.random.number.generation.problem.descriptor2=보안을 위해 <code>java.util.#ref</code> 대신 'java.security.SecureRandom'을 사용합니다 #loc
unsecure.random.number.generation.problem.descriptor3=보안을 위해 <code>#ref</code> 대신 'java.security.SecureRandom'을 사용합니다 #loc
serializable.has.serialization.methods.problem.descriptor=serializable 클래스 <code>#ref</code>이(가) 'readObject()' 또는 'writeObject()'를 정의하지 않습니다 #loc
serializable.has.serialization.methods.problem.descriptor1=serializable 클래스 <code>#ref</code>이(가) 'writeObject()'를 정의하지 않습니다 #loc
serializable.has.serialization.methods.problem.descriptor2=serializable 클래스 <code>#ref</code>이(가) 'readObject()'를 정의하지 않습니다 #loc
serializable.with.unconstructable.ancestor.problem.descriptor=<code>#ref</code>에 비인수 생성자가 없는 비 serializable 조상 ''{0}''이(가) 있습니다 #loc
transient.field.in.non.serializable.class.problem.descriptor=필드 ''{0}''이(가) 비 serializable 클래스에서 <code>#ref</code>(으)로 표시되었습니다 #loc
safe.lock.problem.descriptor=''{0}''은(는) ''try'' 블록 앞에서 잠기고 해당하는 ''finally'' 블록에서 잠금 해제되어야 합니다 #loc
synchronized.method.problem.descriptor=메서드 ''{0}()''이(가) <code>#ref</code>(으)로 선언되었습니다 #loc
synchronized.method.include.option=네이티브 메서드 포함
synchronized.method.ignore.synchronized.super.option=동기화된 메서드를 재정의하는 메서드 무시
synchronized.method.move.quickfix=동기화를 메서드로 이동합니다.
volatile.field.problem.descriptor=타입 ''{0}''의 volatile 필드 <code>#ref</code> #loc
string.format.choose.class=Formatter 클래스 선택
string.format.class.column.name=추가 Formatter 클래스
string.format.class.label=추가 formatter 클래스:
string.format.class.method.name=추가 Formatter 메서드
string.format.class.method.label=추가 formatter 메서드:
exception.class.column.name=예외 클래스
bad.exception.thrown.problem.descriptor=금지된 예외 ''{0}''이(가) 던져졌습니다 #loc
too.broad.catch.problem.descriptor=<code>#ref</code>의 ''catch''가 너무 넓어 예외 ''{0}''을(를) 마스킹합니다 #loc
too.broad.catch.problem.descriptor1=<code>#ref</code>의 ''catch''가 너무 넓어 예외 ''{0}'' 및 ''{1}''을(를) 마스킹합니다 #loc
add.serialversionuidfield.quickfix='serialVersionUID' 필드를 추가합니다.
delete.import.quickfix=불필요한 import 문 삭제
encapsulate.variable.quickfix=필드 ''{0}''을(를) 캡슐화합니다.
extract.method.quickfix=메서드 추출
inline.call.quickfix=호출을 인라인화합니다.
inline.variable.quickfix=변수 인라인화
pointless.nullcheck.display.name=메서드 호출 전 불필요한 'null' 검사
pointless.nullcheck.problem.descriptor.call=''{0}()'' 호출 전 불필요한 ''null'' 검사
remove.redundant.polyadic.operand.fix.name=불필요한 ''{0}'' 조건을 제거합니다.
remove.redundant.polyadic.operand.fix.family.name=불필요한 조건 제거
introduce.constant.quickfix=상수를 삽입합니다.
make.initialization.explicit.quickfix=초기화를 명시적으로 만듭니다.
move.anonymous.to.inner.quickfix=이름 지정된 내부 클래스로 변환합니다.
anonymous.inner.may.be.named.static.inner.class.quickfix=이름 지정된 'static' 내부 클래스로 변환합니다.
move.class.quickfix=클래스를 이동합니다.
normalize.declaration.quickfix=개별 선언으로 분할합니다.
remove.modifier.quickfix=''{0}'' 제어자를 제거합니다
replace.inheritance.with.delegation.quickfix=상속을 위임으로 바꾸기
cast.that.loses.precision.problem.descriptor=''{0}''에서 <code>#ref</code>(으)로 형 변환하면 정확성이 손실될 수 있습니다 #loc
cast.that.loses.precision.negative.problem.descriptor=''{0}''에서 <code>#ref</code>(으)로 형 변환하면 음의 인수 정확성이 손실될 수 있습니다 #loc
comparison.to.nan.problem.descriptor1=<code>#ref</code>와(과)의 비교는 항상 false입니다 #loc
comparison.to.nan.problem.descriptor2=<code>#ref</code>와(과)의 비교는 항상 true입니다 #loc
confusing.floating.point.literal.change.quickfix=표준 형식으로 변경
implicit.numeric.conversion.ignore.widening.conversion.option=변환 확장 무시
implicit.numeric.conversion.ignore.char.conversion.option='char'에서 또는 'char'로의 변환 무시
implicit.numeric.conversion.ignore.constant.conversion.option=상수 및 리터럴에서의 변환 무시
implicit.numeric.conversion.problem.descriptor=<code>#ref</code>을(를) ''{0}''에서 ''{1}''(으)로 묵시적 숫자 변환합니다 #loc
implicit.numeric.conversion.assignment.problem.descriptor=결과 값을 ''{0}''에서 ''{1}''(으)로 묵시적 숫자 변환합니다 #loc
implicit.numeric.conversion.make.explicit.quickfix=변환을 명시적으로 만듭니다.
non.reproducible.math.call.replace.quickfix='StrictMath' 호출로 바꿉니다.
overly.complex.arithmetic.expression.max.number.option=최대 항 수:
expression.can.be.replaced.problem.descriptor=<code>#ref</code>을(를) ''{0}''(으)로 바꿀수 있습니다 #loc
method.complexity.limit.option=메서드 복잡성 제한:
expression.can.be.replaced.no.quotes.problem.descriptor={0}을(를) {1}(으)로 바꿀수 있습니다.
cyclomatic.complexity.problem.descriptor=지나치게 복잡한 메서드 <code>#ref()</code>(순환 복잡도 = {0}) #loc
method.coupling.limit.option=메서드 결합 제한:
method.coupling.problem.descriptor=<code>#ref</code>이(가) 지나치게 결합되었습니다(참조된 클래스 수 = {0}) #loc
method.with.multiple.loops.problem.descriptor=<code>#ref</code>에 {0}개의 루프가 있습니다 #loc
return.point.limit.option=반환점 제한(&R):
multiple.return.points.per.method.problem.descriptor=<code>#ref</code>에 {0}개의 반환점이 있습니다 #loc
nesting.depth.limit.option=중첩 깊이 제한:
nesting.depth.problem.descriptor=<code>#ref</code>이(가) 지나치게 중첩되었습니다(최대 중첩 깊이 = {0}) #loc
non.comment.source.statements.limit.option=주석이 아닌 소스 구문 제한:
non.comment.source.statements.problem.descriptor=<code>#ref</code>이(가) 너무 깁니다(주석이 아닌 소스 구문 수 = {0}) #loc
parameters.per.method.problem.descriptor=<code>#ref()</code>에 매개변수가 너무 많습니다(매개변수 수 = {0}) #loc
parameters.per.constructor.problem.descriptor=<code>#ref()</code>에 매개변수가 너무 많습니다(매개변수 수 = {0}) #loc
parameter.limit.option=매개변수 제한:
constructor.visibility.option=가시성이 있는 생성자 무시:
three.negations.per.method.ignore.option='equals()' 메서드의 부정 무시
three.negations.per.method.ignore.assert.option='assert' 문의 부정 무시
three.negations.per.method.problem.descriptor=<code>#ref</code>에 {0}개의 부정이 있습니다 #loc
thrown.exceptions.per.method.problem.descriptor=<code>#ref</code>에 선언된 예외가 너무 많습니다(예외 수 = {0}) #loc
thrown.exceptions.per.method.limit.option=던져진 예외 제한:
call.to.simple.getter.in.class.ignore.option=다른 객체의 getter 호출 무시
call.to.private.simple.getter.in.class.option=getter가 'private'인 경우에만 보고
call.to.simple.getter.in.class.inline.quickfix=getter 호출을 인라인화합니다
call.to.simple.setter.in.class.ignore.option=다른 객체의 setter 호출 무시
call.to.private.setter.in.class.option=setter가 'private'인 경우에만 보고
call.to.simple.setter.in.class.inline.quickfix=setter 호출을 인라인화합니다.
make.static.quickfix='static'으로 설정합니다.
length.one.strings.in.concatenation.replace.quickfix=문자로 바꿉니다.
multiply.or.divide.by.power.of.two.replace.quickfix=시프트로 바꾸기
boolean.expression.can.be.simplified.problem.descriptor=<code>#ref</code>을(를) ''{0}''(으)로 단순화할 수 있습니다 #loc
boolean.expression.does.not.modify.problem.descriptor=<code>#ref</code>이(가) ''{0}'' 값을 한정하지 않습니다 #loc
boolean.expression.remove.compound.assignment.quickfix=무의미한 복합 대입을 제거합니다.
trivial.string.concatenation.problem.descriptor=연결에 사용되는 빈 문자열
string.replace.quickfix=연결을 ''{0}''(으)로 바꿉니다.
instantiating.object.to.get.class.object.replace.quickfix=클래스 객체 직접 액세스로 바꿉니다.
method.may.be.static.only.option='private' 또는 'final' 메서드만 검사
method.may.be.static.empty.option=빈 메서드 무시
string.concatenation.inside.string.buffer.append.replace.quickfix=체인 'append()' 호출로 바꿉니다.
string.equals.empty.string.option.do.not.add.null.check=null 검사가 필요한 경우 보고 안 함
tail.recursion.replace.quickfix=꼬리 재귀를 반복으로 바꿉니다.
if.statement.with.too.many.branches.max.option=최대 브랜치 수:
if.statement.with.too.many.branches.problem.descriptor=<code>#ref</code>에 브랜치가 너무 많습니다({0}) #loc
negated.conditional.invert.quickfix=조건을 반전시킵니다.
negated.if.else.ignore.negated.null.option='!=null' 비교 무시
negated.if.else.ignore.negated.zero.option='!= 0' 비교 무시
negated.if.else.invert.quickfix='if' 조건을 반전시킵니다.
overly.complex.boolean.expression.max.terms.option=최대 항 수:
pointless.boolean.expression.ignore.option=무의미한 표현식 결정 시 이름 지정된 상수 무시
simplifiable.conditional.expression.problem.descriptor=<code>{1}</code>을(를) ''{0}''(으)로 단순화할 수 있습니다 #loc
switch.statement.density.min.option=최소 브랜치 밀도: %
switch.statement.density.problem.descriptor=<code>#ref</code>의 브랜치 밀도가 너무 낮습니다({0}%) #loc
switch.statement.with.too.few.branches.min.option=최소 브랜치 수:
switch.statement.with.too.few.branches.problem.descriptor=''switch'' 문에 case 라벨이 너무 적어({0}) ''if'' 문으로 바꿔야 할 것입니다 #loc
switch.statement.with.single.default.message='switch' 문에 'default' case만 있습니다.
switch.expression.with.too.few.branches.problem.descriptor=''switch'' 식에 case 라벨이 너무 적어({0}) ''if'' 문 또는 조건 연산자로 바꿔야 할 것입니다 #loc
switch.expression.with.single.default.message='switch' 식에 'default' case만 있습니다.
switch.statement.without.default.ignore.option=완전한 switch 문 무시
unnecessary.label.remove.quickfix=라벨을 제거합니다.
unnecessary.return.problem.descriptor='void' 메서드의 마지막 구문으로서 <code>#ref</code>은(는) 불필요합니다 #loc
unnecessary.return.constructor.problem.descriptor=생성자의 마지막 구문으로서 <code>#ref</code>은(는) 불필요합니다 #loc
unused.label.remove.quickfix=사용되지 않는 라벨을 제거합니다.
unnecessarily.qualified.static.usage.problem.descriptor=static 메서드 호출 <code>{0}()</code>이(가) 불필요하게 정규화되었습니다 #loc
unnecessarily.qualified.static.usage.problem.descriptor1=static 액세스 <code>{0}()</code>이(가) 불필요하게 정규화되었습니다 #loc
unnecessarily.qualified.static.usage.ignore.field.option=불필요하게 정규화된 필드 액세스 무시
unnecessarily.qualified.static.usage.ignore.method.option=불필요하게 정규화된 메서드 호출 무시
unnecessary.interface.modifier.problem.descriptor=제어자 <code>#ref</code>이(가) 인터페이스와 중복됩니다 #loc
smth.unnecessary.remove.quickfix=불필요한 ''{0}''을(를) 제거합니다.
unqualified.static.usage.problem.descriptor=static 메서드 호출 <code>{0}()</code>이(가) 정규화되지 않았습니다 #loc
unqualified.static.usage.problem.descriptor1=static 필드 액세스 <code>{0}()</code>이(가) 정규화되지 않았습니다 #loc
unqualified.static.usage.ignore.field.option=정규화되지 않은 필드 액세스 무시
unqualified.static.usage.ignore.method.option=정규화되지 않은 메서드 호출 무시
unqualified.static.usage.qualify.field.quickfix=static 필드 액세스를 정규화합니다.
unqualified.static.usage.qualify.method.quickfix=static 메서드 호출을 정규화합니다.
too.broad.scope.allow.option=<html>new 식을 이니셜라이저로 가진 변수를 보고<br>(잠재적으로 안전하지 않음)</html>
too.broad.scope.only.blocks.option=내부 블록으로 이동할 수 있는 변수만 보고
too.broad.scope.narrow.quickfix=''{0}''의 선언을 사용 위치 가까이로 이동합니다.
press.escape.to.remove.highlighting.message=강조 표시를 제거하려면 ESC를 누릅니다
literal.as.arg.to.string.equals.problem.descriptor=리터럴 #ref은(는) ''{0}()''의 한정자가 아닌 인수입니다 #loc
literal.as.arg.to.string.equals.flip.quickfix=''{0}()''을(를) 반전시킵니다.
c.style.array.declaration.replace.quickfix=Java 스타일 배열 선언으로 바꿉니다.
chained.method.call.ignore.option=필드 이니셜라이저의 체인 메서드 호출 무시
chained.method.call.ignore.self.types.option=둘러싸는 클래스와 동일한 타입을 반환하는 메서드 호출 무시
introduce.variable.quickfix=변수 삽입
introduce.variable.may.change.semantics.quickfix=변수를 삽입합니다(의미가 변경될 수 있음).
flip.comparison.quickfix=비교 반전
control.flow.statement.without.braces.add.quickfix=구문에 중괄호를 추가합니다.
control.flow.statement.without.braces.message=''{0}'' 문에 중괄호를 추가합니다.
extends.object.remove.quickfix=중복 'extends Object'를 제거합니다.
implicit.call.to.super.ignore.option='java.lang.Object'의 직접 하위 클래스 무시
implicit.call.to.super.make.explicit.quickfix='super()'를 명시적으로 호출합니다.
missorted.modifiers.require.option=어노테이션 순서 검사
missorted.modifiers.typeuse.before.type.option=대상 TYPE_USE 어노테이션은 항상 타입 앞에 작성
missorted.modifiers.sort.quickfix=제어자 정렬
nested.method.call.ignore.option=필드 이니셜라이저의 중첩된 메서드 호출 무시
ignore.calls.to.static.methods=정적 메서드 호출 무시
ignore.calls.to.property.getters=프로퍼티 getter 호출 무시
redundant.field.initialization.remove.quickfix=이니셜라이저를 제거합니다.
redundant.implements.remove.quickfix=중복 인터페이스 선언을 제거합니다.
unnecessary.constructor.remove.quickfix=중복 생성자를 제거합니다.
unnecessary.fully.qualified.name.replace.quickfix=정규화된 이름을 import 문으로 바꿉니다.
unnecessary.fully.qualified.name.remove.quickfix=불필요한 정규화를 제거합니다.
unnecessary.fully.qualified.name.status.bar.escape.highlighting.message={0}개의 정규화된 {0, choice, 1#이름|2#이름}이 import 문으로 대체되었습니다(강조 표시를 제거하려면 Escape를 누르세요)
unnecessary.parentheses.remove.quickfix=불필요한 소괄호를 제거합니다.
unnecessary.qualifier.for.this.remove.quickfix=불필요한 한정자를 제거합니다.
unnecessary.semicolon.remove.quickfix=불필요한 세미콜론을 제거합니다.
unnecessary.super.constructor.remove.quickfix=불필요한 'super()'를 제거합니다.
unnecessary.this.remove.quickfix=불필요한 'this' 한정자를 제거합니다.
overly.strong.type.cast.problem.descriptor=<code>#ref</code>(으)로 형 변환하면 ''{0}''(으)로 약화될 수 있습니다 #loc
field.count.inspection.include.constant.fields.in.count.checkbox=계산 시 상수 필드 포함
field.count.inspection.static.final.fields.count.as.constant.checkbox='static final' 필드를 상수 계산
field.count.inspection.include.enum.constants.in.count=계산 시 열거형 상수 포함
make.method.final.fix.name=메서드 ''{0}()''을(를) ''final''로 설정
make.class.final.fix.name=클래스 ''{0}''을(를) ''final''로 설정
non.boolean.method.name.must.not.start.with.question.display.name=부울이 아닌 메서드 이름은 질문 단어로 시작하면 안 됩니다.
non.boolean.method.name.must.not.start.with.question.problem.descriptor=부울이 아닌 메서드 이름 <code>#ref</code>이(가) 질문 단어로 시작합니다 #loc
boolean.constructor.simplify.quickfix=단순화
unnecessary.temporary.on.conversion.from.string.problem.descriptor=<code>#ref</code>을(를) ''{0}''(으)로 단순화할 수 있습니다 #loc
only.report.qualified.static.usages.option=static 컨텍스트의 정규화된 static 액세스만 보고
unqualified,static.usage.only.report.static.usages.option=비 static 컨텍스트의 정규화된 static 액세스만 보고
assignment.to.catch.block.parameter.problem.descriptor='catch' 블록 매개변수 <code>#ref</code>에 대입되었습니다 #loc
assignment.to.method.parameter.problem.descriptor=메서드 매개변수 <code>#ref</code>에 대입되었습니다 #loc
value.of.post.increment.problem.descriptor=후행 증가 표현식 <code>#ref</code>의 값이 사용되었습니다 #loc
value.of.post.decrement.problem.descriptor=후행 감소 표현식 <code>#ref</code>의 값이 사용되었습니다 #loc
value.of.pre.increment.problem.descriptor=선행 증가 표현식 <code>#ref</code>의 값이 사용되었습니다 #loc
value.of.pre.decrement.problem.descriptor=선행 감소 표현식 <code>#ref</code>의 값이 사용되었습니다 #loc
assignment.replaceable.with.operator.assignment.problem.descriptor=<code>#ref</code>을(를) ''{0}''(으)로 단순화할 수 있습니다 #loc
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option=조건 연산자 무시
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option=모호한 ^ 및 % 연산자 무시
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option='private' 생성자만 있는 타입의 객체 사이에 있는 '==' 무시
redundant.method.override.display.name=메서드가 상위 메서드와 동일
redundant.method.override.delegates.to.super.problem.descriptor=메서드 <code>#ref()</code>은(는) 상위 메서드에만 위임합니다 #loc
redundant.method.override.problem.descriptor=메서드 <code>#ref()</code>이(가) 상위 메서드와 동일합니다 #loc
redundant.method.override.quickfix=중복 메서드를 제거합니다.
redundant.method.override.option.check.library.methods=라이브러리 메서드를 재정의하는 메서드 확인
refused.bequest.problem.descriptor=메서드 <code>#ref()</code>이(가) 'super.#ref()'을(를) 호출하지 않습니다 #loc
refused.bequest.ignore.empty.super.methods.option=빈 상위 메서드 무시
refused.bequest.ignore.default.super.methods.option='default' 상위 메서드 무시
overly.complex.boolean.expression.ignore.option=순수 결합어 및 분리어 무시
pointless.indexof.comparison.display.name=무의미한 'indexOf()' 비교
pointless.indexof.comparison.always.true.problem.descriptor=<code>#ref</code>이(가) 항상 true입니다 #loc
pointless.indexof.comparison.always.false.problem.descriptor=<code>#ref</code>이(가) 항상 false입니다 #loc
reuse.of.local.variable.problem.descriptor=지역 변수 <code>#ref</code> 재사용 #loc
single.character.startswith.display.name=단일 문자 'startsWith()' 또는 'endsWith()'
single.character.startswith.problem.descriptor=단일 문자 <code>#ref()</code>을(를) 'charAt()' 식으로 바꿀수 있습니다 #loc
list.indexof.replaceable.by.contains.display.name='List.indexOf()' 식을 'contains()'로 바꿀 수 있음
string.indexof.replaceable.by.contains.display.name='String.indexOf()' 식을 'contains()'로 바꿀 수 있음
overloaded.methods.with.same.number.parameters.problem.descriptor=매개변수의 수가 동일하고 이름이 <code>#ref</code>인 여러 메서드 #loc
overloaded.vararg.method.problem.descriptor=오버로드된 vararg 메서드 <code>#ref()</code> #loc
overloaded.vararg.constructor.problem.descriptor=오버로드된 vararg 생성자 <code>#ref()</code> #loc
cached.number.constructor.call.display.name=기본 인수가 있는 숫자 생성자 호출
cached.number.constructor.call.problem.descriptor=기본 인수가 있는 숫자 생성자 호출 #loc
cached.number.constructor.call.ignore.string.arguments.option=문자열 인수가 있는 새 숫자 표현식 무시
cached.number.constructor.call.report.only.deprecated=생성자가 @Deprecated인 경우에만 보고
chained.equality.comparisons.problem.descriptor=체인 상등 비교 <code>#ref</code> #loc
confusing.octal.escape.sequence.problem.descriptor=8진 이스케이프 시퀀스 <code>#ref</code>의 바로 뒤에 한 자릿수가 옵니다 #loc
field.accessed.synchronized.and.unsynchronized.option=간단한 getter와 setter도 필드 액세스로 간주됩니다
method.overrides.inaccessible.method.display.name=메서드가 상위 클래스의 메서드를 재정의
method.overrides.package.local.method.problem.descriptor=메서드 <code>#ref()</code>이(가) 다른 패키지에 있는 하위 클래스의 package-private 메서드를 재정의합니다 #loc
suspicious.to.array.call.display.name=의심스러운 'Collection.toArray()' 호출
suspicious.to.array.call.problem.descriptor=타입의 ''{0}[]''의 배열이 필요한데, ''{1}[]''이(가) 발견되었습니다 #loc
suspicious.system.arraycopy.display.name=의심스러운 'System.arraycopy()' 호출
suspicious.system.arraycopy.problem.descriptor4=<code>#ref</code>이(가) 배열 타입이 아닙니다 #loc
suspicious.system.arraycopy.problem.descriptor5=<code>#ref</code>이(가) 배열 타입이 아닙니다 #loc
suspicious.system.arraycopy.problem.descriptor6=소스 매개변수 타입 ''{0}''은(는) 타입 ''{1}''의 대상 매개변수 <code>#ref</code>에 대입할 수 없습니다 #loc
suspicious.system.arraycopy.problem.descriptor.length.bigger.src=길이가 ''src.length - srcPos'' {0}보다 항상 깁니다.
suspicious.system.arraycopy.problem.descriptor.length.bigger.dest=길이가 ''dest.length - destPos'' {0}보다 항상 깁니다.
suspicious.system.arraycopy.problem.descriptor.ranges.intersect=교차 범위가 있는 동일한 배열로 복사합니다.
method.only.used.from.inner.class.display.name=내부 클래스에서만 사용되는 private 메서드
method.only.used.from.inner.class.problem.descriptor=<code>#ref()</code>#loc 메서드는 ''{2}''{0, choice, 1# 내부 |2# 지역 |3#}{1, choice, 1# 클래스|2# 인터페이스|3#에서 파생된 익명 클래스|4# 어노테이션 타입|5# 열거형|6# 레코드}의 것만 사용됩니다 #loc
method.only.used.from.inner.class.ignore.option=익명 또는 지역 클래스에서 호출된 메서드 무시(&A)
only.report.static.methods='static' 메서드만 보고(&O)
single.character.startswith.quickfix='charAt()' 식으로 바꿉니다.
interface.never.implemented.option=상수만 선언하는 인터페이스 무시
size.replaceable.by.isempty.display.name='size() == 0'을 'isEmpty()'로 바꿀 수 있음
size.replaceable.by.isempty.negation.ignore.option='!isEmpty()'로 대체될 표현식 무시
size.replaceable.by.isempty.fix.ignore.calls=타입 ''{1}''에서 ''.{0}()'' 호출 무시
choose.class.type.to.ignore=무시할 클래스 선택
loop.condition.not.updated.inside.loop.display.name=루프 변수가 루프 내에서 업데이트되지 않음
loop.variable.not.updated.inside.loop.problem.descriptor=변수 '#ref'이(가) 루프 내에서 업데이트되지 않습니다 #loc
loop.condition.not.updated.inside.loop.problem.descriptor=조건 '#ref'이(가) 루프 내에서 업데이트되지 않습니다 #loc
loop.variable.not.updated.inside.loop.option.nonlocal=가능한 비 로컬 변경 내용 무시
utility.class.without.private.constructor.option=메인 메서드만 있는 클래스 무시
super.class.logger.option=상위 클래스에 액세스 가능한 로거가 있는 경우 무시
static.method.only.used.in.one.class.display.name=static 멤버가 다른 클래스에서만 사용됨
static.method.only.used.in.one.class.problem.descriptor=static {0, choice, 1#메서드|2#필드} <code>#ref{0, choice, 1#()|2#}</code>이(가) 클래스 ''{1}''에서만 사용됩니다 #loc
static.method.only.used.in.one.anonymous.class.problem.descriptor=static {0, choice, 1#메서드|2#필드} <code>#ref{0, choice, 1#()|2#}</code>이(가) ''{1}''에서 파생된 익명 클래스에서만 사용됩니다 #loc
static.method.only.used.in.one.class.quickfix={0}을(를) 사용 위치 클래스로 이동
static.method.only.used.in.one.class.ignore.test.option=테스트 클래스에서만 사용되는 경우 무시
static.method.only.used.in.one.class.ignore.anonymous.option=익명 클래스에서만 사용되는 경우 무시
static.method.only.used.in.one.class.ignore.on.conflicts=충돌 없이 메서드를 이동할 수 없는 경우 무시
static.method.only.used.in.one.class.ignore.utility.classes=유틸리티 클래스에 있는 멤버 무시
unary.plus.display.name=단항 덧셈
unary.plus.problem.descriptor=단항 <code>#ref</code> 연산자 #loc
await.without.corresponding.signal.display.name=해당하는 'signal()'이 없는 'await()'
await.without.corresponding.signal.problem.descriptor=해당하는 <code>signal()</code> 또는 <code>signalAll()</code> 없이 <code>#ref()</code>이(가) 호출되었습니다 #loc
signal.without.corresponding.await.display.name=해당하는 'await()'가 없는 'signal()'
signal.without.corresponding.await.problem.descriptor=해당하는 <code>await()</code> 없이 <code>#ref()</code>이(가) 호출되었습니다 #loc
wait.without.corresponding.notify.display.name=해당하는 'notify()'가 없는 'wait()'
wait.without.corresponding.notify.problem.descriptor=해당하는 <code>notify()</code> 또는 <code>notifyAll()</code> 없이 <code>#ref()</code>이(가) 호출되었습니다 #loc
notify.without.corresponding.wait.display.name=해당하는 'wait()'가 없는 'notify()'
notify.without.corresponding.wait.problem.descriptor=해당하는 <code>wait()</code> 없이 <code>#ref()</code>이(가) 호출되었습니다 #loc
integer.multiplication.implicit.cast.to.long.display.name=정수 곱하기 또는 시프트가 'long'으로 묵시적 형 변환
integer.multiplication.implicit.cast.to.long.problem.descriptor=#ref: 정수 곱하기가 long으로 묵시적 형 변환을 합니다 #loc
integer.multiplication.implicit.cast.to.long.quickfix=long으로 형 변환합니다.
integer.shift.implicit.cast.to.long.problem.descriptor=#ref: 정수가 long으로 묵시적 형 변환 시프트 #loc
integer.multiplication.implicit.cast.to.long.option=<html>오버플로가 불가능하다는 것이 정적으로 입증된 표현식 무시</html>
wait.or.await.without.timeout.display.name=시간 제한 없는 'wait()' 또는 'await()'
wait.or.await.without.timeout.problem.descriptor=시간 제한 없는 <code>#ref</code> #loc
method.return.always.constant.display.name=메서드가 클래스별 상수를 반환
method.return.always.constant.problem.descriptor=메서드 <code>#ref()</code> 및 모든 파생 항목이 항상 상수를 반환합니다.
class.with.too.many.dependencies.display.name=종속성이 너무 많은 클래스
class.with.too.many.dependencies.problem.descriptor=클래스 ''{0}''에 종속성이 너무 많습니다({1} > {2}).
class.with.too.many.transitive.dependencies.display.name=이행적 종속성이 너무 많은 클래스
class.with.too.many.transitive.dependencies.problem.descriptor=클래스 ''{0}''에 이행적 종속성이 너무 많습니다({1} > {2}).
class.with.too.many.dependents.display.name=종속자가 너무 많은 클래스
class.with.too.many.dependents.problem.descriptor=클래스 ''{0}''에 종속자가 너무 많습니다({1} > {2}).
class.with.too.many.transitive.dependents.display.name=이행적 종속자가 너무 많은 클래스
class.with.too.many.transitive.dependents.problem.descriptor=클래스 ''{0}''에 이행적 종속성이 너무 많습니다({1} > {2}).
class.with.too.many.dependencies.max.option=최대 종속성의 수
class.with.too.many.dependents.max.option=최대 종속자 수
class.with.too.many.transitive.dependencies.max.option=최대 이행적 종속성의 수
class.with.too.many.transitive.dependents.max.option=최대 이행적 종속성의 수
cyclic.class.dependency.display.name=순환 클래스 종속성
cyclic.class.dependency.problem.descriptor=클래스 ''{0}''이(가) {1}개의 다른 클래스에 순환적으로의존합니다.
cyclic.class.dependency.1.problem.descriptor=클래스 ''{0}''이(가) 클래스 ''{1}''에 순환적으로의존합니다.
cyclic.class.dependency.2.problem.descriptor=클래스 ''{0}''이(가) 클래스 ''{1}'' 및 ''{2}''에 순환적으로의존합니다.
cyclic.package.dependency.display.name=순환 패키지 종속성
cyclic.package.dependency.problem.descriptor=패키지 ''{0}''이(가) {1}개의 다른 패키지에 순환적으로의존합니다.
cyclic.package.dependency.1.problem.descriptor=패키지 ''{0}''이(가) 패키지 ''{1}''에 순환적으로의존합니다.
cyclic.package.dependency.2.problem.descriptor=패키지 ''{0}''이(가) 패키지 ''{1}'' 및 ''{2}''에 순환적으로의존합니다.
class.unconnected.to.package.display.name=해당 패키지에의존하지 않는 클래스
class.unconnected.to.package.problem.descriptor=클래스 <code>#ref</code>의 패키지에 종속성 또는 종속자가 없습니다.
exception.package.display.name=예외 패키지
exception.package.problem.descriptor=패키지 ''{0}''에 예외 클래스만 있습니다.
package.with.too.many.classes.display.name=클래스가 너무 많은 패키지
package.with.too.many.classes.problem.descriptor=패키지 ''{0}''에 클래스가 너무 많습니다({1} > {2}).
package.with.too.many.classes.max.option=최대 클래스 수:
package.with.too.few.classes.display.name=클래스가 너무 적은 패키지
package.with.too.few.classes.problem.descriptor=패키지 ''{0}''에 클래스가 너무 적습니다({1} < {2}).
package.with.too.few.classes.min.option=최소 클래스 수:
suspicious.package.private.access.display.name=의심스러운 package-private 액세스
groups.of.modules.loaded.together.label=함께 로드되는 모듈 그룹:
groups.of.modules.loaded.together.description=동일한 클래스 로더로 로드되는 것으로 알려지고 쉼표로 구분된 모듈 이름 목록을 각 줄에서 지정하므로 이러한 모듈 간의 package-private 멤버에 대한 액세스가 보고되어서는 안 됩니다.
module.with.too.many.classes.display.name=클래스가 너무 많은 모듈
module.with.too.many.classes.problem.descriptor=모듈 ''{0}''에 클래스가 너무 많습니다({1} > {2}).
module.with.too.many.classes.max.option=최대 클래스 수:
module.with.too.few.classes.display.name=클래스가 너무 적은 모듈
module.with.too.few.classes.problem.descriptor=모듈 ''{0}''에 클래스가 너무 적습니다({1} < {2}).
module.with.too.few.classes.min.option=최소 클래스 수:
package.in.multiple.modules.display.name=여러 모듈의 클래스가 있는 패키지
disjoint.package.display.name=분리 종속성 그래프가 있는 패키지
disjoint.package.problem.descriptor=패키지 {0}이(가) {1}개의 독립적 패키지로 분해될 수 있습니다.
package.naming.convention.display.name=패키지 이름 지정 규칙
package.naming.convention.problem.descriptor.short=패키지 이름 <code>{0}</code>이(가) 너무 짧습니다.
package.naming.convention.problem.descriptor.long=패키지 이름 <code>{0}</code>이(가) 너무 깁니다.
package.naming.convention.problem.descriptor.regex.mismatch=패키지 이름 <code>{0}</code>이(가) 정규식 ''{1}''와(과) 일치하지 않습니다.
design.for.extension.display.name=확장을 위한 설계
design.for.extension.problem.descriptor=메서드 <code>#ref()</code>이(가) 재정의되어 해당 기능이 무시될 수 있습니다 #loc
bad.oddness.display.name=의심스러운 홀수 검사
bad.oddness.problem.descriptor=홀수 검사는 음수 값에서 실패합니다 #loc
comparator.not.serializable.display.name='Comparator' 클래스가 'Serializable'로 선언되지 않음
comparator.not.serializable.problem.descriptor=comparator 클래스 <code>#ref</code>이(가) serializable로 선언되지 않았습니다 #loc
non.serializable.field.in.serializable.class.display.name=Serializable 클래스의 비 'Serializable' 필드
non.serializable.field.in.serializable.class.problem.descriptor=Serializable 클래스의 비 serializable 필드 '#ref' #loc
non.serializable.object.passed.to.object.stream.display.name=비 serializable 객체가 'ObjectOutputStream'으로 전달됨
non.serializable.object.passed.to.object.stream.problem.descriptor=비 serializable 객체가 ObjectOutputStream으로 전달되었습니다 #loc
non.serializable.object.bound.to.http.session.display.name=비 serializable 객체가 'HttpSession'으로 바운드됨
non.serializable.object.bound.to.http.session.problem.descriptor=비 serializable 객체가 HttpSession으로 바운드되었습니다 #loc
reflection.for.unavailable.annotation.display.name=소스 전용 어노테이션에 대한 리플렉티브 액세스
reflection.for.unavailable.annotation.problem.descriptor=어노테이션 '#ref'이(가) 리플렉티브 액세스가 가능하도록 되어 있지 않습니다 #loc
access.to.static.field.locked.on.instance.display.name='static' 필드에 대한 액세스가 인스턴스 데이터에서 잠겨 있음
access.to.static.field.locked.on.instance.problem.descriptor=static 필드 <code>#ref</code>에 대한 액세스가 인스턴스 데이터에서 잠겨 있습니다 #loc
access.to.static.field.locked.on.instance.fix.name=타입이 ''{0}''인 static 필드 무시
make.method.ctr.quickfix=메서드 생성자 생성
replace.all.dot.display.name=의심스러운 정규식 인수
replace.all.dot.problem.descriptor=''{0}()'' 호출에 의심스러운 정규식 #ref이(가) 있습니다 #loc
replace.all.dot.quickfix=정규식 메타 문자를 이스케이프합니다.
class.extends.utility.class.display.name=클래스가 유틸리티 클래스를 확장
class.extends.utility.class.problem.descriptor=클래스 <code>#ref</code>이(가) 유틸리티 클래스 ''{0}''을(를) 확장합니다 #loc
class.extends.utility.class.ignore.utility.class.option=클래스 재정의가 유틸리티 클래스인 경우 무시
public.constructor.in.non.public.class.quickfix=생성자를 'private'으로 만들기
assignment.to.method.parameter.ignore.transformation.option=<html>대입이 원본 매개변수의 변형인 경우 무시</html>
type.parameter.extends.final.class.display.name=타입 매개변수가 'final' 클래스를 확장
type.parameter.extends.final.class.type.parameter.problem.descriptor=타입 매개변수 <code>#ref</code>이(가) ''final'' 클래스 ''{0}''을(를) 확장합니다 #loc
type.parameter.extends.enum.type.parameter.problem.descriptor=타입 매개변수 <code>#ref</code>이(가) final 열거형 클래스 ''{0}''을(를) 묵시적으로 확장합니다 #loc
type.parameter.extends.final.class.wildcard.problem.descriptor=와일드카드 타입 인수 <code>#ref</code>이(가) ''final'' 클래스 ''{0}''을(를) 확장합니다 #loc
type.parameter.extends.enum.wildcard.problem.descriptor=와일드카드 타입 인수 <code>#ref</code>이(가) final 열거형 클래스 ''{0}''을(를) 묵시적으로 확장합니다 #loc
type.parameter.extends.final.class.quickfix=타입 매개변수를 실제 클래스로 바꿉니다.
double.negation.display.name=이중 부정
double.negation.problem.descriptor=<code>#ref</code>에 이중 부정이 있습니다 #loc
double.negation.quickfix=이중 부정을 제거합니다.
exception.from.catch.which.doesntwrap.ignore.option=예외 메서드 호출의 결과가 사용되는 경우 무시
exception.from.catch.which.doesntwrap.ignore.cant.wrap.option=던져진 예외가 예외를 래핑할 수 없는 경우 무시
comparable.implemented.but.equals.not.overridden.display.name='Comparable'은 구현되었으나 'equals()'가 재정의되지 않음
comparable.implemented.but.equals.not.overridden.problem.descriptor=클래스 <code>#ref</code>이(가) 'java.lang.Comparable'을 구현하지만 'equals()'는 재정의하지 않습니다 #loc
comparable.implemented.but.equals.not.overridden.fix.add.note.name='등호와 일관되지 않은 순서'라는 JavaDoc 메모 추가
comparable.implemented.but.equals.not.overridden.fix.generate.equals.name='equals()' 메서드 생성
unqualified.field.access.display.name=인스턴스 필드 액세스가 'this'로 정규화되지 않음
unqualified.field.access.problem.descriptor=인스턴스 필드 액세스 <code>#ref</code>이(가) 'this'로 정규화되지 않았습니다 #loc
unqualified.method.access.display.name=인스턴스 메서드 호출이 'this'로 정규화되지 않음
unqualified.method.access.problem.descriptor=인스턴스 메서드 호출 <code>#ref()</code>이(가) 'this'로 정규화되지 않았습니다 #loc
add.this.qualifier.quickfix='this' 한정자를 추가합니다.
while.loop.spins.on.field.ignore.non.empty.loops.option=루프가 비어 있는 경우에만 경고
method.may.be.synchronized.problem.descriptor=동기화된 블록이 있는 메서드 <code>#ref()</code>은(는) 동기화된 메서드가 될 수 있습니다 #loc
method.may.be.synchronized.display.name='synchronized' 블록이 있는 메서드를 'synchronized'  메서드로 바꿀 수 있습니다
method.may.be.synchronized.quickfix=메서드를 동기화하고 동기화된 블록을 제거합니다.
fallthru.in.switch.statement.quickfix=''{0}'' 추가
law.of.demeter.display.name=메서드 호출이 데메테르의 법칙을 위반
law.of.demeter.problem.descriptor=<code>#ref()</code> 호출이 데메테르의 법칙을 위반합니다 #loc
law.of.demeter.ignore.library.calls.option=라이브러리 메서드의 호출 무시
masked.assertion.display.name=어설션을 'catch'이 억제하고 있습니다
masked.assertion.problem.description=''{0}''은(는) 둘러싸고 있는 ''catch''가 억제하고 있으므로 실패할 수 없습니다
enumeration.can.be.iteration.display.name=열거형은 반복이 될 수 있음
enumeration.can.be.iteration.problem.descriptor=<code>#ref()</code>을(를) ''{0}'' 구문으로 바꿀수 있습니다 #loc
enumeration.can.be.iteration.quickfix='Iterator' 구문으로 바꿉니다.
equals.hashcode.called.on.url.display.name='URL' 객체에서 'equals()' 또는 'hashCode()' 호출
equals.hashcode.called.on.url.problem.descriptor=URL 객체에서 <code>#ref()</code>이(가) 호출됩니다 #loc
collection.contains.url.problem.decriptor={0} <code>#ref</code>에 URL 객체가 있습니다 #loc
collection.contains.url.display.name='Map' 또는 'Set'에 'URL' 객체가 있을 수 있음
implicit.array.to.string.problem.descriptor=배열 <code>#ref</code>의 'toString()'이 묵시적으로 호출됩니다 #loc
explicit.array.to.string.problem.descriptor=배열의 '#ref()'이(가) 호출됩니다 #loc
implicit.array.to.string.method.call.problem.descriptor=배열 의 'toString()'에 대한 묵시적 호출이 <code>#ref</code> 호출로 반환됩니다 #loc
implicit.array.to.string.display.name=배열의 'toString()' 호출
implicit.array.to.string.quickfix=''{0}'' 식으로 래핑
suspicious.indent.after.control.statement.problem.descriptor=''{0}'' 문 뒤의의심스러운 들여쓰기 #loc
suspicious.indent.after.control.statement.display.name=중괄호 없는 제어문 뒤의의심스러운 들여쓰기
unpredictable.big.decimal.constructor.call.display.name=예측할 수 없는 'BigDecimal' 생성자 호출
unpredictable.big.decimal.constructor.call.problem.descriptor=예측할 수 없는 <code>new #ref()</code> 호출 #loc
unpredictable.big.decimal.constructor.call.ignore.references.option=변수 또는 메서드 호출 인수가 있는 생성자 호출 무시
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option=여러 리터럴이 있는 생성자 호출 무시(예: 0.1 + 0.2)
unnecessary.unary.minus.display.name=불필요한 단항 뺄셈
unnecessary.unary.minus.problem.descriptor=불필요한 단항 <code>#ref</code> 연산자 #loc
unnecessary.unary.minus.quickfix=단항 뺄셈을 제거하고 상위 연산 기호를 반전시킵니다.
unnecessary.unary.minus.remove.quickfix=이중 단항 뺄셈 제거
make.field.final.quickfix=''{0}''을(를) ''final''로 만듭니다.
increment.decrement.used.as.expression.quickfix=''{0}''을(를) 별도의 구문으로 추출합니다.
ignore.classes.in.hierarchy.column.name=다음의 하위 클래스 무시:
overly.strong.type.cast.ignore.in.matching.instanceof.option=일치하는 instanceof 식이 있는 형 변환 무시
access.to.non.thread.safe.static.field.from.instance.display.name=Non-thread-safe 'static' 필드 액세스
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor=''{0}'' 타입의 non-thread-safe static 필드 <code>#ref</code>에 액세스 #loc
access.to.non.thread.safe.static.field.from.instance.option.title=비 스레드 안전 클래스:
access.to.non.thread.safe.static.field.from.instance.class.chooser.title=비 스레드 안전 클래스 선택
transient.field.not.initialized.display.name=transient 필드는 역직렬화에서 초기화되지 않음
transient.field.not.initialized.problem.descriptor=transient 필드 <code>#ref</code>은(는) 역직렬화에서 초기화되지 않습니다 #loc
call.to.string.concat.can.be.replaced.by.operator.display.name='String.concat()' 호출을 '+'로 바꿀수 있습니다.
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor=<code>#ref()</code> 호출을 '+' 표현식으로 바꿀수 있습니다 #loc
call.to.string.concat.can.be.replaced.by.operator.quickfix='concat()' 호출을 '+'로 바꿉니다.
new.string.buffer.with.char.argument.display.name='char'인수가 있는 StringBuilder 생성자 호출
new.string.buffer.with.char.argument.problem.descriptor=<code>new #ref()</code>에 타입 'char'의 인수가 있습니다 #loc
new.string.buffer.with.char.argument.quickfix=char 인수를 문자열 리터럴로 바꿉니다.
suspicious.comparator.compare.display.name=의심스러운 'Comparator.compare()' 구현
suspicious.comparator.compare.descriptor.parameter.not.used='compare()' 매개변수 <code>#ref</code>이(가) 사용되지 않았습니다 #loc
suspicious.comparator.compare.descriptor.non.reflexive=Comparator가 equal 요소에 대해 0을 반환하지 않습니다.
to.array.call.style.display.name='Collection.toArray()' 호출 스타일
to.array.call.style.problem.descriptor.zero=<code>#ref()</code> 호출에 빈 배열 인수 ''{0}''이(가) 있습니다 #loc
to.array.call.style.problem.descriptor.presized=<code>#ref()</code> 호출에 크기가 사전 설정된 배열 인수 ''{0}''이(가) 있습니다 #loc
to.array.call.style.quickfix.family.name='toArray()' 호출로 전달된 배열의 크기 수정
to.array.call.style.quickfix.make.presized=인수를 크기가 사전 설정된 배열로 바꿉니다.
to.array.call.style.quickfix.make.zero=인수를 빈 배열로 바꿉니다.
throwable.instance.never.thrown.runtime.exception.problem.descriptor=런타임 예외 인스턴스 <code>#ref</code>이(가) 던져지지 않습니다 #loc
throwable.instance.never.thrown.checked.exception.problem.descriptor=검사된 예외 인스턴스 <code>#ref</code>이(가) 던져지지 않습니다 #loc
throwable.instance.never.thrown.error.problem.descriptor=오류 인스턴스 <code>#ref</code>이(가) 던져지지 않습니다 #loc
throwable.instance.never.thrown.problem.descriptor=throwable 인스턴스 <code>#ref</code>이(가) 던져지지 않습니다 #loc
ignore.guard.clauses.option=guard 절 무시(&G)
ignore.for.equals.methods.option='equals()' 메서드 무시(&E)
caught.exception.immediately.rethrown.display.name=포착된 예외가 즉시 다시 던져짐
caught.exception.immediately.rethrown.problem.descriptor=포착된 예외 <code>#ref</code>이(가) 즉시 다시 던져집니다 #loc
delete.catch.section.quickfix='catch' 섹션을 삭제합니다.
loop.with.implicit.termination.condition.display.name=묵시적 종료 조건이 있는 루프
loop.with.implicit.termination.condition.dowhile.problem.descriptor=<code>#ref-while</code> 루프에 묵시적 종료 조건이 있습니다 #loc
loop.with.implicit.termination.condition.problem.descriptor=<code>#ref</code> 루프에 묵시적 종료 조건이 있습니다 #loc
loop.with.implicit.termination.condition.quickfix=조건을 명시적으로 만듭니다.
rename.catch.parameter.to.ignored=''catch'' 매개변수의 이름을 ''{0}''(으)로 변경합니다.
inspection.empty.catch.block.generate.body=템플릿에서 'catch' 본문 생성
unnecessary.super.qualifier.display.name=불필요한 'super' 한정자
unnecessary.super.qualifier.problem.descriptor=한정자 <code>#ref</code>은(는) 이 컨텍스트에서 불필요합니다 #loc
unnecessary.super.qualifier.quickfix=불필요한 'super' 한정자를 제거합니다.
collections.field.access.replaceable.by.method.call.display.name=빈 컬렉션 필드 참조를 메서드 호출로 바꿀 수 있습니다
collections.field.access.replaceable.by.method.call.problem.descriptor=<code>#ref</code>을(를) ''Collections.{0}''(으)로 바꿀수 있습니다 #loc
synchronization.on.local.variable.or.method.parameter.display.name=지역 변수 또는 메서드 매개변수 동기화
synchronization.on.local.variable.problem.descriptor=지역 변수 <code>#ref</code> 동기화 #loc
synchronization.on.method.parameter.problem.descriptor=메서드 매개변수 <code>#ref</code> 동기화 #loc
too.broad.catch.quickfix=''{0}''에 대한 ''catch'' 절을 추가합니다.
replace.with.catch.clause.for.runtime.exception.quickfix='RuntimeException'에 대한 'catch' 절로 바꿉니다.
too.broad.catch.option=RuntimeException, Exception, Error 또는 Throwable에 대해서만 경고(&O)
unnecessary.conversion.to.string.display.name='문자열'로 불필요한 변환
unnecessary.tostring.call.display.name=불필요한 'toString()' 호출
unnecessary.tostring.call.problem.descriptor=<code>#ref()</code> 호출이 불필요합니다 #loc
throwable.not.thrown.display.name='Throwable'이 던져지지 않음
throwable.result.of.method.call.ignored.problem.descriptor=<code>#ref()</code>의 결과가 던져지지 않습니다 #loc
char.used.in.arithmetic.context.display.name=산술 컨텍스트에서 'char' 표현식 사용
char.used.in.arithmetic.context.problem.descriptor=산술 컨텍스트에 'char'가 사용되었습니다 #loc
char.used.in.arithmetic.context.quickfix=문자열 리터럴로 변환합니다.
char.used.in.arithmetic.context.cast.quickfix=형 변환을 {0}에 삽입합니다.
unnecessary.constant.array.creation.expression.display.name=상수 배열 생성 시의 중복 'new' 표현식
unnecessary.constant.array.creation.expression.problem.descriptor=새 배열 표현식에서 <code>#ref</code>을(를) 제거할 수 있습니다 #loc
unnecessary.constant.array.creation.expression.family.quickfix=새 배열 표현식에서 타입 사양 제거
ambiguous.method.call.display.name=상속된 메서드 호출이 지역 메서드 호출처럼 보임
ambiguous.method.call.problem.descriptor=상위 클래스 ''{0}''의 메서드 <code>#ref()</code> 호출이 클래스 ''{1}''의 메서드 호출처럼 보입니다 #loc
ambiguous.method.call.quickfix=메서드 호출에 'super' 한정자를 추가합니다.
change.modifier.quickfix=''{0}''을(를) 만듭니다
the.whole.project=전체 프로젝트
this.class=이 클래스
assertequals.may.be.assertsame.display.name='assertEquals()'가 'assertSame()'이 될 수 있음
assertequals.may.be.assertsame.problem.descriptor=<code>#ref</code>이(가) 'assertSame()'이 될 수 있습니다 #loc
logger.initialized.with.foreign.class.problem.descriptor=로거가 외부 클래스 <code>#ref</code>(으)로 초기화되었습니다 #loc
logger.initialized.with.foreign.class.display.name=로거가 외부 클래스로 초기화됨
logger.factory.method.name=로거 팩토리 메서드 이름
logger.factory.class.name=로거 팩토리 클래스 이름
make.static.final.quickfix=''{0}''을(를) static final로 만듭니다.
logging.condition.disagrees.with.log.statement.display.name=로그 조건이 로깅 호출과 일치하지 않음
logging.condition.disagrees.with.log.statement.problem.descriptor=로그 조건 <code>#ref()</code>이(가) ''{0}()'' 로깅 호출과 일치하지 않습니다 #loc
log.statement.guarded.by.log.condition.display.name=로깅 호출이 로그 조건으로 보호되지 않음
log.statement.guarded.by.log.condition.problem.descriptor=<code>#ref()</code> 로킹 호출이 로그 조건으로 보호되지 않습니다 #loc
log.statement.guarded.by.log.condition.quickfix=로그 조건으로 둘러쌉니다.
log.statement.guarded.by.log.condition.flag.all.unguarded.option=로깅 호출로 보호되지 않는 모든 항목에 플래그 표시
key.set.iteration.may.use.entry.set.display.name='keySet()' 반복을 최적화할 수 있음
key.set.iteration.may.use.entry.set.problem.descriptor=<code>#ref()</code> 반복을 ''{0}'' 반복으로 바꿀수 있습니다 #loc
key.set.iteration.may.use.entry.set.quickfix=Map 반복을 최적화합니다.
string.replaceable.by.string.buffer.in.loop.option=루프에 추가할 때만 경고
declare.collection.as.interface.quickfix=''{0}''(으)로 약화합니다.
non.exception.name.ends.with.exception.quickfix=''{0}''이(가) ''java.lang.Exception''을 확장하도록 합니다.
constant.value.variable.use.display.name=값이 상수로 알려진 변수 사용
constant.value.variable.use.problem.descriptor=<code>#ref</code>의 값이 상수로 알려져 있습니다 #loc
unnecessary.parentheses.option=명확히 구분 짓는 소괄호 추가
unnecessary.parentheses.conditional.option=조건식 조건 주위의 소괄호 무시
field.may.be.final.display.name=필드가 'final'이 될 수 있음
field.may.be.final.problem.descriptor=필드 <code>#ref</code>이(가) 'final'이 될 수 있습니다 #loc
cast.that.loses.precision.option=int에서 및 char로의 형 변환 무시
ignore.overflowing.byte.casts.option=int 128~255에서 byte로의 형 변환 무시
variable.not.used.inside.if.display.name='null' 검사된 참조가 'if' 내부에서 사용되지 않음
variable.not.used.inside.if.problem.descriptor='null' 검사된 <code>#ref</code>이(가) 'if' 내부에서 사용되지 않습니다 #loc
variable.not.used.inside.conditional.problem.descriptor='null' 검사된 <code>#ref</code>이(가) 조건 내부에서 사용되지 않습니다 #loc
boolean.expression.may.be.conditional.display.name=부울식을 조건식으로 바꾸기 가능
if.may.be.conditional.problem.descriptor=<code>#ref</code>을(를) 조건식으로 바꿀수 있습니다 #loc
if.may.be.conditional.quickfix=조건식으로 바꿉니다.
redundant.string.format.call.display.name='String.format()' 중복 호출
redundant.call.problem.descriptor=<code>#ref</code>이(가) 중복 호출됩니다 #loc
redundant.string.format.call.quickfix='String.format()' 중복 호출을 제거합니다.
redundant.string.formatted.call.quickfix='String.formatted()' 중복 호출을 제거합니다.
junit4.test.method.in.class.extending.junit3.testcase.display.name=JUnit 3 TestCase를 확장하는 클래스 내 JUnit 4 테스트 메서드
convert.junit3.test.case.error.string=<code>#ref</code>을(를) JUnit4 테스트 케이스로 변환할 수 있습니다.
convert.junit3.test.case.family.name=JUnit4 테스트 케이스로 변환
convert.junit3.test.case.display.name=JUnit 3 테스트가 JUnit 4가 될 수 있음
junit4.test.method.in.class.extending.junit3.testcase.problem.descriptor=클래스 내에서 '@Test'로 어노테이션이 추가된 메서드 <code>#ref()</code>이(가) JUnit 3 TestCase를 확장합니다 #loc
ignore.test.method.in.class.extending.junit3.testcase.problem.descriptor='@Ignore'로 어노테이션이 추가된 JUnit 3 테스트 메서드 <code>#ref()</code>이(가) 무시되지 않습니다 #loc
ignore.test.method.in.class.extending.junit3.testcase.quickfix=''@Ignore''를 제거하고 메서드의 이름을 ''{0}''(으)로 변경합니다.
convert.junit3.test.class.quickfix=JUnit 3 클래스 ''{0}''을(를) JUnit 4로 변환합니다.
remove.junit4.test.annotation.quickfix='@Test' 어노테이션을 제거합니다.
remove.junit4.test.annotation.and.rename.quickfix=''@Test'' 어노테이션을 제거하고 이름을 ''{0}''(으)로 변경합니다.
equals.called.on.enum.constant.display.name=열거 값에서 'equals()' 호출
equals.called.on.enum.constant.problem.descriptor=<code>#ref()</code>이(가) 열거 값에서 호출되었습니다 #loc
int.literal.may.be.long.literal.display.name='long'으로 형 변환하면 'long' 리터럴이 될 수 있음
int.literal.may.be.long.literal.problem.descriptor=<code>#ref</code>을(를) ''{0}''(으)로 바꿀수 있습니다 #loc
constant.assert.condition.display.name='assert' 문 내 상수 조건
constant.assert.condition.problem.descriptor=assert 조건 <code>#ref</code>이(가) 상수입니다 #loc
assert.with.side.effects.display.name=부수 효과가 있는 'assert' 문
assert.with.side.effects.problem.descriptor=<code>#ref</code>에 부수 효과 {0}이(가) 있습니다 #loc
method.count.ignore.getters.setters.option=간단한 getter 및 setter 메서드 무시(&I)
class.new.instance.display.name=안전하지 않은 'Class.newInstance()' 호출
class.new.instance.problem.descriptor=<code>#ref()</code> 호출이 선언되지 않고 검사되지 않은 예외를 던질 수 있습니다 #loc
dynamic.regex.replaceable.by.compiled.pattern.display.name=동적 정규식을 컴파일된 'Pattern'으로 대체 가능
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor=<code>#ref</code>을(를) 컴파일된 'java.util.regex.Pattern' 구문으로 바꿀수 있습니다 #loc
dynamic.regex.replaceable.by.compiled.pattern.quickfix=컴파일된 'Pattern' 상수의 메서드 호출로 바꿉니다.
ignore.serializable.option='java.io.Serializable' 무시
ignore.cloneable.option='java.lang.Cloneable' 무시
listener.may.use.adapter.display.name=클래스가 리스너를 구현하지 않고 어댑터를 확장할 수 있음
listener.may.use.adapter.problem.descriptor=클래스 ''{0}''이(가) <code>#ref</code>을(를) 구현하지 않고 ''{1}''을(를) 확장합니다 #loc
listener.may.use.adapter.emtpy.methods.option=빈 구현 메서드가 발견될 경우에만 경고(&O)
unnecessary.inherit.doc.display.name=불필요한 '{@inheritDoc}' Javadoc 주석
unnecessary.inherit.doc.problem.descriptor=<code>#ref</code>만 있는 Javadoc 주석은 불필요합니다 #loc
unnecessary.inherit.doc.field.invalid.problem.descriptor=<code>#ref</code>이(가) 필드에서 유효하지 않습니다 #loc
unnecessary.inherit.doc.constructor.invalid.problem.descriptor=<code>#ref</code>이(가) 생성자에서 유효하지 않습니다 #loc
unnecessary.inherit.doc.class.invalid.problem.descriptor=<code>#ref</code>이(가) 클래스에서 유효하지 않습니다 #loc
unnecessary.inherit.doc.module.invalid.problem.descriptor=<code>#ref</code>이(가) 모듈 선언에서 유효하지 않습니다 #loc
unnecessary.inherit.doc.constructor.no.super.problem.descriptor=Javadoc에 상속할 상위 메서드를 찾을 수 없습니다 #loc
unnecessary.inherit.doc.quickfix=불필요한 {@inheritDoc}을 제거합니다.
multiple.exceptions.declared.on.test.method.display.name=테스트 메서드에서 선언된 여러 예외
multiple.exceptions.declared.on.test.method.problem.descriptor=<code>#ref</code>을(를) 'throws Exception'으로 바꿀수 있습니다 #loc
unnecessary.javadoc.link.display.name=불필요한 Javadoc 링크
unnecessary.javadoc.link.super.method.problem.descriptor=상위 메서드를 가리키는 <code>#ref</code>은(는) 불필요합니다 #loc
unnecessary.javadoc.link.this.method.problem.descriptor=이 메서드를 가리키는 <code>#ref</code>은(는) 불필요합니다 #loc
unnecessary.javadoc.link.this.class.problem.descriptor=포함 메서드를 가리키는 <code>#ref</code>은(는) 불필요합니다 #loc
unnecessary.javadoc.link.quickfix=불필요한 ''{0}''을(를) 제거합니다.
thread.local.not.static.final.display.name='ThreadLocal' 필드가 'static final'로 선언되지 않음
thread.local.not.static.final.problem.descriptor=ThreadLocal <code>#ref</code>이(가) 'static final'로 선언되지 않았습니다 #loc
remove.try.finally.block.quickfix='try-finally' 블록을 제거합니다.
remove.finally.block.quickfix='finally' 블록을 제거합니다.
remove.leading.zero.to.make.decimal.quickfix=선행 0을 제거하여 10진수를 만듭니다.
remove.leading.zeroes.to.make.decimals.quickfix=선행 0을 제거하여 10진수를 만듭니다.
convert.octal.literal.to.decimal.literal.quickfix=8진 리터럴을 10진 리터럴로 변환합니다.
convert.octal.literals.to.decimal.literals.quickfix=8진 리터럴을 10진 리터럴로 변환합니다.
ignore.single.field.static.imports.option=단일 필드 정적 import 문 무시(&F)
ignore.single.method.static.imports.option=단일 메서드 정적 import 문 무시(&M)
ignore.methods.with.boolean.return.type.option='java.lang.Boolean' 반환 타입의 메서드 무시(&B)
ignore.boolean.methods.in.an.interface.option=@interface의 부울 메서드 무시(&I)
ignore.methods.overriding.super.method=상위 메서드를 재정의/구현하는 메서드 무시(&O)
ignored.io.resource.types=무시된 I/O 리소스 타입
ignored.io.resource.types.label=무시된 I/O 리소스 타입:
choose.io.resource.type.to.ignore=무시할 I/O 리소스 타입 선택
ignore.accesses.from.the.same.class=동일한 클래스로부터의 액세스 무시
ignore.accesses.from.equals.method='equals()' 메서드로부터의 액세스 무시
ignore.branches.of.switch.statements='switch' 문의 브랜치 무시
ignore.equals.hashcode.and.tostring='equals()', 'hashCode()' 및 'toString()' 메서드 무시
ignore.methods.in.anonymous.classes=익명 클래스의 메서드 무시
class.name=클래스 이름
method.name.regex=메서드 이름 정규식
column.assertion.class.name=어설션 클래스 이름
choose.class=클래스 선택
query.column.name=다음으로 시작하는 쿼리 이름
query.label=다음으로 시작하는 쿼리 이름:
update.column.name=다음으로 시작하는 업데이트 이름
update.label=다음으로 시작하는 업데이트 이름:
assert.keyword.is.considered.an.assertion='assert' 키워드는 어설션으로 간주됩니다
expected.exception.never.thrown.display.name=테스트 메서드 본문에 필요한 예외가 던져지지 않음
expected.exception.never.thrown.problem.descriptor=필요한 <code>#ref</code>이(가) ''{0}()'' 본문에서 전혀 던져지지 않습니다 #loc
choose.logger.class=로거 클래스 선택
logger.class.name=Logger 클래스 이름:
ignore.exceptions.declared.on.library.override.option=라이브러리 메서드를 재정의하는 메서드에서 선언된 예외 무시(&L)
allow.resource.to.be.opened.inside.a.try.block='try' 블록 내에서 리소스가 열리도록 허용
any.method.may.close.resource.argument=임의의 메서드가 리소스 인수를 닫을 수 있음
ignore.constructor.method.references=AutoCloseable을 생성하는 생성자 메서드 참조 무시
ignore.getters.returning.resource=리소스를 반환하는 getter 무시
log.method.name=로깅 메서드 이름
log.condition.text=로그 조건 텍스트
ignore.if.annotated.by=다음으로 어노테이션이 추가된 경우 무시:
ignore.classes.annotated.by=다음으로 어노테이션이 추가된 클래스 무시:
ignored.class.hierarchies.border.title=다음의 하위 클래스 무시:
choose.class.hierarchy.to.ignore.title=무시할 클래스 계층 구조 선택
unqualified.inner.class.access.display.name=정규화되지 않은 내부 클래스 액세스
unqualified.inner.class.access.problem.descriptor=<code>#ref</code>이(가) 외부 클래스로 정규화되지 않았습니다 #loc
unqualified.inner.class.access.quickfix=외부 클래스로 정규화합니다.
unnecessarily.qualified.inner.class.access.problem.descriptor=''{0}''이(가) <code>#ref</code>(으)로 불필요하게 정규화되었습니다 #loc
unnecessarily.qualified.inner.class.access.display.name=불필요한 내부 클래스 액세스 정규화
unnecessarily.qualified.inner.class.access.quickfix=한정자 제거
synchronization.on.static.field.display.name='static' 필드 동기화
synchronization.on.static.field.problem.descriptor='static' 필드 <code>#ref</code> 동기화 #loc
assertequals.called.on.arrays.display.name=배열에서 'assertEquals()' 호출
assertequals.called.on.arrays.problem.descriptor=<code>#ref()</code>이(가) 배열에서 호출됩니다 #loc
overly.broad.throws.clause.display.name=지나치게 넓은 'throw' 절
overly.broad.throws.clause.problem.descriptor1=<code>throws #ref</code>이(가) 너무 넓어 예외 ''{0}''을(를) 마스킹합니다 #loc
overly.broad.throws.clause.problem.descriptor2=<code>throws #ref</code>이(가) 너무 넓어 예외 ''{0}'' 및 ''{1}''을(를) 마스킹합니다 #loc
overly.broad.throws.clause.quickfix1=특정 예외를 추가합니다.
overly.broad.throws.clause.quickfix2=특정 예외로 바꿉니다.
overly.broad.throws.clause.ignore.thrown.option=다른 예외를 숨기면서 자신은 던져지는 예외 무시(&H)
unnecessarily.qualified.statically.imported.element.display.name=정적으로 가져온 요소가 불필요하게 정규화됨
unnecessarily.qualified.statically.imported.element.problem.descriptor=정적으로 가져온 요소 ''{0}''이(가) <code>#ref</code>(으)로 불필요하게 정규화되었습니다 #loc
unnecessarily.qualified.statically.imported.element.quickfix=불필요한 한정자를 제거합니다.
ignore.instanceof.on.library.classes=라이브러리 클래스의 instanceof 무시
for.can.be.foreach.option=색인 생성된 'java.util.List' 루프 보고
for.can.be.foreach.option2=타입이 없는 컬렉션 반복을 보고 안 함
cast.conflicts.with.instanceof.quickfix1=형 변환에서 ''{0}''을(를) ''{1}''(으)로 바꿉니다.
cast.conflicts.with.instanceof.quickfix2=instanceof에서 ''{0}''을(를) ''{1}''(으)로 바꿉니다.
double.checked.locking.quickfix=''{0}''을(를) volatile으로 만듭니다
double.literal.may.be.float.literal.display.name='float'로 형 변환하면 'float' 리터럴이 될 수 있음
multiple.declaration.ignore.for.option='for' 루프 선언 무시
multiple.declaration.array.only.option=단일 선언에서 서로 다른 배열 크기에 대해서만 경고
simplifiable.annotation.display.name=단순화 가능한 어노테이션
simplifiable.annotation.problem.descriptor=어노테이션의 <code>#ref</code>이(가) 불필요합니다 #loc
simplifiable.annotation.whitespace.problem.descriptor=어노테이션의 공백이 불필요합니다 #loc
simplifiable.annotation.quickfix=어노테이션을 단순화합니다.
overloaded.methods.with.same.number.parameters.option=<html>매개변수 타입이 확실히 호환되지 않는 오버로드된 메서드 무시</html>
string.concatenation.in.format.call.display.name='format()' 호출에 대한 인수로서의 문자열 연결
string.concatenation.in.format.call.problem.descriptor=''{0}()'' 호출에 문자열 연결 인수가 있습니다
string.concatenation.in.format.call.quickfix=연결을 별도의 인수로 바꿉니다.
string.concatenation.in.message.format.call.display.name='MessageFormat.format()' 호출에 대한 인수로서의 문자열 연결
string.concatenation.in.message.format.call.problem.descriptor='MessageFormat.format()' 호출에 대한 인수로서의 문자열 연결 #loc
boxing.boxed.value.display.name=이미 박싱된 값을 박싱
boxing.boxed.value.problem.descriptor=이미 박싱된 <code>#ref</code>을(를) 박싱합니다 #loc
boxing.boxed.value.quickfix=불필요한 박싱을 제거합니다.
unnecessary.javadoc.link.option=상위 메서드에 대한 인라인 링크 무시
constant.junit.assert.argument.display.name=상수 assert 인수
constant.junit.assert.argument.problem.descriptor=인수 <code>#ref</code>이(가) 상수입니다 #loc
test.case.with.no.test.methods.option=테스트 메서드를 사용하는 상위 클래스가 있는 테스트 사례 무시
package.dot.html.may.be.package.info.display.name='package.html'을 'package-info.java'로 변환할 수 있음
package.dot.html.may.be.package.info.exists.problem.descriptor=<code>package-info.java</code>가 있으므로 <code>package.html</code>이 무시됩니다.
package.dot.html.may.be.package.info.problem.descriptor=<code>package.html</code>이 <code>package-info.java</code>로 변환될 수 있습니다.
package.dot.html.may.be.package.info.delete.quickfix='package.html'을 삭제합니다.
package.dot.html.may.be.package.info.convert.quickfix='package-info.java'로 변환합니다.
ignore.anonymous.inner.classes=익명의 내부 클래스 무시
try.with.identical.catches.display.name='try' 문의 동일한 'catch' 브랜치
try.with.identical.catches.problem.descriptor=''catch'' 브랜치가 ''{0}'' 브랜치와 동일합니다 #loc
if.can.be.switch.display.name='if'를 'switch'로 바꿀 수 있음
if.can.be.switch.problem.descriptor=<code>#ref</code> 문을 'switch' 문으로 바꿀수 있습니다 #loc
if.can.be.switch.minimum.branch.option=최소 'if' 조건 브랜치 수:
if.can.be.switch.int.option=숫자에 대한 switch 제안
if.can.be.switch.enum.option=열거형에 대한 switch 제안
if.can.be.switch.null.safe.option=null 안전 표현식에서만 제안
unnecessarily.qualified.inner.class.access.option=import 문이 필요한 참조 무시
unqualified.inner.class.access.option=지역 내부 클래스에 대한 참조 무시
try.with.identical.catches.quickfix='catch' 블록을 접습니다.
confusing.else.option='if' 문 다음에 구문이 없는 경우 보고
html.tag.can.be.javadoc.tag.display.name='<code>...</code>'을 '{@code ...}'로 대체 가능
html.tag.can.be.javadoc.tag.problem.descriptor=<code>#ref...\\&lt;/code\\&gt;</code>을(를) '{@code ...}'로 바꿀수 있습니다 #loc
try.finally.can.be.try.with.resources.display.name='try finally'를 리소스가 있는 'try'로 바꿀 수 있음
try.finally.can.be.try.with.resources.problem.descriptor=<code>#ref</code>이(가) 자동 리소스 관리를 사용할 수 있습니다 #loc
try.finally.can.be.try.with.resources.quickfix=리소스가 있는 'try'로 바꿉니다.
array.comparison.display.name='Arrays.equals()' 대신 '=='를 사용하여 배열 비교
array.comparison.problem.descriptor=배열 객체를 'Arrays.equals()'가 아닌 <code>#ref</code>을(를) 사용하여 비교합니다 #loc
array.hash.code.display.name=배열에서 'hashCode()' 호출
array.hash.code.problem.descriptor=배열에서 호출된 <code>#ref()</code>은(는) 'Arrays.hashCode()'여야 할 것입니다 #loc
objects.hash.problem.descriptor='Objects.hash()'로 전달한 배열은 'Arrays.hashcode()'로 래핑해야 합니다
wrap.with.arrays.hash.code.quickfix=''{0}''(으)로 래핑
method.can.be.variable.arity.method.display.name=메서드는 varargs 매개변수를 가질 수 있음
method.can.be.variable.arity.method.problem.descriptor=<code>#ref()</code>을(를) vararg 메서드로 변환할 수 있습니다 #loc
method.can.be.variable.arity.method.ignore.byte.short.option=타입 byte[] 또는 short[]가 있는 매개변수 무시
method.can.be.variable.arity.method.ignore.all.primitive.arrays.option=모든 기본 배열 타입 무시
method.can.be.variable.arity.method.ignore.multiple.arrays.option=배열 매개변수가 여러 개인 메서드 무시
method.can.be.variable.arity.method.ignore.multidimensional.arrays.option=여러 크기의 배열 매개변수 무시
convert.to.variable.arity.method.quickfix=vararg 메서드로 변환합니다.
mismatched.string.builder.query.update.display.name='StringBuilder'의 쿼리 및 업데이트 불일치
mismatched.string.builder.updated.problem.descriptor=<code>{0} #ref</code>의 내용은 업데이트되지만 쿼리되지 않습니다 #loc
mismatched.string.builder.queried.problem.descriptor=<code>{0} #ref</code>의 내용은 쿼리되지만 업데이트되지 않습니다 #loc
math.random.cast.to.int.display.name='int'로 'Math.random()' 형 변환
math.random.cast.to.int.problem.descriptor=''{0}''(으)로의 <code>#ref</code> 형 변환은 항상 ''0''으로 버림됩니다 #loc
math.random.cast.to.int.quickfix=형 변환하기 전에 곱셈을 수행하기 위해 소괄호를 추가합니다.
boolean.variable.always.inverted.display.name=부울 변수가 항상 반전됨
boolean.field.always.inverted.problem.descriptor=부울 필드 <code>#ref</code>이(가) 항상 반전됩니다 #loc
boolean.variable.always.inverted.problem.descriptor=부울 변수 <code>#ref</code>이(가) 항상 반전됩니다 #loc
unnecessary.explicit.numeric.cast.display.name=불필요한 명시적 숫자 형 변환
unnecessary.explicit.numeric.cast.problem.descriptor=''{0}''이(가) <code>#ref</code>(으)로 불필요하게 형 변환되었습니다 #loc
unnecessary.explicit.numeric.cast.quickfix=형 변환을 제거합니다.
null.thrown.display.name='null'이 던져짐
null.thrown.problem.descriptor=<code>#ref</code>이(가) 던져집니다 #loc
unnecessary.final.on.local.variable.or.parameter.display.name=지역 변수 또는 매개변수의 불필요한 'final'
unnecessary.final.on.local.variable.problem.descriptor=변수 ''{0}''의 <code>#ref</code>이(가) 불필요합니다 #loc
unnecessary.final.on.parameter.problem.descriptor=매개변수 ''{0}''의 <code>#ref</code>이(가) 불필요합니다 #loc
unnecessary.final.report.local.variables.option=지역 변수 보고
unnecessary.final.report.parameters.option=매개변수 보고
unnecessary.final.on.parameter.only.interface.option=추상 또는 인터페이스 메서드에 대해서만 경고
choose.exception.class=예외 클래스 선택
choose.exception.label=금지된 예외:
class.independent.of.module.display.name=해당 모듈에의존하지 않는 클래스
class.independent.of.module.problem.descriptor=클래스 <code>#ref</code>의 모듈에 종속성 또는 종속자가 없습니다 #loc
class.only.used.in.one.module.display.name=다른 모듈에서만 사용되는 클래스
class.only.used.in.one.module.problem.descriptor=클래스 <code>#ref</code>의 모듈 ''{0}''에 종속성 및/또는 종속자만 있습니다 #loc
simplifiable.equals.expression.option.non.constant=상수가 아니고 null이 아닌 인수가 있는 equals 보고
simplifiable.equals.expression.display.name='equals()' 호출 전 불필요한 'null' 검사
simplifiable.equals.expression.problem.descriptor=''{0}()'' 호출 전 불필요한 ''null'' 검사입니다 #loc
simplifiable.equals.expression.quickfix=''.{0}()''을(를) 반전시키고 불필요한 ''null'' 검사를 제거합니다.
use.of.concrete.class.option.ignore.abstract=추상 클래스 타입 무시
use.of.concrete.class.option.report.method.returns=메서드 반환 타입 보고
use.of.concrete.class.option.report.local.variable=지역 변수 타입 보고
use.of.concrete.class.option.report.parameter=메서드 매개변수 타입 보고
use.of.concrete.class.option.report.static.fields=정적 필드 타입 보고
use.of.concrete.class.option.report.instance.fields=인스턴스 필드 타입 보고
use.of.concrete.class.option.report.instanceof=instanceof, 패턴 또는 getClass() 비교에 사용되는 타입 보고
use.of.concrete.class.option.report.cast=변환 표현식에 사용된 타입 보고
class.only.used.in.one.package.display.name=다른 패키지에서만 사용되는 클래스
class.only.used.in.one.package.problem.descriptor=클래스 <code>#ref</code>의 패키지 ''{0}''에 종속성 및/또는 종속자만 있습니다 #loc
unnecessary.return.option='else' 브랜치가 있는 'if' 문의 브랜치에서 무시
usage.of.obsolete.assert.display.name=곧 사용할 수 없게 될 'junit.framework.Assert' 메서드 사용
use.of.obsolete.assert.problem.descriptor=''{0}''의 <code>#ref()</code> 호출을 ''org.junit.Assert''의 메서드 호출로 바꿔야 합니다 #loc
use.of.obsolete.assert.quickfix='org.junit.Assert' 메서드 호출로 바꿉니다.
ignored.junit.test.display.name=JUnit 테스트에 '@Ignore'/'@Disabled'로 어노테이션 추가
ignored.junit.test.classproblem.descriptor=테스트 클래스 ''{0}''에 <code>#ref</code>(으)로 어노테이션이 추가되었습니다 #loc
ignored.junit.test.method.problem.descriptor=테스트 메서드 ''{0}()''에 <code>#ref</code>(으)로 어노테이션이 추가되었습니다 #loc
ignored.junit.test.ignore.reason.option=이유없이 사용된 어노테이션만 보고
unclear.binary.expression.display.name=우선 순위가 다른 여러 연산자
unclear.binary.expression.problem.descriptor=표현식에 명확히 구분 짓는 소괄호를 사용할 수 있습니다 #loc
unclear.binary.expression.quickfix=명확히 구분 짓는 소괄호를 추가합니다.
new.exception.without.arguments.display.name=인수 없이 예외 생성자 호출
new.exception.without.arguments.problem.descriptor=인수 없는 <code>new #ref()</code> #loc
absolute.alignment.in.user.interface.display.name=AWT/Swing 코드에서 절대 정렬 사용
absolute.alignment.in.user.interface.problem.descriptor=절대 정렬 상수 <code>{0}.#ref</code>이(가) 사용되었습니다 #loc
throws.runtime.exception.display.name=검사되지 않은 예외가 'throws' 절에서 선언됨
throws.runtime.exception.problem.descriptor=검사되지 않은 예외 <code>#ref</code>이(가) 'throws' 절에서 선언되었습니다 #loc
throws.runtime.exception.quickfix=''{0}''을(를) ''throws'' 절에서 제거합니다.
throws.runtime.exception.move.quickfix=''{0}''을(를) Javadoc ''@throws'' 태그로 이동합니다.
empty.class.ignore.parameterization.option=상위 타입의 매개변수화인 경우 클래스 무시
ambiguous.field.access.display.name=상속된 필드로의 액세스가 둘러싸는 코드의 요소로의 액세스처럼 보임
ambiguous.field.access.hides.local.variable.problem.descriptor=상위 클래스 ''{0}''에 있는 필드 <code>#ref</code>의 액세스가 지역 변수의 액세스처럼 보입니다 #loc
ambiguous.field.access.hides.parameter.problem.descriptor=상위 클래스 ''{0}''에 있는 필드 <code>#ref</code>의 액세스가 매개변수의 액세스처럼 보입니다 #loc
ambiguous.field.access.hides.field.problem.descriptor=상위 클래스 ''{0}''에 있는 필드 <code>#ref</code>의 액세스가 주변 클래스에 있는 필드의 액세스처럼 보입니다 #loc
ambiguous.field.access.quickfix=필드 액세스에 'super' 한정자를 추가합니다.
add.0.to.ignore.if.annotated.by.list.quickfix=''{0}''을(를) ''다음으로 어노테이션이 추가된 경우 무시'' 목록에 추가합니다
non.final.field.in.enum.display.name='enum' 내 final이 아닌 필드
non.final.field.in.enum.problem.descriptor=열거형 ''{0}'' 내 final이 아닌 필드 <code>#ref</code> #loc
externalizable.without.public.no.arg.constructor.display.name='public' 비인수 생성자가 없는 'Externalizable' 클래스
externalizable.without.public.no.arg.constructor.problem.descriptor=externalizable 클래스 <code>#ref</code>에 'public' 비인수 생성자가 없습니다 #loc
make.constructor.public=생성자를 'public'으로 설정
string.concatenation.missing.whitespace.display.name=문자열 연결에 공백이 누락되었을 수 있음
string.concatenation.missing.whitespace.problem.descriptor=문자열 연결에 공백이 누락되었을 수 있습니다 #loc
string.concatenation.missing.whitespace.option=가변 문자열과의 연결 무시
negated.equality.expression.display.name=부정된 상등 표현식
negated.equality.expression.problem.descriptor=''{0}''이(가) 부정되었습니다 #loc
negated.equality.expression.quickfix=부정 제거
negated.conditional.expression.display.name=부정된 조건식
negated.conditional.expression.problem.descriptor=조건식이 부정되었습니다 #loc
negated.conditional.expression.quickfix=부정 제거
suspicious.array.cast.display.name=의심스러운 배열 형 변환
suspicious.array.cast.problem.descriptor=<code>#ref</code>(으)로 의심스러운 형 변환이 실행되었습니다 #loc
public.constructor.display.name='public' 생성자를 factory 메서드로 바꿀 수 있습니다
public.default.constructor.problem.descriptor=클래스 <code>#ref</code>에 'public' 디폴트 생성자가 있습니다.
public.constructor.problem.descriptor=public 생성자 <code>#ref()</code> #loc
public.constructor.quickfix=factory 메서드로 생성자를 바꿉니다.
junit3.style.test.method.in.junit4.class.display.name=JUnit 4 클래스의 이전 스타일 JUnit 테스트 메서드
junit3.style.test.method.in.junit4.class.problem.descriptor=JUnit 4 클래스에 이전 스타일 JUnit 테스트 메서드 <code>#ref()</code>이(가) 있습니다 #loc
none=없음
private=private
package.local.private=package-private \\& private
protected.package.local.private=protected, package-private \\& private
non.final.utility.class.display.name=유틸리티 클래스가 'final'이 아님
non.final.utility.class.problem.descriptor=유틸리티 클래스 <code>#ref</code>이(가) 'final'이 아닙니다 #loc
0.will.no.longer.be.overridable.by.1={0}을(를) {1}(으)로 더 이상 재정의할 수 없습니다.
arrays.as.list.with.zero.or.one.argument.display.name=인수가 너무 적은 'Arrays.asList()' 호출
arrays.as.list.with.one.argument.problem.descriptor=인수가 하나뿐인 <code>#ref()</code>이(가) 호출되었습니다 #loc
arrays.as.list.with.zero.arguments.problem.descriptor=빈 목록을 생성하기 위해 <code>#ref()</code>이(가) 호출되었습니다 #loc
string.concatenation.argument.to.log.call.display.name=로깅 호출에 대한 인수로서의 비상수 문자열 연결
string.concatenation.argument.to.log.call.problem.descriptor=<code>#ref()</code> 로깅 호출에 대한 인수로서의 비상수 문자열 연결 #loc
string.concatenation.argument.to.log.call.quickfix=연결을 매개변수화된 로그 메시지로 바꿉니다.
placeholder.count.matches.argument.count.display.name=자리표시자 수가 로깅 호출의 인수 수와 일치하지 않음
placeholder.count.matches.argument.count.more.problem.descriptor=지정된 자리표시자 수({1})보다 인수의 수({0})가 많습니다 #loc
placeholder.count.matches.argument.count.fewer.problem.descriptor=지정된 자리표시자 수({1})보다 인수의 수({0})가 적습니다 #loc
assignment.to.superclass.field.display.name=생성자가 상위 클래스에 정의된 필드에 값을 대입
assignment.to.superclass.field.problem.descriptor=상위 클래스 ''{1}''에서 정의된 필드 ''{0}''에 대입합니다 #loc
inner.class.referenced.via.subclass.display.name=내부 클래스가 하위 클래스를 통해 참조됨
inner.class.referenced.via.subclass.problem.descriptor=내부 클래스 <code>#ref</code>이(가) 클래스 ''{0}''에서 선언되었지만 하위 클래스 ''{1}''을(를) 통해 참조되었습니다 #loc
inner.class.referenced.via.subclass.quickfix=내부 클래스 액세스를 합리화합니다.
boolean.parameter.display.name='boolean' 매개변수가 있는 'public' 메서드
boolean.parameter.problem.descriptor='boolean' 매개변수가 있는 'public' 메서드 <code>#ref()</code> #loc
boolean.parameters.problem.descriptor='boolean' 매개변수가 있는 'public' 메서드 <code>#ref()</code> #loc
boolean.parameter.constructor.problem.descriptor='boolean' 매개변수가 있는 'public' 생성자 <code>#ref()</code> #loc
boolean.parameters.constructor.problem.descriptor='boolean' 매개변수가 있는 'public' 생성자 <code>#ref()</code> #loc
boolean.parameter.only.report.multiple.option=부울 매개변수가 여러 개인 메서드만 보고
unnecessary.unicode.escape.display.name=불필요한 유니코드 이스케이프 시퀀스
unnecessary.unicode.escape.problem.descriptor=유니코드 이스케이프 시퀀스 <code>#ref</code>을(를) ''{0}''(으)로 바꿀수 있습니다 #loc
unnecessary.unicode.escape.problem.tab.descriptor=유니코드 이스케이프 시퀀스 <code>#ref</code>을(를) 탭 문자로 바꿀수 있습니다 #loc
unnecessary.unicode.escape.problem.newline.descriptor=유니코드 이스케이프 시퀀스 <code>#ref</code>을(를) 줄 피드 문자로 바꿀수 있습니다 #loc
missing.package.info.display.name='package-info.java' 누락
missing.package.info.problem.descriptor=패키지 ''{0}''에서 <code>package-info.java</code> 파일이 누락되었습니다.
missing.package.html.problem.descriptor=패키지 ''{0}''에서 <code>package.html</code> 파일이 누락되었습니다.
package.info.java.without.package.display.name='package' 문이 없는 'package-info.java'
package.info.without.package.problem.descriptor='package-info.java'에 'package' 문이 없습니다.
package.info.without.package.quickfix=''package {0};''을(를) 추가합니다.
package.info.without.package.family.quickfix=패키지 구문을 추가합니다.
auto.closeable.resource.display.name=AutoCloseable을 'try'-with-resources 없이 사용
auto.closeable.resource.problem.descriptor=''{0}''이(가) ''try''-with-resources 없이 사용되었습니다 #loc
auto.closeable.resource.quickfix=이 메서드에서 반환된 'AutoCloseable'을 무시합니다.
auto.closeable.resource.returned.option=모든 메서드 호출에서 반환된 AutoCloseable 인스턴스 무시
problematic.varargs.method.display.name=비 vararg 메서드는 vararg 메서드를 재정의
problematic.varargs.method.override.problem.descriptor=비 vararg 메서드 <code>#ref()</code>이(가) vararg 메서드를 재정의합니다 #loc
negatively.named.boolean.variable.problem.descriptor=부울 변수 <code>#ref</code>이(가) 부정적으로 이름이 지정되었습니다 #loc
negatively.named.boolean.variable.display.name=부정적으로 이름 지정된 부울 변수
invert.quickfix.family.name=부울 반전
invert.method.quickfix=메서드를 반전시킵니다.
invert.quickfix=''{0}''을(를) 반전시킵니다.
throwable.printed.to.system.out.display.name='Throwable'을 'System.out'으로 출력
throwable.printed.to.system.out.problem.descriptor=''Throwable''인수 <code>#ref</code>이(가) ''System.{0}.{1}()'' 호출로 출력됩니다.
suppress.for.tests.scope.quickfix='Tests' 범위를 억제합니다.
implicit.default.charset.usage.display.name=묵시적 플랫폼 디폴트 문자 집합
implicit.default.charset.usage.problem.descriptor=<code>#ref()</code> 호출이 플랫폼의 디폴트 문자 집합을 사용합니다.
implicit.default.charset.usage.constructor.problem.descriptor=<code>new #ref()</code> 호출이 플랫폼의 디폴트 문자 집합을 사용합니다.
interface.may.be.annotated.functional.display.name=인터페이스에 @FunctionalInterface'로 어노테이션 추가 가능
interface.may.be.annotated.functional.problem.descriptor=인터페이스 <code>#ref</code>에 @FunctionalInterface로 어노테이션을 추가할 수 있습니다
only.report.public.methods.option='public' 메서드만 보고
lambda.parameter.hides.member.variable.display.name=람다 매개변수가 필드를 숨김
static.initializer.references.subclass.display.name=정적 이니셜라이저가 하위 클래스를 참조
lambda.parameter.hides.member.variable.problem.descriptor=람다 매개변수 <code>#ref</code>이(가) 클래스 ''{0}''의 필드를 숨깁니다 #loc
lambda.parameter.hides.member.variable.ignore.invisible.option=람다에서 실제로 표시되지 않는 필드 무시
shared.thread.local.random.display.name='ThreadLocalRandom'인스턴스를 공유할 수 있음
shared.thread.local.random.problem.descriptor='ThreadLocalRandom'인스턴스를 스레드 간에 공유할 수 있습니다.
native.method.naming.convention.element.description='native' 메서드
use.of.obsolete.date.time.api.display.name=곧 사용할 수 없게 될 date-time API 사용
use.of.obsolete.date.time.api.problem.descriptor=곧 사용할 수 없게 될 date-time 타입 <code>#ref</code>이(가) 사용되었습니다 #loc
warn.on.label=다음에 대해 경고:
all.levels.option=모든 로그 수준
warn.level.and.lower.option=경고 수준 이하
info.level.and.lower.option=정보 수준 이하
debug.level.and.lower.option=디버그 수준 이하
trace.level.option=추적 수준
ignored.autocloseable.types.column.label=무시된 AutoCloseable 리소스 타입
ignored.autocloseable.types.label=무시된 AutoCloseable 리소스 타입:
choose.autocloseable.type.to.ignore.title=무시할 AutoCloseable 리소스 타입 선택
big.decimal.method.without.rounding.called.display.name=반올림 모드 인수 없이 'BigDecimal' 메서드 호출
big.decimal.method.without.rounding.called.problem.descriptor=반올림 모드 인수 없이 'BigDecimal.#ref()'이(가) 호출됩니다.
bigdecimal.legacy.method.display.name='BigDecimal' 기존 메서드 호출
bigdecimal.legacy.method.problem.descriptor='BigDecimal.#ref()' 호출은 'RoundingMode' 열거형 상수를 사용할 수 있습니다.
bigdecimal.legacy.method.quickfix='RoundingMode' 열거형 상수를 사용합니다.
serializable.stores.non.serializable.display.name='Serializable' 객체가 비 'Serializable' 객체를 묵시적으로 저장
serializable.lambda.stores.non.serializable.problem.descriptor=serializable 람다가 타입 ''{0}'' 의 비 serializable 객체를 묵시적으로 저장합니다
serializable.local.class.stores.non.serializable.problem.descriptor=serializable 지역 클래스 ''{1}''이(가) 타입 ''{0}''의 비 serializable 객체를 묵시적으로 저장합니다.
serializable.anonymous.class.stores.non.serializable.problem.descriptor=serializable 익명 클래스가 타입 ''{0}''의 비 serializable 객체를 묵시적으로 저장합니다.
assignment.to.lambda.parameter.display.name=람다 매개변수에 대입
assignment.to.lambda.parameter.problem.descriptor=람다 매개변수 <code>#ref</code>에 대입되었습니다 #loc
class.with.only.private.constructors.display.name='private' 생성자만 있는 클래스는 'final'로 선언되어야 함
class.with.only.private.constructors.problem.descriptor='private' 생성자만 있는 클래스 <code>#ref</code>은(는) 'final'로 선언되어야 합니다.
property.value.set.to.itself.display.name=자신에게 설정된 프로퍼티값
equals.with.itself.display.name=자신에서 'equals()' 호출
equals.with.itself.problem.descriptor=자신에서 <code>#ref()</code> 호출
junit4.method.naming.convention.element.description=JUnit 4+ 테스트 메서드
junit3.method.naming.convention.element.description=JUnit 3 테스트 메서드
introduce.holder.class.quickfix=holder 클래스를 삽입합니다.
double.brace.initialization.display.name=이중 중괄호 초기화
double.brace.initialization.quickfix=일반 초기화로 바꿉니다.
return.of.inner.class.display.name=익명, 지역 또는 내부 클래스의 인스턴스 반환
return.of.anonymous.class.problem.descriptor=익명 클래스의 인스턴스를 반환합니다 #loc
return.of.local.class.problem.descriptor=지역 클래스 <code>{0}</code>의 인스턴스를 반환합니다 #loc
return.of.inner.class.problem.descriptor=비 static 내부 클래스 <code>{0}</code>의 인스턴스를 반환합니다 #loc
return.of.inner.class.ignore.non.public.option=비 public 메서드로부터의 반환 무시
parameter.type.prevents.overriding.display.name=매개변수 타입으로 인해 재정의 불가
parameter.type.prevents.overriding.problem.descriptor=매개변수 타입 <code>#ref</code>은(는) ''{0}''에 있지만 상위 메서드 매개변수 타입은 ''{1}''에 있어 재정의할 수 없습니다 #loc
parameter.type.prevents.overriding.quickfix=매개변수 타입을 ''{0}''(으)로 변경합니다.
parameter.type.prevents.overriding.family.quickfix=매개변수 타입을 '변경합니다.
suspicious.getter.setter.display.name=의심스러운 getter/setter
suspicious.setter.problem.descriptor=setter <code>#ref()</code>이(가) 필드 ''{0}''을(를) 대입합니다 #loc
suspicious.getter.problem.descriptor=Getter <code>#ref()</code>이(가) 필드 ''{0}''을(를) 반환합니다 #loc
unnecessary.break.display.name=불필요한 'break' 문
unnecessary.break.problem.descriptor=<code>#ref</code> 문은 불필요합니다 #loc
utility.class.can.be.enum.display.name=유틸리티 클래스가 'enum'이 될 수 있음
utility.class.code.can.be.enum.problem.descriptor=유틸리티 클래스 <code>#ref</code>이(가) 'enum'이 될 수 있습니다 #loc
utility.class.code.can.be.enum.quickfix='enum'으로 변환합니다.
non.public.clone.display.name='clone()' 메서드가 'public'이 아님
non.public.clone.problem.descriptor=<code>#ref()</code> 메서드가 'public'이 아닙니다 #loc
only.warn.on.public.clone.methods='public' 복제 메서드에 대해서만 경고
only.warn.on.protected.clone.methods='protected' 복제 메서드에 대해서만 경고
clone.returns.class.type.display.name='clone()'에는 포함된 클래스와 동일한 반환 타입이 있어야 함
clone.returns.class.type.problem.descriptor=''복제()''에는 반환 타입 ''{0}''이(가) 있어야 합니다 #loc
clone.returns.class.type.quickfix=반환 타입을 ''{0}''(으)로 변경합니다.
clone.returns.class.type.family.quickfix=반환 타입을 클래스 타입으로 변경합니다.
use.of.clone.display.name='clone()' 또는 'Cloneable' 사용
use.of.clone.call.problem.descriptor=<code>#ref()</code> 호출
use.of.clone.call.method.problem.descriptor=<code>#ref()</code> 구현
use.of.clone.reference.problem.descriptor=<code>#ref</code> 사용
dangling.javadoc.display.name=허상 Javadoc 주석
dangling.javadoc.problem.descriptor=허상 Javadoc 주석 #loc
dangling.javadoc.convert.quickfix=블록 주석으로 바꾸기
dangling.javadoc.delete.quickfix=허상 주석을 제거합니다.
equals.replaceable.by.objects.call.display.name='equals()' 식을 'Objects.equals()' 식으로 바꾸기 가능
equals.replaceable.by.objects.call.problem.descriptor=<code>#ref</code>을(를) 'Objects.equals()' 식으로 바꿀수 있습니다 #loc
equals.replaceable.by.objects.check.not.null.option='a != null \\&\\& a.equals(b)'와 같은 표현식을 강조 표시
array.objects.equals.display.name=얕은 메서드 또는 'Objects' 메서드를 배열과 함께 사용
array.equals.problem.descriptor=배열 비교를 위해 ''{0}''을(를) 사용해야 할 것입니다
array.hashcode.problem.descriptor=배열 해시 코드 계산을 위해 ''{0}''을(를) 사용해야 할 것입니다
extends.throwable.display.name=클래스가 'Throwable'을 바로 확장
anonymous.extends.throwable.problem.descriptor=익명의 클래스가 'java.lang.Throwable'를 바로 확장합니다 #loc
extends.throwable.problem.descriptor=클래스 <code>#ref</code>이(가) 'java.lang.Throwable'을 바로 확장합니다 #loc
lambda.parameter.naming.convention.display.name=람다 매개변수 이름 지정 규칙
lambda.parameter.naming.convention.element.description=람다 매개변수
assert.message.not.string.display.name='assert' 메시지가 문자열이 아님
assert.message.of.type.boolean.problem.descriptor=타입 ''{0}''의 ''assert'' 메시지 #loc
assert.message.not.string.only.warn.boolean.option='assert' 메시지가 'boolean' 또는 'java.lang.Boolean'인 경우에만 경고
suspicious.literal.underscore.display.name=숫자 리터럴의의심스러운 밑줄
suspicious.literal.underscore.problem.descriptor=밑줄이 있는 숫자 리터럴에 있는 그룹의 길이가 3이 아닙니다 #loc
unary.plus.quickfix=단항 '+'를 제거합니다.
convert.double.unary.quickfix=''{0}{1}''(으)로 바꾸기
prefix.operation.quickfix.family.name=접두사 연산자로 바꾸기
super.tear.down.in.finally.display.name='super.tearDown()'이 'finally' 블록에서 호출되지 않음
super.tear.down.in.finally.problem.descriptor=<code>#ref()</code>이(가) 'finally' 블록에서 호출되지 않습니다 #loc
confusing.floating.point.literal.option=과학적 표기에서 부동소수점 리터럴 무시
class.may.be.interface.java8.option=Java 8을 사용할 때 추상이 아닌 메서드가 포함된 클래스 보고
simplifiable.boolean.expression.display.name=단순화 가능한 부울 표현식
unnecessary.initcause.display.name=불필요한 'throwable.initCause()' 호출
unnecessary.initcause.problem.descriptor=불필요한 <code>Throwable.#ref()</code> 호출
unnecessary.initcause.quickfix='Throwable.initCause()' 호출을 제거합니다.
consider.static.final.fields.constant.option='static final' 필드를 상수로 간주
atomic.field.updater.not.static.final.display.name='AtomicFieldUpdater' 필드가 'static final'로 선언되지 않음
atomic.field.updater.not.static.final.problem.descriptor={0} 필드 <code>#ref</code>이(가) ''static final''로 선언되지 않았습니다 #loc
atomic.field.updater.issues.display.name=일관되지 않은 'AtomicFieldUpdater' 선언
field.not.found.in.class.problem.descriptor=이름이 ''{0}''인 필드를 클래스 ''{1}''에서 찾을 수 없습니다.
field.incorrect.type.problem.descriptor=필드 ''{0}''에 타입 ''{1}''이(가) 없습니다.
field.missing.volatile.modifier.problem.descriptor=필드 ''{0}''에 ''volatile'' 제어자가 없습니다.
field.has.static.modifier.problem.descriptor=필드 ''{0}''에 ''static'' 제어자가 있습니다
private.field.not.accessible.problem.descriptor=''private'' 필드 ''{0}''은(는) 여기에서 액세스할 수 없습니다.
package.local.field.not.accessible=package-private 필드 ''{0}''은(는) 여기에서 액세스할 수 없습니다.
protected.field.not.accessible.problem.descriptor=''protected'' 필드 ''{0}''은(는) 여기에서 액세스할 수 없습니다.
interface.clashes.with.object.class.display.name=인터페이스 메서드가 'Object'의 메서드와 충돌
interface.clashes.with.object.class.problem.descriptor=<code>#ref()</code>이(가) 'java.lang.Object'의 메서드와 충돌합니다.
optional.used.as.field.or.parameter.type.display.name='Optional'이 필드 또는 매개변수 타입으로 사용되지 않음
optional.used.as.field.type.problem.descriptor=<code>#ref</code>이(가) 필드 ''{0}''의 타입으로 사용됩니다.
optional.used.as.parameter.type.problem.descriptor=<code>#ref</code>이(가) 매개변수 ''{0}''의 타입으로 사용됩니다.
lambda.unfriendly.method.overload.display.name=람다 친화적이지 않은 메서드 오버로드
lambda.unfriendly.method.overload.problem.descriptor=메서드 <code>#ref()</code>의 오버로드가 람다 친화적이지 않습니다.
lambda.unfriendly.constructor.overload.problem.descriptor=생성자 <code>#ref()</code>의 오버로드가 람다 친화적이지 않습니다.
optional.contains.collection.display.name='Optional'에 배열 또는 컬렉션이 있음
optional.contains.collection.problem.descriptor='Optional'에 컬렉션 <code>#ref</code>이(가) 있습니다.
optional.contains.array.problem.descriptor='Optional'에 배열 <code>#ref</code>이(가) 있습니다.
synchronization.on.get.class.display.name='getClass()' 동기화
synchronization.on.get.class.problem.descriptor=<code>#ref()</code> 동기화 #loc
object.instantiation.inside.equals.or.hashcode.display.name='equals()' 또는 'hashCode()' 내의 객체 인스턴스화
object.instantiation.inside.equals.or.hashcode.problem.descriptor=''{0}()'' 내의 객체 인스턴스화 #loc
object.instantiation.inside.equals.or.hashcode.problem.descriptor2=''{0}()''({1}) 내의 객체 인스턴스화 #loc
lambda.body.can.be.code.block.name=람다 본문이 코드 블록이 될 수 있음
lambda.body.can.be.code.block.quickfix=람다 본문을{...}(으)로 확장합니다.
lambda.parameter.type.can.be.specified.name=람다 매개변수 타입을 지정할 수 있음
lambda.parameter.type.can.be.specified.descriptor=람다 매개변수 타입을 {0}(으)로 확장할 수 있습니다.
lambda.parameter.type.can.be.specified.quickfix=매개변수 타입을 {0}(으)로 확장합니다.
lambda.parameter.type.can.be.specified.family.quickfix=람다 매개변수 타입을 지정합니다.
diamond.can.be.replaced.with.explicit.type.arguments.name=다이아몬드를 명시적 타입 인수로 바꾸기 가능
diamond.can.be.replaced.with.explicit.type.arguments.quickfix='<>'를 명시적 타입 인수로 바꿉니다.
lambda.can.be.replaced.with.anonymous.name=람다를 익명 클래스로 바꾸기 가능
lambda.can.be.replaced.with.anonymous.quickfix=람다를 익명 클래스로 바꿉니다.
method.ref.can.be.replaced.with.lambda.name=메서드 참조를 람다로 바꾸기 가능
method.ref.can.be.replaced.with.lambda.quickfix=메서드 참조를 람다로 바꿉니다.
try.statement.with.multiple.resources.name=여러 리소스가 있는 'try' 문을 분할할 수 있음
try.statement.with.multiple.resources.quickfix=여러 리소스가 있는 'try' 문을 분할합니다.
multi.catch.can.be.split.name=여러 catch를 개별 catch 블록으로 분할할 수 있음
multi.catch.can.be.split.quickfix=여러 catch를 개별 'catch' 블록으로 분할합니다.
assertion.can.be.if.name=어설션을 'if' 문으로 바꾸기 가능
assert.can.be.if.quickfix='assert'를 'if' 문으로 바꿉니다.
if.can.be.assertion.name=구문을 'assert' 또는 'Objects.requireNonNull'로 바꾸기 가능
if.can.be.assertion.replace.with.assertion.quickfix=구문을 'assert' 문으로 바꿉니다.
if.can.be.assertion.replace.with.objects.requirenonnull.quickfix=구문을 'Objects.requireNonNull()'로 바꿉니다.
single.statement.in.block.name=코드 블록에 단일 구문이 있음
single.statement.in.block.descriptor=''{0}''에 단일 구문이 있습니다.
single.statement.in.block.quickfix=''{0}'' 문의 중괄호를 제거합니다.
single.statement.in.block.family.quickfix=구문의 중괄호를 제거합니다.
single.element.annotation.name=정규화되지 않은 어노테이션
single.element.annotation.quickfix='value='를 추가합니다.
single.element.annotation.family.quickfix=어노테이션을 일반 형식으로 확장합니다.
array.creation.without.new.keyword.name='new' 식이 없는 배열 생성
array.creation.without.new.keyword.quickfix=''new {0}''을(를) 추가합니다.
array.creation.without.new.keyword.family.quickfix='new' 표현식을 추가합니다.
overly.long.lambda.display.name=지나치게 긴 람다 표현식
overly.long.lambda.problem.descriptor=Lambda 표현식이 너무 깁니다(주석이 아닌 소스 구문 수 = {0}) #loc
wait.notify.not.in.synchronized.context.display.name='wait()' 또는 'notify()'가 동기화된 컨텍스트에 없음
wait.notify.while.not.synchronized.on.problem.descriptor=<code>#ref</code>이(가) ''{0}''에서 동기화되지 않는 동안 호출됩니다 #loc
call.to.suspicious.string.method.display.name=의심스러운 'String' 메서드 호출
call.to.suspicious.string.method.problem.descriptor=국제화된 컨텍스트에서 <code>String.#ref()</code>이(가) 호출됩니다 #loc
unnecessary.string.escape.display.name=불필요하게 이스케이프된 문자
unnecessary.string.escape.problem.descriptor=<code>#ref</code>이(가) 불필요하게 이스케이프됩니다.
unnecessary.string.escape.quickfix=불필요하게 이스케이프된 문자를 이스케이프되지 않은 것으로 바꿉니다.

array.can.be.replaced.with.enum.values = 배열을 열거형 값으로 바꿀수 있습니다.
array.can.be.replaced.with.enum.values.quickfix = 배열을 {0}.values()로 바꿉니다.
array.can.be.replaced.with.enum.values.family.quickfix = 배열을 EnumType.value()로 바꿉니다.

string.concatenation.replace.fix=StringBuilder로 바꿉니다.
string.concatenation.replace.fix.name=변수 ''{0}''을(를) 문자열에서 {1}(으)로 변환
string.concatenation.replace.fix.name.null.safe=변수 ''{0}''을(를) 문자열에서 {1}(으)로 변환(null 안전)
string.concatenation.introduce.fix=StringBuilder를 삽입합니다.
string.concatenation.introduce.fix.name=새로운 {1}을(를) 삽입하여 변수 ''{0}'' 업데이트
string.concatenation.introduce.fix.name.null.safe=새로운 {1}을(를) 삽입하여 변수 ''{0}'' 업데이트(null 안전)

ignored.class.names=클래스 무시(하위 클래스 포함)
ignored.class.label=무시된 클래스(하위 클래스 포함):
meta.annotation.without.runtime.retention='@Retention(RUNTIME)' 어노테이션 없이 어노테이션 테스트
string.equals.char.sequence.display.name='CharSequence'인수로 'String.equals()' 호출
string.equals.char.sequence.problem.descriptor=<code>String.equals()</code>가 ''{0}'' 인수로 호출되었습니다 #loc
object.equals.can.be.equality.display.name='equals()' 호출을 '=='로 바꾸기 가능
object.equals.can.be.equality.problem.descriptor=<code>#ref()</code>을(를) '=='로 바꿀수 있습니다.
not.object.equals.can.be.equality.problem.descriptor=<code>!#ref()</code>을(를) '!='로 바꿀수 있습니다.
redundant.explicit.var.type.display.name=지역 변수 타입은 생략 가능
variable.type.can.be.explicit.display.name=변수 타입이 명시적일 수 있음
assignment.or.return.of.field.with.mutable.type.display.name=가변 타입이 있는 필드의 대입 또는 반환
assignment.of.field.with.mutable.type.problem.descriptor=매개변수 <code>#ref</code>에서 {0} 필드 ''{1}''(으)로 대입되었습니다 #loc
return.of.field.with.mutable.type.problem.descriptor={0} 필드 <code>{1}</code> 반환 #loc
ignore.private.methods.option=private 메서드의 대입 및 반환 무시

inspection.redundant.string.operation.display.name=중복 'String' 연산
inspection.redundant.string.remove.fix.name=중복 ''{0}()'' 호출 제거
inspection.redundant.string.fix.family.name=중복 호출 제거
inspection.redundant.string.call.message=<code>#ref()</code> 호출이 중복됩니다 #loc
inspection.redundant.empty.string.argument.message=불필요한 빈 문자열 인수입니다.
inspection.redundant.string.length.argument.message=불필요한 문자열 길이 인수
inspection.redundant.zero.argument.message=불필요한 제로 인수
inspection.redundant.string.remove.argument.fix.name=인수 제거
inspection.redundant.string.intern.on.constant.message=컴파일 타임 상수의 <code>#ref()</code> 호출이 불필요합니다 #loc
inspection.redundant.string.constructor.message=<code>#ref</code>이(가) 중복됩니다 #loc
inspection.redundant.string.replace.with.arg.fix.name=인수로 바꾸기
inspection.redundant.string.replace.with.empty.fix.name=빈 문자열로 바꾸기
inspection.redundant.string.option.do.not.report.string.constructors=문자열 생성자를 보고 안 함
inspection.x.call.can.be.replaced.with.y=''{0}'' 호출을 ''{1}''(으)로 바꿀수 있습니다

inspection.type.may.be.weakened.display.name=타입이 약화될 수 있음
inspection.type.may.be.weakened.problem.descriptor=변수 <code>#ref</code>의 타입이 {0}(으)로 약화될 수 있습니다 #loc
inspection.type.may.be.weakened.method.problem.descriptor=메서드 <code>#ref()</code>의 반환 타입이 {0}(으)로 약화될 수 있습니다 #loc
inspection.type.may.be.weakened.parameter.problem.descriptor=매개변수 <code>#ref</code>의 타입이 {0}(으)로 약화될 수 있습니다 #loc
inspection.type.may.be.weakened.field.problem.descriptor=필드 <code>#ref</code>의 타입이 {0}(으)로 약화될 수 있습니다 #loc
inspection.type.may.be.weakened.quickfix=타입을 ''{0}''(으)로 약화합니다.
inspection.type.may.be.weakened.ignore.option=오른쪽 타입을 대입에서 가장 약한 타입으로 사용(&R)
inspection.type.may.be.weakened.collection.method.option=메서드 호출 인수에 대한 컬렉션의 매개변수화된 타입 사용(&P)
inspection.type.may.be.weakened.do.not.weaken.to.object.option='java.lang.object'로 약화 안 함(&W)
inspection.type.may.be.weakened.add.stopper=약화를 위해 중지 클래스로 추가
inspection.type.may.be.weakened.add.stopper.single=약화를 위해 {0}을(를) stop 클래스로 추가
inspection.type.may.be.weakened.only.weaken.to.an.interface=인터페이스로만 약화
inspection.type.may.be.weakened.do.not.weaken.return.type=반환 타입을 약화하면 안 됩니다.
inspection.type.may.be.weakened.add.stop.class.family=stop 클래스 추가
inspection.type.may.be.weakened.weaken.type.family=타입 약화
inspection.type.may.be.weakened.add.stop.class.selection.table=중지 클래스
inspection.type.may.be.weakened.add.stop.class.selection.table.label=stop 클래스:
inspection.type.may.be.weakened.add.stop.class.selection.popup=중지 클래스 선택
inspection.type.may.be.weakened.do.not.weaken.inferred.variable.type='var'로 선언된 약화된 변수를 제안하지 않음

inspection.commented.out.code.display.name=주석 처리된 코드
inspection.commented.out.code.problem.descriptor=주석 처리된 코드 ({0} {0, choice, 1#줄|1<줄})
commented.out.code.delete.quickfix=주석 삭제
commented.out.code.uncomment.quickfix=코드 주석 해제
inspection.commented.out.code.min.lines.options=최소 코드 줄

inspection.catch.ignores.exception.display.name=catch 블록이 예외를 무시할 수 있음
inspection.catch.ignores.exception.option.comments='catch' 블록에 주석이 포함되어 있을 경우 경고 안 함
inspection.catch.ignores.exception.option.nonempty='catch' 블록에 주석이 비어 있을 경우 경고 안 함
inspection.catch.ignores.exception.option.ignored.used='ignore(d)'라는 예외가 실제로 무시되지 않은 경우 경고 안 함
inspection.catch.ignores.exception.used.message=이름이 <code>#ref</code>인 'catch' 매개변수가 사용되었습니다 #loc
inspection.catch.ignores.exception.empty.message=빈 <code>#ref</code> 블록 #loc
inspection.catch.ignores.exception.unused.message=사용되지 않는 'catch' 매개변수 <code>#ref</code> #loc
inspection.catch.ignores.exception.vm.ignored.message=<code>#ref</code> 블록에서 ''{0}'' 등의 예기치 않은 VM 예외는 무시될 수 있습니다 #loc

inspection.redundant.collection.operation.display.name=중복 'Collection' 연산
inspection.redundant.collection.operation.fix.family.name=컬렉션 연산 단순화
inspection.redundant.collection.operation.problem.arraycopy=배열을 복사하기 위해 불필요한 컬렉션이 생성되었습니다.
inspection.redundant.collection.removal.by.index.problem=색인별 제거는 객체별 제거로 바꿀수 있습니다.
inspection.redundant.collection.removal.by.index.fix=객체별 제거를 사용합니다.
inspection.redundant.collection.unnecessary.contains.problem=불필요한 ''{0}()'' 검사
inspection.redundant.collection.unnecessary.contains.fix=''{0}()'' 검사 제거

comments.as.content.option=주석을 내용으로 간주
copy.constructor.misses.field.display.name=복사 생성자에 필드가 누락됨
copy.constructor.misses.field.problem.descriptor.1=복사 생성자가 필드 ''{0}''을(를) 복사하지 않습니다.
copy.constructor.misses.field.problem.descriptor.2=복사 생성자가 필드 ''{0}'', ''{1}''을(를) 복사하지 않습니다.
copy.constructor.misses.field.problem.descriptor.3=복사 생성자가 필드 ''{0}'', ''{1}'', ''{2}''을(를) 복사하지 않습니다.
copy.constructor.misses.field.problem.descriptor.many=복사 생성자가 {0}개 필드를 복사하지 않습니다.

fix.add.argument.family.name=인수 추가
fix.add.argument.name=''{0}''인수 추가

inspection.constant.expression.display.name=상수식을 평가할 수 있음
inspection.constant.expression.message=상수식을 ''{0}''(으)로 평가할 수 있습니다.
inspection.constant.expression.fix.name=''{0}''의 상수값 계산
inspection.constant.expression.fix.name.with.value=''{0}''을(를) 상수값 ''{1}''(으)로 바꾸기
inspection.constant.expression.fix.family.name=상수값 계산

inspection.redundant.compare.call.display.name=중복 'compare()' 메서드 호출
inspection.redundant.compare.call.fix.name='compare()' 호출 인라인화

inspection.simplifiable.if.statement.display.name='if' 문을 조건 또는 부울 표현식으로 바꾸기 가능
inspection.simplifiable.if.statement.message=if 문을 ''{0}''(으)로 바꿀수 있습니다.
inspection.simplifiable.if.statement.option.dont.warn.on.ternary='?:' 연산자를 제안 안 함
inspection.simplifiable.if.statement.fix.name=''if else''를 ''{0}''(으)로 바꾸기
inspection.simplifiable.if.statement.fix.family.name='if else'를 조건식으로 바꾸기

inspection.list.remove.in.loop.display.name=루프에서 'List.remove()' 호출
inspection.list.remove.in.loop.message='List.subList().clear()'로 바꿀수 있습니다.

implicit.default.charset.usage.fix.family.name=UTF-8 문자 집합 지정

inspection.redundant.class.call.display.name=중복 'isInstance()' 또는 'cast()' 호출
inspection.new.object.equality.display.name=새 객체를 '=='를 사용하여 비교
inspection.new.object.equality.message=''{0}''을(를) 사용하여 새 객체가 비교되었습니다
inspection.excessive.range.check.message=''{0}''(으)로 바꿀수 있습니다.
inspection.excessive.range.check.fix.family.name=과도한 범위 검사 단순화
suspicious.integer.div.assignment.problem.descriptor=나누기 결과가 정수로 버림 처리됩니다.
suspicious.integer.div.assignment.display.name=의심스러운 정수 나눗셈 대입
suspicious.integer.div.assignment.quickfix=double로 형 병환합니다.
inspection.if.statement.missing.break.in.loop.name='if' 조건문에서 루프 조기 종료
inspection.if.statement.missing.break.in.loop.description=조건이 충족된 후 루프를 종료할 수 있습니다.
inspection.if.statement.missing.break.in.loop.quickfix='break'를 추가합니다.

inspection.case.mismatch.display.name='String' 연산에서 일치하지 않는 case
inspection.case.mismatch.message.arg.is.lower=메서드 ''{0}()''이(가) {1}을(를) 항상 반환합니다. 인수에는 소문자 심볼이 있지만 한정자는 대문자뿐입니다
inspection.case.mismatch.message.arg.is.upper=메서드 ''{0}()''이(가) {1}을(를) 항상 반환합니다. 인수에는 대문자 심볼이 있지만 한정자는 소문자뿐입니다

inspection.suspicious.date.format.display.name=의심스러운 날짜 형식 패턴
inspection.suspicious.date.format.message.upper=대문자 ''{0}''({1}) 패턴이 사용됩니다. ''{2}''({3})은(는)의도되었을 가능성이 있습니다.
inspection.suspicious.date.format.message.lower=소문자 ''{0}''({1}) 패턴이 사용됩니다. ''{2}''({3})은(는)의도되었을 가능성이 있습니다.

fix.replace.map.with.flat.map.description='map()'을 'flatMap()'으로 바꿀수 있습니다.

fix.eliminate.folded.if.present.name=접힌 'ifPresent()' 호출 제거
fix.eliminate.folded.if.present.description=접힌 'ifPresent()' 호출을 제거할 수 있습니다

inspection.pattern.variable.can.be.used.display.name=패턴 변수 사용 가능
inspection.pattern.variable.can.be.used.message=변수 ''{0}''을(를) 패턴 변수로 바꿀수 있습니다.
inspection.pattern.variable.can.be.used.fix.family.name=패턴 변수로 바꾸기
inspection.pattern.variable.can.be.used.fix.name=''{0}''을(를) 패턴 변수로 바꾸기
inspection.pattern.variable.can.be.used.existing.message=기존 패턴 변수 ''{0}''을(를) ''{1}'' 대신 사용할 수 있습니다
inspection.pattern.variable.can.be.used.existing.fix.family.name=기존 패턴 변수로 바꾸기
inspection.pattern.variable.can.be.used.existing.fix.name=''{0}''을(를) 기존 패턴 변수 ''{1}''(으)로 바꾸기

array.hash.code.fix.family.name=묵시적 'hashCode'로 바꾸기
objects.hash.fix.family.name='Arrays.hashCode()'로 래핑
unqualified.static.access.fix.family.name=static 액세스 정규화
replace.field.reference.fix.family.name=필드 참조 바꾸기
replace.field.reference.fix.text=필드 참조를 {0}(으)로 바꾸기 
replace.method.call.fix.family.name=메서드 호출 바꾸기
replace.method.call.fix.text=메서드 호출을 {0}(으)로 바꾸기
delete.unnecessary.statement.fix.family.name=중복 구문 제거
increment.decrement.used.as.expression.fix.family.name=별도의 구문으로 추출
use.of.properties.as.hashtable.fix.family.name=프로퍼티 액세스 수정
unnecessary.java.doc.link.fix.family.name=중복 태그 제거
swap.equals.fix.family.name=메서드 호출 반전
remove.modifier.fix.family.name=제어자 제거
shift.out.of.range.fix.family.name=시프트 값 수정
unnecessary.unicode.escape.fix.family.name=문자로 바꾸기
unnecessary.unicode.escape.fix.text=라인 피드 문자로 바꾸기
absolute.alignment.in.user.interface.fix.family.name=상수로 바꾸기
static.inheritance.fix.family.name=상속을 정규화된 참조로 바꾸기
suspicious.to.array.call.fix.family.name=적절한 배열로 바꾸기
incorrect.date.format.fix.family.name=잘못된 날짜 형식 수정
referencing.subclass.0.from.superclass.1.initializer.might.lead.to.class.loading.deadlock=상위 클래스 {1} 이니셜라이저의 하위 클래스 {0}을(를) 참조하면 클래스 로딩 교착 상태가 발생할 수 있습니다
collections.field.access.replaceable.by.method.call.fix.family.name=Collections.EMPTY_*를 호출로 바꾸기
delete.catch.section.fix.family.name=catch 문 삭제
make.field.static.final.fix.family.name=static final 생성
string.concatenation.in.format.call.fix.family.name=연결을 인수로 바꾸기
implicit.array.to.string.fix.family.name=Array.toString()을 묵시적으로 작성
listener.may.use.adapter.fix.family.name=어댑터로 바꾸기
unnecessary.temporary.object.fix.family.name=연결 바꾸기
utility.class.with.public.constructor.fix.family.name=생성자를 private으로 설정
change.modifier.fix.family.name=제어자 변경
make.field.final.fix.family.name=final로 설정
generate.to.string.quick.fix.family.name=\ 생성
generate.to.string.quick.fix.text=toString() 생성
replace.instanceof.fix.family.name=instanceOf 타입 바꾸기
replace.cast.fix.family.name=형 변환 타입 바꾸기
make.package.private.fix.family.name=package-private 생성
make.method.final.fix.family.name=메서드를 'final'로 설정
replace.casted.literal.with.just.literal.fix.family.name={0} 리터럴로 바꾸기
char.used.in.arithmetic.content.cast.fix.family.name=형 변환 삽입
ignore.parentheses.around.single.no.formal.type.lambda.parameter=형식이 없는 단일 타입 람다 매개변수를 둘러싼 소괄호 무시
double.checked.locking.fix.family.name=필드를 volatile으로 설정
declare.collection.as.interface.fix.family.name=타입 약화
string.equals.empty.string.fix.family.name=빈 문자열 검사 간소화
class.without.logger.annotations.tab=어노테이션
class.without.logger.loggers.tab=로거
options.title.ignored.classes=무시된 클래스
options.label.ignored.classes=무시된 클래스:
add.catch.section.fix.family.name='catch' 절 추가
inspection.autocloseable.resource.ignored.methods.title=이 메서드에서 반환된 AutoCloseable 인스턴스 무시:
logger.initialized.with.foreign.class.fix.family.name=외부 클래스 바꾸기
extend.exception.fix.family.name=클래스 확장을 '예외'로 설정
inspection.use.of.private.field.inner.classes.option=내부 클래스로부터의 액세스 무시
refused.bequest.fix.family.name=상위 메서드에 호출 삽입
mark.modules.as.loaded.together.fix.family.name=모듈이 함께 로드되도록 표시
mark.modules.as.loaded.together.fix.text=''{0}'' 및 ''{1}'' 모듈이 함께 로드되도록 표시
inspection.suspicious.package.private.access.description={0}은(는) {1}이지만 다른 모듈 ''{2}''에서 선언되었습니다
ignore.class.fix.family.name=해당 타입 무시
create.default.branch.fix.family.name='default' 브랜치 삽입
unnecessary.fully.qualified.name.fix.family.name=완전히 정규화된 이름 바꾸기
return.of.collection.field.fix.family.name=반환 컬렉션을 'unmodifiable'로 설정
remove.redundant.substring.fix.family.name=중복 'substring()' 호출 제거
remove.redundant.string.fix.text=''{0}()'' 사용 및 중복 ''{1}()'' 호출 제거
use.equalsignorecase.for.case.insensitive.comparison=대/소문자 구분 없는 비교를 위해 equalsIgnoreCase() 사용
make.class.final.fix.family.name=클래스를 final로 설정
side.effects.method.ref.to.lambda.fix.family.name={0} (부수 효과)
encapsulate.variable.fix.family.name=필드 캡슐화
method.may.be.static.replaces.qualifiers.with.class.references.option=빠른 수정에서 인스턴스 한정자를 클래스 참조로 바꿉니다
method.may.be.static.ignore.default.methods.option='default' 메서드 무시
make.public.static.void.fix.family.name=제어자 수정
make.public.static.void.fix.name=''{0}''의 시그니처를 ''{1}''(으)로 변경
convert.empty.anonymous.to.new.fix.family.name='{}' 제거
replace.method.ref.with.qualifier.fix.family.name=한정자로 바꾸기
replace.method.ref.with.qualifier.problem.method=메서드 참조를 한정자로 바꿀수 있습니다
replace.method.ref.with.qualifier.problem.lambda=람다를 메서드 한정자로 바꿀수 있습니다
add.throws.clause.fix.family.name='throws' 절 수정
prefer.empty.array.options.title=빈 배열 선호:
prefer.empty.array.options.mode.always=항상
prefer.empty.array.options.mode.by.level=언어 수준에 따라
prefer.empty.array.options.mode.always.never=사용 안 함(사전 지정된 크기의 배열 선호)
too.broad.scope.inspection.fix.family.name=좁은 범위
replace.with.cast.fix.family.name=형 변환으로 바꾸기
replace.anonymous.with.lambda.body.fix.family.name=호출을 메서드 본문으로 바꾸기
replace.with.method.reference.fix.family.name=메서드 참조의 메서드 호출을 적절한 메서드 호출로 바꾸기
replace.with.lambda.body.fix.family.name=람다 메서드 호출을 람다 본문으로 바꾸기
inspection.trivial.functional.expression.usage.description=메서드 호출을 단순화할 수 있습니다
replace.with.var.fix.family.name=명시적 타입을 'var'로 바꾸기
inspection.redundant.explicit.variable.type.description=지역 변수의 명시적 타입을 생략할 수 있습니다
add.read.write.object.methods.fix.family.name=항상 예외를 던지는 'readObject()' 및 'writeObject()' 메서드 추가
add.read.write.object.methods.fix.text=항상 예외를 던지는 'writeObject()' 메서드 추가
add.read.write.object.methods.fix.text2=항상 예외를 던지는 'readObject()' 메서드 추가
replace.with.method.ref.fix.family.name=람다를 메서드 참조로 바꾸기
replace.with.method.ref.fix.name.may.change.semantics=람다를 메서드 참조로 바꾸기(의미가 변경될 수 있음)
qualify.call.fix.family.name=호출 정규화
replace.with.comparator.fix.family.name='Comparator' static 메서드를 사용하여 비교자 단순화
inspection.comparator.combinators.description='Comparator' 체인으로 바꿀 수 있습니다
inspection.comparator.combinators.description2=''{0}''(으)로 바꿀 수 있습니다
inspection.unnecessary.string.escape.report.char.literals.option=char 문자열 보고
inspection.method.call.in.loop.ignore.known.methods.option=부수 효과가 있는 알려진 메서드 무시
fix.data.provider.signature.family.name=데이터 공급자 메서드 시그니처 수정
allow.suppressions.fix.family.name=억제 허용
allow.suppressions.fix.text=해당 억제 허용
remove.suppress.comment.fix.family.name=//{0} 제거
convert.to.j.unit.4.fix.family.name=JUnit 3 클래스를 JUnit 4로 변환
throws.runtime.exception.fix.family.name='throws' 절에서 제거
move.exception.to.javadoc.fix.family.name=Javadoc '@throws' 태그로 이동
create.package.info.java.family.name='package-info.java' 생성
remove.loop.fix.family.name=루프 제거
remove.call.fix.family.name=호출 제거
inspection.meta.annotation.without.runtime.description={0}에는 @Retention(RetentionPolicy.RUNTIME)이 있어야 합니다
inspection.refused.bequest.super.annotated.option=상위 메서드가 다음과 같이 어노테이션이 추가된 경우에만 보고:
inspection.empty.class.ignore.subclasses.option={0} 하위 클래스 무시
inspection.test.method.without.assertions.exceptions.option=예외를 선언하는 테스트 메서드 무시
inspection.collection.must.have.initial.capacity.initializers.option=필드 이니셜라이저를 보고 안 함
utility.class.without.private.constructor.cant.generate.constructor.title=생성자 생성 불가
utility.class.without.private.constructor.cant.generate.constructor.message=유틸리티 클래스에 인스턴스화가 있어 private 생성자가 생성되지 않습니다
inspection.suspicious.package.private.access.problem=다른 모듈 ''{2}''에서 선언된 {1}의 package-private 메서드를 {0}이(가) 재정의합니다
inspection.condition.covered.by.further.condition.descr=후속 {1, choice, 1#조건 ''''{2}''''|2#조건} 으로 수행되는 조건 ''{0}'' 
inspection.parameterized.parameters.static.collection.display.name=데이터 공급자 메서드가 없는 매개변수화된 테스트 클래스
create.missing.switch.branch=누락된 switch 브랜치 ''{0}'' 생성
create.missing.switch.branches=누락된 브랜치 생성: {0}
redundant.as.list.for.iteration.problem=불필요한 'Arrays.asList()' 호출
redundant.as.list.for.iteration.fix.name=줄 바꿈 해제
assert.with.side.effects.call.mutates.expression=''{0}()'' 호출은 ''{1}''을(를) 변이시킵니다
assert.with.side.effects.call.mutates.field=''{0}()'' 호출은 필드 ''{1}''을(를) 변이시킵니다
inspection.comparator.combinators.fix.chain='Comparator' 체인으로 바꾸기
logger.initialized.with.foreign.options.title=로거 팩토리 클래스 선택
test.without.assertion.options.choose.class=어설션 클래스 선택
constant.on.lhs.of.comparison.options.item.left=왼쪽
constant.on.lhs.of.comparison.options.item.right=오른쪽
convert.junit3.test.fix.conflict.semantics={1}이(가) JUnit 4로 변환될 경우 메서드 호출 {0}이(가)의미를 변경할 수 있습니다
convert.junit3.test.fix.conflict.compile={1}이(가) JUnit 4로 변환될 경우 메서드 호출 {0}이(가) 컴파일하지 않습니다
convert.junit3.test.fix.conflict.compile.2={1}이(가) JUnit 4로 변환될 경우 참조 {0}이(가) 컴파일하지 않습니다
inspection.byte.array.output.stream.to.string.message=ByteArrayOutputStream으로부터의 비효율적인 변환

fix.data.provider.signature.fix.name=메서드 시그니처를 ''{0}''(으)로 변경
fix.data.provider.create.method.fix.name=데이터 공급자 메서드 '@Parameters public static Iterable<Object> parameters()' 생성
fix.data.provider.signature.missing.method.problem=매개변수화된 테스트 클래스 <code>#ref</code>에 '@Parameters' 어노테이션이 추가된 데이터 공급자 메서드가 없습니다
fix.data.provider.signature.incorrect.problem=데이터 공급자 메서드 <code>#ref()</code>에 잘못된 시그니처가 있습니다
fix.data.provider.multiple.methods.problem=클래스 <code>#ref</code>에 여러 @Parameters 데이터 공급자 메서드가 있습니다
cloneable.class.without.clone.todo.message=TODO: 이 복제본이 원본의 내부를 변경할 수 없도록 여기에 가변 상태 복사합니다
cloneable.class.without.clone.ignore.when.clone.called.option=상위 클래스의 clone() 메서드를 호출하는 데 Cloneable이 필요한 경우 무시
trivial.if.option.ignore.assert.statements=자명한 'assert'가 있는 'if' 문 무시
if.may.be.factorized.problem.descriptor=<code>#ref</code>을(를) 인수분해할 수 있습니다 #loc
if.may.be.factorized.quickfix=인수분해된 표현식으로 바꾸기
weaken.visibility.quickfix=가시성 약화
non.final.field.in.enum.quickfix.option=빠른 수정을 사용할 수 없는 경우 필드 무시
checkbox.ignore.null.on.wrong.side=<html>잘못된 쪽의 <code>null</code> 무시</html>
cyclic.class.dependency.ignore.in.same.file=같은 파일에 있는 클래스 간 순환 무시
ambiguous.field.access.navigate.quickfix=분명히 접근된 {0, choice, 1#지역 변수|2#매개변수|3#필드}로 이동
logger.initialized.with.foreign.class.ignore.super.class.option=상위 클래스로 초기화된 로거 무시
logger.initialized.with.foreign.class.ignore.non.public.classes.option=비 public 클래스의 로거 무시
dangling.javadoc.ignore.copyright.option=JavaDoc 형식의 파일 헤더 주석 무시
package.in.multiple.modules.problem.descriptor2=패키지 ''{0}''은(는) 클래스가 모듈 ''{1}'' 및 ''{2}''에 있습니다
package.in.multiple.modules.problem.descriptor3=패키지 ''{0}''은(는) 클래스가 모듈 ''{1}'', ''{2}'' 및 ''{3}''에 있습니다
package.in.multiple.modules.problem.descriptor.many=패키지 ''{0}''은(는) 클래스가 모듈 ''{1}'', ''{2}'' 및 ''{3}'' 기타 모듈에 있습니다
use.isblank.to.check.if.string.is.whitespace.or.empty='isBlank()'를 사용하여 문자열이 비어 있거나 공백만 포함되어 있는지 확인합니다
expression.may.be.factorized.display.name=표현식을 인수분해할 수 있음
create.missing.enum.switch.branches.fix.family.name=누락된 열거형 switch 브랜치 생성
create.missing.sealed.class.switch.branches.fix.family.name=누락된 sealed 클래스 switch 브랜치 생성
inspection.case.mismatch.message.label.is.lower=Switch 브랜치에 도달할 수 없습니다. 라벨에 소문자 심볼이 포함되어 있지만 선택자는 대문자뿐입니다.
inspection.case.mismatch.message.label.is.upper=Switch 브랜치에 도달할 수 없습니다. 라벨에 대문자 심볼이 포함되어 있지만 선택자는 대문자뿐입니다
for.can.be.foreach.fix.no.indexed=색인이 생성된 'java.util.List' 루프 보고 안 함
use.of.concrete.class.option.ignore.records=Java 레코드 무시
create.null.branch.fix.family.name='null' 브랜치 삽입
instanceof.concrete.class.pattern.problem.descriptor=구체 클래스 <code>#ref</code>에 대한 패턴 테스트 #loc
remove.annotation.parameter.0.fix.name=어노테이션 매개변수 ''{0}'' 제거
set.annotation.parameter.0.1.fix.name=어노테이션 매개변수 {0} = ''{1}'' 설정
progress.text.analyzing.package.0=패키지 ''{0}'' 분석 중
unnecessary.inner.interface.modifier.problem.descriptor=제어자 <code>#ref</code>이(가) 내부 인터페이스와 중복됩니다 #loc
unnecessary.interface.method.modifier.problem.descriptor=제어자 <code>#ref</code>이(가) 인터페이스 메서드와 중복됩니다 #loc
unnecessary.interface.inner.class.modifier.problem.descriptor=제어자 <code>#ref</code>이(가) 인터페이스의 내부 클래스와 중복됩니다 #loc
unnecessary.interface.field.modifier.problem.descriptor=제어자 <code>#ref</code>이(가) 인터페이스 필드와 중복됩니다 #loc
unnecessary.modifier.display.name=불필요한 제어자
unnecessary.enum.constructor.modifier.problem.descriptor=제어자 <code>#ref</code>이(가) 열거형 생성자와 중복됩니다 #loc
unnecessary.inner.enum.modifier.problem.descriptor=제어자 <code>#ref</code>이(가) 내부 열거형과 중복됩니다 #loc
unnecessary.record.modifier.problem.descriptor=제어자 <code>#ref</code>은(는) 레코드에 불필요합니다
unnecessary.inner.record.modifier.problem.descriptor=제어자 <code>#ref</code>은(는) 내부 레코드에 불필요합니다
unnecessary.transient.modifier.problem.descriptor=제어자 <code>#ref</code>가 'static' 필드와 중복됩니다 #loc
unnecessary.strictfp.modifier.problem.descriptor=제어자 <code>#ref</code>가 Java 17 이후에서 중복됩니다 #loc
inspection.replace.on.literal.display.name=대체 작업이 효과가 없습니다
missing.override.warn.on.super.option=재정의하는 모든 메서드가 '@Override' 어노테이션이 없는 경우 메서드를 강조 표시
unnecessary.interface.member.modifier.problem.descriptor=제어자 <code>#ref</code>이(가) 인터페이스 멤버와 중복됩니다 #loc
try.with.identical.catches.checkbox.different.comments=다른 주석이 있는 catch 블록을 보고하지 않음
unresolved.class.reference.repair.display.name=해결되지 않은 클래스 참조
unresolved.class.reference.repair.problem.descriptor=''{0}'' 참조를 해결할 수 없습니다
switch.statement.with.too.few.branches.ignore.pattern.option=패턴 switch 문을 보고하지 않음
pattern.variable.hides.field.display.name=패턴 변수가 필드를 숨김
pattern.variable.hides.field.problem.descriptor=패턴 변수 <code>#ref</code>이(가) 클래스 ''{0}''의 필드를 숨깁니다 #loc
law.of.demeter.field.problem.descriptor=<code>#ref</code> 액세스가 데메테르의 법칙을 위반합니다 #loc
instantiating.datetimeformatter.without.locale.problem.descriptor=국제화된 컨텍스트에서 로케일을 지정하지 않은 상태로 <code>DateTimeFormatter.#ref</code>을(를) 호출합니다 #loc
change.modifier.package.private.quickfix=package-private 생성
inspection.non.strict.comparison.equality.message=상등으로 교체 가능
inspection.non.strict.comparison.equality.display.name=비엄격 불일치 '>=' 또는 '<='는 '=='로 교체 가능
inspection.quirk.method.reference.return.type.message=대상 메서드 반환 타입에 액세스할 수 없는 클래스 {0}이(가) 있습니다. 이로 인해 런타임에 IllegalAccessError가 발생합니다.
test.method.is.public.void.no.arg.problem.descriptor1=테스트 메서드 <code>#ref()</code>에 매개변수가 있으면 안 될 것입니다 #loc
test.method.is.public.void.no.arg.problem.descriptor2=테스트 메서드 <code>#ref()</code>이(가) 'public void'로 선언되지 않았습니다 #loc
test.method.is.public.void.no.arg.problem.descriptor3=테스트 메서드 <code>#ref()</code>이(가) 'static'이면 안 됩니다 #loc