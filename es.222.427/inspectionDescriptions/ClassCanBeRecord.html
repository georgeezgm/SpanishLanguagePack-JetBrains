<html>
<body>
클래스를 레코드로 바꾸도록 제안합니다.
<p>이 검사는 확장 가능한 동작보다는 불변 데이터를 모델링하는 데 초점을 두는 경우 유용합니다.
  equals 및 접근자와 같은 데이터 중심 메서드의 자동 구현은 보일러플레이트를 제거하는 데 도움을 줍니다.</p>
<p>
  모든 클래스가 레코드가 될 수 있는 것은 아닙니다. 다음 몇 가지 제한 사항입니다:
</p>
<ul>
  <li>클래스는 상속자를 포함하지 않아야하며, 반드시 최상위 클래스여야합니다.</li>
  <li>클래스 내 모든 비 정적 필드는 final이여야합니다.</li>
  <li>클래스는 인스턴스 이니셜라이저, 제네릭 생성자 또는 네이티브 메서드를 포함하지 않아야합니다.</li>
</ul>
<p>모든 제한 사항 목록을 확인하려면, <a href="https://docs.oracle.com/javase/specs/jls/se15/preview/specs/records-jls.html">Oracle documentation</a>을 참조하세요.</p>
<!-- tooltip end -->
<p>예:</p>
<pre><code>
  class Point {
    private final double x;
    private final double y;

    Point(double x, double y) {
      this.x = x;
      this.y = y;
    }

    double getX() {
      return x;
    }

    double getY() {
      return y;
    }
  }
</code></pre>
<p>빠른 수정 적용 후:</p>
<pre><code>
  record Point(int x, int y) {
  }
</code></pre>
<p><code>getX()</code>/<code>isX()</code> 접근자 이름을 <code>x()</code>로 자동 변경하도록 허용하려면 <b>Suggest renaming get/is-accessors(get/is 접근자 이름 변경 제안)</b> 옵션을 활성화하세요.</p>
<p>
  <b>When conversion makes a member more accessible(변환으로 멤버의 접근성을 높일 때)</b> 옵션을 사용하여 변환이 클래스 캡슐화를 위반할 수 있는지 지정하세요.
<ul>
  <li>클래스 캡슐화를 위반하지 않으려면 <b>Do not suggest conversion(변환을 제안 안 함)</b> 옵션을 선택하세요</li>
  <li>캡슐화 위반 문제에 대한 알림과 함께 변환을 적용하려면 <b>Show affected members in conflicts view(영향을 받은 멤버를 충돌 뷰에 표시)</b> 옵션을 선택하세요</li>
  <li>캡슐화 위반 문제의 유무와 무관하게 확인 없이 변환을 적용하려면 <b>Convert silently(확인 없이 변환)</b> 옵션을 선택하세요</li>
</ul>
<p>지정된 패턴과 일치하는 어노테이션이 추가된 경우, 변환에서 클래스를 제외하려면 <b>Suppress conversion if class is annotated by(클래스에 다음 어노테이션이 추가된 경우 변환 억제)</b> 목록을 사용하세요.
</p>
<p>이 검사는 프로젝트 또는 모듈의 언어 수준이 16 이상인 경우에만 보고합니다.</p>
<p><small>2020.3의 새로운 기능</small></p>
</body>
</html>