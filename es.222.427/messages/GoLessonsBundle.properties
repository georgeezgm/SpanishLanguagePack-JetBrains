go.feature.trainer.specify.sdk.to.continue.learning.title=학습을 계속하려면 Go SDK 지정
go.feature.trainer.too.old.go.sdk.notification.title=<b>{0}</b> 이후 버전으로 Go SDK 업데이트
go.feature.trainer.too.old.go.sdk.notification.text=튜토리얼에서는 Go 모듈을 사용한 종속성 관리에 GoSDK <b>{1}</b> 이후 버전이 필요합니다. 현재의 GoSDK 버전은 <b>{0}</b>입니다.
go.working.with.json.name=JSON 작업 중
go.working.with.json.copy=<ide/>에는 JSON 코드를 더 효과적으로 처리하는 데 도움이 되는 여러 가지 도구가 있습니다.\n\
go.working.with.json.replace={0}을(를) 눌러 주석 섹션을 교체합니다. {1} 대화상자가 나타나면 <strong>예</strong>를 클릭하세요.\n\
go.working.with.json.name.struct=구조체 이름을 변경하고 {0}을(를) 입력한 후 {1}을(를) 눌러 편집을 종료하세요. IDE에서 서식을 자동으로 수정합니다.
go.working.with.json.introduce.type={1} 구조체 내부에 포함된 {0} 구조체를 추출해봅시다.\n\
go.working.with.json.change.style=태그 내 필드 이름에 다른 코드 스타일을 적용할 수 있습니다. 예를 들어, 낙타 표기법(camelCase)으로 변경해보세요. {0}을(를) 누르고 {1}을(를) 클릭한 다음 {2}을(를) 선택하세요.
go.working.with.json.update.value.in.tags=태그 값 배치 업데이트에 대해서도 마찬가지입니다. 현재 구조체의 모든 태그에 {0}을(를) 추가한다고 가정해봅시다.\n\
go.working.with.json.add.key.to.tags=XML 태그와 ASN1 태그를 추가하려면 인텐션 액션을 사용할 수도 있습니다.\n\
go.generate.getters.and.setters.name=getter 및 setter 생성
go.generate.getters.and.setters.action=구조체 필드의 getter와 setter를 생성해야 하는 상황에서는 인텐션 액션을 사용하세요.\n\
go.handling.unhandled.errors.name=처리되지 않는 오류 처리 중
go.handling.unhandled.errors.handle.error={0} 코드 검사는 오류 값을 반환하는 함수 또는 메서드에 대해 경고하지만 이러한 오류 값은 검사되지 않습니다. 이를 처리하려면 다음의 빠른 수정을 사용할 수 있습니다.\n\
go.handling.unhandled.errors.handle.error.var.name=변수 이름으로 {0}을(를) 입력하고 {1}을(를) 누르세요.
go.handling.unhandled.errors.wrap.in.closure=또 다른 빠른 수정은 {0} 및 {1} 문에 사용됩니다. {2} 빠른 수정과 비슷하게 작동하지만 코드를 클로저 안에 감쌉니다.\n\
go.support.of.go.embed.name=기본 코드 완성: //go:embed 활용
go.support.of.go.embed.string={0} 지시문을 사용하여 빌드 시간 동안 파일 및 디렉터리를 Go 바이너리에 포함할 수 있습니다.\n\
go.support.of.go.embed.note={0}: {1} 지시문을 사용하려면 Go 1.16 이후 버전이 설치되어 있는지 확인하세요. Go SDK 설치에 관한 자세한 내용은 <a href="{2}">문서에서 Go SDK 다운로드</a>를 참조하세요.
go.support.of.go.embed.navigate=파일에 여전히 이슈가 있습니다. {0}을(를) 눌러 다른 이슈로 이동하세요.
go.support.of.go.embed.fs=검사에 따르면 지정된 디렉터리가 없습니다. 이 디렉터리를 기존 디렉터리로 교체할 수 있습니다.\n\
go.var.check.error.postfix.template.name=varCheckError 접미사 템플릿
go.var.check.error.postfix.template.call=오류 처리 논의를 계속해봅시다. 이번에는 {0} 접미사 템플릿입니다. 오류를 반환하는 식별자 뒤에 입력하는 경우, <ide/>에서 디폴트 변수 이름을 자동으로 추가하고 함수에서 발생한 오류를 반환합니다.\n\
go.var.check.error.postfix.template.anonymous.variable={0}을(를) 입력하여 빈 식별자를 사용한 다음 {1}을(를) 누르세요.
go.var.check.error.postfix.template.quick.fix=Go 1.16에는 {0}에 관한 새로운 검사가 도입되었습니다. 이 검사는 바이트 슬라이스가 마샬링되지 않은 값이 {1}이(가) 아닌지 확인합니다. <ide/>은(는) 그러한 경우를 탐지하고 이슈를 해결하는 빠른 수정 기능을 갖추고 있습니다. {2}을(를) 누른 다음 {3}을(를) 선택하세요.
go.wrapping.lesson.name=긴 줄 줄 바꿈
go.wrapping.put.arguments.on.separate.lines={0} 함수에 상당히 많은 인수가 전달됩니다. 문제는 첫 번째 인수가 매우 길고 그 뒤의 내용을 확인할 수 없다는 것입니다. 이 문제를 수정할 수 있습니다. 여는 대괄호 뒤에 캐럿이 배치되었으므로 이제 {1} 을(를) 누르고 {2} 을(를) 선택해야 합니다.
go.wrapping.enable.soft.wrap=첫 번째 인수가 여전히 가시 영역 밖에 있습니다. 긴 줄에 소프트 랩을 활성화하는 것이 좋습니다. {0}을(를) 누르고 {1}을(를) 입력한 다음, {2} 스위치를 전환하세요. 나중에 {3}을(를) 눌러 검색을 닫을 수 있습니다.
go.wrapping.put.parameters.on.same.lines={0} 함수의 인수는 한 줄로 처리하면 더 보기 좋을 것 같습니다. 병합하려면 여는 대괄호 뒤에 캐럿을 배치하고 {1}을(를) 눌러 인텐션 액션을 호출한 다음, {2}을(를) 선택하세요.
go.struct.inspections.lesson.name=구조체 검사
go.struct.inspections.jump.to.warning=Go에는 구조체 태그 프로그래밍에 관한 규칙이 있습니다. 이 규칙에 대한 자세한 내용은 <a href\="{0}">golang.org의 이 도움말</a>에서 확인할 수 있습니다.\n\
go.struct.inspections.delete.line=경고에서는 두 개의 구조체 필드({0} 및 {1})를 동일한 JSON 필드 이름에 매핑하려는 시도가 좋지 않다는 것을 나타냅니다. 이 오류가 발생하면 프로그램은 실행되지만 출력에서 하나의 키가 누락됩니다.\n\
go.inspection.unsafe.context.cancellation.name=안전하지 않은 컨텍스트 취소
go.inspection.unsafe.context.cancellation.go.to.error={0} 코드 검사는 {2} 이(가) 반환하는 {1} 함수와 그와 유사한 함수가 모든 실행 경로에서 호출되는지 확인합니다. 컨텍스트 패키지에 관해 더 자세히 알아보려면 <a href\="{3}">golang.org의 패키지 컨텍스트</a>를 참조하세요.\n\
go.inspection.unsafe.context.cancellation.add.defer={1} 실행 경로에서 {0} 을(를) 호출하지 않으므로 {2} 을(를) 입력하여 경고를 수정해야 합니다.
go.formatting.lesson.name=코드 스타일을 코드에 적용
go.formatting.reformat.selection=<ide/>은(는) 코드 서식 지정을 지원합니다. 선택한 코드 블록의 서식을 다시 지정하려면 {0}을(를) 누르세요.
go.formatting.clear.selection=선택 범위를 정리하려면 {0}을(를) 누르세요.
go.formatting.whole.file=줄이 선택되지 않은 경우 전체 소스 파일의 서식을 다시 지정하려면, {0}을(를) 사용하세요.
go.fmt.lesson.name=go fmt 실행
go.fmt.task=코드 서식을 {0} (으)로 지정하고 싶은 경우 {1} 을(를) 눌러 실행할 수 있습니다.
go.comments.lesson.name=주석 추가 및 제거
go.comments.comment.one.line={0} (으)로 어느 줄이든 주석 처리하세요.
go.comments.uncomment.line=같은 단축키 {0}(으)로 주석이 추가된 줄에서 주석 제거
go.comments.comment.block=코드 블록에서 주석을 제거할 수 있습니다. 예를 들어 선택한 블록에서 주석을 제거하려면 {0}을(를) 눌러봅시다.
go.code.completion.for.time.package.name=시간 패키지 코드 완성
go.code.completion.for.time.package.year=날짜 및 시간 요소의 서식을 지정하기 위해 {0} 패키지는 이미 정의된 레이아웃인 {1} 을(를) 사용합니다. 그렇기 때문에 참조 시간 요소를 자리표시자로 사용해 서식을 정의하게 됩니다.\n\
go.code.completion.for.time.package.month=다시 {0} 을(를) 누르고 달로 {1} 을(를) 선택하세요.
go.code.completion.for.time.package.hour=제안 목록에서 {0} 을(를) 선택해 시간에 대해서도 동일한 작업을 하세요.
go.code.completion.for.time.package.minute=분으로 {0} 을(를) 선택하여 템플릿을 완료하세요.
go.basic.completion.lesson.name=기본 코드 완성
go.basic.completion.invoke.completion=<ide/>은(는) 새 import 문을 자동으로 삽입합니다. 이제 ''기본 완성''을 활성화하기 위해 {0}을(를) 누르면 조회 메뉴가 다시 표시됩니다.
go.basic.completion.type.and.choose=기본적으로 <ide/>은(는) 코드 완성을 즉시 제안합니다. 캐럿이 있는 곳에서 {0}을(를) 입력하기 시작하면 그에 대응하는 제안 항목이 포함된 조회 메뉴가 표시됩니다. {2}을(를) 누르면 조회 메뉴에서 {1}을(를) 선택할 수 있습니다.
go.smart.type.completion.lesson.name=스마트 유형 완성
go.smart.type.completion.task=스마트 유형 완성은 제안 목록을 필터링하여 현재 컨텍스트에서 적용 가능한 유형만을 포함합니다. {0}을(를) 눌러 대응하는 제안 목록을 확인하세요. 첫 번째 항목을 선택하려면 {1}을(를) 누르세요.
go.smart.type.completion.special.cases.lesson.name=유형 어설션 및 switch 생성
go.smart.type.completion.special.cases.number=변수 유형의 유효성을 검사하거나 확인해야 하는 경우, 유형 어설션이나 switch 구문을 사용할 수 있습니다. <ide/>은(는) 제안 목록의 시작 부분에 그러한 유형을 표시합니다. 제안 개수를 줄이려면 유형 이름을 계속 입력하세요.\n\
go.smart.type.completion.special.cases.line={0} 함수에 문자열을 전달하기로 했다면 {1} 오류가 표시될 것입니다. 값의 유형을 확인하려는 경우 유형 switch 구문을 사용할 수 있습니다. {2}을(를) 눌러 {3}을(를) 선택하세요.
go.smart.type.completion.and.pointers.lesson.name=스마트 유형 완성 및 포인터
go.smart.type.completion.and.pointers.first.task=<ide/>은(는) 가능한 포인터 및 변수 주소 목록을 제안할 수 있습니다.\n\
go.smart.type.completion.and.pointers.second.task=스마트 유형 완성은 포인터에서도 작동합니다. 포인터를 반환하려면 {0}을(를) 눌러 {1}을(를) 선택하세요.
go.postfix.templates.lesson.name=접미사 템플릿(nn, panic, rr, return)
go.postfix.templates.nn=접미사 템플릿을 사용하면 점 뒤의 접미사, 표현식 유형, 해당 컨텍스트를 기반으로 이미 입력된 표현식을 다른 표현식으로 변환할 수 있습니다. 사전 정의된 접미사 완성 템플릿 세트를 사용하거나 새 템플릿을 생성할 수 있습니다. 사용자 지정 접미사 템플릿에 관한 자세한 내용은 <a href \= "{0}">이 문서 자료</a>를 참조하세요.\n\
go.postfix.templates.choose.item={0}을(를) 입력하고 <action>EditorEnter</action>를 누르세요. 제안 목록에서 {1}을(를) 선택하세요.
go.postfix.templates.rr={0} 접미사 완성 템플릿은 오류 변수가 {1}이(가) 아닌지 확인하는 코드를 생성합니다. 오류 처리를 위해 {0} 접미사 완성 템플릿을 사용할 수 있습니다.\n\
go.postfix.templates.return={0}을(를) 입력하고 {1} 접미사 템플릿을 적용하세요.
go.postfix.completion.lesson.name=접미사 완성 및 정렬
go.postfix.completion.task=알파벳 슬라이스가 무질서한 상태입니다. 문자열 슬라이스를 올바르게 정렬하기 위해 {1} 패키지의 {0} 함수를 슬라이스에 적용할 수 있습니다.\n\
go.completion.for.functions.lesson.name=함수의 코드 완성
go.completion.for.functions.choose.item=목록에서 {0}을(를) 선택하고 {1}을(를) 누르세요. 제안 목록이 표시되면 입력을 시작하여 결과 수를 줄일 수 있습니다.
go.completion.for.functions.press.twice=요소를 첫 번째 인수로 허용하는 모든 함수를 찾으려면 {0}을(를) <strong>두 번</strong> 누르세요. 요소는 메서드가 아니지만 점 때문에 그렇게 보이니 유의하세요.
go.debug.function.calls.lesson.name=함수 호출 디버그
go.debug.function.calls.version.warning=<strong>참고</strong>\: 이 기능을 사용하려면 Go 1.11 또는 이후 버전을 설치해야 합니다.
go.debug.function.calls.toggle.breakpoint=디버그 모드에서 함수에 다른 값을 전달하고 함수가 반환하는 결과를 확인할 수 있습니다. 표현식 평가 기능에 관한 자세한 내용은 <a href\="{0}">문서</a>를 참조하세요.\n\
go.debug.function.calls.mac.note=디버그 서버를 시작하기 위해 운영 체제에서 비밀번호를 요청할 수 있습니다.
go.debug.function.calls.run.to.cursor=이제 캐럿은 15행의 끝에 있습니다. {1} 액션의 작동 방식을 확인하려면 {0}을(를) 누르세요.
go.debug.function.calls.step.over={1}을(를) 사용하여 {0} 구문을 스텝오버해 보세요.
go.debug.function.calls.evaluate.expression={1}을(를) 눌러 {0} 액션을 호출하세요.
go.debug.function.calls.enter.expression.to.evaluate={0} 필드에 {1}을(를) 입력하기 시작한 다음 제안 목록에서 {2}을(를) 선택하세요.
go.debug.function.calls.add.arguments.for.evaluation=소괄호 안에 {0}을(를) 입력하세요. 필드에 {1}이(가) 표시되어야 합니다.
go.debug.function.calls.click.evaluate={0}을(를) 클릭하거나 {1}을(를) 누르세요. 그 후에 대화상자를 닫을 수 있습니다.
go.dump.goroutines.name=Goroutines 덤프
go.dump.goroutines.toggle.breakpoint={4} 섹션에서는 <ide/>에 추가된 기능 몇 가지를 설명합니다. 다른 기능은 <a href\="{0}">새로운 기능 페이지</a>에서 확인하세요.\n\
go.dump.goroutines.click.button.DlvFilterGoroutinesAction=열린 {0} 탭에서 {1} 버튼을 클릭하세요.
go.dump.goroutines.filter.goroutines={0} 검색 필드에서 {1} 을(를) 입력해 목록을 필터링하세요. 이 필터는 이름에 {1} 이(가) 있는 goroutines를 가진 실행 스택만 남깁니다.
go.general.templates.lesson.name=라이브 및 접미사 템플릿\: else, fori, var
go.general.templates.fori=이제 {0}을(를) 입력하고 제안 목록에서 이 라이브 템플릿을 선택하세요. 루프에서 다음 조건을 설정하세요. {1}.
go.general.templates.type.iteration=각 반복에서 {0} 루프는 {1}을(를) 실행해야 합니다
go.general.templates.vars=현재 프로그램은 사용자가 키보드로 입력한 숫자를 읽고 {0} 루프에서 사용합니다. 그러나 <ide/> 2020.1부터는 템플릿을 사용하여(상수에는 {1}, 변수에는 {2}, 유형에는 {3}, import 문에는 {4}) 구문 그룹을 더 빠르게 코딩할 수 있습니다.\n\
go.handling.errors.with.templates.lesson.name=라이브 및 접미사 템플릿의 오류 처리\: if 및 rr
go.handling.errors.with.templates.if.not.null=일부 함수는 두 개의 값을 반환합니다. 예를 들어 {0}은(는) {1}에 대한 포인터와 오류 값을 반환합니다. 오류 값이 {2}이면 파일이 성공적으로 열립니다. 오류가 {3}이 아니면 오류가 발생한 것입니다. <ide/>에서 라이브 및 접미사 템플릿을 사용하면 오류 값 처리를 훨씬 빠르게 작성할 수 있습니다.\n\
go.handling.errors.with.templates.return.nil.err=파일을 여는 동안 오류가 발생하면 슬라이스와 오류를 반환해야 합니다. 여기서는 {0} 및 {1}을(를) 반환할 수 있습니다. {2}을(를) 입력하기 시작하고 {3} 라이브 템플릿을 선택하세요.
go.handling.errors.with.templates.error.case=접미사 코드 완성은 코드를 작성할 때 역방향 캐럿 이동을 줄이는 데 도움이 됩니다. 이러한 템플릿을 사용하면 이미 입력한 표현식을 다른 표현식으로 변환할 수 있습니다. 접미사 완성에 관한 더 많은 강의는 {0} 섹션에서 찾을 수 있습니다.\n\
go.live.templates.with.types.lesson.name=라이브 템플릿 및 유형 사용
go.live.templates.with.types.struct.template=구조체는 이름이 지정된 필드가 포함된 유형입니다. 구조체는 데이터를 그룹화하여 레코드를 형성하는 데 유용합니다. 이 코드용으로 하나 만들어 보겠습니다.\n\
go.live.templates.with.types.type.fields={1} 구조체의 필드로 {0}을(를) 추가하세요.
go.live.templates.with.types.interface.template=Go에서 인터페이스는 메서드 시그너처 세트를 지정할 수 있는 사용자 지정 유형입니다. 하나 추가해 봅시다\!\n\
go.live.templates.with.types.add.method={1} 인터페이스에 대한 메서드 시그니처로 {0}을(를) 추가하세요.
go.live.templates.with.types.complete.in.comment=주석은 프로그램 작동 방식과 거기에 내포된 사용자의 의도를 설명합니다. 주석에서 코드 완성을 사용하여 매개변수, 함수, 메서드의 이름을 완성할 수 있습니다.\n\
go.live.templates.with.types.add.second.return.value=현재 {0} 메서드는 문자열 매개변수만 반환합니다. 면적 값을 가진 {1} 반환 값을 추가해야 합니다. <ide/>은(는) 여러 반환 유형 주위에 소괄호를 자동으로 추가합니다.\n\
go.live.templates.with.types.fill.all.fields=마지막으로 사각형의 새 인스턴스를 만들고 {0} 및 {1}에 대한 값을 전달해 보겠습니다.\n\
go.generate.missing.methods.lesson.name=누락된 메서드 생성
go.generate.missing.methods.task={0} 액션을 사용하면 메서드나 매개변수 이름이 인터페이스 정의에서 생략된 경우에도 누락된 메서드를 생성하고 매개변수 이름을 지정할 수 있습니다.\n\
go.fixing.test.lesson.name=테스트 파일 수정
go.fixing.test.open.problems.toolwindow={0} 도구 창은 현재 파일의 경고 및 오류 목록을 표시하고 해당 문제에 대한 설명을 제시합니다.\n\
go.fixing.test.close.problems=주의해야 할 몇가지 문제가 있습니다. 일부 문제는 {0} 도구 창 자체에서 수정할 수 있습니다. 그러나 일부 문제는 에디터에서 특정 액션이 필요합니다. 에디터에서 모든 수정을 적용해 보겠습니다\!\n\
go.fixing.test.fix.string.conversion=이 {0} 변환은 필요한 10진수 문자열 표현이 아닌 유니코드 코드 포인트의 UTF-8 표현을 반환합니다.\n\
go.fixing.test.use.multicursors=다음 오류는 매우 명백하게도 익명 구조체에 닫는 중괄호와 쉼표가 없습니다. 그렇다고 각 줄에 반복해서 입력하고 싶지는 않습니다. 이럴 때 다중 커서가 도움이 될 수 있습니다.\n\
go.fixing.test.fix.camelcase={1} 패키지에 관한 <a href\="{0}">Go 문서</a>에는 함수 이름을 낙타 표기법(예\: {2})으로 작성해야 한다고 나와 있습니다. 여기서 {3} 함수는 이 규칙을 준수하지 않습니다.\n\
go.fixing.test.negate=마지막은 실제로 오류가 아니라 코드를 단순화하는 간단한 리팩터링입니다. {0} 함수의 부정을 확인하세요. 여기서 무엇을 할 수 있는지 살펴보겠습니다.\n\
go.quick.fix.refactorings.lesson.name=빠른 수정, 리팩터링, 외부 문서
go.quick.fix.refactorings.change.to.formatting={0} 함수는 디폴트 형식으로 변수 목록을 인쇄합니다. 한편 {1} 함수를 사용하면 출력 형식을 지정할 수 있습니다. 이 예시에서는 부동 소수점 숫자에 대해 형식화 동사({2})를 사용합니다. 하지만 {1} 대신 {0}을 사용합니다.\n\
go.quick.fix.refactorings.create.variable=변수를 선언하는 방법에는 여러 가지가 있습니다. 변수가 선언되면 등호({0})를 사용하여 값을 대입할 수 있습니다.\n\
go.quick.fix.refactorings.rename=<ide/>에서 요소의 이름을 변경하면 해당 변경 내용을 적용할 수 있습니다. <ide/>은(는) 코드 요소의 이름을 변경하고 그에 따라 사용 위치를 업데이트합니다.\n\
go.quick.fix.refactorings.extract.method=메서드 추출 리팩터링을 사용하면 코드 조각을 취해 분리된 함수로 이동하고 이전 코드를 함수 호출로 바꿀수 있습니다. 모든 인쇄를 별도의 함수로 이동해 보겠습니다.\n\
go.quick.fix.refactorings.external.doc=외부 문서는 웹 브라우저에서 필요한 정보를 열어 주기 때문에 관련 심볼을 탐색하는 동시에 추가 참조를 위해 정보를 보관할 수 있습니다.\n\
go.apply.fix={0} 을(를) 선택하고 {1} 을(를) 누르세요.
go.introduce.function.lesson.name=함수 유형에서 함수 생성
go.introduce.function.intro=<ide/>은(는) 호출에서 함수와 메서드를 생성할 수 있습니다. 이제 함수나 메서드가 누락된 경우 해당 유형에서 생성할 수도 있습니다.
go.introduce.function.invoke.intentions=캐럿이 함수 참조로 사용되는 {0} 식별자의 위치에 있는지 확인하세요. {1}을(를) 눌러 인텐션 액션을 호출하세요.
go.introduce.function.final.propose=그런 다음, 이제 필요에 따라 매개변수를 조정할 수 있습니다.
go.implement.missing.methods.lesson.name=누락된 메서드 구현
go.delete.conversion.lesson.name=중복된 유형 변환
go.delete.conversion.intro=<strong>중복된 유형 변환</strong> 검사는 생략 가능한 중복된 유형 변환을 경고합니다(예\: 문자열 리터럴을 문자열로 변환하는 경우). 이 검사에 관한 자세한 내용은 <a href\="{0}">중복된 유형 변환</a>을 참조하세요.
go.delete.conversion.invoke.intentions=에디터에서 {0} 함수를 확인하세요. 캐럿은 {2}에서 {1} 유형으로의 형 변환의 위치에 있습니다. {3}을(를) 눌러 인텐션 액션을 호출하세요.
go.variadic.functions.lesson.name=가변 함수 처리
go.variadic.functions.unpack.slice=가변 함수는 {0} 등 다양한 수의 인수를 사용하여 호출할 수 있는 함수입니다.\n\
go.variadic.functions.inline=슬라이스를 슬라이스의 가변 인수로 바꿀수 있습니다. {0}을(를) 눌러 {1} 리팩터링을 호출하세요.
go.variadic.functions.introduce.variable={0} 리팩터링을 되돌리려면 {1} 리팩터링을 사용하세요. {2}을(를) 누르고 제안 목록에서 {3}을(를) 선택하세요.
go.improve.names.lesson.name=오류 변수의 이름 개선
go.improve.names.intro=<ide/>은(는) 오류({0}) 및 컨텍스트({1}) 변수의 가장 인기 있는 이름 변형을 제안합니다.
go.improve.names.introduce.variable=캐럿이 {0} 호출의 위치에 있는지 확인하세요. {1}을(를) 눌러 변수를 추출하세요.
go.improve.names.apply.fix=목록에서 전체 호출을 선택하고 {0}을(를) 누르세요. {1}은(는) 가장 일반적인 오류 이름이므로 <ide/>에서 변수 이름으로 제안했습니다.
go.extract.methods.with.returns.lesson.name=return이 포함된 메서드 추출
go.extract.methods.with.returns.intro={0} 리팩터링을 사용하면 코드 조각을 취해 분리된 메서드로 이동하고 이전 코드를 새 메서드 호출로 바꿀수 있습니다. 코드가 return 문에서 종료되면 그대로 추출됩니다. {0} 리팩터링에 관한 자세한 내용은 <a href\="{1}">함수 및 메서드 추출</a> 자료를 참조하세요.
go.extract.methods.with.returns.invoke.refactoring=추출할 수 있는 {0} 절 앞에 캐럿이 있는지 확인하세요. {1}을(를) 누르세요.
go.extract.methods.with.returns.complete.refactoring={0}을(를) 입력하고 {1}을(를) 누르세요.
go.rename.lesson.name=이름 변경
go.rename.invoke.intentions=심볼에 캐럿을 배치하고 {0} 리팩터링을 사용하여 이름을 변경할 수 있습니다. 코드의 {1} 필드에 캐럿을 배치하고 {2}을(를) 누르세요.
go.rename.apply.intention=이 필드의 새 이름을 입력하세요. 예를 들어 {0}을(를) 입력한 다음, {1}을(를) 눌러 결과를 저장합니다.
go.what.s.new.module.name=GoLand 2020.3의 새로운 기능
go.what.s.new.module.description=GoLand 2020.3(2020년 12월)의 새로운 기능입니다.
go.basic.editing.module.name=기본 편집
go.basic.editing.module.description=코드 편집에 도움이 될 수 있는 기본 액션입니다.
go.code.completion.module.name=코드 완성
go.code.completion.module.description=컨텍스트를 인식하는 코드 완성은 코딩 프로세스의 속도를 높이고 오타를 줄입니다.
go.debugging.module.name=디버그
go.debugging.module.description=디버그는 애플리케이션 내 문제를 찾고 해결하는 데 도움이 될 수 있습니다.
go.testing.module.name=테스트하기
go.testing.module.description=테스트는 코드가 예상대로 올바르게 작동하도록 합니다
go.generating.code.module.name=코드 생성
go.generating.code.module.description=코드 청크를 생성하는 액션 및 템플릿입니다.
go.intention.actions.module.name=Acción de intención
go.intention.actions.module.description=인텐션 액션은 코드에 대한 대체 변형은 물론, 탐지된 문제에 대한 해결 방법까지 제안할 수 있습니다.
go.refactorings.module.name=Refactorización
go.refactorings.module.description=리팩터링은 코드를 빈틈이나 중복 코드 없이 관리하기 쉽게 유지하는 데 도움이 됩니다.
go.support.for.table.tests.name=테이블 테스트 지원
go.support.for.table.tests.call.context.menu=테스트를 실행할 때 <ide/>는 캐럿의 위치를 고려합니다.\n\
go.support.for.table.tests.run.subtest=같은 방법을 사용해 각각의 하위 테스트를 실행할 수 있습니다. 현재 캐럿이 {2} 하위 테스트에 있습니다. {0} 을(를) 눌러 실행하세요. \n\
go.code.completion.for.benchmarks.bn.name=벤치마크 잋 테스르 코드 완성
go.code.completion.for.benchmarks.bn.for.loop=벤치마크 내에서 {0} 을(를) 입력하면 <ide/>이(가) {0} 루프의 조건식으로 {1} 을(를) 제안합니다.\n\
go.code.completion.for.benchmarks.bn.create.bench=새 벤치마크를 생성하려면 {0} 을(를) 입력하기 시작한 다음 제안 목록에서 {0} 을(를) 선택하세요.
go.support.of.testify.framework.completion.and.subtests.name=코드 완성 및 testify 프레임워크 내 하위 테스트
go.support.of.testify.framework.completion.and.subtests.assert=<strong>전제 조건</strong>\: 이 수업을 종료하려면 <a href\="{0}">GOPATH 전체의 색인화를 활성화</a>하고 <a href\="{1}">{2} 패키지</a>를 설치하세요.\n\
go.support.of.testify.framework.completion.and.subtests.run.subtest=게다가 하위 테스트 이름이 문자열 상수라면 {0} 및 {1} 하위 테스트를 실행할 수 있습니다.\n\
go.onboarding.module.name=온보딩 투어
go.onboarding.module.description={0}의 주요 기능에 관한 간략한 개요입니다
go.onboarding.lesson.name={0} 알아보기
go.onboarding.project.view.description=<strong>프로젝트</strong> 뷰는 주요 도구 창 중 하나입니다. 이 뷰는 프로젝트 디렉터리, SDK 전용 패키지, 스크래치 파일을 포함합니다. 줄무늬 버튼을 클릭해 열면 간단한 데모 프로젝트 컨텐츠의 미리보기가 표시됩니다. {0}을(를) 눌러 열어 볼 수도 있습니다.
go.onboarding.balloon.project.view=클릭하여 <strong>프로젝트</strong> 뷰를 여세요
go.onboarding.balloon.project.directory=프로젝트 디렉터리를 두 번 클릭하여 확장하면 프로젝트 파일을 확인할 수 있습니다
go.onboarding.balloon.open.file=두 번 클릭하여 {0}을(를) 여세요
go.onboarding.balloon.open.learn.toolbar={0} 도구 창으로 전환하여 이 수업을 계속 진행하세요
go.onboarding.context.menu=코드를 실행하는 방법에는 여러 가지가 있습니다. 그중 하나는 컨텍스트 메뉴를 이용하는 것입니다.\n\
go.onboarding.run.sample={0}을(를) 선택하거나 {1}을(를) 사용해보세요.
go.onboarding.temporary.configuration.description=<ide/>이(가) 임시 실행 구성을 생성했습니다. 이 구성은 실행 툴바에서 찾을 수 있습니다. 이 툴바를 사용하면 선택한 구성에 대해 {0} 실행, {1} 디버그, {2} 코드 프로파일링, 커버리지 {3}(으)로 코드 실행 등, 인기 실행 액션을 실행할 수 있습니다.
go.onboarding.balloon.click.here=여기를 클릭하여 중단점을 설정하세요
go.onboarding.toggle.breakpoint.1={1} 메서드가 필요한 값인 {0} 대신 {2}을(를) 반환하는 것을 눈치채셨을 것입니다. return 문으로 가서 문제 코드를 디버그해봅시다.
go.onboarding.toggle.breakpoint.2=강조 표시된 영역에서 여백을 클릭하여 중단점을 설정하세요.
go.onboarding.balloon.start.debugging=아이콘을 클릭하여 디버그를 시작하세요
go.onboarding.start.debugging={0} 아이콘을 클릭하여 디버그 프로세스를 시작하세요.
go.onboarding.balloon.about.debug.panel={0} 도구 창은 다양한 디버그 액션을 갖춘 {1,choice,0#툴바|1#툴바}를 제공합니다. 나중에 {2} 수업을 수강하여 이 액션을 사용해보세요.
go.onboarding.balloon.stop.debugging=아이콘을 클릭하여 디버그를 시작하세요
go.onboarding.stop.debugging=디버그를 시작해봅시다. {0} 아이콘을 클릭하세요.
go.onboarding.type.division=코드에서 문제를 발견했으니 수정해봅시다. 결과 합을 값의 길이로 나누세요. {0}을(를) 입력하세요.
go.onboarding.choose.len.item=입력과 동시에 <ide/>에서 코드 완성 옵션이 자동으로 표시됩니다. 키보드 방향 키를 사용하여 {0} 항목을 선택한 다음 {1}을(를) 누르세요.
go.onboarding.invoke.completion=이제 코드 완성을 호출하여 괄호 {1} 안에 {0}을(를) 삽입해봅시다. {2}을(를) 눌러 코드 완성 목록을 여세요.
go.onboarding.choose.values.item={0}을(를) 입력하여 제안된 항목 수를 줄일 수 있습니다. {1}을(를) 선택한 다음 {2}을(를) 누르세요.
go.onboarding.invoke.intention.for.warning.1=방금 버그를 수정했지만 이 코드를 더욱 깔끔하게 만들 수 있습니다. <ide/>은(는) 향상될 여지가 있는 코드 줄을 강조 표시하고 노란색 전구를 추가합니다.
go.onboarding.invoke.intention.for.warning.2={0}을(를) 눌러 경고를 미리 보고 빠른 수정을 적용하세요.
go.onboarding.select.fix=첫 번째 항목을 적용하세요. {0}. 이 수정을 적용하면 불필요한 괄호가 삭제됩니다.
go.onboarding.invoke.intention.for.code=또한, 인텐션을 사용하면 시간을 절약하고 코드를 더 쉽게 작성할 수 있습니다. 인텐션을 사용해 {0} 함수를 내보낸 함수로 빠르게 변환해 봅시다. {1}을(를) 누르세요.
go.onboarding.apply.intention={0}을(를) 선택한 후 {1}을(를) 누르세요.
go.onboarding.invoke.search.everywhere.1=<ide/>에서 작업할 때 프로젝트, 심볼, 타입 또는 IDE 액션 내의 파일을 검색하고자 하는 경우가 있습니다. 이번 수업에서는 {0} 액션을 검색하여 {1} 문자열을 소문자로 만들어 봅시다.
go.onboarding.invoke.search.everywhere.2={0}을(를) 두 번 눌러 {1} 대화상자를 여세요.
go.onboarding.search.everywhere.description=보시다시피 선택한 텍스트, {0}이(가) 자동으로 입력 문자열에 복사되었습니다. {0} 대신 {1}을(를) 입력해봅시다.
go.onboarding.apply.action={0} 액션을 선택하고 {1}을(를) 누르세요.
go.onboarding.case.changed=대/소문자가 변경되었습니다.
go.onboarding.epilog=축하합니다. 온보딩 투어를 마쳤습니다. 이제 다음을 진행할 수 있습니다.\n\
- 학습 프로젝트 <callback id="{0}">닫기</callback>{1}\n\
- 수업 <callback id="{2}">더보기</callback>
go.onboarding.return.to.welcome=\ 및 시작 화면으로 돌아가기
go.onboarding.finish.title=축하합니다
go.onboarding.finish.text=<ide/> 온보딩 투어를 완료했습니다.\n\
go.onboarding.finish.exit=데모 프로젝트 닫기
go.onboarding.finish.modules=수업 더보기
toggle.case.part=대/소문자
go.onboarding.close.debug.tool.window={0} 도구 창을 닫고 {1}을(를) 누르세요.
go.to.internal.directory.name=탐색, 빌드 제약, 코드 서식 지정
go.to.internal.directory.build.constraints=<a href="{0}">버그 방지 빌드 제약 제안</a>에 따라 {1}이(가) {2}(으)로 바뀝니다. {1}~{2}의 전환 기간 동안 구문은 Go 1.16~1.18 버전에서 유지됩니다. Go 1.16 버전에서는 예전 구문을 사용하거나 두 가지 구문을 동시에 사용할 수 있습니다.\n\
go.to.internal.directory={0} 2021.2부터 {1} 폴더에 저장된 인터페이스로 이동할 수 있습니다.\n\
go.to.internal.directory.hover.over.tab=파일 위치를 확인하려면 에디터의 탭을 마우스로 가리키면 됩니다. 예를 들어, {0} 탭을 마우스로 가리켜 보세요.
go.to.internal.directory.reformat.gofmt.on.save={0} 파일의 코드 서식을 다시 지정해야 합니다. {1}을(를) 눌러 파일의 서식을 다시 지정하세요.\n\
go.wrapping.delete.line=경고의 의미는 정수를 서식 지정 함수에 전달하려고 시도했다는 것입니다. {0}은(는) 정렬이 필요한 텍스트를 포함한 템플릿 문자열을 받습니다. 서식 지정 동사나 빠른 수정을 사용하여 정수를 문자열로 바꿀 수 있습니다.\n\
go.error.handling.module.name=오류 처리
go.error.handling.module.description=Go에서 오류 처리 속도를 높일 수 있는 방법 알아보기
go.advanced.module.name=고급
go.advanced.module.description=이 언어에 대한 보다 깊은 이해가 필요한 기능
go.navigation.module.name=Navegar
go.navigation.module.description=코드 베이스에서 이동
go.code.style.module.name=코드 스타일
go.code.style.module.description=소스 코드에 Go 코딩 규칙 적용
go.search.module.name=검색
go.search.module.description=IDE의 검색 기능에 대해 알아보기
go.postfix.completion.intro=접미사 템플릿을 사용하면 점 뒤의 접미사, 표현식 타입, 해당 컨텍스트를 기반으로 이미 입력된 표현식을 다른 표현식으로 변환할 수 있습니다. 사전 정의된 접미사 완성 템플릿 세트를 사용하거나 새 템플릿을 생성할 수 있습니다. 사용자 지정 접미사 템플릿에 관한 자세한 내용은 <a href = "{0}">이 문서 자료</a>를 참조하세요.
go.postfix.completion.better.variable.names.in.templates.description=<ide/>은(는) {0} 및 {1} 접미사 템플릿으로 생성된 변수의 이름을 지정할 수 있도록 도와줍니다. 예를 들어 이러한 제안을 살펴보면 색인의 경우 {2} 또는 {3}, {5}의 경우 {4}이(가) 제시됩니다.
go.postfix.completion.better.variable.names.in.templates.use.forr={0}을(를) 입력하고 완성 목록에서 {1} 접미사 템플릿을 선택하세요.
go.general.templates.intro=라이브 템플릿은 루프, 조건, 다양한 선언 또는 print 문과 같은 일반적인 구문을 코드에 삽입합니다.
go.navigate.to.error={0}을(를) 눌러 다음 오류로 이동하세요.
go.struct.fields.lesson.name=구조체 생성 및 구조체 필드 채우기
go.struct.fields.create.type=구조체 작업 시, 먼저 필드와 해당 값으로 구조체를 작성한 다음 모든 것을 구조체 타입으로 정의하려고 할 수 있습니다. 예제에서와 같이, 새로운 구조체를 만들고 해당 필드에 대한 값을 정의했습니다. 하지만 아직 구조체 정의가 없습니다.\n\
go.struct.fields.type.defined=이제 {0} 구조체가 해당 필드에 정의되었습니다.
go.struct.fields.struct.no.fields=또 다른 상황도 있습니다. 모든 것을 정의했지만 새 구조체의 필드 이름을 채워야 합니다. 수동으로 다시 입력할 수 있지만 <ide/>에는 이 프로시저에 대한 인텐션 액션이 있습니다.
go.struct.fields.invoke.intentions={0}을(를) 눌러 인텐션 액션을 호출합니다.
go.working.with.parameters.lesson.name=매개변수 사용
go.working.with.parameters.single.type=함수 또는 메서드 시그니처에 단일 타입의 여러 매개변수가 있는 경우 이러한 매개변수에 대해 짧은 타입 사양({0})을 사용하거나 각 매개변수에 대해 별도의 타입 사양({1})을 사용할 수 있습니다.
go.working.with.parameters.invoke.intentions.1=캐럿이 {0} 메서드의 첫 번째 매개변수의 위치에 있는 것을 확인하세요. {1}을(를) 눌러 인텐션 액션을 호출하세요.
go.working.with.parameters.signature.combined=시그니처 타입이 결합된 방식을 확인하세요.
go.working.with.parameters.press.action.again={0}을(를) 다시 누르세요.
go.working.with.parameters.signature.expanded=시그니처를 초기 상태로 반환하려면 {0}을(를) 선택하세요.
go.working.with.parameters.that.are.not.used=<ide/>은(는) 메서드 또는 함수의 본문에서 사용되지 않는 시그니처의 매개변수를 탐지할 수 있습니다. 해당 매개변수가 사용되지 않는 경우 {0} 빠른 수정을 사용하여 삭제할 수 있습니다.
go.working.with.parameters.invoke.intentions.2=에디터에서 {0} 메서드를 확인하세요. 캐럿은 첫 번째 매개변수의 위치에 있습니다. {1}을(를) 눌러 인텐션 액션을 호출하세요.
go.working.with.parameters.remove.parameters=<ide/>은(는) 사용되지 않는 매개변수의 타입이 메서드 사양을 구현하는 데 사용되는 경우 해당 매개변수의 이름만 강조 표시합니다. 이 경우 이 매개변수의 이름을 {0}(으)로 변경하거나 완전히 제거할 수 있습니다.
go.working.with.parameters.invoke.intentions.3=인터페이스를 구현하는 메서드에 매개변수가 필요한 경우, 이러한 매개변수를 제거하는 것은 안전하지 않습니다. {0}을(를) 눌러 가능한 옵션 목록을 확인하세요.
go.extract.inline.variables.lesson.name=변수 추출 및 인라인화
go.extract.inline.variables.extract.task={0}을(를) 눌러 변수를 추출하고 문자열 표현식을 선택한 다음, 새 이름을 입력하고 {1}을(를) 눌러 리팩터링을 완료하세요.
go.extract.inline.variables.inline.task={0} 리팩터링과 반대로 {1}은(는) 불필요한 변수의 제거를 돕습니다. {2}을(를) 눌러 변수를 단일 사용 위치로 인라인화하세요.
go.dump.goroutines.click.button.more={0} 도구 창에서 {1}을(를) 클릭하세요.
go.dump.goroutines.dump.tab={0} 탭에는 애플리케이션의 고루틴 목록이 표시됩니다. 당사의 애플리케이션에는 몇 가지 목록이 있지만, 사용자의 실제 애플리케이션에는 그보다 더 많이 있을 수 있습니다. <ide/>에서, 특정 고루틴을 검색하는 필터를 적용하고 필터링된 결과를 자세히 살펴볼 수 있습니다.
go.press.and.apply.fix={0}을(를) 누르고 {1}을(를) 선택합니다.
go.apply.fix.at.once=또는 툴팁이 계속 표시되면 {0}을(를) 눌러 제안된 빠른 수정을 한 번에 적용할 수 있습니다.
go.onboarding.change.ui.settings=이 수업을 위해, <ide/>에서는 일부 UI 설정을 기본 상태로 변경합니다. 이 수업을 완료하거나 종료하면 해당 환경 설정이 복원됩니다.
go.onboarding.indexing.description=처음으로 프로젝트를 열면 <ide/>에서 Go SDK 및 프로젝트 자체를 검사하여 코딩 지원에 필요한 세부 정보를 수집합니다. 계속하려면 색인화가 완료될 때까지 기다리세요.
go.debug.function.context.menu=코드을 디버그하는 방법에는 여러 가지가 있습니다. 그중 하나는 컨텍스트 메뉴를 이용하는 것입니다.\n\
go.autocomplete.json.name=JSON 구조체 태그 자동 완성
go.autocomplete.json.autocomplete=백틱 ({0})을(를) 입력하고 JSON 태그를 채우기 시작할 때, <ide/>이(가) 키를 입력하도록 제안합니다.\n\
go.autocomplete.json.select.style=적용하고 싶은 스타일을 선택하세요. {0}을(를) 선택합시다! IDE가 선택을 저장하고 이 구조체의 다른 필드에서 같은 스타일을 제안합니다.
go.export.types.name=타입 내보내기
go.export.types.quickfix=내보내지 않는 타입을 반환하는 내보낸 함수를 작성하면, <ide/>이(가) 타입을 내보내기 위한 빠른 수정을 제안합니다.\n\
go.error.string.formatting.name=접미사 완성: 문자열을 숫자로 변환
go.error.string.formatting.parsefloat=<ide/>에는 문자열을 숫자로 변환하는데 도움을 주는 특별 접미사 템플릿이 있습니다.\n\
go.error.string.formatting.parseint={0} 접미사 템플릿을 {1}에 적용해 보세요.\n\
go.error.string.formatting.goto=프로그램 내에 아직 가벼운 경고가 있습니다.
go.error.string.formatting.introduction=<a href="{0}">Go 규칙</a>에 따르면, 오류 문자열을 대문자로 표기하면 안 됩니다. 이 규칙을 잊으신 경우에는 <ide/>이(가) 알려줍니다.\n\
go.goto.next.error={0}을(를) 눌러 파일 내 강조 표시된 다음 오류로 이동하세요.
go.debug.nil.hide.types.name=타입과 nil 인터페이스의 표현
go.debug.nil.hide.types.introduction=Go의 인터페이스에는 두 가지 구성요소가 있습니다. 타입과 타입의 값이 그것입니다. 인터페이스가 {0}이려면 두 요소 모두가 {0}이어야 합니다. 프로그램에 {0} 포인터를 포함하는 값이 있는 인터페이스가 있다면 그 인터페이스는 내부 타입이 {0}이(가) 아니므로 값이 {0}와(과) 같지 않게 됩니다. 디버깅 과정에서 <ide/>는 이런 경우를 발견하고 다르게 표시합니다.\n\
go.debug.nil.hide.types.variables={0} 창에서 {1} 및 {2} 인터페이스의 차이를 볼 수 있습니다. {1} 인터페이스는 값과 타입이 설정되지 않았으므로 {3}입니다. 인터페이스 값 안에 {4} 타입의 {3} 포인터를 저장하는 {2} 인터페이스와는 다릅니다. {2} 인터페이스의 내부 타입은 포인터의 값과 관계 없이 {3}입니다.
go.debug.nil.hide.types=객체 타입이 공간을 많이 차지하면 {0} 도구 창에 숨길 수 있습니다.\n\
go.debug.stop.debug=디버그를 중지하고 강의를 마치려면 {0}을(를) 누르세요.
go.goto.next.warning={0}을(를) 눌러 파일 내 강조 표시된 다음 경고로 이동하세요.
go.debug.run.sample={0} 메뉴 항목을 선택하거나 {1}을(를) 시도하세요.
go.onboarding.feedback.system.found.sdks=발견된 SDK:
go.onboarding.feedback.system.no.sdks=Ninguno
go.onboarding.feedback.system.used.sdk=사용된 SDK:
go.generate.missing.methods.todo={1} 액션을 사용했을 때 생성된 템플릿으로 {0} 주석이 자동으로 추가됩니다. 이러한 특별 주석은 에디터에서 강조 표시되고, 색인되고 {2} 도구 창에 나열됩니다. 이는 구현되지 않은 메서드가 무엇인지 알려줍니다.
go.generics.inspections.title=타입 매개변수 검사
go.generics.inspections.delete.type.parameters=<ide/> 2022.2에서는 사용자가 놓친 오류를 찾는 데 도움이 되는 새로운 검사가 도입됩니다.\n\
go.generics.inspections.union.interfaces.with.methods=<a href="{0}">Go 팀</a>에 따르면 인터페이스와 메서드는 공용체 내에서 함께 사용할 수 없습니다. 따라서 {1}은(는) 공용체 요소 중에서 항으로 사용됩니다.\n\
go.generics.inspections.unused.type.parameter=타입 매개변수는 우리의 코드 내 어디에서도 사용되지 않기 때문에 음영 처리되었습니다. 매개변수 섹션에서 {0} 타입을 {1}(으)로 교체하여 이를 수정합니다.
go.quick.documentation.title=빠른 문서 사용하기
go.quick.documentation.iota=에디터에서 모든 기호에 관한 정보를 빠르게 얻을 수 있습니다. 예를 들어 {0} 값을 보려면 {1} 동작을 실행하세요.\n\
go.quick.documentation.iota.methods.pointer.and.value.fix=<a href="{0}">Go 문서</a>에서는 한 타입의 모든 메서드에 값이나 포인터 리시버 중 하나가 있도록 하는 것을 권장합니다. <ide/>에서 {1} 구조체에 값과 포인터 리시버 모두에 해당하는 메서드가 있는 것을 발견했습니다. {2} 메서드를 재작성하거나 제거할 수도 있습니다. 다음의 링크를 클릭하여 다음의 절차로 진행하세요.
go.quick.documentation.convert.to.pointer.receiver=규칙을 따르도록 {0} 메서드를 업데이트할 수 있습니다. {2} 앞에 {1}을(를) 입력하여 메서드를 값 리시버에서 포인터 리시버로 변환하세요.
go.type.parameters.module.name=제네릭(유형 매개변수)
go.type.parameters.description=제네릭과 관련된 작업에 도움이 되는 기능입니다
go.generics.inspections.change.interface.to.any=진행하기 전에 한 가지를 더 리팩터링합니다. {0}(으)로 대체될 수 있는 빈 인터페이스를 사용합니다. {1}을(를) 누르고 {2}을(를) 선택합니다.
go.support.fuzz.testing.title=퍼즈 테스팅
go.support.fuzz.testing.run=퍼즈 테스팅은 다양한 입력을 연속적으로 제출함으로써 테스트를 자동화하는 방법입니다. 퍼즈 테스트를 실행하여 생성된 다양한 테이터로 함수를 점검해 봅시다.\n\
go.support.fuzz.testing.check.failing=이런, 퍼즈 테스트가 실패했습니다! 이유를 알아내려면 {0} 도구 창에서 출력을 아래로 스크롤하고 {1} 디렉터리로 연결되는 링크를 클릭하세요.
go.generics.running.code.click.link=이제 결과 링크를 클릭하여 브라우저에서 코드를 엽니다.\n\
