jvm.inspections.group.name=Lenguaje JVM
jvm.inspections.unstable.api.usage.display.name=Usando API inestable
jvm.inspections.unstable.api.usage.annotations.list=Anotaciones API inestables
jvm.inspections.unstable.api.usage.ignore.inside.imports=ignorar dentro de la declaración de importación
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=이 프로젝트에서 선언된 API 무시
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' está marcado como inestable en @ {1}.
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}''이(가) @{3}(으)로 표시된 불안정한 {1} ''{2}''에서 선언되었습니다.
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=El método anulado ''{0}'' está marcado como inestable en @ {1}.
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=Método anulado ''{0}'' marcado como inestable {1 como @ {3}} Declarado en '' {2 } ''.
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' marcado como @ {3} inestable {1} ''{2}'' se hace referencia por su firma y, por lo tanto, es inestable
jvm.inspections.scheduled.for.removal.future.version=Versiones futuras
jvm.inspections.scheduled.for.removal.predefined.version=versión {0}
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' está a punto de eliminarse de {1}.
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' está programado para ser eliminado de {3} ''{2}'' ha sido declarado en
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=El método anulado ''{0}'' está a punto de ser eliminado de {1}.
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=El método reemplazado ''{0}'' programado para ser eliminado de {3} {1} ''{2}'' fue declarado.
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' se eliminará de {3} {1 } ''{2}'' se hace referencia en su firma y se eliminará
jvm.inspections.unstable.type.used.in.signature.display.name=Tipo inestable utilizado en la firma
jvm.inspections.unstable.type.used.in.class.signature.description=Anotado ''@{0} '' porque la clase hace referencia al tipo inestable ''{1}'' en su declaración, debería ser
jvm.inspections.unstable.type.used.in.method.signature.description=Anotado ''@{0} '' porque el método hace referencia al tipo inestable ''{1}'' en su firma debe ser
jvm.inspections.unstable.type.used.in.field.signature.description=El campo está anotado con ''@{0} '' porque hace referencia al tipo inestable ''{1}'' debería ser
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=Falta la anotación '' @Deprecated '' en la API que se eliminará
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=Las API que se eliminarán también deben estar marcadas con la anotación '' @Deprecated ''.
jvm.inspections.must.already.be.removed.api.display.name=La API ya ha sido eliminada.
jvm.inspections.must.already.be.removed.api.earlier.version.description=La API se ha eliminado de {0} pero la versión actual es {1}.
jvm.inspections.must.already.be.removed.api.current.version.description=La API se ha eliminado de la versión actual {0}.
jvm.inspections.blocking.method.problem.descriptor=Llamada al método de bloqueo no válida.
jvm.inspections.blocking.method.display.name=Llamada al método de bloqueo de subprocesos no válida
jvm.inspections.blocking.method.annotation.blocking=Bloqueo de anotaciones
jvm.inspections.blocking.method.annotation.non-blocking=Non-Blocking 어노테이션
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=Agregar anotación de bloqueo
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=Non-Blocking 어노테이션 추가
jvm.inspections.blocking.method.annotation.configure.empty.text=No se agregaron anotaciones.
jvm.inspections.api.no.extension.display.name=La clase, la interfaz o el método no deben extenderse
jvm.inspections.api.no.extension.class.description=La clase ''{0}'' no debe extenderse.
jvm.inspections.api.no.extension.interface.implement.description=La interfaz ''{0}'' no debe implementarse.
jvm.inspections.api.no.extension.interface.extend.description=La interfaz ''{0}'' no debe extenderse.
jvm.inspections.api.no.extension.method.overriding.description=El método ''{0}'' no debe anularse.
jvm.inspections.api.override.only.display.name=Los métodos solo se pueden anular
jvm.inspections.api.override.only.description=El método ''{0}'' solo se puede anular.
jvm.inspections.dependency.display.name=잘못된 패키지 종속성
jvm.inspections.dependency.edit.rules.text=종속성 규칙 "{0}" 편집
jvm.inspections.dependency.edit.rules.family=종속성 규칙 편집
jvm.inspections.dependency.configure.button.text=종속성 규칙 구성
jvm.inspections.dependency.violator.problem.descriptor=종속성 규칙 ''{0}.''이(가) 위반되었습니다
jvm.inspections.testonly.display.name=프로덕션 코드 내 테스트 전용 사용 위치
jvm.inspections.testonly.class.reference=테스트 전용 클래스가 프로덕션 코드에서 참조됩니다
jvm.inspections.testonly.field.reference=테스트 전용 필드가 프로덕션 코드에서 참조됩니다
jvm.inspections.testonly.method.call=테스트 전용 메서드가 프로덕션 코드에서 호출됩니다
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting은 @TestOnly 코드에서 의미가 없습니다
jvm.inspections.string.touppercase.tolowercase.without.locale.description=<code> String. Se llama a {0} ()</code> sin especificar una configuración regional que utilice una cadena internacionalizada.\#loc
can.t.build.uast.tree.for.file=No se pudo construir el árbol UAST para el archivo.
title.uast=UAST
current.version=Versión actual
dialog.title.choose.annotation=Seleccione {0}
jvm.inspection.test.failed.line.display.name=테스트에서 실패한 줄
jvm.inspections.source.to.sink.flow.display.name=안전하지 않은 문자열이 안전한 메서드로 전달됨
jvm.inspections.junit5.converter.display.name=JUnit 4 테스트가 JUnit 5가 될 수 있음
jvm.inspections.junit5.converter.problem.descriptor=#ref이(가) JUnit 5 테스트일 수 있습니다
jvm.inspections.junit5.converter.quickfix=JUnit 5로 마이그레이션
jvm.inspections.junit5.converter.quickfix.presentation.text=어설션 변환
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=호환되지 않는 상속자가 있으므로 클래스 {0}을(를) JUnit 5로 변환할 수 없습니다. {1}
jvm.inspections.thread.run.display.name='Thread.run()' 호출
jvm.inspections.serializable.class.without.serialversionuid.display.name='serialVersionUID'가 없는 serializable 클래스
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code>이(가) 'serialVersionUID' 필드를 정의하지 않습니다 #loc
jvm.inspections.source.to.sink.flow.passed.unsafe=안전하지 않은 문자열이 안전한 매개변수로 사용됨
jvm.inspections.source.to.sink.flow.passed.unknown=알 수 없는 문자열이 안전한 매개변수로 사용됨
jvm.inspections.source.to.sink.flow.returned.unsafe=안전하지 않은 문자열이 안전한 메서드에서 반환됨
jvm.inspections.source.to.sink.flow.returned.unknown=알 수 없는 문자열이 안전한 메서드에서 반환됨
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=검증 필요로 표시
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=''{0}''을(를) 검증 필요로 표시
jvm.inspections.blocking.method.consider.unknown.context.blocking=알 수 없는 컨텍스트를 블로킹으로 고려
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=안전한 어노테이션 전달
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=''{0}''(으)로부터 안전한 어노테이션 전달
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=안전하다고 어노테이션을 추가할 멤버 선택
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=제외된 것만 빼고 모두 어노테이션 추가
propagated.from=안전하다고 표시할 사유:
propagated.to=안전하다고 표시할 대상:
propagate.from.empty.text=안전함으로 표시할 사유가 여기에 표시됩니다
propagate.to.empty.text=안전함으로 표시할 대상이 여기에 표시됩니다
jvm.inspections.blocking.method.problem.wildcard.descriptor={0}에서 호출을 블로킹하면 스레드에서 기아 상태를 일으킬 수 있습니다
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=안전하지 않은 흐름
jvm.inspections.source.to.sink.flow.assigned.unsafe=안전하지 않은 문자열이 안전한 변수에 대입됨
jvm.inspections.source.to.sink.flow.assigned.unknown=알 수 없는 문자열이 안전한 변수에 대입됨
jvm.inspections.source.to.sink.flow.common.unsafe=안전하지 않은 문자열이 안전한 컨텍스트에 사용됨
jvm.inspections.source.to.sink.flow.common.unknown=알 수 없는 문자열이 안전한 컨텍스트에 사용됨
jvm.inspections.api.display.name=구성된 언어 수준에서 사용할 수 없는 API 사용
jvm.inspections.1.5.problem.descriptor=@since {0}+로 기록된 API 사용
jvm.inspections.1.7.problem.descriptor=JDK {0}에 컴파일 문제를 일으킬 수 있는 1.6 이후에 일반화된 API 사용
jvm.inspections.1.8.problem.descriptor=디폴트 {0, choice, 0#|1#메서드가|2#메서드가} 재정의되지 않았습니다. JDK {1)에 컴파일 문제를 일으킬 수 있습니다.
jvm.inspections.1.8.problem.single.descriptor=디폴트 메서드 ''{0}''이(가) 재정의되지 않았습니다. 이로 인해 JDK {1}에 컴파일 문제가 발생할 수 있습니다
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=검증 필요로 표시
jvm.inspections.source.unsafe.to.sink.flow.preview.multiple.files={0}에 ''@Untainted'' 어노테이션 추가
jvm.inspections.dependency.on.internal.display.name=내부 패키지에 유효하지 않은 종속 요소
inspection.message.illegal.dependency.module.doesn.t.export=유효하지 않은 종속 요소: 모듈 ''{0}''은(는) 패키지 ''{1}''을(를) 내보내지 않습니다
jvm.inspections.test.frameworks.group.name=테스트 프레임워크
assertequals.between.inconvertible.types.display.name=변환할 수 없는 타입의 객체 간의 'assertequals()'
jvm.inspections.assertequals.between.inconvertible.types.problem.descriptor=<code>#ref()</code>이(가) 변환할 수 없는 유형인 ''{0}'' 및 ''{1}''의 객체 사이에 있습니다. #loc
jvm.inspections.assertnotsame.between.inconvertible.types.problem.descriptor=어설션이 중복되었습니다. 호환되지 않는 타입, ''{0}'' 및 ''{1}''이(가) 비교됩니다.
jvm.inspections.assertnotequals.between.inconvertible.types.problem.descriptor=어설션이 중복되었을 수 있습니다. 호환되지 않는 타입, ''{0}'' 및 ''{1}''이(가) 비교됩니다.
jvm.inspections.junit.malformed.declaration.name=JUnit 잘못된 선언
jvm.inspections.junit.malformed.option.ignore.test.parameter.if.annotated.by=다음으로 어노테이션된 경우 테스트 매개변수 무시:
jvm.inspections.junit.malformed.test.combination.descriptor={0}와 ''@{1}''의의심스러운 조합
jvm.inspections.junit.malformed.repetition.number.descriptor=반복 횟수는 0보다 커야 합니다
jvm.inspections.junit.malformed.nested.class.descriptor=비 static 중첩 클래스만이 '@Nested' 테스트 클래스로 사용될 수 있습니다
jvm.inspections.junit.malformed.extension.registration.descriptor=''{0}''은(는) ''{1}''을(를) 구현해야 합니다
jvm.inspections.junit.malformed.extension.class.level.descriptor={0}은(는) 클래스 수준에서 등록되어야 합니다
jvm.inspections.junit.malformed.param.method.source.unresolved.descriptor=대상 메서드 소스를 확인할 수 없습니다. ''{0}''
jvm.inspections.junit.malformed.param.wrapped.in.arguments.descriptor=여러 매개변수는 'Arguments'로 감싸야 합니다
jvm.inspections.junit.malformed.param.method.source.return.type.descriptor=메서드 소스 ''{0}''에는 다음 반환 타입 중 하나가 포함되어야 합니다. ''Stream<?>'', ''Iterator<?>'', ''Iterable<?>'' 또는 ''Object[]''
jvm.inspections.junit.malformed.param.method.source.no.params.descriptor=메서드 소스 ''{0}''에는 매개변수가 포함될 수 없습니다
jvm.inspections.junit.malformed.param.method.source.static.descriptor=메서드 소스 ''{0}''의 경우 항상 static이어야 합니다
jvm.inspections.junit.malformed.param.method.source.assignable.descriptor=''{0}''을(를) ''{1}''(으)로 변환하는 묵시적 변환을 찾지 못했습니다
jvm.inspections.junit.malformed.param.duplicated.enum.descriptor='enum' 상수 이름 중복
jvm.inspections.junit.malformed.param.unresolved.enum.descriptor='enum' 상수 참조를 해결할 수 없습니다.
jvm.inspections.junit.malformed.param.no.value.source.is.defined.descriptor=정의된 값 소스가 없습니다
jvm.inspections.junit.malformed.param.exactly.one.type.of.input.must.be.provided.descriptor=입력 타입은 정확히 하나만 제공되어야 합니다
jvm.inspections.junit.malformed.param.file.source.descriptor=파일 소스를 해결할 수 없습니다. ''{0}''
jvm.inspections.junit.malformed.param.null.source.cannot.provide.argument.no.params.descriptor=\n메서드에 매개변수가 없으므로 ''@{0}''은(는) 메서드에 인수를 제공할 수 없습니다
jvm.inspections.junit.malformed.param.null.source.cannot.provide.argument.too.many.params.descriptor=\n메서드에 매개변수가 너무 많아 ''@{0}''은(는) 메서드에 인수를 제공할 수 없습니다
jvm.inspections.junit.malformed.param.empty.source.cannot.provide.argument.descriptor=메서드에 지원되지 않는 ''{1}'' 유형의 매개변수가 있으므로 ''@{0}''은(는) 메서드에 인수를 제공할 수 없습니다
jvm.inspections.junit.malformed.param.multiple.parameters.are.not.supported.by.this.source.descriptor=이 소스는 여러 매개변수를 지원하지 않습니다
jvm.inspections.junit.malformed.param.no.sources.are.provided.descriptor=제공된 소스가 없어 스위트가 공백으로 남습니다
jvm.inspections.junit.malformed.method.no.arg.void.descriptor=메서드 <code>#ref</code>은(는) {0}, {1}이어야 하며 매개변수가 없고 void 타입이어야 합니다
jvm.inspections.junit.malformed.annotated.field.single.descriptor=''@{0}''(으)로 어노테이션된 필드 <code>#ref</code>은(는) {1}이어야 합니다
jvm.inspections.junit.malformed.annotated.field.double.descriptor=''@{0}''(으)로 어노테이션된 필드 <code>#ref</code>은(는) {1} 및 {2}이어야 합니다
jvm.inspections.junit.malformed.annotated.field.typed.descriptor=''@{0}''(으)로 어노테이션된 필드 <code>#ref</code>은(는) {1} 타입이어야 합니다
jvm.inspections.junit.malformed.annotated.field.single.typed.descriptor=''@{0}''(으)로 어노테이션된 필드 <code>#ref</code>은(는) {1}이고 ''{2}'' 타입이어야 합니다
jvm.inspections.junit.malformed.annotated.field.double.typed.descriptor=''@{0}''(으)로 어노테이션된 필드 <code>#ref</code>은(는) {1} 및 {2}이고 ''{3}'' 타입이어야 합니다
jvm.inspections.junit.malformed.annotated.method.single.descriptor=''@{0}''(으)로 어노테이션된 메서드 <code>#ref</code>은(는) {1}이어야 합니다
jvm.inspections.junit.malformed.annotated.method.double.descriptor=''@{0}''(으)로 어노테이션된 메서드 <code>#ref</code>은(는) {1} 및 {2}이어야 합니다
jvm.inspections.junit.malformed.annotated.method.typed.descriptor=''@{0}''(으)로 어노테이션된 메서드 <code>#ref</code>은(는) {1} 타입이어야 합니다
jvm.inspections.junit.malformed.annotated.method.single.typed.descriptor=''@{0}''(으)로 어노테이션된 메서드 <code>#ref</code>은(는) {1}이고 ''{2}'' 타입이어야 합니다
jvm.inspections.junit.malformed.annotated.method.double.typed.descriptor=''@{0}''(으)로 어노테이션된 메서드 <code>#ref</code>은(는) {1} 및 {2}이고 ''{3}'' 타입이어야 합니다
jvm.inspections.junit.malformed.annotated.method.param.single.descriptor=''@{0}''(으)로 어노테이션된 메서드 <code>#ref</code>은(는) 매개변수 ''{1}''을(를) 선언하면 안됩니다
jvm.inspections.junit.malformed.annotated.method.typed.param.single.descriptor=''@{0}''(으)로 어노테이션된 메서드 <code>#ref</code>은(는) ''{1}'' 타입이어야 하며 매개변수 ''{2}''을(를) 선언하면 안됩니다
jvm.inspections.junit.malformed.annotated.method.single.param.single.descriptor=''@{0}''(으)로 어노테이션된 메서드 <code>#ref</code>은(는) {1}이어야 하며 매개변수 ''{2}''을(를) 선언하면 안됩니다
jvm.inspections.junit.malformed.annotated.method.double.param.single.descriptor=''@{0}''(으)로 어노테이션된 메서드 <code>#ref</code>은(는) {1} 및 {2}이어야 하며 매개변수 ''{3}''을(를) 선언하면 안됩니다
jvm.inspections.junit.malformed.annotated.method.single.typed.param.single.descriptor=''@{0}''(으)로 어노테이션된 메서드 <code>#ref</code>은(는) {1}이면서 ''{2}'' 타입이어야 하며 매개변수 ''{3}''을(를) 선언하면 안됩니다
jvm.inspections.junit.malformed.annotated.method.double.typed.param.single.descriptor=''@{0}''(으)로 어노테이션된 메서드 <code>#ref</code>은(는) {1} 및 {2}이면서 ''{3}'' 타입이어야 하며 매개변수 ''{4}''을(를) 선언하면 안됩니다
jvm.inspections.junit.malformed.annotated.method.param.double.descriptor=''@{0}''(으)로 어노테이션된 메서드 <code>#ref</code>은(는) 매개변수 {1}와(과) ''{2}''을(를) 선언하면 안됩니다
jvm.inspections.junit.malformed.annotated.method.typed.param.double.descriptor=''@{0}''(으)로 어노테이션된 메서드 <code>#ref</code>은(는) ''{1}'' 타입이어야 하며 매개변수 {2}와(과) ''{3}''을(를) 선언하면 안됩니다
jvm.inspections.junit.malformed.annotated.method.single.param.double.descriptor=''@{0}''(으)로 어노테이션된 메서드 <code>#ref</code>은(는) {1}이어야 하며 매개변수 ''{2}''와(과) ''{3}''을(를) 선언하면 안됩니다
jvm.inspections.junit.malformed.annotated.method.double.param.double.descriptor=''@{0}''(으)로 어노테이션된 메서드 <code>#ref</code>은(는) {1} 및 {2}이어야 하며 매개변수 ''{3}''와(과) ''{4}''을(를) 선언하면 안됩니다
jvm.inspections.junit.malformed.annotated.method.single.typed.param.double.descriptor=''@{0}''(으)로 어노테이션된 메서드 <code>#ref</code>은(는) {1}이면서 ''{2}'' 타입이어야 하며 매개변수 {3}와(과) ''{4}''을(를) 선언하면 안됩니다
jvm.inspections.junit.malformed.annotated.method.double.typed.param.double.descriptor=''@{0}''(으)로 어노테이션된 메서드 <code>#ref</code>은(는) {1} 및 {2}이면서 ''{3}'' 타입이어야 하며 매개변수 {4}와(과) ''{5}''을(를) 선언하면 안됩니다
jvm.inspections.junit.malformed.fix.method.signature=메서드 시그니처 수정
jvm.inspections.junit.malformed.fix.method.signature.descriptor=''{0}'' 메서드 시그니처 수정
jvm.inspections.junit.malformed.fix.field.signature=필드 시그니처 수정
jvm.inspections.junit.malformed.fix.field.signature.descriptor=''{0}'' 필드 시그니처 수정
jvm.inspections.junit.malformed.method.no.arg.descriptor=메서드 <code>#ref</code>은(는) {0}, {1}이어야 하며 매개변수가 없어야 합니다
jvm.inspections.junit.malformed.annotated.suspend.function.descriptor=''@{0}''(으)로 어노테이션된 메서드 <code>#ref</code>은(는) 일시 중지하는 함수가 아니어야 합니다
jvm.inspections.junit.malformed.suspend.function.descriptor=메서드 <code>#ref</code>은(는) 일시 중지하는 함수가 아니어야 합니다
