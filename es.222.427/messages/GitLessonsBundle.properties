git.module.name=Git
git.module.description=IDE에서 Git 통합 기능을 사용하는 방법을 알아봅니다
git.window.closed.warning={0}을(를) 누르면 {1} 도구 창이 다시 열립니다.
git.project.history.lesson.name=프로젝트 기록
git.project.history.open.git.window={0}을(를) 눌러 <strong>프로젝트 기록</strong>을 열면 수행된 모든 커밋을 시각적 타임라인에서 미리 볼 수 있습니다.
git.project.history.commits.tree.explanation=커밋 트리는 도구 창의 중앙에 있습니다. 활성화된 브랜치의 마지막 커밋이 강조 표시된 것을 확인할 수 있습니다. 강조 표시된 커밋 아래의 모든 커밋 역시 이 브랜치에 있으며 다른 색으로 표시됩니다. 나머지 커밋을 다른 브랜치에 있습니다.
git.project.history.apply.branch.filter=도구 창의 왼쪽 패널에 저장소의 모든 브랜치가 나열되어 있습니다. 활성화된 브랜치의 커밋만 표시하려면 <strong>HEAD</strong> 브랜치를 {0,choice,0#클릭|1#두 번 클릭}하세요.
git.project.history.apply.user.filter=커밋을 찾는 데 도움이 되는 다양한 필터를 사용할 수 있습니다. 예를 들어 특정 작성자의 커밋을 미리 볼 수 있습니다. 강조 표시된 필터를 클릭하여 사용자 목록을 열어보세요.
git.project.history.select.me=목록에서 {0}을(를) 선택하면 내 커밋만 표시됩니다.
git.project.history.apply.message.filter=강조 표시된 검색창을 이용하면 메시지 또는 해시별로 커밋을 검색할 수 있습니다. 메시지의 일부를 가지고 커밋을 찾으려 한다고 가정해보겠습니다. 예를 들어 강조 표시된 창에 {0}을(를) 입력하고 {1}을(를) 눌러보세요.
git.project.history.select.commit=강조 표시된 커밋을 선택하면 해당 커밋의 정보를 얻을 수 있습니다.
git.project.history.commit.details.explanation=도구 창의 오른쪽 패널에는 선택한 커밋의 메타데이터 및 해당 커밋을 포함하는 브랜치에 관한 정보가 표시됩니다.
git.project.history.click.changed.file=이 커밋에서 변경된 모든 파일이 표시된 트리도 있습니다. 강조 표시된 파일을 두 번 클릭하면 변경 내용을 미리 볼 수 있습니다.
git.project.history.invitation.to.commit.lesson=좋습니다! 다음 수업에서는 커밋을 생성하는 방법을 알아보겠습니다.
git.commit.lesson.name=커밋(commit)
git.commit.open.commit.window=프로젝트에서 파일 몇 개를 수정한 후 현재 브랜치에 커밋하려 한다고 가정해보겠습니다.
git.commit.choose.files={0} 도구 창은 커밋에 대한 폭넓은 사용자 지정을 제공합니다. {1}을(를) 커밋의 일부로 포함하고 싶지 않다고 가정해 봅시다. 체크박스를 선택 해제하여 해당 항목을 제외하세요.
git.commit.choose.files.balloon=강조 표시된 파일을 선택 해제하면 해당 파일이 커밋에서 제외됩니다
git.commit.open.before.commit.options=이제 커밋 옵션을 편집해보겠습니다. {0}을(를) 눌러 Git 옵션 팝업을 열어보세요.
git.commit.analyze.code.explanation={0}을(를) 사용하면 커밋할 파일에서 발견된 경고와 오류에 관해 알림을 받을 수 있습니다. 이 수업에서는 이 옵션을 그대로 두겠습니다.
git.commit.enable.reformat.code={0}을(를) 선택하면 파일이 코드 스타일에 따라 자동으로 편집됩니다.
git.commit.close.commit.options=필수 옵션을 선택한 후에는 커밋 옵션 팝업을 닫으세요. {0}을(를) 누르세요.
git.commit.perform.commit=이제 커밋 메시지를 편집하거나 제안된 대로 둡니다. 그런 다음, {0} 버튼을 클릭하여 커밋을 수행하세요.
git.commit.open.git.window=좋습니다! {0}을(를) 눌러 <strong>Git</strong> 도구 창을 열고 트리에서 내 커밋을 찾아보세요.
git.commit.select.top.commit=트리에서 맨 위의 커밋을 선택하면 그에 관한 세부 정보를 확인할 수 있습니다.
git.commit.committed.file.explanation=<strong>Git</strong> 도구 창의 오른쪽 패널에는 마지막 커밋으로 변경된 파일이 표시됩니다.
git.commit.select.amend.checkbox=마지막으로 수행한 커밋에서 몇 가지 변경을 깜박하고 추가하지 않은 경우 어떻게 해야 할까요? 가장 좋은 방법은 {0} 기능을 사용하여 마지막 커밋을 편집하는 것입니다. {1}을(를) 누르거나 {2} 도구 창에서 {0} 체크박스를 선택하세요.
git.commit.select.file=강조 표시된 파일을 선택하면 해당 파일이 커밋에 추가됩니다.
git.commit.amend.commit={0} 버튼을 클릭하여 마지막 커밋을 편집하세요.
git.commit.select.top.commit.again=<strong>Git</strong> 도구 창에서 맨 위의 커밋을 다시 선택하면 수정된 커밋의 정보를 확인할 수 있습니다.
git.commit.two.committed.files.explanation=이제 대상 커밋에 2개의 변경된 파일이 포함된 것을 확인할 수 있습니다.
git.feature.branch.lesson.name=피처 브랜치 워크플로
git.feature.branch.introduction.1={0} 브랜치에서 작업을 완료한 후 변경 내용을 원격으로 푸시하여 나중에 {1} 브랜치와 병합한다고 가정해 보겠습니다. {2}을(를) 눌러 <strong>Git</strong> 도구 창을 열고 프로젝트 기록을 미리 확인하세요.
git.feature.branch.introduction.2=그런데 내가 피처에서 작업하는 동안 동료도 자신의 변경 내용을 {0} 브랜치로 푸시할 수 있습니다. {0}에 있을 수 있는 변경 내용이 내 변경 내용과 충돌하지 않는지 확인해봅시다.
git.feature.branch.open.branches.popup.1=먼저 {0} 브랜치를 확인하겠습니다. {1}을(를) 누르거나 강조 표시된 현재 브랜치를 클릭하여 브랜치 목록을 여세요.
git.feature.branch.open.branches.popup.balloon=활성화된 브랜치가 여기에 표시됩니다
git.feature.branch.checkout.branch={0} 브랜치를 선택한 후 메뉴에서 {1}을(를) 선택하세요.
git.feature.branch.open.update.dialog=이제 {0} 브랜치를 업데이트하여 원격 저장소에 있을 수 있는 변경 내용을 확인해 보겠습니다.
git.feature.branch.confirm.update={0}을(를) 클릭하여 업데이트를 확인하세요.
git.feature.branch.new.commits.explanation={0} 브랜치에 몇 가지 변경 내용이 있음을 확인할 수 있습니다.
git.feature.branch.open.branches.popup.2=그러므로 사용자의 커밋을 {0} 브랜치에서 가져온 신규 커밋 뒤에 배치해야 합니다. 이는 {1} 기능을 사용하여 수행할 수 있습니다. {2}을(를) 누르거나 현재 강조 표시된 브랜치를 클릭하여 브랜치 목록을 다시 여세요.
git.feature.branch.checkout.and.rebase={0} 브랜치와 {1}을(를) 차례로 선택하세요.
git.feature.branch.open.push.dialog={0} 브랜치를 업데이트한 후에는 원격 저장소에서도 업데이트해야 합니다.
git.feature.branch.choose.force.push=원격 {0} 브랜치가 업데이트된 로컬 브랜치와 충돌하므로 변경 내용을 그냥 푸시할 수는 없습니다. {1}을(를) 사용하세요. {2} 버튼 옆에 있는 강조 표시된 화살표를 눌러 목록을 열고 {1}을(를) 선택하세요.
git.feature.branch.confirm.force.push={0}을(를) 다시 누르고 액션을 확인하세요.
git.interactive.rebase.lesson.name=대화형 리베이스
git.interactive.rebase.open.git.window=프로젝트에서 몇 가지를 수정한다고 가정해보겠습니다. {0}을(를) 눌러 <strong>Git</strong> 도구 창을 열고 프로젝트 기록을 미리 확인해보세요.
git.interactive.rebase.introduction=강조 표시된 커밋 시퀀스를 살펴봐도 보통 어떤 항목이 변경되었는지 파악하기가 어렵습니다. 이때 일부 커밋을 재정렬하거나 스쿼시하면 파악하기가 한결 쉬워집니다.
git.interactive.rebase.open.context.menu=<strong>대화형 리베이스</strong>를 사용해 이 작업을 해결해보세요. 강조 표시된 커밋을 마우스 오른쪽 버튼으로 클릭하여 컨텍스트 메뉴를 엽니다.
git.interactive.rebase.choose.interactive.rebase=목록에서 {0}을(를) 선택하세요.
git.interactive.rebase.select.one.commit=강조 표시된 커밋이 목록의 최상위의 커밋에서 무언가를 수정한 것으로 보입니다. 이 2개의 커밋을 하나로 합치면 좋을 겁니다. 강조 표시된 커밋을 선택하세요.
git.interactive.rebase.move.commit=그러고 나서 이 커밋을 강조 표시된 영역으로 옮기세요. 마우스를 사용하거나 {0}을(를) 3번 누르면 됩니다.
git.interactive.rebase.invoke.fixup={0}을(를) 누르거나 강조 표시된 버튼을 클릭한 후, 목록에서 {1}을(를) 선택하여 이 커밋의 변경 내용을 최상위 커밋에 추가하세요.
git.interactive.rebase.select.three.commits=좋습니다! 3개의 강조 표시된 커밋이 동일한 것 같습니다. 이 커밋을 하나로 합쳐서 결과 메시지를 수정할 수 있습니다. 강조 표시된 커밋을 클릭하거나 {0}을(를) 눌러 선택하세요.
git.interactive.rebase.invoke.squash={0}을(를) 누르거나 {1} 버튼을 클릭하여 커밋을 합치세요.
git.interactive.rebase.apply.reword=기본적으로 모든 스쿼시된 커밋의 메시지는 결과 메시지에 포함됩니다. 그러나 이 수업에서는 <code>Fix style</code> 같은 것으로 메시지를 바꿔보겠습니다. 원하는 경우 메시지를 편집하고 {0}을(를) 눌러 수정 내용을 적용하세요.
git.interactive.rebase.start.rebasing=마지막으로 {0}을(를) 클릭하세요.
git.interactive.rebase.congratulations=축하합니다! 프로젝트 기록이 깔끔하게 정리되었습니다!
git.changelists.shelf.lesson.name=변경 목록 및 보류 항목
git.changelists.shelf.introduction=추가된 주석이 로컬에서만 필요하기 때문에 해당 주석을 저장소에 커밋하지 않으려 한다고 가정해 보겠습니다. 일반적인 경우 이러한 주석은 개인의 설정을 나타냅니다. 주석을 다른 변경 내용과 함께 실수로 커밋하지 않으려면 새 변경 목록으로 추출할 수 있습니다. 강조 표시된 줄의 마커를 클릭하여 컨텍스트 메뉴를 여세요.
git.changelists.shelf.choose.new.changelist={0}을(를) 클릭한 다음, {1} 메뉴 항목을 선택하세요.
git.changelists.shelf.create.changelist=새 변경 목록의 이름을 <code>Comments</code>로 지정하세요. {0}을(를) 누르거나 {1}을(를) 클릭하여 새 변경 목록을 만드세요.
git.changelists.shelf.open.commit.window=이제 생성된 변경 목록을 검사해봅시다.
git.changelists.shelf.explanation=추가로, {0} 기능을 사용하면 컴퓨터상의 파일에 이 변경 내용을 저장할 수 있습니다. {0}에 저장된 변경 내용은 나중에 모든 브랜치에 적용할 수 있습니다. 이렇게 하면 변경 내용을 잃어버릴 염려가 없습니다.
git.changelists.shelf.open.context.menu=변경 내용을 보류 항목에 넣어봅시다! 강조 표시된 변경 목록을 마우스 오른쪽 버튼으로 클릭하여 컨텍스트 메뉴를 여세요.
git.changelists.shelf.open.shelf.dialog={0}을(를) 선택하여 {1} 대화상자를 여세요.
git.changelists.shelf.shelve.changelist=이제 메시지를 편집하거나 그대로 둘 수 있습니다. {0}을(를) 클릭하여 {1}에 변경 내용을 저장하세요.
git.changelists.shelf.remove.changelist=이 변경 목록이 더 이상 필요 없으면 {0} 버튼을 클릭하세요.
git.changelists.shelf.performed.explanation=변경 목록이 {0}에 성공적으로 저장되고 주석이 사라진 것이 확인됩니다.
git.changelists.shelf.open.unshelve.dialog={0}에 변경 내용을 저장하면 이를 다시 적용할 수 있습니다. 강조 표시된 변경 목록을 선택하고 {1}을(를) 열어 <strong>보류 해제</strong> 대화상자를 여세요.
git.changelists.shelf.unshelve.changelist=이제 변경 목록의 이름을 편집하여 보류 해제할 변경 내용을 입력하거나 그대로 둘 수 있습니다. {0}을(를) 클릭하여 변경 내용을 적용하세요.
git.annotate.lesson.name=Git Blame으로 어노테이션 추가
git.annotate.introduction=강조 표시된 프로퍼티를 확인해보세요. 프로퍼티의 값은 고양이의 귀가 4개임을 의미합니다. 이렇게 변경된 이유가 궁금하군요. 이때 {0} 기능을 사용하면 파일 기록을 조사할 수 있습니다.
git.annotate.invoke.shortcut.1={0}을(를) 누르면 이 파일의 기록이 표시됩니다.
git.annotate.open.context.menu=강조 표시된 왼쪽 여백을 마우스 오른쪽 버튼으로 클릭하여 컨텍스트 메뉴를 여세요.
git.annotate.choose.annotate={0} 옵션을 선택하면 이 파일의 기록이 표시됩니다.
git.annotate.add.shortcut.tip=<strong>팁</strong>: {0} 액션의 단축키를 지정할 수 있습니다. 이 {1} 링크를 클릭하여 {2}을(를) 선택해보세요.
git.annotate.feature.explanation={0} 액션을 사용하면 파일의 특정 줄을 수정한 마지막 커밋에 쉽게 액세스할 수 있습니다. {1}(이)라는 사람이 이 줄을 마지막으로 수정한 것이 확인됩니다. 강조 표시된 어노테이션을 마우스 오른쪽 버튼으로 클릭하여 컨텍스트 메뉴를 여세요.
git.annotate.choose.show.diff={0} 옵션을 선택하면 이 커밋에서 변경된 내용이 표시됩니다.
git.annotate.go.deeper=이 커밋 전에 있었던 {0}의 값이 표시되어 있습니다. 그러면 기록을 더 자세히 살펴봅시다!
git.annotate.invoke.shortcut.2=캐럿을 왼쪽 에디터로 이동하고 {0}을(를) 다시 누르세요.
git.annotate.invoke.manually=강조 표시된 영역을 마우스 오른쪽 버튼으로 클릭하여 열린 메뉴에서 {0} 옵션을 선택하세요.
git.annotate.show.diff=강조 표시된 어노테이션을 마우스 오른쪽 버튼으로 클릭하여 컨텍스트 메뉴를 열고 {0}을(를) 선택하세요.
git.annotate.found.needed.commit=잘하셨습니다! {0} 값이 변경된 위치를 찾았습니다. 그러면 마지막으로 이 위치에 어노테이션을 추가하여 이 변경의 이유를 조사해봅시다.
git.annotate.invoke.shortcut.3=캐럿을 오른쪽 에디터로 이동하고 {0}을(를) 누르세요.
git.annotate.click.annotation=강조 표시된 어노테이션을 클릭하면 이 커밋의 정보를 미리 볼 수 있습니다.
git.annotate.close.all.windows=그리고 이제 {0,choice,0#열려 있는 모든 창|1#열려 있는 모든 에디터 탭}을 닫고 에디터로 돌아갑니다. {1}을(를) 두 번 누릅니다.
git.annotate.close.annotations=이제 어노테이션을 닫을 수 있습니다.
git.annotate.close.by.shortcut={0}을(를) 누르세요.
git.quick.start.lesson.name=빠른 시작
git.quick.start.find.action={0} 액션을 사용하면 기존 Git 저장소를 복제할 수 있습니다. {1}을(를) 두 번 눌러 {2} 팝업을 여세요.
git.quick.start.type.clone=검색창에 {0}을(를) 입력하고 강조 표시된 옵션을 선택하세요.
git.quick.start.clone.dialog.got.it.1=저장소 URL을 사용하여 지정된 디렉터리에 저장소를 복제할 수 있습니다
git.quick.start.clone.dialog.got.it.2=또한 인기 있는 버전 관리 시스템에 연결하여 그곳에 저장된 저장소를 복제할 수 있습니다
git.quick.start.close.clone.dialog=하지만, 이 수업을 위한 샌드박스 저장소가 이미 준비되어 있습니다. 대화상자를 닫으셔도 됩니다.
git.quick.start.open.branches=좋습니다! 이제 IDE와 통합된 기능을 이용하여 몇 가지 기본적인 Git 워크플로를 수행하는 방법을 살펴보겠습니다. 예를 들어 <strong>새 브랜치 체크아웃 → 변경 및 커밋 → 푸시</strong>와 같은 워크플로가 있을 수 있습니다. 먼저 {0}을(를) 누르거나 강조 표시된 현재 브랜치를 클릭하여 브랜치 목록을 여세요.
git.quick.start.choose.new.branch.item=목록에서 {0}을(를) 선택하세요.
git.quick.start.name.new.branch=새 브랜치에 사용할 이름을 입력하세요. 그런 다음 {0}을(를) 누르거나 {1}을(를) 클릭하세요.
git.quick.start.modify.file=이 새 브랜치에서는 파일을 변경할 수 있으며 이러한 변경은 IDE에서 탐지됩니다. 예를 들어 열려 있는 파일에서 고양이 눈의 색상을 수정해봅시다. {0}을(를) 다른 색상으로 바꿔보세요.
git.quick.start.open.commit.window=이제 변경된 파일을 커밋할 수 있습니다.
git.quick.start.commit.window.got.it=여기에서는 커밋할 파일을 선택할 수 있습니다
git.quick.start.perform.commit=강조 표시된 영역에 커밋 메시지를 입력하세요(예: <code>Edit eyes color of puss in boots</code>). 그런 다음, {0}을(를) 클릭하세요.
git.quick.start.open.push.dialog=커밋을 수행한 후에는 해당 커밋을 원격 저장소로 푸시할 수 있습니다.
git.quick.start.perform.push=이제 {0}을(를) 클릭하세요. 커밋이 사용자 시스템에서 튜토리얼 목적으로 생성된 저장소로 푸시됩니다.
git.annotate.invoke.manually.2=강조 표시된 영역을 마우스 오른쪽 버튼으로 클릭하여 메뉴에서 {0} 옵션을 선택하세요.
git.use.non.modal.commit.ui.warning=모달이 아닌 커밋 인터페이스를 활성화해야 이 수업을 완료할 수 있습니다. {0}을(를) 누르고 {1} <strong>→</strong> {2}(으)로 이동한 다음 {3}을(를) 선택하세요.
git.project.history.close.diff=변경 내용을 검토한 후 Diff 창을 닫으세요. {0}을(를) 누르세요.
git.open.dialog={0,choice,0#{1}을(를) 누르거나 {2}을(를) 클릭하여|1#{1}을(를) 눌러} {3} 대화상자를 여세요.
git.open.tool.window={0,choice,0#{1}을(를) 누르거나 {2}을(를) 클릭하여|1#{1}을(를) 눌러} {3} 도구 창을 여세요.
git.feature.branch.force.push.tip=<strong>팁</strong>: 해당 브랜치를 본인만 사용하는 것이 아니라면 {0}을(를) 사용하면 안 됩니다. 사용하면 동료의 커밋이 유실될 수 있습니다.
git.project.history.click.head.tooltip=<strong>HEAD</strong>를 {0,choice,0#클릭|1#두 번 클릭}하면 활성화된 브랜치의 커밋만 표시됩니다
git.project.history.click.filter.tooltip=클릭하여 사용자 목록를 여세요
git.commit.open.options.tooltip=클릭하여 {0} 옵션을 여세요
git.interactive.rebase.click.commit.tooltip=강조 표시된 커밋을 마우스 오른쪽 버튼으로 클릭하세요
git.changelists.shelf.click.changelist.tooltip={0} 변경 목록을 마우스 오른쪽 버튼으로 클릭하세요
git.annotate.click.annotation.tooltip=어노테이션을 마우스 오른쪽 버튼으로 클릭하세요
git.click.balloon={0} 을(를) 클릭하세요
git.changelists.shelf.click.line.marker.balloon=줄 마커를 클릭하세요
git.changelists.shelf.congratulations=축하합니다! 변경 목록을 관리하고 변경 내용을 보류하는 방법을 습득하셨습니다.
git.annotate.click.gutter.balloon=여백을 마우스 오른쪽 버튼으로 클릭하세요
git.quick.start.introduction=이 수업에서는 Git 통합의 IDE 기능을 활용하여 기존 프로젝트를 복제하는 방법과 기본적인 버전 관리 워크플로를 수행하는 방법을 배웁니다.
git.annotate.close.changes=강조 표시된 커밋 메시지에 따르면 {0}의 이상한 값은 실수가 아닙니다. 그러므로 이 파일의 기록을 살펴본 뒤에 열려 있는 열린 도구 창을 닫고 에디터로 돌아갈 수 있습니다. {1}을(를) 누릅니다.
git.quick.start.help.link=Git 저장소 설정
git.commit.help.link=변경 내용을 Git 저장소에 커밋 및 푸시
git.feature.branch.help.link=Git 브랜치 관리
git.interactive.rebase.help.link=대화형 리베이스를 수행하여 프로젝트 기록 편집
git.changelists.shelf.help.link=Git을 사용하여 여러 기능을 동시에 작업
git.annotate.help.link=코드 작성자 찾기(Git Blame으로 어노테이션 추가)
git.not.use.staging.area.warning=이번 강좌를 완료하려면 <strong>스테이징 영역</strong>을 비활성화해야 합니다. {0}을(를) 누르고 {1} <strong>→</strong> {2}(으)로 이동한 다음 {3}을(를) 선택 해제하세요.
git.click.to.change.settings=혹은 <callback id="{0}">클릭</callback>하여 설정을 변경할 수 있습니다.
