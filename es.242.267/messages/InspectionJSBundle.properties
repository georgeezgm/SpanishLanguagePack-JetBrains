add.require.amd.module.fix={0} 모듈 종속성을 추가합니다.
add.require.amd.module.group.name=Node.js
add.return.statement.fix.name=return 문을 추가합니다
anonymous.function.contains.multiple.loops.error.string=\#ref에 {0}개의 루프가 있습니다 \#loc
anonymous.function.contains.multiple.return.points.error.string=\#ref에 {0}개의 반환점이 있습니다 \#loc
anonymous.function.contains.too.many.negation.error.string=\#ref에 {0}개의 부정이 있습니다 \#loc
anonymous.function.display.name=익명 함수
anonymous.function.error.string=익명 함수 \#loc
anonymous.function.has.inconsistent.return.points.error.string=\#ref에 일관되지 않은 반환점이 있습니다 \#loc
anonymous.function.has.too.many.parameters.error.string=\#ref에 매개변수가 너무 많습니다(매개변수 수 \= {0}) \#loc
anonymous.function.is.overly.complex.cyclomatic.complexity.error.string=''\#ref''이(가) 지나치게 복잡합니다(순환 복잡성 \= {0}) \#loc
anonymous.function.is.overly.long.statement.error.string=\#ref이(가) 지나치게 깁니다(구문 수 \= {0}) \#loc
anonymous.function.is.overly.nested.error.string=\#ref이(가) 지나치게 중첩되어 있습니다(중첩 깊이가 {0}, 허용되는 최대값은 {1}) \#loc
assignment.replaceable.with.operator.assignment.display.name=대입을 연산자 대입으로 바꿀 수 있습니다
assignment.replaceable.with.operator.assignment.error.string=\#ref을(를) {0}(으)로 단순화할 수 있습니다 \#loc
assignment.to.for.loop.parameter.display.name='for' 루프 매개변수에 대입
assignment.to.for.loop.parameter.error.string=for 루프 매개변수 \#ref에 대입 \#loc
assignment.to.function.parameter.display.name=함수 매개변수에 대입
assignment.to.function.parameter.error.string=함수 매개변수 '\#ref'에 대입되었습니다 \#loc
break.statement.display.name='break' 문
break.statement.error.string='\#ref' 문 \#loc
break.statement.with.label.display.name=라벨이 있는 'break' 문
break.statement.with.label.error.string=라벨 지정된 '\#ref' 문 \#loc
call.to.document.write.display.name='document.write()' 호출
caller.display.name='caller' 프로퍼티 사용
caller.error.string='\#ref' 프로퍼티가 사용되고 있습니다 \#loc
chained.equality.display.name=체인 상등
chained.equality.error.string=체인 상등 비교 <code>\#ref</code> \#loc
chained.function.call.display.name=체인 함수 호출
chained.function.call.problem.descriptor=함수 '\#ref' 호출이 체인되어 있습니다 \#loc
class.name.doesnt.match.regex.error.string=클래스 이름 {0}이(가) 정규식 ''{1}''와(과) 일치하지 않습니다 \#loc
class.name.is.too.long.error.string=클래스 이름 ''{0}''이(가) 너무 깁니다 \#loc
class.name.is.too.short.error.string=클래스 이름 ''{0}''이(가) 너무 짧습니다 \#loc
class.naming.convention.display.name=클래스 이름 지정 규칙
collapse.conditional.expression.fix=조건식 접기
collapse.if.statement.fix='if' 문 접기
comma.expression.display.name=쉼표 표현식
comma.expression.error.string=쉼표 표현식 \#loc
conditional.expression.display.name=조건식
conditional.expression.error.string=조건식 \#loc
conditional.expression.with.identical.branches.display.name=동일한 브랜치가 있는 조건식
conditional.expression.with.identical.branches.error.string=동일한 브랜치가 있는 조건식 <code>\#ref</code> \#loc
confusing.floating.point.literal.change.quickfix=표준 형식으로 변경
confusing.floating.point.literal.display.name=혼동되는 부동소수점 리터럴
confusing.floating.point.literal.problem.descriptor=부동소수점 리터럴 <code>\#ref</code>이(가) 혼동됩니다 \#loc
confusing.pluses.or.minuses.display.name=혼동되는 '+' 또는 '-'의 시퀀스
confusing.pluses.or.minuses.error.string=공백을 제거하면 '+' 또는 '-'의 시퀀스가 의미를 변경할 수 있습니다 \#loc
constant.conditional.expression.display.name=상수 조건식
constant.conditional.expression.error.string=<code>\#ref</code>을(를) 단순화할 수 있습니다 \#loc
constant.on.left.side.of.comparison.display.name=비교 중인 왼쪽의 상수
constant.on.left.side.of.comparison.error.string=\#ref\: 비교 중인 왼쪽의 상수 \#loc
constant.on.right.side.of.comparison.display.name=비교 중인 오른쪽의 상수
constant.on.right.side.of.comparison.error.string=\#ref\: 비교 중인 오른쪽의 상수 \#loc
constructor.name.doesnt.match.regex.error.string=생성자 이름 ''{0}''이(가) 정규식 ''{1}''와(과) 일치하지 않습니다 \#loc
constructor.name.is.too.long.error.string=생성자 이름 ''{0}''이(가) 너무 깁니다 \#loc
constructor.name.is.too.short.error.string=생성자 이름 ''{0}''이(가) 너무 짧습니다 \#loc
continue.or.break.inside.finally.block.display.name='finally' 블록 내 'continue' 또는 'break'
continue.or.break.inside.finally.block.error.string='finally' 블록 내 '\#ref' \#loc
continue.statement.display.name='continue' 문
continue.statement.error.string='\#ref' 문 \#loc
continue.statement.with.label.display.name=라벨이 있는 'continue' 문
continue.statement.with.label.error.string=라벨 지정된 '\#ref' 문 \#loc
debugger.statement.display.name='debugger' 문
debugger.statement.error.string='\#ref' 문 \#loc
default.branch.not.last.case.in.switch.error.string=<code>\#ref</code> 브랜치가 'switch'의 마지막 case가 아닙니다 \#loc
default.not.last.case.in.switch.display.name='default'가 'switch'의 마지막 case가 아님
divide.by.zero.display.name=0으로 나누기
division.by.zero.error.string=0으로 나누기 \#loc
document.write.error.string='\#ref()'을(를) 호출합니다 \#loc
duplicate.case.label.display.name=중복 'case' 라벨
duplicate.case.label.error.string=중복 case 라벨 \#ref \#loc
duplicate.condition.error.string=중복 조건 <code>\#ref</code> \#loc
duplicate.condition.in.if.statement.display.name='if' 문의 중복 조건
dynamically.generated.code.display.name=동적으로 생성된 코드 실행
dynamically.generated.code.error.string=함수 '\#ref'이(가) 동적으로 생성된 코드를 표시합니다 \#loc
empty.catch.block.display.name=빈 'catch' 블록
empty.catch.block.error.string=빈 '\#ref' 블록 \#loc
empty.finally.block.display.name=빈 'finally' 블록
empty.finally.block.error.string=빈 'finally' 블록 \#loc
empty.try.block.display.name=빈 'try' 블록
empty.try.block.error.string=빈 '\#ref' 블록 \#loc
exception.caught.locally.error.string=예외의 '\#ref'이(가) 로컬에서 캡처되었습니다 \#loc
exception.used.for.local.control.flow.display.name=로컬 제어 흐름에 사용되는 예외
expression.statement.is.not.assignment.or.call.error.string=표현식 구문이 대입 또는 호출이 아닙니다 \#loc
expression.statement.which.is.not.assignment.or.call.display.name=대입 또는 호출이 아닌 표현식 구문
fall.through.in.switch.statement.display.name='switch' 문의 폴스루
fall.through.in.switch.statement.error.string='switch' 문의 폴스루 \#loc. 'break' 또는 'return'이 누락되었습니다
flip.comparison.fix=비교 반전
for.loop.not.use.loop.variable.display.name=업데이트 또는 조건이 루프 변수를 사용하지 않는 'for' 루프
for.loop.not.use.loop.variable.problem.descriptor.both.condition.and.update=<code>\#ref</code> 문에 for 루프 변수를 사용하지 않는 조건 및 업데이트가 있습니다 \#loc
for.loop.not.use.loop.variable.problem.descriptor.condition=<code>\#ref</code> 문에 for 루프 변수를 사용하지 않는 조건이 있습니다 \#loc
for.loop.not.use.loop.variable.problem.descriptor.update=<code>\#ref</code> 문에 for 루프 변수를 사용하지 않는 업데이트가 있습니다 \#loc
for.loop.replaceable.by.while.display.name='for' 루프를 'while' 루프로 바꿀 수 있음
for.loop.replaceable.by.while.ignore.option=조건 없는 루프의 'infinite' 무시
for.loop.replaceable.by.while.problem.descriptor=<code>\#ref</code> 루프를 'while' 루프로 바꿀수 있습니다 \#loc
for.loop.replaceable.by.while.replace.quickfix='while'로 바꾸기
function.complexity.limit.parameter=함수 복잡성 제한\:
function.contains.multiple.loops.error.string=함수 ''\#ref''에 {0}개의 루프가 있습니다 \#loc
function.contains.multiple.return.points.error.string=\#ref에 {0}개의 반환점이 있습니다 \#loc
function.contains.too.many.negation.error.string=함수 ''\#ref''에 {0}개의 부정이 있습니다 \#loc
function.has.inconsistent.return.points.error.string=함수 \#ref에 일관되지 않은 반환점이 있습니다 \#loc
function.has.too.many.parameters.error.string=함수 ''\#ref''에 매개변수가 너무 많습니다(매개변수 수 \= {0}) \#loc
function.is.overly.long.statement.error.string=함수 ''\#ref''이(가) 지나치게 깁니다(구문 수 \= {0}) \#loc
function.is.overly.nested.error.string=함수 ''\#ref''이(가) 지나치게 중첩되어 있습니다(중첩 깊이가 {0}, 허용되는 최대값은 {1}) \#loc
function.name.doesnt.match.regex.error.string=함수 이름 ''{0}''이(가) 정규식 ''{1}''와(과) 일치하지 않습니다 \#loc
function.name.is.too.long.error.string=함수 이름 ''{0}''이(가) 너무 깁니다 \#loc
function.name.is.too.short.error.string=함수 이름 ''{0}''이(가) 너무 짧습니다 \#loc
function.naming.convention.display.name=함수 이름 지정 규칙
function.parameter.limit=함수 매개변수 제한\:
function.parameter.naming.convention.display.name=함수 매개변수 이름 지정 규칙
function.ref.is.overly.complex.cyclomatic.complexity.error.string=함수 ''\#ref''이(가) 지나치게 복잡합니다(순환 복잡성 \= {0}) \#loc
function.with.inconsistent.returns.display.name=일관되지 않은 반환이 있는 함수
function.with.more.than.three.negations.display.name=3개 이상의 부정이 있는 함수
function.with.multiple.loops.display.name=여러 루프가 있는 함수
function.with.multiple.return.points.display.name=여러 반환점이 있는 함수
function.with.too.many.parameters.display.name=매개변수가 너무 많은 함수
group.path.javascript=JavaScript
if.statement.with.identical.branches.display.name=브랜치가 동일한 'if' 문
if.statement.with.too.many.branches.display.name=브랜치가 너무 많은 'if' 문
if.statement.with.too.many.branches.error.string=''\#ref''에 브랜치가 너무 많습니다({0}) \#loc
include.anonymous.functions.parameter=익명 함수 포함
include.statement.bodies.that.are.empty.code.blocks.parameter=빈 코드 블록인 구문 본문 포함
incompatible.mask.operation.display.name=호환되지 않는 비트 마스크 연산
incompatible.mask.operation.problem.descriptor.always.false=<code>\#ref</code>이(가) 항상 false입니다 \#loc
incompatible.mask.operation.problem.descriptor.always.true=<code>\#ref</code>이(가) 항상 true입니다 \#loc
infinite.loop.error.string=<code>\#ref</code> 문은 예외를 던지지 않으면 완료되지 않습니다 \#loc
infinite.loop.statement.display.name=무한 루프 문
infinite.recursion.display.name=무한 재귀
infinite.recursion.problem.descriptor=함수 <code>\#ref</code>이(가) 무한 반복되며 예외를 던져야 종료됩니다 \#loc
inner.html.error.string='\#ref' 프로퍼티가 사용됨 \#loc
invert.condition.fix=조건 반전
invert.if.condition.fix='if' 조건 반전
javascript.dom.issues.group.name=DOM 문제
js.inspection.group.path=JavaScript 및 TypeScript
js.inspection.switch.group.name=switch 문 이슈
labeled.statement.display.name=라벨 지정된 구문
local.variable.naming.convention.display.name=지역 변수 이름 지정 규칙
loop.statement.that.doesn.t.loop.display.name=루프를 실행하지 않는 루프 문
loop.statement.that.doesnt.loop.error.string=<code>\#ref</code> 문이 루프되지 않습니다 \#loc
magic.number.display.name=매직 넘버
magic.number.problem.descriptor=매직 넘버 '\#ref' \#loc
maximum.number.of.branches.parameter=최대 브랜치 수\:
maximum.number.of.terms.parameter=최대 항 수\:
maximum.statements.per.function=함수당 최대 구문 수\:
missing.return.statement.error.string=return 문이 누락되어 있습니다 \#loc
negated.conditional.expression.display.name=부정된 조건식
negated.conditional.expression.error.string=부정된 조건식 \#loc
negated.if.statement.display.name=부정된 'if' 문
negated.ref.statement.error.string=부정된 '\#ref' 문 \#loc
nested.anonymous.function.error.string=중첩된 \#ref \#loc
nested.assignment.display.name=중첩된 대입
nested.assignment.error.string=중첩된 대입 <code>\#ref</code> \#loc
nested.conditional.expression.display.name=중첩된 조건식
nested.conditional.expression.error.string=중첩된 조건식 \#loc
nested.function.call.display.name=중첩된 함수 호출
nested.function.call.problem.descriptor=함수 '\#ref' 호출이 중첩되어 있습니다 \#loc
nested.function.display.name=중첩된 함수
nested.function.error.string=중첩된 함수 '\#ref' \#loc
nested.switch.statement.display.name=중첩된 'switch' 문
nested.switch.statement.error.string=중첩된 '\#ref' 문 \#loc
nesting.depth.limit=중첩 깊이 제한\:
non.block.body.error.string=<code>\#ref</code> 문에 블록이 아닌 본문이 있습니다 \#loc
non.block.branch.error.string=<code>\#ref</code> 문에 블록이 아닌 브랜치가 있습니다 \#loc
non.block.statement.body.display.name=중괄호가 없는 구문 본문
octal.integer.display.name=8진 정수
overly.complex.arithmetic.expression.display.name=지나치게 복잡한 산술 표현식
overly.complex.arithmetic.expression.error.string=지나치게 복잡한 산술 표현식 \#loc
overly.complex.boolean.expression.display.name=지나치게 복잡한 부울 표현식
overly.complex.boolean.expression.error.string=지나치게 복잡한 부울 표현식 \#loc
overly.complex.function.display.name=지나치게 복잡한 함수
overly.long.function.display.name=지나치게 긴 함수
overly.nested.function.display.name=지나치게 중첩된 함수
parameter.name.doesnt.match.regex.error.string=매개변수 이름 ''\#ref''이(가) 정규식 ''{0}''와(과) 일치하지 않습니다 \#loc
parameter.name.is.too.long.error.string=매개변수 이름 '\#ref'이(가) 너무깁니다 \#loc
parameter.name.is.too.short.error.string=매개변수 이름 '\#ref'이(가) 너무 짧습니다 \#loc
platform.detection.display.name=정확하지 않은 플랫폼 탐지
platform.detection.error.string='\#ref'이(가) 플랫폼 탐지에 사용되는 것 같습니다 \#loc
pointless.arithmetic.error.message=\#ref을(를) {0}(으)로 바꿀수 있습니다 \#loc
pointless.arithmetic.expression.display.name=무의미한 산술 표현식
pointless.bitwise.expression.display.name=Bitwise 표현식을 단순화할 수 있음
pointless.bitwise.expression.ignore.option=무의미한 표현식 판단 시 명명된 상수 무시
pointless.bitwise.expression.problem.descriptor=''{1}''을(를) ''{0}''(으)로 바꿀수 있습니다 \#loc
pointless.bitwise.expression.simplify.quickfix=단순화
pointless.boolean.error.string={0}(으)로 단순화할 수 있습니다 \#loc
pointless.boolean.expression.display.name=무의미한 구문 또는 부울 표현식
pointless.statement.error.string={0} 문을 단순화할 수 있습니다 \#loc
redundant.conditional.expression.display.name=중복 조건식
redundant.if.statement.display.name=중복 'if' 문
redundant.local.variable.display.name=중복 지역 변수
redundant.local.variable.ignore.option=즉시 반환되거나 던져된 변수 무시
redundant.local.variable.quickfix=변수 인라인화
ref.statement.with.identical.branches.error.string=동일한 브랜치가 있는 <code>\#ref</code> 문 \#loc
remove.label.fix=라벨 제거
remove.unnecessary.continue.fix=불필요한 continue를 제거합니다
remove.unnecessary.return.fix=불필요한 return을 제거합니다
rename.fix=이름 변경
replace.redundant.await.family.name=중복 await 바꾸기
replace.with.operator.assign.fix=\=를 {0}\=로 바꾸기
reserved.word.used.as.name.display.name=이름으로 사용되는 예약 단어
reserved.word.used.as.name.error.string=이름으로 사용되는 예약 단어 '\#ref'
result.of.assignment.expression.used.error.string=대입 표현식의 결과가 사용되었습니다 \#loc
result.of.assignment.used.displayName=대입 결과 사용
result.of.increment.or.decrement.expression.used.error.string=사용된 증분 또는 감소 표현식의 결과 \#loc
result.of.increment.or.decrement.used.display.name=사용된 증분 또는 감소의 결과
result.of.object.allocation.ignored.display.name=객체 대입의 결과가 무시됨
result.of.object.allocation.ignored.error.string=<code>new \#ref()</code>의 결과가 무시되었습니다 \#loc
return.inside.finally.block.display.name='finally' 블록 내 'return'
return.inside.finally.block.error.string='finally' 블록 내 '\#ref' \#loc
reuse.of.local.variable.display.name=지역 변수 재사용
reuse.of.local.variable.problem.descriptor=지역 변수 <code>\#ref</code> 재사용 \#loc
set.return.type.to.void.fix.name=반환 타입을 void로 설정
shift.operation.by.inappropriate.constant.display.name=잘못된 상수에 의한 시프트 연산이 있을 수 있음
shift.operation.by.inappropriate.constant.problem.descriptor.negative=음수값에의한 시프트 연산 <code>\#ref</code> \#loc
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=지나치게 큰 상수값에의한 시프트 연산 <code>\#ref</code> \#loc
shift.out.of.range.family.name=시프트 값 수정
silly.assignment.display.name=변수가 자신에게 할당됨
silly.assignment.error.string=변수가 자신에게 할당됩니다 \#loc
simplify.fix=단순화
statement.has.empty.body.error.string=<code>\#ref</code> 문에 본문이 비어 있습니다 \#loc
statement.has.empty.branch.error.string=<code>\#ref</code> 문에 브랜치가 비어 있습니다 \#loc
statement.label.error.string=구문 라벨 '\#ref' \#loc
statement.simplify.quickfix=구문을 단순화합니다.
statement.with.empty.body.display.name=본문이 비어 있는 구문
string.literal.breaks.html.display.name=HTML 구문 분석을 중단하는 문자열 리터럴
string.literal.breaks.html.error.string=문자열 리터럴 \#ref이(가) HTML 구문 분석을 중단할 수 있습니다 \#loc
tail.recursion.display.name=꼬리 재귀
tail.recursion.problem.descriptor=꼬리 재귀 \#loc
terminate.statement.fix=구문 종료
text.label.in.switch.statement.display.name='switch' 문의 텍스트 라벨
text.label.in.switch.statement.error.string=텍스트 라벨 <code>\#ref\:</code>이(가) 'switch' 문에 있습니다 \#loc
this.expression.references.global.object.error.string=최상위 '\#ref' 표현식 \#loc
this.expression.which.references.the.global.object.display.name=전역 객체를 참조하는 'this' 식
throw.inside.finally.block.display.name='finally' 블록 내 'throw'
throw.inside.finally.block.error.string='finally' 블록 내 '\#ref' \#loc
trivial.conditional.error.string=''{0}''을(를) ''{1}''(으)로 단순화할 수 있습니다 \#loc
trivial.if.error.string=<code>\#ref</code> 문을 단순화할 수 있습니다 \#loc
typeof.using.incorrect.case.display.name=비표준 값과 'typeof' 비교
typeof.using.incorrect.case.error=비표준 값과 비교하는 typeof
typeof.using.incorrect.convert={0}(으)로 변환
typeof.using.incorrect.family.name=표준 값으로 변환
unnecessary.block.statement.display.name=불필요한 block 문
unnecessary.block.statement.error.string=불필요한 block 문 \#loc
unnecessary.continue.error.string=루프의 마지막 구문으로서 <code>\#ref</code>은(는) 불필요합니다 \#loc
unnecessary.continue.statement.display.name=불필요한 'continue' 문
unnecessary.label.display.name=불필요한 라벨
unnecessary.label.error.string=불필요한 라벨 <code>\#ref</code> \#loc
unnecessary.label.on.break.error.string=불필요한 라벨이 있는 <code>\#ref</code> 문 \#loc
unnecessary.label.on.break.statement.display.name='break' 문의 불필요한 라벨
unnecessary.label.on.continue.error.string=불필요한 라벨이 있는 <code>\#ref</code> 문 \#loc
unnecessary.label.on.continue.statement.display.name='continue' 문의 불필요한 라벨
unnecessary.local.variable.problem.descriptor=지역 변수 {0}이(가) 중복됩니다
unnecessary.return.error.string=반환값이 없는 함수의 마지막 구문에 <code>\#ref</code>은(는) 불필요합니다 \#loc
unnecessary.return.statement.display.name=불필요한 'return' 문
unreachable.code.display.name=사용할 수 없는 코드
unreachable.code.error.string=도달할 수 없는 코드 \#loc
unterminated.statement.display.name=종료되지 않은 구문
unterminated.statement.error.string=종료되지 않은 구문 \#loc
unterminated.statement.ignore.atend.of.block=블록 끝에 세미콜론의 누락 허용
unterminated.statement.possibly.unterminated.statement.error=종료되지 않았을 수 있는 구문 \#loc
unused.catch.parameter.display.name=사용되지 않는 'catch' 매개변수
unused.catch.parameter.ignore.catch.option=주석이 포함된 catch 블록 무시
unused.catch.parameter.problem.descriptor=사용되지 않는 catch 매개변수 <code>\#ref</code> \#loc
use.of.innerhtml.property.display.name='innerHTML' 프로퍼티 사용
variable.name.doesnt.match.regex.error.string=변수 이름 ''\#ref''이(가) 정규식 ''{0}''와(과) 일치하지 않습니다 \#loc
variable.name.is.too.long.error.string=변수 이름 '\#ref'이(가) 너무 깁니다 \#loc
variable.name.is.too.short.error.string=변수 이름 '\#ref'이(가) 너무 짧습니다 \#loc
void.expression.display.name='void' 표현식
void.expression.error.string='\#ref' 표현식 \#loc
with.expression.error.string='\#ref' 문 \#loc
with.statement.display.name='with' 문
wrap.statement.body.fix=구문의 본문을 줄 바꿈합니다.
xhtml.incompatabilities.error.string='\#ref'이(가) XHTML 문서에 대해 일관하지 않는 결과를 생성할 수 있습니다 \#loc
xhtml.incompatibilities.display.name=호환되지 않는 XHTML 사용
