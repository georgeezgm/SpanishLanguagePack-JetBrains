action.find.similar.stack.call.methods.not.found=유사한 클래스를 찾을 수 없습니다
advanced.setting.process.console.output.to.find.class.names=터미널 출력을 처리하여 클래스 이름을 찾고 강조 표시
allow.suppressions.fix.family.name=억제 허용
allow.suppressions.fix.text=해당 억제 허용
assertequals.between.inconvertible.types.display.name=변환할 수 없는 타입의 객체 간의 'assertequals()'
can.t.build.uast.tree.for.file=파일에 대한 UAST 트리를 빌드할 수 없습니다.
checkbox.comments.and.javadoc.count.as.content=주석 및 javadoc을 내용으로 간주
current.version=현재 버전
dialog.title.choose.annotation={0} 선택 
group.advanced.settings.jvm=JVM 언어
ignored.suppressions=무시된 억제\:
inspection.empty.method.delete.quickfix=불필요한 메서드 삭제
inspection.empty.method.display.name=빈 메서드
inspection.empty.method.problem.descriptor=메서드가 상위 메서드만 호출합니다
inspection.empty.method.problem.descriptor1=빈 메서드가 빈 메서드를 재정의합니다
inspection.empty.method.problem.descriptor2=빈 메서드입니다
inspection.empty.method.problem.descriptor3=메서드 및 모든 파생 항목이 비어 있습니다
inspection.empty.method.problem.descriptor4=이 메서드의 모든 구현이 비어 있습니다
inspection.message.illegal.dependency.module.doesn.t.export=유효하지 않은 종속 요소\: 모듈 ''{0}''은(는) 패키지 ''{1}''을(를) 내보내지 않습니다
inspection.suppression.annotation.display.name=검사 숨기기 어노테이션
inspection.suppression.annotation.problem.descriptor=어노테이션이 {0}을(를) 억제합니다 \#loc
inspection.suppression.comment.problem.descriptor=주석이 {0}을(를) 억제합니다 \#loc
jvm.class.filter.choose.calls=비슷한 로그 호출\:
jvm.inspection.log.guarded.display.name=로그 조건으로 로그 호출에 guard가 적용됨
jvm.inspection.log.guarded.fix.family.name=로그 guard 조건 래핑 해제
jvm.inspection.log.guarded.problem.descriptor=로그 조건으로 로그 호출에 guard가 적용됨 \#loc
jvm.inspection.log.guarded.warn.if.fix.possible=수정할 수 있을 때만 경고
jvm.inspection.log.statement.not.guarded.all.levels.option=모든 로그 수준
jvm.inspection.log.statement.not.guarded.debug.level.and.lower.option=디버그 수준 이하
jvm.inspection.log.statement.not.guarded.display.name=로그 조건으로 로그 호출에 guard가 적용되지 않음
jvm.inspection.log.statement.not.guarded.info.level.and.lower.option=정보 수준 이하
jvm.inspection.log.statement.not.guarded.log.fix.family.name=로그 조건으로 둘러싸기
jvm.inspection.log.statement.not.guarded.log.problem.descriptor=로그 조건으로 로그 호출에 guard가 적용되지 않음 \#loc
jvm.inspection.log.statement.not.guarded.trace.level.option=추적 수준
jvm.inspection.log.statement.not.guarded.unguarded.constant.option=상수 메시지로 보호되지 않은 로그 호출 처리
jvm.inspection.log.statement.not.guarded.unguarded.constant.option.comment=상수가 아닌 인수가 있는 호출 뿐만 아니라 모든 보호되지 않은 로그 호출 처리
jvm.inspection.log.statement.not.guarded.warn.level.and.lower.option=경고 수준 이하
jvm.inspection.log.statement.not.guarded.warn.on.label=다음에 대해 경고\:
jvm.inspection.logging.condition.disagrees.with.log.statement.display.name=로그 조건이 로깅 호출과 일치하지 않음
jvm.inspection.logging.condition.disagrees.with.log.statement.fix.family.name=로그 수준 변경
jvm.inspection.logging.condition.disagrees.with.log.statement.fix.name={0, choice, 0\#조건|1\#호출}의 수준 변경
jvm.inspection.logging.condition.disagrees.with.log.statement.problem.descriptor=조건 ''{0}''의 레벨이 로그 호출 ''{1}''의 레벨과 일치하지 않습니다
jvm.inspection.logging.placeholder.count.matches.argument.count.display.name=자리표시자 수가 로깅 호출의 인수 수와 일치하지 않음
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.descriptor=지정된 자리표시자 수({1})보다 인수의 수({0})가 적습니다 \#loc
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.partial.descriptor=지정된 자리표시자 수(최소 {1}개)보다 제공된 인수의 수({0}개)가 적습니다 \#loc
jvm.inspection.logging.placeholder.count.matches.argument.count.incorrect.problem.descriptor=잘못된 서식 문자열 지정자 \#loc
jvm.inspection.logging.placeholder.count.matches.argument.count.more.problem.descriptor=지정된 자리표시자 수({1})보다 인수의 수({0})가 많습니다 \#loc
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option=SLF4J가 Log4j 2를 구현으로 사용합니다
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.auto=자동 확인
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.no=아니요
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.yes=예
jvm.inspection.logging.similar.message.display.name=구분할 수 없는 로그 호출
jvm.inspection.logging.similar.message.problem.descriptor=유사한 로그 메시지
jvm.inspection.logging.similar.message.problem.min.similar.length=비슷한 시퀀스의 최대 길이
jvm.inspection.logging.similar.message.problem.skip.on.error=`error` 로그 수준으로 호출을 보고 안 함
jvm.inspection.logging.string.template.as.argument.all.levels.option=모든 로그 수준
jvm.inspection.logging.string.template.as.argument.debug.level.and.lower.option=디버그 수준 이하
jvm.inspection.logging.string.template.as.argument.display.name=문자열 템플릿을 로깅 호출에 인수로 전달
jvm.inspection.logging.string.template.as.argument.info.level.and.lower.option=정보 수준 이하
jvm.inspection.logging.string.template.as.argument.problem.descriptor=<code>\#ref()</code> 로깅 호출에 문자열 템플릿을 인수로 전달 \#loc
jvm.inspection.logging.string.template.as.argument.quickfix.name=자리표시자로 대체
jvm.inspection.logging.string.template.as.argument.skip.on.primitives=원시 타입, 래퍼 또는 문자열이 있는 표현식만 포함되었을 때 경고 안 함
jvm.inspection.logging.string.template.as.argument.trace.level.option=추적 수준
jvm.inspection.logging.string.template.as.argument.warn.level.and.lower.option=경고 수준 이하
jvm.inspection.logging.string.template.as.argument.warn.on.label=다음에 대해 경고\:
jvm.inspection.test.failed.line.display.name=테스트에서 실패한 줄
jvm.inspections.1.5.problem.descriptor=@since {0}로 기록된 API 사용
jvm.inspections.1.7.problem.descriptor=JDK {0}에 컴파일 문제를 일으킬 수 있는 1.6 이후에 일반화된 API 사용
jvm.inspections.1.8.problem.descriptor=디폴트 {0, choice, 0\#|1\#메서드가|2\#메서드가} 재정의되지 않았습니다. JDK {1}에 컴파일 문제를 일으킬 수 있습니다.
jvm.inspections.1.8.problem.single.descriptor=디폴트 메서드 ''{0}''이(가) 재정의되지 않았습니다. 이로 인해 JDK {1}에 컴파일 문제가 발생할 수 있습니다
jvm.inspections.api.display.name=구성된 언어 수준에서 사용할 수 없는 API 사용
jvm.inspections.api.no.extension.class.description=클래스 ''{0}''은(는) 확장되면 안 됩니다.
jvm.inspections.api.no.extension.display.name=클래스, 인터페이스 또는 메서드가 확장되면 안 됨
jvm.inspections.api.no.extension.interface.extend.description=인터페이스 ''{0}''은(는) 확장되면 안 됩니다.
jvm.inspections.api.no.extension.interface.implement.description=인터페이스 ''{0}''은(는) 구현되면 안 됩니다.
jvm.inspections.api.no.extension.method.overriding.description=메서드 ''{0}''은(는) 재정의되면 안 됩니다.
jvm.inspections.api.override.only.description=메서드 ''{0}''은(는) 재정의만 가능합니다.
jvm.inspections.api.override.only.display.name=메서드는 재정의만 가능
jvm.inspections.assertequals.between.inconvertible.types.problem.descriptor=<code>\#ref()</code>이(가) 변환할 수 없는 타입인 ''{0}'' 및 ''{1}''의 객체 사이에 있습니다. \#loc
jvm.inspections.assertnotequals.between.inconvertible.types.problem.descriptor=어설션이 불필요할 수 있습니다. 호환되지 않는 타입, ''{0}'' 및 ''{1}''이(가) 비교됩니다
jvm.inspections.assertnotsame.between.inconvertible.types.problem.descriptor=어설션이 불필요합니다. 호환되지 않는 타입, ''{0}'' 및 ''{1}''이(가) 비교됩니다
jvm.inspections.blocking.method.annotation.blocking=블로킹 어노테이션\:
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=Blocking 어노테이션 추가
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=Non-Blocking 어노테이션 추가
jvm.inspections.blocking.method.annotation.non-blocking=비 블로킹 어노테이션\:
jvm.inspections.blocking.method.consider.suspend.context.non.blocking=Kotlin 일시 중지 컨텍스트를 블로킹이 아닌 것으로 간주
jvm.inspections.blocking.method.consider.unknown.context.blocking=알 수 없는 컨텍스트를 블로킹으로 고려
jvm.inspections.blocking.method.consider.unknown.context.nonblocking=알 수 없는 컨텍스트를 비 블로킹으로 간주
jvm.inspections.blocking.method.display.name=비 블로킹 컨텍스트의 잠재적 블로킹 호출
jvm.inspections.blocking.method.in.implicit.ctr.problem.descriptor=블로킹이 아닌 컨텍스트에서 묵시적 생성자로부터의 블로킹 호출은 잠재적으로 스레드 기아 상태를 일으킬 수 있습니다
jvm.inspections.blocking.method.in.implicit.ctr.problem.wildcard.descriptor={0}에서 묵시적 생성자로부터의 블로킹 호출은 잠재적으로 스레드 기아 상태를 일으킬 수 있습니다
jvm.inspections.blocking.method.intention.text=검사 옵션 ''{0}''을(를) 활성화합니다.
jvm.inspections.blocking.method.problem.descriptor=비 블로킹 컨텍스트에서 호출을 막는 것은 스레드에서 기아 상태를 일으킬 수 있습니다
jvm.inspections.blocking.method.problem.wildcard.descriptor={0}에서 호출을 블로킹하면 스레드에서 기아 상태를 일으킬 수 있습니다
jvm.inspections.collection.contains.url.problem.descriptor=''{0}''에 URL 객체가 있습니다 \#loc
jvm.inspections.dependency.display.name=잘못된 패키지 종속성
jvm.inspections.dependency.edit.rules.family=종속성 규칙 편집
jvm.inspections.dependency.edit.rules.text=종속성 규칙 "{0}" 편집
jvm.inspections.dependency.intention.description=스코프 간 종속성 규칙을 구성하는 대화상자를 엽니다.
jvm.inspections.dependency.on.internal.display.name=내부 패키지에 유효하지 않은 종속 요소
jvm.inspections.dependency.violator.problem.descriptor=종속성 규칙 ''{0}.''이(가) 위반되었습니다
jvm.inspections.equals.hashcode.called.on.url.display.name='URL' 객체에서 'equals()' 또는 'hashCode()' 호출
jvm.inspections.equals.hashcode.called.on.url.problem.descriptor=URL 객체에서 ''{0}''이(가) 호출되었습니다
jvm.inspections.group.name=JVM 언어
jvm.inspections.logging.frameworks.group.name=로깅
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=제거 예정인 API도 '@Deprecated' 어노테이션으로 표시되어야 합니다.
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=제거 예정인 API에서 누락된 '@Deprecated' 어노테이션
jvm.inspections.must.already.be.removed.api.current.version.description=API가 현재 버전 {0}에서 제거되었습니다.
jvm.inspections.must.already.be.removed.api.display.name=API가 이미 제거되었습니다.
jvm.inspections.must.already.be.removed.api.earlier.version.description=API가 {0}에서 제거되었으나 현재 버전은 {1}입니다.
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}''이(가) {3}에서 제거될 예정인 {1} ''{2}''에서 선언되었습니다.
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}''은(는) {1}에서 제거될 예정입니다.
jvm.inspections.scheduled.for.removal.future.version=향후 버전
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=재정의된 메서드 ''{0}''이(가) {3}에서 제거될 예정인 {1} ''{2}''에서 선언되었습니다.
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=재정의된 메서드 ''{0}''은(는) {1}에서 제거될 예정입니다.
jvm.inspections.scheduled.for.removal.predefined.version=버전 {0}
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}''이(가) {3}에서 제거될 예정인 {1} ''{2}''을(를) 해당 시그니처에서 참조하고 있으므로 제거될 예정입니다
jvm.inspections.serializable.class.without.serialversionuid.display.name='serialVersionUID'가 없는 serializable 클래스
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>\#ref</code>이(가) 'serialVersionUID' 필드를 정의하지 않습니다 \#loc
jvm.inspections.source.to.sink.flow.assigned.unknown=알 수 없는 문자열이 안전한 변수에 대입됨
jvm.inspections.source.to.sink.flow.assigned.unsafe=안전하지 않은 문자열이 안전한 변수에 대입됨
jvm.inspections.source.to.sink.flow.common.unknown=알 수 없는 문자열이 안전한 컨텍스트에 사용됨
jvm.inspections.source.to.sink.flow.common.unsafe=안전하지 않은 문자열이 안전한 컨텍스트에 사용됨
jvm.inspections.source.to.sink.flow.display.name=안전하지 않은 문자열이 안전한 메서드로 전달됨
jvm.inspections.source.to.sink.flow.passed.unknown=알 수 없는 문자열이 안전한 매개변수로 사용됨
jvm.inspections.source.to.sink.flow.passed.unsafe=안전하지 않은 문자열이 안전한 매개변수로 사용됨
jvm.inspections.source.to.sink.flow.returned.unknown=알 수 없는 문자열이 안전한 메서드에서 반환됨
jvm.inspections.source.to.sink.flow.returned.unsafe=안전하지 않은 문자열이 안전한 메서드에서 반환됨
jvm.inspections.source.to.sink.flow.too.complex=너무 복잡해서 안전한 컨텍스트에서 문자열이 안전한지 확인할 수 없습니다
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods=private 메서드의 매개변수를 안전한 것으로 간주
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods.comment=활성화 시 private 메서드의 매개변수는 안전한 것으로 간주되며 그렇지 않은 경우는 알 수 없는 것으로 간주됩니다
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex=케이스가 확인하기에 너무 복잡한 경우 보고
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex.comment=복잡도 때문에 확인할 수 없는 객체를 보고
jvm.inspections.source.unsafe.to.sink.flow.checked.types=확인된 타입\:
jvm.inspections.source.unsafe.to.sink.flow.config=요소 ''{0}''에 대한 검사 설정에 Untainted 어노테이션이 추가됩니다
jvm.inspections.source.unsafe.to.sink.flow.depth.inside=메서드 내의 깊이 분석\:
jvm.inspections.source.unsafe.to.sink.flow.impossible=Untainted 어노테이션은 요소 ''{0}''에 대해 지원되지 않습니다. 해당 요소는 무시됩니다
jvm.inspections.source.unsafe.to.sink.flow.index.parameter=매개변수 색인
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=검증 필요로 표시
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=검증 필요로 표시
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=요소를 검증 필요로 표시
jvm.inspections.source.unsafe.to.sink.flow.not.number=숫자가 아닙니다
jvm.inspections.source.unsafe.to.sink.flow.place.class.column.title=컨텍스트의 클래스 이름
jvm.inspections.source.unsafe.to.sink.flow.place.method.column.title=컨텍스트의 메서드 이름 정규식
jvm.inspections.source.unsafe.to.sink.flow.preview='@Untainted' 어노테이션 추가
jvm.inspections.source.unsafe.to.sink.flow.preview.propagate=전달 트리 표시
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=전달 트리
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.preview=안전한 어노테이션의 전달을 확인하기 위한 도구 창을 엽니다
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=여기에 전달 트리 표시
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=제외된 것만 빼고 모두 어노테이션 추가
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=안전하지 않은 멤버
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=안전하지 않은 흐름
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.arguments=인수
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.classes=클래스
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.comment=이러한 메서드는 한정자를 'untainted'로 표시합니다(인수는 쉼표로 구분해야 합니다)
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.methods=메서드
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.table=한정자를 정리하기 위한 메서드\:
jvm.inspections.source.unsafe.to.sink.flow.safe.class=안전한 클래스\:
jvm.inspections.source.unsafe.to.sink.flow.safe.class.comment=클래스에 안전하지 않은 데이터가 없습니다
jvm.inspections.source.unsafe.to.sink.flow.show.unknown.object=알 수 없는 객체 보고
jvm.inspections.source.unsafe.to.sink.flow.show.unsafe.object=안전하지 않은 객체 보고
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations=Tainted 어노테이션\:
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations.comment=이러한 어노테이션은 분석 중에는 '@Tainted' 어노테이션으로 사용됩니다
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods=Tainted 메서드\:
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods.comment=이러한 메서드는 안전하지 않은 객체만 반환하는 것으로 간주됩니다
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters=Tainted 매개변수\:
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters.comment=이러한 매개변수는 '@Tainted' 어노테이션이 있는 것으로 간주됩니다
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations=Untainted 어노테이션\:
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations.comment=이러한 어노테이션은 분석 중에는 '@Tainted' 어노테이션으로 사용됩니다. 경로 상에 존재하면 목록의 첫 번째 어노테이션이 전달에 사용됩니다.
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields=Untainted 필드\:
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.comment=이러한 필드는 안전한 객체만 포함하는 것으로 간주됩니다
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.name=필드 이름
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods=Untainted 메서드\:
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods.comment=이러한 메서드는 안전한 객체만 반환하는 것으로 간주됩니다
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters=Untainted 매개변수\:
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters.comment=이러한 매개변수는 '@Untainted' 어노테이션이 있는 것으로 간주됩니다
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments=리시버와 인수가 untainted인 경우 외부 메서드를 untainted인 것으로 간주
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments.comment=활성화된 경우 현재 클래스 밖의 외부 클래스는 리시버와 인수가 안전하면 안전한 것으로 간주됩니다. 일부 적용되지 않는 경우가 있으나 스테이트리스 클래스에는 유용할 수 있습니다. 그렇지 않으면 모든 외부 메서드가 안전하지 않은 것으로 간주됩니다
jvm.inspections.string.touppercase.tolowercase.without.locale.description=국제화된 문자열을 사용하는 로케일을 지정하지 않은 상태에서 <code>String.{0}()</code>이(가) 호출됩니다 \#loc
jvm.inspections.system.get.property.display.name='System.getProperty(str)' 호출을 간소화할 수 있습니다
jvm.inspections.system.get.property.problem.descriptor=<code>\#ref</code> 호출을(를) ''{0}''(으) 로 단순화할 수 있습니다
jvm.inspections.test.case.in.product.source.display.name=제품 소스 내 테스트
jvm.inspections.test.case.in.product.source.problem.descriptor=테스트 케이스 <code>\#ref</code>은(는) 테스트 소스 트리에 배치해야 할 수 있습니다 \#loc
jvm.inspections.test.case.with.constructor.display.name=사소하지 않은 생성자가 있는 TestCase
jvm.inspections.test.case.with.constructor.problem.descriptor=수명 주기 메서드 'setup()'이 아닌 생성자 <code>\#ref()</code>의 초기화 논리 \#loc
jvm.inspections.test.case.with.constructor.problem.descriptor.initializer=생명주기 메서드 'setup()'이 아닌 이니셜라이저의 초기화 논리
jvm.inspections.test.case.without.test.methods.display.name=테스트가 없는 테스트 클래스
jvm.inspections.test.case.without.test.methods.option=테스트 메서드를 사용하는 상위 클래스가 있는 테스트 사례 무시
jvm.inspections.test.case.without.test.methods.problem.descriptor=테스트 클래스 <code>\#ref</code>에 테스트가 없습니다 \#loc
jvm.inspections.test.frameworks.group.name=테스트 프레임워크
jvm.inspections.test.method.in.product.source.problem.descriptor=테스트 메서드 <code>\#ref()</code>은(는) 테스트 소스 트리에 배치해야 할 수 있습니다 \#loc
jvm.inspections.test.method.without.assertion.display.name=어설션이 없는 테스트 메서드
jvm.inspections.test.method.without.assertion.problem.descriptor=테스트 메서드 <code>\#ref()</code>에 어설션이 없습니다 \#loc
jvm.inspections.testonly.class.reference=테스트 전용 클래스가 프로덕션 코드에서 참조됩니다
jvm.inspections.testonly.display.name=프로덕션 코드 내 테스트 전용 사용 위치
jvm.inspections.testonly.field.reference=테스트 전용 필드가 프로덕션 코드에서 참조됩니다
jvm.inspections.testonly.method.call=테스트 전용 메서드가 프로덕션 코드에서 호출됩니다
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting은 @TestOnly 코드에서 의미가 없습니다
jvm.inspections.thread.run.display.name='Thread.run()' 호출
jvm.inspections.unstable.api.usage.annotations.list=불안정한 API 어노테이션\:
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}''이(가) @{3}(으)로 표시된 불안정한 {1} ''{2}''에서 선언되었습니다.
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}''이(가) @{1}에서 불안정한 것으로 표시됩니다.
jvm.inspections.unstable.api.usage.display.name=불안정한 API 사용
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=이 프로젝트에서 선언된 API 무시
jvm.inspections.unstable.api.usage.ignore.inside.imports=import 문 내에서 무시
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=재정의된 메서드 ''{0}''이(가) @{3}(으)로 표시된 불안정한 {1} ''{2}''에서 선언되었습니다.
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=재정의된 메서드 ''{0}''이(가) @{1}에서 불안정한 것으로 표시됩니다.
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}''이(가) @{3}(으)로 표시된 불안정한 {1} ''{2}''을(를) 해당 시그니처에서 참조하고 있으므로 불안정합니다
jvm.inspections.unstable.type.used.in.class.signature.description=클래스가 해당 선언에서 불안정한 타입 ''{1}''을(를) 참조하고 있으므로 ''@{0}'' 어노테이션으로 표시되어야 합니다.
jvm.inspections.unstable.type.used.in.field.signature.description=필드가 불안정한 타입 ''{1}''을(를) 해당 타입에서 참조하고 있으므로 ''@{0}'' 어노테이션으로 표시되어야 합니다.
jvm.inspections.unstable.type.used.in.method.signature.description=메서드가 불안정한 타입 ''{1}''을(를) 해당 시그니처에서 참조하고 있으므로 ''@{0}'' 어노테이션으로 표시되어야 합니다
jvm.inspections.unstable.type.used.in.signature.display.name=불안정한 타입이 시그니처에서 사용됨
jvm.inspections.usages.of.obsolete.api.description=지원 중단된 API가 사용됩니다
jvm.inspections.usages.of.obsolete.api.display.name=ApiStatus.@Obsolete의 사용 위치
propagated.from=전달 이유\:
propagated.to=전달할 대상\:
remove.suppress.comment.fix.family.name=//{0} 제거
title.uast=UAST
