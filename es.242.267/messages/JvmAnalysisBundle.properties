action.find.similar.stack.call.methods.not.found=Similar classes have not been found
advanced.setting.process.console.output.to.find.class.names=Process terminal output to find class names and highlight them
allow.suppressions.fix.family.name=Allow suppressions
allow.suppressions.fix.text=Allow these suppressions
assertequals.between.inconvertible.types.display.name='assertEquals()' between objects of inconvertible types
can.t.build.uast.tree.for.file=No se pudo construir el árbol UAST para el archivo.
checkbox.comments.and.javadoc.count.as.content=Comments and javadoc count as content
current.version=Versión actual
dialog.title.choose.annotation=Seleccione {0}
group.advanced.settings.jvm=JVM languages
ignored.suppressions=Ignored suppressions:
inspection.empty.method.delete.quickfix=Delete unnecessary method(s)
inspection.empty.method.display.name=Empty method
inspection.empty.method.problem.descriptor=Method only calls its super
inspection.empty.method.problem.descriptor1=Empty method overrides empty method
inspection.empty.method.problem.descriptor2=The method is empty
inspection.empty.method.problem.descriptor3=The method and all its derivables are empty
inspection.empty.method.problem.descriptor4=All implementations of this method are empty
inspection.message.illegal.dependency.module.doesn.t.export=Illegal dependency: module ''{0}'' doesn''t export package ''{1}''
inspection.suppression.annotation.display.name=Inspection suppression annotation
inspection.suppression.annotation.problem.descriptor=Annotation suppresses {0} #loc
inspection.suppression.comment.problem.descriptor=Comment suppresses {0} #loc
jvm.class.filter.choose.calls=Similar Log Calls:
jvm.inspection.log.guarded.display.name=로그 조건으로 로그 호출에 guard가 적용됨
jvm.inspection.log.guarded.fix.family.name=로그 guard 조건 래핑 해제
jvm.inspection.log.guarded.problem.descriptor=로그 조건으로 로그 호출에 guard가 적용됨 \#loc
jvm.inspection.log.guarded.warn.if.fix.possible=수정할 수 있을 때만 경고
jvm.inspection.log.statement.not.guarded.all.levels.option=모든 로그 수준
jvm.inspection.log.statement.not.guarded.debug.level.and.lower.option=디버그 수준 이하
jvm.inspection.log.statement.not.guarded.display.name=로그 조건으로 로그 호출에 guard가 적용되지 않음
jvm.inspection.log.statement.not.guarded.info.level.and.lower.option=정보 수준 이하
jvm.inspection.log.statement.not.guarded.log.fix.family.name=로그 조건으로 둘러싸기
jvm.inspection.log.statement.not.guarded.log.problem.descriptor=로그 조건으로 로그 호출에 guard가 적용되지 않음 \#loc
jvm.inspection.log.statement.not.guarded.trace.level.option=추적 수준
jvm.inspection.log.statement.not.guarded.unguarded.constant.option=상수 메시지로 보호되지 않은 로그 호출 처리
jvm.inspection.log.statement.not.guarded.unguarded.constant.option.comment=상수가 아닌 인수가 있는 호출 뿐만 아니라 모든 보호되지 않은 로그 호출 처리
jvm.inspection.log.statement.not.guarded.warn.level.and.lower.option=경고 수준 이하
jvm.inspection.log.statement.not.guarded.warn.on.label=다음에 대해 경고\:
jvm.inspection.logging.condition.disagrees.with.log.statement.display.name=Log condition does not match logging call
jvm.inspection.logging.condition.disagrees.with.log.statement.fix.family.name=Change log level
jvm.inspection.logging.condition.disagrees.with.log.statement.fix.name=Change level of the {0, choice, 0#condition|1#call}
jvm.inspection.logging.condition.disagrees.with.log.statement.problem.descriptor=Level of condition ''{0}'' does not match level of logging call ''{1}''
jvm.inspection.logging.placeholder.count.matches.argument.count.display.name=Number of placeholders does not match number of arguments in logging call
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.descriptor=Fewer arguments provided ({0}) than placeholders specified ({1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.partial.descriptor=Fewer arguments provided ({0}) than placeholders specified (at least {1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.incorrect.problem.descriptor=Illegal format string specifier #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.more.problem.descriptor=More arguments provided ({0}) than placeholders specified ({1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option=SLF4J uses Log4j 2 as implementation
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.auto=Check automatically
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.no=No
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.yes=Yes
jvm.inspection.logging.similar.message.display.name=Non-distinguishable logging calls
jvm.inspection.logging.similar.message.problem.descriptor=Similar log messages
jvm.inspection.logging.similar.message.problem.min.similar.length=Minimum length of a similar sequence
jvm.inspection.logging.similar.message.problem.skip.on.error=Do not report calls with `error` log level
jvm.inspection.logging.string.template.as.argument.all.levels.option=all log levels
jvm.inspection.logging.string.template.as.argument.debug.level.and.lower.option=debug level and lower
jvm.inspection.logging.string.template.as.argument.display.name=String template as argument to logging call
jvm.inspection.logging.string.template.as.argument.info.level.and.lower.option=info level and lower
jvm.inspection.logging.string.template.as.argument.problem.descriptor=String template as argument to <code>#ref()</code> logging call #loc
jvm.inspection.logging.string.template.as.argument.quickfix.name=Replace with placeholders
jvm.inspection.logging.string.template.as.argument.skip.on.primitives=Do not warn when only expressions with primitive types, their wrappers or String are included
jvm.inspection.logging.string.template.as.argument.trace.level.option=trace level
jvm.inspection.logging.string.template.as.argument.warn.level.and.lower.option=warn level and lower
jvm.inspection.logging.string.template.as.argument.warn.on.label=Warn on:
jvm.inspection.test.failed.line.display.name=Failed line in test
jvm.inspections.1.5.problem.descriptor=Usage of API documented as @since {0}+
jvm.inspections.1.7.problem.descriptor=Usage of generified after 1.6 API which would cause compilation problems with JDK {0}
jvm.inspections.1.8.problem.descriptor=Default {0, choice, 0#|1#method is|2# methods are} not overridden. It would cause compilation problems with JDK {1}
jvm.inspections.1.8.problem.single.descriptor=Default method ''{0}'' is not overridden. It would cause compilation problems with JDK {1}
jvm.inspections.api.display.name=Usages of API which isn't available at the configured language level
jvm.inspections.api.no.extension.class.description=La clase ''{0}'' no debe extenderse.
jvm.inspections.api.no.extension.display.name=La clase, la interfaz o el método no deben extenderse
jvm.inspections.api.no.extension.interface.extend.description=La interfaz ''{0}'' no debe extenderse.
jvm.inspections.api.no.extension.interface.implement.description=La interfaz ''{0}'' no debe implementarse.
jvm.inspections.api.no.extension.method.overriding.description=El método ''{0}'' no debe anularse.
jvm.inspections.api.override.only.description=El método ''{0}'' solo se puede anular.
jvm.inspections.api.override.only.display.name=Los métodos solo se pueden anular
jvm.inspections.assertequals.between.inconvertible.types.problem.descriptor=<code>#ref()</code> between objects of inconvertible types ''{0}'' and ''{1}'' #loc
jvm.inspections.assertnotequals.between.inconvertible.types.problem.descriptor=Possibly redundant assertion: incompatible types are compared ''{0}'' and ''{1}''
jvm.inspections.assertnotsame.between.inconvertible.types.problem.descriptor=Redundant assertion: incompatible types are compared ''{0}'' and ''{1}''
jvm.inspections.blocking.method.annotation.blocking=Bloqueo de anotaciones
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=Agregar anotación de bloqueo
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=Add Non-Blocking Annotation
jvm.inspections.blocking.method.annotation.non-blocking=Non-blocking annotations:
jvm.inspections.blocking.method.consider.suspend.context.non.blocking=Consider Kotlin suspend context non-blocking
jvm.inspections.blocking.method.consider.unknown.context.blocking=Consider unknown contexts blocking
jvm.inspections.blocking.method.consider.unknown.context.nonblocking=Consider unknown contexts non-blocking
jvm.inspections.blocking.method.display.name=Llamada al método de bloqueo de subprocesos no válida
jvm.inspections.blocking.method.in.implicit.ctr.problem.descriptor=Possibly blocking call from implicit constructor call in non-blocking context could lead to thread starvation
jvm.inspections.blocking.method.in.implicit.ctr.problem.wildcard.descriptor=Possibly blocking call from implict constructor call in {0} could lead to thread starvation
jvm.inspections.blocking.method.intention.text=Enables the inspection option ''{0}''.
jvm.inspections.blocking.method.problem.descriptor=Llamada al método de bloqueo no válida.
jvm.inspections.blocking.method.problem.wildcard.descriptor=Possibly blocking call in {0} could lead to thread starvation
jvm.inspections.collection.contains.url.problem.descriptor=''{0}'' may contain URL objects #loc
jvm.inspections.dependency.display.name=Illegal package dependencies
jvm.inspections.dependency.edit.rules.family=Edit dependency rules
jvm.inspections.dependency.edit.rules.text=Edit dependency rule \"{0} \"
jvm.inspections.dependency.intention.description=Opens a dialog to configure dependency rules between scopes.
jvm.inspections.dependency.on.internal.display.name=Illegal dependency on internal package
jvm.inspections.dependency.violator.problem.descriptor=Dependency rule ''{0}.'' is violated
jvm.inspections.equals.hashcode.called.on.url.display.name=Call to 'equals()' or 'hashCode()' on 'URL' object
jvm.inspections.equals.hashcode.called.on.url.problem.descriptor=Call to ''{0}'' on URL object
jvm.inspections.group.name=Lenguaje JVM
jvm.inspections.logging.frameworks.group.name=Logging
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=Las API que se eliminarán también deben estar marcadas con la anotación '' @Deprecated ''.
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=Falta la anotación '' @Deprecated '' en la API que se eliminará
jvm.inspections.must.already.be.removed.api.current.version.description=La API se ha eliminado de la versión actual {0}.
jvm.inspections.must.already.be.removed.api.display.name=La API ya ha sido eliminada.
jvm.inspections.must.already.be.removed.api.earlier.version.description=La API se ha eliminado de {0} pero la versión actual es {1}.
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' está programado para ser eliminado de {3} ''{2}'' ha sido declarado en
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' está a punto de eliminarse de {1}.
jvm.inspections.scheduled.for.removal.future.version=Versiones futuras
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=El método reemplazado ''{0}'' programado para ser eliminado de {3} {1} ''{2}'' fue declarado.
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=El método anulado ''{0}'' está a punto de ser eliminado de {1}.
jvm.inspections.scheduled.for.removal.predefined.version=versión {0}
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' se eliminará de {3} {1 } ''{2}'' se hace referencia en su firma y se eliminará
jvm.inspections.serializable.class.without.serialversionuid.display.name=Serializable class without 'serialVersionUID'
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code> does not define a 'serialVersionUID' field #loc
jvm.inspections.source.to.sink.flow.assigned.unknown=Unknown string is assigned to safe variable
jvm.inspections.source.to.sink.flow.assigned.unsafe=Unsafe string is assigned to safe variable
jvm.inspections.source.to.sink.flow.common.unknown=Unknown string is used in a safe context
jvm.inspections.source.to.sink.flow.common.unsafe=Unsafe string is used in a safe context
jvm.inspections.source.to.sink.flow.display.name=Non-safe string is passed to safe method
jvm.inspections.source.to.sink.flow.passed.unknown=Unknown string is used as safe parameter
jvm.inspections.source.to.sink.flow.passed.unsafe=Unsafe string is used as safe parameter
jvm.inspections.source.to.sink.flow.returned.unknown=Unknown string is returned from safe method
jvm.inspections.source.to.sink.flow.returned.unsafe=Unsafe string is returned from safe method
jvm.inspections.source.to.sink.flow.too.complex=Too complex to check that the string is safe in a safe context
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods=Consider parameters of private methods as safe
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods.comment=If it is enabled, then parameters of private methods are considered as safe, otherwise they will be considered as unknown
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex=Report if the case is too complex to check
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex.comment=Report objects, which cannot be checked because of their complexity
jvm.inspections.source.unsafe.to.sink.flow.checked.types=Checked types:
jvm.inspections.source.unsafe.to.sink.flow.config=Untainted annotation will be added to the inspection''s setting for element ''{0}''
jvm.inspections.source.unsafe.to.sink.flow.depth.inside=Analysis Depth inside the method:
jvm.inspections.source.unsafe.to.sink.flow.impossible=Untainted annotation is not supported for element ''{0}''. The element will be skipped
jvm.inspections.source.unsafe.to.sink.flow.index.parameter=Parameter Index
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=Mark as Requiring Validation
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=Mark as requiring validation
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=Mark elements as requiring validation
jvm.inspections.source.unsafe.to.sink.flow.not.number=Not a number
jvm.inspections.source.unsafe.to.sink.flow.place.class.column.title=Class Name Of Context
jvm.inspections.source.unsafe.to.sink.flow.place.method.column.title=Method Name Regex Of Context
jvm.inspections.source.unsafe.to.sink.flow.preview=Add '@Untainted' annotation
jvm.inspections.source.unsafe.to.sink.flow.preview.propagate=Show propagation tree
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=Propagation tree
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.preview=Opens a tool window to check the propagation of the safe annotation
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=Show propagation tree from here
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=Annotate All except Excluded
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=Unsafe Members
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=Unsafe flow
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.arguments=Arguments
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.classes=Classes
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.comment=These methods mark qualifiers as 'untainted' (Arguments must be split by comma)
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.methods=Methods
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.table=Methods to clean qualifiers:
jvm.inspections.source.unsafe.to.sink.flow.safe.class=Safe classes:
jvm.inspections.source.unsafe.to.sink.flow.safe.class.comment=These classes can't contain unsafe data
jvm.inspections.source.unsafe.to.sink.flow.show.unknown.object=Report unknown object
jvm.inspections.source.unsafe.to.sink.flow.show.unsafe.object=Report unsafe object
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations=Tainted annotations:
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations.comment=These annotations will be used as '@Tainted' annotations during the analysis
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods=Tainted methods:
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods.comment=These methods are considered to return only non-safe objects
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters=Tainted parameters:
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters.comment=These parameters are considered to have '@Tainted' annotation
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations=Untainted annotations:
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations.comment=These annotations will be used as '@Untainted' annotations during the analysis. The first annotation from this list will be used for propagation if it exists in the classpath.
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields=Untainted fields:
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.comment=These fields are considered to contain only safe objects
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.name=Field Name
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods=Untainted methods:
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods.comment=These methods are considered to return only safe objects
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters=Untainted parameters:
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters.comment=These parameters are considered to have '@Untainted' annotation
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments=Consider external methods untainted if receivers and arguments are untainted
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments.comment=If it is enabled, then external methods outside the current class will be considered as safe if their receivers and arguments are safe. In some cases, it is not applicable, but it can be useful for stateless classes. Otherwise, all external methods will be considered as unsafe
jvm.inspections.string.touppercase.tolowercase.without.locale.description=<code> String. Se llama a {0} ()</code> sin especificar una configuración regional que utilice una cadena internacionalizada.\#loc
jvm.inspections.system.get.property.display.name=Call to 'System.getProperty(str)' could be simplified
jvm.inspections.system.get.property.problem.descriptor=Call <code>#ref</code> can be simplified for ''{0}''
jvm.inspections.test.case.in.product.source.display.name=Test in product source
jvm.inspections.test.case.in.product.source.problem.descriptor=Test case <code>#ref</code> should probably be placed in a test source tree #loc
jvm.inspections.test.case.with.constructor.display.name=TestCase with non-trivial constructors
jvm.inspections.test.case.with.constructor.problem.descriptor=Initialization logic in constructor <code>#ref()</code> instead of 'setup()' life cycle method #loc
jvm.inspections.test.case.with.constructor.problem.descriptor.initializer=Initialization logic in initializer instead of 'setup()' life cycle method
jvm.inspections.test.case.without.test.methods.display.name=Test class without tests
jvm.inspections.test.case.without.test.methods.option=Ignore test cases which have superclasses with test methods
jvm.inspections.test.case.without.test.methods.problem.descriptor=Test class <code>#ref</code> has no tests #loc
jvm.inspections.test.frameworks.group.name=Test frameworks
jvm.inspections.test.method.in.product.source.problem.descriptor=Test method <code>#ref()</code> should probably be placed in a test source tree #loc
jvm.inspections.test.method.without.assertion.display.name=Test method without assertions
jvm.inspections.test.method.without.assertion.problem.descriptor=Test method <code>#ref()</code> contains no assertions #loc
jvm.inspections.testonly.class.reference=Test-only class is referenced in production code
jvm.inspections.testonly.display.name=Test-only usage in production code
jvm.inspections.testonly.field.reference=Test-only field is referenced in production code
jvm.inspections.testonly.method.call=Test-only method is called in production code
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting makes little sense on @TestOnly code
jvm.inspections.thread.run.display.name=Call to 'Thread.run()'
jvm.inspections.unstable.api.usage.annotations.list=Anotaciones API inestables
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}'' is declared in unstable {1} ''{2}'' marked with @{3}
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' está marcado como inestable en @ {1}.
jvm.inspections.unstable.api.usage.display.name=Usando API inestable
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=Ignore API declared in this project
jvm.inspections.unstable.api.usage.ignore.inside.imports=ignorar dentro de la declaración de importación
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=Método anulado ''{0}'' marcado como inestable {1 como @ {3}} Declarado en '' {2 } ''.
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=El método anulado ''{0}'' está marcado como inestable en @ {1}.
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' marcado como @ {3} inestable {1} ''{2}'' se hace referencia por su firma y, por lo tanto, es inestable
jvm.inspections.unstable.type.used.in.class.signature.description=Anotado ''@{0} '' porque la clase hace referencia al tipo inestable ''{1}'' en su declaración, debería ser
jvm.inspections.unstable.type.used.in.field.signature.description=El campo está anotado con ''@{0} '' porque hace referencia al tipo inestable ''{1}'' debería ser
jvm.inspections.unstable.type.used.in.method.signature.description=Anotado ''@{0} '' porque el método hace referencia al tipo inestable ''{1}'' en su firma debe ser
jvm.inspections.unstable.type.used.in.signature.display.name=Tipo inestable utilizado en la firma
jvm.inspections.usages.of.obsolete.api.description=Obsolete API is used
jvm.inspections.usages.of.obsolete.api.display.name=Usages of ApiStatus.@Obsolete
propagated.from=Reason of Propagation:
propagated.to=Target to Propagate:
remove.suppress.comment.fix.family.name=Remove //{0}
title.uast=UAST
