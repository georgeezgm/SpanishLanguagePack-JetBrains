ACT.CMD.use.import=Usar módulos importados
ACT.from.some.module.import=Consíguelo de…
ACT.qualify.with.module=Verificar módulos importados
ANN.assign.to.none=Asignación a Ninguno
ANN.assignment.expression.as.a.target=Las expresiones de asignación no se pueden utilizar como objetivos aquí
ANN.assignment.expression.in.an.iterable=Las expresiones de asignación no se pueden utilizar en iterables de comprensión.
ANN.assignment.expressions.within.a.comprehension.cannot.be.used.in.a.class.body=Las expresiones de tareas en comprensión no se pueden usar en el cuerpo de la clase.
ANN.assignment.to.keyword=Sustituir por palabra clave
ANN.await.outside.async.function='esperar' fuera de la función asíncrona
ANN.break.outside.loop='break' fuera del bucle
ANN.can.t.use.starred.expression.here=No puedes usar expresiones de asterisco aquí.
ANN.cannot.assign.to.debug=No se puede asignar a __debug__
ANN.cant.assign.to.call=No se puede asignar a la llamada de función
ANN.cant.assign.to.comprh=No se puede asignar a la comprensión de la lista
ANN.cant.assign.to.dict.comprh=No se puede asignar a la comprensión de dict
ANN.cant.assign.to.generator=Asignar a la expresión del generador no es posible
ANN.cant.assign.to.lambda=No se puede asignar a lambda
ANN.cant.assign.to.literal=No se puede asignar a literal
ANN.cant.assign.to.operator=No se puede asignar al operador
ANN.cant.assign.to.parens=No se puede asignar a()
ANN.cant.assign.to.set.comprh=No se puede asignar para establecer la comprensión
ANN.cant.aug.assign.starred.assignment.target.must.be.in.list.or.tuple=Los objetivos de asignación con un asterisco deben estar en una lista o tupla
ANN.cant.aug.assign.to.comprh=Asignación aumentada a la comprensión de la lista no es posible
ANN.cant.aug.assign.to.dict.comprh=Asignación aumentada a comprensión de dictado no es posible
ANN.cant.aug.assign.to.generator=No es posible la asignación aumentada a la expresión del generador
ANN.cant.aug.assign.to.list.or.comprh=Asignación aumentada a literal de lista o no es posible la comprensión
ANN.cant.aug.assign.to.set.comprh=No es posible la asignación aumentada para establecer la comprensión
ANN.cant.aug.assign.to.tuple.or.generator=Asignación aumentada a literal de tupla o expresión generadora no posible
ANN.cant.delete.call=No se puede eliminar la llamada a la función
ANN.cant.delete.literal=No se puede eliminar literal
ANN.continue.break.or.return.in.star.except='break', 'continue' y 'return' no se pueden usar en bloques excepto*.
ANN.continue.outside.loop='continue' fuera del bucle
ANN.default.except.must.be.last=El valor predeterminado 'except\:' debe ir al final
ANN.deleting.none=Eliminando ninguno
ANN.duplicate.param.name=nombre de parámetro duplicado
ANN.exception.group.in.star.except=ExceptionGroup no se puede utilizar con excepto*.
ANN.fstrings.illegal.conversion.character=''{0}'' es un carácter de conversión no válido. Debe ser uno de "s", "r" o "a".
ANN.fstrings.missing.conversion.character=Se requieren caracteres de conversión. Debe ser uno de "s", "r" o "a"
ANN.fstrings.single.right.brace.not.allowed.inside.fstrings=El sencillo '}' no está permitido dentro de f-string
ANN.generator.expression.must.be.parenthesized.if.not.sole.argument=Si hay más de un argumento, la expresión generadora debe estar entre paréntesis.
ANN.ignore.errors.like.this=Ignora errores como este
ANN.illegal.target.for.variable.annotation=Objetivo incorrecto para la anotación variable
ANN.missing.closing.quote=Falta la cita de cierre [{0}]
ANN.missing.closing.triple.quotes=Falta la triple cotización de cierre
ANN.multiple.args=varios * parámetros no están permitidos
ANN.multiple.kwargs=múltiples ** parámetros no están permitidos
ANN.multiple.slash=no se permiten varios/parámetros
ANN.name.used.both.as.global.and.param=El nombre ''{0}'' se utiliza como parámetro y como parámetro global.
ANN.named.parameters.after.star=los parámetros con nombre deben seguir al desnudo *
ANN.named.parameters.before.slash=los parámetros con nombre deben preceder a bare /
ANN.no.exception.to.reraise=No hay excepciones para volver a lanzar
ANN.non.default.param.after.default=el parámetro no predeterminado sigue al parámetro predeterminado
ANN.non.empty.return.inside.asynchronous.generator='Retorno' no vacío en generador asíncrono
ANN.patterns.attribute.name.is.repeated=El nombre de propiedad ''{0}'' se repite
ANN.patterns.double.star.pattern.cannot.be.used.outside.mapping.patterns=El patrón de 2 estrellas no se puede utilizar fuera de un patrón de mapeo
ANN.patterns.invalid.complex.number.literal=Literal de número compuesto no válido
ANN.patterns.key.pattern.can.only.be.value.or.literal.pattern=Los patrones clave solo pueden ser patrones de valores o patrones literales
ANN.patterns.name.already.bound=El nombre ''{0}'' ya está vinculado
ANN.patterns.pattern.does.not.bind.names=El patrón no vincula {0,choice,1\#name|2\#name} {1}
ANN.patterns.pattern.makes.remaining.alternatives.unreachable=Las alternativas restantes no se pueden alcanzar debido al patrón.
ANN.patterns.pattern.makes.remaining.case.clauses.unreachable=El resto de la cláusula del caso es inalcanzable debido al patrón
ANN.patterns.repeated.star.pattern=patrón de estrella repetido
ANN.patterns.single.star.pattern.cannot.be.used.outside.sequence.patterns=Los patrones de 1 estrella no se pueden utilizar fuera de los patrones de secuencia
ANN.python.does.not.support.yield.from.inside.async.functions=Python no admite 'rendimiento desde' dentro de funciones asíncronas
ANN.regular.param.after.keyword=parámetro regular después de ** parámetro
ANN.regular.param.after.vararg=parámetro regular después de * parámetro
ANN.return.outside.of.function='regresar' fuera de la función
ANN.slash.param.after.keyword=/ parámetro debe preceder ** parámetro
ANN.slash.param.after.vararg=/ parámetro debe preceder * parámetro
ANN.star.import.at.top.only='importar *' solo está permitido a nivel de módulo
ANN.starred.param.after.kwparam=* parámetro después de ** parámetro
ANN.try.except.can.not.have.except.and.star.except=Una declaración Try no puede contener excepto y excepto*.
ANN.tuple.py3=el desempaquetado del parámetro tuple no es compatible con Python 3
ANN.unparenthesized.assignment.expression.statement=En el nivel más alto de la sintaxis de expresión, están prohibidas las expresiones de asignación que no estén entre paréntesis.
ANN.unparenthesized.assignment.expression.value=En el nivel superior a la derecha de la declaración de asignación, están prohibidas las expresiones de asignación que no estén entre paréntesis.
ANN.variable.annotation.cannot.be.combined.with.tuple.unpacking=Las anotaciones variables no se pueden combinar con el desempaquetado de tuplas.
ANN.variable.annotation.cannot.be.used.in.assignment.with.multiple.targets=Las anotaciones variables no se pueden utilizar para la asignación de múltiples objetivos
ANN.yield.outside.of.function='rendimiento' fuera de la función
INSP.GROUP.python=Python
INSP.NAME.abstract.class=Una clase debe implementar todos los métodos abstractos.
INSP.NAME.argument.equal.default=El argumento de la función es el mismo que el valor del parámetro predeterminado.
INSP.NAME.assignment.to.loop.or.with.parameter=Asignación a parámetros de declaración 'for' o 'with'
INSP.NAME.attribute.outside.init=Propiedad de instancia definida fuera de '__init__'
INSP.NAME.augment.assignment=Podemos cambiar la tarea a una tarea incremental.
INSP.NAME.bad.except.clauses.order=Orden incorrecto de las cláusulas 'excepto'
INSP.NAME.byte.literal=El byte literal contiene caracteres no ASCII
INSP.NAME.calling.non.callable=Intentar llamar a un objeto que no se puede llamar
INSP.NAME.chained.comparisons=Comparaciones demasiado complicadas
INSP.NAME.check.can.be.simplified=Comprobando variables bool innecesarias
INSP.NAME.class.has.no.init=Falta el método '__init__' en la clase
INSP.NAME.class.var.variables=Uso no válido de la variable ClassVar
INSP.NAME.classic.class.usage=Dónde utilizar las clases de estilo clásico.
INSP.NAME.comparison.with.none=Utilice el operador de igualdad para comparar con Ninguno
INSP.NAME.compatibility=Código no compatible con una versión específica de Python
INSP.NAME.coroutine.is.not.awaited=La rutina ''{0}'' no está esperando
INSP.NAME.dataclass.definition.and.usages=Definición y uso incorrectos de clases de datos.
INSP.NAME.decorator.outside.class=Decorador específico de clase usado fuera de la clase
INSP.NAME.default.argument=Los argumentos predeterminados se pueden cambiar.
INSP.NAME.deprecated.function.class.or.module=Una función, clase o módulo que pronto dejará de estar disponible.
INSP.NAME.dict.creation=La creación de un diccionario se puede reescribir como un literal de diccionario
INSP.NAME.docstring.types=El tipo de cadena de documentación no coincide con el tipo inferido
INSP.NAME.dunder.slots=Uso no válido de una clase que contiene la definición '__slots__'
INSP.NAME.duplicate.keys=El diccionario contiene claves duplicadas
INSP.NAME.exception.not.inherit=La excepción no hereda la clase estándar 'Excepción'
INSP.NAME.final.classes.methods.and.variables=Uso incorrecto de clases, métodos y variables finales.
INSP.NAME.first.arg.assign=Se reasigna el primer argumento del método.
INSP.NAME.from.future.import=desde __futuro__ importación en ubicación incorrecta
INSP.NAME.global.undefined=La variable global no está definida a nivel de módulo
INSP.NAME.inconsistent.indentation=Sangría inconsistente
INSP.NAME.incorrect.call.arguments=Argumentos de llamada no válidos
INSP.NAME.incorrect.docstring=Cadena de documentación no válida
INSP.NAME.init.return=Método __init__ que devuelve un valor
INSP.NAME.invalid.interpreter=mal intérprete
INSP.NAME.invalid.usages.of.override.decorator=Uso incorrecto del decorador @override
INSP.NAME.list.creation=Declaración de lista no optimizada
INSP.NAME.mandatory.encoding=No se ha especificado ninguna codificación para el archivo
INSP.NAME.method.may.be.static=Método no declarado estático
INSP.NAME.method.over=La firma del método no coincide con la firma del método anulado
INSP.NAME.missing.or.empty.docstring=Cadena de documentación faltante o vacía
INSP.NAME.missing.super.constructor=Falta una llamada a '__init__' en la clase principal
INSP.NAME.missing.type.hints=Falta sugerencia de tipo para la definición de función
INSP.NAME.nested.decorators=Anidamiento problemático de decoradores.
INSP.NAME.new.init.signature=Firmas __new__ y __init__ incompatibles
INSP.NAME.new.style.generics.type.param.syntax=Uso no válido de parámetros de tipo y alias de tipo en tipos nuevos
INSP.NAME.non.ascii=El archivo contiene caracteres que no son ASCII.
INSP.NAME.none.function.assignment=Asignar una llamada de función que no devuelve nada
INSP.NAME.oldstyle.class=Las clases de estilo antiguo ahora contienen características de clase de estilo nuevo
INSP.NAME.overloads.in.regular.python.files=Sobrecarga de archivos Python simples
INSP.NAME.pep8.naming=Violación de la convención de nomenclatura PEP 8
INSP.NAME.problematic.first.parameter=Primer parámetro inadecuado
INSP.NAME.property.access=Acceso incorrecto a la propiedad
INSP.NAME.property.definition=Definición de propiedad no válida
INSP.NAME.protected.member=Acceso a miembros protegidos de una clase o módulo.
INSP.NAME.protocol.definition.and.usages=Definición y uso incorrectos del protocolo
INSP.NAME.pytest-parametrized=Argumento no válido en @pytest.mark.parametrize
INSP.NAME.pytest.unpassed.fixture=La función de prueba no solicita fijación
INSP.NAME.redeclaration=Nombre no utilizado y redeclarado
INSP.NAME.redundant.parentheses=paréntesis innecesarios
INSP.NAME.relative.import=Declaración de importación relativa sospechosa
INSP.NAME.requirements=Requisitos de paquete no cumplidos
INSP.NAME.set.function.to.literal=Puede reemplazar las llamadas a funciones con literales establecidos
INSP.NAME.shadowing.builtins=Ocultar nombres integrados
INSP.NAME.single.quoted.docstring=cadena de documentación de comillas simples
INSP.NAME.statement.effect=La declaración no tiene efecto.
INSP.NAME.str.format=Error de tarea de formato de cadena
INSP.NAME.too.broad.exception.clauses=cláusula de excepción poco clara
INSP.NAME.trailing.semicolon=Puntos y coma al final prohibidos en la sintaxis
INSP.NAME.tuple.assignment.balance=El saldo de asignación de tupla es incorrecto
INSP.NAME.tuple.item.assignment=Prohibida la asignación de elementos de tupla
INSP.NAME.type.checker=Tipo incorrecto
INSP.NAME.type.hints=Definición y uso de sugerencias de tipo incorrecto
INSP.NAME.typed.dict=Definición y uso incorrectos de TypedDict
INSP.NAME.unbound=variable local independiente
INSP.NAME.unnecessary.backslash=barra invertida innecesaria
INSP.NAME.unreachable.code=código inalcanzable
INSP.NAME.unresolved.refs=referencias no resueltas
INSP.NAME.unused=Símbolos locales no utilizados
INSP.NAME.wrong.super.arguments=Argumento de superllamada no válido
INSP.abstract.class.add.to.superclasses=Agregue ''{0}'' a la clase principal
INSP.abstract.class.class.must.implement.all.abstract.methods=La clase {0} debe implementar todos los métodos abstractos
INSP.abstract.class.set.as.metaclass=Establecer ''{0}'' como metaclase
INSP.argument.equals.to.default=El argumento es igual al valor del parámetro predeterminado
INSP.arguments.not.declared.but.provided.by.decorator=Los siguientes argumentos no se declaran pero los proporciona el decorador: {0}
INSP.assignment.can.be.replaced.with.augmented.assignment=Podemos cambiar la tarea a una tarea incremental.
INSP.assignment.to.loop.or.with.parameter=La variable ''{0}'' ya se ha declarado en el bucle ''for'' o en la declaración ''with'' anterior
INSP.async.call=Falta la declaración 'espera' en la llamada de rutina
INSP.attribute.outside.init=Propiedad de instancia {0} definida fuera de __init__
INSP.auto.to.manual.field.numbering=No se puede cambiar de la notación automática de números de campo a la especificación de campo manual
INSP.bad.except.exception.class.already.caught=La clase de excepción ''{0}'' ya ha sido detectada
INSP.bad.except.superclass.of.exception.class.already.caught=''{0}'',superclass of exception class ''{1}'',has already been caught
INSP.byte.literal.contains.illegal.characters=El byte literal contiene más de 255 caracteres.
INSP.cant.return.value.from.init=__init__ no puede devolver un valor
INSP.chained.comparisons.ignore.statements.with.constant.in.the.middle=Ignorar la sintaxis con constantes en el medio
INSP.class.has.no.init=La clase no tiene método __init__
INSP.class.is.not.subtype.of.class=''{0}'' no es una instancia o subclase de ''{1}''
INSP.class.object.is.not.callable=No se puede llamar al objeto ''{0}''
INSP.class.var.can.be.used.only.in.class.body='ClassVar' solo se puede utilizar para asignaciones en el cuerpo de una clase.
INSP.class.var.can.not.be.assigned.to.instance=No se puede asignar a la variable de clase ''{0}'' mediante la instancia.
INSP.class.var.can.not.be.used.in.annotation.for.function.return.value='ClassVar' no se puede utilizar en anotaciones sobre valores de retorno de funciones.
INSP.class.var.can.not.be.used.in.annotations.for.function.parameters='ClassVar' no se puede utilizar en anotaciones para parámetros de funciones.
INSP.class.var.can.not.be.used.in.function.body='ClassVar' no se puede utilizar en anotaciones para variables locales.
INSP.class.var.can.not.include.type.variables=El parámetro 'ClassVar' no puede contener variables de tipo
INSP.class.var.can.not.override.class.variable=La variable de clase ''{0}'' (previamente declarada en la clase base ''{1}'') no se puede redefinir como una variable de instancia.
INSP.class.var.can.not.override.instance.variable=La variable de instancia ''{0}'' (previamente declarada en la clase base ''{1}'') no se puede redefinir como una variable de clase.
INSP.classic.class.usage.old.style.class=clases de estilo antiguo
INSP.classic.class.usage.old.style.class.ancestors=Old-style class,because all classes from whom it inherits are old-style
INSP.comparison.with.none.performed.with.equality.operators=Comparación con Ninguno realizada con el operador de igualdad
INSP.compatibility.basestring.type.not.available.in.py3=El tipo de cadena base no está disponible en Python3.
INSP.compatibility.check.for.compatibility.with.python.versions=Verifique la compatibilidad con su versión de Python:
INSP.compatibility.feature.allow.async.and.await.as.names='async' y 'await' no están permitidos como nombres
INSP.compatibility.feature.allow.backslashes.in.f-strings=Permitir barras invertidas dentro de expresiones en cadenas f
INSP.compatibility.feature.allow.deep.expression.nesting.in.f-strings=Permitir expresiones anidadas dentro de especificadores de formato de esta profundidad
INSP.compatibility.feature.allow.duplicate.kwargs=**No se permiten expresiones duplicadas
INSP.compatibility.feature.allow.duplicate.positional.varargs=**No se permiten expresiones duplicadas
INSP.compatibility.feature.allow.keyword.arguments.after.kwargs=**No hay argumentos de palabras clave después de la expresión.
INSP.compatibility.feature.allow.new.lines.in.f-strings=Permitir nuevas líneas en la parte de expresión de una cadena f entre comillas triples
INSP.compatibility.feature.allow.positional.arguments.after.expression=*No se permiten argumentos posicionales después de la expresión.
INSP.compatibility.feature.allow.quote.reuse.in.f-strings=f Permite anidar literales de cadena usando el mismo tipo de comillas dentro de una cadena.
INSP.compatibility.feature.allow.to.mix.bytes.and.non.bytes.literals=No se permite la mezcla de literales de bytes y literales que no son de bytes.
INSP.compatibility.feature.allow.trailing.comma.after.kwargs=**No hay coma al final después de la palabra clave después de la expresión
INSP.compatibility.feature.allow.trailing.comma.after.positional.vararg=*No se permiten comas finales después de la expresión.
INSP.compatibility.feature.have.method=No contiene el método {0}
INSP.compatibility.feature.have.module=No contiene el módulo {0}
INSP.compatibility.feature.have.module.builtin=No incluye módulo __builtin__
INSP.compatibility.feature.have.module.builtins=No incluye módulos incorporados
INSP.compatibility.feature.have.nonlocal.keyword=No contiene palabras clave no locales
INSP.compatibility.feature.have.type.long=No contiene tipo largo. Utilice int en su lugar.
INSP.compatibility.feature.line.comments.in.f-strings=Permitir comentarios dentro de expresiones en cadena f
INSP.compatibility.feature.support.arbitrary.expressions.as.decorator=No se admiten expresiones arbitrarias como decoradores.
INSP.compatibility.feature.support.assignment.expressions=No admite expresiones de asignación
INSP.compatibility.feature.support.backquotes=No se admiten comillas invertidas. Utilice repr() en su lugar
INSP.compatibility.feature.support.continue.inside.finally.clause='Continuar' dentro de la cláusula 'finalmente' no es compatible
INSP.compatibility.feature.support.diamond.operator=<> no es compatible. Utilice \!\= en su lugar
INSP.compatibility.feature.support.ellipsis.outside.slices='...' no se admite el corte de secuencia externa
INSP.compatibility.feature.support.long.integer.literal.suffix=No se admite el final de ''{0}''
INSP.compatibility.feature.support.match.statements=Compatibilidad con sintaxis de coincidencia
INSP.compatibility.feature.support.matrix.multiplication.operators=El operador de multiplicación de matrices no es compatible
INSP.compatibility.feature.support.old.style.octal.literals=Esta sintaxis no es compatible. Para literales octales, se requiere el prefijo '0o'.
INSP.compatibility.feature.support.parenthesized.context.expressions=Soporte para expresiones de contexto entre paréntesis
INSP.compatibility.feature.support.positional.only.parameters=No se admiten parámetros solo posicionales
INSP.compatibility.feature.support.print.statement=Esta sintaxis no es compatible. La declaración de impresión ha sido reemplazada por la función print()
INSP.compatibility.feature.support.raise.with.no.arguments.outside.except.block=Esta sintaxis no es compatible. Las ocurrencias sin argumentos solo se pueden usar en bloques excepto
INSP.compatibility.feature.support.starred.except.part=excepto* soporte parcial
INSP.compatibility.feature.support.starred.expressions.as.assignment.targets=Las expresiones con asteriscos no se admiten como objetivos de asignación
INSP.compatibility.feature.support.starred.expressions.in.dicts=Los diccionarios no admiten expresiones con asteriscos
INSP.compatibility.feature.support.starred.expressions.in.subscriptions=Las suscripciones admiten expresiones destacadas.
INSP.compatibility.feature.support.starred.expressions.in.tuples.lists.and.sets=Las expresiones con asteriscos no se admiten en tuplas, listas y conjuntos
INSP.compatibility.feature.support.starred.expressions.in.type.annotations=Admite expresiones destacadas en anotaciones tipográficas.
INSP.compatibility.feature.support.string.literal.prefix=El prefijo ''{0}'' no es compatible
INSP.compatibility.feature.support.super.without.arguments=Esta sintaxis no es compatible. En Python 2, super() debe tomar argumentos
INSP.compatibility.feature.support.this.syntax=Esta sintaxis no es compatible
INSP.compatibility.feature.support.this.syntax.in.list.comprehensions=La comprensión de listas no admite esta sintaxis
INSP.compatibility.feature.support.type.alias.statements=Compatibilidad con la sintaxis de alias de tipo
INSP.compatibility.feature.support.underscores.in.numeric.literals=Los guiones bajos no se admiten en literales numéricos
INSP.compatibility.feature.support.unpacking.without.parentheses.in.return.statements=La declaración de devolución no admite el desembalaje sin paréntesis
INSP.compatibility.feature.support.unpacking.without.parentheses.in.yield.statements=La declaración de rendimiento no admite el desembalaje sin paréntesis
INSP.compatibility.feature.support.variable.annotations=No admite anotaciones variables.
INSP.compatibility.feature.support.yield.from=Esta sintaxis no es compatible. La delegación a subgeneradores está disponible en Python 3.3 y versiones posteriores. En su lugar, utilice iteración explícita para subgeneradores.
INSP.compatibility.inspection.unsupported.feature.prefix=Python {0,choice,1\#version|2\#version} {1} es {2}{0,choice,1\#|2\#}
INSP.compatibility.keyword.argument.repeated=Los argumentos de las palabras clave se repiten.
INSP.compatibility.new.union.syntax.not.available.in.earlier.version=tipo de unión Permitir escribir Y
INSP.compatibility.old.dict.methods.not.available.in.py3=Los métodos dict.iterkeys(), dict.iteritems(), dict.itervalues() no están disponibles en Python 3
INSP.compatibility.positional.argument.after.keyword.argument=Argumentos posicionales después de argumentos de palabras clave
INSP.compatibility.positional.argument.after.kwargs=**Argumento posicional de palabra clave después de la expresión
INSP.compatibility.pre35.versions.do.not.allow.return.with.argument.inside.generator=Las versiones de Python inferiores a 3.3 no permiten 'retornar' con argumentos dentro de un generador
INSP.compatibility.support.equality.signs.in.fstrings=Los símbolos de igualdad no son compatibles con f-string
INSP.compatibility.this.syntax.available.only.since.py3=Esta sintaxis sólo está disponible en Python 3 y versiones posteriores.
INSP.dataclasses.argument.ignored.if.class.already.defines.method=Si la clase ya define el método ''{1}'', ''{0}'' será ignorado
INSP.dataclasses.attribute.default.set.using.method=El valor predeterminado se establece usando ''{0}''
INSP.dataclasses.attribute.lacks.type.annotation=La propiedad ''{0}'' no tiene anotación de tipo
INSP.dataclasses.attribute.useless.until.post.init.declared=La propiedad ''{0}'' no tiene significado hasta que se declara ''__post_init__''
INSP.dataclasses.attrs.post.init.should.not.take.any.parameters.except.self='__attrs_post_init__ no puede tener parámetros excepto 'self'
INSP.dataclasses.attrs.post.init.would.not.be.called.until.init.parameter.set.to.true='__attrs_post_init__' no se llamará hasta que el parámetro 'init' esté establecido en True
INSP.dataclasses.cannot.specify.both.default.and.default.factory=No se pueden especificar tanto 'default' como 'default_factory'
INSP.dataclasses.cannot.specify.both.default.and.factory=No se pueden especificar tanto 'predeterminado' como 'fábrica'
INSP.dataclasses.eq.must.be.true.if.order.true=Si 'orden' es verdadero, 'eq' debe ser verdadero
INSP.dataclasses.field.cannot.have.default.factory=Los campos no pueden tener una fábrica predeterminada
INSP.dataclasses.frozen.attribute.should.be.false.if.class.defines.setattr.or.delattr=Si la clase define '__setattr__' o '__delattr__', 'congelado' debe ser Falso
INSP.dataclasses.frozen.dataclasses.can.not.inherit.non.frozen.one=Las clases de datos y las clases descongeladas no pueden heredar entre sí
INSP.dataclasses.hash.ignored.if.class.already.defines.cmp.or.order.or.frozen.parameters='__hash__' se ignora si la clase ya define los parámetros 'cmp/order' y 'frozen'
INSP.dataclasses.method.is.ignored.if.class.already.defines.parameter=Si la clase ya define el parámetro ''{1}'', ''{0}'' será ignorado
INSP.dataclasses.method.should.be.called.on.attrs.instances=El método ''{0}'' debe invocarse en una instancia de propiedad
INSP.dataclasses.method.should.be.called.on.attrs.types=El método ''{0}'' debe invocarse en un tipo de propiedad
INSP.dataclasses.method.should.be.called.on.dataclass.instances=El método ''{0}'' debe invocarse en una instancia de clase de datos
INSP.dataclasses.method.should.be.called.on.dataclass.instances.or.types=El método ''{0}'' debe invocarse en una instancia o tipo de clase de datos
INSP.dataclasses.method.should.take.only.n.parameter=''{0}'' contiene {1} {1,choice, 1\#parámetros| Debe haber solo 2\#parámetros}
INSP.dataclasses.mutable.attribute.default.not.allowed.use.default.factory=No se permite cambiar el valor predeterminado ''{0}''. Utilice ''default_factory''
INSP.dataclasses.object.attribute.read.only=''{0}'' la propiedad del objeto ''{1}'' es de solo lectura
INSP.dataclasses.object.could.have.no.attribute.because.it.declared.as.init.only=El objeto ''{0}'' se declara de solo inicio y no puede tener la propiedad ''{1}''
INSP.dataclasses.operator.not.supported.between.instances.of.class=''{0}'' entre instancias de ''{1}'' no es compatible
INSP.dataclasses.operator.not.supported.between.instances.of.classes=''{0}'' entre instancias de ''{1}'' y ''{2}'' no es compatible
INSP.dataclasses.order.argument.should.be.false.if.class.defines.one.of.order.methods=Si una clase define uno de los métodos de orden, 'orden' debe ser Falso
INSP.dataclasses.post.init.should.take.all.init.only.variables.in.same.order.they.defined='__post_init__' debe tomar todas las variables de solo inicio en el orden en que están definidas
INSP.dataclasses.post.init.should.take.all.init.only.variables.including.inherited.in.same.order.they.defined='__post_init__' debe tomar todas las variables de solo inicio (incluidas las variables heredadas) en el orden en que están definidas
INSP.dataclasses.post.init.would.not.be.called.until.init.parameter.set.to.true='__post_init__' no se llamará hasta que el parámetro 'init' esté establecido en True
INSP.dataclasses.unsafe.hash.attribute.should.be.false.if.class.defines.hash=Si la clase define '__hash__', entonces 'unsafe_hash' debe ser Falso
INSP.decorator.receives.unexpected.builtin=Este decorador no recibe el objeto invocable que espera, el decorador incorporado devuelve un objeto especial
INSP.decorators.method.only.decorator.on.method.outside.class=Decorador para el método externo de clase {0}
INSP.default.arguments.default.argument.value.mutable=Los valores de argumento predeterminados se pueden cambiar
INSP.deleter.should.not.return=Un eliminador no debe devolver un valor
INSP.deleter.signature.advice=La firma del eliminador debe ser (auto)
INSP.deprecation.abc.decorator.deprecated.use.alternative=''{0}'' está en desuso en Python 3.3 y posteriores. Utilice ''{1}'' con ''{2}'' en su lugar
INSP.dict.creation.this.dictionary.creation.could.be.rewritten.as.dictionary.literal=La creación de un diccionario se puede reescribir como un literal de diccionario
INSP.doc.param.should.be.str=El parámetro doc debe ser una cadena.
INSP.docstring.types.change.type=Cambiar el tipo de {0} de {1} a {2}
INSP.docstring.types.dynamically.inferred.type.does.not.match.specified.type=El tipo de inferencia dinámica ''{0}'' no coincide con el tipo especificado ''{1}''
INSP.docstring.types.fix.docstring=Editar cadena de documentación
INSP.dunder.slots.class.object.attribute.read.only=''{0}'' la propiedad del objeto ''{1}'' es de solo lectura
INSP.dunder.slots.name.in.slots.conflicts.with.class.variable=''{0}'' en __slots__ entra en conflicto con la variable de clase
INSP.duplicate.keys.dictionary.contains.duplicate.keys=El diccionario contiene clave duplicada ''{0}''
INSP.empty.docstring=cadena de documentos vacía
INSP.exception.inheritance.exception.does.not.inherit.from.base.exception.class=La excepción no hereda la clase base 'Excepción'
INSP.expected.dict.got.type=Expected a dictionary,got {0}
INSP.expected.iterable.got.type=Expected an iterable,got {0}
INSP.expression.can.be.simplified=Las expresiones se pueden simplificar.
INSP.expression.is.not.callable=la expresión no se puede llamar
INSP.final.already.declared.name.could.not.be.redefined.as.final=El nombre ya declarado no se puede redefinir como 'Final'
INSP.final.either.instance.attribute.or.class.attribute.could.be.type.hinted.as.final=Puede especificar 'Final' como sugerencia de tipo para una propiedad de instancia o una propiedad de clase.
INSP.final.final.attribute.could.not.be.overridden=''{0}'' no se puede redefinir porque es ''Final''
INSP.final.final.attribute.should.be.declared.in.class.body.or.init=La propiedad 'Final' debe declararse dentro del cuerpo de la clase o '__init__'
INSP.final.final.class.could.not.contain.abstract.methods=La clase 'Final' no puede contener métodos abstractos
INSP.final.final.could.not.be.mixed.with.abstract.decorators='Final' no se puede mezclar con un decorador abstracto
INSP.final.final.could.not.be.used.in.annotation.for.function.return.value='Final' no se puede utilizar en anotaciones de valores de retorno de funciones
INSP.final.final.could.not.be.used.in.annotations.for.function.parameters='Final' no se puede utilizar en anotaciones de parámetros de función
INSP.final.final.could.not.be.used.inside.loop='Final' no se puede utilizar dentro de un bucle
INSP.final.final.could.only.be.used.as.outermost.type='Final' solo se puede utilizar como el tipo más externo
INSP.final.final.name.should.be.initialized.with.value=El nombre 'final' debe inicializarse con un valor
INSP.final.final.should.be.placed.on.first.overload='@final' debe estar en la primera sobrecarga
INSP.final.final.should.be.placed.on.implementation='@final' debe estar en implementación
INSP.final.final.target.could.not.be.reassigned=''{0}'' no se puede reasignar porque es ''Final''
INSP.final.if.assigned.value.omitted.there.should.be.explicit.type.argument.to.final=Si se omite el valor asignado, 'Final' debe tener un argumento de tipo explícito
INSP.final.method.marked.as.final.should.not.be.overridden=''{0}'' está marcado como ''@final'' y no se puede redefinir
INSP.final.no.need.to.mark.method.in.final.class.as.final=No es necesario marcar los métodos de la clase 'Final' como '@final'
INSP.final.non.method.function.could.not.be.marked.as.final=Las funciones que no son de método no se pueden marcar como '@final'
INSP.final.super.classes.are.marked.as.final.and.should.not.be.subclassed={0}{1,choice,1\#|2\#} no puede ser una subclase porque está marcada como ''@final''
INSP.first.arg.assign.method.parameter.reassigned=El parámetro del método ''{0}'' ha sido reasignado
INSP.first.param.must.not.be.tuple=El primer parámetro de un método no estático no debe ser una tupla.
INSP.format.requires.mapping=El formato requiere mapeo
INSP.format.requires.no.mapping=El formato no requiere mapeo
INSP.from.future.import.from.future.imports.must.occur.at.beginning.file=La importación de __futuro__ debe estar al principio del archivo.
INSP.func.property.name.mismatch=Los nombres de funciones y decoradores no coinciden. Descriptor de acceso de propiedad no creado.
INSP.function.lacks.positional.argument=A la función ''{0}'' le faltan argumentos posicionales
INSP.getter.return.smth=El captador debe devolver o ceder algo.
INSP.getter.signature.advice=La firma del captador debe ser (auto)
INSP.global.variable.undefined=La variable global ''{0}'' no está definida a nivel de módulo
INSP.incompatible.options=Las opciones de formato para el fragmento "{0}" son incompatibles
INSP.inconsistent.indentation.mix.tabs.spaces=Sangría inconsistente\: mezclar tabulaciones y espacios
INSP.inconsistent.indentation.previous.line.used.spaces.this.line.uses.tabs=Sangría inconsistente\: se usaron espacios en la línea anterior, se usaron tabulaciones en esta línea
INSP.inconsistent.indentation.previous.line.used.tabs.this.line.uses.spaces=Sangría inconsistente\: la línea anterior usó una tabulación, esta línea usó un espacio
INSP.init.incompatible.to.new=La firma es incompatible con __new__
INSP.interpreter.configure.python.interpreter=Configuración del intérprete de Python
INSP.interpreter.interpreter.settings=Configuración del intérprete
INSP.interpreter.invalid.python.interpreter.selected.for.module=Se seleccionó un intérprete de Python incorrecto para el módulo
INSP.interpreter.invalid.python.interpreter.selected.for.project=Se seleccionó un intérprete de Python incorrecto para el proyecto
INSP.interpreter.no.python.interpreter.configured.for.module=No hay ningún intérprete de Python configurado para el módulo.
INSP.interpreter.no.python.interpreter.configured.for.project=No hay ningún intérprete de Python configurado para su proyecto
INSP.interpreter.pipenv.interpreter.associated.with.another.module=El intérprete Pipenv está vinculado a otro módulo. ''{0}''
INSP.interpreter.pipenv.interpreter.associated.with.another.project=El intérprete de Pipenv está vinculado a otro proyecto. ''{0}''
INSP.interpreter.pipenv.interpreter.not.associated.with.any.module=El intérprete Pipenv no está asociado con ningún módulo.
INSP.interpreter.pipenv.interpreter.not.associated.with.any.project=El intérprete de Pipenv no está asociado con ningún proyecto.
INSP.interpreter.python.has.reached.its.end.life.and.is.no.longer.supported.in.python.plugin=Python {0} ha llegado a su fecha de finalización de soporte y ya no es compatible con el complemento de Python
INSP.interpreter.python.has.reached.its.end.of.life.and.is.no.longer.supported.in.pycharm=Python {0} ha llegado a su fecha de fin de soporte y ya no es compatible con PyCharm
INSP.interpreter.use.interpreter=Utilice {0}
INSP.interpreter.use.suggested.interpreter=Utilice el intérprete sugerido
INSP.list.creation.this.list.creation.could.be.rewritten.as.list.literal=Puede reemplazar la inicialización de listas de varios pasos con listas literales
INSP.mandatory.encoding.checkbox.enable.in.python.3=Habilitado en Python 3
INSP.mandatory.encoding.label.encoding.comment.format=Formato de codificación de comentarios\:
INSP.mandatory.encoding.label.select.default.encoding=Seleccione la codificación predeterminada\:
INSP.mandatory.encoding.no.encoding.specified.for.file=No se ha especificado ninguna codificación en el archivo
INSP.manual.to.auto.field.numbering=No puede cambiar a la notación automática del número de campo en las especificaciones de campo manual.
INSP.message.single.quoted.docstring=Se deben utilizar cadenas triples entre comillas simples en las cadenas de documentos.
INSP.method.may.be.static=El método <code>\#ref</code> puede ser 'estático'
INSP.method.parameters.metaclass.method.first.argument.name=nombre del primer argumento del método de metaclase
INSP.missing.parameter.in.docstring=Falta el parámetro {0} en la cadena de documentación
INSP.missing.super.constructor.message=Falta la llamada __init__ de clase principal
INSP.missing.type.hints.add.type.hints=Agregar sugerencia de tipo
INSP.missing.type.hints.add.type.hints.for=Se agregó una sugerencia de tipo para ''{0}''
INSP.missing.type.hints.checkbox.only.when.types.are.known=Sólo si el tipo es conocido (recopilado o inferido en tiempo de ejecución)
INSP.missing.type.hints.type.hinting.missing.for.function.definition=Falta sugerencia de tipo para la definición de función
INSP.must.have.first.parameter=Method must have a first parameter,usually called ''{0}''
INSP.named.tuple=Definición no válida de 'typing.NamedTuple'
INSP.new.incompatible.to.init=La firma es incompatible con __init__
INSP.new.style.generics.are.not.allowed.inside.type.param.bounds=Los tipos genéricos no se pueden utilizar dentro de los límites y restricciones de los parámetros de tipo.
INSP.new.style.generics.assignment.expressions.not.allowed=No se pueden asignar expresiones dentro de las declaraciones de clases, funciones y alias de tipo con listas de parámetros de tipo.
INSP.new.style.generics.classes.with.type.param.list.should.not.extend.generic=La clase con lista de parámetros de tipo no puede extender 'Genérico'
INSP.new.style.generics.extending.protocol.does.not.need.parameterization=Para extender 'Protocolo', no necesita parametrizarlo con una lista de parámetros de tipo dentro de su clase.
INSP.new.style.generics.mixing.old.style.and.new.style.type.vars.not.allowed=Los parámetros de tipo de tipos antiguos y nuevos no se pueden mezclar
INSP.new.style.generics.old.style.type.vars.not.allowed.in.new.style.type.aliases=Los TypeVars existentes no se pueden utilizar dentro de la sintaxis de alias de tipo del nuevo formulario.
INSP.no.docstring=Falta una cadena de documentación
INSP.no.format.specifier.char=Carácter especificador de formato faltante
INSP.non.ascii.char.non.ascii.character.in.file.but.no.encoding.declared=Carácter no ASCII ''{0}'' en el archivo pero no se ha declarado ninguna codificación
INSP.none.function.assignment=La función ''{0}'' no devuelve nada
INSP.oldstyle.class.getattribute=La clase de estilo antiguo contiene la definición __getattribute__
INSP.oldstyle.class.slots=La clase de estilo antiguo contiene la definición de __slots__
INSP.oldstyle.class.super=La clase de estilo antiguo contiene una llamada al método principal
INSP.overloads.series.overload.decorated.functions.should.always.be.followed.by.implementation=Una serie de funciones decoradas con @overload deben ir seguidas de una implementación que no sea @overload-ed
INSP.overloads.series.overload.decorated.methods.should.always.be.followed.by.implementation=Un conjunto de métodos decorados con @overload debe ir seguido de una implementación que no sea @overload-ed
INSP.overloads.this.function.overload.signature.not.compatible.with.implementation=La firma de esta función @overload-decorated es incompatible con su implementación
INSP.overloads.this.method.overload.signature.not.compatible.with.implementation=La firma de este método @overload-decorated es incompatible con su implementación
INSP.override.missing.super.method=A la anulación le falta el súper método
INSP.package.requirements.add.import=Agregar importación
INSP.package.requirements.administrator.privileges.required=Se requieren privilegios de administrador
INSP.package.requirements.administrator.privileges.required.button.configure=composición
INSP.package.requirements.administrator.privileges.required.button.install.anyway=Todavía instalado
INSP.package.requirements.administrator.privileges.required.description=La instalación de paquetes con ''{0}'' requiere privilegios de administrador.\n\nConfigure un entorno virtual específico del proyecto con el intérprete del proyecto para evitar instalar proyectos en áreas protegidas del sistema de archivos.
INSP.package.requirements.requirement.has.been.ignored=''{0}''이(가) 무시되었습니다
INSP.package.requirements.requirements.file.empty=El archivo de requisitos está vacío
INSP.package.requirements.requirements.have.been.ignored=Se ignoraron los requisitos
INSP.pandas.series.values.replace.with.tolist=Se recomienda el método Series.to_list()
INSP.parameter(s).unfilled=Los parámetros no están poblados.
INSP.parameter.unfilled=El parámetro ''{0}'' no está completo
INSP.pep8.coding.style.violation=Violación del estilo de codificación PEP 8
INSP.pep8.ignore.base.class=Ignorar la clase base
INSP.pep8.ignore.method.names.for.descendants.of.class=Ignorar los nombres de los métodos para las subclases
INSP.pep8.naming.argument.name.should.be.lowercase=Los nombres de los argumentos deben estar en minúsculas.
INSP.pep8.naming.camelcase.variable.imported.as.constant=variables de notación camel importadas como constantes
INSP.pep8.naming.camelcase.variable.imported.as.lowercase=Variables de notación camel importadas como variables en minúsculas
INSP.pep8.naming.class.names.should.use.capwords.convention=Los nombres de las clases deben utilizar las convenciones de CapWords.
INSP.pep8.naming.column.name.excluded.base.classes=Clases base excluidas\:
INSP.pep8.naming.column.name.ignored.errors=Errores ignorados\:
INSP.pep8.naming.constant.variable.imported.as.non.constant=Variable constante importada como variable no constante
INSP.pep8.naming.function.name.should.be.lowercase=Los nombres de las funciones deben estar en minúsculas.
INSP.pep8.naming.lowercase.variable.imported.as.non.lowercase=Variables en minúsculas importadas como variables que no están en minúsculas
INSP.pep8.naming.variable.in.function.should.be.lowercase=Las variables dentro de funciones deben estar en minúsculas.
INSP.possible.callees=posible destinatario
INSP.probably.mistyped.self=¿No es "yo"?
INSP.property.cannot.be.deleted=La propiedad ''{0}'' no se puede eliminar
INSP.property.cannot.be.read=No se puede leer la propiedad ''{0}''
INSP.property.cannot.be.set=La propiedad ''{0}'' no se puede establecer
INSP.protected.member.access.to.protected.member.of.class=\ Acceso al miembro protegido {0} de la clase
INSP.protected.member.access.to.protected.member.of.module=\ Acceso al miembro protegido {0} del módulo
INSP.protected.member.ignore.annotations=Ignorar anotaciones
INSP.protected.member.ignore.test.functions=Ignorar la función de prueba
INSP.protected.member.name.not.declared.in.all=''{0}'' no está declarado en __all__
INSP.protocol.all.bases.protocol.must.be.protocols=Toda base de un protocolo debe ser un protocolo.
INSP.protocol.element.type.incompatible.with.protocol=El tipo de ''{0}'' es incompatible con ''{1}''
INSP.protocol.newtype.cannot.be.used.with.protocol.classes=NewType no se puede utilizar en clases de protocolo
INSP.protocol.only.runtime.checkable.protocols.can.be.used.with.instance.class.checks=Solo se puede utilizar el protocolo @runtime_checkable para la verificación de instancias y clases.
INSP.python.suppressor.suppress.for.class=suprimir para la clase
INSP.python.suppressor.suppress.for.function=Suprimir en función
INSP.python.suppressor.suppress.for.statement=suprimir por sintaxis
INSP.redeclared.name=''{0}'' definido anteriormente ha quedado obsoleto y redeclarado
INSP.redundant.parens.ignore.argument.of.operator=Ignorando los argumentos del operador %
INSP.redundant.parens.ignore.empty.lists.of.base.classes=Ignorar listas vacías en clases base
INSP.redundant.parens.ignore.tuples=Ignorar tuplas
INSP.relative.import.relative.import.outside.package=Importación relativa fuera del paquete
INSP.requirements.ignore.packages.label=Paquete ignorado\:
INSP.requirements.package.containing.module.not.listed.in.project.requirements=El paquete que contiene el módulo ''{0}'' no está en la lista de requisitos del proyecto
INSP.requirements.package.requirements.not.satisfied=El paquete {1,choice,1\#requirement|2\#requirement} {0}{1,choice,1\#|2\#} no se cumplió
INSP.setter.should.not.return=Los establecedores no deben devolver un valor
INSP.setter.signature.advice=Setter signature should be (self,value)
INSP.shadowing.builtins.ignore.built.ins.label=Elementos integrados ignorados\:
INSP.shadowing.builtins.shadows.built.in.name=Ocultar nombre integrado "{0}"
INSP.shadowing.names=Nombre de enmascaramiento del alcance externo
INSP.shadows.name.from.outer.scope=Ocultar nombre ''{0}'' en ámbito externo
INSP.signature.mismatch=La firma del método ''{0}'' no coincide con la firma del método base en la clase ''{1}''
INSP.simplify.boolean.check.ignore.comparison.to.zero=Ignorar la comparación con 0
INSP.simplify.chained.comparison=Simplificando la comparación de cadenas
INSP.statement.effect.statement.having.no.effect.can.be.replaced.with.function.call=La sintaxis no parece tener ningún efecto. Cambiarlo a una llamada de función tendrá efecto.
INSP.statement.effect.statement.seems.to.have.no.effect=La declaración parece no tener efecto.
INSP.str.format.can.not.use.star.in.formats.when.using.mapping=Cuando se utiliza el mapeo, '*' no se puede utilizar en el formato
INSP.str.format.key.has.no.argument=La clave ''{0}'' no tiene ningún argumento correspondiente
INSP.str.format.unexpected.argument.type=tipo inesperado {0}
INSP.str.format.unsupported.format.character.b=Carácter de formato no admitido 'b'
INSP.strange.arg.want.callable=Extraño argumento; Invocable requiere argumentos
INSP.stub.packages=Anunciante de paquete de resguardo
INSP.stub.packages.compatibility=Paquete de resguardo incompatible
INSP.stub.packages.compatibility.ignore=Ignorar la compatibilidad ''{0}''
INSP.stub.packages.compatibility.ignored.packages.label=Paquetes de resguardo ignorados\:
INSP.stub.packages.compatibility.incompatible.packages.message=''{0}{1}{2}'' no es compatible con ''{3}{4}{5}''. Se requiere la versión ''{6}''. [{7}]
INSP.symbol.is.not.callable=No se puede llamar a ''{0}''
INSP.too.broad.exception.clause=Cláusula de excepción demasiado amplia
INSP.too.few.args.for.fmt.string=Muy pocos argumentos para la cadena de formato
INSP.too.few.keys=Hay muy pocas claves de mapeo
INSP.too.many.args.for.fmt.string=Demasiados argumentos para la cadena de formato
INSP.trailing.semicolon=Punto y coma al final de una declaración
INSP.try.except.import.error=''{0}'' en un bloque try con ''except ImportError'' también debe definirse en el bloque except
INSP.tuple.assignment.balance.need.more.values.to.unpack=Necesita más valores para descomprimir
INSP.tuple.assignment.balance.only.one.starred.expression.allowed.in.assignment=Sólo se permite una expresión con un asterisco en una tarea
INSP.tuple.assignment.balance.too.many.values.to.unpack=Demasiados valores para descomprimir
INSP.tuples.never.assign.items=Tuple no admite la asignación de elementos
INSP.type.checker.expected.matched.type.got.type.instead=Tipo esperado ''{0}'' (coincide con el tipo genérico ''{1}''), pero se recibió ''{2}'' en su lugar
INSP.type.checker.expected.to.return.type.got.no.return=Se esperaba que devolviera ''{0}'' pero no se devolvió nada
INSP.type.checker.expected.type.got.type.instead=Se esperaba el tipo ''{0}'' pero en su lugar se obtuvo ''{1}''
INSP.type.checker.expected.types.prefix=Tipos posibles\:
INSP.type.checker.init.should.return.none=__init__ debe devolver Ninguno
INSP.type.checker.only.concrete.class.can.be.used.where.matched.protocol.expected=Sólo se pueden utilizar clases concretas cuando se requiere un protocolo ''{0}'' (que coincida con el tipo genérico ''{1}'').
INSP.type.checker.only.concrete.class.can.be.used.where.protocol.expected=Sólo se pueden utilizar clases concretas donde se requiere el protocolo ''{0}''
INSP.type.checker.type.does.not.have.expected.attribute=La {1,choice,1\#property|2\#property} {2} requerida para el tipo ''{0}'' no existe
INSP.type.checker.typed.dict.extra.key=Clave adicional ''{0}'' para TypedDict ''{1}''
INSP.type.checker.typed.dict.missing.keys=TypedDict ''{0}'' no contiene la siguiente {1,choice,1\#key|2\#key}. {2}
INSP.type.checker.unexpected.argument.from.paramspec=Argumento inesperado (en ParamSpec ''{0}'')
INSP.type.checker.unexpected.types.prefix=Tipo inesperado\:
INSP.type.checker.unfilled.parameter.for.paramspec=El parámetro ''{0}'' (en ParamSpec ''{1}'') no está completo.
INSP.type.checker.unfilled.vararg=No se introdujo el parámetro ''{0}''. ''{1}'' es obligatorio
INSP.type.hints.annotated.must.be.called.with.at.least.two.arguments='Anotado' debe llamarse con al menos dos argumentos
INSP.type.hints.argument.to.paramspec.must.be.string.equal.to.variable.name=El argumento 'ParamSpec()' debe ser la misma cadena que el nombre de la variable asignada.
INSP.type.hints.argument.to.typevar.must.be.string.equal.to.variable.name=El argumento 'TypeVar()' debe ser la misma cadena que el nombre de la variable asignada.
INSP.type.hints.argument.to.typevar.tuple.must.be.string.equal.to.variable.name=El argumento 'TypeVarTuple()' debe ser la misma cadena que el nombre de la variable asignada
INSP.type.hints.bivariant.type.variables.are.not.supported=No se admiten variables de tipo variable
INSP.type.hints.builtin.cannot.be.parameterized.directly=El ''{0}'' integrado no se puede parametrizar directamente
INSP.type.hints.cannot.inherit.from.generic.multiple.times=No se puede heredar 'Genérico[...]' varias veces
INSP.type.hints.cannot.inherit.from.plain.generic=No se puede heredar el genérico 'Genérico'
INSP.type.hints.generics.should.be.specified.through.square.brackets=Los genéricos deben especificarse utilizando corchetes.
INSP.type.hints.illegal.callable.format='Invocable' debe usarse como 'Invocable[[arg, ...], resultado]'
INSP.type.hints.illegal.first.parameter=El primer parámetro 'Invocable' debe ser una expresión de parámetro
INSP.type.hints.illegal.literal.parameter='Literal' se puede parametrizar mediante int literal, bytes y cadenas Unicode, bool, valores de enumeración, Ninguno, otros tipos literales o alias de tipo para otros tipos literales.
INSP.type.hints.invalid.type.self=Tipo "yo" no válido
INSP.type.hints.literal.must.have.at.least.one.parameter='Literal' debe tener al menos un parámetro
INSP.type.hints.non.self.attribute.could.not.be.type.hinted=Las propiedades distintas de self no se pueden especificar como sugerencias de tipo.
INSP.type.hints.parameterized.generics.cannot.be.used.with.instance.class.checks=Los genéricos parametrizados no se pueden utilizar, por ejemplo, ni la inspección de clases.
INSP.type.hints.parameters.to.generic.must.all.be.type.variables=Todos los parámetros de 'Generic[...]' deben ser variables de tipo
INSP.type.hints.parameters.to.generic.must.all.be.unique=Todos los parámetros de 'Generic[...]' deben ser únicos
INSP.type.hints.parameters.to.generic.types.cannot.contain.more.than.one.unpacking=Los parámetros de un genérico no pueden contener más de un desempaquetado.
INSP.type.hints.parameters.to.generic.types.must.be.types=Los parámetros de tipos genéricos deben ser tipos.
INSP.type.hints.paramspec.expects.string.literal.as.first.argument='ParamSpec()' requiere un literal de cadena como primer argumento
INSP.type.hints.self.use.for.cls.parameter.with.self.annotation='Self' no está disponible si el parámetro 'cls' no está anotado con 'Self'
INSP.type.hints.self.use.for.self.parameter.with.self.annotation='Self' no está disponible si el parámetro 'self' no está anotado con 'Self'
INSP.type.hints.self.use.in.staticmethod='Self' no se puede utilizar dentro de un método estático
INSP.type.hints.self.use.outside.class='Self' no se puede utilizar fuera de clase
INSP.type.hints.single.typevar.constraint.not.allowed=No se permiten constantes individuales
INSP.type.hints.some.type.variables.are.not.listed.in.generic=Algunas variables de tipo ({0}) no están en la lista ''Genérica[{1}]''
INSP.type.hints.type.alias.cannot.be.parameterized='TypeAlias' no se puede parametrizar
INSP.type.hints.type.alias.must.be.immediately.initialized=Los alias de tipo deben inicializarse inmediatamente
INSP.type.hints.type.alias.must.be.top.level.declaration=Los alias de tipo deben ser declaraciones de nivel superior
INSP.type.hints.type.alias.must.be.used.as.standalone.type.hint='TypeAlias' debe usarse como una sugerencia de tipo independiente
INSP.type.hints.type.cannot.be.used.with.instance.class.checks=''{0}'' no se puede utilizar para inspección de instancias y clases
INSP.type.hints.type.comment.cannot.be.matched.with.unpacked.variables=La anotación de tipo no puede coincidir con la variable desempaquetada
INSP.type.hints.type.self.not.supertype.its.class=El tipo de self ''{0}'' no es un supertipo de la clase ''{1}''
INSP.type.hints.type.signature.has.too.few.arguments=La firma tipográfica tiene muy pocos argumentos
INSP.type.hints.type.signature.has.too.many.arguments=La firma tipográfica tiene demasiados argumentos
INSP.type.hints.type.specified.both.in.type.comment.and.annotation=Tipo especificado tanto en la anotación de tipo como en la anotación
INSP.type.hints.type.var.tuple.must.always.be.unpacked=TypeVarTuple siempre debe estar descomprimido
INSP.type.hints.type.variables.cannot.be.used.with.instance.class.checks=Las variables de tipo no se pueden utilizar para verificaciones de clase y de ejemplo.
INSP.type.hints.type.variables.must.not.be.redefined=Las variables de tipo no deben redefinirse
INSP.type.hints.typevar.constraints.cannot.be.combined.with.bound=Las restricciones están limitadas\=… no se puede combinar con
INSP.type.hints.typevar.constraints.cannot.be.parametrized.by.type.variables=Las restricciones no se pueden parametrizar con variables de tipo
INSP.type.hints.typevar.expects.string.literal.as.first.argument='TypeVar()' requiere un literal de cadena como primer argumento
INSP.type.hints.typevar.expression.must.be.always.directly.assigned.to.variable=Las expresiones 'TypeVar()' siempre deben asignarse directamente a las variables
INSP.type.hints.typevar.tuple.expects.string.literal.as.first.argument='TypeVarTuple()' requiere un literal de cadena como primer argumento
INSP.type.hints.typing.self.cannot.be.parameterized='Self' no se puede parametrizar
INSP.typeddict.cannot.add.non.string.key.to.typeddict=No se puede agregar una clave que no sea una cadena a TypedDict "{0}"
INSP.typeddict.cannot.be.required.and.not.required.at.the.same.time=No se puede pedir una llave y no pedirla al mismo tiempo
INSP.typeddict.cannot.overwrite.typeddict.field=El campo TypedDict no se puede sobrescribir
INSP.typeddict.cannot.overwrite.typeddict.field.while.merging=El campo TypedDict ''{0}'' no se puede sobrescribir durante la combinación
INSP.typeddict.first.argument.has.to.match.variable.name=El primer argumento debe coincidir con el nombre de la variable.
INSP.typeddict.invalid.statement.in.typeddict.definition.expected.field.name.field.type=La definición de TypedDict tiene una sintaxis incorrecta. Se esperaba 'nombre_campo\:tipo_campo'
INSP.typeddict.key.cannot.be.deleted=No se puede eliminar la clave ''{0}'' en TypedDict ''{1}''
INSP.typeddict.key.should.be.string=La clave debe ser una cadena.
INSP.typeddict.required.notrequired.cannot.be.used.outside.typeddict.definition=''{0}'' solo se puede utilizar en definiciones TypedDict
INSP.typeddict.required.notrequired.must.have.exactly.one.type.argument=''{0}'' puede tener exactamente un argumento
INSP.typeddict.right.hand.side.values.are.not.supported.in.typeddict=El valor correcto no es compatible con TypedDict
INSP.typeddict.specifying.metaclass.not.allowed.in.typeddict=La especificación de metaclase no está permitida en TypedDict
INSP.typeddict.this.operation.might.break.typeddict.consistency=Esto puede dañar la coherencia de TypedDict
INSP.typeddict.total.value.must.be.true.or.false=El valor de 'total' debe ser Verdadero o Falso
INSP.typeddict.typeddict.cannot.have.key=TypedDict "{0}" no puede tener la clave ''{1}''
INSP.typeddict.typeddict.cannot.inherit.from.non.typeddict.base.class=TypedDict no puede heredar una clase base que no sea TypedDict
INSP.typeddict.typeddict.has.no.key=TypedDict "{0}" no tiene la clave ''{1}''
INSP.typeddict.typeddict.has.no.keys=TypedDict "{0}" no tiene clave ({1})
INSP.typeddict.typeddict.key.must.be.string.literal.expected.one=Las claves TypedDict deben ser cadenas literales. Requiere uno de ({0})
INSP.typeddict.value.must.be.type=El valor debe ser de tipo.
INSP.unbound.function.too.large=La función ''{0}'' es demasiado grande para analizarla
INSP.unbound.local.variable=Se puede hacer referencia a la variable local ''{0}'' antes de la asignación
INSP.unbound.name.undefined=El nombre ''{0}'' puede no estar definido
INSP.unbound.nonlocal.variable=La variable no local ''{0}'' debe estar vinculada al alcance de una función externa
INSP.unexpected.arg=argumento inesperado
INSP.unexpected.arg(s)=argumento inesperado
INSP.unexpected.parameter.in.docstring=Parámetro inesperado {0} en la cadena de documentación
INSP.unnecessary.backslash.unnecessary.backslash.in.expression=Barras invertidas innecesarias en expresiones.
INSP.unreachable.code=No se puede alcanzar este código
INSP.unresolved.refs.cannot.find.reference.in.type=Referencia ''{0}'' no encontrada en ''{1}''
INSP.unresolved.refs.class.does.not.define.operator=El operador ''{2}'' no se puede utilizar en una instancia porque la clase ''{0}'' no define ''{1}''
INSP.unresolved.refs.class.object.has.no.attribute=El objeto ''{0}'' no tiene la propiedad ''{1}''
INSP.unresolved.refs.ignore.references.label=Referencia ignorada\:
INSP.unresolved.refs.import.resolves.to.its.containing.file=La importación se resuelve en el archivo de inclusión de la importación.
INSP.unresolved.refs.module.not.found=Módulo ''{0}'' no encontrado
INSP.unresolved.refs.unresolved.attribute.for.class=Referencia de propiedad no resuelta ''{0}' en la clase '{1}''
INSP.unresolved.refs.unresolved.reference=Referencia no resuelta ''{0}''
INSP.unsupported.format.character=Carácter de formato no admitido ''{0}''
INSP.unused.import.statement=Declaración import obsoleta <code>\#ref</code>
INSP.unused.locals.ignore.lambda.parameters=Ignorando los parámetros lambda
INSP.unused.locals.ignore.range.iteration.variables=Ignorar variables de repetición de rango
INSP.unused.locals.ignore.variables.starting.with=Ignorar las variables que comienzan con '_'
INSP.unused.locals.ignore.variables.used.in.tuple.unpacking=Ignorar las variables utilizadas para descomprimir tuplas
INSP.unused.locals.local.class.isnot.used=La clase local ''{0}'' está en desuso
INSP.unused.locals.local.function.isnot.used=La función local ''{0}'' está obsoleta
INSP.unused.locals.local.variable.isnot.used=El valor de la variable local ''{0}'' no se utiliza
INSP.unused.locals.parameter.isnot.used=El valor del parámetro ''{0}'' no se utiliza
INSP.unused.locals.replace.with.wildcard=Cambiar a _
INSP.use.fixture.without.declaration.in.test.function=Ni la función de prueba ni el marcador ''@pytest.mark.usefixtures'' solicitan el accesorio ''{0}''
INSP.usually.named=Normalmente, el primer parámetro de estos métodos se denomina ''{0}''.
INSP.usually.named.self=Normalmente, el primer parámetro de un método se denomina "propio".
INTN.NAME.add.type.hint.for.variable=Agregar sugerencias de tipo para variables
INTN.NAME.add.type.hints.for.function=Agregar sugerencias de tipo para funciones
INTN.NAME.convert.collection.literal=Convertir colección a {0}
INTN.NAME.convert.import.qualify=Cambie 'de importación de módulo' a 'módulo de importación'
INTN.NAME.convert.import.unqualify=Convertir 'módulo de importación' a 'de importación de módulo'
INTN.NAME.convert.type.comment.to.variable.annotation=Convertir anotaciones de tipo en anotaciones de variables
INTN.NAME.demorgan.law=Ley de Morgan
INTN.NAME.flip.comparison=Invertir comparación
INTN.NAME.hide.type.annotations=Ocultar anotaciones de tipo
INTN.NAME.insert.docstring.stub=Insertar código auxiliar de cadena de documentación
INTN.NAME.join.if=Combinando declaraciones 'si'
INTN.NAME.negate.comparison=Negar comparación
INTN.NAME.specify.type.in.annotation=Especificación de tipos de referencia mediante anotaciones
INTN.NAME.specify.type.in.docstring=Especificar el tipo de referencia en la cadena de documentación
INTN.NAME.split.if=Dividir declaraciones 'si'
INTN.NAME.toggle.import.alias=Cambiar usando alias de declaración de importación
INTN.add.import.alias=Agregar alias
INTN.add.import.alias.dialog.message=Alias para ''{0}''\:
INTN.add.import.alias.title=Agregar alias
INTN.add.import.alias.to.name=Agregar alias a ''{0}''
INTN.add.parameters.to.docstring=Agregar parámetros a la cadena de documentos
INTN.add.qualifier=Add ''{0}'' qualifier
INTN.add.type.hint.for.variable=Agregar sugerencia de formato para la variable ''{0}''
INTN.add.type.hint.for.variable.PEP484.incompatible.type=El tipo ''{0}'' no se puede expresar en línea en formato PEP 484
INTN.add.type.hints.for.function=Agregar sugerencia de tipo para la función ''{0}''
INTN.category.python=Python
INTN.convert.absolute.to.relative=Convertir importación absoluta en relativa
INTN.convert.builtin.import=Convertir la importación del módulo incorporado al formato admitido
INTN.convert.collection.literal=Convertir {0} a {1}
INTN.convert.dict.constructor.to.dict.literal=Convertir el constructor de dict a dict literal
INTN.convert.dict.literal.to.dict.constructor=Convertir dict literal en constructor dict
INTN.convert.except.to=Convert ''except exceptClass,Target'' to ''except exceptClass as Target''
INTN.convert.lambda.to.function=Convertir lambda a función
INTN.convert.method.to.property=Convertir método en propiedad
INTN.convert.relative.to.absolute=Convertir importación relativa en absoluta
INTN.convert.static.method.to.function=Convertir método estático en función
INTN.convert.to.from.import=Convertir a ''desde {0} importar {1}''
INTN.convert.to.fstring.literal=Convertir a literal f-string
INTN.convert.to.plain.import=Convertir a ''importar {0}''
INTN.convert.type.comment.to.variable.annotation=Convertir a anotación variable
INTN.convert.variadic.param=Convertir parámetros variables en parámetros regulares
INTN.flip.comparison=Invertir ''{0}''
INTN.flip.comparison.to.operator=Invertir ''{0}'' a ''{1}''
INTN.format.operator.to.method=Convertir operador de formato a llamada al método 'str.format'
INTN.hide.type.annotations=Ocultar anotación de tipo
INTN.insert.assertion=Insertar aserción de tipo
INTN.insert.docstring.stub=Insertar trozo de cadena de documento
INTN.invert.if.condition=Invertir la condición 'si'
INTN.join.if=Combinando dos declaraciones 'si'
INTN.multiple.usages.of.import.found=Multiple Usages of the Import Found
INTN.negate.comparison=Negar ''{0}'' como ''{1}''
INTN.quoted.string=Convierta una cadena entre comillas simples en una cadena entre comillas dobles y viceversa
INTN.quoted.string.double.to.single=Convertir una cadena entre comillas dobles en una cadena entre comillas simples
INTN.quoted.string.single.to.double=Convertir una cadena entre comillas simples en una cadena entre comillas dobles
INTN.remove.import.alias=Eliminar alias ''{0}''
INTN.remove.qualifier=Remove ''{0}'' qualifier
INTN.remove.qualifier.from.all.usages=Remove qualifier from all usages
INTN.remove.qualifier.from.this.name=Remove qualifier from this name
INTN.replace.backquote.expression=Reemplazar expresión de comillas inversas
INTN.replace.list.comprehensions=Convertir listas por comprensión a un formato compatible
INTN.replace.list.comprehensions.with.for=Convertir la comprensión de listas en un bucle 'for'
INTN.replace.noteq.operator=Reemplazar operador no igual
INTN.replace.octal.numeric.literal=Convertir literal numérico octal a la forma admitida
INTN.replace.plus.with.format.operator=Reemplazar con operadores de formato de cadena
INTN.replace.plus.with.str.format=Reemplazar con llamada al método str.format
INTN.replace.raise.statement=Convertir la declaración de aumento a la forma admitida
INTN.replace.with.method=Reemplazar con llamada al método str.format
INTN.specify.return.type.in.annotation=Especificación del tipo de devolución mediante anotaciones
INTN.specify.return.type.in.docstring=Especificar el tipo de retorno en la cadena de documentación
INTN.specify.type.in.annotation=Especificación de tipos de referencia mediante anotaciones
INTN.specify.type.in.docstring=Especificar el tipo de referencia en la cadena de documentación
INTN.split.if=Dividir en dos declaraciones 'si'
INTN.string.concatenation.to.format=Cambie la concatenación de cadenas a 'str.format'
INTN.transform.into.if.else.statement=Convierta expresiones condicionales en declaraciones 'if'/'else'
INTN.triple.quoted.string=Convertir una cadena con comillas triples en una cadena con comillas simples
INTN.yield.from=Transforma la iteración explícita con 'rendimiento' en la expresión 'rendimiento de'
QDOC.accessor.kind=Tipo de acceso:
QDOC.assigned.to=Asignado a:
QDOC.attributes=propiedad\:
QDOC.built.in.description=Descripción incorporada
QDOC.class=clase
QDOC.class.attribute=Atributo de clase {0} de {1}
QDOC.copied.from=Copiado de\:
QDOC.epydoc.python2.sdk.not.found=Necesita configurar Python 2 SDK para renderizar <a href='http://epydoc.sourceforge.net/'> Epydoc</a> docstrings
QDOC.inferred.type.name=Tipo inferido\: {0}
QDOC.instance.attribute=Propiedad de instancia {0} de {1}
QDOC.keyword.args=Argumentos de palabras clave:
QDOC.local.sdk.not.found=Necesita un SDK de Python local configurado para renderizar cadenas de documentos.
QDOC.module.name=módulo {0}
QDOC.module.path.unknown=(Se desconoce la ruta del módulo)
QDOC.not.defined.in.parentheses=(no definida)
QDOC.package.name=paquete {0}
QDOC.parameter.name=Parámetro ''{0}''
QDOC.parameter.name.of.link=Parámetro {0} de {1}
QDOC.parameter.of.function.name=Parámetro ''{0}'' de la función ''{1}''
QDOC.parameter.of.method.name=Parámetro ''{0}'' del método ''{1}''
QDOC.params=Parámetro:
QDOC.property.getter=captador de propiedad
QDOC.property.name.of.link=Propiedad {0} de {1}
QDOC.raises=Aumentos:
QDOC.returns=Devoluciones:
QDOC.type.alias.statement.name.of.link=Escriba la sintaxis de alias {0} para {1}
QDOC.type.parameter.kind=tipo\:
QDOC.type.parameter.name=escriba el parámetro {0}
QDOC.type.parameter.name.of.link=Escriba el parámetro {0} de {1}
QDOC.variable.name=Variable ''{0}''
QFIX.NAME.add.exception.base=Agregar clase base de excepción
QFIX.NAME.add.field.to.class=Agregar campos a la clase
QFIX.NAME.add.method.to.class=Agregar método a la clase
QFIX.NAME.add.specifier=Agregar caracteres especificadores de formato
QFIX.NAME.auto.import=Importar
QFIX.NAME.convert.builtin=Conversión de importación de módulo incorporado
QFIX.NAME.create.function.in.module=Crear una función en el módulo.
QFIX.NAME.docstring=Editar cadena de documentación
QFIX.NAME.ignore.errors.like.this=Ignora errores como este
QFIX.NAME.ignore.requirements={0,choice,1\#requisito|2\#requisito}
QFIX.NAME.ignore.shadowed.built.in.name=Ignorar nombres integrados ocultos
QFIX.NAME.install.and.import.package=Instalar e importar el paquete '{0}'
QFIX.NAME.install.requirements={0,choice,1\#requisito|2\#requisito}
QFIX.NAME.local.auto.import=Consíguelo localmente
QFIX.NAME.make.function=Creando una función a partir de un método
QFIX.NAME.make.function.return.type=Configurar la función para devolver un tipo inferido
QFIX.NAME.make.list=Convertir tupla en lista
QFIX.NAME.make.static=Hacer método estático
QFIX.NAME.move.except.up=Mover cláusula de excepción hacia arriba
QFIX.NAME.remove.argument=eliminar argumento
QFIX.NAME.remove.assignment=Eliminar asignación
QFIX.NAME.remove.assignment.target=Eliminar el objetivo de ingreso a la universidad
QFIX.NAME.remove.call=eliminar llamada
QFIX.NAME.remove.dict.key=eliminar esta clave
QFIX.NAME.remove.exception.target=Eliminar objetivo de excepción
QFIX.NAME.remove.parameter=Eliminar parámetro
QFIX.NAME.remove.statement=eliminar sintaxis
QFIX.NAME.remove.string.prefix=Quitar prefijo
QFIX.NAME.remove.underscores.in.numeric=Eliminar guiones bajos de literales numéricos
QFIX.NAME.remove.with.target=Eliminar objetivo 'con'
QFIX.NAME.rename.argument=Cambiar el nombre del argumento
QFIX.NAME.rename.parameter=Cambiar nombre del parámetro
QFIX.NAME.replace.with.true.or.false=Cambiar a verdadero o falso
QFIX.NAME.simplify.boolean.expression=Simplificando expresiones booleanas
QFIX.NAME.unpack.type.var.tuple=TypeVarTuple descomprimiendo
QFIX.NAME.unresolved.reference.add.param=Crear parámetros a partir de referencias.
QFIX.NAME.unresolved.reference.create.function=Crear función ''{0}''
QFIX.NAME.update.parameters=Actualización de parámetros
QFIX.action.failed=Accion: Fallida
QFIX.add.encoding=Agregar declaración de codificación
QFIX.add.field.to.class=Agregar el campo ''{0}'' a la clase {1}
QFIX.add.field.to.class.popup.content.added.init=Se agregó<br/>__init__ a la clase <code>{0}</code> para acomodar el nuevo campo <code>{1}</code>
QFIX.add.fixture.to.test.function.parameters.list=Agregar dispositivo al parámetro de función de prueba
QFIX.add.from.future.import.annotations=Agregue 'de __future__ anotaciones de importación'
QFIX.add.global=Agregar sintaxis global
QFIX.add.imported.packages.to.requirements=Agregue paquetes importados a los requisitos...
QFIX.add.method.to.class=Agregue el método ''{0}'' a la clase {1}
QFIX.add.parameter.self=Agregar parámetro ''{0}''
QFIX.add.property=Agregar propiedades de campo
QFIX.add.qualifier=Agregar calificador
QFIX.add.super=Agregar llamada de clase principal
QFIX.augment.assignment=Reemplazar asignación con asignación aumentada
QFIX.auto.import.import.name=importar ''{0}''
QFIX.auto.import.import.this.name=Obtener este nombre
QFIX.chained.comparison=Simplificando la comparación de cadenas
QFIX.change.base.class=Cambiar clase base
QFIX.classic.class.transform=herencia del objeto
QFIX.convert.indents=Conversión de sangría
QFIX.convert.indents.to.spaces=Convertir sangría a espacios
QFIX.convert.indents.to.tabs=Convertir sangrías a tabulaciones
QFIX.convert.single.quoted.docstring=Convertir cadena de documentación a formato de cadena con comillas dobles triples
QFIX.convert.to.new.style=Convertir a una nueva clase de estilo
QFIX.coroutine.is.not.awaited=La rutina no está esperando.
QFIX.create.class=crear clase
QFIX.create.class.0=Crear clase ''{0}''
QFIX.create.class.in.module=Crear clase ''{0}'' en el módulo {1}
QFIX.create.function.in.module=Crear función {0}() en el módulo {1}
QFIX.create.property=Crear propiedad
QFIX.default.argument=Reemplazo de argumentos predeterminados variables
QFIX.dict.creation=Cambiar la creación del diccionario
QFIX.docstring.add.parameter=Agregar parámetro de cadena de documentación ''{0}''
QFIX.docstring.insert.stub=Insertar cadena de documentación
QFIX.docstring.remove.parameter=Eliminar el parámetro de cadena de documentación ''{0}''
QFIX.failed.to.add.field=<br/>No se pudo agregar el campo\!<br/><br/>
QFIX.failed.to.add.function=<br/>No se pudo agregar la función\!<br/><br/>
QFIX.failed.to.add.method=<br/>¡Error al agregar el método\!<br/><br/>
QFIX.ignore.shadowed.built.in.name=Ignorar el nombre integrado oculto "{0}"
QFIX.install.and.import.package=Instalar e importar el paquete.
QFIX.introduce.variable=Insertar variables en declaraciones
QFIX.list.creation=Reemplace la lista con un literal.
QFIX.local.auto.import.import.locally=Localmente {0}
QFIX.make.function.return.type=Hacer que ''{0}'' devuelva ''{1}''
QFIX.make.public=establecer en público
QFIX.move.attribute=Mover la propiedad al método __init__
QFIX.move.from.future.import=Mover 'de __futura__ importación' a la ubicación correcta
QFIX.optimize.imports=Optimización de declaraciones de importación
QFIX.pandas.series.values.replace.with.tolist=Reemplace la lista (Series.values) con Series.to_list()
QFIX.redundant.parentheses=Eliminar paréntesis duplicados
QFIX.remove.annotation=Eliminar anotación
QFIX.remove.argument.equal.default=Eliminar argumento igual al valor predeterminado
QFIX.remove.decorator=Quitar decorador
QFIX.remove.function.annotations=Eliminar anotación de función
QFIX.remove.generic.parameters=Eliminar parámetros genéricos
QFIX.remove.square.brackets=Quitar corchetes
QFIX.remove.string.prefix=Eliminar el {0} inicial
QFIX.remove.trailing.semicolon=Quitar punto y coma al final
QFIX.remove.trailing.suffix=Eliminar el sufijo final
QFIX.remove.type.comment=Eliminar anotación de tipo
QFIX.remove.unnecessary.backslash=Eliminar barras invertidas innecesarias de las expresiones
QFIX.rename.parameter=Cambiar nombre a ''{0}''
QFIX.rename.unresolved.reference=Cambiar nombre de referencia
QFIX.replace.equality=reemplazar la igualdad
QFIX.replace.function.set.with.literal=Convertir llamadas a funciones para establecer literales
QFIX.replace.star.by.unpack=Reemplazar con Typing_extensions.Unpack
QFIX.replace.with.old.union.style=Reemplazar con unión de estilo antiguo
QFIX.replace.with.square.brackets=reemplazar con corchetes
QFIX.replace.with.target.name=Reemplazar con el nombre del objetivo
QFIX.replace.with.true.or.false=Reemplazar con {0}
QFIX.replace.with.type.name=Reemplazar con nombre de tipo
QFIX.replace.with.typing.alias=Convertir a tipo alias
QFIX.simplify.boolean.expression=Convertir expresión booleana a ''{0}''
QFIX.statement.effect=Reemplazar con llamada de función
QFIX.surround.with.square.brackets=Rodear con corchetes
QFIX.unresolved.reference=Reemplace ''{0}'' por ''{1}.{0}''
QFIX.unresolved.reference.add.param=Crear parámetro ''{0}''
QFIX.unresolved.reference.create.function=Crear función
QFIX.use.property=Usar propiedades de campo
custom.type.mimic.name=Clase dinámica basada en {0}
debugger.cleaning.signature.cache=Limpieza de caché para tipos recopilados dinámicamente
element.presentation.location.string.in.class=({0} en {1})
element.presentation.location.string.in.class.stub=({0}/{1} talón)
element.presentation.location.string.module=({0})
element.presentation.location.string.module.stub=({0} trozo)
filetype.python.docstring.description=Python docstring
filetype.python.function.type.annotation.description=Anotaciones de tipo de función Python PEP-484
filetype.python.type.hint.description=Sugerencias de tipo Python PEP-484
find.usages.class=clase
find.usages.function=función
find.usages.imported.module.alias=Alias del módulo importado
find.usages.keyword.argument=Argumentos de palabras clave
find.usages.method=método
find.usages.parameter=parámetro
find.usages.unnamed=<unnamed>
find.usages.variable=variable
ignore.overridden.functions=Ignorar funciones anuladas
python.docstring.format=Formato de cadena de documentos\:
python.docstring.select.type=Seleccione el tipo de cadena de documentación
python.find.usages=Descubra dónde usarlo
python.find.usages.base.method.question=El método {0} anula un método de la clase {1}.\n¿Le gustaría saber el uso del método predeterminado?
python.find.usages.untyped.probable.usage=타입이 지정되지 않은(그럴 가능성 있는) 사용 위치
python.find.usages.usage.in.import.statement=Dónde usarlo en la declaración de importación
python.find.usages.usage.in.isinstance=Dónde usar isinstance() en mí
python.find.usages.usage.in.superclass.list=Dónde usarlo en la lista de clases principales
python.find.usages.usage.in.type.hint=Dónde utilizar sugerencias de escritura
refactoring.extract.method=Extracción del método
refactoring.extract.method.error.bad.selection=No se puede refactorizar el método de extracción con elementos seleccionados
refactoring.extract.method.error.class.level=La refactorización no se puede realizar a nivel de clase.
refactoring.extract.method.error.empty.fragment=La refactorización no se puede realizar en fragmentos de código vacíos
refactoring.extract.method.error.interrupted.execution.flow=No se puede realizar la refactorización cuando se interrumpe el flujo de ejecución
refactoring.extract.method.error.local.variable.modifications=La refactorización no se puede realizar en expresiones que tengan modificaciones de variables locales dentro de un fragmento de código.
refactoring.extract.method.error.local.variable.modifications.and.returns=No se puede refactorizar expresiones con instrucciones de devolución y modificar variables locales dentro de fragmentos de código.
refactoring.extract.method.error.name.clash=El nombre del método entra en conflicto con el nombre existente
refactoring.extract.method.error.returns=No se puede extraer el método con la instrucción de retorno dentro del fragmento de código
refactoring.extract.method.error.star.import=No se puede realizar la refactorización con la declaración de importación en estrella dentro del bloque de código
refactoring.extract.method.error.yield=No se puede realizar la refactorización con la declaración 'yield' dentro del bloque de código
refactoring.inline.all.border.title=En línea
refactoring.inline.all.keep.declaration=Incorporar todas las llamadas y conservar las declaraciones.
refactoring.inline.all.remove.declaration=Incorporar todas las llamadas y eliminar declaraciones.
refactoring.inline.can.not.multiline.string.to.f.string=No se puede insertar una cadena multilínea en f-string
refactoring.inline.can.not.string.to.nested.f.string=No se puede insertar una cadena en una cadena f anidada
refactoring.inline.can.not.string.with.backslashes.or.quotes.to.f.string=No se pueden insertar cadenas con barras invertidas y comillas en f-string
refactoring.inline.function=Función en línea {0}
refactoring.inline.function.async=La función asíncrona no se puede insertar
refactoring.inline.function.builtin=Las funciones integradas no se pueden integrar
refactoring.inline.function.command.name={0} en línea
refactoring.inline.function.constructor=Las llamadas al constructor no se pueden incluir en línea.
refactoring.inline.function.decorator=No se puede alinear una función con un decorador
refactoring.inline.function.function.to.inline=Función para en línea
refactoring.inline.function.generator=El generador no se puede insertar
refactoring.inline.function.global=No se pueden incorporar funciones con variables globales
refactoring.inline.function.interrupts.flow=No se pueden incorporar funciones en línea que interrumpan el flujo de control
refactoring.inline.function.invocations.to.be.inlined=Llamadas insertadas en el archivo {0}
refactoring.inline.function.is.decorator=La función {0} no se puede insertar porque se utiliza como decorador. La definición de función no se elimina
refactoring.inline.function.is.overridden=No se puede anular el método en línea
refactoring.inline.function.is.reference=La función {0} no se puede insertar porque se usa por referencia. La definición de función no se elimina
refactoring.inline.function.nested=No se puede alinear una función con otra declaración de función
refactoring.inline.function.nonlocal=No se pueden incorporar funciones no locales
refactoring.inline.function.overrides.method=No se puede insertar un método que anule otro método.
refactoring.inline.function.self.referrent=No se puede insertar una función que hace referencia a sí misma
refactoring.inline.function.skeleton.only=No se puede realizar la función en línea en el módulo binario
refactoring.inline.function.special.method=No se pueden incluir métodos especiales
refactoring.inline.function.star=* Las funciones con argumentos no se pueden insertar
refactoring.inline.function.title=Funciones en línea
refactoring.inline.function.uses.unpacking=La función {0} no se puede insertar utilizando instrucciones de empaquetado de argumentos. La definición de función no se elimina
refactoring.inline.label.function=función {0}
refactoring.inline.label.method=Método {0}
refactoring.inline.local.multiassignment=La definición está en asignación múltiple.
refactoring.inline.method=Método en línea {0}
refactoring.inline.this.only=Inserte solo esta llamada y conserve la declaración.
refactoring.introduce.constant.cannot.extract.selected.expression=La expresión seleccionada no se puede extraer como una constante
refactoring.introduce.constant.dialog.title=extracción constante
refactoring.introduce.constant.scope.error=el nombre ya está declarado en el alcance
refactoring.introduce.name.error=nombre equivocado
refactoring.introduce.selection.error=La refactorización no se puede realizar utilizando el elemento seleccionado
refactoring.introduce.variable.dialog.title=Extracción de variables
refactoring.introduce.variable.scope.error=El nombre entra en conflicto con la variable o parámetro existente
refactoring.move.module.members.error.cannot.place.elements.into.nonpython.file=No se pueden colocar elementos en archivos que no sean Python
refactoring.name.label.text={0} ha {1} elementos encontrados{2,choice, 0\#|1\#}
refactoring.progress.title.updating.existing.usages=Actualizando ubicaciones de uso existentes...
type.param.list.annotator.two.or.more.types.required=Se requieren dos o más tipos
type.param.list.annotator.type.parameter.already.defined=Un parámetro de tipo con nombre ''{0}'' ya está definido en esta lista de parámetros de tipo.
type.param.list.annotator.type.var.tuple.and.param.spec.can.not.have.bounds=ParamSpec y TypeVarTuple no pueden tener restricciones ni límites superiores
unresolved.docstring.param.reference=La función ''{0}'' no tiene parámetro ''{1}''
unresolved.import.reference=Ningún módulo con nombre ''{0}''
