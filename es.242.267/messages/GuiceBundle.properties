GuiceClassAnnotator.popup.title=Seleccionar expresión para mover
GuiceClassAnnotator.popup.tooltip.text=Vaya a Expresión de enlace de Guice
ImplicitSubclassInspection.display.forMethod.annotated=Los métodos @Transactional no pueden ser privados
binding.annotation.without.inject.display.name=Anotación vinculante sin @Inject
binding.annotation.without.inject.problem.descriptor=Anotación vinculante \#ref \#loc sin @Inject declarado
class.provided=Clase proporcionada\:
conflicting.annotations.display.name=Anotaciones de Guice en conflicto
conflicting.annotations.problem.descriptor=La anotación \#ref entra en conflicto con otra anotación declarada \#loc
delete.binding=Eliminar enlace
group.GuiceActionGroup.description=Componentes de Google Guice
group.GuiceActionGroup.text=Google Guice
group.guice.inspections.name=Guice
guice.intentions=Guice
gutter.choose.injected.point=Elija el punto de inyección
gutter.navigate.to.injection.point=Ir al punto de inyección
interception.annotation.without.runtime.retention.display.name=Anotaciones de interceptación sin período de retención de tiempo de ejecución
interception.annotation.without.runtime.retention.problem.descriptor=La anotación \#ref no tiene período de retención de tiempo de ejecución \#loc
invalid.implemented.by.display.name=Anotación @ImplementedBy no válida
invalid.implemented.by.problem.descriptor=La clase \#ref no implementa la clase anotada \#loc
invalid.provided.by.display.name=Anotación @ProvidedBy no válida
invalid.provided.by.problem.descriptor=La clase \#ref no proporciona una clase anotada \#loc
invalid.request.parameters.display.name=@RequestParameters tipo incorrecto de parámetro
invalid.request.parameters.problem.descriptor=Las variables o parámetros etiquetados con \#ref deben tener el tipo Map<String, String[]> \#loc
make.injection.mandatory=Hacer obligatoria la inyección
make.injection.optional=Hacer que la inyección sea opcional
move.binding.scope.to.class.family.name=Mover el alcance vinculante a la clase
move.binding.scope.to.class.text=Mover el alcance vinculante a la clase
move.binding.to.class.family.name=Mover enlace a clase
move.binding.to.class.text=Mover clase vinculante a clase
move.provider.binding.to.class.family.name=Mover enlaces de proveedores a clases
move.provider.binding.to.class.text=Mover enlaces de proveedores a clases
multiple.binding.annotations.display.name=Múltiples anotaciones vinculantes sobre variables
multiple.binding.annotations.problem.descriptor=La variable \#ref tiene múltiples anotaciones vinculantes \#loc
multiple.injected.constructors.for.class.display.name=Múltiples constructores @Inject para una clase
multiple.injected.constructors.for.class.problem.descriptor=Hay varios constructores @Inject en la clase \#ref \#loc
new.guice.binding.annotation.action.name=Crear anotaciones vinculantes de Guice
new.guice.binding.annotation.error=No se pueden generar anotaciones vinculantes de Guice
new.guice.binding.annotation.name=Creando anotación de enlace de Guice\: {0}.{1}
new.guice.method.interceptor.action.name=Crear un interceptor del método Guice
new.guice.method.interceptor.error=No se puede crear el interceptor del método Guice
new.guice.method.interceptor.name=Creando interceptor del método Guice\: {0}.{1}
new.guice.module.action.name=Crear un módulo de Guice
new.guice.module.error=No se puede crear el módulo Guice
new.guice.module.name=Creando módulo Guice\: {0}.{1}
new.guice.provider=Nuevo proveedor de Guice
new.guice.provider.action.name=Crear un proveedor de Guice
new.guice.provider.error=No se puede crear el proveedor de Guice
new.guice.provider.name=Creando proveedor Guice\: {0}.{1}
new.guice.scope.annotation.action.name=Crear anotaciones de alcance de Guice
new.guice.scope.annotation.error=No se puede generar la anotación del alcance de Guice
pointless.binding.display.name=vinculación sin sentido
pointless.binding.problem.descriptor=El enlace es innecesario y se puede eliminar \#loc
provider.class.name=Nombre de la clase del proveedor\:
redundant.scope.binding.display.name=Enlace de alcance innecesario
redundant.scope.binding.problem.descriptor=La vinculación al alcance \#ref es innecesaria \#loc
redundant.to.binding.display.name=encuadernación innecesaria
redundant.to.binding.problem.descriptor=La vinculación a la clase \#ref es innecesaria \#loc
redundant.to.provider.binding.display.name=Enlace de proveedor innecesario
redundant.to.provider.binding.problem.descriptor=La vinculación a la clase \#ref es innecesaria \#loc
select.provided.class=Seleccione una clase para proporcionar
session.scoped.injects.request.scoped.display.name=El componente @SessionScoped inyecta el componente @RequestScoped
session.scoped.injects.request.scoped.problem.descriptor=@Inject \#loc en la clase @RequestScoped \#ref en la clase @SessionScoped
singleton.injects.scoped.display.name=El componente @Singleton inserta un componente con alcance
singleton.injects.scoped.problem.descriptor=@Inject \#loc en clase con alcance \#ref en clase @Singleton
toggle.injection.required.family.name=Se requiere inyección de alternancia
toggle.required=Cambiar a ''opcional''
uninstantiable.binding.display.name=Enlace del que no se puede crear una instancia
uninstantiable.binding.problem.descriptor=No se puede crear una instancia de la clase \#ref y, por lo tanto, no se puede vincular a \#loc
uninstantiable.implemented.by.class.display.name=@ImplementedBy clase de la que no se puede crear una instancia
uninstantiable.implemented.by.class.problem.descriptor=@ImplementedBy no puede ser \#loc porque no se puede crear una instancia de la clase \#ref
uninstantiable.provided.by.class.display.name=No se puede crear una instancia de la clase @ProvidedBy
uninstantiable.provided.by.class.problem.descriptor=@ ProvidedBy no puede ser \#loc porque no se puede crear una instancia de la clase \#ref
unnecessary.static.injection.display.name=Inserción estática innecesaria
unnecessary.static.injection.problem.descriptor=La clase \#ref no tiene el miembro @Inject estático \#loc
