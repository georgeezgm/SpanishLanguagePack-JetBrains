0.is.not.an.identifier=''{0}'' no es un identificador.
annotation.name.is.missing=Las propiedades de la anotación deben tener el formato '' nombre \=valor ''.
anonymous.class.context.display=anónimo de {0}
anonymous.class.derived.display=Clase anónima derivada de {0}
aux.context.display=(en {0})
bad.return.type.in.lambda.expression=Tipo de retorno de expresión lambda no válido\: no se puede convertir {0} a {1}
bad.return.type.in.lambda.expression1=Tipo de retorno no válido de expresión lambda\: {0} no se puede convertir a vacío
bad.return.type.in.method.reference=Tipo de retorno de referencia de método no válido\: No se puede convertir {0} a {1}
bound.not.expected=Límite inesperado
catch.without.try= atrapar '' sin '' intentar 
class.context.display={0} de {1}
class.file.version=ver. {0}
class.literal.expected=.class es obligatorio
command.name.insert.block.statement=Insert Block Statement
conflicting.conjuncts={0} y {1}
context.type.java.comment=Comentario
context.type.string=cadena
default.language.level.description=Valores predeterminados del SDK
diamond.error.anonymous.inner.classes='' <> '' no se puede usar con clases internas anónimas
diamond.error.anonymous.inner.classes.non.private=No se puede usar '' <> '' ya que no es un método no privado que no anula ni implementa métodos de un supertipo
diamond.error.cannot.infer.arguments=No se pudieron inferir argumentos
diamond.error.cannot.infer.arguments.unable.to.resolve.constructor=No se pueden inferir argumentos (no se puede resolver el constructor)
diamond.error.cannot.infer.type.arguments=No se pudo inferir el tipo de argumento de {0}
diamond.error.explicit.type.parameters.for.constructor=Los diamantes no se pueden usar con parámetros de tipo explícitos en constructores
element.abstract_method=método abstracto
element.annotation=Anotación
element.anonymous_class=Clase anónima
element.class=Clase
element.constant=campo constante
element.constructor=Constructor
element.enum=enumeración
element.enum_constant=Constante de enumeración
element.expression=expresión
element.extends.list=extends list
element.field=campo
element.initializer=Inicializador
element.interface=Interfaz
element.kind.and.name={0} {1}
element.label=etiqueta
element.local_variable=Variable local
element.method=método
element.method.call=method call
element.module=Módulo
element.package=paquete
element.package.statement=package statement
element.parameter=parámetro
element.pattern_variable=Variable de patrón
element.permits.list=permits list
element.receiver.parameter=receiver parameter
element.record=registro
element.record_component=Componente de registro
element.snippet_body=snippet body
element.statement=Sintaxis
element.throws.list=throws list
element.type.arguments=type arguments
element.type.parameter=type parameter
element.type.parameters=형식 매개 변수
element.type.semicolon=semicolon
element.unknown=Elemento
element.variable=variable
else.without.if= else '' sin '' if 
enum.constant.context={1}'' constante de enumeración ''{0}
error.incompatible.type={0} no es compatible con {1}
error.incompatible.type.bad.lambda.return.type=Tipo de retorno no válido en la expresión lambda\: {0} no se puede convertir a {1}
error.incompatible.type.declaration.for.the.method.reference.not.found=No se pudo encontrar la declaración en tiempo de compilación para la referencia del método
error.incompatible.type.expected.non.void.got.void.method.reference=tipo incompatible\: se requiere no vacío, pero la declaración en tiempo de compilación para la referencia del método tiene un tipo de retorno vacío
error.incompatible.type.expected.value.lambda=tipo incompatible\: no se requiere nulo pero el cuerpo lambda es un bloque con valores incompatibles
error.incompatible.type.failed.to.resolve.argument=No se pudo resolver el argumento
error.incompatible.type.incompatible.equality.constraint=Restricción de igualdad incompatible\: {1} y {0}
error.incompatible.type.incompatible.parameter.types.in.lambda=Tipos de parámetros incompatibles en la expresión lambda
error.incompatible.type.incompatible.parameter.types.in.method.reference=Tipos de parámetros incompatibles dentro de expresiones de referencia de métodos
error.incompatible.type.incompatible.types.expected.not.void.got.void.method.reference=tipo incompatible\: se requiere no void, pero la declaración en tiempo de compilación para la referencia del método tiene un tipo de retorno nulo
error.incompatible.type.incompatible.types.expected.void.lambda=tipo incompatible\: se requiere void, pero el cuerpo lambda no es una expresión de sintaxis ni un bloque compatible void
error.incompatible.type.no.type.variable=No hay instancia de la variable de tipo {0}
error.incompatible.type.no.type.variable.0={1} porque no hay una instancia de la variable de tipo {0}
error.incompatible.type.no.valid.function.type.found=No se pudo encontrar el tipo de función válido para {0}
error.incompatible.type.not.a.functional.interface={0} no es una interfaz funcional
error.incompatible.type.not.convertible=Tipo incompatible\: {0} no se puede convertir a {1}
error.incompatible.type.parameter.type.is.not.yet.inferred=El tipo de parámetro aún no se ha inferido. {0}
error.incompatible.type.return.type.is.not.yet.inferred=El tipo de retorno aún no se ha inferido. {0}
error.incompatible.type.unhandled.exception=Excepción no controlada\: {0}
error.incompatible.upper.bounds=Límites superiores incompatibles\: {0}
error.inference.variable.has.incompatible.bounds=La variable de inferencia {0} tiene límites incompatibles.\n{1}\: {2}\n{3}\: {4}
error.message.wildcard.not.expected=comodín inesperado
error.type.parameter.has.incompatible.upper.bounds=El parámetro de tipo {0} tiene límites superiores incompatibles. {1}
expected.array.initializer=inicializador de matriz esperado
expected.boolean.expression=expresión bool esperada
expected.case.label.element=Expression, pattern, 'default' or 'null' expected
expected.catch.or.finally='' captura '' o '' finalmente '' esperado
expected.class.or.interface=se requiere '' clase '' o '' interfaz ''
expected.class.reference=Se requiere una referencia de clase
expected.colon=''\: '' esperado
expected.colon.or.arrow=':' or '->' expected
expected.comma='', '' esperado
expected.comma.or.rparen='', '' o '') '' esperado
expected.comma.or.semicolon='', '' o ''; '' es obligatorio.
expected.dot=''. '' esperado
expected.eq='' \='' esperado
expected.expression=Expresión esperada
expected.gt=''> '' esperado
expected.gt.or.comma=''> '' o '' '', '' esperado
expected.identifier=Identificador esperado
expected.identifier.or.type=Identificador o tipo esperado
expected.lbrace='' {'' esperado
expected.lbrace.or.semicolon='' {'' o ''; '' es esperado
expected.lbracket='' ['' esperado
expected.lparen='' ('' esperado
expected.lparen.or.lbracket='' ('' o ''] '' esperado
expected.lt.or.lparen='' <'' o '' ('' es obligatorio.
expected.module.declaration=Se requiere la declaración del módulo
expected.module.statement=Se requiere directiva de módulo
expected.package.reference=Se requiere la referencia del paquete
expected.parameter=parámetro esperado
expected.pattern=Pattern expected
expected.rbrace=''} '' esperado
expected.rbracket=] 
expected.resource=Se requiere una definición de recurso
expected.rparen=) 
expected.semicolon=; 
expected.statement=Declaración esperada
expected.string=Se requiere literal de cadena
expected.switch.label='' caso '', '' predeterminado '' o ''} '' esperado
expected.switch.rule=Expect expresión, bloqueo o declaración de lanzamiento
expected.template.fragment=Template fragment expected
expected.type=Tipo requerido
expected.type.parameter=Tipo de parámetro requerido
expected.value=Valor requerido
expected.while= mientras 
expected.with='' con '' es obligatorio
feature.advanced.collection.api=Lambda methods in collections
feature.annotations=Annotations
feature.assertions=Assertions
feature.binary.literals=Binary literals
feature.classfile.api=ClassFile API
feature.collection.factories=Collection factory methods
feature.diamond.types=Diamond types
feature.effectively.final=Effectively final variables
feature.enhanced.switch=Enhanced 'switch' blocks
feature.enum.qualified.name.in.switch=Qualified enum as a constant in switch
feature.enums=Enums
feature.extension.methods=Extension methods
feature.for.each=For-each loops
feature.foreign.functions=Foreign Function & Memory API
feature.generics=Generics
feature.hex.fp.literals=Hexadecimal floating point literals
feature.implicit.classes=Implicitly declared classes
feature.inner.statics=Static declarations in inner classes
feature.intersections.in.casts=Intersection types in casts
feature.javadoc.snippets=@snippet in Javadoc
feature.lambda.expressions=Lambda expressions
feature.local.enums=Local enums
feature.local.interfaces=Local interfaces
feature.lvti=Local variable type inference
feature.method.references=Method references
feature.modules=Modules
feature.multi.catch=Multi-catches
feature.nestmates=Nest-based access control
feature.no.this.capture=Inner classes don't capture 'this'
feature.objects.class=java.util.Objects API
feature.override.interface=@Override in interfaces
feature.pattern.guard.and.record.patterns=Pattern guards and record patterns
feature.patterns.in.switch=Patterns in switch
feature.patterns.instanceof=Patterns in 'instanceof'
feature.private.interface.methods=Private interface methods
feature.record.patterns.in.for.each=Record patterns in for-each loops
feature.records=Records
feature.scoped.values=Scoped Values
feature.sealed.classes=Sealed classes
feature.sequenced.collections=Sequenced Collections
feature.serial.annotation=@Serial annotation
feature.statements.before.super=Statements before super()
feature.static.imports=Static imports
feature.static.interface.calls=Static interface method calls
feature.stream.and.optional.api=Stream and Optional API
feature.stream.gatherers=Stream Gatherers
feature.strictfp=Always-strict floating point semantics
feature.string.switch=Strings in 'switch' statements
feature.string.templates=String templates
feature.structured.concurrency=Structured Concurrency
feature.switch.expressions='switch' expressions
feature.text.block.escape.sequences='\\s' escape sequences
feature.text.blocks=Text block literals
feature.try.with.resources=Try-with-resources
feature.try.with.resources.refs=Resource references
feature.type.annotations=Type annotations
feature.type.receivers=Receiver parameters
feature.underscores.in.literals=Underscores in literals
feature.unnamed.vars=Unnamed patterns and variables
feature.var.lambda.parameter='var' in lambda parameters
feature.varargs=Variable arity methods
feature.virtual.threads=Virtual Threads
feature.with.initial=ThreadLocal.withInitial()
filetype.class.description=Java class
filetype.class.display.name=Java class
filetype.java.description=Java
filetype.jshell.description=JShell snippet
finally.without.try= finalmente '' sin '' intentar 
implicit.class.context.display=Implicit class
import.statement.identifier.or.asterisk.expected.=Identificador o '' * '' requerido
java.terms.anonymous.class.base.ref=Anónimo {0}
javadoc.exception.tag.class.is.not.throwable=La clase {0} no es descendiente de Throwable.
javadoc.exception.tag.exception.is.not.thrown={0} no está declarado para ser lanzado como método {1}.
javadoc.exception.tag.wrong.tag.value=Valor de etiqueta no válido
javadoc.param.tag.parameter.name.expected=Nombre de parámetro obligatorio
javadoc.param.tag.type.parameter.gt.expected=''> '' esperado
javadoc.param.tag.type.parameter.name.expected=Tipo de nombre de parámetro obligatorio
javadoc.ref.tag.class.ref.expected=Se requiere una referencia de clase
javadoc.value.field.required=La etiqueta @value debe hacer referencia a un campo.
javadoc.value.field.with.initializer.required=La etiqueta @value debe hacer referencia a un campo que contiene un inicializador constante.
javadoc.value.static.field.required=@value etiqueta debe hacer referencia a un campo estático.
javadoc.value.tag.jdk15.required=Cuando se usa JDK 1.4 o anterior, las etiquetas @value pueden no contener argumentos.
jdk.1.3.language.level.description=1.3 - Java antiguo simple
jdk.1.4.language.level.description=1.4 - palabra clave '' aseverar ''
jdk.1.5.language.level.description=5 - palabra clave '' enum '', genéricos, autoboxing, etc.
jdk.1.6.language.level.description=6 - Etiqueta @Override en la interfaz
jdk.1.7.language.level.description=7 - Diamante, ARM, capturas múltiples, etc.
jdk.1.8.language.level.description=8 - lambdas, anotaciones de tipo, etc.
jdk.1.9.language.level.description=9 - métodos privados en módulos, interfaces, etc.
jdk.10.language.level.description=10 - inferir el tipo de variable local
jdk.11.language.level.description=11 - sintaxis de variable local para parámetros lambda
jdk.12.language.level.description=12 - sin nuevas funciones de idioma
jdk.13.language.level.description=13 - sin nuevas funciones de idioma
jdk.14.language.level.description=14 - Cambiar expresión
jdk.15.language.level.description=15 - bloque de texto
jdk.16.language.level.description=16 - Records, patterns, local enums and interfaces
jdk.17.language.level.description=17 - Sealed types, always-strict floating-point semantics
jdk.18.language.level.description=18 - JavaDoc snippets
jdk.19.language.level.description=19 - No new language features
jdk.20.language.level.description=20 - No new language features
jdk.21.language.level.description=21 - Record patterns, pattern matching for switch
jdk.21.preview.language.level.description=21 (Preview) - String templates, unnamed classes and instance main methods etc.
jdk.22.language.level.description=22 - Unnamed variables and patterns
jdk.22.preview.language.level.description=22 (Preview) - Statements before super(), string templates (2nd preview) etc.
jdk.X.language.level.description=X - funcion experimental
jdk.unsupported.preview.language.level.description={0} (Preview) - Unsupported
lambda.body.must.be.a.statement.expression=El cuerpo lambda debe ser sintáctico.
list.item.no.module=<Sin modulo>
local.class.preposition=Local
method.context.display={0} () de {1}
missing.return.value.lambda=Falta el valor de retorno
node.abstract.flag.tooltip=Resumen
node.annotation.tooltip=Anotaciones
node.anonymous.class.tooltip=Clase anónima
node.class.tooltip=Clase
node.enum.tooltip=Enum
node.exception.tooltip=Excepción
node.field.tooltip=Campo
node.final.flag.tooltip=Final
node.interface.tooltip=Interfaz
node.junit.test.tooltip=Prueba JUnit
node.method.tooltip=Método
node.record.tooltip=Grabar (función de vista previa)
node.runnable.class.tooltip=Clase ejecutable
node.static.flag.tooltip=static
psi.error.attempt.to.edit.class.file=No se pueden modificar los elementos compilados en el archivo ''{0}''
task.background.title.maven=Maven
type.can.be.converted={0} se puede convertir a {1}
type.conforms.to.constraint={0} cumple con {1}
unexpected.identifier=Identificador inesperado
unexpected.return.value=Valor de retorno inesperado
unexpected.token=Token inesperado
unexpected.tokens=tokens inesperados
