conflicting.annotations.display.name=Anotaciones de Guice en conflicto
conflicting.annotations.problem.descriptor=La anotación \#ref entra en conflicto con otra anotación declarada \#loc
multiple.binding.annotations.display.name=Múltiples anotaciones vinculantes sobre variables
multiple.binding.annotations.problem.descriptor=La variable \#ref tiene múltiples anotaciones vinculantes \#loc
binding.annotation.without.inject.display.name=Anotación vinculante sin @Inject
binding.annotation.without.inject.problem.descriptor=Anotación vinculante \#ref \#loc sin @Inject declarado
interception.annotation.without.runtime.retention.display.name=Anotaciones de interceptación sin retención de tiempo de ejecución
interception.annotation.without.runtime.retention.problem.descriptor=La anotación \#ref no tiene capacidad de retención de tiempo de ejecución \#loc
invalid.request.parameters.display.name=@RequestParameters Tipo no válido para parámetro
invalid.request.parameters.problem.descriptor=Una variable o parámetro etiquetado como \#ref debe tener el tipo Map<String, String[]> \#loc
invalid.implemented.by.display.name=Anotación @ImplementedBy no válida
invalid.implemented.by.problem.descriptor=La clase \#ref no implementa la clase anotada \#loc
singleton.injects.scoped.display.name=El componente @Singleton inserta un componente con alcance
singleton.injects.scoped.problem.descriptor=@Clase Singleton clase con ámbito \#ref @Inject \#loc
group.guice.inspections.name=Guice
session.scoped.injects.request.scoped.display.name=El componente @SessionScoped inyecta el componente @RequestScoped
session.scoped.injects.request.scoped.problem.descriptor=Clase @RequestScoped \#ref @Inject \#loc en la clase @SessionScoped
invalid.provided.by.display.name=Anotación @ProvidedBy no válida
invalid.provided.by.problem.descriptor=La clase \#ref no proporciona una clase anotada \#loc
uninstantiable.implemented.by.class.display.name=@ImplementedBy clase de la que no se puede crear una instancia
uninstantiable.implemented.by.class.problem.descriptor=@ImplementedBy no puede ser \#loc porque no se puede crear una instancia de la clase \#ref
uninstantiable.provided.by.class.display.name=No se puede crear una instancia de la clase @ProvidedBy
uninstantiable.provided.by.class.problem.descriptor=@ ProvidedBy no puede ser \#loc porque no se puede crear una instancia de la clase \#ref
uninstantiable.binding.display.name=Enlace del que no se puede crear una instancia
uninstantiable.binding.problem.descriptor=No se puede crear una instancia de la clase \#ref y, por lo tanto, no se puede vincular a \#loc
redundant.to.binding.display.name=encuadernación innecesaria
redundant.to.binding.problem.descriptor=La vinculación a la clase \#ref es innecesaria \#loc
redundant.to.provider.binding.display.name=Enlace de proveedor innecesario
redundant.to.provider.binding.problem.descriptor=La vinculación a la clase \#ref es innecesaria \#loc
redundant.scope.binding.display.name=Enlace de alcance innecesario
redundant.scope.binding.problem.descriptor=La vinculación al alcance \#ref es innecesaria \#loc
pointless.binding.display.name=vinculación sin sentido
pointless.binding.problem.descriptor=El enlace es innecesario y se puede eliminar \#loc
unnecessary.static.injection.display.name=Inserción estática innecesaria
unnecessary.static.injection.problem.descriptor=La clase \#ref no tiene un miembro @Inject estático. \#loc
multiple.injected.constructors.for.class.display.name=Múltiples constructores @Inject para una clase
multiple.injected.constructors.for.class.problem.descriptor=Hay varios constructores @Inject en las clases \#ref y \#loc
move.binding.scope.to.class.text=Mover el alcance vinculante a la clase
move.binding.scope.to.class.family.name=Mover el alcance vinculante a la clase
move.binding.to.class.text=Mover clase vinculante a clase
move.binding.to.class.family.name=Mover enlace a clase
move.provider.binding.to.class.text=Mover enlaces de proveedores a clases
move.provider.binding.to.class.family.name=Mover enlaces de proveedores a clases
guice.intentions=Guice
new.guice.module.error=No se puede crear el módulo Guice
new.guice.module.action.name=Crear un módulo de Guice
new.guice.module.name=Creando módulo Guice\: {0}.{1}
new.guice.scope.annotation.error=No se pueden generar anotaciones de alcance de Guice
new.guice.scope.annotation.action.name=Crear anotaciones de alcance de Guice
new.guice.binding.annotation.error=No se pueden generar anotaciones vinculantes de Guice
new.guice.binding.annotation.action.name=Crear anotaciones vinculantes de Guice
new.guice.binding.annotation.name=Creando anotación de enlace de Guice\: {0}.{1}
new.guice.method.interceptor.error=No se puede crear el interceptor del método Guice
new.guice.method.interceptor.action.name=Crear un interceptor del método Guice
new.guice.method.interceptor.name=Creando interceptor del método Guice\: {0}.{1}
new.guice.provider.error=No se puede crear el proveedor de Guice
new.guice.provider.action.name=Crear un proveedor de Guice
new.guice.provider.name=Creando proveedor Guice\: {0}.{1}
toggle.injection.required.family.name=Se requiere inyección de alternancia
make.injection.optional=Hacer que la inyección sea opcional
make.injection.mandatory=Hacer obligatoria la inyección
toggle.required=Cambiar a ''opcional''
action.group.guice.title=Google Guice
action.group.guice.description=Componente Google Guice creado
delete.binding=Eliminar enlace
select.provided.class=Seleccione una clase para proporcionar
GuiceClassAnnotator.popup.title=Seleccionar expresión para mover
GuiceClassAnnotator.popup.tooltip.text=Vaya a Expresión de enlace de Guice
gutter.choose.injected.point=Elija el punto de inyección
gutter.navigate.to.injection.point=Ir al punto de inyección
provider.class.name=Nombre de la clase del proveedor\:
class.provided=Clase proporcionada\:
new.guice.provider=Nuevo proveedor de Guice
