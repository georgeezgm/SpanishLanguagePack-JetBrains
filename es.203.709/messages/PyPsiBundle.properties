# Message we display for inspection if user uses custom class type members that do not exist
custom.type.mimic.name=Clase dinámica basada en {0}

### Refactorización

refactoring.extract.method.error.interrupted.execution.flow=No se puede realizar la refactorización cuando se interrumpe el flujo de ejecución
refactoring.extract.method.error.star.import=No se puede realizar la refactorización con la declaración de importación en estrella dentro del bloque de código
refactoring.extract.method.error.yield=No se puede realizar la refactorización con la declaración 'yield' dentro del bloque de código

### Anotadores ###
ANN.deleting.none=Eliminando ninguno
ANN.assign.to.none=Asignación a Ninguno
ANN.cant.assign.to.call=No se puede asignar a la llamada de función
ANN.cant.delete.call=No se puede eliminar la llamada a la función
ANN.cant.aug.assign.to.generator=No es posible la asignación aumentada a la expresión del generador
ANN.cant.aug.assign.to.tuple.or.generator=Asignación aumentada a literal de tupla o expresión generadora no posible
ANN.cant.assign.to.generator=Asignar a la expresión del generador no es posible
ANN.cant.assign.to.operator=No se puede asignar al operador
ANN.cant.assign.to.parens=No se puede asignar a()
ANN.cant.aug.assign.to.list.or.comprh=Asignación aumentada a literal de lista o no es posible la comprensión
ANN.cant.assign.to.comprh=No se puede asignar a la comprensión de la lista
ANN.cant.assign.to.dict.comprh=No se puede asignar a la comprensión de dict
ANN.cant.assign.to.set.comprh=No se puede asignar para establecer la comprensión
ANN.cant.aug.assign.to.comprh=Asignación aumentada a la comprensión de la lista no es posible
ANN.cant.aug.assign.to.dict.comprh=Asignación aumentada a comprensión de dictado no es posible
ANN.cant.aug.assign.to.set.comprh=No es posible la asignación aumentada para establecer la comprensión
ANN.cant.aug.assign.starred.assignment.target.must.be.in.list.or.tuple=별표 대입 대상은 리스트 또는 튜플 안에 있어야 합니다
ANN.cant.assign.to.literal=No se puede asignar a literal
ANN.cant.delete.literal=No se puede eliminar literal
ANN.cant.assign.to.lambda=No se puede asignar a lambda

ANN.break.outside.loop='break' fuera del bucle
ANN.continue.outside.loop='continue' fuera del bucle

ANN.duplicate.param.name=nombre de parámetro duplicado
ANN.starred.param.after.kwparam=* parámetro después de ** parámetro
ANN.regular.param.after.vararg=parámetro regular después de * parámetro
ANN.regular.param.after.keyword=parámetro regular después de ** parámetro
ANN.non.default.param.after.default=el parámetro no predeterminado sigue al parámetro predeterminado
ANN.named.parameters.after.star=los parámetros con nombre deben seguir al desnudo *
ANN.named.parameters.before.slash=los parámetros con nombre deben preceder a bare /
ANN.tuple.py3=​​el desempaquetado del parámetro tuple no es compatible con Python 3
ANN.multiple.args=varios * parámetros no están permitidos
ANN.multiple.kwargs=múltiples ** parámetros no están permitidos
ANN.multiple.slash=no se permiten varios/parámetros
ANN.slash.param.after.vararg=/ parámetro debe preceder * parámetro
ANN.slash.param.after.keyword=/ parámetro debe preceder ** parámetro

ANN.star.import.at.top.only=''import *''는 모듈 레벨에서만 허용됩니다.

ANN.missing.closing.quote=닫는 따옴표 [{0}] 누락
ANN.missing.closing.triple.quotes=닫는 삼중 따옴표 누락

### análisis
PARSE.expected.expression=expresión esperada
PARSE.expected.rbracket=Se esperaba ']'
PARSE.expected.expr.or.comma.or.bracket=expresión esperada, ',' o ']'
PARSE.expected.in=Se esperaba 'in'
PARSE.expected.for.or.bracket=Se esperaba ']' o 'for'
PARSE.expected.comma=Se esperaba ','
PARSE.expected.colon=Se esperaba ':'
PARSE.expected.rpar=Se esperaba ')'
PARSE.expected.lpar=Se esperaba '('
PARSE.expected.rbrace=Se esperaba '}'
PARSE.expected.tick=Se esperaba '`' (comilla invertida)
PARSE.expected.name=nombre esperado
PARSE.expected.colon.or.rbracket=Se esperaba ':' o ']'
PARSE.expected.comma.or.rpar=Se esperaba ',' o ')'
PARSE.expected.else=Se esperaba 'else'

PARSE.expected.identifier=식별자가 필요합니다
PARSE.expected.comma.lpar.rpar='','' 또는 ''('' 또는 '')'' 가 필요합니다
PARSE.expected.statement.break=break 문이 필요합니다
PARSE.expected.@.or.def=''@'' 또는 ''def'' 이(가) 필요합니다
PARSE.expected.formal.param.name=형식 매개변수 이름 기대
PARSE.0.expected=''{0}'' 기대
PARSE.expected.ellipsis=''...'' 가 필요합니다
PARSE.string.literal.expected=문자열 리터럴이 필요합니다
PARSE.expected.symbols=''{0}'' 또는 ''{1}'' 기대
PARSE.expected.symbols.first.quotation=''{0}'' 또는 {1} 기대
PARSE.expected.symbols.second.quotation={0} 또는 ''{1}'' 기대
PARSE.declarator.should.be.empty=선언자가 비어 있어야 합니다.
PARSE.string.literal=문자열 리터럴
PARSE.newline.expected=줄 바꿈이 필요합니다
PARSE.eq.expected=''\='' 이 필요합니다
PARSE.from.expected=''from'' 이 필요합니다
PARSE.gt.expected=''>'' 가 필요합니다
PARSE.expected.fstring.quote={0} 기대
PARSE.expected.fstring.rbrace=''}'' 기대
PARSE.expected.fstring.colon.or.rbrace=\: 또는 ''}'' 기대
PARSE.expected.fstring.type.conversion.or.colon.or.rbrace=형 변환, ''\:'' 또는 ''}'' 기대
PARSE.single.star.parameter.not.supported.py2=단일 별표 매개변수는 Python 2에서 지원되지 않습니다
PARSE.async.keyword.not.expected.here=''async'' 키워드는 적합하지 않습니다
PARSE.keyword.cannot.be.used.as.identifier.py2=''{0}'' 키워드는 Python 2에서 식별자로 사용할 수 없습니다

statement.expected.found.0=Se esperaba una declaración, se encontró {0}
unexpected.indent=sangría inesperada
unindent.does.not.match.any.outer.indent=Unindent no coincide con ningún nivel de sangría exterior
except.or.finally.expected=Se esperaba 'except' o 'finally'
expected.statement=Declaración esperada
dedent.expected=Dedent esperado
indent.expected=Se esperaba Sangría
indented.block.expected=Se espera un bloque con sangría
cannot.assign.to.yield.expression=No se puede asignar a la expresión 'yield'
end.of.statement.expected=Fin de la declaración esperado
import.expected=Se esperaba 'import'
def.or.with.or.for.expected=Se esperaba 'def' o 'with' o 'for'
rbracket.or.comma.expected=Se esperaba ']' o ','
unexpected.expression.syntax=Sintaxis de expresión inesperada
tuple.expression.expected=expresión de tupla esperada
value.expression.expected=expresión de valor esperada
unexpected.expression.part=parte de expresión inesperada
unexpected.f.string.token=token de cadena f inesperado
can.t.assign.to.await.expression=No se puede asignar a una expresión en await
for.expected=Se esperaba 'for'
rarrow.expected=Se esperaba '->'
unexpected.tokens=tokens inesperados

PARSE.function.type.annotations.py2=Las anotaciones de tipo no son compatibles con Python 2
PARSE.function.return.type.annotations.py2=Las anotaciones de tipo de retorno no son compatibles con Python 2

PARSE.console.multiline.magic.warn=여러 줄 매직을 표현식으로 사용할 수 없습니다.
PARSE.console.help.request.warn=도움 요청은 이름 다음에 와야 합니다.

### generador de documentos rápido
QDOC.module.path.unknown=(Se desconoce la ruta del módulo)
QDOC.epydoc.python2.sdk.not.found=Necesita configurar Python 2 SDK para renderizar <a href='http://epydoc.sourceforge.net/'> Epydoc</a> docstrings
QDOC.local.sdk.not.found=Necesita un SDK de Python local configurado para renderizar cadenas de documentos.
QDOC.assigned.to=Asignado a:
QDOC.documentation.is.copied.from=La documentación se copia de:
QDOC.accessor.kind=Tipo de acceso:
QDOC.raises=Aumentos:
QDOC.keyword.args=Argumentos de palabras clave:
QDOC.returns=Devoluciones:
QDOC.params=Parámetro:

### Formateador
formatter.panel.dict.alignment.do.not.align=No alinear
formatter.panel.dict.alignment.align.on.colon=Alinear en dos puntos
formatter.panel.dict.alignment.align.on.value=Alinear en valor

ignore.overridden.functions=Ignorar funciones anuladas

### Intenciones ###

INTN.replace.octal.numeric.literal=Convertir literal numérico octal a la forma admitida
INTN.convert.builtin.import=Convertir la importación del módulo incorporado al formato admitido

QFIX.NAME.convert.builtin=기본 제공 모듈 가져오기 변환

INTN.NAME.convert.import.unqualify=''import module'' 에서 ''from module import''으로 바꿉니다
INTN.convert.to.from.import=''from {0} import {1}''(으)로 변환

INTN.NAME.convert.import.qualify=''from module import'' 에서 ''import module''으로 바꿉니다
INTN.convert.to.plain.import=''import {0}''(으)로 변환

INTN.convert.except.to=Convert ''except exceptClass,Target'' to ''except exceptClass as Target''

INTN.NAME.toggle.import.alias=가져오기 별칭 전환
INTN.add.import.alias=별칭 추가
INTN.add.import.alias.to.name=''{0}''에 별칭 추가
INTN.add.import.alias.dialog.message=''{0}''에 대한 별칭\:
INTN.add.import.alias.title=별칭 추가
INTN.remove.import.alias=별칭 ''{0}'' 제거

INTN.replace.noteq.operator=Reemplazar operador no igual

QFIX.NAME.remove.string.prefix=접두사 제거
QFIX.remove.string.prefix=선행 {0} 제거

INTN.replace.backquote.expression=Reemplazar expresión de comillas inversas
INTN.replace.raise.statement=Convertir la declaración de aumento a la forma admitida

INTN.replace.list.comprehensions=Convertir listas por comprensión a un formato compatible

# PyConvertToFStringIntention
INTN.convert.to.fstring.literal=Convertir a literal f-string
INTN.replace.with.method=Reemplazar con llamada al método str.format

# ConvertFormatOperatorToMethodIntention
INTN.format.operator.to.method=형식 연산자 사용 위치를 str.format 메서드 호출로 변환

INTN.replace.list.comprehensions.with.for=리스트 내포를 for 루프로 변환

INTN.NAME.split.if=if 문 분할
INTN.split.if=''if'' 문 2개로 분할

INTN.NAME.negate.comparison=Negar comparación
INTN.negate.comparison=Negar ''{0}'' como ''{1}''

INTN.string.concatenation.to.format=문자열 연결을 형식 연산자로 바꾸기
INTN.replace.plus.with.format.operator=+를 문자열 서식 지정 연산자로 바꾸기
INTN.replace.plus.with.str.format=+를 str.format 메서드 호출로 바꾸기


INTN.NAME.flip.comparison=Invertir comparación
INTN.flip.comparison=Invertir ''{0}''
INTN.flip.comparison.to.operator=Invertir ''{0}'' a ''{1}''

INTN.NAME.join.if=if 문 결합
INTN.join.if=두 if 문 결합

INTN.convert.dict.constructor.to.dict.literal=dict 생성자를 dict 리터럴 형식으로 변환
INTN.convert.dict.literal.to.dict.constructor=dict 리터럴을 dict 생성자로 변환

INTN.quoted.string=작은 따옴표 및 큰따옴표로 문자열 간 변환
INTN.quoted.string.single.to.double=작은 따옴표 문자열을 큰따옴표 문자열로 변환
INTN.quoted.string.double.to.single=큰따옴표 문자열을 작은 따옴표 문자열로 변환

INTN.convert.lambda.to.function=람다를 함수로 변환

INTN.convert.variadic.param=가변에서 일반 매개변수로 변환

# PyConvertTripleQuotedStringIntention
INTN.triple.quoted.string=삼중 따옴표 문자열을 작은 따옴표 문자열로 변환

# PyBaseConvertCollectionLiteralIntention
INTN.NAME.convert.collection.literal=컬렉션을 {0}(으)로 변환 
INTN.convert.collection.literal={0} 을(를) {1}(으)로 변환

# PyConvertTypeCommentToVariableAnnotation
INTN.NAME.convert.type.comment.to.variable.annotation=유형 주석을 변수 어노테이션으로 변환
INTN.convert.type.comment.to.variable.annotation=변수 어노테이션으로 변환

INTN.NAME.demorgan.law=드모르간 법칙

# PyTransformConditionalExpressionIntention
INTN.transform.into.if.else.statement=조건식을 if/else 문으로 변환

# PyGenerateDocstringIntention
INTN.NAME.insert.docstring.stub=문서 문자열 스텁 삽입
INTN.insert.docstring.stub=문서 문자열 스텁 삽입
INTN.add.parameters.to.docstring=docstring에 매개변수 추가

#SpecifyTypeInDocstringIntention
INTN.NAME.specify.type.in.docstring=docstring 내 참조 유형 지정
INTN.specify.type.in.docstring=docstring 내 참조 유형 지정
INTN.specify.return.type.in.docstring=docstring 내 반환 유형 지정

#SpecifyTypeInPy3AnnotationsIntention
INTN.NAME.specify.type.in.annotation=어노테이션를 사용하여 참조 유형 지정
INTN.specify.type.in.annotation=어노테이션를 사용하여 참조 유형 지정
INTN.specify.return.type.in.annotation=어노테이션를 사용하여 반환 유형 지정

#PyAnnotateTypesIntention
INTN.NAME.add.type.hints.for.function=함수에 대한 유형 힌트 추가
INTN.add.type.hints.for.function=함수 ''{0}''에 대한 유형 힌트 추가

# PyAnnotateVariableTypeIntention
INTN.NAME.add.type.hint.for.variable=변수에 대한 유형 힌트 추가
INTN.add.type.hint.for.variable=변수 ''{0}''에 대한 형식 힌트 추가
INTN.add.type.hint.for.variable.PEP484.incompatible.type=유형 ''{0}''을(를) PEP 484 형식으로 인라인으로 표현할 수 없습니다.

#TypeAssertionIntention
INTN.insert.assertion=Insertar aserción de tipo

#PyYieldFromIntention
INTN.yield.from=Transforma la iteración explícita con 'rendimiento' en la expresión 'rendimiento de'

#PyConvertStaticMethodToFunctionIntention
INTN.convert.static.method.to.function=Convertir método estático en función

#PyConvertMethodToPropertyIntention
INTN.convert.method.to.property=Convertir método en propiedad

#PyConvertImportIntentionAction
INTN.convert.relative.to.absolute=Convertir importación relativa en absoluta
INTN.convert.absolute.to.relative=Convertir importación absoluta en relativa

#PyInvertIfConditionIntention
INTN.invert.if.condition=''if'' 조건을 반전시킵니다.

### Quick fixes ###
QFIX.add.qualifier=한정자 추가

QFIX.NAME.auto.import=가져오기
QFIX.auto.import.import.this.name=이 이름 가져오기
QFIX.auto.import.import.name=가져오기 ''{0}''

QFIX.NAME.local.auto.import=로컬로 가져오기
QFIX.local.auto.import.import.locally=로컬로 {0}

QFIX.augment.assignment=Reemplazar asignación con asignación aumentada
QFIX.NAME.remove.call=호출 제거
QFIX.replace.equality=등식 바꾸기
QFIX.dict.creation=딕셔너리 생성 바꾸기
QFIX.NAME.remove.dict.key=이 키 제거
QFIX.NAME.move.except.up=except 절을 위로 이동
QFIX.NAME.add.field.to.class=\ 클래스에 필드 추가
QFIX.add.field.to.class={1} 클래스에 ''{0}''필드 추가
QFIX.add.field.to.class.popup.content.added.init=새 필드 <code>{1}</code>를 수용하기 위해<br/>__init__을 클래스에 <code>{0}</code>에추가했습니다. 
QFIX.NAME.remove.parameter=매개변수 제거
QFIX.NAME.rename.parameter=매개변수 이름 변경
QFIX.rename.parameter=''{0}''로 이름 바꾸기
QFIX.NAME.remove.statement=구문 제거
QFIX.NAME.remove.target.expr=대상 표현식 제거
QFIX.failed.to.add.field=<br/>필드 추가 실패하였습니다\!<br/><br/>
QFIX.redundant.parentheses=중복 된 소괄호 제거
QFIX.NAME.simplify.boolean.expression=부울 표현식 단순화
QFIX.simplify.boolean.expression=부울 표현식을 ''{0}''로 바꿉니다
QFIX.chained.comparison=체인 비교 간소화
QFIX.move.from.future.import=올바른 위치로 ''from __future__ import'' 이동
QFIX.list.creation=리스트 생성 바꾸기
QFIX.add.super=상위 클래스 호출 추가
QFIX.NAME.remove.assignment=변수 지정 제거
QFIX.NAME.remove.argument=인수 제거
QFIX.add.parameter.self=파라메타 추가 ''{0}''
QFIX.statement.effect=함수 호출로 바꾸기
QFIX.remove.trailing.semicolon=후행 세미콜른 제거하기
QFIX.introduce.variable=명령문에 대한 변수 삽입
QFIX.NAME.make.list=튜플을 리스트로 바꾸기
QFIX.NAME.add.specifier=형식 지정자 문자 추가
QFIX.NAME.wrap.in.exception=Exception 호출로 래핑
QFIX.add.global=전역 변수(global) 추가
QFIX.create.property=프로퍼티 만들기
QFIX.add.property=필드 프로퍼티 추가
QFIX.use.property=필드 프로퍼티 사용
QFIX.make.public=public으로 설정
QFIX.NAME.update.parameters=파라메타 업데이트 
QFIX.convert.to.new.style=새로운 스타일의 클래스로 바꾸기
QFIX.change.base.class=기본 클래스 변경
QFIX.classic.class.transform=객체에서 상속받습니다
QFIX.NAME.rename.argument=인자 이름 바꾸기
QFIX.NAME.add.exception.base=Exception 기본 클래스 추가
QFIX.add.encoding=인코딩 선언 추가
QFIX.remove.trailing.suffix=후행 접미사 제거
QFIX.action.failed=작업이 실패 하였습니다
QFIX.create.class=클래스 생성
QFIX.create.class.0=클래스 ''{0}'' 생성
QFIX.create.class.in.module=모듈 {1} 에 클래스 ''{0}'' 생성

QFIX.unresolved.reference=''{0}'' 을(를) ''{1}.{0}'' (으)로 바꾸기

QFIX.NAME.unresolved.reference.add.param=참조를 위한 매개변수 생성
QFIX.unresolved.reference.add.param=매개변수 ''{0}'' 생성

#PyRenameUnresolvedRefQuickFix
QFIX.rename.unresolved.reference=참조 이름 변경

# UnresolvedRefCreateFunctionQuickFix
QFIX.unresolved.reference.create.function=함수 생성
QFIX.NAME.unresolved.reference.create.function=함수 ''{0}'' 생성

#UnresolvedRefTrueFalseQuickFix
QFIX.NAME.replace.with.true.or.false=True 또는 False로 바꾸기
QFIX.replace.with.true.or.false={0} (으)로 바꾸기

#PyRemoveUnderscoresInNumericLiteralsQuickFix
QFIX.NAME.remove.underscores.in.numeric=숫자 리터럴에서 밑줄을 제거하세요

# ReplaceFunctionWithSetLiteralQuickFix
QFIX.replace.function.set.with.literal=함수 호출을 집합 리터럴로 바꾸기

#RemoveArgumentEqualDefaultQuickFix
QFIX.remove.argument.equal.default=디폴트 값과 동일한 인수 제거

#PyDefaultArgumentQuickFix
QFIX.default.argument=변경 가능한 디폴트 인수 바꾸기

#PyMoveAttributeToInitQuickFix
QFIX.move.attribute=속성을 __init__ 메서드로 이동

#DocstringQuickFix
QFIX.NAME.docstring=docstring 수정
QFIX.docstring.add.parameter=docstring 매개변수 ''{0}'' 추가
QFIX.docstring.remove.parameter=docstring 매개변수 ''{0}'' 제거
QFIX.docstring.insert.stub=docstring 삽입

#PyMakeMethodStaticQuickFix
QFIX.NAME.make.static=메서드를 정적으로 만들기

#PyMakeFunctionFromMethodQuickFix
QFIX.NAME.make.function=메서드로부터 함수 생성

#ConvertIndents
QFIX.convert.indents=들여쓰기 변환
QFIX.convert.indents.to.tabs=들여쓰기를 탭으로 변환
QFIX.convert.indents.to.spaces=들여쓰기를 공백으로 변환

# ConvertDocstringQuickFix
QFIX.convert.single.quoted.docstring=docstring을 삼중 큰따옴표 문자열 양식으로 변환

# RemoveUnnecessaryBackslashQuickFix
QFIX.remove.unnecessary.backslash=표현식에서 불필요한 백슬래시 제거

#RemoveDecoratorQuickFix
QFIX.remove.decorator=데코레이터 제거

#PyMakeFunctionReturnTypeQuickFix
QFIX.NAME.make.function.return.type=함수가 추론 유형을 반환하게 하기
QFIX.make.function.return.type=''{0}''이(가) ''{1}''을(를) 반환하도록 만듭니다.

# Add method quick fix
QFIX.NAME.add.method.to.class=클래스에 메서드 추가
QFIX.add.method.to.class={1} 클래스에 ''{0}''메서드 추가
QFIX.failed.to.add.method=<br/>메서드 추가 실패\!<br/><br/>

QFIX.NAME.create.function.in.module=모듈에 기능 생성
QFIX.create.function.in.module={1} 모듈에 {0}() 함수 생성
QFIX.failed.to.add.function=<br/>함수 추가 실패하였습니다\!<br/><br/>

# InstallAndImportQuickFix
QFIX.install.and.import.package=패키지를 설치하고 가져옵니다
QFIX.NAME.install.and.import.package=''{0}''패키지를 설치하고 가져옵니다

# PyAsyncCallInspection
QFIX.coroutine.is.not.awaited=코루틴은 대기하고 있지 않습니다


# Actions and associated commands
ACT.CMD.use.import=가져온 모듈 사용
ACT.qualify.with.module=가져온 모듈 검증
ACT.from.some.module.import=...으로부터 가져오기


python.docstring.file.type=python docstring
python.function.type.annotation.file.type.description=Python PEP-484 함수 유형 주석
python.type.hint.file.type.description=Python PEP-484 유형 힌트
python.docstring.format=Docstring 형식\:
python.docstring.select.type=Docstring 유형 선택

### Inspections: INSP ###
INSP.GROUP.python=Python

INSP.abstract.class.set.as.metaclass=''{0}''을(를) 메타 클래스로 설정
INSP.abstract.class.add.to.superclasses=상위 클래스에 ''{0}'' 추가
INSP.named.tuple=Namedtuple 정의
INSP.shadows.name.from.outer.scope=외부 범위의 이름 ''{0}'' 가리기
INSP.trailing.semicolon=명령문 내 후행 세미콜론
INSP.raising.string.exception=문자열 예외 발생
INSP.protected.member.ignore.annotations=어노테이션 무시
INSP.protected.member.ignore.test.functions=테스트 함수 무시
INSP.docstring.types.fix.docstring=docstring 수정
INSP.docstring.types.change.type={0} 유형을 {1}에서 {2}(으)로 변경
INSP.interpreter.configure.python.interpreter=Python 인터프리터 구성
INSP.interpreter.interpreter.settings=인터프리터 설정
INSP.interpreter.use.interpreter={0} 사용
INSP.interpreter.use.suggested.interpreter=제안된 인터프리터 사용
INSP.method.parameters.metaclass.method.first.argument.name=메타 클래스 메서드 첫 번째 인수 이름

INSP.package.requirements.requirements.have.been.ignored=요구 사항이 무시되었습니다.
INSP.package.requirements.requirement.has.been.ignored=''{0}'' 이(가) 무시되었습니다.
INSP.package.requirements.add.import=import 문 추가
INSP.package.requirements.administrator.privileges.required=관리자 권한 필요
INSP.package.requirements.administrator.privileges.required.description=''{0}''로 패키지를 설치하려면 관리자 권한이 필요합니다.\n\
\n\
파일 시스템의 보호된 영역에 프로젝트를 설치하지 않도록 프로젝트별 가상 환경을 프로젝트 인터프리터로 구성하세요.
INSP.package.requirements.administrator.privileges.required.button.configure=구성
INSP.package.requirements.administrator.privileges.required.button.install.anyway=그래도 설치
INSP.package.requirements.requirements.file.empty=요구 사항 파일이 비어 있습니다.
QFIX.add.imported.packages.to.requirements=요구 사항에 가져온 패키지 추가...

INSP.pep8.ignore.base.class=기본 클래스 무시
INSP.pep8.ignore.method.names.for.descendants.of.class=하위 클래스에 대한 메서드 이름 무시
INSP.stub.packages.compatibility.ignore=''{0}'' 호환성 무시
INSP.stub.packages.compatibility.ignored.packages=무시한 스텁 패키지
INSP.stub.packages.compatibility.incompatible.packages.message=''{0}{1}{2}''은(는) ''{3}{4}{5}''와(과) 호환되지 않습니다. ''{6}'' 버전이 필요합니다\: [{7}]
INSP.arguments.not.declared.but.provided.by.decorator=다음 인수가 선언되지 않지만 데코레이터에 의해 제공됩니다\: {0}
INSP.pep8.coding.style.violation=PEP 8 코딩 스타일 위반
INSP.shadowing.names=외부 범위로부터 이름 가림
INSP.stub.packages.compatibility=스텁 패키지 호환성 검사
INSP.stub.packages=스텁 패키지 애드버타이저

# PyCallingNonCallableInspection
INSP.NAME.calling.non.callable=호출할 수 없는 객체를 호출하려고 합니다.
INSP.class.object.is.not.callable=''''{0}'' 객체를 호출할 수 없습니다
INSP.symbol.is.not.callable=''{0}'' 을(를) 호출할 수 없습니다
INSP.expression.is.not.callable=표현식을 호출할 수 없습니다

# PyArgumentListInspection
INSP.NAME.incorrect.call.arguments=잘못된 호출 인수
INSP.unexpected.arg=예기치 않은 인수
INSP.unexpected.arg(s)=예기치 않은 인수
INSP.parameter.unfilled=매개변수 ''{0}'' 이(가) 채워지지 않았습니다.
INSP.parameter(s).unfilled=매개변수가 채워지지 않았습니다.
INSP.possible.callees=가능한 피호출자
INSP.function.lacks.positional.argument=함수 ''{0}''에 위치 인수가 부족합니다.
INSP.expected.dict.got.type=Expected a dictionary,got {0}
INSP.expected.iterable.got.type=Expected an iterable,got {0}

# PyMethodParametersInspection
INSP.NAME.problematic.first.parameter=첫 번째 매개변수에 문제가 있는 메서드
INSP.must.have.first.parameter=Method must have a first parameter,usually called ''{0}''
INSP.probably.mistyped.self=''self''가 아닙니까?
INSP.usually.named.self=일반적으로 메서드의 첫 번째 매개변수는 ''self''로 이름이 지정됩니다.
INSP.usually.named=일반적으로 이러한 메서드의 첫 번째 매개변수는 ''{0}''로 이름이 지정됩니다.
INSP.first.param.must.not.be.tuple=비 static 메서드의 첫 번째 매개변수는 튜플이 아니어야 합니다

# PyNestedDecoratorsInspection
INSP.NAME.nested.decorators=데코레이터의 문제 있는 중첩
INSP.decorator.receives.unexpected.builtin=이 데코레이터는 기대하는 호출 가능한 객체를 받지 않으며, 기본 제공 데코레이터가 특수 객체를 반환합니다.

# PyRedeclarationInspection
INSP.NAME.redeclaration=사용되지 않고 다시 선언된 이름
INSP.redeclared.name=위에서 정의된 ''{0}'' 이(가) 사용되지 않고 다시 선언되었습니다.

# PyUnresolvedReferencesInspection
INSP.try.except.import.error=''except ImportError''가 있는 try 블록의 ''{0}'' 이(가) except 블록 안에서도 정의되어야 합니다.
INSP.unused.import.statement=Declaración import obsoleta <code>\#ref</code>

# PyInterpreterInspection
INSP.NAME.invalid.interpreter=유효하지 않은 인터프리터가 구성되었습니다.
INSP.interpreter.pipenv.interpreter.associated.with.another.project=Pipenv 인터프리터가 다른 프로젝트와 연결되어 있습니다\: ''{0}''
INSP.interpreter.pipenv.interpreter.associated.with.another.module=Pipenv 인터프리터가 다른 모듈과 연결되어 있습니다\: ''{0}''
INSP.interpreter.pipenv.interpreter.not.associated.with.any.project=Pipenv 인터프리터가 모든 프로젝트와 연결되어 있습니다
INSP.interpreter.pipenv.interpreter.not.associated.with.any.module=Pipenv 인터프리터가 다른 모듈과 연결되어 있습니다
INSP.interpreter.invalid.python.interpreter.selected.for.project=프로젝트에 유효하지 않은 Python 인터프리터가 선택됨
INSP.interpreter.invalid.python.interpreter.selected.for.module=모듈에 유효하지 않은 Python 인터프리터가 선택됨
INSP.interpreter.python.has.reached.its.end.of.life.and.is.no.longer.supported.in.pycharm=Python {0} 이(가) 지원 종료일에 도달했으며 PyCharm에서 더 이상 지원되지 않습니다
INSP.interpreter.python.has.reached.its.end.life.and.is.no.longer.supported.in.python.plugin=Python {0} 이(가) 지원 종료일에 도달했으며 PyCharm 플러그인에서 더 이상 지원되지 않습니다
INSP.interpreter.no.python.interpreter.configured.for.project=프로젝트에 대해 구성된 Python 인터프리터가 없습니다
INSP.interpreter.no.python.interpreter.configured.for.module=모듈에 대해 구성된 Python 인터프리터가 없습니다

# ReturnValueFromInitInspection
INSP.NAME.init.return=값을 반환하는 __init__ 메서드
INSP.cant.return.value.from.init=__init__에서 값을 반환할 수 없습니다.

# PyUnreachableCodeInspection
INSP.NAME.unreachable.code=사용할 수 없는 코드
INSP.unreachable.code=이 코드에 도달할 수 없습니다.

# PyStringFormatInspection
INSP.NAME.str.format=문자열 서식 지정 작업 오류
INSP.format.requires.no.mapping=형식에는 매핑이 필요하지 않습니다.
INSP.str.format.key.has.no.argument=키 ''{0}''에 해당 인수가 없습니다.
INSP.str.format.unexpected.argument.type=예기치 않은 유형 {0}
INSP.too.few.keys=매핑 키가 너무 적습니다.
INSP.no.format.specifier.char=형식 지정자 문자가 누락되었습니다.
INSP.format.requires.mapping=형식에는 매핑이 필요합니다.
INSP.too.many.args.for.fmt.string=형식 문자열에 대한 인수가 너무 많습니다.
INSP.too.few.args.for.fmt.string=형식 문자열에 대한 인수가 너무 적습니다.
INSP.incompatible.options=청크 "{0}"의 형식 옵션이 호환되지 않습니다.
INSP.unsupported.format.character=지원되지 않는 형식 문자 ''{0}''
INSP.manual.to.auto.field.numbering=No puede cambiar a la notación automática del número de campo en las especificaciones de campo manual.
INSP.auto.to.manual.field.numbering=자동 필드 번호 표기에서 수동 필드 사양으로 전환할 수 없습니다.
INSP.str.format.unsupported.format.character.b=지원되지 않는 형식 문자 ''b''
INSP.str.format.can.not.use.star.in.formats.when.using.mapping=매핑을 사용할 경우 형식에 ''*''를 사용할 수 없음

# PyMethodOverridingInspection
INSP.NAME.method.over=메서드 시그니처가 재정의된 메서드의 시그니처와 일치하지 않습니다.
INSP.signature.mismatch=메서드 ''{0}''의 시그니처가 클래스 ''{1}'' 기본 메서드의 시그니처와 일치 하지 않습니다.

# PyInitNewSignatureInspection
INSP.NAME.new.init.signature=호환되지 않는 __new__ 및 __init__ 시그니처
INSP.new.incompatible.to.init=시그니처가 __init__로 호환되지 않습니다. 
INSP.init.incompatible.to.new=시그니처가 __new__로 호환되지 않습니다. 

# PyTrailingSemicolonInspection
INSP.NAME.trailing.semicolon=명령문 내 후행 세미콜론


# PyUnboundLocalVariableInspection
INSP.NAME.unbound=바인딩되지 않은 지역 변수
INSP.unbound.local.variable=지역 변수 ''{0}'' 이(가) 할당 전에 참조될 수 있습니다.
INSP.unbound.nonlocal.variable=비지역 변수 ''{0}''을(를) 외부 함수 범위에 바인딩해야 합니다.
INSP.unbound.name.undefined=이름 ''{0}'' 이(가) undefined일 수 있습니다.
INSP.unbound.function.too.large=함수 ''{0}'' 이(가) 너무 커서 분석할 수 없습니다.

# PyListCreationInspection
INSP.NAME.list.creation=리스트 생성을 리스트 리터럴로 다시 작성할 수 있습니다.
INSP.list.creation.this.list.creation.could.be.rewritten.as.list.literal=리스트 생성을 리스트 리터럴로 다시 작성할 수 있습니다

# PyTupleAssignmentBalanceInspection
INSP.NAME.tuple.assignment.balance=튜플 할당 밸런스가 올바르지 않습니다.
INSP.tuple.assignment.balance.only.one.starred.expression.allowed.in.assignment=할당에 하나의 별표 표현식만 허용됨
INSP.tuple.assignment.balance.need.more.values.to.unpack=패킹 해제할 값이 더 필요합니다
INSP.tuple.assignment.balance.too.many.values.to.unpack=패킹 해제할 값이 너무 많음

# PyClassicStyleClassInspection
INSP.NAME.classic.class.usage=클래식 스타일 클래스 사용 위치
INSP.classic.class.usage.old.style.class=이전 스타일 클래스
INSP.classic.class.usage.old.style.class.ancestors=Old-style class,because all classes from whom it inherits are old-style


# PyExceptionInheritance
INSP.NAME.exception.not.inherit=예외는 표준 ''Exception'' 클래스를 상속해 있지 않습니다.
INSP.exception.inheritance.exception.does.not.inherit.from.base.exception.class=예외는 기본 ''Exception'' 클래스를 상속하지 않습니다

# PyDefaultArgumentInspection
INSP.NAME.default.argument=디폴트 인수는 변경 가능합니다.
INSP.default.arguments.default.argument.value.mutable=기본 인수 값은 변경 가능합니다

# PyDocstringTypesInspection
INSP.NAME.docstring.types=docstring의 유형이 추론 유형과 일치하지 않습니다.
INSP.docstring.types.dynamically.inferred.type.does.not.match.specified.type=동적 추론 유형 ''{0}'' 이(가) 지정된 유형 ''{1}'' 와(과) 일치하지 않습니다

# PyStatementEffectInspection
INSP.NAME.statement.effect=명령문이 영향을 주지 않습니다.
INSP.statement.effect.statement.seems.to.have.no.effect=명령문이 아무 영향을 미치지 않는 것으로 보입니다.
INSP.statement.effect.statement.having.no.effect.can.be.replaced.with.function.call=구문은 아무 효과가 없는 듯 보이며 효과를 발휘하기 위해 함수 호출로 교체할 수 있습니다

# PyStringExceptionInspection
INSP.NAME.raising.string.exception=문자열 예외 발생

# PySuperArgumentsInspection
INSP.NAME.wrong.super.arguments=잘못된 super 호출 인수
INSP.class.is.not.subtype.of.class=''{0}'' 이(가) ''{1}''의 인스턴스 또는 하위 클래스가 아닙니다.

# PyNonAsciiCharInspection
INSP.NAME.non.ascii=파일이 ASCII가 아닌 문자를 포함합니다.
INSP.non.ascii.char.non.ascii.character.in.file.but.no.encoding.declared=파일에 ASCII 문자가 아닌 글자 ''{0}'' 이(가) 있으나 선언된 인코딩이 없습니다

# PyMandatoryEncodingInspection
INSP.NAME.mandatory.encoding=파일에 대해 지정된 인코딩이 없습니다.
INSP.mandatory.encoding.label.encoding.comment.format=주석 형식 인코딩\:
INSP.mandatory.encoding.label.select.default.encoding=기본 인코딩 선택\:
INSP.mandatory.encoding.checkbox.enable.in.python.3=Python 3+에서 활성화
INSP.mandatory.encoding.no.encoding.specified.for.file=파일에 대해 지정된 인코딩이 없습니다.

# PyTupleItemAssignmentInspection
INSP.NAME.tuple.item.assignment=튜플 항목 할당
INSP.tuples.never.assign.items=Tuple이 항목 할당을 지원하지 않습니다.

# PyPropertyAccessInspection
INSP.NAME.property.access=프로퍼티에 대한 액세스
INSP.property.cannot.be.set=프로퍼티 ''{0}''을(를) 설정할 수 없습니다.
INSP.property.cannot.be.read=프로퍼티 ''{0}''을(를) 읽을 수 없습니다.
INSP.property.cannot.be.deleted=프로퍼티 ''{0}''을(를) 삭제할 수 없습니다.

# PyPropertyDefinitionInspection
INSP.NAME.property.definition=프로퍼티 정의
INSP.doc.param.should.be.str=doc 매개변수는 문자열이어야 합니다.
INSP.strange.arg.want.callable=이상한 인수; 호출 가능한 인수가 필요합니다
INSP.func.property.name.mismatch=함수 및 데코레이터 이름이 일치하지 않습니다. 프로퍼티 접근자가 생성되지 않았습니다.
INSP.getter.return.smth=getter가 무언가 반환하거나 산출해야합니다
INSP.setter.should.not.return=세터는 값을 반환해지 않아야 합니다.
INSP.deleter.should.not.return=삭제자는 값을 반환하지 않아야 합니다.
INSP.getter.signature.advice=getter 시그니처는 (self)이어야 합니다
INSP.setter.signature.advice=Setter signature should be (self,value)
INSP.deleter.signature.advice=삭제자 시그니처는 (self)이어야 합니다.

# PyProtectedMemberInspection
INSP.NAME.protected.member=클래스 또는 모듈의 보호된 멤버에 대한 액세스
INSP.protected.member.access.to.protected.member.of.class=\ 클래스의 protected 멤버 {0}에 대한 액세스
INSP.protected.member.access.to.protected.member.of.module=\ 모듈의 protected 멤버 {0}에 대한 액세스
INSP.protected.member.name.not.declared.in.all=''{0}'' 이(가) __all__ 에 선언되어 있지 않습니다

# PyOldStyleClassesInspection
INSP.NAME.oldstyle.class=이전 스타일 클래스가 새로운 스타일의 클래스 기능을 포함합니다.
INSP.oldstyle.class.slots=이전 스타일 클래스가 __slots__ 정의를 포함합니다.
INSP.oldstyle.class.getattribute=이전 스타일 클래스가 __getattribute__ 정의를 포함합니다.
INSP.oldstyle.class.super=이전 스타일 클래스가 상위 메서드 호출을 포함합니다.

# PyCompatibilityInspection
INSP.NAME.compatibility=코드 호환성 검사
INSP.compatibility.this.syntax.available.only.since.py3=이 구문은 py3 이후에서만 사용할 수 있습니다.
INSP.compatibility.check.for.compatibility.with.python.versions=Python 버전과의 호환성을 확인하세요\:
INSP.compatibility.inspection.unsupported.feature.prefix=Python {0,choice,1\#버전|2\#버전}은 {1} 은(는) {2} 을(를) {0,choice,1\#하지|2\#하지} 않습니다
INSP.compatibility.feature.support.variable.annotations=변수 어노테이션 지원
INSP.compatibility.feature.support.this.syntax=이 구문 지원
INSP.compatibility.feature.have.module.builtins=기본 제공 모듈 있음
INSP.compatibility.feature.have.module.builtin=모듈 __builtin__ 있음
INSP.compatibility.feature.support.starred.expressions.as.assignment.targets=할당 대상으로 별표 표현식 지원
INSP.compatibility.feature.support.starred.expressions.in.tuples.lists.and.sets=튜플, 리스트, 집합 내 별표 표현식 지원
INSP.compatibility.feature.support.unpacking.without.parentheses.in.return.statements=return 문에서 소괄호 없이 패킹 해제 지원
INSP.compatibility.feature.support.unpacking.without.parentheses.in.yield.statements=yield 문에서 소괄호 없이 패킹 해제 지원
INSP.compatibility.feature.support.starred.expressions.in.dicts=사전 내 별표 표현식 지원
INSP.compatibility.feature.support.diamond.operator=<> 지원, 대신 \!\= 사용
INSP.compatibility.feature.support.matrix.multiplication.operators=행렬 곱셈 연산자 지원
INSP.compatibility.feature.support.long.integer.literal.suffix=후행 ''{0}'' 지원
INSP.compatibility.feature.support.old.style.octal.literals=이 구문을 지원합니다. 8진 리터널에 ''0o'' 접두사가 필요합니다
INSP.compatibility.feature.support.underscores.in.numeric.literals=숫자 리터럴에서 밑줄 지원
INSP.compatibility.feature.support.string.literal.prefix=''{0}'' 접두사 지원
INSP.compatibility.feature.allow.to.mix.bytes.and.non.bytes.literals=바이트 리터럴과 비바이트 리터럴 혼용 허용
INSP.compatibility.feature.support.this.syntax.in.list.comprehensions=리스트 내포 내 이 구문 지원
INSP.compatibility.feature.support.raise.with.no.arguments.outside.except.block=이 구문을 지원합니다. 인수 없이 발생은 except 블록에서만 사용할 수 있습니다
INSP.compatibility.feature.support.backquotes=역따옴표 지원, 대신 repr() 사용
INSP.compatibility.feature.support.print.statement=이 구문을 지원합니다. print 문이 print() 함수로 교체되었습니다
INSP.compatibility.feature.support.super.without.arguments=이 구문을 지원합니다. super() 문은 Python 2에서 인수를 취해야 합니다
INSP.compatibility.py35.does.not.support.yield.inside.async.functions=Python 버전 3.5는 비동기 함수 내부에서 ''yield''를 지원하지 않습니다
INSP.compatibility.feature.support.yield.from=이 구문을 지원합니다. ''서브 생성기에 위임''은 Python 3.3 이후 버전에서 사용할 수 있습니다. 대신 ''서브 생성기에서 명시적 반복''을 사용하세요.
INSP.compatibility.pre35.versions.do.not.allow.return.with.argument.inside.generator=Python 버전 3.3 이하는 생성기 내부에서 인수를 가진 ''return''을 허용하지 않습니다
INSP.compatibility.feature.support.ellipsis.outside.slices=시퀀스 슬라이싱 외부의 ''...'' 지원
INSP.compatibility.feature.have.nonlocal.keyword=로컬이 아닌 키워드 있음
INSP.compatibility.keyword.argument.repeated=키워드 인수 반복됨
INSP.compatibility.feature.allow.keyword.arguments.after.kwargs=**표현식 뒤 키워드 인수 허용
INSP.compatibility.feature.allow.duplicate.kwargs=중복 **표현식 허용
INSP.compatibility.feature.allow.duplicate.positional.varargs=중복 **표현식 허용
INSP.compatibility.feature.allow.positional.arguments.after.expression=*표현식 뒤 위치 인수 허용
INSP.compatibility.positional.argument.after.keyword.argument=키보드 인수 뒤 위치 인수
INSP.compatibility.positional.argument.after.kwargs=**표현식 뒤 키워드 위치 인수
INSP.compatibility.feature.allow.trailing.comma.after.kwargs=**표현식 뒤 키워드 후행 쉼표
INSP.compatibility.feature.allow.trailing.comma.after.positional.vararg=*표현식 뒤 위치 후행 쉼표
INSP.compatibility.py35.does.not.support.async.inside.comprehensions.and.generator.expressions=Python 버전 3.5는 내포 및 생성기 표현식 내부에서 ''async''를 지원하지 않습니다
INSP.compatibility.py35.does.not.support.await.inside.comprehensions=Python 버전 3.5는 내포 내부에서 ''await''를 지원하지 않습니다
INSP.compatibility.feature.support.positional.only.parameters=위치 전용 매개변수 지원
INSP.compatibility.support.equality.signs.in.fstrings=f 문자열에 상등 기호 지원
INSP.compatibility.feature.support.assignment.expressions=할당 표현식 지원
INSP.compatibility.feature.support.continue.inside.finally.clause=''finally'' 절 내부에 ''continue'' 지원
INSP.compatibility.feature.support.arbitrary.expressions.as.decorator=데코레이터로 임의 표현식 지원
INSP.compatibility.feature.have.type.long=유형이 long입니다. 대신 int 를 사용하세요.
INSP.compatibility.feature.have.method=메서드 {0} 있음
INSP.compatibility.feature.have.module=모듈 {0} 있음
INSP.compatibility.feature.allow.async.and.await.as.names=''async'' 및 ''await''를 이름으로 허용
INSP.compatibility.old.dict.methods.not.available.in.py3=dict.iterkeys(), dict.iteritems() 및 dict.itervalues() 메서드는 Python 3에서 사용할 수 없습니다
INSP.compatibility.basestring.type.not.available.in.py3=basestring 유형은 Python3에서 사용할 수 없습니다

# PyUnnecessaryBackslashInspection
INSP.NAME.unnecessary.backslash=불필요한 백슬래시
INSP.unnecessary.backslash.unnecessary.backslash.in.expression=표현식 내 불필요한 백슬래시

# PySingleQuotedDocstringInspection
INSP.NAME.single.quoted.docstring=작은 따옴표 docstring
INSP.message.single.quoted.docstring=삼중 작은 따옴표 문자열이 docstrings에 사용되어야 합니다.

# PyMissingConstructorInspection
INSP.NAME.missing.super.constructor=누락된 상위 클래스 __init__ 호출
INSP.missing.super.constructor.message=상위 클래스 __init__ 호출이 누락되었습니다.

# PySetFunctionToLiteralInspection
INSP.NAME.set.function.to.literal=함수 호출을 집합 리터럴로 바꿀수 있습니다.

# PyDecoratorInspection
INSP.NAME.decorator.outside.class=클래스 외부 메서드의 클래스 특수 데코레이터
INSP.decorators.method.only.decorator.on.method.outside.class=클래스 외부 메서드의 데코레이터 {0}

# PyPackageRequirementsInspection
INSP.NAME.requirements=패키지 요구 사항
INSP.requirements.column.name.ignore.packages=패키지 무시
INSP.requirements.package.requirements.not.satisfied=패키지 {1,choice,1\#요구사항|2\#요구사항} {0} {1,choice,1\#이(가)|2\#이(가)} 만족되지 않았습니다
INSP.requirements.package.containing.module.not.listed.in.project.requirements=모듈 ''{0}'' 을(를) 포함하는 패키지는 프로젝트 요구사항 목록에 포함되어 있지 않습니다
QFIX.NAME.install.requirements={0,choice,1\#요구사항|2\#요구사항} 설치
QFIX.NAME.ignore.requirements={0,choice,1\#요구사항|2\#요구사항} 무시

# PyClassHasNoInitInspection
INSP.NAME.class.has.no.init=클래스에 __init__ 메서드가 없습니다.
INSP.class.has.no.init=클래스에 __init__ 메서드가 없습니다.

#PyNoneFunctionAssignmentInspection
INSP.NAME.none.function.assignment=아무 것도 반환하지 않는 함수 호출 할당
INSP.none.function.assignment=함수 ''{0}'' 이(가) 아무것도 반환하지 않습니다.

# PyTestParametrizedInspection
INSP.NAME.pytest-parametrized=pytest parametrize로 장식된 함수에 올바른 인수가 있는지 확인합니다.

# PyUnusedLocalInspection
INSP.NAME.unused=사용되지 않는 로컬
INSP.unused.locals.parameter.isnot.used=매개변수 ''{0}'' 값이 사용되지 않습니다.
INSP.unused.locals.local.variable.isnot.used=지역 변수 ''{0}'' 값이 사용되지 않습니다.
INSP.unused.locals.replace.with.wildcard=_로 바꾸기 
INSP.unused.locals.local.function.isnot.used=지역 함수 ''{0}'' 이(가) 사용되지 않습니다.
INSP.unused.locals.local.class.isnot.used=지역 클래스 ''{0}'' 이(가) 사용되지 않습니다.

INSP.unused.locals.ignore.variables.starting.with=''_''로 시작하는 변수 무시
INSP.unused.locals.ignore.range.iteration.variables=범위 반복 변수 무시
INSP.unused.locals.ignore.lambda.parameters=람다 매개변수 무시
INSP.unused.locals.ignore.variables.used.in.tuple.unpacking=튜플 풀기에 사용되는 변수 무시

# PyChainedComparsonsInspection
INSP.NAME.chained.comparisons=체인 비교를 간소화할 수 있습니다.
INSP.chained.comparisons.ignore.statements.with.constant.in.the.middle=중간에 상수가 있는 구문 무시
INSP.simplify.chained.comparison=체인 비교 간소화

# PyAugmentAssignmentInspection
INSP.NAME.augment.assignment=할당을 증강 할당으로 바꿀수 있습니다.
INSP.assignment.can.be.replaced.with.augmented.assignment=할당을 증강 할당으로 바꿀수 있습니다.

# PyBroadExceptionInspection
INSP.NAME.too.broad.exception.clauses=너무 광범위한 예외 절
INSP.too.broad.exception.clause=너무 광범위한 예외 절

# PyByteLiteralInspection
INSP.NAME.byte.literal=바이트 리터럴이 255개 이상의 문자를 포함합니다.
INSP.byte.literal.contains.illegal.characters=바이트 리터럴이 255개 이상의 문자를 포함합니다

# PyComparisonWithNoneInspection
INSP.NAME.comparison.with.none=상등 연산자로 수행된 None과의 비교
INSP.comparison.with.none.performed.with.equality.operators=상등 연산자로 수행된 None과의 비교

# PyDictCreationInspection
INSP.NAME.dict.creation=사전 생성을 사전 리터럴로 다시 작성할 수 있습니다.
INSP.dict.creation.this.dictionary.creation.could.be.rewritten.as.dictionary.literal=사전 생성을 사전 리터럴로 다시 작성할 수 있습니다

# PyDictDuplicateKeysInspection
INSP.NAME.duplicate.keys=사전이 중복 키를 포함합니다.
INSP.duplicate.keys.dictionary.contains.duplicate.keys=사전이 중복 키 ''{0}'' 을(를) 포함합니다 

# PyFromFutureImportInspection
INSP.NAME.from.future.import=from __future__ import가 첫 번째 실행 명령문이어야 합니다.
INSP.from.future.import.from.future.imports.must.occur.at.beginning.file=from __future__ import는 파일 시작 부분에 실행되어야 합니다

# PyMethodFirstArgAssignmentInspection
INSP.NAME.first.arg.assign=메서드 첫 번째 인수 재할당
INSP.first.arg.assign.method.parameter.reassigned=메서드 매개변수 ''{0}'' 이(가) 다시 할당되었습니다.

# PyMethodMayBeStaticInspection
INSP.NAME.method.may.be.static=메서드가 static일 수 있습니다.
INSP.method.may.be.static=메서드 <code>\#ref</code>가 ''static''일 수 있습니다.

# PyAbstractClassInspection
INSP.NAME.abstract.class=클래스는 모든 추상 메서드를 구현해야 합니다.
INSP.abstract.class.class.must.implement.all.abstract.methods=클래스 {0} 이(가) 모든 추상 메서드를 구현해야 합니다.

#PyAssignmentToLoopOrWithParameterInspection
INSP.NAME.assignment.to.loop.or.with.parameter=''for'' 루프 또는 ''with'' 문 매개변수에 할당
INSP.assignment.to.loop.or.with.parameter=변수 ''{0}'' 이(가) 이미 위의 ''for'' 루프 또는 ''with'' 문에서 선언되었습니다.

# PyArgumentEqualDefaultInspection
INSP.NAME.argument.equal.default=함수에 전달된 인수가 디폴트 매개변수 값과 같습니다.
INSP.argument.equals.to.default=인수가 디폴트 매개변수 값과 같습니다.

#PyAsyncCallInspection
INSP.NAME.coroutine.is.not.awaited=코루틴 ''{0}'' 은(는) 대기하고 있지 않습니다. 
INSP.async.call=코루틴은 대기하고 있지 않습니다.

# PyAttributeOutsideInitInspection
INSP.NAME.attribute.outside.init=인스턴스 속성이 __init__ 외부에 정의되었습니다.
INSP.attribute.outside.init=__init__ 외부에 정의된 인스턴스 속성 {0}  

# PyMissingOrEmptyDocstringInspection
INSP.NAME.missing.or.empty.docstring=누락되었거나 빈 docstring
INSP.no.docstring=누락된 docstring
INSP.empty.docstring=빈 docstring

# PyUnresolvedReferencesInspection
INSP.NAME.unresolved.refs=해결되지 않는 참조
INSP.unresolved.refs.module.not.found=모듈 ''{0}''을(를) 찾을 수 없습니다.
INSP.unresolved.refs.unresolved.reference=확인되지 않은 참조 ''{0}''
INSP.unresolved.refs.unresolved.attribute.for.class=확인되지 않은 ''{1}'' 클래스 속성 참조 ''{0}''
INSP.unresolved.refs.cannot.find.reference.in.type=''{1}''에서 참조 ''{0}''을(를) 찾을 수 없습니다.
INSP.unresolved.refs.class.object.has.no.attribute=''{0}'' 객체에 인수 ''{1}'' 이(가) 있습니다
INSP.unresolved.refs.import.resolves.to.its.containing.file=가져오기는 그것을 포함하는 파일로 해결됩니다
INSP.unresolved.refs.class.does.not.define.operator=클래스 ''{0}'' 이(가) ''{1}''을(를) 정의하지 않기 때문에 ''{2}'' 연산자를 인스턴스에서 사용할 수 없습니다.
INSP.unresolved.refs.column.name.ignore.references=참조 무시
unresolved.docstring.param.reference=함수 ''{0}'' 에 매개변수 ''{1}'' 이(가) 없습니다
unresolved.import.reference=이름이 ''{0}'' 인 모듈 없음

python.stub=Python 스텁

# PyRedundantParenthesesInspection
INSP.NAME.redundant.parentheses=불필요한 소괄호
INSP.redundant.parens.ignore.empty.lists.of.base.classes=기본 클래스의 빈 리스트 무시
INSP.redundant.parens.ignore.tuples=투플 무시
INSP.redundant.parens.ignore.argument.of.operator=% 연산자 인수 무시

# PySimplifyBooleanCheckInspection
INSP.NAME.check.can.be.simplified=부울 변수 검사를 단순화할 수 있습니다.
INSP.expression.can.be.simplified=표현식을 단순화할 수 있습니다.
INSP.simplify.boolean.check.ignore.comparison.to.zero=0에 대한 비교 무시

# PyIncorrectDocstringInspection
INSP.NAME.incorrect.docstring=잘못된 docstring
INSP.missing.parameter.in.docstring=docstring 내 누락된 매개변수 {0}
INSP.unexpected.parameter.in.docstring=docstring 내 예기치 않은 매개변수

# PyExceptClausesOrderInspection
INSP.NAME.bad.except.clauses.order=잘못된 except 절 순서
INSP.bad.except.exception.class.already.caught=예외 클래스 ''{0}'' 이(가) 이미 포착되었습니다.
INSP.bad.except.superclass.of.exception.class.already.caught=''{0}'',superclass of exception class ''{1}'',has already been caught

#PyGlobalUndefinedInspection
INSP.NAME.global.undefined=전역 변수가 모듈 수준에서 undefined입니다.
INSP.global.variable.undefined=전역 변수 ''{0}'' 이(가) 모듈 수준에서 undefined입니다.

#PyDataclassInspection
INSP.NAME.dataclass.definition.and.usages=데이터클래스 정의 및 사용 위치
INSP.dataclasses.operator.not.supported.between.instances.of.class=''{1}'' 인스턴스 사이의 ''{0}'' 은(는) 지원되지 않음
INSP.dataclasses.operator.not.supported.between.instances.of.classes=''{1}'' 및 ''{2}'' 인스턴스 사이의 ''{0}'' 은(는) 지원되지 않음
INSP.dataclasses.object.could.have.no.attribute.because.it.declared.as.init.only=''{0}'' 객체는 초기화 전용으로 선언되어 속성 ''{1}'' 을(를) 취하지 않을 수 있습니다
INSP.dataclasses.object.attribute.read.only=''{0}'' 객체 속성 ''{1}'' 이(가) 읽기 전용입니다
INSP.dataclasses.eq.must.be.true.if.order.true=''order''가 참인 경우 ''eq''는 true여야 합니다
INSP.dataclasses.argument.ignored.if.class.already.defines.method=클래스가 이미 ''{1}'' 메서드를 정의하는 경우 ''{0}'' 이(가) 무시됩니다
INSP.dataclasses.order.argument.should.be.false.if.class.defines.one.of.order.methods=클래스가 order 메서드 중 하나를 정의하는 경우 ''order''가 false여야 합니다
INSP.dataclasses.frozen.attribute.should.be.false.if.class.defines.setattr.or.delattr=클래스가 ''__setattr__'' 또는 ''__delattr__''를 정의하는 경우 ''frozen''이 false여야 합니다
INSP.dataclasses.unsafe.hash.attribute.should.be.false.if.class.defines.hash=클래스가 ''__hash__''를 정의하는 경우 ''unsafe_hash''가 false여야 합니다
INSP.dataclasses.frozen.dataclasses.can.not.inherit.non.frozen.one=데이터 클래스와 동결되지 않은 클래스는 서로를 상속할 수 없습니다
INSP.dataclasses.method.is.ignored.if.class.already.defines.parameter=클래스가 이미 ''{1}'' 매개변수를 정의하는 경우 ''{0}'' 이(가) 무시됩니다
INSP.dataclasses.hash.ignored.if.class.already.defines.cmp.or.order.or.frozen.parameters=클래스가 이미 ''cmp/order'' 및 ''frozen'' 매개변수를 정의하는 경우 ''__hash__'' 이(가) 무시됩니다
INSP.dataclasses.mutable.attribute.default.not.allowed.use.default.factory=변경 가능한 기본값 ''{0}'' 은(는) 허용되지 않습니다. ''default_factory''를 사용하세요
INSP.dataclasses.attribute.default.is.set.using.attr.ib=기본값은 ''attr.ib()''를 사용하여 설정됩니다
INSP.dataclasses.attribute.default.set.using.method=기본값은 ''{0}'' 을(를) 사용하여 설정됩니다
INSP.dataclasses.method.should.take.only.n.parameter=''{0}'' 은(는) {1} {1, choice,1\#매개변수|2\#매개변수}만을 취해야 합니다
INSP.dataclasses.attribute.lacks.type.annotation=속성 ''{0}'' 에 유형 어노테이션이 없습니다
INSP.dataclasses.cannot.specify.both.default.and.factory=''default'' 및 ''factory'' 둘 다 지정할 수 없음
INSP.dataclasses.attribute.useless.until.post.init.declared=속성 ''{0}'' 은(는) ''__post_init__''가 선언되기 전까지 쓸모가 없습니다
INSP.dataclasses.field.cannot.have.default.factory=필드는 기본 팩토리를 취할 수 없습니다
INSP.dataclasses.cannot.specify.both.default.and.default.factory=''default'' 및 ''default_factory'' 둘 다 지정할 수 없음
INSP.dataclasses.post.init.would.not.be.called.until.init.parameter.set.to.true=''__post_init__''은 ''init'' 매개변수가 True로 설정되기 전까지 호출되지 않습니다
INSP.dataclasses.post.init.should.take.all.init.only.variables.including.inherited.in.same.order.they.defined=''__post_init__''는 모든 init 전용 변수(상속된 변수 포함)를 정의된 순서대로 받아들여야 합니다
INSP.dataclasses.post.init.should.take.all.init.only.variables.in.same.order.they.defined=''__post_init__''는 모든 init 전용 변수를 정의된 순서대로 받아들여야 합니다
INSP.dataclasses.attrs.post.init.would.not.be.called.until.init.parameter.set.to.true=''__attrs_post_init__''은 ''init'' 매개변수가 True로 설정되기 전까지 호출되지 않습니다
INSP.dataclasses.attrs.post.init.should.not.take.any.parameters.except.self=''__attrs_post_init__은 ''self''를 제외한 어떤 매개변수도 취할 수 없습니다
INSP.dataclasses.method.should.be.called.on.dataclass.instances.or.types=''{0}'' 메서드는 데이터 클래스 인스턴스 또는 유형에서 호출되어야 합니다
INSP.dataclasses.method.should.be.called.on.dataclass.instances=''{0}'' 메서드는 데이터 클래스 인스턴스에서 호출되어야 합니다
INSP.dataclasses.method.should.be.called.on.attrs.instances=''{0}'' 메서드는 속성 인스턴스에서 호출되어야 합니다
INSP.dataclasses.method.should.be.called.on.attrs.types=''{0}'' 메서드는 속성 유형에서 호출되어야 합니다

# PyHighlightingAnnotator
INSP.python.trailing.suffix.not.support=Python은 후행 ''{0}''을(를) 지원하지 않습니다.

# PyDeprecationInspection
INSP.NAME.deprecated.function.class.or.module=더 이상 사용되지 않는 함수, 클래스 또는 모듈
INSP.deprecation.abc.decorator.deprecated.use.alternative=''{0}'' 은(는) Python 3.3 이후 버전에서 더 이상 사용되지 않습니다. 대신 ''{2}'' 와(과) 함께 ''{1}'' 을(를) 사용하세요

# PyDunderSlotsInspection
INSP.NAME.dunder.slots=클래스 내 __slots__ 정의
INSP.dunder.slots.name.in.slots.conflicts.with.class.variable=__slots__의 ''{0}'' 은(는) 클래스 변수와 충돌합니다
INSP.dunder.slots.class.object.attribute.read.only=''{0}'' 객체 속성 ''{1}'' 이(가) 읽기 전용입니다

# PyFinalInspection
INSP.NAME.final.classes.methods.and.variables=final 클래스, 메서드 및 변수
INSP.final.super.classes.are.marked.as.final.and.should.not.be.subclassed={0} {1,choice,1\#은(는)|2\#은(는)} ''@final''로 표시되었으므로 하위 클래스가 될 수 없습니다
INSP.final.final.should.be.placed.on.first.overload=''@final''은 첫 번째 오버로드에 위치해야 합니다
INSP.final.method.marked.as.final.should.not.be.overridden=''{0} {choice,\#은(는)|\#은(는)} ''@final''로 표시되었으므로 덮어쓸 수 없습니다
INSP.final.final.should.be.placed.on.implementation=''@final''은 구현 위에 위치해야 합니다
INSP.final.final.could.not.be.mixed.with.abstract.decorators=''Final''은 추상 데코레이터와 함께 혼용할 수 없습니다
INSP.final.final.class.could.not.contain.abstract.methods=''Final'' 클래스는 추상 메서드를 포함할 수 없습니다
INSP.final.no.need.to.mark.method.in.final.class.as.final=''Final'' 클래스의 메서드를 ''@final''로 표시할 필요가 없음
INSP.final.non.method.function.could.not.be.marked.as.final=비 메서드 함수는 ''@final''로 표시될 수 없습니다
INSP.final.final.could.not.be.used.in.annotations.for.function.parameters=''Final''은 함수 매개변수의 어노테이션에서 사용할 수 없습니다
INSP.final.final.could.not.be.used.in.annotation.for.function.return.value=''Final''은 함수 반환 값의 어노테이션에서 사용할 수 없습니다
INSP.final.if.assigned.value.omitted.there.should.be.explicit.type.argument.to.final=할당된 값이 생략된 경우 ''Final''에 명시적 유형 인수가 있어야 합니다
INSP.final.final.name.should.be.initialized.with.value=''Final'' 이름은 값으로 초기화되어야 합니다
INSP.final.already.declared.name.could.not.be.redefined.as.final=이미 선언된 이름은 ''Final''로 재정의할 수 없습니다
INSP.final.either.instance.attribute.or.class.attribute.could.be.type.hinted.as.final=인스턴스 속성 또는 클래스 속성 중 하나를 ''Final''로 유형 힌트를 표시할 수 있습니다
INSP.final.final.attribute.could.not.be.overridden=''{0}'' 은(는) ''Final''이므로 재정의할 수 없습니다
INSP.final.final.attribute.should.be.declared.in.class.body.or.init=''Final'' 속성은 클래스 본문 또는 ''__init__'' 안에 선언되어야 합니다
INSP.final.final.target.could.not.be.reassigned=''{0}'' 은(는) ''Final''이므로 다시 할당할 수 없습니다
INSP.final.final.could.only.be.used.as.outermost.type=''Final''은 가장 바깥쪽 유형으로만 사용할 수 있습니다
INSP.final.final.could.not.be.used.inside.loop=''Final''은 루프 내부에서 사용할 수 없습니다

# PyInconsistentIndentationInspection
INSP.NAME.inconsistent.indentation=일관되지 않은 들여쓰기
INSP.inconsistent.indentation.mix.tabs.spaces=일관되지 않은 들여쓰기\: 탭과 공백 혼용
INSP.inconsistent.indentation.previous.line.used.tabs.this.line.uses.spaces=일관되지 않은 들여쓰기\: 이전 줄에서 탭 사용됨, 이 줄에서 공백 사용
INSP.inconsistent.indentation.previous.line.used.spaces.this.line.uses.tabs=일관되지 않은 들여쓰기\: 이전 줄에서 공백 사용됨, 이 줄에서 탭 사용

# PyMissingTypeHintsInspection
INSP.NAME.missing.type.hints=함수 정의에 대한 유형 힌트가 누락되었습니다.
INSP.missing.type.hints.type.hinting.missing.for.function.definition=함수 정의에 대한 유형 힌트가 누락되었습니다
INSP.missing.type.hints.add.type.hints=유형 힌트 추가
INSP.missing.type.hints.add.type.hints.for=''{0}''에 대한 유형 힌트 추가
INSP.missing.type.hints.checkbox.only.when.types.are.known=유형이 알려진 경우에만 (런타임에서 수집 또는 유추)

# PyOverloadsInspection
INSP.NAME.overloads.in.regular.python.files=일반 Python 파일의 오버로드
INSP.overloads.series.overload.decorated.methods.should.always.be.followed.by.implementation=일련의 @overload-decorated 메서드 다음에는 @overload-ed가 아닌 구현이 와야 합니다
INSP.overloads.series.overload.decorated.functions.should.always.be.followed.by.implementation=일련의 @overload-decorated 함수 다음에는 @overload-ed가 아닌 구현이 와야 합니다
INSP.overloads.this.method.overload.signature.not.compatible.with.implementation=이 @overload-decorated 메서드의 시그니처는 구현과 호환되지 않습니다
INSP.overloads.this.function.overload.signature.not.compatible.with.implementation=이 @overload-decorated 함수의 시그니처는 구현과 호환되지 않습니다

# PyPep8NamingInspection
INSP.NAME.pep8.naming=PEP 8 이름 지정 규칙 위반
INSP.pep8.naming.column.name.excluded.base.classes=제외된 기본 클래스
INSP.pep8.naming.column.name.ignored.errors=무시된 오류
QFIX.NAME.ignore.errors.like.this=이와 같은 오류 무시
INSP.pep8.naming.class.names.should.use.camelcase.convention=클래스 이름은 낙타 표기법(camelCase)을 사용해야 합니다
INSP.pep8.naming.function.name.should.be.lowercase=함수 이름은 소문자여야 합니다
INSP.pep8.naming.argument.name.should.be.lowercase=인수 이름은 소문자여야 합니다
INSP.pep8.naming.variable.in.function.should.be.lowercase=함수 내 변수는 소문자여야 합니다
INSP.pep8.naming.constant.variable.imported.as.non.constant=상수가 아닌 변수로 가져온 상수 변수
INSP.pep8.naming.lowercase.variable.imported.as.non.lowercase=소문자가 아닌 변수로 가져온 소문자 변수
INSP.pep8.naming.camelcase.variable.imported.as.lowercase=소문자 변수로 가져온 낙타 표기(camelCase) 변수
INSP.pep8.naming.camelcase.variable.imported.as.constant=상수로 가져온 낙타 표기(camelCase) 변수

# PyProtocolInspection
INSP.NAME.protocol.definition.and.usages=프로토콜 정의 및 사용 위치
INSP.protocol.all.bases.protocol.must.be.protocols=프로토콜의 모든 기본은 프로토콜이어야 합니다
INSP.protocol.only.runtime.checkable.protocols.can.be.used.with.instance.class.checks=인스턴스 및 클래스 검사에는 @runtime_checkable 프로토콜만 사용할 수 있습니다
INSP.protocol.newtype.cannot.be.used.with.protocol.classes=NewType은 프로토콜 클래스에 사용할 수 없습니다
INSP.protocol.element.type.incompatible.with.protocol=''{0}'' 의 유형은 ''{1}'' 와(과) 호환되지 않습니다

# PyShadowingBuiltinsInspection
INSP.NAME.shadowing.builtins=기본 가림
INSP.shadowing.builtins.shadows.built.in.name=기본 제공 이름 "{0}" 가리기
INSP.shadowing.builtins.column.name.ignore.built.ins=기본 제공 항목 무시
QFIX.NAME.ignore.shadowed.built.in.name=가려진 기본 제공 이름 무시
QFIX.ignore.shadowed.built.in.name=가려진 기본 제공 이름 "{0}" 무시

# PyTypeCheckerInspection
INSP.NAME.type.checker=유형 검사기
INSP.type.checker.expected.type.got.type.instead=유형 ''{0}'' 을(를) 기대했으나 대신 ''{1}'' 을(를) 받았습니다
INSP.type.checker.expected.to.return.type.got.no.return=''{0}'' 반환을 기대했으나 반환 값이 없습니다
INSP.type.checker.init.should.return.none=__init__는 None을 반환해야 합니다
INSP.type.checker.type.does.not.have.expected.attribute=유형 ''{0}'' 에 기대하는 {1,choice,1\#속성|2\#속성} {2} 이(가) 없습니다
INSP.type.checker.only.concrete.class.can.be.used.where.matched.protocol.expected=''{0}''(일치하는 제네릭 유형 ''{1}'') 프로토콜이 기대되는 곳에는 구체 클래스만 사용할 수 있습니다
INSP.type.checker.only.concrete.class.can.be.used.where.protocol.expected=''{0}'' 프로토콜이 기대되는 곳에는 구체 클래스만 사용할 수 있습니다
INSP.type.checker.expected.matched.type.got.type.instead=유형 ''{0}''(일치하는 제네릭 유형 ''{1}'') 을(를) 기대했으나 대신 ''{2}'' 을(를) 받았습니다
INSP.type.checker.unexpected.types.prefix=예기치 않은 유형\:
INSP.type.checker.expected.types.prefix=가능한 유형\:

# PyTypedDictInspection
INSP.NAME.typed.dict=TypedDict 정의 및 사용 위치
INSP.typeddict.typeddict.key.must.be.string.literal.expected.one=TypedDict 키는 문자열이어야 합니다; ({0}) 중 하나 기대
INSP.typeddict.typeddict.has.no.key=TypedDict "{0}" 에 키 ''{1}'' 이(가) 없습니다
INSP.typeddict.typeddict.has.no.keys=TypedDict "{0}" 에 키({1})가 없습니다
INSP.typeddict.first.argument.has.to.match.variable.name=첫 번째 인수는 변수 이름과 일치해야 합니다
INSP.typeddict.typeddict.cannot.inherit.from.non.typeddict.base.class=TypedDict는 TypedDict가 아닌 기본 클래스를 상속할 수 없습니다
INSP.typeddict.specifying.metaclass.not.allowed.in.typeddict=TypedDict에서는 메타 클래스 지정이 허용되지 않습니다
INSP.typeddict.cannot.overwrite.typeddict.field.while.merging=병합 도중 TypedDict 필드 ''{0}'' 을(를) 덮어쓸 수 없음
INSP.typeddict.invalid.statement.in.typeddict.definition.expected.field.name.field.type=TypedDict 정의 내 유효하지 않은 구문; ''field_name\: field_type'' 기대
INSP.typeddict.right.hand.side.values.are.not.supported.in.typeddict=TypedDict에서는 우측 값이 지원되지 않습니다
INSP.typeddict.cannot.overwrite.typeddict.field=TypedDict 필드를 덮어쓸 수 없음
INSP.typeddict.key.cannot.be.deleted=TypedDict ''{1}'' 의 키 ''{0}'' 을(를) 삭제할 수 없습니다
INSP.typeddict.this.operation.might.break.typeddict.consistency=이 동작은 TypedDict 일관성을 해칠 수 있습니다
INSP.typeddict.key.should.be.string=키는 문자열이어야 합니다
INSP.typeddict.value.must.be.type=값은 유형이어야 합니다
INSP.typeddict.total.value.must.be.true.or.false=''total''의 값은 True 또는 False여야 합니다
INSP.typeddict.typeddict.cannot.have.key=TypedDict "{0}" 은(는) 키 ''{1}'' 을(를) 취할 수 없습니다
INSP.typeddict.cannot.add.non.string.key.to.typeddict=TypedDict "{0}" 에 문자열이 아닌 키를 추가할 수 없음

# PyTypeHintsInspection
INSP.NAME.type.hints=유형 힌트 정의 및 사용 위치
INSP.type.hints.builtin.cannot.be.parameterized.directly=기본 제공 ''{0}'' 은(는) 직접 매개변수화될 수 없습니다
INSP.type.hints.invalid.type.self=유효하지 않은 유형 ''self''
INSP.type.hints.literal.must.have.at.least.one.parameter=''Literal''은 최소 하나의 매개변수를 취해야 합니다
INSP.type.hints.annotated.must.be.called.with.at.least.two.arguments=''Annotated''는 최소 두 개의 인수와 함께 호출되어야 합니다
INSP.type.hints.type.specified.both.in.type.comment.and.annotation=유형 주석과 어노테이션 모두에 지정된 유형
INSP.type.hints.typevar.expression.must.be.always.directly.assigned.to.variable=''TypeVar()'' 표현식은 항상 변수에 직접 할당되어야 합니다
INSP.type.hints.type.variables.must.not.be.redefined=유형 변수는 redefined일 수 없습니다
INSP.type.hints.typevar.expects.string.literal.as.first.argument=''TypeVar()''에는 첫 번째 인수로 문자열 리터럴이 필요합니다
INSP.type.hints.argument.to.typevar.must.be.string.equal.to.variable.name=''TypeVar()'' 인수는 할당된 변수 이름과 동일한 문자열이어야 합니다
INSP.type.hints.bivariant.type.variables.are.not.supported=이변적 유형 변수는 지원되지 않습니다
INSP.type.hints.typevar.constraints.cannot.be.combined.with.bound=제약은 bound\=...와 결합할 수 없습니다
INSP.type.hints.single.typevar.constraint.not.allowed=단일 상수는 허용되지 않습니다
INSP.type.hints.typevar.constraints.cannot.be.parametrized.by.type.variables=제약은 유형 변수로 매개변수화될 수 없습니다
INSP.type.hints.type.variables.cannot.be.used.with.instance.class.checks=인스턴스 및 클래스 검사에는 유형 변수를 사용할 수 없습니다
INSP.type.hints.type.cannot.be.used.with.instance.class.checks=''{0}'' 은(는) 인스턴스 및 클래스 검사에 사용할 수 없습니다
INSP.type.hints.parameterized.generics.cannot.be.used.with.instance.class.checks=인스턴스 및 클래스 검사에는 매개변수화된 제네릭을 사용할 수 없습니다
INSP.type.hints.generics.should.be.specified.through.square.brackets=제네릭은 대괄호를 사용해 지정해야 합니다
INSP.type.hints.cannot.inherit.from.plain.generic=일반 ''Generic''을 상속할 수 없음
INSP.type.hints.cannot.inherit.from.generic.multiple.times=''Generic[...]''을 여러 번 상속할 수 없음
INSP.type.hints.some.type.variables.are.not.listed.in.generic=일부 유형 변수({0})는 ''Generic[{1}]'' 목록에 포함되어 있지 않습니다
INSP.type.hints.illegal.literal.parameter=''Literal''은 리터럴 int, 바이트 및 유니코드 스트링, bool, 열거값, None, 기타 리터럴 유형 또는 다른 리터럴 유형의 유형 별칭으로 매개변수화할 수 있습니다.
INSP.type.hints.parameters.to.generic.must.all.be.type.variables=''Generic[...]'' 매개변수는 모두 유형 변수여야 합니다
INSP.type.hints.parameters.to.generic.must.all.be.unique=''Generic[...]'' 매개변수는 모두 고유해야 합니다
INSP.type.hints.illegal.callable.format=''Callable''을 Callable[[arg,...], result]''로 사용해야 합니다
INSP.type.hints.parameters.to.generic.types.must.be.types=제네릭 유형의 매개변수는 유형이어야 합니다
INSP.type.hints.type.comment.cannot.be.matched.with.unpacked.variables=유형 주석이 패킹 해제된 변수와 일치할 수 없습니다
INSP.type.hints.type.signature.has.too.few.arguments=유형 시그니처의 인수가 너무 적습니다
INSP.type.hints.type.signature.has.too.many.arguments=유형 시그니처의 인수가 너무 많습니다
INSP.type.hints.type.self.not.supertype.its.class=self ''{0}'' 의 유형은 클래스 ''{1}'' 의 상위 유형이 앙닙니다
INSP.type.hints.non.self.attribute.could.not.be.type.hinted=self가 아닌 속성은 유형 힌트로 표시될 수 없습니다
INSP.type.hints.type.alias.must.be.used.as.standalone.type.hint=''TypeAlias''는 독립실행형 유형 힌트로 사용되어야 합니다
INSP.type.hints.type.alias.must.be.immediately.initialized=유형 별칭을 즉시 초기화해야 합니다
INSP.type.hints.type.alias.must.be.top.level.declaration=유형 별칭은 최상위 선언이어야 합니다
INSP.type.hints.type.alias.cannot.be.parameterized=''TypeAlias''는 매개변수화될 수 없습니다
QFIX.remove.function.annotations=함수 어노테이션 제거
QFIX.replace.with.target.name=대상 이름으로 바꾸기
QFIX.remove.generic.parameters=제네릭 매개변수 제거
QFIX.replace.with.square.brackets=대괄호로 바꾸기
QFIX.surround.with.square.brackets=대괄호로 둘러싸기
QFIX.remove.square.brackets=대괄호 제거
QFIX.replace.with.typing.alias=유형 별칭으로 바꾸기
QFIX.remove.type.comment=유형 주석 제거
QFIX.remove.annotation=어노테이션 제거
QFIX.replace.with.type.name=유형 이름으로 바꾸기

# PyInspectionsSuppressor
INSP.python.suppressor.suppress.for.function=함수 억제
INSP.python.suppressor.suppress.for.class=클래스 억제
INSP.python.suppressor.suppress.for.statement=구문 억제

find.usages.unnamed=<unnamed>
find.usages.keyword.argument=키워드 인수
find.usages.variable=변수
find.usages.imported.module.alias=가져온 모듈 별칭
find.usages.class=클래스
find.usages.function=함수
find.usages.method=메서드
find.usages.parameter=매개 변수

python.find.usages=사용 위치 찾기
python.find.usages.base.method.question=메서드 {0} 이(가) 클래스 {1} 메서드를 재정의합니다.\n\
기본 메서드의 사용 위치를 찾으시겠어요?
python.find.usages.usage.in.superclass.list=상위 클래스 목록 내 사용 위치
python.find.usages.usage.in.isinstance=isinstance() 내 사용 위치
python.find.usages.untyped.probable.usage=유형이 없는 (가능성 있는) 사용 위치
python.find.usages.usage.in.import.statement=import 문 내 사용 위치

# PyPackagesInspection
INSP.NAME.relative.import=의심스러운 상대적 가져오기
INSP.relative.import.relative.import.outside.package=패키지 외부의 상대적 가져오기

