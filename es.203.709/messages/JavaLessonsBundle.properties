readme.shared.indexes.remark=Es posible que se le solicite que descargue un índice compartido. Si tiene una buena conexión a Internet, aceptar esta oferta puede acelerar la inicialización del proyecto.
java.surround.and.unwrap.help.unwrapping.and.removing.statements=Trabajando en la sintaxis del código
java.basic.completion.choose.first=Puede seleccionar el primer elemento en el menú de consulta presionando {0}.
java.basic.completion.activate=Si presiona {0} para activar la finalización básica, verá el menú de consulta nuevamente.
java.basic.completion.choose.item=Desde el menú de consulta, seleccione {0} y presione {1}.
java.basic.completion.complete=Haga clic en {0} para completar esta declaración.
java.basic.completion.deeper.level=static A veces es necesario consultar la lista de sugerencias para encontrar una constante o un método. Toca dos veces {0} para mostrarlo en la lista de búsqueda.
java.basic.completion.module.promotion=Puede encontrar más detalles sobre la refactorización en el módulo {0}.
java.run.configuration.lets.run=Puede ejecutar código arbitrario marcado con {0}. Ejecutemos un ejemplo simple usando {1}. Como alternativa, puede hacer clic en {0} para seleccionar {2}.
java.postfix.completion.apply=La finalización del sufijo ayuda a reducir el movimiento de intercalación al escribir código. Puede convertir una expresión ya ingresada en otra expresión según el sufijo que agregue, el tipo de expresión y su contexto. Ingrese {0} después de paréntesis para ver una lista de sugerencias de finalización de sufijos. Seleccione {1} de la lista o escríbalo en el editor y presione {2} para completar la frase.
java.smart.type.completion.lesson.name=Finalización de tipo inteligente
java.smart.type.completion.apply=La finalización de tipo inteligente filtra la lista de sugerencias para incluir solo aquellos tipos que son aplicables dentro del contexto actual. Presione {0} para ver una lista de sugerencias coincidentes. Presione {1} para seleccionar el primer elemento.
java.smart.type.completion.return=La finalización de tipo inteligente también puede sugerir código para declaraciones de retorno. Presione {0} para ver el menú de consulta de la declaración de devolución. Presione {1} para seleccionar el primer elemento.
java.statement.completion.lesson.name=Declaración completa
java.statement.completion.complete.for=Presione {0} para completar la declaración {1}.
java.statement.completion.complete.if=Ingrese {0} y presione {1} para generar la declaración.
java.statement.completion.complete.condition=Agrega la condición entre paréntesis {0} y luego presiona {1} para pasar a la sintaxis {2}.
java.statement.completion.complete.finish.body=Ingrese {0} en una línea y presione {1} para completar la declaración y aplicar el formato.
java.rename.press.rename=Cambie el nombre del campo {1} presionando {0}.
java.rename.type.new.name=Ingrese un nuevo nombre para este campo (por ejemplo: {0}) y presione {1}.
java.rename.confirm.accessors.rename=<ide /> detectará ese getter/setter y sugerirá cambiarle el nombre en consecuencia. Ahora presione {0} o haga clic en {1}.
java.refactoring.menu.inline.variable=Ahora insertemos la variable {0} para reducir su uso a uno. Puede filtrar el menú de refactorización presionando {1} y <strong> iv</strong> (<strong> i</strong> nline <strong> variable). Seleccione este elemento o presione {2}.
java.refactoring.menu.introduce.constant=Finalmente, extraigamos la extensión del nombre del archivo. De manera similar, presione {0} y filtre por <strong> ic</strong> (<strong> i</strong> ntroduzca <strong> c</strong> onstant) o presione {1}.
java.refactoring.menu.confirm.constant=Este diálogo le permite elegir el nombre, la clase principal y la visibilidad de la nueva constante. Mantenga el valor predeterminado y presione {0} o haga clic en {1}.
java.inheritance.hierarchy.lesson.name=Jerarquía de herencia
java.inheritance.hierarchy.goto.implementation=Haga clic en {0} para buscar {1} implementaciones.
java.inheritance.hierarchy.choose.any.implementation=Elija una implementación y presione o haga clic en {0}.
java.inheritance.hierarchy.navigate.to.base=Puede pasar de un método derivado a un súper método. Presione {0} o presione el icono {1} en el margen del editor.
java.inheritance.hierarchy.invoke.implementations.again=La declaración del método principal tiene su propio icono de margen {0}. Haga clic o presione {1} nuevamente.
java.inheritance.hierarchy.open.in.find.tool.window=Para jerarquías grandes, se recomienda buscar implementaciones en la ventana de herramientas {0}. Haga clic en {1}.
java.inheritance.hierarchy.hide.find.tool.window=Presione {0} para ocultar la ventana de herramientas {1}.
java.inheritance.hierarchy.open.method.hierarchy=Es una buena idea revisar toda la jerarquía de este método. Presione {0}.
java.inheritance.hierarchy.hide.method.hierarchy={0} También vamos a escondernos. Presione {1} nuevamente.
java.inheritance.hierarchy.open.class.hierarchy=Presione {0} para obtener una vista previa de la descripción general de la jerarquía de clases.
java.inheritance.hierarchy.last.note=<strong> Nota\:</strong> Las acciones {0} y {1} también se aplican a las clases. Las acciones {2} {3} rara vez se utilizan, pero siempre se pueden encontrar como {4} usando el filtro {5}.
java.find.occurrences.lesson.name=Buscar anterior/siguiente
java.find.occurrences.invoke.find=Ha seleccionado {0} para esta lección. Presione {1} para iniciar una búsqueda de texto completo del archivo actual.
java.find.occurrences.find.previous=Presione {0} para volver al uso anterior.
java.find.occurrences.search.closed.warning=Presione {0} para volver a abrir el campo de búsqueda.
java.find.occurrences.find.next=<ide /> copia automáticamente el texto seleccionado en el campo de búsqueda. Averigüemos dónde usarlo a continuación. Presione {0} o {1}.
java.find.occurrences.close.search.tool=Puede usar este atajo para navegar entre usos descubiertos recientemente incluso con el panel de búsqueda cerrado. Presione {0} para cerrar el panel de búsqueda.
java.find.occurrences.find.next.in.editor=Busque el siguiente uso con {0}.
java.find.occurrences.find.previous.in.editor=Presione {0} para volver.
java.find.occurrences.note.about.cyclic=<strong> Nota\:</strong> La búsqueda es cíclica, al tocar dos veces {0} en la última aparición se establecerá la última aparición en el rango de selección. {1} también es cíclico.
java.debug.workflow.rebuild=Los programas grandes pueden tardar mucho en ejecutarse de nuevo. Si encuentra un error en el método puro, simplemente reconstruya el proyecto para aplicar la función de JVM <strong> hot-swap</strong>. Construyamos el proyecto {0} o {1}.
java.debug.workflow.confirm.hot.swap=Confirmar el reemplazo del <strong> intercambio en caliente</strong>.
java.debug.workflow.drop.frame=El método ha sido parcheado, pero el {0} obsoleto todavía se está ejecutando y la excepción se ha vuelto a lanzar. Eliminemos el marco y volvamos al estado anterior a la llamada {1}. {2} Haga clic en el panel de depuración o presione {3}.
