language.groovy=Groovy
file.type.dgm=Archivo descriptor del módulo de extensión Groovy
file.type.logback=Configuración de DSL de inicio de sesión de Groovy
file.type.gdsl=Configuración de IntelliJ Groovy DSL
action.Mvc.RunTarget.text=Ejecutar comando
action.Mvc.RunTarget.description=Ejecutar comando arbitrario Grails/Griffon
action.Mvc.Upgrade.text=Cambiar la versión del SDK
action.Mvc.Upgrade.description=Cambiar la versión del SDK de Grails/Griffon
group.Mvc.Actions.text=Grails/Griffon
title.groovy.shell=Concha maravillosa
action.Groovy.Shell.text=Groovy Shell...
action.Groovy.Shell.description=Lanzar el shell Groovy
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.text=propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.description=La acción genera propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.text=methodMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.description=La acción genera propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.text=equals() y hashCode()
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.description=La acción genera equals y hashCode ahora
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.text=Getter y Setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.description=Genera getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.text=Setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.description=Genera setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.text=Getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.description=Genera getter
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.text=Constructor
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.description=Genera constructor
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.text=to_String()
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.description=Generar método toString()
action.ExcludeFromStubGeneration.text=Excluir de la generación de stub
action.ExcludeFromStubGeneration.description=No genere stubs de Java para este archivo Groovy en la compilación
action.DumpGroovyControlFlowAction.text=Volcar Flujo de control Groovy
action.ConvertToCompileStatic.text=Convertir a @CompileStatic
action.ConvertToCompileStatic.description=Convertir archivos Groovy a @CompileStatic
action.ConvertGroovyToJava.text=Convertir a Java
action.ConvertGroovyToJava.description=Convertir archivos Groovy a Java
action.Groovy.NewScript.text=Script maravilloso
action.Groovy.NewScript.description=Crear nuevo script Groovy
action.Groovy.NewClass.text=Clase Groovy
action.Groovy.NewClass.description=Crear nueva clase Groovy
action.Groovy.CheckResources.Rebuild.text=_Rebuild Resources
action.Groovy.CheckResources.Rebuild.description=Ejecute el compilador para todos los archivos Groovy en las raíces de recursos para comprobar si hay problemas de compilación
action.Groovy.CheckResources.Make.text=_Build Resources
action.Groovy.CheckResources.Make.description=Ejecute el compilador incremental para archivos Groovy en las raíces de recursos para comprobar si hay problemas de compilación
group.Groovy.CheckResources.text=Gr_oovy Recursos
group.Groovy.CheckResources.description=Ejecute el compilador de archivos Groovy en las raíces de recursos para comprobar si hay problemas de compilación
action.Groovy.Shell.Execute.text=Ejecutar código Groovy
action.Groovy.Shell.Execute.description=Ejecutar código Groovy en la consola
file.template.group.title.groovy=Groovy
groovy.term.class=clase
groovy.term.interface=interfaz
groovy.term.trait=rasgo
groovy.term.enum=enumeración
groovy.term.annotation=anotación
groovy.term.method=método
groovy.term.field=campo
groovy.term.property=propiedad
groovy.term.parameter=parámetro
groovy.term.variable=variable local
groovy.term.binding=variable de enlace de script
groovy.term.label=etiqueta
groovy.term.closure=cierre
groovy.term.expression=Expresión
new.class.action.text=Clase Groovy
new.class.action.description=Crea una nueva clase Groovy
new.class.dialog.title=Nueva clase Groovy
new.class.list.item.class=clase
new.class.list.item.interface=interfaz
new.class.list.item.trait=característica
new.class.list.item.enum=enumeración
new.class.list.item.annotation=anotación
invalid.qualified.name=No es un nombre válido y completo de Groovy
new.script.action.text=Guión maravilloso
new.script.action.description=Crea un nuevo script Groovy
new.script.dialog.title=Ingrese un nuevo nombre de script Groovy
new.script.list.item.script=Guión maravilloso
new.script.list.item.script.dsl=Guión GroovyDSL
new.gant.script.dialog.title=Nuevo guión de Gant
new.gant.script.dialog.message=Introduzca un nuevo nombre de secuencia de comandos Gant
debug.option=Habilitar y &depurar el seguimiento de la pila
groovy.debug.disable.specific.methods=No entre en clases específ&icas de Groovy
groovy.debug.caption=Groovy
identifier.expected=Identificador esperado
identifier.or.block.expected=Identificador o bloque de código esperado
string.end.expected=Se espera el final de la cadena
try.without.catch.finally=intentar' sin 'atrapar' o 'finalmente
expression.expected=Expresión esperada
duplicate.modifier=Modificador duplicado ''{0}''
cannot.resolve=No se puede resolver el símbolo ''{0}''
cannot.access=El acceso a ''{0}'' excede sus derechos de acceso
cannot.reference.non.static=No se puede hacer referencia al símbolo no estático ''{0}'' desde el contexto estático
cannot.return.from.constructor=No se puede devolver un objeto del constructor
cannot.return.from.void.method=No se puede devolver un objeto de un método que devuelve 'void'
cannot.return.type=No se puede devolver ''{0}'' del método que devuelve ''{1}''
cannot.apply.method.or.closure='{0}'' no se puede aplicar a ''{1}'
cannot.apply.method1='{0}'' in ''{1}'' no se puede aplicar a ''{2}'
cannot.apply.constructor=El constructor ''{0}'' en ''{1}'' no se puede aplicar a ''{2}''
cannot.apply.default.constructor=No se puede aplicar el constructor predeterminado para la clase ''{0}''
cannot.instantiate.abstract.class=No se puede crear una instancia de la clase abstracta ''{0}''
cannot.instantiate.interface=No se puede crear una instancia de la interfaz ''{0}''
missing.required.named.parameter=Falta el parámetro con nombre obligatorio ''{0}''
loss.of.precision=Posible pérdida de precisión de ''{0}'' a ''{1}''
cannot.assign=No se puede asignar ''{0}'' a ''{1}''
cannot.cast=No se puede transmitir ''{0}'' a ''{1}''
multiple.assignments.without.list.expr=Múltiples asignaciones sin expresiones de lista en el lado derecho no son compatibles en el modo de verificación de tipo estático
spread.operator.is.not.available=El operador de propagación no se puede usar como argumento con verificación de tipo estático
replace.with.list.literal=Reemplazar con lista literal
replace.with.get.at=Reemplazar con acceso de índice
incorrect.number.of.values=Número incorrecto de valores. Esperado: {0} Era: {1}
invalid.lvalue=Valor no válido para asignar
duplicate.class=Class ''{0}'' ya existe en ''{1}''
duplicate.inner.class=Clase duplicada: ''{0}''
script.generated.with.same.name=Hay una clase sintética ''{0}'' generada para el código del script
variable.already.defined=Variable ''{0}'' ya definida
field.already.defined=Campo ''{0}'' ya definido
create.class.family.name=Crear clase
create.class.text=Crear clase {0}
create.interface.text=Crear interfaz {0}
create.annotation.text=Crear anotación {0}
constructors.are.not.allowed.in.anonymous.class=Los constructores no están permitidos en la clase anónima
no.such.property=La propiedad ''{0}'' no existe
change.modifier=Hacer ''{0}'' {1}
change.modifier.not=Hacer ''{0}'' no {1}
change.modifier.family.name=Cambiar modificadores
parameter.cast.fix=Transmitir el parámetro {0, número, ordinal} a {1}
action.convert.lambda.to.closure=Convertir lambda en cierre
add.parenthesis.to.lambda.parameter.list=Agregar paréntesis a la lista de parámetros
packageLocal.visibility.presentation=Visibilidad predeterminada
protected.visibility.presentation=protected
private.visibility.presentation=privado
public.visibility.presentation=public
abstract.visibility.presentation=abstract
static.visibility.presentation=static
final.visibility.presentation=final
native.visibility.presentation=native
synchronized.visibility.presentation=sincronizado
strictfp.visibility.presentation=strictfp
transient.visibility.presentation=transient
volatile.visibility.presentation=volatile
def.visibility.presentation=def
intention.family.name.convert.conditional.expression.to.elvis=Convertir expresión condicional a elvis
intention.family.name.replace.with.keyed.access=Reemplazar con acceso clave
intention.family.name.fix.range.class=Modificar clasificación de rango
intention.family.name.make.return.implicit=Establecer el retorno implícitamente
intention.family.name.simplify=arrasamiento
intention.family.name.remove.unnecessary.continue=Eliminar continuar innecesario
intention.family.name.remove.unnecessary.return=Eliminar devoluciones innecesarias
intention.family.name.add.parameter.cast=Agregar conversión de tipo de parámetro
intention.family.name.replace.for.each.operator=Reemplazo del operador para cada uno
intention.family.name.add.cast=Agregar conversión de tipo
intention.family.name.change.variable.type=Cambiar tipo de variable
intention.family.name.replace.with.conditional.call=Cambiar a llamada condicional
intention.family.name.collapse.conditional.expressions=Contraer expresiones condicionales
intention.family.name.remove.double.negation=eliminar doble negativo
intention.family.name.activate.dsl.descriptor=Habilitar descriptor DSL
intention.family.name.collapse.if.statement=Contraer la declaración ''si''
intention.family.name.replace.with.short.circuit.expression=Convertir a expresión de párrafo
intention.family.name.replace.something.with=Reemplace ''{0}'' con ''{1}''
intention.family.name.add.attributes.to.annotation=Agregar propiedades a las anotaciones
illegal.combination.of.modifiers=Combinación ilegal de modificadores
illegal.combination.of.modifiers.abstract.and.final=Combinación ilegal de modificadores 'abstracto' y 'final'
modifier.volatile.not.allowed.here=Modificador 'volátil' no permitido aquí
modifier.transient.not.allowed.here=Modificador 'transitorio' no permitido aquí
modifier.0.not.allowed=Modificador ''{0}'' no permitido aquí
interface.cannot.have.modifier.final=La interfaz no puede tener el modificador 'final'
script.method.cannot.have.modifier.abstract=El método de script no puede tener el modificador 'abstracto'
script.cannot.have.modifier.native=El script no puede tener el modificador 'nativo'
interface.must.have.no.static.method=La interfaz no debe tener un método estático
only.abstract.class.can.have.abstract.method=Solo la clase abstracta puede tener un método abstracto
anonymous.class.cannot.have.abstract.method=La clase anónima no puede tener un método abstracto
illegal.combination.of.modifiers.volatile.and.final=Combinación ilegal de modificadores 'volátil' y 'final'
variable.cannot.be=La variable no puede tener el modificador ''{0}''
remove.modifier=Eliminar ''{0}''
not.abstract.method.should.have.body=El método no abstracto debe tener cuerpo
cannot.create.class.error.text=No se puede crear la clase ''{0}'': {1}
cannot.create.class.error.title=No se puede crear una clase
no.class.in.file.template=No se encontró ninguna clase en la plantilla de archivo
Inner.methods.are.not.supported=Los métodos internos no son compatibles
final.class.cannot.be.extended=La clase final no se puede extender
unsupported.inner.class.0=Las clases internas no son compatibles con Groovy {0}
unsupported.anonymous.class.0=Las clases anónimas no son compatibles con Groovy {0}
unsupported.diamonds.0=Los diamantes no son compatibles con Groovy {0}
unsupported.command.syntax.0=La sintaxis de la expresión de comando no es compatible con Groovy {0}
unsupported.dollar.slashy.string.0=Las cadenas de barras inclinadas en dólares no son compatibles con Groovy {0}
unsupported.multiline.slashy.string.0=Las cadenas de barras inclinadas de varias líneas no son compatibles con Groovy {0}
unsupported.traits.0=Los rasgos no son compatibles con Groovy {0}
duplicating.named.parameter=El parámetro con nombre duplicado ''{0}'' ocurre en los parámetros: {1}
field.should.be.immutable=El campo ''{0}'' debe tener un tipo inmutable o declararse así con @ImmutableOptions
immutable.options.property.not.exist=La propiedad ''{0}'' no existe
explicit.includes.and.excludes=Solo se debe proporcionar uno de "incluye" y "excluye"
require.closure.as.attribute.value=Necesito un cierre como valor de la propiedad.
initializers.are.forbidden.with.defaults=Deshabilitar los ''valores predeterminados'' en @TupleConstructor significa que los valores predeterminados están prohibidos
super.is.not.allowed.in.pre.with.call.super=Las súper llamadas no están permitidas en ''pre'' con ''callSuper'' habilitado
illegal.default.modifier=El modificador 'predeterminado' solo tiene sentido en los métodos de la interfaz
illegal.default.modifier.fix=Eliminar modificador 'predeterminado'
default.modifier.in.old.versions=El modificador 'predeterminado' está disponible con Groovy 3.0 o posterior
unsupported.do.while.statement='hacer mientras' no es compatible con la versión actual
unsupported.tuple.declaration.in.for=La declaración de tupla en la inicialización 'for' no es compatible con la versión actual
unsupported.multiple.variables.in.for=Varias variables en la inicialización 'for' no son compatibles con la versión actual
unsupported.expression.list.in.for.update=Varias expresiones en la actualización 'for' no son compatibles con la versión actual
unsupported.resource.list='probar' con recursos no es compatible con la versión actual
unsupported.array.initializers=Los inicializadores de matriz no son compatibles con la versión actual
operator.is.not.supported.in=El operador ''{0}'' no es compatible con la versión actual
unsupported.negated.in=Negated 'in' no es compatible con la versión actual
unsupported.negated.instanceof=La 'instancia de' negada no es compatible con la versión actual
unsupported.elvis.assignment=La asignación de Elvis no es compatible con la versión actual
unsupported.safe.index.access=El acceso seguro al índice no es compatible con la versión actual
unsupported.lambda=Lambdas no son compatibles con la versión actual
unsupported.type.annotations=Las anotaciones de tipo no son compatibles con la versión actual
unsupported.tuple.application.initializer=El inicializador de aplicaciones no es compatible con la versión actual
illegal.single.argument.lambda=La forma de un solo argumento de lambda está disponible solo como parte derecha de la expresión de asignación o como argumento dentro de la llamada al método
method.is.not.implemented=El método ''{0}'' no está implementado
change.implements.and.extends.classes=Normalizar extiende e implementa listas
fix.package.name=Corregir el nombre del paquete
checkbox.delegate.via.overloading.method=Delegación mediante métodos sobrecargados
checkbox.ignore.conditional.operators=Ignorar operadores condicionales
checkbox.ignore.obscure.operators=Ignorar operadores ambiguos
checkbox.ignore.double.checked.locking.on.volatile.fields=Evite bloqueos de doble verificación en campos volátiles
checkbox.inspect.anonymous.closures=Comprobación de cierre anónimo
checkbox.only.warn.if.loop.empty=Advertir sólo si el bucle está vacío
add.dynamic.property=Agregar propiedad dinámica ''{0}''
duplicate.element.in.the.map=Elemento duplicado ''{0}'' en el mapa
dynamic.tool.window.id=Miembros dinámicos
create.field.from.usage.family.name=Crear campo a partir del uso
create.field.from.usage=Crear campo ''{0}''
create.method.from.usage.family.name=Crear método a partir del uso
create.method.from.usage=Crear método ''{0}''
create.variable.from.usage.family.name=Crear variable de uso
create.variable.from.usage=Crear variable ''{0}''
create.parameter.from.usage.family.name=Crear parámetro a partir del uso
create.parameter.from.usage=Crear parámetro ''{0}''
add.dynamic.element=Agregar elemento dinámico
add.dynamic.method=Agregar método dinámico
add.dynamic.method.0=Agregar método dinámico ''{0}''
dynamic.type=Tipo
dynamic.name=Nombre
dynamic.properties.table.name=Argumentos del método
dynamic.method.return.type=Devolver &tipo:
dynamic.method.property.type=Propiedad y tipo:
are.you.sure.to.delete.dynamic.property=¿Está seguro de eliminar ''{0}''?
dynamic.property.deletion=Propiedad dinámica de eliminación
are.you.sure.to.delete.elements=¿Está seguro de eliminar los elementos ''{0}''?
dynamic.element.deletion=Eliminación de elementos dinámicos
tuple.cant.be.placed.in.class=No se permiten múltiples asignaciones para los campos
is.not.enclosing.class=''{0}'' no es una clase adjunta
package.definition.cannot.have.modifiers=La definición del paquete no puede tener modificadores
import.statement.cannot.have.modifiers=La declaración de importación no puede tener modificadores
undefined.label=Etiqueta no definida ''{0}''
continue.outside.loop=La instrucción continue solo se permite dentro de los bucles
break.outside.loop.or.switch=La declaración de interrupción solo se permite dentro de bucles o interruptores
label.already.used=La etiqueta ''{0}'' ya está en uso
break.outside.loop=La declaración de ruptura con etiquetas con nombre solo se permite dentro de los bucles
Constructor=Constructor
Getter=Getter
Setter=Setter
not.allowed.modifier.in.for.in=El modificador ''{0}'' no está permitido aquí
property.name.expected=Nombre de propiedad esperado
wildcards.are.not.allowed.in.extends.list=Un supertipo no puede especificar un tipo de comodín
method.does.not.override.super=El método no anula el método de su superclase
method.duplicate=El método con la firma {0} ya está definido en la clase ''{1}''
ambiguous.code.block=Bloque de código ambiguo
cyclic.inheritance.involving.0=Herencia cíclica que involucra ''{0}''
there.is.no.default.constructor.available.in.class.0=No hay un constructor predeterminado disponible en la clase ''{0}''
groovy.library.is.not.configured.for.module=Groovy SDK no está configurado para el módulo ''{0}''
configure.groovy.library=Configurar Groovy SDK…
create.instance.of.built-in.type=Creación de instancias del tipo incorporado
incorrect.variable.name=Nombre de variable incorrecto
no.interface.expected.here=No se espera ninguna interfaz aquí
no.class.expected.here=No se espera una clase aquí
invoke.completion.second.time.to.show.skipped.methods=Invocar la finalización por segunda vez para mostrar los métodos omitidos
groovy.file.extension.is.not.mapped.to.groovy.file.type=*. Los archivos groovy se asignan a ''{0}''.\nPuedes asignarlos a Groovy en Configuración | Tipos de archivo
class.is.not.annotation=''{0}'' no es una anotación
method.call.is.ambiguous=La llamada al método es ambigua
operator.call.is.ambiguous=La llamada del operador es ambigua
duplicated.named.parameter=Parámetro con nombre duplicado ''{0}'' encontrado
no.super.classes.found=No se encontraron superclases
no.super.method.found=No se encontraron supermétodos
cannot.assign.string.to.enum.0=No se puede asignar una cadena a la enumeración ''{0}''
cannot.find.enum.constant.0.in.enum.1=No se puede encontrar la constante de enumeración ''{0}'' en la enumeración ''{1}''
recursive.constructor.invocation=Invocación de constructor recursivo
the.usage.of.a.map.entry.expression.to.initialize.an.enum.is.currently.not.supported=Actualmente no se admite el uso de una expresión de entrada de mapa para inicializar un Enum
class.definition.is.not.expected.here=No se espera una definición de clase aquí
move.class.0.from.method=Mover ''{0}'' al lugar correcto
move.class.from.method.family.name=Mover al lugar correcto solución rápida
cannot.infer.argument.types=No se pueden inferir tipos de argumentos
Equals=Iguales
default.initializers.are.not.allowed.in.abstract.method=Los inicializadores predeterminados no están permitidos en métodos abstractos
groovy.does.not.support.constructor.type.arguments=Groovy no admite argumentos de tipo constructor
illegal.escape.character.in.string.literal=Carácter de escape ilegal en literal de cadena
method.with.type.parameters.should.have.return.type=El método con parámetros de tipo debe tener un tipo de retorno
primitive.type.parameters.are.not.allowed=Los parámetros de tipo primitivo no están permitidos en la lista de parámetros de tipo
primitive.bound.types.are.not.allowed=Los tipos de enlace primitivo no están permitidos
ellipsis.type.is.not.allowed.here=El tipo de elipsis no está permitido aquí
method.0.is.too.complex.too.analyze=El método ''{0}'' es demasiado complejo para analizar.\nLos tipos de variables locales no se infieren.
closure.is.too.complex.to.analyze=El cierre es complejo de analizar.\nLos tipos de variables locales no se infieren.
0.is.deprecated=''{0}'' está obsoleto
wrong.number.of.type.arguments=Número incorrecto de argumentos de tipo\: {0}; requerido\: {1}
type.argument.0.is.not.in.its.bound.should.extend.1=El parámetro de tipo ''{0}'' no está en su límite; debería extender ''{1}''
catch.statement.parameter.type.should.be.a.subclass.of.throwable=El tipo de parámetro de declaración Catch debe ser una subclase de Throwable
exception.0.has.already.been.caught=La excepción ''{0}'' ya ha sido detectada
unnecessary.type=Excepción innecesaria ''{0}''. ''{1}'' ya está declarado
create.enum=Crear enumeración {0}
create.trait=Crear rasgo {0}
annotation.field.can.only.be.used.within.a.script.body=Annotation @Field solo se puede usar dentro de un cuerpo de script
annotation.field.can.only.be.used.within.a.script=Annotation @Field solo se puede usar dentro de un script
return.type.is.incompatible=El tipo de retorno de {0} en {1} es incompatible con {2} en {3}
anonymous.class.derived.from.0=clase anónima derivada de {0}
throws.clause.is.not.allowed.in.at.interface=La cláusula 'throws' no está permitida en los miembros de @interface
at.interface.0.does.not.contain.attribute=@interface ''{0}'' no contiene el atributo ''{1}''
duplicate.attribute=Atributo duplicado
missed.attributes=Atributos perdidos\: {0}
unexpected.attribute.type.0=Tipo de atributo inesperado\: ''{0}''
annotation.field.should.have.type.declaration=El campo en la anotación debe tener una declaración de tipo
interface.members.are.not.allowed.to.be=Los miembros de la interfaz no pueden ser {0}
abstract.methods.must.not.have.body=Los métodos abstractos no deben tener cuerpo
method.has.incorrect.modifier.volatile=El método tiene un modificador incorrecto 'volátil'
native.methods.cannot.have.body=Los métodos nativos no pueden tener cuerpo
top.level.class.may.not.have.private.modifier=Es posible que la clase de nivel superior no tenga el modificador 'privado'
top.level.class.may.not.have.protected.modifier=Es posible que la clase de nivel superior no tenga el modificador 'protegido'
property.missing=propertyMissing
attribute.name.expected=Nombre de atributo esperado
java.style.for.each.statement.requires.a.type.declaration=Estilo Java para cada declaración requiere una declaración de tipo
super.cannot.be.used.in.static.context='super' no se puede utilizar en contexto estático
qualified.0.is.allowed.only.in.nested.or.inner.classes=Qualified {0} solo se permite en clases anidadas/internas
groovy.file.0=Archivo maravilloso ''{0}''
type.argument.list.is.not.allowed.here=La lista de argumentos de tipo no está permitida aquí
initializers.are.not.allowed.in.interface=Los inicializadores no están permitidos en la interfaz
initializer.cannot.have.annotations=Los inicializadores no pueden tener anotaciones
initializer.cannot.be.0=El inicializador no puede ser {0}
constructors.are.not.allowed.in.interface=Los constructores no están permitidos en la interfaz
type.parameters.are.unexpected=Los parámetros de tipo son inesperados
constructors.cannot.have.return.type=El elemento de tipo de retorno no está permitido en el constructor
constructor.cannot.have.static.modifier=El constructor no puede ser estático
annotation.types.may.not.have.extends.clause=Los tipos de anotaciones pueden no tener una cláusula 'extiende'
annotation.types.may.not.have.implements.clause=Los tipos de anotaciones pueden no tener una cláusula 'implements'
no.implements.clause.allowed.for.interface=Es posible que las interfaces no tengan la cláusula 'implements'
enums.may.not.have.extends.clause=Las enumeraciones pueden no tener la cláusula 'extends'
method.0.cannot.override.method.1.in.2.overridden.method.is.final=El método ''{0}'' no puede anular el método ''{1}'' en ''{2}'' ; el método anulado es final
method.0.cannot.have.weaker.access.privileges.1.than.2.in.3.4=El método ''{0}'' no puede tener privilegios de acceso más débiles (''{1}'') que '' { 2} '' en ''{3}'' (''{4}'')
tuple.declaration.should.end.with.def.modifier=La declaración de tupla debe terminar con el modificador 'def'
injection.should.not.contain.line.feeds=La inyección GString no debe contener avances de línea
collection.literal.contains.named.argument.and.expression.items=El literal de colección contiene argumentos con nombre y expresión al mismo tiempo
annotation.collector.cannot.have.attributes=El tipo de anotación anotado con @AnnotationCollector no puede tener atributos
annotation.type.cannot.be.inner=El tipo de anotación no puede ser interno
named.arguments.are.not.allowed.inside.index.operations=No se permiten argumentos con nombre dentro de operaciones de índice
expected.0.to.be.inline.constant=Se espera que ''{0}'' sea una constante en línea
cannot.assign.a.value.to.final.field.0=No se puede asignar un valor al campo final ''{0}''
cannot.assign.a.value.to.final.parameter.0=No se puede asignar un valor al parámetro final ''{0}''
variable.0.might.not.have.been.initialized=Es posible que la variable ''{0}'' no se haya inicializado
doc.end.expected='*/' esperado
mixing.private.and.public.protected.methods.of.the.same.name=Mezclando métodos privados y públicos/protegidos del mismo nombre
explicit.constructors.are.not.allowed.in.immutable.class=Los constructores explícitos no están permitidos para la clase @Immutable
repetitive.method.name.0=Nombre de método repetitivo ''{0}''
declared.type.0.have.to.extend.script=El tipo declarado ''{0}'' no extiende la clase '' groovy.lang.Script ''
base.script.annotation.is.allowed.only.inside.scripts=La anotación @BaseScript solo se puede usar dentro de un script
delegate.annotation.is.only.for.methods.without.arguments=La anotación @Delegate no se pudo aplicar al método con argumentos
builder.annotation.not.support.super.for.simple.strategy=El atributo de anotación 'includeSuperProperties' no es compatible con groovy.transform.builder.SimpleStrategy
0.expressions.on.trait.fields.properties.are.not.supported.in.traits={0} las expresiones en los campos/propiedades de rasgos no son compatibles con los rasgos
only.traits.expected.here=Aquí solo se esperan rasgos
anonymous.classes.cannot.be.created.from.traits=No se pueden crear clases anónimas a partir de rasgos
trait.method.cannot.be.protected=Los métodos de rasgos no pueden protegerse
non.static.classes.not.allowed=Las clases internas no estáticas no están permitidas en los rasgos
selfType.class.does.not.inherit=@SelfType: La clase ''{0}'' no hereda ''{1}''
illegal.type.void=Tipo ilegal: 'void'
illegal.method.name=El nombre del método contiene caracteres ilegales: {0}
indexed.property.is.applicable.to.properties.only=@IndexedProperty no se puede aplicar solo a propiedades
listener.list.field.must.have.a.generic.collection.type=El campo @ListenerList requiere un tipo de colección genérico
listener.list.field.with.generic.wildcards.not.supported=No se admite el uso de comodines genéricos en los campos @ListenerList
synchronized.not.allowed.on.abstract.method=@Synchronized no está permitido en métodos abstractos
lock.field.0.must.be.static=El campo de bloqueo ''{0}'' debe ser estático
lock.field.0.must.not.be.static=El campo de bloqueo ''{0}'' no puede ser estático
lock.field.0.not.found=Campo de roca ''{0}'' no encontrado
select.module.action.text=Seleccionar módulo...
select.module.action.description=Seleccionar módulos para usar el classpath
select.module.popup.title=Usar classpath del módulo
inspection.annotations=Verificación de anotaciones
inspection.assignments=Problemas de asignación
inspection.bugs=Errores probables
inspection.confusing=Construcciones de código potencialmente confusas
inspection.control.flow=Problemas de flujo de control
inspection.data.flow=Flujo de datos
inspection.error.handling=Manejo de errores
inspection.gpath=GPath
inspection.naming=Convenciones de nomenclatura
inspection.method.metrics=Métricas del método
inspection.redundancy=Declaración de redundancia
inspection.threading=Problemas de subprocesos
inspection.validity=Problemas de validez
inspection.style=Estilo
inspection.other=Otro
inspection.display.name.result.of.assignment.used=Resultado de la asignación utilizada
inspection.display.name.assignment.can.be.operator.assignment=Asignación reemplazable por asignación de operador
inspection.display.name.delegates.to=@DelegatesTo inspección
inspection.display.name.unresolved.access=Acceso a expresión no resuelta
inspection.display.name.untyped.access=Acceso a expresión sin tipo
inspection.display.name.list.set.can.be.keyed.access=Llamar a List.set puede ser acceso por clave
inspection.display.name.list.get.can.be.keyed.access=Llamar a List.get puede ser acceso por clave
inspection.display.name.map.put.can.be.keyed.access=La llamada a Map.put puede ser acceso por clave
inspection.display.name.map.get.can.be.keyed.access=La llamada a Map.get puede ser acceso por clave
inspection.display.name.parameter.naming.convention=Convención de nomenclatura de parámetros de método
inspection.display.name.constant.naming.convention=Convención de nomenclatura constante
inspection.display.name.instance.variable.naming.convention=Convención de nomenclatura de variables de instancia
inspection.display.name.instance.method.naming.convention=Convención de nomenclatura del método de instancia
inspection.display.name.static.variable.naming.convention=Convención de nomenclatura de variables estáticas
inspection.display.name.static.method.naming.convention=Convención de nomenclatura de métodos estáticos
inspection.display.name.local.variable.naming.convention=Convención de nomenclatura de variables locales
inspection.display.name.class.naming.convention=Convención de nomenclatura de clases
inspection.display.name.groovydoc.check=Problemas con GroovyDoc
inspection.display.name.constructor.named.arguments=Argumentos nombrados de la llamada al constructor
inspection.display.name.result.of.object.allocation.ignored=Resultado de la asignación del objeto ignorado
inspection.display.name.divide.by.zero=Dividir por cero
inspection.display.name.infinite.recursion=Recursión infinita
inspection.display.name.infinite.loop.statement=Declaración de bucle infinito
inspection.display.name.non.short.circuit.boolean=Booleano sin cortocircuito
inspection.display.name.duplicate.switch.branch=Caso de interruptor duplicado
inspection.display.name.gstring.key=Clave del mapa GString
inspection.display.name.octal.integer=Entero octal
inspection.display.name.overly.complex.boolean.expression=Expresión booleana demasiado compleja
inspection.display.name.clashing.trait.methods=Métodos de rasgos en conflicto
inspection.display.name.overly.complex.arithmetic.expression=Expresión aritmética demasiado compleja
inspection.display.name.double.negation=Doble negación
inspection.display.name.pointless.arithmetic=Expresión aritmética sin sentido
inspection.display.name.empty.statement.body=Declaración con cuerpo vacío
inspection.display.name.reassigned.in.closure.local.var=La variable local se reasigna en cierre o clase anónima
inspection.display.name.result.of.increment.or.decrement.used=Resultado del incremento o decremento utilizado
inspection.display.name.negated.if=Expresión de condición si se niega
inspection.display.name.in.argument.check=Tipos de argumentos 'in' incompatibles
inspection.display.name.negated.conditional=Expresión condicional negada
inspection.display.name.nested.conditional=Expresión condicional anidada
inspection.display.name.conditional=Expresión condicional
inspection.display.name.nested.switch=Instrucción de cambio anidada
inspection.display.name.multiple.return.points.per.method=Método con múltiples puntos de retorno
inspection.display.name.method.with.more.than.three.negation=Método con más de tres negaciones
inspection.display.name.overly.nested.method=Método demasiado anidado
inspection.display.name.overly.long.method=Método demasiado largo
inspection.display.name.overly.complex.method=Método demasiado complejo
inspection.display.name.method.parameter.count=Método con demasiados parámetros
inspection.display.name.while.loop.spins.on.field=Mientras el bucle gira en el campo
inspection.display.name.unsynchronized.method.overrides.synchronized.method=El método no sincronizado anula el método sincronizado
inspection.display.name.synchronization.on.variable.initialized.with.literal=Sincronización en variable inicializada con literal
inspection.display.name.synchronization.on.non.final.field=Sincronización en campo no final
inspection.display.name.wait.while.not.synchronized='esperar()' mientras no está sincronizado
inspection.display.name.wait.call.not.in.loop='wait()' no está en bucle
inspection.display.name.notify.while.not.synchronized='notificar()' o 'notificar a todos()' mientras no esté sincronizado
inspection.display.name.system.run.finalizers.on.exit=Llamada a System.runFinalizersOnSalir()
inspection.display.name.thread.stop.suspend.resume=Llamada a Thread.stop(), Thread.suspend() o Thread.resume()
inspection.display.name.nested.synchronized.statement=Declaración 'sincronizada' anidada
inspection.display.name.synchronized.method=Método sincronizado
inspection.display.name.synchronization.on.this=Sincronización en 'esto'
inspection.display.name.empty.sync.block=Bloque vacío 'sincronizado'
inspection.display.name.busy.wait=Espera ocupada
inspection.display.name.public.field.accessed.in.synchronized.context=Campo no privado al que se accede en contexto sincronizado
inspection.display.name.unconditional.wait=Llamada de 'espera' incondicional
inspection.display.name.double.checked.locking=Bloqueo verificado dos veces
inspection.display.name.access.to.static.field.locked.on.instance=Acceso al campo estático bloqueado en datos de instancia
inspection.display.name.change.to.method=Cambiar a método
inspection.display.name.change.to.operator=Cambiar a operador
inspection.display.name.unnecessary.alias=Alias de importación innecesario
inspection.display.name.unnecessary.semicolon=Punto y coma innecesario
inspection.display.name.unnecessary.public.modifier='público' innecesario
inspection.display.name.unnecessary.def.modifier='def' innecesario
inspection.display.name.java.style.properties.invocation=Acceso a la propiedad estilo Java
inspection.display.name.trivial.if=Declaración 'if' redundante
inspection.display.name.constant.if.statement=Constante si declaración
inspection.display.name.constant.conditional=Expresión condicional constante
inspection.display.name.trivial.conditional=Expresión condicional redundante
inspection.display.name.return.from.closure.can.be.implicit=la declaración 'return' puede ser implícita
inspection.display.name.switch.statement.with.no.default=Sentencia de cambio sin caso predeterminado
inspection.display.name.final.variable.access=Acceso a la variable final
inspection.display.name.unnecessary.return=Declaración de 'retorno' innecesaria
inspection.display.name.unnecessary.continue=Declaración 'continuar' innecesaria
inspection.display.name.fallthrough=Fallthrough en la declaración de cambio
inspection.display.name.if.statement.with.too.many.branches=Declaración If con demasiadas ramas
inspection.display.name.if.statement.with.identical.branches=Declaración If con ramas idénticas
inspection.display.name.conditional.can.be.conditional.call=La expresión condicional puede ser una llamada condicional
inspection.display.name.conditional.can.be.elvis=La expresión condicional puede ser elvis
inspection.display.name.conditional.with.identical.branches=Expresión condicional con ramas idénticas
inspection.display.name.loop.statement.that.doesnt.loop=Declaración de bucle que no se repite
inspection.display.name.unreachable.statement=Declaración inalcanzable
inspection.display.name.continue=Continuar declaración
inspection.display.name.break=Declaración de ruptura
inspection.display.name.unused.catch.parameter=Parámetro de captura no utilizado
inspection.display.name.empty.try.block=Bloque 'try' vacío
inspection.display.name.annotation.references.unknown.identifier=Identificador desconocido en las propiedades ''incluye'' y ''excluye''
inspection.display.name.unresolved.labels.in.named.variant=Etiquetas no resueltas después de la conversión @NamedVariant/@NamedParam/@NamedDelegate
inspection.display.name.empty.finally.block=Bloque 'finally' vacío
inspection.display.name.empty.catch.block=Bloque 'catch' vacío
inspection.display.name.throw.from.finally.block=throw' dentro del bloque 'finally
inspection.display.name.return.from.finally.block=return' dentro del bloque 'finally
inspection.display.name.method.may.be.static=El método puede ser estático
inspection.display.name.continue.or.break.from.finally.block=continuar' o 'romper' dentro del bloque 'finalmente
inspection.display.name.unchecked.assignment.of.member.of.raw.type=Asignación no verificada de miembros de tipo crudo
inspection.display.name.silly.assignment=Tarea tonta
inspection.display.name.nested.assignment=Asignación anidada
inspection.display.name.assignment.to.method.parameter=Asignación al parámetro del método
inspection.display.name.assignment.to.for.loop.parameter=Asignación al parámetro de bucle for
inspection.display.name.assignability.check=Asignaciones de tipos incompatibles
inspection.display.name.type.customizer=Tipo de inspección del personalizador
inspection.display.name.unused.declaration=Declaración no utilizada
inspection.display.name.second.unsafe.call=Segunda llamada insegura
inspection.display.name.unused.assignment=Asignación no utilizada
inspection.display.name.unused.inc.dec=Incremento o decremento no utilizado
inspection.display.name.unassigned.access=Variable No asignada
inspection.display.name.no.return=Falta la declaración de retorno
inspection.display.name.clashing.getters=Captadores en conflicto
inspection.display.name.package.mismatch=No coincide el paquete
inspection.display.name.deprecated.api.usage=Inspección de API obsoleta
inspection.display.name.unnecessary.qualified.reference=Referencia calificada innecesaria
inspection.display.name.pointless.boolean=Expresión booleana sin sentido
inspection.display.name.access.to.inaccessible.element=Acceso a elemento inaccesible
inspection.display.name.incorrect.range.argument=Argumentos de rango incorrectos
inspection.display.name.new.instance.of.singleton=Nueva instancia de clase anotada con @groovy.lang.Singleton
inspection.display.name.check.labeled.statement=Inspección de declaración etiquetada
inspection.display.name.variable.can.be.final=La variable puede ser final
inspection.display.name.equals.between.inconvertible.types='equals()' entre objetos de tipos inconvertibles
inspection.display.name.singleton.constructor=Constructor @Singleton
inspection.message.access.to.static.field.locked.on.instance.data=El acceso al campo estático <code>\#ref</code> está bloqueado en los datos de instancia \#loc
inspection.message.assignment.replaceable.with.operator.assignment=<code>\#ref</code> se puede simplificar a ''{0}'' \#loc
inspection.message.assignment.to.for.loop.parameter=Asignación al parámetro de bucle for ''\#ref'' \#loc
inspection.message.assignment.to.method.parameter=Asignación al parámetro del método ''\#ref'' \#loc
inspection.message.ref.statement=\#ref declaración \#loc
inspection.message.call.to.thread.ref.in.a.loop=La llamada a <code>Thread.\#ref()</code> dentro del bucle puede estar ocupada esperando \#loc
inspection.message.conditional.expression.can.be.call=Una expresión condicional puede ser una llamada \#loc
inspection.message.conditional.expression.can.be.elvis=La expresión condicional puede ser elvis \#loc
inspection.message.conditional.expression=Expresión condicional \#loc
inspection.message.conditional.expression.with.identical.branches=Expresión condicional \#loc con la misma rama
inspection.message.ref.can.be.simplified=''\#ref'' se puede simplificar a \#loc
inspection.message.ref.statement.can.be.simplified=La declaración \#ref se puede simplificar a \#loc
inspection.message.constant.name.ref.too.short=El nombre de la constante ''\#ref'' es demasiado corto
inspection.message.constant.name.ref.too.long=El nombre de la constante ''\#ref'' es demasiado largo
inspection.message.constant.name.ref.doesnt.match.regex=El nombre de la constante ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
inspection.message.ref.inside.finally.block=''\#ref'' \#loc en el bloque ''finalmente''
inspection.message.divide.by.zero=Dividir por cero \#loc
inspection.message.double.checked.locking=Cerradura de doble verificación \#loc
inspection.message.double.negation.ref=Doble negación \#ref \#loc
inspection.message.duplicate.switch.case.ref=Caja de interruptor duplicada ''\#ref'' \#loc
inspection.message.empty.ref.block=Bloque ''\#ref'' vacío \#loc
inspection.message.ref.statement.has.empty.branch=La rama de la declaración ''\#ref'' está vacía
inspection.message.ref.statement.has.empty.body=El cuerpo de la declaración ''\#ref'' está vacío
inspection.message.fallthrough.in.switch.statement=Fallo de la declaración de cambio \#loc
inspection.message.gstring.used.as.maps.key=GString se usó como clave de mapa \#loc
inspection.message.ref.statement.cannot.complete.without.throwing.exception=La declaración <code>\#ref</code> no se completará sin generar una excepción \#loc
inspection.message.code.ref.code.recurses.infinitely.can.only.complete.by.throwing.exception=<code>\#ref</code> se repite infinitamente y debe generar una excepción para completar \#loc
inspection.message.instance.method.name.ref.too.short=El nombre del método de instancia ''\#ref'' es demasiado corto
inspection.message.instance.method.name.ref.too.long=El nombre del método de instancia ''\#ref'' es demasiado largo
inspection.message.instance.method.name.ref.doesnt.match.regex=El nombre del método de instancia ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
inspection.message.instance.variable.name.ref.too.short=El nombre de la variable de instancia ''\#ref'' es demasiado corto
inspection.message.instance.variable.name.ref.too.long=El nombre de la variable de instancia ''\#ref'' es demasiado largo
inspection.message.couldnt.find.property.field.with.this.name=No se puede encontrar el marco para la propiedad o campo con este nombre \#loc
inspection.message.instance.variable.name.ref.doesn.t.match.regex=El nombre de la variable de instancia ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
inspection.message.call.to.ref.can.be.keyed.access=La llamada ''\#ref'' puede ser una clave de acceso \#loc
inspection.message.ref.statement.with.identical.branches=Declaración ''\#ref'' con la misma rama \#loc
inspection.message.ref.statement.with.too.many.branches=La declaración ''\#ref'' tiene demasiadas ramas ({0}) \#loc
inspection.message.local.variable.name.ref.too.short=El nombre de la variable local ''\#ref'' es demasiado corto
inspection.message.local.variable.name.ref.too.long=El nombre de la variable local ''\#ref'' es demasiado largo
inspection.message.local.variable.name.ref.doesnt.match.regex=El nombre de la variable local ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
inspection.message.code.ref.code.statement.doesnt.loop=La declaración <code>\#ref</code> no se repite en \#loc
inspection.message.method.ref.contains.too.many.parameters.0.1=El módulo ''\#ref'' tiene demasiados parámetros ({0}>{1})
inspection.message.method.ref.has.too.many.negations=Demasiadas negaciones en el método ''\#ref'' ({0}>3)
inspection.message.ref.has.0.return.points=<code>\#ref</code> tiene {0} puntos de retorno \#loc
inspection.message.negated.conditional.expression=Expresión condicional negada \#loc
inspection.message.negated.if.condition.expression=Negado si expresión de condición \#loc
inspection.message.nested.assignment.expression=Asignación anidada \#loc
inspection.message.nested.conditional.expression=Expresión condicional anidada \#loc
inspection.message.nested.ref.statement=Declaraciones ''\#ref'' anidadas \#loc
inspection.message.non.short.circuit.boolean.expression=Expresión booleana sin cortocircuito \#loc
inspection.message.call.to.ref.outside.synchronized.context=Llamar a ''\#ref'' fuera del contexto sincronizado \#loc
inspection.message.octal.integer.ref=entero octal \#ref \#loc
inspection.message.overly.complex.arithmetic.expression=Expresión aritmética demasiado compleja \#loc
inspection.message.overly.complex.boolean.expression=Expresión booleana demasiado compleja \#loc
inspection.message.method.ref.overly.complex.cyclomatic.complexity=El método ''\#ref'' es demasiado complejo (complejidad ciclomática \={0}>{1})
inspection.message.method.ref.too.long.statement.count=El método ''\#ref'' es demasiado largo (recuento de sintaxis \={0}>{1}})
inspection.message.method.ref.overly.nested.nesting.depth=El método ''\#ref'' está demasiado anidado (profundidad de anidamiento \={0}>{1})
inspection.message.method.parameter.name.ref.too.short=El nombre del parámetro del método ''\#ref'' es demasiado corto
inspection.message.method.parameter.name.ref.too.long=El nombre del parámetro del método ''\#ref'' es demasiado largo
inspection.message.method.parameter.name.ref.doesnt.match.regex=El nombre del parámetro del método ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
inspection.message.non.private.field.accessed.in.synchronized.context=Se accede al campo no privado <code>\#ref</code> en el contexto sincronizado \#loc
inspection.message.nested.assignment=El resultado de la expresión de asignación se utiliza \#loc
inspection.message.result.increment.or.decrement.expression.used=Resultado de la expresión de incremento o decremento utilizada \#loc
inspection.message.result.of.new.ref.is.ignored=<code>Resultado del nuevo \#ref{0}</code> ignorado \#loc
inspection.message.ref.statement.at.end.closure.can.be.made.implicit=Puede hacer que la declaración \#ref al final del cierre sea implícita \#loc
inspection.message.silly.assignment=Asignación no válida \#loc
inspection.message.static.method.name.ref.too.short=El nombre del método estático ''\#ref'' es demasiado corto
inspection.message.static.method.name.ref.too.long=El nombre del método estático ''\#ref'' es demasiado largo
inspection.message.static.method.name.ref.doesnt.match.regex=El nombre del método estático ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
inspection.message.static.variable.name.ref.too.short=El nombre de la variable estática ''\#ref'' es demasiado corto
inspection.message.label.name.ref.not.supported.by.0={0} no admite el nombre de etiqueta ''\#ref''
inspection.message.static.variable.name.ref.too.long=El nombre de la variable estática ''\#ref'' es demasiado largo
inspection.message.static.variable.name.ref.doesnt.match.regex=El nombre de la variable estática ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
inspection.message.property.0.is.final=La propiedad ''{0}'' es final \#loc
inspection.message.ref.statement.with.no.default.branch=\#ref declaración sin rama predeterminada \#loc
inspection.message.synchronization.on.non.final.field.ref=El campo no final ''\#ref'' sincroniza \#loc
inspection.message.synchronization.on.ref=\ ''\#ref'' Sincronizar \#loc
inspection.message.synchronization.on.variable.ref.which.was.initialized.with.literal=Sincronizar la variable ''\#ref'' inicializada con el literal \#loc
inspection.message.synchronized.method.ref=Método sincronizado ''\#ref'' \#loc
inspection.message.call.to.system.ref=''Sistema.\#ref'' llama a \#loc
inspection.message.call.to.thread.ref=''hilo.\#ref'' llamada \#loc
inspection.message.0.can.be.simplified.to.1=''{0}'' se puede simplificar a ''{1}'' \#loc
inspection.message.property.0.is.ignored.by.map.constructor=La propiedad ''{0}'' fue ignorada por @MapConstructor \#loc
inspection.message.unconditional.call.to.ref=Llama a <code>\#ref()</code> incondicionalmente \#loc
inspection.message.ref.is.unnecessary.as.last.statement.in.loop=\#ref no es necesario como última declaración del bucle \#loc.
inspection.message.ref.is.unnecessary.as.last.statement.in.method.with.no.return.value=\#ref no es necesario como última declaración de un método sin valor de retorno \#loc.
inspection.message.unreachable.statement=Declaración inalcanzable \#loc
inspection.message.unsynchronized.method.ref.overrides.synchronized.method=El método asincronizado ''\#ref'' anula el método sincronizado \#loc
inspection.message.cannot.determine.type.ref=No se puede determinar el tipo de ''\#ref''
inspection.message.call.to.ref.outside.of.loop=Llamando a ''\#ref'' fuera del bucle \#loc
inspection.message.call.to.ref.outside.of.synchronized.context=Llamar a ''\#ref'' fuera del contexto sincronizado \#loc
inspection.message.ref.loop.spins.on.field=El bucle <code>\#ref</code> gira en el campo \#loc
inspection.message.package.name.mismatch=el nombre del paquete no coincide
inspection.message.dsl.descriptor.file.has.been.changed.and.isnt.currently.executed=El archivo descriptor DSL ha cambiado y no se está ejecutando actualmente.
inspection.message.dsl.descriptor.file.has.been.disabled.due.to.processing.error=Debido a un error de procesamiento, el archivo descriptor DSL ha sido deshabilitado.
inspection.message.traits.0.contain.clashing.methods.with.signature.1=El atributo {0} contiene un método en conflicto con la firma {1}
inspection.message.unused.catch.parameter.ref=Parámetro de captura no utilizado ''\#ref'' \#loc
inspection.message.package.name.mismatch.actual.0.expected.1=El nombre del paquete no coincide. real\: ''{0}'', requerido\: ''{1}''
inspection.message.property.not.indexable.type.must.be.array.or.list.but.found.0=Las propiedades no se pueden indexar. El tipo debe ser una matriz o una lista, pero se encontró {0}
inspection.message.type.argument.0.can.not.be.1=El argumento ''{0}'' no puede tener el tipo ''{1}''
text.class.0.is.unused=La clase {0} está en desuso
text.constructor.0.is.unused=El constructor {0} está en desuso
text.method.0.is.unused=El método {0} está en desuso
text.property.0.is.unused=La propiedad {0} está en desuso
text.parameter.0.is.unused=El parámetro ''{0}'' está en desuso
intention.category.groovy=Groovy
intention.category.conversions=Conversiones Groovy/Expression
intention.category.closures=Groovy/Closures
intention.category.comments=Groovy/Comentarios
intention.category.groovy.style=Groovy/Groovy-style
intention.category.control.flow=Groovy/Control de flujo
intention.category.groovy.declaration=Groovy/Declaración
intention.category.groovy.other=Groovy/Otro
configurable.GroovyCompilerConfigurable.display.name=Compilador Groovy
configurable.GantConfigurable.display.name=Gant
settings.compiler.alternative=Alternativamente, puede especificar el compilador Groovy-Eclipse en la <a href=\\"#\\"> página del compilador Java</a>
settings.compiler.select.path.to.groovy.compiler.configscript=Seleccione la ruta al configscript del compilador Groovy
settings.compiler.path.to.configscript=Ruta de &configscript:
settings.compiler.invoke.dynamic.support=Invocar soporte &dinámico
settings.compiler.exclude.from.stub.generation=Excluir de la generación de stub:
settings.code.style.label.indent.style=Estilo de sangría de etiqueta:
settings.code.style.label.indent.size=tamaño de sangría de etiqueta
settings.code.style.indent.statements.after.label=Declaraciones de sangría después de la etiqueta
settings.code.style.absolute=Absoluto
settings.code.style.indent.labels=Aplicar sangría a las etiquetas
settings.inlay.parameter.types=Tipos de parámetros
settings.inlay.inferred.parameter.types=Tipos de parámetros inferidos
settings.inlay.type.parameter.list=Tipo de lista de parámetros
settings.inlay.show.type.hints.for=Mostrar sugerencias de tipo para:
intention.name.replace.with.in=Cambie ''\:'' a ''en''
intention.name.activate.back=reactivar
intention.name.cast.to.0=Convertir a {0}
intention.name.replace.eq.with.0.eq=Cambie ''\='' por ''{0}\=''
intention.name.cast.operand.to.0=Transmitir operando a {0}
intention.name.add.required.attributes.to.map.constructor=Agregue las propiedades requeridas a @MapConstructor
intention.family.name.create.field=Crear campo
action.remove.dynamic.member.text=Eliminar
action.remove.dynamic.member.description=Eliminar miembro dinámico
action.collapse.all.text=Desplegar todo
action.collapse.all.description=Desplegar todo
action.expand.all.text=Expandir todo
action.expand.all.description=Expandir todo
dynamic.members.column.name.element=elementos dinámicos
dynamic.members.column.name.type=Categoría
command.name.add.dynamic.member=Agregar miembros dinámicos
popup.content.navigation.to.overriding.classes.unavailable=La navegación que anula una clase no es posible durante una actualización de índice
overriding.methods.of.0=Método de anulación ''{0}''
expression.type.no.expression=Expresión no encontrada
expression.type.unknown=<unknown>
add.class.to.extends.family.name=avatar
intention.family.name.rename=cambiar nombre
generated.stub.message=Este código auxiliar se genera para que las clases Groovy habiliten la compilación cruzada Groovy-Java.
generated.stub.navigate.link.label=Ir a la clase Groovy
generated.stub.exclude.link.label=Excluir de la generación de resguardos
module.with.groovy=Módulo simple con biblioteca Groovy adjunta
action.build.restart.text=Reiniciar después de la compilación
action.build.module.restart.description=Reiniciar después de crear el módulo ''{0}''
gdsl.investigate.link.label=Haga clic para investigar
gdsl.error.notification.title=Error de ejecución del script DSL
dialog.message.gant.not.configured=Gant no está configurado.
investigate.gdsl.error.intention.name=Ver detalles
investigate.gdsl.error.family.name=Comprobación de errores del proceso del descriptor DSL
grab.intention.name=Agarrar artefactos
grab.family.name=Grab
grab.progress.title=Procesando la anotación @Grab
grab.result.title={0} Dependencia de uva {0,choice, 0\#jar|1\#jar|2\#jar} agregada
grab.jar.count=<b>{0}</b>\: {1} {1, choice, 0\#jar|1\#jar|2\#jar}
grab.error.ivy.missing.title=falta hiedra
grab.error.ivy.missing.message=Lo sentimos, IDEA no puede @Grab dependencias sin Apache Ivy. Vuelva a ejecutar la acción agregando Apache Ivy a las dependencias de su módulo.
grab.error.0.title=@Grab no se pudo ejecutar\: {0}
this.super.completion.advertisement=Al presionar {0} dos veces sin un calificador de clase se mostrarán todos los métodos estáticos accesibles.
compact.empty.middle.packages.action.text=Comprimir un paquete intermedio vacío
compact.empty.middle.packages.action.description=Mostrar/comprimir paquete intermedio vacío
scroll.from.source.action.text=desplazarse en la fuente
scroll.from.source.action.description=Seleccione un archivo abierto en el editor activo
optimize.imports.progress.title=Optimizando declaraciones de importación en un archivo Groovy...
mvc.framework.0.library.label={0} biblioteca\:
mvc.framework.0.not.configured.for.module.1={0} SDK no está configurado para el módulo ''{1}''
mvc.framework.0.configure.sdk.label={0} configuración del SDK
mvc.framework.0.module.1.has.no.sdk=El módulo ''{1}'' no tiene el SDK {0}.
mvc.framework.0.module.builder.description=El módulo {0} se utiliza para crear la aplicación {0}
mvc.framework.0.sdk.not.found.title={0} SDK no encontrado
mvc.framework.0.change.sdk.version.title={0} Cambio de versión del SDK
mvc.framework.0.run.target.action.text=Ejecutar {0} objetivo
mvc.framework.0.run.target.action.description=Ejecute {0} objetivos aleatorios
mvc.framework.0.run.target.dialog.title=Ejecutar {0} objetivo
mvc.framework.0.run.target.interactive=&Iniciar la consola {0} en modo interactivo
mvc.run.target.options.border.title=opción
mvc.run.configuration.command.line.label=Línea de comando (&C)\:
mvc.run.configuration.no.module=Módulo no especificado
mvc.run.configuration.disposed.module=El módulo ha quedado obsoleto.
mvc.console.cannot.start.process.error.title=No se pudo iniciar el proceso
mvc.console.executing.progress=ejecución...
mvc.console.0.executing.progress={0}\: Ejecutando...
mvc.console.execution.error.title=La ejecución del comando falló\: {0}
mvc.console.kill.process.action.text=Proceso de muerte forzada
mvc.console.kill.process.action.description=Proceso de muerte forzada
mvc.run.configuration.add.classpath.label=Agregar --classpath
mvc.run.configuration.add.classpath.0.label=Agregar --classpath\: {0}
mvc.no.jdk.found.error.title=JDK no encontrado
mvc.no.jdk.found.error.message=La estructura del proyecto {0} no se puede crear porque no se ha especificado un JDK para el módulo ''{1}''.\n¿Le gustaría especificar un JDK?
replace.all.occurrences.and.remove.variable.0=Reemplazar todos los usos y eliminar la variable ''{0}''
introduce.variable.declare.final.label=Declarar y final
introduce.variable.replace.all.occurrences=&Reemplazar todos los usos
introduce.variable.replace.all.0.occurrences=Reemplazar todos los usos ({0} ubicaciones)
introduce.parameter.delegate.via.overload=Delegación mediante métodos sobrecargados
introduce.parameter.replace.fields.border.title=Convertir campos utilizados en expresiones en captadores
introduce.parameter.do.not.replace.option.label=&No reemplazar
introduce.parameter.replace.inaccessible.fields.option.label=&Reemplazar campos que no son accesibles en el contexto de uso
introduce.parameter.replace.all.fields.option.label=&Reemplazar todos los campos
introduce.variable.type.label=Escriba &T\:
introduce.variable.name.label=&Nombre\:
introduce.parameter.explicit.return.statement.option.label=Utilice una declaración de devolución explícita (&X)
introduce.parameter.delegating.unavailable.tooltip=No se permite la delegación en contexto de cierre
introduce.variable.change.type.advertisement=Presione {0} para cambiar el tipo
framework.0.home.label={0} Inicio\:
select.framework.0.home.title={0} Seleccione Inicio
framework.0.sdk.chooser.title={0} SDK
framework.0.sdk.chooser.description=Seleccione el directorio que contiene la distribución {0}
framework.0.sdk.chooser.error.message=La distribución {0} en la ruta especificada parece estar rota. No se puede determinar la versión.
framework.0.sdk.chooser.error.title=Error al crear la clase
framework.0.library={0} biblioteca
framework.0.library.version.1={0} versión de biblioteca {1}
framework.gant=Gant
script.runner.display.name=Groovy
script.runner.description=Clase o guión maravilloso
script.runner.chooser.title=ruta del script
script.runner.chooser.description=Especifique la ruta del script\:
script.runner.module.not.specified.message=Módulo no especificado
script.runner.no.groovy.for.module=Groovy no está configurado para el módulo ''{0}''
script.runner.cant.find.script=Script ''{0}'' no encontrado
script.runner.unknown.script.type=Tipo de secuencia de comandos desconocido ''{0}''
script.runner.file.is.not.groovy.file=El archivo de script no es un archivo Groovy
script.runner.class.does.not.exist=No hay clases.
script.runner.class.cannot.be.executed=La clase no se puede ejecutar
shell.cannot.run.title=no puede correr
dialog.title.refactoring.unavailable.in.current.scope=Refactorización no disponible en el alcance actual
parameter.list.owner.chooser.title=Insertar parámetros como
extract.closure.command.name=Extracción de cierre
introduce.constant.title=Insertar constante
undefined.library.version=No definida
method.parameters.count.max.parameters.option=Número máximo de parámetros\:
method.returns.max.returns.option=Límite de punto de retorno\:
overly.complex.method.complexity.limit.option=Límites de complejidad del método\:
overly.long.method.statements.limit.option=Número máximo de declaraciones por método\:
overly.nested.method.nesting.limit.option=Profundidad máxima de anidamiento\:
add.method.family=Agregar método
change.base.method.label=Cambiar el método predeterminado
change.usages.label=Cambia dónde lo usas
convert.parameter.to.map.entry.title=Convertir parámetros en elementos de mapa
live.template.context.declaration=Declaración
live.template.context.expression=expresión
live.template.context.statement=construcción
find.usages.method.0.of.class.1={0} de {1}
change.signature.type.column=categoría
change.signature.default.initializer.column=inicializador predeterminado
static.import.method.fix=método de importación estática...
static.import.method.0.fix=método de importación estática ''{0}''
groovy.consoles.type=Consola Groovy
getter.kind.gdk.method.0=Método GDK {0}
getter.kind.method.0=Método {0}
getter.kind.getter.0=getter {0}
parameter.hint.number.of.arguments={0,choice, 0\#|1\#{0} argumento|2\#{0} argumento}
surround.with.for=for
surround.with.if=if
surround.with.if.else=if/else
surround.with.if.expr=if (expr)
surround.with.if.else.expr=if (expr)/else
surround.with.parentheses=(expr)
surround.with.closure={ ->... }.call()
surround.with.try=try
surround.with.try.catch=try/catch
surround.with.try.finally=try/finally
surround.with.try.catch.finally=try/catch/finally
surround.with.while=while
surround.with.while.expr=while (expr)
surround.with.cast=((Type) expr)
surround.with.with=with () {...}
surround.with.with.expr=with (expr)
surround.with.shouldFail=shouldFail () {...}
code.style.group.list.map.literals=Literales de lista y mapa
code.style.option.align.when.multiple=Ordenar si son múltiples
code.style.option.align.multiline.named.arguments=Ordenar argumentos con nombre en varias líneas
code.style.option.use.flying.geese.braces=Coloque la llave de cierre en una línea.
code.style.option.import.annotations=Obtener anotaciones
code.style.option.simple.lambdas.closures.in.one.line=Lambda/cierre simple en una línea
code.style.option.relational.operators=Operadores relacionales (<, >, <\=, >\=, <\=>)
code.style.option.unary.operators=Operadores unarios (\!, -, +, ++, --, *)
code.style.option.in.named.argument.before.colon=Dentro de los argumentos con nombre antes de ''\:''
code.style.option.in.named.argument.after.colon=Dentro del argumento nombrado después de ''\:''
code.style.option.list.maps.literals=Literales de lista y mapa
code.style.option.closure.left.brace.in.method.calls=Cierre de llave izquierda dentro de la llamada al método
code.style.option.gstring.injection.braces=Tirantes de inserción GString
code.style.option.tuple.assignment.expression=Expresión de asignación de tupla
code.style.option.regexp.expression=Expresión regular (\=\=~, \=~)
code.style.option.before.assert.separator=Antes del delimitador ''afirmar''
code.style.option.after.assert.separator=Después del delimitador ''afirmar''
singleton.constructor.found=Las clases @Singleton no pueden contener constructores
singleton.constructor.remove=Eliminar constructor
singleton.constructor.makeNonStrict=Establecer @Singleton como no estricto
unused.import=Declaración de importación no utilizada
optimize.imports=Optimización de declaración import
optimize.all.imports=Optimice las declaraciones de importación no utilizadas
dialog.create.class.package.chooser.title=Seleccionar paquete de destino
create.directory.command=Crear directorio
destination.package=Paquete objetivo\:
second.unsafe.call=Segunda llamada insegura
call.can.throw.npe=La cadena de llamadas puede generar NullPointerException
unused.default.parameter.message=Los parámetros predeterminados no se utilizan
unused.default.parameter.fix=Eliminar inicializador
unused.assignment.tooltip=La tarea no se utiliza
unused.variable=La variable no se utiliza
variable.can.be.final.tooltip=La variable ''{0}'' puede ser final
parameter.can.be.final.tooltip=El parámetro ''{0}'' puede ser final
equals.between.inconvertible.types.tooltip=<code>{0}</code> está entre objetos de tipo ''{1}'' y ''{2}'' que no se pueden convertir
replace.with.operator.message=Puedes reemplazar ''{0}'' con un operador
replace.with.operator.fix=Reemplace ''{0}'' con operador
replace.with.operator.double.negation.option=Usar dobles negativos (por ejemplo, \: \!\!)
replace.with.operator.compareTo.equality.option=Cambiar la ecuación ''compareTo'' a igual (por ejemplo, \=\=)
replace.with.operator.parentheses=No sugiere reemplazar con operador si se necesitan paréntesis adicionales
replace.with.method.message=Se puede reemplazar con la llamada al método ''{0}''
replace.with.method.fix=Reemplazar con el método ''{0}''
unassigned.access.tooltip=Es posible que la variable ''{0}'' no esté asignada
no.return.message=Algunas rutas de ejecución no devuelven valores
unresolved.type.status=El tipo ''{0}'' no se resuelve
no.type.specified=No se especifica ningún tipo
dynamic.element=elementos dinámicos
pointless.boolean.problem.descriptor=\#ref se puede simplificar a ''{0}'' \#loc
pointless.arithmetic.error.message=Puedes reemplazar \#ref con ''{0}'' \#loc
pointless.boolean.quickfix=arrasamiento
Cannot.perform.undo.operation=Las operaciones no se pueden deshacer
Undo.disable=Deshacer deshabilitar
type.doesnt.contain.method=El tipo ''{0}'' no tiene el método ''{1}'', por lo que ese tipo no se puede iterar en su alcance
type.doesnt.implement.comparable=El tipo ''{0}'' no implementa Comparable
add.method=Agregue el método ''{0}()'' a ''{1}''
implement.class={0} implementación
fix.class=Modificar clase {0}
rtype.cannot.contain.ltype=''{1}'' no puede contener ''{0}''
new.instance.of.singleton=Una nueva instancia de la clase anotada @groovy.lang.Singleton.
replace.new.expression.with.instance.access=Cambiar al acceso a la instancia
getter.0.clashes.with.getter.1=Se produjo un conflicto: ''{0}'' con ''{1}''
unused.0=sin usar {0}
remove.0=eliminar {0}
replace.postfix.0.with.prefix.0=Reemplace el sufijo {0} con el prefijo {0}
replace.0.with.1=Convertir {0} a binario {1}
local.var.0.is.reassigned=Se asignó la variable local ''{0}''
anonymous.class=clase anónima
closure=cierre
other.scope=Otra gama
method.may.be.static=El método puede ser estático.
method.may.be.static.option.ignore.trait.methods=Anulación del método de atributo
method.may.be.static.only.private.or.final.option=Inspeccionar solo métodos finales o privados.
method.may.be.static.ignore.empty.method.option=Ignorar métodos vacíos
ignore.boolean.expressions=Ignorar variables no asignadas al verificar booleano
highlight.if.groovy.object.methods.overridden=Resalte referencias en clases que anulan invokeMethod(), getProperty() o setProperty()
highlight.if.missing.methods.declared=Resalte referencias en clases que declaran MissingMethod() o MissingProperty()
gr.package.inspection.check.scripts=Inspección de guión
java.style.property.access=Llamadas de acceso al estilo Java
type.customizer.is.not.marked.as.a.resource.file=El script del personalizador de tipos no está marcado como recurso del compilador.
add.to.resources=Agregar al recurso
add.type.customizer.to.resources=Agregar script de personalizador de tipo al recurso
target.0.does.not.exist=El objetivo ''{0}'' no existe
target.annotation.is.unused=@Target está en desuso
change.lvalue.type=Cambiar el tipo de variable ''{0}'' a ''{1}''
replace.qualified.name.with.import=Reemplazo de nombres completos con declaraciones de importación
comments.count.as.content=Contar comentarios como contenido
ignore.when.catch.parameter.is.named.ignore.or.ignored=Se ignora si el parámetro catch se denomina ignorar o ignorar.
no.applicable.signature.found=No se encontró ninguna firma aplicable
expected.type.0=''{0}'' requerido pero ''{1}'' encontrado
declare.explicit.implementations.of.trait=Declaración de implementación explícita de un rasgo
unnecessary.modifier.description=El controlador ''{0}'' no es necesario
unnecessary.modifier.remove=Eliminar ''{0}'' innecesario
unnecessary.def.explicitly.typed.only=Informar solo sobre declaraciones escritas explícitamente
unnecessary.alias.fix=Eliminar alias innecesarios
unnecessary.alias.description=No se necesita alias
unnecessary.semicolon.description=No se requiere punto y coma
unnecessary.semicolon.fix=Quitar punto y coma
dynamic.dialog.class.label=&Clase\:
dynamic.dialog.type.label=Escriba &T\:
dynamic.dialog.static.checkbox=&silencio
find.method.ro.method.usages=Buscando la ubicación del uso del método adjunto en el archivo del proyecto
find.method.ro.closure.usages=Búsqueda del uso de cierres adjuntos en archivos de proyecto
conversion.method.not.allowed.in.non.groovy.files=La refactorización no está disponible para métodos utilizados en archivos que no sean Groovy\:
conversion.closure.not.allowed.in.non.groovy.files=La refactorización no está disponible para cierres utilizados en archivos que no sean Groovy\:
wrong.method.first.parameter.type=El método ''{0}'' se utiliza con argumentos con nombre, pero el primer argumento interno ''{1}'' no se ajusta al tipo de mapa.
wrong.closure.first.parameter.type=El cierre ''{0}'' se utiliza con argumentos con nombre, pero el primer argumento dentro de ''{1}'' no se ajusta al tipo de mapa.
map.parameter.dialog.create.new.checkbox=&Crear parámetros para argumentos con nombre
map.parameter.dialog.explicit.type.checkbox=Especificar el tipo explícitamente
convert.cannot.itself=La refactorización no se puede utilizar en el parámetro del mapa en sí.
map.param.name=Nombre del parámetro de mapa (&N)\:
convert.param.to.map.entry=Convertir parámetros en elementos de mapa
closure.used.as.variable=Se aprobó un cierre como argumento. La refactorización puede cambiar el significado.
do.you.want.to.change.method.return.type=¿Le gustaría cambiar el tipo de retorno del método ''{0}''?
do.you.want.to.change.variable.type=¿Quieres cambiar el tipo de ''{0}''?
closure.is.accessed.outside.of.groovy=Se accede al campo <b>{0}</b> fuera de Groovy
write.access.to.closure.variable=Acceso de escritura al campo <b>{0}</b>
field.is.used.in.argument.label=El campo <b>{0}</b> se utiliza en etiquetas de argumentos.
method.with.signature.already.exists=Ya existe un método con firma {0}
field.already.exists=El campo <b>{0}</b> ya existe
method.is.used.outside.of.groovy=El método se utiliza fuera de Groovy.
do.you.want.to.change.type.of.parameter.in.method=¿Quiere cambiar el tipo de parámetro ''{0}'' en el método ''{1}''?
file.exists=El archivo ''{0}'' ya existe en el directorio ''{1}''
move.to.correct.dir.family.name=Mover archivos al paquete correcto
move.to.correct.dir=Ir a ''{0}''
add.return.type=Agregar tipo de devolución
add.return.type.to.method.declaration=Agregar tipo de retorno a la declaración del método
infer.method.parameters.types=Agregar tipos explícitos a los parámetros
infer.method.parameters.types.for.method.declaration=Agregue tipos explícitos para todos los parámetros en la declaración del método
replace.with.wrapper=Reemplazar con {0}
replace.primitive.type.with.wrapper=Reemplazo de tipos de base con envoltorios
remove.parameter.0=Eliminar parámetro ''{0}''
remove.unused.parameter=Eliminar parámetros no utilizados
remove.exception=eliminar excepción
remove.catch.block=Quitar bloque de captura
try.catch.fix=arreglar try-catch
cannot.create.class=No se puede crear la clase
rename.file.to.0=Cambiar el nombre del archivo a ''{0}''
java.style.properties.invocation.intention.family.name=Cambie las llamadas de acceso al estilo Java a referencias de propiedades al estilo Groovy
java.style.properties.invocation.intention.name=Cambiar a la referencia de propiedad de estilo Groovy
generate.equals.and.hashcode.already.defined.warning.anonymous=equals() y hashCode() ya están definidos
generate.equals.and.hashcode.already.defined.warning=equals() y hashCode() ya están definidos
generate.equals.and.hashcode.already.defined.title=equals() y hashCode() ya están definidos
generate.equals.compare.nested.arrays.comment=// matriz anidada aquí {0} - comparar valores
generate.equals.compare.arrays.comment=// Comparar matrices Object[] con Arrays.equals puede ser incorrecta
generate.property.missing.already.defined.warning=propertyMissing() ya está definido
generate.property.missing.already.defined.title=propertyMissing() ya está definido
generate.method.missing.already.defined.warning=métodoMissing() ya está definido
generate.method.missing.already.defined.title=métodoMissing() ya está definido
action.Gant.NewScript.text=guión de gant
action.Gant.NewScript.description=Crear un nuevo script Gant
action.Groovy.Console.text=Consola Groovy
action.Groovy.Console.description=Inicia la consola Groovy
module.name.0.and.groovy.version.1={0} ({1})
groovy.version.0=Groovy {0}
groovy.version.bundled.0=Paquete maravilloso {0}
configurable.greclipse.border.title=Opciones de Groovy-Eclipse
configurable.greclipse.path.label=ruta del jar groovy-eclipse-batch\:
configurable.greclipse.path.chooser.description=Seleccione la ruta groovy-eclipse-batch-*.jar para la versión que coincida con su distribución Groovy
configurable.greclipse.command.line.params.label=Parámetros de línea de comando adicionales\:
configurable.greclipse.debug.checkbox=Generar información de depuración
configurable.hotswap.checkbox=Habilitación del agente de intercambio en caliente en código Groovy
configurable.hotswap.checkbox.description=Puede causar problemas de serialización en aplicaciones depuradas
run.configuration.script.path.label=Ruta del script\:
run.configuration.vm.options.label=Opciones de máquina virtual (&V)\:
run.configuration.module.chooser.label=&Módulo\:
run.configuration.module.classpath.checkbox=Agregar classpath del módulo al corredor
pull.up.wont.be.accessible.from={1} no puede acceder a {0}
pull.up.wont.be.accessible.from.the.subclass={0} usa {1} al que no se puede acceder desde subclases.
pull.up.abstract.wont.be.accessible.from={0} no se puede hacer abstracto porque no se puede acceder a él desde las subclases.
gdsl.trusted.project.message=This project contains Groovy DSL (GDSL) scripts, which improve code insight experience when editing Groovy code. GDSL scripts might contain potentially malicious code, which will be executed within the IDE. Would you like to run them?
gdsl.trusted.project.answer.trust=Yes
gdsl.trusted.project.answer.dont.trust=No
