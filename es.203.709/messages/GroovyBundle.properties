language.groovy=Groovy
file.type.dgm=Groovy 확장 모듈 설명자 파일
file.type.logback=Groovy Logback DSL 구성
file.type.gdsl=IntelliJ Groovy DSL 구성
action.Mvc.RunTarget.text=Ejecutar comando
action.Mvc.RunTarget.description=Ejecutar comando arbitrario Grails/Griffon
action.Mvc.Upgrade.text=Cambiar la versión del SDK
action.Mvc.Upgrade.description=Cambiar la versión del SDK de Grails/Griffon
group.Mvc.Actions.text=Grails/Griffon
title.groovy.shell=Groovy 셸
action.Groovy.Shell.text=Groovy Shell...
action.Groovy.Shell.description=Lanzar el shell Groovy
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.text=propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.description=La acción genera propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.text=methodMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.description=La acción genera propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.text=equals() y hashCode()
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.description=La acción genera equals y hashCode ahora
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.text=Getter y Setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.description=Genera getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.text=Setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.description=Genera setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.text=Getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.description=Genera getter
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.text=Constructor
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.description=Genera constructor
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.text=to_String()
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.description=Generar método toString()
action.ExcludeFromStubGeneration.text=Excluir de la generación de stub
action.ExcludeFromStubGeneration.description=No genere stubs de Java para este archivo Groovy en la compilación
action.DumpGroovyControlFlowAction.text=Volcar Flujo de control Groovy
action.ConvertToCompileStatic.text=Convertir a @CompileStatic
action.ConvertToCompileStatic.description=Convertir archivos Groovy a @CompileStatic
action.ConvertGroovyToJava.text=Convertir a Java
action.ConvertGroovyToJava.description=Convertir archivos Groovy a Java
action.Groovy.NewScript.text=Script maravilloso
action.Groovy.NewScript.description=Crear nuevo script Groovy
action.Groovy.NewClass.text=Clase Groovy
action.Groovy.NewClass.description=Crear nueva clase Groovy
action.Groovy.CheckResources.Rebuild.text=_Rebuild Resources
action.Groovy.CheckResources.Rebuild.description=Ejecute el compilador para todos los archivos Groovy en las raíces de recursos para comprobar si hay problemas de compilación
action.Groovy.CheckResources.Make.text=_Build Resources
action.Groovy.CheckResources.Make.description=Ejecute el compilador incremental para archivos Groovy en las raíces de recursos para comprobar si hay problemas de compilación
group.Groovy.CheckResources.text=Gr_oovy Recursos
group.Groovy.CheckResources.description=Ejecute el compilador de archivos Groovy en las raíces de recursos para comprobar si hay problemas de compilación
action.Groovy.Shell.Execute.text=Ejecutar código Groovy
action.Groovy.Shell.Execute.description=Ejecutar código Groovy en la consola

file.template.group.title.groovy=Groovy

groovy.term.class=clase
groovy.term.interface=interfaz
groovy.term.trait=rasgo
groovy.term.enum=enumeración
groovy.term.annotation=anotación
groovy.term.method=método
groovy.term.field=campo
groovy.term.property=propiedad
groovy.term.parameter=parámetro
groovy.term.variable=variable local
groovy.term.binding=variable de enlace de script
groovy.term.label=etiqueta
groovy.term.closure=cierre
groovy.term.expression=Expresión
new.class.action.text=Clase Groovy
new.class.action.description=Crea una nueva clase Groovy
new.class.dialog.title=새 Groovy 클래스
new.class.list.item.class=클래스
new.class.list.item.interface=인터페이스
new.class.list.item.trait=특성
new.class.list.item.enum=열거형
new.class.list.item.annotation=어노테이션
invalid.qualified.name=유효한 Groovy 정규화된 이름이 아닙니다
new.script.action.text=Groovy 스크립트
new.script.action.description=새 Groovy 스크립트 생성
new.script.dialog.title=새 Groovy 스크립트 이름 입력
new.script.list.item.script=Groovy 스크립트
new.script.list.item.script.dsl=GroovyDSL 스크립트
new.gant.script.dialog.title=새 Gant 스크립트
new.gant.script.dialog.message=새 Gant 스크립트 이름 입력
debug.option=Habilitar y &depurar el seguimiento de la pila
groovy.debug.disable.specific.methods=No entre en clases específ&icas de Groovy
groovy.debug.caption=Groovy
########################################################################################################################
# Parser error messages
########################################################################################################################
identifier.expected=Identificador esperado
identifier.or.block.expected=Identificador o bloque de código esperado
string.end.expected=Se espera el final de la cadena
try.without.catch.finally='intentar' sin 'atrapar' o 'finalmente'
expression.expected=Expresión esperada
duplicate.modifier=Modificador duplicado ''{0}''
########################################################################################################################
# Intentions & error messages
########################################################################################################################
cannot.resolve=No se puede resolver el símbolo ''{0}''
cannot.access=El acceso a ''{0}'' excede sus derechos de acceso
cannot.reference.non.static=No se puede hacer referencia al símbolo no estático ''{0}'' desde el contexto estático
cannot.return.from.constructor=No se puede devolver un objeto del constructor
cannot.return.from.void.method=No se puede devolver un objeto de un método que devuelve 'void'
cannot.return.type=No se puede devolver ''{0}'' del método que devuelve ''{1}''
cannot.apply.method.or.closure=''{0}'' no se puede aplicar a ''{1}''
cannot.apply.method1=''{0}'' in ''{1}'' no se puede aplicar a ''{2}''
cannot.apply.constructor=El constructor ''{0}'' en ''{1}'' no se puede aplicar a ''{2}''
cannot.apply.default.constructor=No se puede aplicar el constructor predeterminado para la clase ''{0}''
cannot.instantiate.abstract.class=No se puede crear una instancia de la clase abstracta ''{0}''
cannot.instantiate.interface=No se puede crear una instancia de la interfaz ''{0}''
missing.required.named.parameter=Falta el parámetro con nombre obligatorio ''{0}''
loss.of.precision=Posible pérdida de precisión de ''{0}'' a ''{1}''
cannot.assign=No se puede asignar ''{0}'' a ''{1}''
cannot.cast=No se puede transmitir ''{0}'' a ''{1}''
multiple.assignments.without.list.expr=Múltiples asignaciones sin expresiones de lista en el lado derecho no son compatibles en el modo de verificación de tipo estático
spread.operator.is.not.available=El operador de propagación no se puede usar como argumento con verificación de tipo estático
replace.with.list.literal=Reemplazar con lista literal
replace.with.get.at=Reemplazar con acceso de índice
incorrect.number.of.values=Número incorrecto de valores. Esperado: {0} Era: {1}
invalid.lvalue=Valor no válido para asignar
duplicate.class=Class ''{0}'' ya existe en ''{1}''
duplicate.inner.class=Clase duplicada: ''{0}''
script.generated.with.same.name=Hay una clase sintética ''{0}'' generada para el código del script
variable.already.defined=Variable ''{0}'' ya definida
field.already.defined=Campo ''{0}'' ya definido
create.class.family.name=Crear clase
create.class.text=Crear clase {0}
create.interface.text=Crear interfaz {0}
create.annotation.text=Crear anotación {0}
constructors.are.not.allowed.in.anonymous.class=Los constructores no están permitidos en la clase anónima
no.such.property=La propiedad ''{0}'' no existe
change.modifier=Hacer ''{0}'' {1}
change.modifier.not=Hacer ''{0}'' no {1}
change.modifier.family.name=Cambiar modificadores
parameter.cast.fix=Transmitir el parámetro {0, número, ordinal} a {1}
action.convert.lambda.to.closure=Convertir lambda en cierre
add.parenthesis.to.lambda.parameter.list=Agregar paréntesis a la lista de parámetros
# suprimir la inspección "UnusedProperty"
packageLocal.visibility.presentation=Visibilidad predeterminada
# suprimir la inspección "UnusedProperty"
protected.visibility.presentation=protected
# suprimir la inspección "UnusedProperty"
private.visibility.presentation=privado
# suprimir la inspección "UnusedProperty"
public.visibility.presentation=public
# suprimir la inspección "UnusedProperty"
abstract.visibility.presentation=abstract
# suprimir la inspección "UnusedProperty"
static.visibility.presentation=static
# suprimir la inspección "UnusedProperty"
final.visibility.presentation=final
# suprimir la inspección "UnusedProperty"
native.visibility.presentation=native
# suprimir la inspección "UnusedProperty"
synchronized.visibility.presentation=sincronizado
# suprimir la inspección "UnusedProperty"
strictfp.visibility.presentation=strictfp
# suprimir la inspección "UnusedProperty"
transient.visibility.presentation=transient
# suprimir la inspección "UnusedProperty"
volatile.visibility.presentation=volatile
# suprimir la inspección "UnusedProperty"
def.visibility.presentation=def
intention.family.name.convert.conditional.expression.to.elvis=조건식을 elvis로 변환
intention.family.name.replace.with.keyed.access=키 액세스로 바꾸기
intention.family.name.fix.range.class=범위 등급 수정
intention.family.name.make.return.implicit=반환을 묵시적으로 설정
intention.family.name.simplify=단순화
intention.family.name.remove.unnecessary.continue=불필요한 continue 제거
intention.family.name.remove.unnecessary.return=불필요한 return 제거
intention.family.name.add.parameter.cast=매개변수 형 변환 추가
intention.family.name.replace.for.each.operator=for-each 연산자 바꾸기
intention.family.name.add.cast=형 변환 추가
intention.family.name.change.variable.type=변수 유형 변경
intention.family.name.replace.with.conditional.call=조건 호출로 바꾸기
intention.family.name.collapse.conditional.expressions=조건식 접기
intention.family.name.remove.double.negation=이중 부정 제거
intention.family.name.activate.dsl.descriptor=DSL 설명자 활성화
intention.family.name.collapse.if.statement=''if'' 문'' 접기
intention.family.name.replace.with.short.circuit.expression=단락 표현식으로 바꾸기
intention.family.name.replace.something.with=''{0}'' 을(를) ''{1}'' (으)로 바꾸기
intention.family.name.add.attributes.to.annotation=어노테이션에 속성 추가
illegal.combination.of.modifiers=Combinación ilegal de modificadores
illegal.combination.of.modifiers.abstract.and.final=Combinación ilegal de modificadores 'abstracto' y 'final'
modifier.volatile.not.allowed.here=Modificador 'volátil' no permitido aquí
modifier.transient.not.allowed.here=Modificador 'transitorio' no permitido aquí
modifier.0.not.allowed=Modificador ''{0}'' no permitido aquí
interface.cannot.have.modifier.final=La interfaz no puede tener el modificador 'final'
script.method.cannot.have.modifier.abstract=El método de script no puede tener el modificador 'abstracto'
script.cannot.have.modifier.native=El script no puede tener el modificador 'nativo'
interface.must.have.no.static.method=La interfaz no debe tener un método estático
only.abstract.class.can.have.abstract.method=Solo la clase abstracta puede tener un método abstracto
anonymous.class.cannot.have.abstract.method=La clase anónima no puede tener un método abstracto
illegal.combination.of.modifiers.volatile.and.final=Combinación ilegal de modificadores 'volátil' y 'final'
variable.cannot.be=La variable no puede tener el modificador ''{0}''
remove.modifier=Eliminar ''{0}''
not.abstract.method.should.have.body=El método no abstracto debe tener cuerpo
cannot.create.class.error.text=No se puede crear la clase ''{0}'': {1}
cannot.create.class.error.title=No se puede crear una clase
no.class.in.file.template=No se encontró ninguna clase en la plantilla de archivo
Inner.methods.are.not.supported=Los métodos internos no son compatibles
final.class.cannot.be.extended=La clase final no se puede extender

# Groovy 1.7 cheques
unsupported.inner.class.0=Las clases internas no son compatibles con Groovy {0}
unsupported.anonymous.class.0=Las clases anónimas no son compatibles con Groovy {0}

# Groovy 1.8 cheques
unsupported.diamonds.0=Los diamantes no son compatibles con Groovy {0}
unsupported.command.syntax.0=La sintaxis de la expresión de comando no es compatible con Groovy {0}
unsupported.dollar.slashy.string.0=Las cadenas de barras inclinadas en dólares no son compatibles con Groovy {0}
unsupported.multiline.slashy.string.0=Las cadenas de barras inclinadas de varias líneas no son compatibles con Groovy {0}

#Groovy 2.3 controles
unsupported.traits.0=Los rasgos no son compatibles con Groovy {0}

#Groovy 2.5 cheques
duplicating.named.parameter=El parámetro con nombre duplicado ''{0}'' ocurre en los parámetros: {1}
field.should.be.immutable=El campo ''{0}'' debe tener un tipo inmutable o declararse así con @ImmutableOptions
immutable.options.property.not.exist=La propiedad ''{0}'' no existe

explicit.includes.and.excludes=''includes'' 및 ''excludes'' 중 하나만 제공해야 합니다
require.closure.as.attribute.value=속성 값으로 클로저가 필요합니다
initializers.are.forbidden.with.defaults=@TupleConstructor에서 ''defaults''를 비활성화하면 기본값은 금지됩니다
super.is.not.allowed.in.pre.with.call.super=super 호출은 ''callSuper''가 활성화된 ''pre''에서 허용되지 않습니다
#Groovy 3.0 checks
illegal.default.modifier=El modificador 'predeterminado' solo tiene sentido en los métodos de la interfaz
illegal.default.modifier.fix=Eliminar modificador 'predeterminado'
default.modifier.in.old.versions=El modificador 'predeterminado' está disponible con Groovy 3.0 o posterior
unsupported.do.while.statement='hacer mientras' no es compatible con la versión actual
unsupported.tuple.declaration.in.for=La declaración de tupla en la inicialización 'for' no es compatible con la versión actual
unsupported.multiple.variables.in.for=Varias variables en la inicialización 'for' no son compatibles con la versión actual
unsupported.expression.list.in.for.update=Varias expresiones en la actualización 'for' no son compatibles con la versión actual
unsupported.resource.list='probar' con recursos no es compatible con la versión actual
unsupported.array.initializers=Los inicializadores de matriz no son compatibles con la versión actual
operator.is.not.supported.in=El operador ''{0}'' no es compatible con la versión actual
unsupported.negated.in=Negated 'in' no es compatible con la versión actual
unsupported.negated.instanceof=La 'instancia de' negada no es compatible con la versión actual
unsupported.elvis.assignment=La asignación de Elvis no es compatible con la versión actual
unsupported.safe.index.access=El acceso seguro al índice no es compatible con la versión actual
unsupported.lambda=Lambdas no son compatibles con la versión actual
unsupported.type.annotations=Las anotaciones de tipo no son compatibles con la versión actual
unsupported.tuple.application.initializer=애플리케이션 이니셜라이저는 현재 버전에서 지원되지 않습니다
illegal.single.argument.lambda=La forma de un solo argumento de lambda está disponible solo como parte derecha de la expresión de asignación o como argumento dentro de la llamada al método
method.is.not.implemented=El método ''{0}'' no está implementado
change.implements.and.extends.classes=Normalizar extiende e implementa listas

fix.package.name=Corregir el nombre del paquete

checkbox.delegate.via.overloading.method=오버로드 메서드를 통한 위임
checkbox.ignore.conditional.operators=조건 연산자 무시
checkbox.ignore.obscure.operators=모호한 연산자 무시
checkbox.ignore.double.checked.locking.on.volatile.fields=휘발성 필드에서 이중 검사된 잠금 무시
checkbox.inspect.anonymous.closures=익명 클로저 검사
checkbox.only.warn.if.loop.empty=루프가 비어 있는 경우에만 경고
add.dynamic.property=Agregar propiedad dinámica ''{0}''
duplicate.element.in.the.map=Elemento duplicado ''{0}'' en el mapa
dynamic.tool.window.id=Miembros dinámicos

create.field.from.usage.family.name=Crear campo a partir del uso
create.field.from.usage=Crear campo ''{0}''
create.method.from.usage.family.name=Crear método a partir del uso
create.method.from.usage=Crear método ''{0}''
create.variable.from.usage.family.name=Crear variable de uso
create.variable.from.usage=Crear variable ''{0}''
create.parameter.from.usage.family.name=Crear parámetro a partir del uso
create.parameter.from.usage=Crear parámetro ''{0}''
add.dynamic.element=Agregar elemento dinámico
add.dynamic.method=Agregar método dinámico
add.dynamic.method.0=동적 메서드 ''{0}'' 추가
dynamic.type=Tipo
dynamic.name=Nombre
dynamic.properties.table.name=Argumentos del método
dynamic.method.return.type=Devolver &tipo:
dynamic.method.property.type=Propiedad y tipo:
are.you.sure.to.delete.dynamic.property=¿Está seguro de eliminar ''{0}''?
dynamic.property.deletion=Propiedad dinámica de eliminación
are.you.sure.to.delete.elements=¿Está seguro de eliminar los elementos ''{0}''?
dynamic.element.deletion=Eliminación de elementos dinámicos
tuple.cant.be.placed.in.class=No se permiten múltiples asignaciones para los campos
is.not.enclosing.class=''{0}'' no es una clase adjunta
package.definition.cannot.have.modifiers=La definición del paquete no puede tener modificadores
import.statement.cannot.have.modifiers=La declaración de importación no puede tener modificadores
undefined.label=Etiqueta no definida ''{0}''
continue.outside.loop=La instrucción continue solo se permite dentro de los bucles
break.outside.loop.or.switch=La declaración de interrupción solo se permite dentro de bucles o interruptores
label.already.used=La etiqueta ''{0}'' ya está en uso
break.outside.loop=La declaración de ruptura con etiquetas con nombre solo se permite dentro de los bucles

Constructor=Constructor
Getter=Getter
Setter=Setter
not.allowed.modifier.in.for.in=El modificador ''{0}'' no está permitido aquí
property.name.expected=Nombre de propiedad esperado
wildcards.are.not.allowed.in.extends.list=Un supertipo no puede especificar un tipo de comodín
method.does.not.override.super=El método no anula el método de su superclase
method.duplicate=El método con la firma {0} ya está definido en la clase ''{1}''
ambiguous.code.block=Bloque de código ambiguo
cyclic.inheritance.involving.0=Herencia cíclica que involucra ''{0}''
there.is.no.default.constructor.available.in.class.0=No hay un constructor predeterminado disponible en la clase ''{0}''
groovy.library.is.not.configured.for.module=Groovy SDK no está configurado para el módulo ''{0}''
configure.groovy.library=Configurar Groovy SDK…
create.instance.of.built-in.type=Creación de instancias del tipo incorporado
incorrect.variable.name=Nombre de variable incorrecto
no.interface.expected.here=No se espera ninguna interfaz aquí
no.class.expected.here=No se espera una clase aquí
invoke.completion.second.time.to.show.skipped.methods=Invocar la finalización por segunda vez para mostrar los métodos omitidos
groovy.file.extension.is.not.mapped.to.groovy.file.type=*. Los archivos groovy se asignan a ''{0}''.\nPuedes asignarlos a Groovy en Configuración | Tipos de archivo
class.is.not.annotation=''{0}'' no es una anotación
method.call.is.ambiguous=La llamada al método es ambigua
operator.call.is.ambiguous=La llamada del operador es ambigua
duplicated.named.parameter=Parámetro con nombre duplicado ''{0}'' encontrado
no.super.classes.found=No se encontraron superclases
no.super.method.found=No se encontraron supermétodos
cannot.assign.string.to.enum.0=No se puede asignar una cadena a la enumeración ''{0}''
cannot.find.enum.constant.0.in.enum.1=No se puede encontrar la constante de enumeración ''{0}'' en la enumeración ''{1}''
recursive.constructor.invocation=Invocación de constructor recursivo
the.usage.of.a.map.entry.expression.to.initialize.an.enum.is.currently.not.supported=Actualmente no se admite el uso de una expresión de entrada de mapa para inicializar un Enum
class.definition.is.not.expected.here=No se espera una definición de clase aquí
move.class.0.from.method=Mover ''{0}'' al lugar correcto
move.class.from.method.family.name=Mover al lugar correcto solución rápida
cannot.infer.argument.types=No se pueden inferir tipos de argumentos
Equals=Iguales
default.initializers.are.not.allowed.in.abstract.method=Los inicializadores predeterminados no están permitidos en métodos abstractos
groovy.does.not.support.constructor.type.arguments=Groovy no admite argumentos de tipo constructor
illegal.escape.character.in.string.literal=Carácter de escape ilegal en literal de cadena
method.with.type.parameters.should.have.return.type=El método con parámetros de tipo debe tener un tipo de retorno
primitive.type.parameters.are.not.allowed=Los parámetros de tipo primitivo no están permitidos en la lista de parámetros de tipo
primitive.bound.types.are.not.allowed=Los tipos de enlace primitivo no están permitidos
ellipsis.type.is.not.allowed.here=El tipo de elipsis no está permitido aquí
method.0.is.too.complex.too.analyze=El método ''{0}'' es demasiado complejo para analizar.\nLos tipos de variables locales no se infieren.
closure.is.too.complex.to.analyze=El cierre es complejo de analizar.\nLos tipos de variables locales no se infieren.
0.is.deprecated=''{0}'' está obsoleto
wrong.number.of.type.arguments=Número incorrecto de argumentos de tipo\: {0}; requerido\: {1}
type.argument.0.is.not.in.its.bound.should.extend.1=El parámetro de tipo ''{0}'' no está en su límite; debería extender ''{1}''
catch.statement.parameter.type.should.be.a.subclass.of.throwable=El tipo de parámetro de declaración Catch debe ser una subclase de Throwable
exception.0.has.already.been.caught=La excepción ''{0}'' ya ha sido detectada
unnecessary.type=Excepción innecesaria ''{0}''. ''{1}'' ya está declarado
create.enum=Crear enumeración {0}
create.trait=Crear rasgo {0}
annotation.field.can.only.be.used.within.a.script.body=Annotation @Field solo se puede usar dentro de un cuerpo de script
annotation.field.can.only.be.used.within.a.script=Annotation @Field solo se puede usar dentro de un script
return.type.is.incompatible=El tipo de retorno de {0} en {1} es incompatible con {2} en {3}
anonymous.class.derived.from.0=clase anónima derivada de {0}
throws.clause.is.not.allowed.in.at.interface=La cláusula 'throws' no está permitida en los miembros de @interface
at.interface.0.does.not.contain.attribute=@interface ''{0}'' no contiene el atributo ''{1}''
duplicate.attribute=Atributo duplicado
missed.attributes=Atributos perdidos\: {0}
unexpected.attribute.type.0=Tipo de atributo inesperado\: ''{0}''
annotation.field.should.have.type.declaration=El campo en la anotación debe tener una declaración de tipo
interface.members.are.not.allowed.to.be=Los miembros de la interfaz no pueden ser {0}
abstract.methods.must.not.have.body=Los métodos abstractos no deben tener cuerpo
method.has.incorrect.modifier.volatile=El método tiene un modificador incorrecto 'volátil'
native.methods.cannot.have.body=Los métodos nativos no pueden tener cuerpo
top.level.class.may.not.have.private.modifier=Es posible que la clase de nivel superior no tenga el modificador 'privado'
top.level.class.may.not.have.protected.modifier=Es posible que la clase de nivel superior no tenga el modificador 'protegido'
property.missing=propertyMissing
attribute.name.expected=Nombre de atributo esperado
java.style.for.each.statement.requires.a.type.declaration=Estilo Java para cada declaración requiere una declaración de tipo
super.cannot.be.used.in.static.context='super' no se puede utilizar en contexto estático
qualified.0.is.allowed.only.in.nested.or.inner.classes=Qualified {0} solo se permite en clases anidadas/internas
groovy.file.0=Archivo maravilloso ''{0}''
type.argument.list.is.not.allowed.here=La lista de argumentos de tipo no está permitida aquí
initializers.are.not.allowed.in.interface=Los inicializadores no están permitidos en la interfaz
initializer.cannot.have.annotations=Los inicializadores no pueden tener anotaciones
initializer.cannot.be.0=El inicializador no puede ser {0}
constructors.are.not.allowed.in.interface=Los constructores no están permitidos en la interfaz
type.parameters.are.unexpected=Los parámetros de tipo son inesperados
constructors.cannot.have.return.type=El elemento de tipo de retorno no está permitido en el constructor
constructor.cannot.have.static.modifier=El constructor no puede ser estático
annotation.types.may.not.have.extends.clause=Los tipos de anotaciones pueden no tener una cláusula 'extiende'
annotation.types.may.not.have.implements.clause=Los tipos de anotaciones pueden no tener una cláusula 'implements'
no.implements.clause.allowed.for.interface=Es posible que las interfaces no tengan la cláusula 'implements'
enums.may.not.have.extends.clause=Las enumeraciones pueden no tener la cláusula 'extends'
method.0.cannot.override.method.1.in.2.overridden.method.is.final=El método ''{0}'' no puede anular el método ''{1}'' en ''{2}'' ; el método anulado es final
method.0.cannot.have.weaker.access.privileges.1.than.2.in.3.4=El método ''{0}'' no puede tener privilegios de acceso más débiles (''{1}'') que '' { 2} '' en ''{3}'' (''{4}'')
tuple.declaration.should.end.with.def.modifier=La declaración de tupla debe terminar con el modificador 'def'
injection.should.not.contain.line.feeds=La inyección GString no debe contener avances de línea
collection.literal.contains.named.argument.and.expression.items=El literal de colección contiene argumentos con nombre y expresión al mismo tiempo
annotation.collector.cannot.have.attributes=El tipo de anotación anotado con @AnnotationCollector no puede tener atributos
annotation.type.cannot.be.inner=El tipo de anotación no puede ser interno
named.arguments.are.not.allowed.inside.index.operations=No se permiten argumentos con nombre dentro de operaciones de índice
expected.0.to.be.inline.constant=Se espera que ''{0}'' sea una constante en línea
cannot.assign.a.value.to.final.field.0=No se puede asignar un valor al campo final ''{0}''
cannot.assign.a.value.to.final.parameter.0=No se puede asignar un valor al parámetro final ''{0}''
variable.0.might.not.have.been.initialized=Es posible que la variable ''{0}'' no se haya inicializado
doc.end.expected='*/' esperado
mixing.private.and.public.protected.methods.of.the.same.name=Mezclando métodos privados y públicos/protegidos del mismo nombre
explicit.constructors.are.not.allowed.in.immutable.class=Los constructores explícitos no están permitidos para la clase @Immutable
repetitive.method.name.0=Nombre de método repetitivo ''{0}''
declared.type.0.have.to.extend.script=El tipo declarado ''{0}'' no extiende la clase '' groovy.lang.Script ''
base.script.annotation.is.allowed.only.inside.scripts=La anotación @BaseScript solo se puede usar dentro de un script
delegate.annotation.is.only.for.methods.without.arguments=La anotación @Delegate no se pudo aplicar al método con argumentos
builder.annotation.not.support.super.for.simple.strategy=El atributo de anotación 'includeSuperProperties' no es compatible con groovy.transform.builder.SimpleStrategy
0.expressions.on.trait.fields.properties.are.not.supported.in.traits={0} las expresiones en los campos/propiedades de rasgos no son compatibles con los rasgos
only.traits.expected.here=Aquí solo se esperan rasgos
anonymous.classes.cannot.be.created.from.traits=No se pueden crear clases anónimas a partir de rasgos
trait.method.cannot.be.protected=Los métodos de rasgos no pueden protegerse
non.static.classes.not.allowed=Las clases internas no estáticas no están permitidas en los rasgos
selfType.class.does.not.inherit=@SelfType: La clase ''{0}'' no hereda ''{1}''
illegal.type.void=Tipo ilegal: 'void'
illegal.method.name=El nombre del método contiene caracteres ilegales: {0}

indexed.property.is.applicable.to.properties.only=@IndexedProperty를 프로퍼티에만 적용할 수 없습니다
listener.list.field.must.have.a.generic.collection.type=@ListenerList 필드는 제네릭 Collection 유형이 필요합니다
listener.list.field.with.generic.wildcards.not.supported=@ListenerList 필드에 제네릭 와일드카드 사용은 지원되지 않음
synchronized.not.allowed.on.abstract.method=@Synchronized는 추상 메서드에서 허용되지 않음
lock.field.0.must.be.static=락 필드 ''{0}'' 은(는) static이어야 합니다
lock.field.0.must.not.be.static=락 필드 ''{0}'' 은(는) static일 수 없습니다
lock.field.0.not.found=락 필드 ''{0}'' 을(를) 찾을 수 없음
select.module.action.text=모듈 선택...
select.module.action.description=클래스 경로를 사용할 모듈 선택
select.module.popup.title=모듈 클래스 경로 사용
### Grupos de inspección ###
inspection.annotations=Verificación de anotaciones
inspection.assignments=Problemas de asignación
inspection.bugs=Errores probables
inspection.confusing=Construcciones de código potencialmente confusas
inspection.control.flow=Problemas de flujo de control
inspection.data.flow=Flujo de datos
inspection.error.handling=Manejo de errores
inspection.gpath=GPath
inspection.naming=Convenciones de nomenclatura
inspection.method.metrics=Métricas del método
inspection.redundancy=Declaración de redundancia
inspection.threading=Problemas de subprocesos
inspection.validity=Problemas de validez
inspection.style=Estilo
inspection.other=Otro
### Inspecciones ###
inspection.display.name.result.of.assignment.used=Resultado de la asignación utilizada
inspection.display.name.assignment.can.be.operator.assignment=Asignación reemplazable por asignación de operador
inspection.display.name.delegates.to=@DelegatesTo inspección
inspection.display.name.unresolved.access=Acceso a expresión no resuelta
inspection.display.name.untyped.access=Acceso a expresión sin tipo
inspection.display.name.list.set.can.be.keyed.access=Llamar a List.set puede ser acceso por clave
inspection.display.name.list.get.can.be.keyed.access=Llamar a List.get puede ser acceso por clave
inspection.display.name.map.put.can.be.keyed.access=La llamada a Map.put puede ser acceso por clave
inspection.display.name.map.get.can.be.keyed.access=La llamada a Map.get puede ser acceso por clave
inspection.display.name.parameter.naming.convention=Convención de nomenclatura de parámetros de método
inspection.display.name.constant.naming.convention=Convención de nomenclatura constante
inspection.display.name.instance.variable.naming.convention=Convención de nomenclatura de variables de instancia
inspection.display.name.instance.method.naming.convention=Convención de nomenclatura del método de instancia
inspection.display.name.static.variable.naming.convention=Convención de nomenclatura de variables estáticas
inspection.display.name.static.method.naming.convention=Convención de nomenclatura de métodos estáticos
inspection.display.name.local.variable.naming.convention=Convención de nomenclatura de variables locales
inspection.display.name.class.naming.convention=Convención de nomenclatura de clases
inspection.display.name.groovydoc.check=Problemas con GroovyDoc
inspection.display.name.constructor.named.arguments=Argumentos nombrados de la llamada al constructor
inspection.display.name.result.of.object.allocation.ignored=Resultado de la asignación del objeto ignorado
inspection.display.name.divide.by.zero=Dividir por cero
inspection.display.name.infinite.recursion=Recursión infinita
inspection.display.name.infinite.loop.statement=Declaración de bucle infinito
inspection.display.name.non.short.circuit.boolean=Booleano sin cortocircuito
inspection.display.name.duplicate.switch.branch=Caso de interruptor duplicado
inspection.display.name.gstring.key=Clave del mapa GString
inspection.display.name.octal.integer=Entero octal
inspection.display.name.overly.complex.boolean.expression=Expresión booleana demasiado compleja
inspection.display.name.clashing.trait.methods=Métodos de rasgos en conflicto
inspection.display.name.overly.complex.arithmetic.expression=Expresión aritmética demasiado compleja
inspection.display.name.double.negation=Doble negación
inspection.display.name.pointless.arithmetic=Expresión aritmética sin sentido
inspection.display.name.empty.statement.body=Declaración con cuerpo vacío
inspection.display.name.reassigned.in.closure.local.var=La variable local se reasigna en cierre o clase anónima
inspection.display.name.result.of.increment.or.decrement.used=Resultado del incremento o decremento utilizado
inspection.display.name.negated.if=Expresión de condición si se niega
inspection.display.name.in.argument.check=Tipos de argumentos 'in' incompatibles
inspection.display.name.negated.conditional=Expresión condicional negada
inspection.display.name.nested.conditional=Expresión condicional anidada
inspection.display.name.conditional=Expresión condicional
inspection.display.name.nested.switch=Instrucción de cambio anidada
inspection.display.name.multiple.return.points.per.method=Método con múltiples puntos de retorno
inspection.display.name.method.with.more.than.three.negation=Método con más de tres negaciones
inspection.display.name.overly.nested.method=Método demasiado anidado
inspection.display.name.overly.long.method=Método demasiado largo
inspection.display.name.overly.complex.method=Método demasiado complejo
inspection.display.name.method.parameter.count=Método con demasiados parámetros
inspection.display.name.while.loop.spins.on.field=Mientras el bucle gira en el campo
inspection.display.name.unsynchronized.method.overrides.synchronized.method=El método no sincronizado anula el método sincronizado
inspection.display.name.synchronization.on.variable.initialized.with.literal=Sincronización en variable inicializada con literal
inspection.display.name.synchronization.on.non.final.field=Sincronización en campo no final
inspection.display.name.wait.while.not.synchronized='esperar()' mientras no está sincronizado
inspection.display.name.wait.call.not.in.loop='wait()' no está en bucle
inspection.display.name.notify.while.not.synchronized='notificar()' o 'notificar a todos()' mientras no esté sincronizado
inspection.display.name.system.run.finalizers.on.exit=Llamada a System.runFinalizersOnSalir()
inspection.display.name.thread.stop.suspend.resume=Llamada a Thread.stop(), Thread.suspend() o Thread.resume()
inspection.display.name.nested.synchronized.statement=Declaración 'sincronizada' anidada
inspection.display.name.synchronized.method=Método sincronizado
inspection.display.name.synchronization.on.this=Sincronización en 'esto'
inspection.display.name.empty.sync.block=Bloque vacío 'sincronizado'
inspection.display.name.busy.wait=Espera ocupada
inspection.display.name.public.field.accessed.in.synchronized.context=Campo no privado al que se accede en contexto sincronizado
inspection.display.name.unconditional.wait=Llamada de 'espera' incondicional
inspection.display.name.double.checked.locking=Bloqueo verificado dos veces
inspection.display.name.access.to.static.field.locked.on.instance=Acceso al campo estático bloqueado en datos de instancia
inspection.display.name.change.to.method=Cambiar a método
inspection.display.name.change.to.operator=Cambiar a operador
inspection.display.name.unnecessary.alias=Alias de importación innecesario
inspection.display.name.unnecessary.semicolon=Punto y coma innecesario
inspection.display.name.unnecessary.public.modifier='público' innecesario
inspection.display.name.unnecessary.def.modifier='def' innecesario
inspection.display.name.java.style.properties.invocation=Acceso a la propiedad estilo Java
inspection.display.name.trivial.if=Declaración 'if' redundante
inspection.display.name.constant.if.statement=Constante si declaración
inspection.display.name.constant.conditional=Expresión condicional constante
inspection.display.name.trivial.conditional=Expresión condicional redundante
inspection.display.name.return.from.closure.can.be.implicit=la declaración 'return' puede ser implícita
inspection.display.name.switch.statement.with.no.default=Sentencia de cambio sin caso predeterminado
inspection.display.name.final.variable.access=Acceso a la variable final
inspection.display.name.unnecessary.return=Declaración de 'retorno' innecesaria
inspection.display.name.unnecessary.continue=Declaración 'continuar' innecesaria
inspection.display.name.fallthrough=Fallthrough en la declaración de cambio
inspection.display.name.if.statement.with.too.many.branches=Declaración If con demasiadas ramas
inspection.display.name.if.statement.with.identical.branches=Declaración If con ramas idénticas
inspection.display.name.conditional.can.be.conditional.call=La expresión condicional puede ser una llamada condicional
inspection.display.name.conditional.can.be.elvis=La expresión condicional puede ser elvis
inspection.display.name.conditional.with.identical.branches=Expresión condicional con ramas idénticas
inspection.display.name.loop.statement.that.doesnt.loop=Declaración de bucle que no se repite
inspection.display.name.unreachable.statement=Declaración inalcanzable
inspection.display.name.continue=Continuar declaración
inspection.display.name.break=Declaración de ruptura
inspection.display.name.unused.catch.parameter=Parámetro de captura no utilizado
inspection.display.name.empty.try.block=Bloque 'try' vacío
inspection.display.name.annotation.references.unknown.identifier=''includes'' 및 ''excludes'' 속성 내 알 수 없는 식별자
inspection.display.name.unresolved.labels.in.named.variant=@NamedVariant/@NamedParam/@NamedDelegate 변환 뒤 해결되지 않은 라벨
inspection.display.name.empty.finally.block=Bloque 'finally' vacío
inspection.display.name.empty.catch.block=Bloque 'catch' vacío
inspection.display.name.throw.from.finally.block='throw' dentro del bloque 'finally'
inspection.display.name.return.from.finally.block='return' dentro del bloque 'finally'
inspection.display.name.method.may.be.static=El método puede ser estático
inspection.display.name.continue.or.break.from.finally.block='continuar' o 'romper' dentro del bloque 'finalmente'
inspection.display.name.unchecked.assignment.of.member.of.raw.type=Asignación no verificada de miembros de tipo crudo
inspection.display.name.silly.assignment=Tarea tonta
inspection.display.name.nested.assignment=Asignación anidada
inspection.display.name.assignment.to.method.parameter=Asignación al parámetro del método
inspection.display.name.assignment.to.for.loop.parameter=Asignación al parámetro de bucle for
inspection.display.name.assignability.check=Asignaciones de tipos incompatibles
inspection.display.name.type.customizer=Tipo de inspección del personalizador
inspection.display.name.unused.declaration=Declaración no utilizada
inspection.display.name.second.unsafe.call=Segunda llamada insegura
inspection.display.name.unused.assignment=Asignación no utilizada
inspection.display.name.unused.inc.dec=Incremento o decremento no utilizado
inspection.display.name.unassigned.access=Variable No asignada
inspection.display.name.no.return=Falta la declaración de retorno
inspection.display.name.clashing.getters=Captadores en conflicto
inspection.display.name.package.mismatch=No coincide el paquete
inspection.display.name.deprecated.api.usage=Inspección de API obsoleta
inspection.display.name.unnecessary.qualified.reference=Referencia calificada innecesaria
inspection.display.name.pointless.boolean=Expresión booleana sin sentido
inspection.display.name.access.to.inaccessible.element=Acceso a elemento inaccesible
inspection.display.name.incorrect.range.argument=Argumentos de rango incorrectos
inspection.display.name.new.instance.of.singleton=Nueva instancia de clase anotada con @groovy.lang.Singleton
inspection.display.name.check.labeled.statement=Inspección de declaración etiquetada
inspection.display.name.variable.can.be.final=La variable puede ser final
inspection.display.name.equals.between.inconvertible.types='equals()' entre objetos de tipos inconvertibles
inspection.display.name.singleton.constructor=Constructor @Singleton
inspection.message.access.to.static.field.locked.on.instance.data=static 필드 <code>\#ref</code> 로의 액세스가 인스턴스 데이터에서 잠김 \#loc
inspection.message.assignment.replaceable.with.operator.assignment=<code>\#ref</code>을(를) ''{0}'' (으)로 단순활할 수 있습니다 \#loc
inspection.message.assignment.to.for.loop.parameter=for 루프 매개변수 ''\#ref''에 대입 \#loc
inspection.message.assignment.to.method.parameter=메서드 매개변수 ''\#ref''에 대입 \#loc
inspection.message.ref.statement=\#ref 문 \#loc
inspection.message.call.to.thread.ref.in.a.loop=루프 내 <code>Thread.\#ref()</code>에 대한 호출이 바쁜 대기 중일 수 있습니다 \#loc
inspection.message.conditional.expression.can.be.call=조건식이 호출일 수 있습니다 \#loc
inspection.message.conditional.expression.can.be.elvis=조건식이 elvis일 수 있습니다 \#loc
inspection.message.conditional.expression=조건식 \#loc
inspection.message.conditional.expression.with.identical.branches=동일한 브랜치가 있는 조건식 \#loc
inspection.message.ref.can.be.simplified=''\#ref''을(를) 단순화할 수 있습니다 \#loc
inspection.message.ref.statement.can.be.simplified=\#ref 문을 단순화할 수 있습니다 \#loc
inspection.message.constant.name.ref.too.short=상수 이름 ''\#ref''이(가) 너무 짧습니다
inspection.message.constant.name.ref.too.long=상수 이름 ''\#ref''이(가) 너무 깁니다
inspection.message.constant.name.ref.doesnt.match.regex=상수 이름 ''\#ref''이(가) 정규식 ''{0}'' 와(과) 일치하지 않습니다 \#loc
inspection.message.ref.inside.finally.block=''finally'' 블록 내 ''\#ref'' \#loc
inspection.message.divide.by.zero=0으로 나누기 \#loc
inspection.message.double.checked.locking=이중 검사된 잠금 \#loc
inspection.message.double.negation.ref=이중 부정 \#ref \#loc
inspection.message.duplicate.switch.case.ref=중복 switch case ''\#ref'' \#loc
inspection.message.empty.ref.block=빈 ''\#ref'' 블록 \#loc
inspection.message.ref.statement.has.empty.branch=''\#ref'' 문의 브랜치가 비어 있습니다
inspection.message.ref.statement.has.empty.body=''\#ref'' 문의 본문이 비어 있습니다
inspection.message.fallthrough.in.switch.statement=switch 문의 폴스루 \#loc
inspection.message.gstring.used.as.maps.key=GString가 맵 키로 사용되었습니다 \#loc
inspection.message.ref.statement.cannot.complete.without.throwing.exception=<code>\#ref</code> 문은 예외를 던지지 않으면 완료되지 않습니다 \#loc
inspection.message.code.ref.code.recurses.infinitely.can.only.complete.by.throwing.exception=<code>\#ref</code>이(가) 무한 반복되며 예외를 던져야 완료됩니다 \#loc
inspection.message.instance.method.name.ref.too.short=인스턴스 메서드 이름 ''\#ref''이(가) 너무 짧습니다
inspection.message.instance.method.name.ref.too.long=인스턴스 메서드 이름 ''\#ref''이(가) 너무 깁니다
inspection.message.instance.method.name.ref.doesnt.match.regex=인스턴스 메서드 이름 ''\#ref''이(가) 정규식 ''{0}'' 와(과) 일치하지 않습니다 \#loc
inspection.message.instance.variable.name.ref.too.short=인스턴스 변수 이름 ''\#ref''이(가) 너무 짧습니다
inspection.message.instance.variable.name.ref.too.long=인스턴스 변수 이름 ''\#ref''이(가) 너무 깁니다
inspection.message.couldnt.find.property.field.with.this.name=이 이름을 가진 프로퍼티 또는 필드를 프레임을 찾을 수 없음 \#loc
inspection.message.instance.variable.name.ref.doesn.t.match.regex=인스턴스 변수 이름 ''\#ref''이(가) 정규식 ''{0}'' 와(과) 일치하지 않습니다 \#loc
inspection.message.call.to.ref.can.be.keyed.access=''\#ref'' 호출이 키 액세스일 수 있습니다 \#loc
inspection.message.ref.statement.with.identical.branches=동일한 브랜치가 있는 ''\#ref'' 문 \#loc
inspection.message.ref.statement.with.too.many.branches=''\#ref'' 문에 브랜치가 너무 많음({0}) \#loc
inspection.message.local.variable.name.ref.too.short=지역 변수 이름 ''\#ref''이(가) 너무 짧습니다
inspection.message.local.variable.name.ref.too.long=지역 변수 이름 ''\#ref''이(가) 너무 깁니다
inspection.message.local.variable.name.ref.doesnt.match.regex=지역 변수 이름 ''\#ref''이(가) 정규식 ''{0}'' 와(과) 일치하지 않습니다 \#loc
inspection.message.code.ref.code.statement.doesnt.loop=<code>\#ref</code> 문이 루프되지 않습니다 \#loc
inspection.message.method.ref.contains.too.many.parameters.0.1=모듈 ''\#ref''에 매개변수가 너무 많습니다({0}>{1})
inspection.message.method.ref.has.too.many.negations=메서드 ''\#ref''에 부정이 너무 많습니다({0}>3)
inspection.message.ref.has.0.return.points=<code>\#ref</code>에 {0} 개의 반환점이 있습니다 \#loc
inspection.message.negated.conditional.expression=부정된 조건식 \#loc
inspection.message.negated.if.condition.expression=부정된 if 조건식 \#loc
inspection.message.nested.assignment.expression=중첩된 대입식 \#loc
inspection.message.nested.conditional.expression=중첩된 조건식 \#loc
inspection.message.nested.ref.statement=중첩된 ''\#ref'' 문 \#loc
inspection.message.non.short.circuit.boolean.expression=비단락 회로 부울 표현식 \#loc
inspection.message.call.to.ref.outside.synchronized.context=동기화된 컨텍스트 외부의 ''\#ref'' 호출 \#loc
inspection.message.octal.integer.ref=8진 정수 \#ref \#loc
inspection.message.overly.complex.arithmetic.expression=지나치게 복잡한 산술 표현식 \#loc
inspection.message.overly.complex.boolean.expression=지나치게 복잡한 부울 표현식 \#loc
inspection.message.method.ref.overly.complex.cyclomatic.complexity=메서드 ''\#ref'' 이(가) 지나치게 복잡합니다(순환 복잡성 \={0}>{1})
inspection.message.method.ref.too.long.statement.count=메서드 ''\#ref''이(가) 지나치게 깁니다(구문 수 \={0}>{1}})
inspection.message.method.ref.overly.nested.nesting.depth=메서드 ''\#ref''이(가) 과도하게 중첩되어 있습니다(중첩 깊이 \={0}>{1})
inspection.message.method.parameter.name.ref.too.short=메서드 매개변수 이름 ''\#ref''이(가) 너무 짧습니다
inspection.message.method.parameter.name.ref.too.long=메서드 매개변수 이름 ''\#ref''이(가) 너무 깁니다
inspection.message.method.parameter.name.ref.doesnt.match.regex=메서드 매개변수 이름 ''\#ref''이(가) 정규식 ''{0}'' 와(과) 일치하지 않습니다 \#loc
inspection.message.non.private.field.accessed.in.synchronized.context=동기화된 컨텍스트에서 비 private 필드 <code>\#ref</code>이(가) 액세스됩니다 \#loc
inspection.message.nested.assignment=대입 표현식의 결과가 사용되었습니다 \#loc
inspection.message.result.increment.or.decrement.expression.used=사용된 증분 또는 감소 표현식의 결과 \#loc
inspection.message.result.of.new.ref.is.ignored=<code>새 \#ref{0}</code>의 결과가 무시되었습니다 \#loc
inspection.message.ref.statement.at.end.closure.can.be.made.implicit=클로저 끝의 \#ref 문을 묵시적으로 만들 수 있습니다 \#loc
inspection.message.silly.assignment=잘못된 대입 \#loc
inspection.message.static.method.name.ref.too.short=정적 메서드 이름 ''\#ref''이(가) 너무 짧습니다
inspection.message.static.method.name.ref.too.long=정적 메서드 이름 ''\#ref''이(가) 너무 깁니다
inspection.message.static.method.name.ref.doesnt.match.regex=정적 메서드 이름 ''\#ref''이(가) 정규식 ''{0}'' 와(과) 일치하지 않습니다 \#loc
inspection.message.static.variable.name.ref.too.short=정적 변수 이름 ''\#ref''이(가) 너무 짧습니다
inspection.message.label.name.ref.not.supported.by.0={0} 은(는) 라벨 이름 ''\#ref''을(를) 지원하지 않습니다
inspection.message.static.variable.name.ref.too.long=정적 변수 이름 ''\#ref''이(가) 너무 깁니다
inspection.message.static.variable.name.ref.doesnt.match.regex=정적 변수 이름 ''\#ref''이(가) 정규식 ''{0}'' 와(과) 일치하지 않습니다 \#loc
inspection.message.property.0.is.final=프로퍼티 ''{0}'' 이(가) final입니다 \#loc
inspection.message.ref.statement.with.no.default.branch=default 브랜치가 없는 \#ref 문 \#loc
inspection.message.synchronization.on.non.final.field.ref=비 final 필드 ''\#ref'' 동기화 \#loc
inspection.message.synchronization.on.ref=\ ''\#ref'' 동기화 \#loc
inspection.message.synchronization.on.variable.ref.which.was.initialized.with.literal=리터럴로 초기화된 변수 ''\#ref'' 동기화 \#loc
inspection.message.synchronized.method.ref=동기화된 메서드 ''\#ref'' \#loc
inspection.message.call.to.system.ref=''System.\#ref'' 호출 \#loc
inspection.message.call.to.thread.ref=''스레드.\#ref'' 호출 \#loc
inspection.message.0.can.be.simplified.to.1=''{0}'' 을(를) ''{1}'' (으)로 단순화할 수 있습니다 \#loc
inspection.message.property.0.is.ignored.by.map.constructor=프로퍼티 ''{0}'' 이(가) @MapConstructor에 의해 무시되었습니다 \#loc
inspection.message.unconditional.call.to.ref=<code>\#ref()</code>을(를) 조건 없이 호출합니다 \#loc
inspection.message.ref.is.unnecessary.as.last.statement.in.loop=루프의 마지막 구문으로서 \#ref 은(는) 불필요합니다 \#loc
inspection.message.ref.is.unnecessary.as.last.statement.in.method.with.no.return.value=반환값이 없는 메서드의 마지막 구문으로서 \#ref 은(는) 불필요합니다 \#loc
inspection.message.unreachable.statement=도달할 수 없는 명령문 \#loc
inspection.message.unsynchronized.method.ref.overrides.synchronized.method=비동기화된 메서드 ''\#ref'' 이(가) 동기화된 메서드를 재정의합니다 \#loc
inspection.message.cannot.determine.type.ref=''\#ref''의 유형을 파악할 수 없음
inspection.message.call.to.ref.outside.of.loop=루프 밖에서 ''\#ref'' 호출 \#loc
inspection.message.call.to.ref.outside.of.synchronized.context=동기화된 컨텍스트 외부의 ''\#ref'' 호출 \#loc
inspection.message.ref.loop.spins.on.field=<code>\#ref</code> 루프가 필드에서 스핀합니다 \#loc
inspection.message.package.name.mismatch=패키지 이름 불일치
inspection.message.dsl.descriptor.file.has.been.changed.and.isnt.currently.executed=DSL 기술자 파일이 변경되어 현재 실행되고 있지 않습니다.
inspection.message.dsl.descriptor.file.has.been.disabled.due.to.processing.error=처리 오류 때문에, DSL 기술자 파일이 비활성화 되었습니다.
inspection.message.traits.0.contain.clashing.methods.with.signature.1=특성 {0} 이(가) 시그니처 {1} 이 있는 충돌 메서드를 포함합니다
inspection.message.unused.catch.parameter.ref=사용되지 않은 catch 매개변수 ''\#ref'' \#loc
inspection.message.package.name.mismatch.actual.0.expected.1=패키지 이름 불일치. 실제\: ''{0}'', 필요\: ''{1}''
inspection.message.property.not.indexable.type.must.be.array.or.list.but.found.0=속성은 색인화할 수 없습니다. 유형은 배열 또는 목록이어야 하나 {0} 를 찾았습니다
inspection.message.type.argument.0.can.not.be.1=인수 ''{0}'' 의 유형이 ''{1}'' 일 수 없습니다
text.class.0.is.unused=클래스 {0} 이(가) 사용되지 않습니다
text.constructor.0.is.unused=생성자 {0} 이(가) 사용되지 않습니다
text.method.0.is.unused=메서드 {0} 이(가) 사용되지 않습니다
text.property.0.is.unused=프로퍼티 {0} 이(가) 사용되지 않습니다
text.parameter.0.is.unused=매개변수 ''{0}'' 이(가) 사용되지 않습니다
### Grupos de intención ###
intention.category.groovy=Groovy
intention.category.conversions=Conversiones Groovy/Expression
intention.category.closures=Groovy/Closures
intention.category.comments=Groovy/Comentarios
intention.category.groovy.style=Groovy/Groovy-style
intention.category.control.flow=Groovy/Control de flujo
intention.category.groovy.declaration=Groovy/Declaración
intention.category.groovy.other=Groovy/Otro
configurable.GroovyCompilerConfigurable.display.name=Compilador Groovy
configurable.GantConfigurable.display.name=Gant
settings.compiler.alternative=Alternativamente, puede especificar el compilador Groovy-Eclipse en la <a href=\\"#\\"> página del compilador Java</a>
settings.compiler.select.path.to.groovy.compiler.configscript=Seleccione la ruta al configscript del compilador Groovy
settings.compiler.path.to.configscript=Ruta de &configscript:
settings.compiler.invoke.dynamic.support=Invocar soporte &dinámico
settings.compiler.exclude.from.stub.generation=Excluir de la generación de stub:
settings.code.style.label.indent.style=Estilo de sangría de etiqueta:
settings.code.style.label.indent.size=tamaño de sangría de etiqueta
settings.code.style.indent.statements.after.label=Declaraciones de sangría después de la etiqueta
settings.code.style.absolute=Absoluto
settings.code.style.indent.labels=Aplicar sangría a las etiquetas
settings.inlay.parameter.types=Tipos de parámetros
settings.inlay.inferred.parameter.types=Tipos de parámetros inferidos
settings.inlay.type.parameter.list=Tipo de lista de parámetros
settings.inlay.show.type.hints.for=Mostrar sugerencias de tipo para:
intention.name.replace.with.in=''\:''을 ''in''으로 바꾸기
intention.name.activate.back=다시 활성화
intention.name.cast.to.0={0} (으)로 형 변환
intention.name.replace.eq.with.0.eq=''\=''를 ''{0}\=''로 바꾸기
intention.name.cast.operand.to.0=피연산자를 {0} (으)로 형 변환
intention.name.add.required.attributes.to.map.constructor=@MapConstructor에 필수 속성 추가
intention.family.name.create.field=필드 생성
action.remove.dynamic.member.text=Eliminar
action.remove.dynamic.member.description=동적 멤버 제거
action.collapse.all.text=모두 접기
action.collapse.all.description=모두 접기
action.expand.all.text=모두 펼치기
action.expand.all.description=모두 펼치기
dynamic.members.column.name.element=동적 요소
dynamic.members.column.name.type=Categoría
command.name.add.dynamic.member=동적 멤버 추가
popup.content.navigation.to.overriding.classes.unavailable=색인 업데이트 중에는 클래스를 재정의하는 탐색이 불가능합니다
overriding.methods.of.0=''{0}'' 메서드 재정의 중
expression.type.no.expression=표현식을 찾을 수 없음
expression.type.unknown=<unknown>
add.class.to.extends.family.name=구현
intention.family.name.rename=이름 변경
generated.stub.message=이 스텁은 Groovy 클래스가 Groovy-Java 크로스 컴파일을 가능하게 하기 위해 생성됩니다
generated.stub.navigate.link.label=Groovy 클래스로 이동
generated.stub.exclude.link.label=스텁 생성에서 제외
module.with.groovy=Groovy 라이브러리가 연결된 간단한 모듈
action.build.restart.text=빌드 후 다시 시작
action.build.module.restart.description=모듈 ''{0}'' 빌드 후 다시 시작
gdsl.investigate.link.label=조사하려면 클릭하세요
gdsl.error.notification.title=DSL 스크립트 실행 오류
dialog.message.gant.not.configured=Gant가 구성되지 않았습니다.
investigate.gdsl.error.intention.name=세부 정보 보기
investigate.gdsl.error.family.name=DSL 설명자 프로세스 오류 검사
grab.intention.name=아티팩트 Grab
grab.family.name=Grab
grab.progress.title=@Grab 어노테이션 처리 중
grab.result.title={0} Grape 종속성 {0, choice, 0\#jar|1\#jar|2\#jar} 추가됨
grab.jar.count=<b>{0}</b>\: {1} {1, choice, 0\#jar|1\#jar|2\#jar}
grab.error.ivy.missing.title=Ivy가 누락되었습니다
grab.error.ivy.missing.message=죄송하지만 IDEA는 Apache Ivy 없이 종속성을 @Grab할 수 없습니다. Apache Ivy를 모듈 종속성에 추가하여 액션을 재실행하세요.
grab.error.0.title=@Grab을 실행할 수 없음\: {0}
this.super.completion.advertisement=클래스 한정자 없이 {0} 을(를) 2회 누르면 액세스 가능한 모든 정적 메서드가 표시됩니다
compact.empty.middle.packages.action.text=빈 중간 패키지 압축
compact.empty.middle.packages.action.description=빈 중간 패키지 표시/압축
scroll.from.source.action.text=소스에서 스크롤
scroll.from.source.action.description=활성화된 에디터에서 열려 있는 파일 선택
optimize.imports.progress.title=Groovy 파일에서 import 문 최적화 중...
mvc.framework.0.library.label={0} 라이브러리\:
mvc.framework.0.not.configured.for.module.1={0} SDK가 모듈 ''{1}'' 에 대해 구성되지 않았습니다
mvc.framework.0.configure.sdk.label={0} SDK 구성
mvc.framework.0.module.1.has.no.sdk=모듈 ''{1}'' 에 {0} SDK가 없습니다.
mvc.framework.0.module.builder.description={0} 모듈은 {0} 애플리케이션 생성에 사용됩니다
mvc.framework.0.sdk.not.found.title={0} SDK를 찾을 수 없음
mvc.framework.0.change.sdk.version.title={0} SDK 버전 변경
mvc.framework.0.run.target.action.text={0} 대상 실행
mvc.framework.0.run.target.action.description=임의 {0} 대상 실행
mvc.framework.0.run.target.dialog.title={0} 대상 실행
mvc.framework.0.run.target.interactive=대화형 모드에서 {0} 콘솔 시작(&S)
mvc.run.target.options.border.title=옵션
mvc.run.configuration.command.line.label=명령줄(&C)\:
mvc.run.configuration.no.module=모듈이 지정되지 않았습니다
mvc.run.configuration.disposed.module=모듈이 폐기되었습니다
mvc.console.cannot.start.process.error.title=프로세스를 시작할 수 없음
mvc.console.executing.progress=실행...
mvc.console.0.executing.progress={0}\: 실행 중...
mvc.console.execution.error.title=명령어 실행 실패\: {0}
mvc.console.kill.process.action.text=프로세스 강제 종료
mvc.console.kill.process.action.description=프로세스 강제 종료
mvc.run.configuration.add.classpath.label=--classpath 추가
mvc.run.configuration.add.classpath.0.label=--classpath 추가\: {0}
mvc.no.jdk.found.error.title=JDK를 찾을 수 없음
mvc.no.jdk.found.error.message=모듈 ''{1}'' 에 JDK가 지정되지 않았으므로 {0} 프로젝트 구조를 생성할 수 없습니다.\n\
JDK를 지정하시겠어요?
replace.all.occurrences.and.remove.variable.0=모든 사용 위치 바꾸기 및 변수 ''{0}'' 제거
introduce.variable.declare.final.label=final 선언(&F)
introduce.variable.replace.all.occurrences=모든 사용 위치 바꾸기(&A)
introduce.variable.replace.all.0.occurrences=모든 사용 위치 바꾸기({0}개 위치)(&A)
introduce.parameter.delegate.via.overload=오버로드 메서드를 통한 위임(&L)
introduce.parameter.replace.fields.border.title=표현식에 사용된 필드를 getter로 바꾸기
introduce.parameter.do.not.replace.option.label=바꾸기 안 함(&O)
introduce.parameter.replace.inaccessible.fields.option.label=사용 컨텍스트에서 접근할 수 없는 필드 바꾸기(&I)
introduce.parameter.replace.all.fields.option.label=모든 필드 바꾸기(&R)
introduce.variable.type.label=유형(&T)\:
introduce.variable.name.label=&Nombre\:
introduce.parameter.explicit.return.statement.option.label=명시적 return 문 사용(&X)
introduce.parameter.delegating.unavailable.tooltip=위임은 클로저 컨텍스트에서 허용되지 않습니다
introduce.variable.change.type.advertisement={0} 을(를) 눌러 유형 변경
framework.0.home.label={0} 홈\:
select.framework.0.home.title={0} 홈 선택
framework.0.sdk.chooser.title={0} SDK
framework.0.sdk.chooser.description={0} 배포판을 포함하는 디렉터리 선택
framework.0.sdk.chooser.error.message=지정된 경로의 {0} 배포판이 망가진 것 같습니다. 버전을 파악할 수 없습니다.
framework.0.sdk.chooser.error.title=클래스 생성 실패
framework.0.library={0} 라이브러리
framework.0.library.version.1={0} 라이브러리 버전 {1}
framework.gant=Gant
script.runner.display.name=Groovy
script.runner.description=Groovy 클래스 또는 스크립트
script.runner.chooser.title=스크립트 경로
script.runner.chooser.description=스크립트 경로 지정\:
script.runner.module.not.specified.message=모듈이 지정되지 않았습니다
script.runner.no.groovy.for.module=Groovy가 모듈 ''{0}''에 대해 구성되지 않았습니다
script.runner.cant.find.script=스크립트 ''{0}'' 을(를) 찾을 수 없음
script.runner.unknown.script.type=알 수 없는 스크립트 유형 ''{0}''
script.runner.file.is.not.groovy.file=스크립트 파일이 Groovy 파일이 아닙니다
script.runner.class.does.not.exist=클래스가 없습니다.
script.runner.class.cannot.be.executed=클래스를 실행할 수 없습니다
shell.cannot.run.title=실행할 수 없음
dialog.title.refactoring.unavailable.in.current.scope=현재 범위에서는 리팩터링을 사용할 수 없음
parameter.list.owner.chooser.title=다음으로 매개변수 삽입
extract.closure.command.name=클로저 추출
introduce.constant.title=상수 삽입
undefined.library.version=정의되지 않음
method.parameters.count.max.parameters.option=최대 매개변수 개수\:
method.returns.max.returns.option=반환점 제한\:
overly.complex.method.complexity.limit.option=메서드 복잡성 제한\:
overly.long.method.statements.limit.option=메서드당 최대 구문 수\:
overly.nested.method.nesting.limit.option=최대 중첩 깊이\:
add.method.family=메서드 추가
change.base.method.label=기본 메서드 변경
change.usages.label=사용 위치 변경
convert.parameter.to.map.entry.title=매개변수를 맵 항목으로 변환
live.template.context.declaration=선언
live.template.context.expression=표현식
live.template.context.statement=구문
find.usages.method.0.of.class.1={0} de {1}
change.signature.type.column=유형
change.signature.default.initializer.column=기본 이니셜라이저
static.import.method.fix=static import 메서드...
static.import.method.0.fix=static import 메서드 ''{0}''
groovy.consoles.type=Consola Groovy
getter.kind.gdk.method.0=GDK 메서드 {0}
getter.kind.method.0=메서드 {0}
getter.kind.getter.0=getter {0}
parameter.hint.number.of.arguments={0, choice, 0\#|1\#{0} 인수|2\#{0} 인수}
surround.with.for=for
surround.with.if=if
surround.with.if.else=if/else
surround.with.if.expr=if (expr)
surround.with.if.else.expr=if (expr)/else
surround.with.parentheses=(expr)
surround.with.closure={ ->... }.call()
surround.with.try=try
surround.with.try.catch=try/catch
surround.with.try.finally=try/finally
surround.with.try.catch.finally=try/catch/finally
surround.with.while=while
surround.with.while.expr=while (expr)
surround.with.cast=((Type) expr)
surround.with.with=with () {...}
surround.with.with.expr=with (expr)
surround.with.shouldFail=shouldFail () {...}
code.style.group.list.map.literals=List 및 Map 리터럴
code.style.option.align.when.multiple=여러 개일 경우 정렬
code.style.option.align.multiline.named.arguments=여러 줄의 이름 지정된 인수 정렬
code.style.option.use.flying.geese.braces=닫는 중괄호를 한 줄에 입력
code.style.option.import.annotations=어노테이션 가져오기
code.style.option.simple.lambdas.closures.in.one.line=한 줄의 간단한 람다/클로저
code.style.option.relational.operators=관계 연산자(<, >, <\=, >\=, <\=>)
code.style.option.unary.operators=단항 연산자(\!, -, +, ++, --, *)
code.style.option.in.named.argument.before.colon=''\:'' 앞 이름 지정된 인수 내
code.style.option.in.named.argument.after.colon=''\:'' 뒤 이름 지정된 인수 내
code.style.option.list.maps.literals=List 및 Map 리터럴
code.style.option.closure.left.brace.in.method.calls=메서드 호출 내 왼쪽 중괄호 클로저
code.style.option.gstring.injection.braces=GString 삽입 중괄호
code.style.option.tuple.assignment.expression=튜플 할당 표현식
code.style.option.regexp.expression=정규 표현식 (\=\=~, \=~)
code.style.option.before.assert.separator=''assert'' 구분 기호 앞
code.style.option.after.assert.separator=''assert'' 구분 기호 뒤
# @Singleton
singleton.constructor.found=@Singleton 클래스는 생성자를 포함할 수 없습니다
singleton.constructor.remove=생성자 제거
singleton.constructor.makeNonStrict=@Singleton을 비 strict로 설정
########################################################################################################################
# Unused imports
########################################################################################################################
unused.import=사용되지 않은 import 문
optimize.imports=import 문 최적화
optimize.all.imports=사용되지 않는 import 문 최적화
########################################################################################################################
# Create class fix
########################################################################################################################
dialog.create.class.package.chooser.title=대상 패키지 선택
create.directory.command=디렉터리  생성
destination.package=대상 패키지\:
second.unsafe.call=두 번째 안전하지 않은 호출
call.can.throw.npe=호출 체인이 NullPointerException을 던질 수 있습니다
unused.default.parameter.message=디폴트 매개변수가 사용되지 않습니다
unused.default.parameter.fix=이니셜라이저 제거
unused.assignment.tooltip=대입이 사용되지 않습니다
unused.variable=변수가 사용되지 않습니다
variable.can.be.final.tooltip=변수 ''{0}'' 은(는) final이 될 수 있습니다
parameter.can.be.final.tooltip=매개변수 ''{0}'' 은(는) final이 될 수 있습니다
equals.between.inconvertible.types.tooltip=<code>{0}</code>이(가) 변환할 수 없는 유형인 ''{1}'' 및 ''{2}'' 의 객체 사이에 있습니다
replace.with.operator.message=''{0}'' 을(를) 연산자로 바꿀수 있습니다
replace.with.operator.fix=''{0}'' 을(를) 연산자로 바꾸기
replace.with.operator.double.negation.option=이중 부정 사용(예\: \!\!)
replace.with.operator.compareTo.equality.option=''compareTo'' 등식을 equals(예\: \=\=)로 바꾸기
replace.with.operator.parentheses=추가 소괄호가 필요한 경우 연산자로 바꾸도록 제안 안 함
replace.with.method.message=''{0}'' 메서드 호출로 바꿀 수 있음
replace.with.method.fix=''{0}'' 메서드로 바꾸기
unassigned.access.tooltip=변수 ''{0}'' 은(는) 대입되지 않을 수 있습니다
no.return.message=일부 실행 경로가 값을 반환하지 않습니다
unresolved.type.status=유형 ''{0}'' 이(가) 해결되지 않았습니다
no.type.specified=지정된 유형 없음
dynamic.element=동적 요소
pointless.boolean.problem.descriptor=\#ref 을(를) ''{0}'' (으)로 단순화할 수 있습니다 \#loc
pointless.arithmetic.error.message=\#ref 을(를) ''{0}'' (으)로 바꿀수 있습니다 \#loc
pointless.boolean.quickfix=단순화
Cannot.perform.undo.operation=연산을 실행 취소할 수 없음
Undo.disable=비활성화 실행 취소
type.doesnt.contain.method=유형 ''{0}'' 에 메서드 ''{1}'' 이(가) 없으므로 해당 유형을 범위 내에서 반복할 수 없습니다
type.doesnt.implement.comparable=유형 ''{0}'' 이(가) Comparable을 구현하지 않습니다
add.method=메서드 ''{0}()'' 을(를) ''{1}'' 에 추가
implement.class={0} 구현
fix.class=클래스 {0} 수정
rtype.cannot.contain.ltype=''{1}'' 은(는) ''{0}'' 을(를) 포함할 수 없습니다
new.instance.of.singleton=@groovy.lang.Singleton 어노테이션이 지정된 클래스의 새 인스턴스
replace.new.expression.with.instance.access=인스턴스 액세스로 바꾸기
getter.0.clashes.with.getter.1=충돌 발생\: ''{0}'' 와(과) ''{1}''
unused.0=사용되지 않은 {0}
remove.0={0} 제거
replace.postfix.0.with.prefix.0=접미사 {0} 을(를) 접두사 {0} (으)로 바꾸기
replace.0.with.1={0} 을(를) 2진 {1} (으)로 바꾸기
local.var.0.is.reassigned=지역 변수 ''{0}'' 이(가) 대입되었습니다
anonymous.class=익명 클래스
closure=클로저
other.scope=기타 범위
method.may.be.static=메서드가 static일 수 있습니다
method.may.be.static.option.ignore.trait.methods=특성 메서드 무시
method.may.be.static.only.private.or.final.option=final 또는 private 메서드만 검사
method.may.be.static.ignore.empty.method.option=빈 메서드 무시
ignore.boolean.expressions=부울 검사 시 대입되지 않은 변수 무시
highlight.if.groovy.object.methods.overridden=invokeMethod(), getProperty() 또는 setProperty()를 재정의하는 클래스에서 참조 강조 표시
highlight.if.missing.methods.declared=missingMethod() 또는 missingProperty()를 선언하는 클래스에서 참조 강조 표시
gr.package.inspection.check.scripts=스크립트 검사
java.style.property.access=Java 스타일 접근자 호출
type.customizer.is.not.marked.as.a.resource.file=유형 커스터마이저 스크립트가 컴파일러 리소스로 표시되지 않았습니다.
add.to.resources=리소스에 추가
add.type.customizer.to.resources=유형 커스터마이저 스크립트를 리소스에 추가
target.0.does.not.exist=대상 ''{0}'' 이(가) 없습니다
target.annotation.is.unused=@Target은 사용되지 않습니다
change.lvalue.type=변수 ''{0}'' 유형을 ''{1}'' (으)로 변경
replace.qualified.name.with.import=정규화된 이름을 import 문으로 바꾸기
comments.count.as.content=주석을 내용으로 계산
ignore.when.catch.parameter.is.named.ignore.or.ignored=catch 매개변수의 이름이 ignore 또는 ignored로 지정된 경우 무시
no.applicable.signature.found=적용 가능한 시그니처를 찾을 수 없음
expected.type.0=''{0}'' 이(가) 필요하나 ''{1}'' 발견
declare.explicit.implementations.of.trait=특성의 명시적 구현 선언
unnecessary.modifier.description=제어자 ''{0}'' 은(는) 필요하지 않습니다
unnecessary.modifier.remove=불필요한 ''{0}'' 제거
unnecessary.def.explicitly.typed.only=명시적으로 유형 지정된 선언에서만 보고
unnecessary.alias.fix=불필요한 별칭 제거
unnecessary.alias.description=별칭이 필요하지 않습니다
unnecessary.semicolon.description=세미콜론이 필요하지 않습니다
unnecessary.semicolon.fix=세미콜론 제거
dynamic.dialog.class.label=클래스(&C)\:
dynamic.dialog.type.label=유형(&T)\:
dynamic.dialog.static.checkbox=&정적
find.method.ro.method.usages=프로젝트 파일 내 둘러싸는 메서드 사용 위치 검색 중
find.method.ro.closure.usages=프로젝트 파일 내 둘러싸는 클로저 사용 위치 검색 중
conversion.method.not.allowed.in.non.groovy.files=Groovy가 아닌 파일에서 사용되는 메서드에는 리팩터링을 사용할 수 없습니다\:
conversion.closure.not.allowed.in.non.groovy.files=Groovy가 아닌 파일에서 사용되는 클로저에는 리팩터링을 사용할 수 없습니다\:
wrong.method.first.parameter.type=메서드 ''{0}'' 은(는) 이름 지정된 인수와 함께 사용되지만 내부의 첫 번째 인수 ''{1}'' 이(가) Map 유형을 준수하지 않습니다.
wrong.closure.first.parameter.type=클로저 ''{0}'' 은(는) 이름 지정된 인수와 함께 사용되지만 내부의 첫 번째 인수 ''{1}'' 이(가) Map 유형을 준수하지 않습니다.
map.parameter.dialog.create.new.checkbox=이름 지정된 인수에 대한 매개변수 생성(&C)
map.parameter.dialog.explicit.type.checkbox=명시적으로 유형 지정
convert.cannot.itself=리팩터링은 맵 매개변수 자체에 사용할 수 없습니다
map.param.name=맵 매개변수 이름(&N)\:
convert.param.to.map.entry=매개변수를 맵 항목으로 변환
closure.used.as.variable=클로저가 인수로서 전달되었습니다. 리팩터링을 하면 의미가 변경될 수 있습니다.
do.you.want.to.change.method.return.type=''{0}'' 메서드의 반환 유형을 변경하시겠어요?
do.you.want.to.change.variable.type=''{0}'' 의 유형을 변경하시겠어요?
closure.is.accessed.outside.of.groovy=필드 <b>{0}</b> 이(가) Groovy 외부에서 액세스됩니다
write.access.to.closure.variable=필드 <b>{0}</b>에 대한 쓰기 액세스
field.is.used.in.argument.label=필드 <b>{0}</b> 이(가) 인수 라벨에서 사용됩니다
method.with.signature.already.exists=시그니처 {0} 이(가) 포함된 메서드가 이미 있습니다
field.already.exists=필드 <b>{0}</b>이(가) 이미 있습니다
method.is.used.outside.of.groovy=메서드가 Groovy 외부에서 사용됩니다
do.you.want.to.change.type.of.parameter.in.method=메서드 ''{1}'' 에서 매개변수 ''{0}'' 의 유형을 변경하시겠어요?
file.exists=파일 ''{0}'' 이(가) 디렉터리 ''{1}'' 에 이미 있습니다
move.to.correct.dir.family.name=올바른 패키지로 파일 이동
move.to.correct.dir=''{0}'' (으)로 이동
add.return.type=반환 유형 추가
add.return.type.to.method.declaration=반환 유형을 메서드 선언에 추가
infer.method.parameters.types=명시적 유형을 매개변수에 추가
infer.method.parameters.types.for.method.declaration=메서드 선언 내 모든 매개변수의 명시적 유형을 추가
replace.with.wrapper={0} (으)로 바꾸기
replace.primitive.type.with.wrapper=기본 유형을 래퍼로 바꾸기
remove.parameter.0=매개변수 ''{0}'' 제거
remove.unused.parameter=사용되지 않은 매개변수 제거
remove.exception=예외 제거
remove.catch.block=catch 블록 제거
try.catch.fix=try-catch 수정
cannot.create.class=클래스를 생성할 수 없음
rename.file.to.0=파일 이름을 ''{0}'' (으)로 변경
java.style.properties.invocation.intention.family.name=Java 스타일 접근자 호출을 Groovy 스타일 프로퍼티 참조로 변경
java.style.properties.invocation.intention.name=Groovy 스타일 프로퍼티 참조로 변경
generate.equals.and.hashcode.already.defined.warning.anonymous=equals() 및 hashCode()가 이미 정의되어 있음
generate.equals.and.hashcode.already.defined.warning=equals() 및 hashCode()가 이미 정의되어 있음
generate.equals.and.hashcode.already.defined.title=equals() 및 hashCode()가 이미 정의되어 있음
generate.equals.compare.nested.arrays.comment= // 여기 {0} 의 중첩된 배열 - 값 비교
generate.equals.compare.arrays.comment= // Object[] 배열을 Arrays.equals와 비교하면 올바르지 않을 수 있음
generate.property.missing.already.defined.warning=propertyMissing()이 이미 정의되어 있음
generate.property.missing.already.defined.title=propertyMissing()이 이미 정의되어 있음
generate.method.missing.already.defined.warning=methodMissing()이 이미 정의되어 있음
generate.method.missing.already.defined.title=methodMissing()이 이미 정의되어 있음
action.Gant.NewScript.text=Gant 스크립트
action.Gant.NewScript.description=새 Gant 스크립트 생성
action.Groovy.Console.text=Consola Groovy
action.Groovy.Console.description=Inicia la consola Groovy
module.name.0.and.groovy.version.1={0} ({1})
groovy.version.0=Groovy {0}
groovy.version.bundled.0=번들 Groovy {0}
configurable.greclipse.border.title=Groovy-Eclipse 옵션
configurable.greclipse.path.label=groovy-eclipse-batch jar 경로\:
configurable.greclipse.path.chooser.description=Groovy 배포판과 일치하는 버전의 groovy-eclipse-batch-*.jar 경로 선택
configurable.greclipse.command.line.params.label=추가 명령줄 매개변수\:
configurable.greclipse.debug.checkbox=디버깅 정보 생성
configurable.hotswap.checkbox=Groovy 코드의 핫 스왚 에이전트 활성화
configurable.hotswap.checkbox.description=디버그된 애플리케이션에서 직렬화 문제를 유발할 수 있음
run.configuration.script.path.label=스크립트 경로\:
run.configuration.vm.options.label=VM 옵션(&V)\:
run.configuration.module.chooser.label=모듈(&M)\:
run.configuration.module.classpath.checkbox=러너에 모듈 클래스 경로 추가(&C)
pull.up.wont.be.accessible.from={1} 에서 {0} 에 액세스할 수 없습니다
pull.up.wont.be.accessible.from.the.subclass={0} 이(가) 하위 클래스에서 액세스할 수 없는 {1} 을(를) 사용합니다.
pull.up.abstract.wont.be.accessible.from={0} 은(는) 하위 클래스에서 접근할 수 없으므로 abstract으로 만들 수 없음

gdsl.trusted.project.message=This project contains Groovy DSL (GDSL) scripts, which improve code insight experience when editing Groovy code. GDSL scripts might contain potentially malicious code, which will be executed within the IDE. Would you like to run them?
gdsl.trusted.project.answer.trust=Yes
gdsl.trusted.project.answer.dont.trust=No
