scala.notification.group.id.general=Scala(일반)
scala.notification.group.id.java.to.scala.converter=Java에서 Scala로 변환하는 컨버터
scala.notification.group.id.sbt.project.import=SBT 프로젝트 가져오기
scala.notification.group.id.sbt.shell=SBT 셸
scala.notification.group.id.plugin.verifier=Scala 플러그인 검증기
scala.notification.group.id.plugin.updater=Scala 플러그인 업데이터
scala.notification.group.id.scala3.disclaimer=Scala 3 면책조항
scala.notification.group.id.features.advertiser=Scala 기능 애드버타이저
scala.notification.group.id.scalafmt=Scalafmt
scala.notification.group.id.scalafmt.fatal.errors=Scalafmt 치명적인 오류
scala.notification.group.id.scalafmt.format.errors=Scalafmt 서식 오류
title.problem.opening.web.page=웹 페이지 열기 문제
html.unable.to.launch.web.browser=<html><body>웹 브라우저를 실행할 수 없으므로, 수동으로 여세요\:<br />{0} (<a href\="{0}">클립보드로 복사</a>)</body></html>
copy.link.to.clipboard=링크를 클립보드에 복사
edit.package.prefix=패키지 접두사 편집...
make.implicit.conversion.explicit.action.text=묵시적 변환을 명시적으로 만들기
make.implicit.conversion.explicit.action.description=묵시적 변환을 명시적으로 만들기
title.choose.implicit.conversion.method=묵시적 변환 메서드 선택\:
press.alt.enter=Alt+Enter 누르기
make.explicit=명시적으로 설정
make.explicit.and.import.method=명시적으로 설정(메서드 가져오기)
new.packageobject.menu.action.text=패키지 객체
new.packageobject.menu.action.description=새 Scala 패키지 객체 생성
newclass.menu.action.text=Scala 클래스
newclass.menu.action.description=새 Scala 클래스 생성
create.new.scala.class=새 Scala 클래스 생성
newclassorfile.menu.action.text=Scala 클래스/파일
newclassorfile.menu.action.description=새 Scala 클래스 또는 파일을 생성합니다
create.new.scala.class.or.file=새 Scala 클래스/파일 생성
this.is.not.a.valid.scala.qualified.name=올바른 Scala 정규화된 이름이 아닙니다
unknown.type=<알 수 없음>
type.info.text=유형 정보
type.info.description=유형 정보 표시
could.not.find.type.for.selection=선택 항목의 유형을 찾을 수 없습니다
hint.label.non.singleton=비 싱글턴
hint.label.simplified=단순화됨
hint.label.original=원본
hint.label.expected=필요
toggle.type.aware.highlighting.menu.action.text=유형 정보를 사용하는 강조표시 전환
toggle.type.aware.highlighting.menu.action.description=유형 인식 강조 표시 전환
implicit.argument.is.applicable=묵시적 인수를 적용할 수 있습니다
implicit.is.diverged=implicit이 분기되었습니다
can.t.infer.proper.types.for.type.parameters=유형 매개변수에 적절한 유형을 추론할 수 없음
can.t.find.implicit.argument.for.this.definition=이 정의에 대한 묵시적 인수를 찾을 수 없습니다
no.implicits.applicable.by.type=유형별로 적용 가능한 묵시적 항목이 없습니다
reason.prefix.applicable=적용 가능\:
reason.prefix.diverged=분기됨\:
reason.prefix.cannot.infer.type=유형을 추론할 수 없음\:
reason.prefix.candidate=후보\:
problem.prefix.ambiguous=(모호함)
problem.prefix.not.found=(찾을 수 없음)
location.description.parameter.of.name={0}의 매개변수
location.description.parameter.of.getclassnametext={0}의 매개변수
location.description.anonymous.class=익명 클래스
location.description.containing.block=포함 블록
location.description.body.of.name={0}의 본문
show.implicit.arguments.action.text=묵시적 인수 표시
show.implicit.arguments.action.description=묵시적 인수 표시
no.implicit.arguments=묵시적 인수 없음
title.expressions=표현식
navigate=Navegar
implicit.arguments.for.implicit.conversion=묵시적 변환에 대한 묵시적 인수\:
implicit.arguments=묵시적 인수\:
implicit.conversions.action.text=묵시적 변환 표시
implicit.conversions.action.description=묵시적 변환 표시
type.mismatch.found.required=유형 불일치, 발견\: {0}, 필요\: {1}
type.mismatch.expected.actual=유형 불일치, 기대\: {0}, 실제\: {1}
abstract.member.not.have.private.modifier=추상 멤버는 private 제어자를 가질 수 없습니다
illegal.inheritance.from.sealed.kind=봉인된 {0} ''{1}'' (으)로부터의 올바르지 않은 상속
passed.as.by.name.parameter=by-name 매개변수로 전달됨
function.must.define.type.explicitly=메서드 {0} 에 return 문이 있으므로 결과 유형이 필요합니다
function.recursive.need.result.type=재귀 메서드 {0} 에 결과 유형이 필요합니다
family.name.remove.tailrec.annotation=@tailrec 어노테이션 제거
method.annotated.with.tailrec.is.neither.private.nor.final=@tailrec로 어노테이션 추가된 메서드가 비공개도 아니고 최종도 아닙니다(재정의될 수 있음)
method.annotated.with.tailrec.contains.no.recursive.calls=@tailrec 어노테이션이 지정된 메서드가 재귀 호출을 포함하지 않습니다
recursive.call.not.in.tail.position=재귀 호출이 꼬리 위치에 없습니다(@tailrec 어노테이션이 지정된 메서드 내)
member.needs.override.modifier={0} ''{1}'' 에 재정의 제어자가 필요합니다
member.overrides.nothing={0} ''{1}'' 이(가) 아무 것도 재정의하지 않습니다
can.not.override.final={0} ''{1}'' 이(가) final 멤버를 재정의할 수 없습니다
member.cannot.override.val=메서드 {0} 에 안정적인 변경 불가한 값이 필요합니다
var.cannot.override.val=변수 {0} 이(가) 변경 불가한 값을 재정의할 수 없습니다
override.types.not.conforming=재정의 유형 {0} 이(가) 기본 유형 {1} 을(를) 준수하지 않습니다
regular.method.overrides.extension=메서드 {0}은(는) 일반 메서드이므로 확장 메서드를 재정의할 수 없습니다.
extension.method.overrides.regular=메서드 {0}은(는) 확장 메서드이므로 일반 메서드를 재정의할 수 없습니다.
covariant.type.contravariant.position.of.method=공변성 유형 {0} 이(가) 메서드 {2} 의 유형 {1} 내 반공변성 위치에 나타납니다
covariant.type.contravariant.position.of.value=공변성 유형 {0} 이(가) 값 {2} 의 유형 {1} 내 반공변성 위치에 나타납니다
covariant.type.invariant.position.of.method=공변성 유형 {0} 이(가) 메서드 {2} 의 유형 {1} 내 무공변성 위치에 나타납니다
covariant.type.invariant.position.of.value=공변성 유형 {0} 이(가) 값 {2} 의 유형 {1} 내 무공변성 위치에 나타납니다
contravariant.type.covariant.position.of.method=반공변성 유형 {0} 이(가) 메서드 {2} 의 유형 {1} 내 공변성 위치에 나타납니다
contravariant.type.covariant.position.of.value=반공변성 유형 {0} 이(가) 값 {2} 의 유형 {1} 내 공변성 위치에 나타납니다
contravariant.type.invariant.position.of.method=반공변성 유형 {0} 이(가) 메서드 {2} 의 유형 {1} 내 무공변성 위치에 나타납니다
contravariant.type.invariant.position.of.value=반공변성 유형 {0} 이(가) 값 {2} 의 유형 {1} 내 무공변성 위치에 나타납니다
id.is.already.defined={0} 이(가) 범위 안에 이미 정의되어 있습니다
type.mismatch.message=유형이 불일치합니다. 필요\: {0}, 발견\: {1}
type.mismatch.hints.action.text=유형 불일치 힌트
type.mismatch.hints.action.description=유형 불일치 힌트 전환
family.name.create.apply.method=''apply'' 메서드 생성
create.apply.method.in={0} 내 ''apply'' 메서드 생성
error.message.title.create.entity.quickfix=엔티티 빠른 수정 생성
family.name.create.extractor.object=추출기 객체 생성
create.extractor.object.named=추출기 객체 ''{0}'' 생성
family.name.create.parameter=매개변수 생성
create.parameter.named=매개변수 {0} 생성
family.name.create.parameterless.method=매개변수 없는 메서드 생성
create.parameterless.method.named=매개변수 없는 메서드 ''{0}'' 생성
family.name.create.variable=변수 생성
create.variable.named=변수 ''{0}'' 생성
family.name.create.value=값 생성
create.value.named=값 ''{0}'' 생성
family.name.create.method=메서드 생성
create.method.named=메서드 ''{0}''을(를) 생성합니다.
family.name.create.object=객제 생성
family.name.create.trait=특성 생성
family.name.create.class=클래스 생성
family.name.create.annotation.class=어노테이션 클래스 생성
family.name.create.case.class=케이스 클래스 생성
create.object.named=객제 ''{0}'' 생성
create.trait.named=특성 ''{0}'' 생성
create.class.named=클래스 ''{0}'' 생성
create.annotation.class.named=어노테이션 클래스 ''{0}'' 생성
create.case.class.named=case 클래스 ''{0}'' 생성
choose.level.popup.title=수준 선택
new.class.location.new.file=새 파일
new.class.location.top.level.in.this.file=이 파일의 최상위 수준
new.class.location.inner.in.class={0}의 내부
new.class.location.local.scope=로컬 범위
family.name.create.unapply.method=''unapply'' 메서드 생성
create.unapply.method.in={0} 내 ''unapply'' 메서드 생성
annotator.error.annotation.type.expected=어노테이션 타입이 필요합니다
annotator.error.wrong.right.assignment.side=잘못된 오른쪽 대입
annotator.error.reassignment.to.val=val에 다시 대입
illegal.assignment.target=잘못된 대입 대상
expr.type.does.not.conform.expected.type=유형 {0} 표현식이 기대 유형 {1} 을(를) 준수하지 않습니다
method.is.not.member=메서드 {0} 이(가) 유형 {1} 의 멤버가 아닙니다
expected.type.boolean=메서드 {0} 반환 유형으로 부울 유형 기대
missing.char.value=문자 값 누락
illegal.secondary.constructors.value.class=보조 생성자는 값 클래스에서 허용되지 않습니다
value.class.can.have.only.one.parameter=값 클래스는 하나의 매개변수만 가질 수 있습니다
value.class.can.have.only.val.parameter=값 클래스는 비공개가 아닌 val 매개변수 한 개만 가질 수 있습니다
type.parameter.value.class.may.not.be.specialized=값 클래스의 유형 매개변수는 특수화될 수 없습니다
value.classes.cannot.have.nested.objects=값 클래스는 중첩 클래스, 객체 또는 특성을 가질 수 없습니다.
value.classes.cannot.redefine.equals.hashcode=값 클래스는 equals 및 hashCode를 재정의할 수 없습니다
value.classes.can.have.only.defs=값 클래스에서는 필드 정의가 허용되지 않습니다
value.classes.may.not.be.member.of.another.class=값 클래스는 다른 클래스의 멤버일 수 없습니다
constructor.invocation.expected=''this'' 기대
type.mismatch.default.args.expected.actual=디폴트 인수 관련 유형 불일치, 기대\: {0}, 실제\: {1}
annotator.error.class.type.required.but.found=클래스 유형이 기대되나 ({0}) 이(가) 발견됨
annotator.error.constructor.has.malformed.definition=생성자 정의 형식이 잘못되었습니다
annotator.error.no.constructor.accessible=여기에서 접근 가능한 생성자가 없습니다
annotator.error.cannot.resolve.overloaded.constructor=오버로드된 생성자 `{0}`을(를) 해결할 수 없음
annotator.error.trait.has.no.constructor=특성 {0} 은(는) 특성이므로 생성자 인수를 취하지 않습니다
annotator.error.too.many.arguments.for.constructor=생성자 {0} 의 인수가 너무 많음
annotator.error.missing.argument.list.for.constructor=생성자 {0} 의 인수 목록 누락
annotator.error.expansion.for.non.repeated.parameter=반복되지 않는 매개변수 확장
annotator.error.positional.after.named.argument=명명된 인수 뒤 위치 인수
annotator.error.parameter.specified.multiple.times=매개변수가 여러 번 지정됨
annotator.error.cannot.apply.constructor=생성자 {0} 을(를) 적용할 수 없음
annotator.error.enum.nonvariant.type.param,in.enum=열거형 클래스의 상위 {0}의 타입 인수를 파악할 수 없습니다. 타입 매개변수 {1}이(가) 무공변성입니다
annotator.error.enum.case.must.extend.parent=열거형 case는 해당 열거형 클래스 {0}을(를) 확장해야 합니다
annotator.error.enum.two.type.parameter.clauses=열거형 case 및 열거형 클래스 모두 타입 매개변수를 포함하므로 명시적 extends 절이 필요합니다
semicolon.not.allowed.here=세미콜론이 허용되지 않음
remove.all.erroneous.semicolons.from.forexpression=for 표현식의 모든 잘못된 세미콜론 제거
else.expected=''else'' 가 필요합니다
for.pattern.bindings.require.scala3=''for'' 패턴 바인딩 내 ''case'' 구문을 사용하려면 Scala 3.0이 필요합니다
enumerators.generator.val.keyword.found=패턴이 기대되나 ''val''이 발견되었습니다
enumerators.binding.val.keyword.deprecated=열거자 내 ''val'' 키워드는 더 이상 사용되지 않습니다
enumerators.binding.case.keyword.found=패턴이 기대되나 ''case''가 발견되었습니다
remove.case=''case'' 제거
family.name.remove.case.from.enumerator=열거자에서 ''case'' 제거
transparent.method.must.be.inline=''transparent'' 키워드는 인라인 메서드에만 사용할 수 있습니다
only.inline.methods.may.have.inline.args=''inline'' 제어자는 인라인 메서드의 인수에만 사용할 수 있습니다
annotator.error.too.many.parameters=매개변수가 너무 많음
annotator.error.missing.parameter.type=매개변수 유형 누락
type.mismatch.expected=유형 불일치, 기대\: {0}, 실제\: {1}
repeated.param.non.method=메서드 시그니처에는 반복 매개변수가 허용되지 않습니다. 대신 `Seq`를 사용하세요
family.name.give.a.name.to.anonymous.abstract.given=익명 추상 given의 이름 지정
family.name.implement.anonymous.abstract.given=익명 추상 given 구현
given.alias.declaration.must.be.named=익명 given은 추상적일 수 없습니다
import.expr.should.be.qualified=import 표현식이 정규화되어야 합니다
cannot.resolve.in.StringContext=값 ''{0}'' 이(가) StringContext의 멤버가 아닙니다
wrong.type.no.literal.types=잘못된 유형 `{0}`, 리너털 유형 지원을 위해 Scala 2.13 또는 `-Yliteral-types` 컴파일러 플래그가 있는 Typelevel Scala를 사용하세요
identifier.expected.but.0.found=식별자가 필요하나 {0}이(가) 발견되었습니다
macro.defs.must.have.explicit.return.type=매크로 정의는 명시적으로 지정된 반환 유형을 포함해야 합니다
annotator.error.unspecified.value.parameters=지정되지 않은 값 매개변수\: {0}
annotator.error.cannot.resolve.overloaded.method=오버로드된 메서드를 해결할 수 없음
annotator.error.too.many.arguments=인수가 너무 많음
annotator.error.target.does.not.take.parameters={0} 은(는) 매개변수를 취하지 않습니다
missing.argument.list.for.method.with.explicit.list=메서드 {1}의 인수 목록 {0} 누락
missing.argument.list.for.method=메서드 {0}의 인수 목록 누락
does.not.take.parameter.default.target=애플리케이션
annotator.error.too.many.arguments.method=메서드 {0} 의 인수가 너무 많음
annotator.error.name.has.malformed.definition=''{0}''에 형식이 잘못된 정의가 있습니다
illegal.instantiation={0} ''{1}'' 은(는) abstract이므로 인스턴스화할 수 없습니다
octal.literals.removed=8진 리터널 구문은 Scala 2.11 이후 비활성화되었습니다
trailing.underscore.separator=후미 밑줄 구분자가 허용되지 않습니다
illegal.underscore.separator=밑줄 구분자를 사용할려면 Scala 2.13이 필요합니다
long.literal.is.out.of.range=Integer 숫자가 Long 유형의 범위조차 벗어납니다
integer.literal.is.out.of.range=Integer 리터럴이 int 유형의 범위를 벗어납니다
lowercase.long.marker=소문자로 쓰인 long 리터럴 마커
var.cannot.be.overridden=가변 변수는 재정의할 수 없습니다
missing.setter.implementation=setter에 대한 구현 누락\: {0}
missing.getter.implementation=getter에 대한 구현 누락\: {0}
annotator.error.parameter.without.an.owner.name=소유자가 없는 매개변수\: {0}
annotator.error.missing.type.annotation.for.parameter=매개변수의 유형 어노테이션 누락\: {0}
missing.parameter.type.name=매개변수 유형 누락\: {0}
topic.parameters.may.not.be.call.by.name={0} 매개변수는 이름에 의한 호출(call-by-name)이 아닐 수 있습니다
unspecified.type.parameters=지정되지 않은 값 매개변수\: {0}
too.many.type.arguments.for.typeparamowner={0}의 타입 인수가 너무 많습니다. {1}개가 필요하나 {2}개가 발견되었습니다
type.arg.does.not.conform.to.upper.bound=타입 {0}이(가) 타입 매개변수 {2}의 상위 바운드 {1}을(를) 준수하지 않습니다
type.arg.does.not.conform.to.lower.bound=타입 {0}이(가) 타입 매개변수 {2}의 하위 바운드 {1}을(를) 준수하지 않습니다
name.does.not.take.type.arguments={0}은(는) 타입 인수를 취하지 않습니다
expected.type.constructor=타입 생성자 {0}이(가) 필요합니다
type.constructor.does.not.conform=타입 생성자 {0}이(가) {1}을(를) 준수하지 않습니다
type.constructor.mismatch=타입 생성자가 일치하지 않습니다.
annotator.error.repeated.parameter.must.be.last=*-매개변수가 마지막에 와야 합니다
annotator.error.repeated.or.default=*-매개변수가 있는 매개변수 섹션이 디폴트 인수를 포함할 수 없습니다
pattern.on.refinement.unchecked=개선 유형의 패턴 일치가 검사되지 않았습니다
type.cannot.be.used.in.type.pattern=유형 {0} 이(가) 유형 패턴 또는 isInstanceOf 테스트에서 사용될 수 없습니다
scrutinee.incompatible.pattern.type=Scrutinee이 패턴 유형과 호환되지 않습니다, 발견\: {0}, 필요\: {1}
pattern.type.incompatible.with.expected=패턴 유형이 기대 유형과 호환되지 않습니다, 발견\: {0}, 필요\: {1}
constructor.cannot.be.instantiated.to.expected.type=생성자를 기대 유형으로 초기화할 수 없습니다, 발견\: {0}, 필요\: {1}
fruitless.type.test=결과가 없는 유형 테스트\: 유형 {0} 값이 동시에 {1} 이(가) 될 수 없습니다
erasure.warning=(여전히 해당 이레이저와 일치할 수 있음)
wrong.number.arguments.extractor=추출기의 잘못된 인수 개수, 발견\: {0}, 기대\: {1}
wrong.number.arguments.extractor.unapplySeq=추출기의 잘못된 인수 개수, 발견\: {0}, 기대\: {1} 이상
stable.identifier.required=안정적 식별자가 기대되나 {0} 이(가) 발견됨
better.monadic.for.invalid.pattern=인수에 명시적 유형 어노테이션이 지정되어야 합니다
vararg.pattern.must.be.last.pattern=_*는 마지막 인수로만 사용될 수 있습니다
vararg.pattern.with.colon.requires.scala3=vararg 패턴 내 ''\:'' 구문을 사용하려면 Scala 3.0이 필요합니다
vararg.pattern.with.at.deprecated.since.scala3=vararg 패턴 내 ''@'' 구문은 Scala 3.0 이후 버전에서 더 이상 사용되지 않습니다
family.name.replace.type.with.type.in.vararg.pattern=vararg 패턴 내 ''{0}'' 을(를) ''{1}'' (으)로 바꾸기
family.name.replace.with.scala3.vararg.pattern=''\:'' 구문을 Scala 3.0 vararg 패턴으로 바꾸기
replace.with.type=''{0}''(으)로 바꾸기
poly.function.without.parameters=다형 함수 {0}은(는) 값 매개변수를 가져야 합니다
cannot.resolve=심볼 {0}을(를) 해결할 수 없습니다.
cannot.resolve.overloaded=오버로드된 메서드 ''{0}'' 을(를) 해결할 수 없음
forward.reference.detected=잘못된 전방 참조
cannot.resolve.apply.method=메서드 {0}.apply를 해결할 수 없음
cannot.resolve.unapply.method=메서드 {0}.unapply를 해결할 수 없음
annotator.error.missing.arguments.for.method=메서드 {0} 의 인수 누락
symbol.is.inaccessible.from.this.place=이 위치에서는 심볼 {0}에 액세스할 수 없습니다
return.expression.is.redundant=Unit 결과 유형을 가진 메서드에서 {0} 반환 중
return.outside.method.definition=메서드 정의 외부의 return 문
called.constructor.definition.must.precede=호출된 생성자 정의가 생성자 정의 호출보다 선행해야 합니다
annotator.error.cannot.find.constructor.for.this.call=이 호출에 대한 생성자를 찾을 수 없음
type.takes.type.parameters=유형 {0} 은(는) 유형 매개변수를 취합니다
string.literal.is.too.long=문자열 리터럴 크기가 컴파일러 제한을 초과합니다
string.literal.invalid.escape.character=잘못된 이스케이프 문자
string.literal.invalid.unicode.escape=잘못된 유니코드 이스케이프
symbolliterals.are.deprecated=심볼 리터널은 Scala 2.13에서 더 이상 사용되지 않습니다. 대신 Symbol("{0}")을 사용하세요.
illegal.inheritance.self.type=올바르지 않은 상속, 자체 유형 {0} 이(가) {1} 을(를) 준수하지 않습니다
mixin.required=''{3}'' 내 멤버 ''{2}'' 이(가) ''abstract'' 및  ''override'' 로 표시되나 기본 클래스에서 구체 구현을 찾을 수 없으므로, {0} ''{1}'' 은(는) mixin이여야 합니다
illegal.undefined.member=선언되었으나 정의되지 않은 멤버는 오직 클래스만 가질 수 있습니다
illegal.inheritance.from.final.kind=final {0} ''{1}'' (으)로부터의 올바르지 않은 상속
illegal.inheritance.from.value.class=값 클래스 ''{0}'' (으)로부터의 올바르지 않은 상속
illegal.inheritance.extends.enum=열거형 확장은 금지됩니다
trait.may.not.call.constructor=특성 {0}이(가) {1}의 생성자를 호출하지 않을 수 있습니다
trait.is.already.implemented.by.superclass=특성 {0}은(는) 이미 상위 클래스 {1}에 의해 구현되어 있으므로 해당 생성자는 다시 호출되지 않습니다
parameterised.trait.is.implemented.indirectly=매개변수화된 특성 {0}은(는) 간접적으로 구현됩니다. 인수가 전달되려면 직접 구현되어야 합니다
illegal.inheritance.multiple={0} ''{1}'' 이(가) 여러 번 상속됨
illegal.mixin={0} ''{1}'' 은(는) 혼합 가능한 특성이여야 합니다
member.implementation.required={0} ''{1}'' 이(가) abstract로 선언되거나 ''{3}'' 내 abstract 멤버 ''{2}'' 을(를) 구현해야 합니다
object.creation.impossible.since={0}, 그러므로 객체를 생성할 수 없습니다
member.is.not.defined={1}의 멤버 {0}(이)가 정의되지 않았습니다
trait.parameter.require.scala3=특성 매개변수를 사용하려면 Scala 3.0이 필요합니다
lower.bound.conform.to.upper=하한이 상한을 준수하지 않습니다
cannot.upcast.type.to.other.type={0}을(를) {1}(으)로 업캐스트할 수 없습니다
unbound.placeholder.parameter=바인딩되지 않은 자리표시자 매개변수
local.variables.must.be.initialized=지역 변수가 초기화되어야 합니다
default.init.prohibited.literal.types=리터럴 유형 var에서 금지된 디폴트 초기화
annotation.ascriptions.in.pattern.definitions.require.scala3=패턴 정의 내 어노테이션 귀속을 사용하려면 Scala 3.0이 필요합니다
goto.super.member.chooser.title=상위 멤버 선택
goto.super.class.chooser.title=상위 클래스 선택
goto.super.class.or.member.chooser.title=상위 클래스/상위 멤버 선택
companion.class=클래스
companion.object=객체
companion.trait=특성
companion.enum=열거형
go.to.companion=컴패니언 {0}(으)로 이동
go.to.implementation=구현으로 이동
go.to.super.method=상위 멤버로 이동
gutter.companion=컴패니언
gutter.implemented=구현된 멤버
gutter.implementing=구성원 구현 중
gutter.overridden=재정의된 멤버
gutter.overriding=멤버 재정의 중
gutter.recursion=재귀 유형
gutter.sam=SAM 구현
has.companion=컴패니언 {0} 포함
multiple.overriding.tooltip=여러 개의 재정의 멤버
multiple.overriden.tooltip=여러 개의 재정의된 멤버
scala.line.markers=Scala 줄 마커
implements.member.prefix=멤버 구현
implements.member.from.prefix=다음에서 멤버 구현
implements.member.from.several.classes={0} 클래스에서 멤버 구현
overrides.member.from.prefix=다음에서 멤버 재정의
overrides.member.from.several.classes={0} 클래스에서 멤버 재정의
overrides.type.prefix=유형 재정의
overrides.type.from.super.several.classes={0} 클래스의 유형 재정의
navigation.title.super.members={0} 의 상위 멤버 선택
navigation.findUsages.title.super.members={0} 의 상위 멤버
navigation.title.super.types={0} 의 상위 유형 멤버 선택
navigation.findUsages.title.super.types={0} 의 상위 유형 멤버
trait.has.implementations=다음으로 혼합
trait.has.several.implementations={0} 클래스로 혼합됨
class.has.subclasses=확장 기준
class.has.several.subclasses={0} 하위 클래스별로 확장
has.implementations=멤버가 구현을 포함합니다
is.overridden.by=멤버가 재정의를 포함합니다
navigation.title.inheritors.trait=<html><b>{0}</b> 구현 선택({1} 클래스 발견)</html>
navigation.findUsages.title.inheritors.trait={0}의 구현
navigation.title.inheritors.class=<html><b>{0}</b> 하위 클래스 선택({1} 클래스 발견)</html>
navigation.findUsages.title.inheritors.class={0} 의 하위 클래스
navigation.title.implementing.member=<html><b>{0}</b> 의 구현 멤버 선택({1} 멤버 발견)</html>
navigation.findUsages.title.implementing.member={0} 의 구현 멤버
navigation.title.overriding.member=<html><b>{0}</b> 의 재정의 멤버 선택({1} 멤버 발견)</html>
navigation.findUsages.title.overriding.member={0} 의 재정의 멤버
notification.navigation.to.overriding.members=색인 업데이트 중에는 재정의하는 멤버로 이동할 수 없습니다
searching.for.overriding.members=재정의 멤버 검색
call.is.recursive=재귀 호출
method.is.recursive=Method ''{0}'' 이(가) 재귀 메서드입니다
method.is.tail.recursive=Method ''{0}'' 이(가) 꼬리 재귀 메서드입니다
type.mismatch.dot=유형 불일치.
lazy.modifier.is.not.allowed.here=''lazy'' 제어자는 값 정의에만 허용됨
lazy.modifier.is.not.allowed.with.param=''lazy'' 제어자는 허용되지 않으므로, 대신 call-by-name 매개변수를 사용하세요
lazy.values.may.not.be.abstract=lazy 값이 abstract일 수 없습니다
final.modifier.not.with.declarations=''final'' 제어자는 불완전한 멤버와 사용될 수 없습니다
final.modifier.not.with.trait=''final'' 제어자는 특성에 허용되지 않음
final.modifier.is.redundant.with.final.parents=''final'' 제어자는 객체 또는 final 클래스 멤버와 중복됩니다
final.modifier.is.not.allowed.here=''final'' 제어자는 허용되지 않습니다
access.modifier.is.not.allowed.here=''{0}'' 제어자는 허용되지 않습니다
abstract.modifier.redundant.fot.traits=''abstract'' 제어자는 특성과 중복됩니다
abstract.modifier.is.not.allowed=''abstract'' 제어자는 클래스 또는 ''override'' 제어자가 있는 정의에만 허용됩니다
abstract.override.modifier.is.not.allowed=''abstract override'' 제어자는 특성 멤버에만 허용됨
override.modifier.is.not.allowed.for.classes=''override'' 제어자는 유형 정의 멤버에만 허용됨
override.modifier.is.not.allowed=''override'' 제어자는 허용되지 않습니다
sealed.modifier.is.not.allowed.here=''sealed'' 제어자는 허용되지 않습니다
illegal.modifiers.combination=올바르지 않은 제어자 조합\: {0} 및 {1}
implicit.modifier.cannot.be.used.for.top.level.objects=''implicit'' 제어자는 최상위 객체에 사용할 수 없습니다
implicit.class.must.have.a.primary.constructor.with.one.argument=묵시적 클래스에는 첫 번째 매개변수 목록에 정확히 하나의 인수가 있는 기본 생성자가 있어야 합니다
implicit.modifier.can.be.used.only.for=''implicit'' 제어자는 값, 변수, 메서드, 클래스에만 사용할 수 있습니다
modifier.is.redundant.for.this.definition=''{0}'' 제어자는 이 정의에 불필요합니다
only.classes.can.be.open=클래스만 열 수 있습니다
class.is.abstract.it.cannot.be.instantiated=클래스 ''{0}''은(는) abstract이므로 인스턴스화할 수 없습니다
opaque.modifier.allowed.only.for.type.aliases=''opaque'' 제어자는 타입 별칭에만 허용됩니다
tree.mismatch.tooltip=<html><body>{0}<table><tr><td>필요\:</td>{1}</tr><tr><td>발견\:</td>{2}</tr></table></body></html>
add.collection.breakout.argument=`collection.breakOut` 인수 추가
family.name.add.collection.breakout=`collection.breakOut` 추가
add.return.type=반환 유형 추가
family.name.change.type=유형 변경
change.type.to=유형 ''{0}'' 을(를) ''{1}'' (으)로 변경
convert.to.explicit.symbol=심볼("{0}")로 변환
convert.to.explicit.symbol.family=명시적 심볼로 변환
family.name.enable.type.mismatch.hints=유형 불일치 힌트 활성화
implement.members.fix=멤버 구현
make.non.private.title=프로퍼티를 비공개가 아닌것으로 만들기
add.modifier.fix.without.name=''{0}'' 제어자를 추가합니다
remove.named.modifier.fix=''{0}'' 제어자를 제거합니다
make.protected.fix=프로퍼티를 protected로 만들기
make.public.fix=프로퍼티를 공개로 만들기
numeric.literal.family=숫자 리터럴
convert.to.hex.fix=8진 리터럴을 16진수로 변환
convert.to.long.fix=long 리터럴로 변환
lowercase.long.marker.fix=long 리터널 마커를 대문자로 변환
pull.method.to=다음으로 메서드 ''{0}'' 끌어오기...
pull.value.to=다음으로 값 ''{0}'' 끌어오기...
pull.variable.to=다음으로 변수 ''{0}'' 끌어오기...
report.highlighting.error.fix=강조 표시 오류 보고...
wrap.in.option.name=옵션 줄 바꿈
wrap.in.option.hint=Option(...) 내 표현식을 줄 바꿈하시겠어요?
family.name.add.empty.parentheses=빈 소괄호 추가
family.name.convert.to.object=객체로 변환
case.classes.without.parameter.list.not.allowed=매개변수 목록이 없는 케이스 클래스가 허용되지 않습니다
case.classes.without.parameter.list.deprecated=매개변수 목록이 없는 케이스 클래스는 더 이상 사용되지 않습니다
no.implicit.arguments.of.type=유형의 묵시적 인수가 없습니다. {0}
annotator.error.bean.property.should.not.be.private=Bean 프로퍼티가 비공개면 안 됩니다.
traits.cannot.have.type.parameters.with.context.bounds=특성은 컨텍스트 바운드가 있는 유형 매개변수를 가질 수 없습니다
traits.cannot.have.type.parameters.with.view.bounds=특성은 뷰 바운드가 있는 유형 매개변수를 가질 수 없습니다
import.extension.method=확장 메서드 가져오기...
import.with=가져오기 ''{0}''
import.implicit.conversion=변환 가져오기...
import.implicit=묵시적 항목 가져오기...
import.class.chooser.title=가져올 클래스
import.package.chooser.title=가져올 패키지
import.something.chooser.title=가져올 이륾
import.conversion.chooser.title=가져올 변환
import.implicit.chooser.title=가져올 묵시적 항목
import.extension.method.chooser.title=가져올 확장 메서드
add.import.action=import 액션 추가
exclude.value.from.auto.import=자동 가져오기에서 ''{0}''을(를) 제외합니다.
import.hint.text={0}? Alt+Enter {1}
import.multiple.choices=(다중 선택...)
import.global.member=전역 멤버 가져오기
import.as=''{0}''로서 가져오기
import.with.prefix.ellipsis=접두사 포함 가져오기...
import.with.prefix=접두사 포함 가져오기
import.something=가져오기...
import.class=클래스 가져오기
import.package=패키지 가져오기
family.name.add.braces=중괄호 추가
add.braces.around.single.line.expression=단일 줄 표현식 주위에 중괄호 추가
create.companion.object.for.class=클래스에 대한 컴패니언 객체 생성
family.name.create.companion.object=컴패니언 객체 생성
family.name.remove.braces=중괄호를 제거합니다.
family.name.comparing.length=길이 비교 중
family.name.filter.set.contains=Set Contains 필터링
family.name.some.to.option=Some을 Option으로
family.name.convert.to.curly.braces=중괄호로 변환
intention.for.comprehension.convert.to.parentheses=소괄호로 변환
desugar.for.comprehension=for 내포 디슈가링
family.name.convert.to.desugared.expression=디슈가링된 표현식으로 변환
family.name.convert.from.infix.expression=infix 표현식 변환
family.name.convert.parameter.to.underscore.section=매개변수를 밑줄 섹션으로 변환
family.name.convert.to.infix.expression=infix 표현식으로 변환
family.name.convert.underscore.section.to.parameter=밑줄 섹션을 매개변수로 변환
family.name.make.implicit.conversion.explicit=묵시적 변환을 명시적으로 만들기
family.name.remove.unnecessary.apply=불필요한 적용 제거
remove.unnecessary.parentheses=불필요한 소괄호를 제거합니다.
family.name.replace.type.check.with.pattern.matching=유형 검사를 패턴 매칭으로 바꾸기
family.name.import.additional.identifiers=추가 식별자 가져오기
import.additional.identifiers.from.qualifier=한정자에서 추가 식별자 가져오기
family.name.import.all.members=모든 멤버 가져오기
import.all.members.of.reference={0} 의 모든 멤버 가졍오기
family.name.import.member.with.stable.path=안정적 경로로 멤버 가져오기
import.stable.member={0} 가져오기
intention.family.put.on.one.line={0}을(를) 하나의 줄에 배치
intention.family.put.on.separate.lines={0}을(를) 별도의 줄에 배치
convert.to.typed.pattern=유형이 지정된 패턴으로 변환
family.name.expand.to.constructor.pattern=생성자 패턴으로 확장
expand.to.new.pattern=다음으로 확장자\: {0}
intention.add.explicit.unit.type.annotation=묵시적 Unit 유형 어노테이션 추가
intention.type.annotation.function.add.text=함수 정의에 유형 어노테이션 추가
family.name.adjust.types=유형 조정
family.name.use.prefix.type.syntax=접두사 유형 구문 사용
family.name.convert.implicit.bounds=묵시적 바운드 변환
convert.view.and.context.bounds.to.implicit.parameters=뷰 및 컨텍스트 바운드를 묵시적 매개변수로 변환
convert.java.to.scala.collection.hint=asScala를 사용하여 Scala 컬렉션으로 변환하시겠어요?
convert.java.to.scala.collection.name=Scala 컬렉션으로 변환
convert.scala.to.java.collection.hint=asJava를 사용하여 Java 컬렉션으로 변환하시겠어요?
convert.scala.to.java.collection.name=Java 컬렉션으로 변환
family.name.use.infix.type.syntax=Infix 유형 구문 사용
make.type.more.specific.fun=반환 유형을 더 구체적으로 만들기
make.type.more.specific=선언된 유형을 더 구체적으로 만들기
intention.type.annotation.regen.family=유형 어노테이션 다시 생성
intention.type.annotation.function.regenerate.text=함수 정의에 대한 유형 어노테이션 다시 생성
intention.type.annotation.value.regenerate.text=값 정의에 대한 유형 어노테이션 다시 생성
intention.type.annotation.variable.regenerate.text=변수 정의에 대한 유형 어노테이션 다시 생성
intention.type.annotation.toggle.family=유형 어노테이션 전환
intention.type.annotation.function.remove.text=함수 정의에서 유형 어노테이션 제거
intention.type.annotation.value.add.text=값 정의에 유형 어노테이션 추가
intention.type.annotation.value.remove.text=값 정의에서 유형 어노테이션 제거
intention.type.annotation.variable.add.text=변수 정의에 유형 어노테이션 추가
intention.type.annotation.variable.remove.text=변수 정의에서 유형 어노테이션 제거
intention.type.annotation.pattern.add.text=패턴 정의에 유형 어노테이션 추가
intention.type.annotation.pattern.remove.text=패턴 정의에서 유형 어노테이션 제거
intention.type.annotation.parameter.add.text=매개변수에 유형 어노테이션 추가
intention.type.annotation.parameter.remove.text=매개변수에서 유형 어노테이션 제거
intention.type.annotation.underscore.add.text=밑줄 매개변수에 유형 어노테이션 추가
intention.type.annotation.underscore.remove.text=밑줄 매개변수에서 유형 어노테이션 제거
remove.case.clause=case 절 제거
remove.finally=finally 블록 제거
remove.catch=catch 블록 제거
unwrap.interpolated.string.injection=보간된 문자열 삽입 줄 바꿈 해제
unwrap.case.clause=case 절 줄 바꿈 해제
unwrap.finally=finally 줄 바꿈 해제
unwrap.try.with.finally=try/finally 줄 바꿈 해제
val.on.case.class.param.redundant=케이스 클래스 기본 생성자의 매개변수와 ''val'' 제어자가 중복됩니다
remove.val=''val'' 제거
specify.type.of.exception=예외 유형 지정
suspicious.forward.reference.template.body=클래스 내 의심스러운 전방 참조
remove.braces.from.import=import 문의 중괄호 제거
remove.return.keyword=반환 키워드 제거
make.import.fully.qualified=import 문 정규화하기
delete.inlined.tag=인라인화된 태그 삭제
replace.with.wiki.syntax=인라인화된 태그를 고정폭 wiki 구문으로 바꾸기
remove.generic={0} 제거
move.text.after.header.to.new.line=헤더 닫기 뒤 텍스트를 새 줄로 이동
balance.header=밸런스 헤더
replace.tag.with.esc.seq=태그를 이스케이프 시퀀스로 바꾸기
delete.unknown.tag=알 수 없는 태그 삭제
replace.tuple.type=TupleN[A1, A1,...,  AN]를 (A1, A1,...,  AN)로 바꾸기
replace.fun.type=FunctionN[A1, A1,...,  AN, R]을 (A1, A1,...,  AN) \=> R로 바꾸기
new.on.case.class.instantiation.redundant=''new'' 제어자 제거
xml.no.opening.tag=여는 태그 없음
xml.no.closing.tag=닫는 태그 없음
xml.delete.unmatched.tag=일치하지 않는 태그 삭제
xml.rename.opening.tag=여는 태그 이름 변경
xml.rename.closing.tag=닫는 태그 이름 변경
incompatible.plugin.detected=호환되지 않는 플러그인 탐지됨
scala.3.support.is.experimental=Scala 3 지원은 개발 중입니다.<br>야간 빌드를 사용해 보세요. <a href\=''{0}''>자세히 알아보기</a>
configure.updates=업데이트 구성...
idea.is.outdated.please.update=IDEA가 Scala 플러그인 {0} 브랜치와 함께 사용할 수 있는 오래된 버전입니다.<br/>최신 Scala 플러그인을 사용하려면 IDEA를 {1} 이상으로 업데이트하세요.
please.select.scala.plugin.update.channel=Scala 플러그인 업데이트 채널을 선택해주세요.
channel.stable.releases=안정화된 릴리스
channel.early.access.program=얼리 액세스
channel.nightly.builds=야간 빌드
scala.plugin.update=Scala 플러그인 업데이트
type.aware.highlighting.title=Scala 유형 인식 강조 표시
click.or.press.shortcut.to.change=(변경하려면 {0} 을(를) 클릭하거나 누르세요)
click.to.change=(클릭하여 변경)
enabled.word=Habilitado
disabled.word=deshabilitado
scala.type.aware.highlighting.indicator=Scala 유형 인식 강조 표시 표시기
downloading.url=Descargando {0}
title.searching.for.library.extensions=라이브러리 확장 검색
select.library.from.the.list.above=위 목록에서 라이브러리 선택
idea.will.try.to.search.for.extra.support.for.particular.libraries=IDEA가 프로젝트의 특정 라이브러리에 대한 추가 지원 검색을 시도합니다
title.failed.to.load.extension.jar=확장 JAR 로드 실패
no.known.extension.libraries=알려진 확장 라이브러리 없음
known.extension.libraries=알려진 확장 라이브러리
extensions.in.selected.library=선택한 라이브러리 내 확장
enable.loading.external.extensions=외부 확장 로드 활성화
how.to.add.custom.macro.support.help.link.title=사용자 지정 Scala 매크로 지원을 추가하는 방법
title.extensions.available=사용 가능한 확장
additional.support.has.been.found.popup=<p>일부 라이브러리에 대한 추가 지원을 찾았습니다.</p><p>활성화하시겠어요? <a href\="Yes">네</a>/<a href\="No">아니요</a></p>
scala.language.console.placeholder.command.to.execute=실행할 <{0}>
scala.console.actions.scala.repl=Scala REPL
scalarepl.menu.action.text=Scala REPL...
scalarepl.menu.action.description=Scala REPL 실행
clean.scala.repl.content.menu.action.text=Scala REPL 내용 삭제
clean.scala.repl.content.menu.action.description=Scala REPL 내용 삭제
execute.scala.repl.statement.menu.action.text=Scala REPL 구문 실행
execute.scala.repl.statement.menu.action.description=Scala REPL 구문 실행
scalaconsole.new.line.in.repl=REPL 내 새 줄
send.selection.to.scala.repl.menu.action.text=Scala REPL에 선택 항목 전송
send.selection.to.scala.repl.menu.action.description=Scala REPL에 선택 항목 전송
scala.console.config.display.name=Scala REPL
scala.console.config.scala.repl.run.configurations=Scala REPL 실행 구성
scala.console.config.module.is.not.specified=Módulo no especificado
scala.console.config.working.directory=작업 디렉터리\:
scala.console.config.use.classpath.and.sdk.of.module=클래스 경로 및 모듈 SDK 사용\:
scala.console.config.vm.options=VM 옵션
scala.console.config.console.arguments=콘솔 인수
scala.console.config.test.run.config.choose.working.directory=작업 디렉터리 선택
scala.console.configure.scala.sdk.classpath=Scala SDK 클래스 경로 구성(&C)
subsystem.requires.jline={0} 을(를) 실행하려면 {1} 이(가) 필요합니다\n\
options.scala.display.name=Scala
auto.import.show.import.popup.for=import 문 팝업 표시\:
auto.import.add.unambiguous.imports.on.the.fly.for=다음에서 모호하지 않은 import 문 즉시 추가\:
auto.import.optimize.imports.on.the.fly=import 문 즉시 최적화
auto.import.show.popup.classes=클래스
auto.import.show.popup.methods=static 멤버
auto.import.show.popup.conversions=묵시적 변환
auto.import.show.popup.implicits=묵시적 정의
auto.import.show.popup.extension.methods=확장 메서드
auto.import.find.more.configuration.options=<a>코드 스타일</a>에서 더 많은 구성 옵션 찾아보기
bytecode.indices.target.sam.type=SAM 유형
bytecode.indices.target.unapply.method=apply/unapply 메서드
bytecode.indices.target.for.comprehension.method=for-comprehension 메서드
bytecode.indices.target.implicit.definition=묵시적 정의
find.usages.member.has.supers=멤버 {0} 이(가) 일부 기본 멤버를 재정의/구현합니다.\n\
title.warning=경고
find.what.members.usages.checkbox=멤버 사용 위치(&M)
find.what.implementing.type.definitions.checkbox=유형 정의 구현 중(&D)
find.what.companion.module.checkbox=컴패니언 모듈 사용 위치(&C)
find.what.new.instances.usages=인스턴스 생성 전용(&I)
scala.mutable.collection=가변 컬렉션
scala.immutable.collection=불변 컬렉션
java.collection=Java 컬렉션
wrong.top.statement.declaration=잘못된 상단 구문 선언
to.import.method.statically.press.hotkey=메서드를 정적으로 가져오려면 {0}(을)를 누릅니다.
action.import.member=멤버 가져오기
method.of.containingclass={1} 중 {0}
descriptive.name.anonymous=익명
usage.extractor=추출기
usage.typed.pattern=유형이 지정된 패턴
usage.typed.statement=유형이 지정된 구문
usage.method.apply=메서드 `apply`
usage.this.reference=이 참조
usage.access.modifier=접근 제어자
usage.package.clause=패키지 절
usage.function.expression=함수 표현식
usage.named.parameter=명명된 매개변수
usage.interpolated.string.prefix=보간된 문자열 접두사
usage.parameter.in.pattern=패턴 내 매개변수
usage.self.type=자체 유형
usage.type.bound=유형 바운드
usage.type.alias=유형 별칭
usage.secondary.constructor=보조 생성자
usage.implicit.conversion.parameter=묵시적 변환/매개변수
usage.unresolved.implicit.conversion.parameter=해결되지 않은 묵시적 변환/매개변수
usage.sam.interface.implementation=SAM 인터페이스 구현
scalafmt.suggester.detected.in.project=이 프로젝트에서 Scalafmt 구성이 탐지됨
scalafmt.suggester.enable=활성화
scalafmt.suggester.dont.show=표시 안 함
scalafmt.picked.new.config=Scalafmt에 새 스타일 설정(v{0})이 적용되었습니다
scalafmt.can.not.find.config.file=구성 파일을 찾을 수 없습니다. {0}
scalafmt.can.not.find.config.file.go.to.settings=설정...
scalafmt.can.not.find.config.file.create.new=새 파일을 생성합니다.
scalafmt.can.not.create.config.file=구성 파일을 생성할 수 없습니다
scalafmt.config.load.errors.failed.to.load.config=Scalafmt 구성 로드 실패
scalafmt.config.load.errors.parse.error=파싱 오류\: {0}
scalafmt.config.load.errors.cyclic.includes.detected=순환 include가 탐지되었습니다
scalafmt.config.load.actions.open.config.file=구성 파일 열기
scalafmt.download=Descargar
scalafmt.resolve.again=다시 해결
scalafmt.progress.resolving.scalafmt.version=Scalafmt 버전 {0} 해결 중
scalafmt.progress.downloading.scalafmt.version=Scalafmt 버전 {0} 다운로드 중
scalafmt.progress.resolving.scalafmt.version.cancel=해결 중지
scalafmt.progress.downloading.scalafmt.version.cancel=Descarga detenida
scalafmt.progress.version.was.downloaded=Scalafmt 버전 {0} 이(가) 다운로드되었습니다
scalafmt.resolve.errors.cant.resolve.scalafmt.version=Scalafmt 버전 {0} 을(를) 해결할 수 없음
scalafmt.resolve.errors.version.is.not.downloaded.yet=Scalafmt 버전 `{0}` 이(가) 다운로드되지 않았습니다.<br>다운로드 하시겠어요?
scalafmt.resolve.errors.download.is.in.progress=다운로드가 진행 중입니다
scalafmt.resolve.errors.downloading.error.occurred=Error al descargar
scalafmt.resolve.errors.classpath.is.corrupted=클래스 경로가 손상되었습니다
scalafmt.resolve.errors.unknown.error=알 수 없는 오류
scalafmt.format.errors.scala.file.parse.error=Scalafmt 파싱 오류 ({0})\:<br>{1}
scalafmt.format.errors.failed.to.find.correct.surrounding.code=Scalafmt 오류 ({0})\:<br> scalafmt에 전달할 올바른 둘러싸는 코드 찾기 실패, 서식 지정이 수행되지 않습니다
codegeneration.panel.title=코드 생성
imports.panel.class.count.to.use.import.with=''_''로 import를 사용하는 클래스 수\:
imports.panel.add.import.statement.in.closest.block=가장 가까운 블록에 import 문 추가
imports.panel.add.fully.qualified.imports=정규화된 import 문 추가
imports.panel.do.not.change.path.during.optimize.imports.for.local.imports=로컬 가져오기 import 문 최적화 도중 경로 변경 안 함
imports.panel.sort.imports.for.optimize.imports=import 문 정렬(import 문 최적화)\:
imports.panel.lexicographically=사전순
imports.panel.scalastyle.consistent=scalastyle 일치
imports.panel.force.scala2.in.source3=-Xsource\:3\:를 사용할 때 구문 가져오기
imports.panel.merge.imports.with.the.same.prefix.into.one.statement=동일한 접두사를 가진 import 문을 한 구문으로 병합
imports.panel.use.the.shortest.path.when.trying.to.import.reference.with.already.imported.name=이미 가져온 이름을 가진 참조 가져오기 시도 시 최단 경로 사용
imports.panel.classes.to.use.only.with.prefix=접두사만 포함하는 사용할 클래스
imports.panel.import.layout=Obtener diseño
imports.panel.imports.always.marked.as.used=항상 사용됨으로 표시된 import 문
except.for.base.package=기본 패키지 제외
imports.panel.title=가져오기
imports.panel.add.pattern.to.use.appropriate.classes.only.with.prefix=Agregue un patrón que use clases que contengan solo el prefijo
imports.panel.use.references.with.prefix=접두사를 포함하는 참조 사용\:
imports.panel.no.imports.with.prefix=접두사를 포함하는 import 문 없음
imports.panel.add.package.name=패키지 이름 추가
imports.panel.import.layout.manager=가져오기 레이아웃 관리자
imports.panel.add.import.to.always.mark.it.as.used=항상 사용됨으로 표시할 import 문 추가
imports.panel.always.mark.as.used=항상 사용됨으로 표시
imports.panel.honestly.mark.imports.as.unused=import 문을 사용 안 됨으로 솔직하게 표시
imports.panel.base.package.help=기본 패키지가 <code>org.example.application</code>인 경우, 클래스 <code>org.example.application.NAME</code>은 <code>import NAME</code>으로 가져와야 합니다
multi.line.string.panel.opening.quotes.on.new.line=새 줄에 여는 따옴표 배치(&O)
multi.line.string.panel.place.closing.quotes.on.new.line.on.enter.press=Enter 입력 시 새 줄에 닫는 따옴표 배치(&C)
multi.line.string.panel.align.dangling.closing.quotes=허상 닫는 따옴표 할당(&A)
multi.line.string.panel.insert.margin.char.on.enter=Enter 입력 시 새 줄에 여백 문자 삽입(&I)
multi.line.string.panel.process.margin.on.copy.paste=복사/붙여넣기 시 여백 제거/삽입(&S)
multi.line.string.panel.margin.char.value=여백 문자\:
multi.line.string.panel.margin.char.indent=여백 문자 들여쓰기\:
multi.line.string.panel.title=다중 줄 문자열
other.panel.enforce.functional.syntax.for.methods.with.unit.return.type=Unit 반환 유형을 가진 메서드에 대한 함수 구문 강제 실행
other.panel.reformat.on.compile=컴파일 시 서식 다시 지정
other.panel.replace.with.unicode.symbol=''\=>''를 유니코드 심볼로 바꾸기
other.panel.replace.with.unicode.symbol1=''->''를 유니코드 심볼로 바꾸기
other.panel.replace.in.for.generator.with.unicode.symbol=\"for\" 생성기의 ''<-''를 유니코드 심볼로 바꾸기
other.panel.kind.projector.replace.lambda.with.unicode.symbol=Kind Projector\: ''Lambda''를 유니코드 심볼로 바꾸기
other.panel.alternate.indentation.for.constructor.args.and.parameter.declarations=생성자 인수 및 매개변수 선언에 대한 대체 들여쓰기\:
other.panel.spaces=공백
other.panel.implicit.value.class.prefix.suffix=묵시적 값 클래스 접두사/접미사
other.panel.title=Otros
scala3.panel.use.indentation.based.syntax=들여쓰기 기반 구문 사용
scala3.panel.title=Scala 3
wrapping.and.braces.panel.extends.do.not.align=정렬하지 않음
wrapping.and.braces.panel.extends.on.first.token=첫 번째 토큰
wrapping.and.braces.panel.extends.align.to.extends=''extends''에 할당
scaladoc.panel.title=ScalaDoc
scaladoc.panel.enable.scaladoc.formatting=scaladoc 서식 지정 활성화
scaladoc.panel.add.additional.space.for.leading.asterisk=선행 별표에 추가 공백 추가
scaladoc.panel.groups.blank.lines=빈 줄
scaladoc.panel.groups.alignment=맞추기
scaladoc.panel.groups.other=Otros
scalafmt.default=디폴트
scalafmt.default.path=Valor por defecto\: {0}
scalafmt.settings.panel.show.warnings.when.formatting.invalid.code=유효하지 않은 코드 서식 지정 시도 시 경고 표시
scalafmt.settings.panel.use.intellij.formatter.for.code.range.formatting=코드 범위 서식 지정을 위해 IntelliJ 서식 지정 도구 사용
scalafmt.settings.panel.use.intellij.formatter.for.code.range.formatting.warning.tooltip=코드 범위 서식 지정을 위해 Scalafmt을 사용하면 코드 불일치가 발생할 수 있습니다.<br>Scalafmt은 Scala 코드를 포함하는 전체 파일 서식 지정을 위해서만 사용해야 합니다.
scalafmt.settings.panel.reformat.on.file.save=파일 저장 시 서식 다시 지정
scalafmt.settings.panel.reformat.on.file.save.tooltip=힌트\: ''코드 서식 다시 지정''을 사용({0})
scalafmt.settings.panel.fallback.to.default.settings=디폴트 IntelliJ 설정으로 되돌리기
scalafmt.settings.panel.configuration.label=구성
scalafmt.settings.panel.scalafmt.version.label=Scalafmt 버전
scalafmt.settings.panel.select.custom.scalafmt.configuration.file=사용자 지정 Scalafmt 구성 파일 선택
scalafmt.settings.panel.no.config.found.under.path.using.default=지정된 경로에서 구성 파일을 찾을 수 없습니다
scalafmt.settings.panel.errors.cant.resolve.version=Scalafmt 버전 {0} 을(를) 해결할 수 없음
scalafmt.settings.panel.errors.failed.to.parse.config=파싱 설정 실패\:<br> {0}
scalafmt.settings.panel.errors.cant.find.config.file=다음 경로를 가진 Scalafmt 구성 파일을 찾을 수 없습니다.<br> {0}
spaces.panel.simple.one.line.block.braces=단순한 한 줄 블록 중괄호
spaces.panel.import.braces=중괄호 가져오기
spaces.panel.self.type.braces=자체 유형 중괄호
spaces.panel.before.context.bound.colon.rest=컴텍스트 바운드 콜론 앞 (rest)
spaces.panel.before.context.bound.colon.leading.higher.kinded=컨텍스트 바운드 콜론 앞 (선행 상류)
spaces.panel.before.context.bound.colon.leading=컨텍스트 바운드 콜론 앞 (선행)
spaces.panel.before.opening.square.bracket=여는 대괄호 앞
spaces.panel.keep.one.line.comments.on.same.line=같은 줄에 한 줄 주석 유지
spaces.panel.newline.after.annotations=어노테이션 뒤 새 줄
spaces.panel.around.at.in.pattern.bindings=패턴 바인팅 내 ''@'' 주위
spaces.panel.inside.closure.braces=클로저 중괄호 내부
spaces.panel.before.colon.after.declarations.name=콜론 앞, 선언 이름 뒤
spaces.panel.after.colon.before.declarations.type=콜론 뒤, 선언 유형 앞
spaces.panel.method.call.left.brace=메서드 호출 왼쪽 중괄호
spaces.panel.preserve.space.before.method.parentheses=메서드 소괄호 앞 공백 유지
spaces.panel.infix.method.parentheses=inflix 메서드 소괄호
spaces.panel.infix.operator.like.method.call.parentheses=inflix 연산자식 메서드 호출 소괄호
spaces.panel.infix.method.call.parentheses=inflix 메서드 호출 소괄호
spaces.panel.constructor.parameters.with.modifiers=제어자를 가진 생성자 매개변수
wrapping.and.braces.panel.groups.method.definition=메서드 정의
wrapping.and.braces.panel.groups.anonymous.method.definition=익명 메서드 정의
wrapping.and.braces.panel.groups.class.definition=클래스 정의
wrapping.and.braces.panel.groups.xml.formatting=XML 서식 지정
wrapping.and.braces.panel.groups.tuple=튜플
wrapping.and.braces.panel.groups.type.arguments=유형 인수
wrapping.and.braces.panel.groups.type.parameters=유형 매개변수
wrapping.and.braces.panel.force.braces=중괄호 강제 적용
wrapping.and.braces.panel.force.try.braces=''try'' 중괄호 강제 적용
wrapping.and.braces.panel.force.case.branch.braces=''case'' 중괄호 강제 적용
wrapping.and.braces.panel.force.finally.braces=''finally'' 중괄호 강제 적용
wrapping.and.braces.panel.align.tuple.elements=튜플 요소 정렬
wrapping.and.braces.panel.do.not.indent.tuples.closing.parenthesis=튜플 닫는 소괄호 들여쓰기 안 함
wrapping.and.braces.panel.do.not.align.block.expression.parameters=블록 표현식 매개변수 정렬 안 함
wrapping.and.braces.panel.indent.braced.arguments=중괄호 안 인수 들여쓰기
wrapping.and.braces.panel.simple.one.line.lambdas.in.arg.list=인수 목록 내 간단한 한 줄 람다
wrapping.and.braces.panel.keep.xml.formatting=XML 서식 지정 유지
wrapping.and.braces.panel.place.self.type.on.new.line=새 줄에 자체 유형 배치
wrapping.and.braces.panel.align.multiline.pattern.alternatives=다중 줄 패턴 대체 할당
wrapping.and.braces.panel.align.in.columns.case.branches=''case'' 브랜치 열 정렬
wrapping.and.braces.panel.do.not.indent.case.clause.body=case 절 본문 들여쓰기 안 함
wrapping.and.braces.panel.match.statement=''match'' 문
wrapping.and.braces.panel.indent.first.parameter.clause.if.on.new.line=새 줄에서 첫 번째 매개변수 절 들여쓰기
wrapping.and.braces.panel.indent.first.parameter.if.on.new.line=새 줄에서 첫 번째 매개변수 들여쓰기
wrapping.and.braces.panel.align.parameter.types.in.multiline.declarations=다중 줄 선언 내 매개변수 유형 정렬
wrapping.and.braces.panel.use.normal.indent.for.parameters=매개변수 일반 들여쓰기 사용
wrapping.and.braces.panel.parameters.on.new.line=새 줄의 매개변수
wrapping.and.braces.panel.wrap.before.with.keyword=''with'' 키워드 앞 줄 바꿈
wrapping.and.braces.panel.align.if.else.statements=if-else 구문 정렬
wrapping.and.braces.panel.indent=Sangrar
wrapping.and.braces.panel.new.line.options.no.new.line=새 줄 없음
wrapping.and.braces.panel.new.line.options.new.line.always=항상 줄 바꿈
wrapping.and.braces.panel.new.line.options.new.line.for.multiple.arguments=다중 줄 인수 사용 시 줄 바꿈
wrapping.and.braces.panel.renamed.infix.expressions=inflix 표현식
wrapping.and.braces.panel.renamed.extends.with.list=extends/with 목록
wrapping.and.braces.panel.renamed.extends.keyword=키워드 확장
wrapping.and.braces.panel.renamed.force.yield.braces=yield 중괄호 강제 적용
wrapping.and.braces.panel.for.indent.yield.after.one.line.enumerators=한 줄 열거자 뒤 yield 들여쓰기
blank.lines.panel.around.method.in.inner.scopes=내부 범위 내 메서드 주위
blank.lines.panel.around.field.in.inner.scopes=내부 범위 내 필드 주위
blank.lines.panel.around.class.in.inner.scopes=내부 범위 내 클래스 주위
scaladoc.panel.align.parameter.descriptions=매개변수 설명 정렬
scaladoc.panel.align.throws.exception.descriptions=할당이 예외 설명을 던집니다
scaladoc.panel.align.return.value.description=반환 값 설명 정렬
scaladoc.panel.align.other.tags.descriptions=기타 태그 설명 정렬
scaladoc.panel.blank.lines.keep=유지(태그 사이의 빈 줄이 제거되지 않습니다)
scaladoc.panel.between.parameter.descriptions=매개변수 설명 사이
scaladoc.panel.before.parameter.descriptions=매개변수 설명 앞
scaladoc.panel.before.tags=태그 앞
scaladoc.panel.after.tags=반환 뒤
scaladoc.panel.after.parameter.comments=매개변수 설명 뒤
scaladoc.panel.preserve.spaces.in.tags=태그 공백 유지
align.list.items.content=목록 항목 내용 정렬
scala.root.code.style.panel.formatter=서식 지정 도구\:
trailing.comma.panel.title=후행 쉼표
trailing.comma.panel.keep=유지
trailing.comma.panel.remove.when.multiline=다중 줄 사용 시 제거
trailing.comma.panel.add.when.multiline=여러 줄일 경우 추가
trailing.comma.panel.scope.arguments.list=인수 목록
trailing.comma.panel.scope.parameters.list=매개변수 목록
trailing.comma.panel.scope.tuple=튜플
trailing.comma.panel.scope.tuple.type=튜플 유형
trailing.comma.panel.scope.pattern.arguments.list=패턴 인수 목록
trailing.comma.panel.scope.type.parameters.list=유형 매개변수 목록
trailing.comma.panel.scope.import.selector=가져오기 선택자
type.annotations.panel.use.for=사용 대상
type.annotations.panel.public.member=public 멤버
type.annotations.panel.protected.member=protected 멤버
type.annotations.panel.private.member=private 멤버
type.annotations.panel.local.definition=Definición local
type.annotations.panel.function.literal.parameter=함수 리터럴 매개변수
type.annotations.panel.underscore.parameter=밑줄 매개변수
type.annotations.panel.enforce.for=적용 대상
type.annotations.panel.implicit.definition=묵시적 정의
type.annotations.panel.unit.type=Unit 유형
type.annotations.panel.accidental.structural.type=예기치 않은 구조 유형*
type.annotations.panel.accidental.structural.type.tooltip=<html>값에 유형 어노테이션 강제 적용, 추론된 구조 유형을 가짐, 예\:<br>\n\
val foo \=Runnable {\n\
override def run()\: Unit \=()\n\
def helper()\: Unit \=()\n\
type.annotations.panel.except.when=다음과 같은 경우 예외
type.annotations.panel.member.of.anonymous.class=익명 클래스 멤버
type.annotations.panel.member.of.private.class=비공개 클래스 멤버
type.annotations.panel.member.of=다음의 멤버\:
type.annotations.panel.annotated.with=어노테이션 지정\:
type.annotations.panel.constant.final.val=상수 (final val)
type.annotations.panel.type.is.stable=유형이 안정적입니다*
type.annotations.panel.type.is.stable.tooltip=<html><body>오른쪽이\:<br> 리터럴\: <code>123</code>인 경우, <code>\"string\"</code> 등. (<code>null</code> 포함)<br> Unit 표현식\: <code>()</code><br> 객체 생성\: <code>new Foo(...)</code> (개선 코드 포함\: <code>new Foo() {}</code>)<br> Factory 메서드 호출\: <code>Foo(...)</code> (컴패니언 객체에서 <code>apply(...)</code> 호출)<br> 빈 컬렉션\: <code>Seq.empty[Int]</code>, <code>Map.empty[Int, String]</code>, etc.<br> Java 열거형 상수\: <code>Enum.VALUE</code><br> 예외\: <code>throw Exception()</code></body></html>
type.annotations.panel.type.matches=유형 일치\:
type.annotations.panel.in.test.sources=테스트 소스 내
type.annotations.panel.in.scala.dialect.sources=Scala 파생 언어 소스 내*
type.annotations.panel.in.scala.dialect.sources.tooltip=*.sbt, *.sc, etc.
type.annotations.panel.title=유형 어노테이션
type.annotations.panel.classes=클래스
type.annotations.panel.annotations=어노테이션
type.annotations.panel.type.patterns=유형 패턴
expand.macro=매크로 확장
wrong.pattern=잘못된 패턴
right.brace.expected=''}'' 이(가) 기대됩니다
bad.interpolated.string.injection=보간된 문자열 삽입이 잘못됨
wrong.string.literal=잘못된 문자열 리터럴
end.of.string.expected=문자열 끝 기대
package.qualID.expected=패키지 이름이 표시된 정규화된 식별자 기대
semi.expected='';'' 또는 새 줄 기대
out.of.compilation.unit=컴파일 장치를 범어남
lbrace.expected=''{'' 이(가) 필요합니다
unreachable.error=예기치 않은 오류 발견
rsqbracket.expected='']'' 가 필요합니다
identifier.expected=식별자 기대
parameter.expected=매개변수 필요
expected.at.least.one.extension.method=확장 메서드가 1개 이상 필요합니다
expected.new.line.after.colon=콜론 뒤에 새 줄이 필요합니다
extension.method.expected=확장 메서드가 필요합니다
identifier.or.opening.brace.expected=식별자 또는 여는 중괄호가 필요합니다
identifier.or.wild.sign.expected=식별자 또는 ''_'' 기대
rbrace.expected=''}'' 이(가) 필요합니다
import.selector.expected=import 선택자 기대
wrong.annotation.expression=잘못된 어노테이션 표현식
rparenthesis.expected='')'' 이(가) 필요합니다
wrong.expression=잘못된 표현식
annotation.or.type.expected=어노테이션 또는 유형 기대
wrong.type=잘못된 유형
wrong.binding=잘못된 매개변수
wrong.declaration.in.block=블록에 선언이 포함될 수 없습니다
missing.statement.for.annotation=어노테이션에 대한 구문 누락
choose.expected=생성기 구문 내 ''<-'' 기대
case.clauses.expected=case 절 기대
while.expected=''do'' 구문 내 while 키워드 기대
enumerators.expected=''for'' 문 내 열거자 기대
condition.expected=부울 조건 기대
expected.then=''then''이 필요합니다
expected.do=''do''가 필요합니다
expected.do.or.yield=''do'' 또는 ''yield''가 필요합니다
line.is.indented.too.far.to.the.left=줄이 너무 왼쪽으로 들여쓰기되어 있습니다
assign.expected=''\='' 예상
type.expected=유형이 필요합니다
fun.sign.expected=''\=>'' 예상
wrong.parameter=잘못된 매개변수
implicit.params.excepted=묵시적 매개변수 절은 최소 하나의 매개변수를 포함해야 합니다
using.parameter.clause.expected=''using'' 매개변수 절이 필요합니다
param.clause.expected=매개변수 절 기대
variance.annotation.not.allowed=변화 어노테이션이 허용되지 않습니다
context.bounds.not.allowed=컨텍스트 바운드가 허용되지 않습니다
view.bounds.not.allowed=뷰 바운드가 허용되지 않습니다
expected.more.types=더 많은 유형이 필요합니다
pattern.expected=패턴 기대
wrong.postfix.expression=잘못된 접미사 표현식
wrong.type.associativity=연관성이 잘못되었습니다. 모든 연산자가 동일한 연관성을 가져야 합니다
simple.pattern.expected=단순 패턴의 올바르지 않은 시작
wrong.constr.expression=잘못된 생성자 표현식
auxiliary.constructor.may.not.have.a.type.annotation=보조 생성자는 타입 어노테이션을 가질 수 없습니다
auxiliary.constructor.definition.expected=보조 생성자 정의가 필요합니다
expression.expected=표현식 기대
expected.another.pattern=다른 패턴 기대
wrong.val.declaration=잘못된 값 선언
wrong.var.declaration=잘못된 변수 선언
wrong.qual.identifier=정규화된 식별자가 잘못됨
wrong.case.modifier=케이스 제어자가 잘못되었습니다. 클래스 또는 객체로 사용하세요
colon.expected=''\:'' 예상
parameter.type.expected=매개변수 유형 기대
val.var.expected=val 또는 var 키워드 기대
def.dcl.expected=정의 또는 선언 기대
existential.block.expected=존재 절 기대
wrong.existential.declaration=잘못된 존재 선언입니다. 유형 또는 값 선언이어야 합니다
compound.type.expected=복합 유형 기대
match.type.cases.expected=Match 유형 case 절 기대
expected.case.on.a.new.line=새 줄에 case가 필요합니다
type.lambda.expected=''\=>>'' 예상
identifier.expected.comma.found=식별자가 기대되나 '',''이 발견됨
dot.expected=''.'' 예상
dot.or.cq.expected=''.'' 또는 클래스 한정자가 필요합니다
xml.attribute.end.expected=XML 속성 값 끝 구분자 기대
xml.eq.expected=''\='' 예상
xml.attribute.value.expected=속성 값이 필요합니다
xml.cdata.end.expected=XML CData 끝 기대
xml.tag.end.expected=XML 태그 끝 기대
xml.name.expected=XML 태그 이름 기대
xml.end.tag.expected=XML 끝 태그(''</'' name ''>'') 기대
xml.PI.end.expected=XML 처리 지침 끝 기대
xml.scala.injection.end.expected=XML 내 Scala 삽입 끝(''}'') 기대
xml.scala.expression.expected=XML의 삽입에 Scala 표현식이 필요합니다
xml.comment.end.expected=XML 주석 끝(''-->'') 기대
xml.wrong.character=XML 주석 내 잘못된 문자열
xml.scala.patterns.expected=XML의 삽입에 Scala 패턴이 필요합니다
recursive.type.of.type.element=유형 요소의 재귀 유형
cannot.desugarize.typename={0} 을(를) 디슈가링할 수 없습니다
cannot.find.partialfunction.class=PartialFunction 클래스를 찾을 수 없음
cannot.find.throwable.class=Throwable 클래스를 찾을 수 없음
cannot.infer.type.without.expected.type=기대 유형이 없는 유형을 추론할 수 없음
cannot.infer.type.without.function.expected.type=scala.FunctionN 또는 scala.PartialFunction의 기대 유형이 없는 유형을 추론할 수 없음
no.type.inferred=표현식 ''{0}'' 의 유형을 추론할 수 없음
no.alias.type=별칭 유형 없음
file.type.scala.outlines=Scala 아웃라인
could.not.decompile.file.comment=//{0} 을(를) 디컴파일할 수 없음
can.t.resolve.type=유형을 해결할 수 없음
java.constructors.only.have.one.parameter.section=Java 생성자가 단 하나의 매개변수 섹션을 포함합니다
has.no.reference=참조 없음
cannot.find.method.of.stringcontext=StringContext의 메서드 {0}을(를) 찾을 수 없습니다
wrong.psi.for.literal.type=리터럴 유형을 얻는 요소가 잘못됨
cannot.resolve.unknown.symbol=심볼을 해결할 수 없음
cannot.define.expected.type=기대 유형을 정의할 수 없음
no.expected.type.for.wildcard.naming=와일드카드 이름 지정을 위한 기대 유형 없음
no.type.element.for.typed.pattern=타입 패턴에 대한 타입 요소가 없습니다
no.type.pattern=유형 패턴 없음
cannot.determine.expected.type=기대 유형을 확인할 수 없음
dependent.function.types.are.not.yet.supported=종속 함수 유형은 아직 지원되지 않습니다
cannot.find.template.for.this.reference=이 참조의 템플릿을 찾을 수 없음
cannot.find.enclosing.container=해당 컨테이너를 찾을 수 없음
cannot.resolve.ref=참조를 해결할 수 없음
unknown.macro.in.type.position=유형 조건 내 알 수 없는 매크로
recursive.non.value.type.of.type.element=유형 요소의 값이 아닌 재귀 유형
cannot.resolve.reference=참조를 해결할 수 없음
suitable.method.not.found=적합한 메서드를 찾을 수 없음
cannot.create.expression=표현식을 생성할 수 없음
not.a.polymorphic.lambda=polymorphic 람다가 아님
nothing.to.type=유형 지정할 항목 없음
empty.new.expression=빈 새로운 표현식
no.expression.in.parentheses=소괄호 안에 표현식이 없습니다
no.declared.type.found=정의된 유형을 찾을 수 없음
case.class.has.no.primary.constructor=케이스 클래스에 기본 생성자가 없습니다
cannot.resolve.expression=표현식을 해결할 수 없음
not.enough.parameter.sections=매개변수 섹션이 충분하지 않습니다
cannot.shape.resolve.self.invocation=자체 호출을 해결할 수 없습니다
cannot.infer.type.of.super.expression=`super'' 표현식의 유형을 추론할 수 없음
cannot.infer.type=유형을 추론할 수 없음
no.clazz.type.found=클래스 유형을 찾을 수 없습니다
typed.statement.is.not.complete.for.underscore.section=유형이 지정된 구문이 밑줄 섹션에 대해 완전하지 않습니다
failed.to.found.corresponding.underscore.section=해당하는 밑줄 섹션을 찾을 수 없습니다
could.not.infer.type.of.underscore.section=밑줄 섹션 유형을 추론할 수 없음
no.type.inferred.for.unknown.expression=표현식 유형을 추론할 수 없음
not.found.scala.xml.node=scala.xml.Node를 찾을 수 없습니다
both.stub.and.name.identifier.node.are.null={0} 의 스텁 및 이름 식별자 노드 모두 비어 있습니다\n\
no.defined.return.type=정의된 반환 유형 없음
no.type.element.found=''{0}'' 에서 유형 요소를 찾을 수 없음
cannot.infer.type.without.an.expression=표현식 없이 유형을 추론할 수 없음
wrong.stub.problem=잘못된 스텁 문제
wrong.type.element=잘못된 유형 요소
derives.type.has.no.type.parameters={0}은(는) 타입 매개변수가 없으므로 파생될 수 없습니다
derives.type.has.no.companion.object={0}은(는) 컴패니언 객체가 없으므로 파생될 수 없습니다
derives.cannot.be.unified={0}은(는) {1}의 타입 인수와 통합될 수 없습니다
derives.not.a.class.type={0}은(는) 클래스 타입이 아니므로 파생될 수 없습니다
derives.scala.class.expected=Scala class/trait가 필요합니다
derives.no.member.named.derived=파생된 값이 객체 {0}의 멤버가 아닙니다
cannot.resolve.parent.class=상위 클래스를 해결할 수 없음
no.containing.file=해당 파일 없음
assignment.missing.right.side=대입 오른쪽 누락
cannot.handle.compatibility.for={0} 에 대한 호환성을 처리할 수 없음
variance.contravariant=반공변성
variance.covariant=공변성
variance.invariant=무공변성
variance.bivariant=이변적
no.element.found=요소를 찾을 수 없음
rearranger.panel.keep.scala.style.getters.and.setters.together=cala-style getter 및 setter 함께 유지
rearranger.panel.keep.java.style.getters.and.setters.together=java-style getter 및 setter 함께 유지
rearranger.panel.split.into.unarrangeable.blocks.by.expressions=표현식을 통해 정렬할 수 없는 블록으로 분할
rearranger.panel.split.into.unarrangeable.blocks.by.implicits=implicit으로 정렬할 수 없는 블록으로 분할
processing.imports.modified.during.refactoring=리팩터링 중에 수정된 가져온 항목 처리 중
by.name.parameters.cannot.be.used=이 메서드는 Java 재정의자를 포함하므로, 값 클래스의 by-name 매개변수를 사용할 수 없습니다.
method.is.overridden.by.class.parameter.of.class=메서드가 {0} 의 클래스 매개변수에 의해 재정의되었습니다. 이를 함수 정의로 변환하는 것은 지원되지 않습니다.
updating.of.usages.of.generated.unapply=생성된 `unapply` 메서드 사용 위치 업데이트는 지원되지 않습니다
method.is.overridden.in.a.composite.pattern.definition=메서드가 {0}의 복합 패턴 정의에서 재정의되었습니다. 이를 함수 정의로 변환하는 것은 지원되지 않습니다.
method.is.overridden.in.a.composite.variable.definition=메서드가 {0}의 복합 변수 정의에서 재정의되었습니다. 이를 함수 정의로 변환하는 것은 지원되지 않습니다.
default.values=Valor por defecto\:
add.to.definition=정의에 추가
modify.method.calls=메서드 호출 수정
change.signature.vararg.should.be.last.in.clause=Vararg 매개변수가 매개변수 절의 마지막에 위치해야 합니다
change.signature.parameters.same.name.{0}=매개변수의 이름이 동일합니다\: {0}
change.signature.add.parameter.clause=매개변수 절 추가
change.signature.remove.parameter.clause=매개변수 절 제거
default.value.is.missing.default.arguments=디폴트 값이 없습니다. 디폴트 인수에 새로운 매개변수 값 대신 공백이 포함됩니다.
default.value.is.missing.method.calls=디폴트 값이 없습니다. 메서드 호출에 새로운 매개변수 값 대신 공백이 포함됩니다.
specify.result.type=결과 유형 지정
default.ta.settings=설정
error.wrong.caret.position.method.name=캐럿이 리팩터링할 메서드 이름에 위치해야 합니다.
change.signature.not.supported.implicit.functions=시그니처 변경은 묵시적 함수에서 지원되지 않습니다
change.signature.not.supported.implicit.parameters=시그니처 변경은 묵시적 매개변수를 가진 함수에서 지원되지 않습니다
change.signature.not.supported.extractors=시그니처 변경은 추출기에서 지원되지 않습니다
change.signature.specify.type.for.parameter=매개변수 ''{0}'' 유형 지정
parameter.could.not.be.repeated.and.by.name=매개변수가 by-name이면서 반복될 수 없습니다
could.not.understand.type=유형 {0} 을(를) 이해할 수 없음
extract.method.title=메서드 추출
default.ta.tooltip=유형 어노테이션 설정 구성
cannot.extract.used.function.definition=리팩터링이 지원되지 않습니다\: 선택 영역 내 함수 정의가 선택한 조각 외부에서 사용됩니다
extract.method.cannot.find.possible.scope=추출한 메서드의 가능한 범위를 찾을 수 없음
extract.local.method={0} 내 로컬 메서드 추출
extract.method.to.object.name=객체 {0} (으)로 메서드 추출
extract.method.to.class.name=클래스 {0} (으)로 메서드 추출
extract.method.to.trait.name=특성 {0} (으)로 메서드 추출
extract.method.to.package.name=패키지 {0}(으)로 메서드 추출
extract.method.to.anonymous.class=익명 클래스로 메서드 추출
try.block=try 블록
constructor=생성자
case.clause=case 절
if.block=if 블록
def.name=def {0}
extract.local.method.in.else.block=else 블록 내 로컬 메서드 추출
val.name=val {0}
var.name=var {0}
for.statement=구문의 경우
while.statement=while 문
do.statement=do 문
function.expression=함수 표현식
code.block=코드 블록
extract.file.method=파일 메서드 추출
unknown.extraction=알 수 없는 추출
choose.level.for.extract.method=추출 메서드 레벨 선택
process.duplicates=중복 처리
cannot.find.package.with.name=다음 이름을 가진 패키지를 찾을 수 없음\: {0}
cannot.find.directory.for.package=다음 패키지 디렉터리를 찾을 수 없음\: {0}
class.already.exists.in.package=패키지 {1} 에 이름이 {0} 인 클래스가 이미 존재합니다
extract.trait.action.text=특성 추출...
extract.trait.action.description=선택한 클래스에서 특성 추출
extract.trait.title=특성 추출
extract.trait.top.label.text=다음에서 특성 추출\:
extract.trait.name=특성 이름\:
extract.trait.package.label=새 특성용 패키지\:
members.to.extract=추출할 멤버
extract.abstracts=추상 요소 추출
private.member.cannot.be.used.in.extracted.member=비공개 멤버 {0} 은(는) 추출된 멤버 {1} 에서 사용될 수 없습니다
member.of.anonymous.class.cannot.be.used.in.extracted.member=익명 클래스의 멤버 {0} 은(는) 추출된 멤버 {1} 에서 사용될 수 없습니다
super.reference.used.in.extracted.member=추출된 멤버 {0} 은(는) 상위 클래스 참조를 포함하지만 추출된 특성은 기본 클래스를 포함하지 않습니다
type.parameters.for.self.type.not.supported=추출된 특성이 {0} 을(를) 자체 유형으로 포함하지만 유형 매개변수의 식별은 지원되지 않습니다
cannot.inline.different.files=멤버가 다른 파일에 선언되어 있습니다. 인라인화가 지원되지 않습니다.
cannot.inline.used.outside.class=멤버가 해당 클래스 외부에서 사용됩니다. 인라인화가 지원되지 않습니다.
cannot.inline.stable.reference=값이 안정된 참조에서 사용되며 인라인화될 수 없습니다
cannot.inline.never.used=변수가 한 번도 사용되지 않습니다.
cannot.inline.not.simple.pattern=단순 패턴 정의에 대해서만 인라인화가 지원됩니다
cannot.inline.recursive.function=인라인화는 재귀 함수에 대해 지원되지 않습니다
cannot.inline.function.implicit.parameters=인라인화는 묵시적 매개변수를 가진 함수에 대해 지원되지 않습니다
cannot.inline.function.multiple.clauses=인라인화는 다수의 매개변수 절을 가진 함수에 대해 지원되지 않습니다
cannot.inline.function.varargs=인라인화는 vararg 매개변수를 가진 함수에 대해 지원되지 않습니다
cannot.inline.implicit.element=인라인화는 묵시적 요소에 대해 지원되지 않습니다
cannot.inline.special.function=인라인화는 특수 함수에 대해 지원되지 않습니다
cannot.inline.generic.function=인라인화는 제네릭 함수에 대해 지원되지 않습니다
cannot.inline.notsimple.typealias=단순 유형 별칭에 대해서만 인라인화가 지원됩니다
cannot.inline.value.functional.type=함수 유형을 가진 값의 인라인화는 지원되지 않습니다
cannot.inline.function.functional.parameters=함수 매개변수을 가진 함수의 인라인화는 지원되지 않습니다
cannot.inline.parameter=인라인화는 매개변수에 대해 지원되지 않습니다
cannot.inline.not.method.call=정규 메서드 호출에 대해 인라인화가 지원됩니다
introduce.field.title=필드 추출
field.occurrences={0} 사용 위치
cannot.refactor.not.expression=선택한 문자열을 표현식으로 추출할 수 없습니다
cannot.create.field.from.this.expression=이 표현식에서 필드를 생성할 수 없음
cannot.find.place.for.the.new.field=새 필드 위치를 찾을 수 없음
choose.class.for.introduce.field=필드 삽입용 클래스 선택
parameter.label.name=이름\:
parameter.label.type=유형\:
parameter.label.default.value=Valor por defecto\:
replace.all.occurrences=모든 사용 위치 바꾸기
cannot.refactor.no.function=매개변수 삽입을 위한 함수를 찾을 수 없음
introduce.parameter.title=매개변수 삽입
refactoring.is.not.supported.contains.return=리팩터링이 지원되지 않습니다\: 선택 영역이 return 문을 포함합니다
choose.function.for.refactoring={0} 에 대한 함수 선택
introduce.variable.title=값/변수 삽입
cannot.refactor.not.valid.type=유형 요소가 선택되어야 합니다
cannot.refactor.scope.not.found=적합한 클래스 또는 패키지를 찾을 수 없음
choose.scope.for={0} 범위 선택
introduce.type.alias.title=유형 별칭 삽입
command.introduce.type.alias=유형 별칭 삽입
press.hotkey.to.show.more.options=ctrl + alt + v를 눌러 더 많은 옵션을 가진 대화상자를 표시하세요
introduce.variable.declare.as.var=변수(&V)
introduce.variable.specify.type.explicitly=유형 지정
introduce.variable.identifier.is.not.valid=식별자가 유효하지 않습니다
replace.all.x.occurrences=모든 {0} 사용 위치 바꾸기
1.occurrence=(1 coincidencia)
multi.occurrences=({0} líneas coincidentes)
replace.occurrences.available.from.companion.class=컴패니언 클래스 {0}에 있는 사용 위치 바꾸기
cannot.refactor.not.expression.nor.type=표현식 또는 유형 요소가 선택되어야 합니다
press.escape.to.remove.the.highlighting=esc 키를 눌러 강조 표시를 제거하세요
pull.up.members.from=다음의 멤버를 위로 이동
class.to.pull.up.members.to.class=멤버를 {0} (으)로 올릴 클래스
move.to.inner.is.not.supported.title=리팩터링이 지원되지 않습니다
move.to.inner.is.not.supported=내부로 클래스 이동은 Scala에서 지원되지 않습니다
move.with.companion=컴패니언과 함께 이동
target.0.already.contains.definition.of.1=<b>{0}</b> 이(가) 멤버 <b>{1}</b> 의 정의를 이미 포함합니다
move.members.source.title=객체 멤버 이동\:
move.members.target.title=객체로\:
move.members.object.name.or.qualified.name.expected=Scala 객체의 이름 또는 정규화된 이름 기대
move.members.cannot.find.object=그러한 이름을 가진 객체를 찾을 수 없음
move.members=멤버 이동
move.members.supported.only.stable.objects=안정적 객체 멤버에 대해서만 리팩터링 이동이 지원됩니다
move.members.not.supported.implicits=묵시적 정의에 대해 리팩터링 이동이 지원되지 않습니다
move.members.not.supported.overridden=재정의된 정의에 대해 리팩터링 이동이 지원되지 않습니다
rename.companion.module=컴패니언 {0} 이름 변경
rename.getters.and.setters.title=함수가 동일한 이름을 가진 getter 또는 setter를 포함합니다. 이것들의 이름 또한 변경하시겠어요?
rename.all.base.members=모든 기본 멤버 이름 변경
rename.base.member=기본 멤버 이름 변경
rename.only.current.member=현재 멤버만 이름 변경
rename.has.multiple.base.members={0} 이(가) 여러 기본 멤버를 포함합니다
rename.only.in={0} {1} 안에서만 이름 변경
name.implements.member.of.qualname={0}이(가) {1}의 멤버를 구현합니다
name.overrides.member.of.qualname={0}이(가) {1}의 멤버를 재정의합니다
rename.special.method.title=이 메서드의 이름을 변경할 수 없습니다
rename.special.method.rename.class=해당 {0} 이름 변경
rename.cancel=Cancelar
rename.aliased.title=import 별칭 이름 변경은 지원되지 않습니다
rename.aliased.rename.actual=실제 요소 이름 변경
rename=이름 변경
could.not.perform.inplace.rename=인플레이스 이름 변경을 수행할 수 없음\:\n\
presentable.definition.unnamed=이름이 지정되지 않았습니다
presentable.type.unnamed=이름 없는 유형
only.for.scala=이는 Scala 파일에서만 작동합니다
cannot.refactor.constr.expression=선택한 블록이 생성자 표현식으로 표시되면 안 됩니다
cannot.refactor.under.generic.call=리팩터링은 제네릭 호출에서 지원되지 않습니다
cannot.refactor.arg.in.self.invocation.of.constructor=리팩터링은 생성자 본문의 자체 호출 인수에 대해 지원되지 않습니다
cannot.refactor.named.arg=리팩터링은 명명된 인수에 대해 지원되지 않습니다
cannot.refactor.literal.pattern=리팩터링은 명명된 인수에 대해 지원되지 않습니다
cannot.refactor.class.parameter.top.level=리팩터링은 최상위 클래스의 매개변수에 대해 지원되지 않습니다
cannot.refactor.interpolated.string.prefix=리팩터링은 보간된 문자열 접두사에 대해 지원되지 않습니다
cannot.refactor.self.invocation=리팩터링은 보조 생성자의 생성자 호출에 대해 지원되지 않습니다
refactoring.is.not.supported.in.guard=가드에서 리팩터링이 지원되지 않으며 코드 구조를 파괴할 가능성이 있습니다
file.is.not.writable=파일은 쓰기 가능한 파일이 아닙니다
cannot.extract.empty.message=리팩터링 영역 선택이 잘못되었습니다. 완전한 표현식 또는 구문의 개수가 필요합니다.
cannot.extract.self.invocation=자체 호출을 추출할 수 없습니다.
cannot.extract.used.type.definition=리팩터링이 지원되지 않습니다\: 선택 영역 내 유형 정의가 선택한 조각 외부에서 사용됩니다
choose.expression.for={0} 에 대한 표현식 선택
choose.type.element.for={0} 에 대한 유형 요소 선택
introduced.typeAlias.will.conflict.with.type.name=삽입한 유형 별칭이 유형 이름과 충돌합니다\: {0}
introduced.typeAlias.will.conflict.with.class.name=삽입한 유형 별칭이 클래스 이름과 충돌합니다\: {0}
introduced.variable.will.conflict.with.local=삽입된 변수가 지역 변수와 충돌합니다(또는 지역 변수에 의해 숨겨집니다)\: {0}
introduced.variable.will.conflict.with.parameter=삽입된 변수가 매개변수와 충돌합니다(또는 매개변수에 의해 숨겨집니다)\: {0}
introduced.variable.will.conflict.with.field=삽입된 변수가 매개변수가 없는 필드 또는 메서드와 충돌합니다(또는 그것들에 의해 숨겨집니다)\: {0}
introduced.variable.will.conflict.with.class.parameter=삽입된 변수가 클래스 매개변수와 충돌합니다(또는 이에 의해 숨겨집니다)\: {0}
generate.scaladoc=Scaladoc 생성
generate.scaladoc.action.text=Scaladoc 생성
generate.scaladoc.action.description=Scaladoc 생성
scaladoc.noon=Scaladoc
output.dir=출력 디렉터리
documentation.for.project={0} 문서
scaladoc.parsing.open.syntax.element=구문 요소 열기
scaladoc.parsing.closing.link.tag.before.opening=열기 전 링크 태그 닫기
scaladoc.parsing.closing.code.tag.before.opening=열기 전 코드 태그 닫기
scaladoc.parsing.error.bad.token=오류\: 잘못된 토큰\: {0}
scaladoc.parsing.header.closed.by.opening.new.one=새 요소 열기에 의해 닫힌 헤더
scaladoc.parsing.wiki.syntax.element.closed.by.message={0} 에 의해 닫힌 Wiki 구문 요소
scaladoc.parsing.wiki.syntax.closed.by.new.paragraph=새 단락
scaladoc.parsing.wiki.syntax.closed.by.tag=태그
scaladoc.parsing.wiki.syntax.closed.by.inner.code.tag=내부 코드 태그
scaladoc.parsing.cross.tags=크로스 태그
scaladoc.parsing.no.closing.element=요소 닫기 없음
scaladoc.parsing.unclosed.code.tag=닫히지 않은 코드 태그
scaladoc.parsing.unexpected.end.of.tag.body=예기치 않은 태그 본문 끝
scaladoc.parsing.inline.tag=태그 인라인화
scaladoc.parsing.missing.tag.param=태그 매개변수 누락
scaladoc.parsing.unknown.tag=알 수 없는 태그\: {0}
type.unnamed=유형의 이름이 지정되지 않음
bold.surrounder.template.description=굵게\: '''' ''''
italic.surrounder.template.description=기울임꼴\: '' ''
monospace.surrounder.template.description=고정폭\: ` `
subscript.surrounder.template.description=아래 첨자\: ,, ,,
superscript.surrounder.template.description=위 첨자\: ^ ^
underline.surrounder.template.description=밑줄\: __ __
desugar.scala.code.in.scope=Scala 코드 ({0}) 디슈가링
scope.selection=선택 항목
scope.file=파일
desugar.scala.code.action.text=Scala 코드 디슈가링...
desugar.scala.code.action.description=Scala 코드 디슈가링 (선택 영역/파일 전체)
column.enabled=사용
column.transformation=변환
desugar.group.method.invocations=메서드 호출
desugar.expand.apply.call="apply" 호출 확장
desugar.expand.update.call="update" 호출 확장
desugar.expand.unary.call=단항 호출 확장
desugar.expand.property.setter.call=프로퍼티 setter 호출 확장
desugar.expand.assignment.call=대입 호출 확장
desugar.expand.dynamic.call=동적 호출 확장
desugar.canonize.infix.call=infix 호출 정규화
desugar.canonize.postfix.call=접미사 호출 정규화
desugar.canonize.arity.0.call=arity-0 호출 정규화
desugar.canonize.block.argument=빈 블록 인수 정규화
desugar.expand.auto.tupling=자동 튜플링 확장
desugar.expand.vararg.argument=vararg 인수 확장
desugar.inscribe.default.arguments=디폴트 인수 삽입
desugar.expand.to.equals.call="\=\="를 "equals" 호출로 확장
desugar.group.type.annotations=유형 어노테이션
desugar.value.definition=값 정의
desugar.variable.definition=변수 정의
desugar.method.definition=메서드 정의
desugar.function.parameter=함수 매개변수
desugar.underscore.parameter=밑줄 매개변수
desugar.reference.pattern=참조 패턴
desugar.type.parameters=유형 매개변수
desugar.group.types=유형
desugar.expand.function.type=함수 유형 확장
desugar.expand.tuple.type=튜플 유형 확장
desugar.expand.type.alias=유형 별칭 확장
desugar.expand.context.bound=컨텍스트 바운드 확장
desugar.expand.view.bound=뷰 바운드 확장
desugar.substitute.anyref=AnyRef 대체
desugar.group.implicits=묵시적
desugar.expand.implicit.conversion=묵시적 변환 확장
desugar.inscribe.implicit.parameters=묵시적 매개변수 삽입
desugar.group.functions=함수
desugar.expand.placeholder.syntax=자리표시자 구문 확장
desugar.expand.eta.expansion=eta 확장 확장
desugar.make.eta.expansion.explicit=eta 확장을 명시적으로 설정
desugar.expand.single.abstract.methods=단일 abstract 메서드 확장
desugar.expand.function.instantiation=함수 인스턴스화 확장
desugar.group.expressions=표현식
desugar.expand.for.comprehensions=for 내포 확장
desugar.expand.string.interpolation=문자열 보간 확장
desugar.expand.tuple.instantiation=튜플 인스턴스화 확장
desugar.group.declarations=선언
desugar.expand.procedure.syntax=프로시저 구문 확장
desugar.make.method.return.expressions.explicit=메서드 반환 표현식을 명시적으로 설정
desugar.add.explicit.override.modifier=명시적 "override" 제어자 추가
desugar.replace.underscore.section.with.default.value=밑줄 섹션을 디폴트 값으로 바꾸기
desugar.expand.property.declaration=프로퍼티 선언 확장
desugar.expand.property.definition=프로퍼티 정의 확장
desugar.convert.implicit.class.to.class.and.function=묵시적 클래스를 클래스 및 함수로 변환
desugar.group.references=참조
desugar.expand.wildcard.import=와일드카드 import 문 확장
desugar.fully.qualify.import.expression=import 표현식을 완전히 정규화
desugar.partially.qualify.simple.reference=단순 참조를 부분적으로 정규화
desugar.fully.qualify.reference=참조를 완전히 정규화
desugar.group.general=일반
desugar.append.semicolon=세미콜론 추가
desugar.inscribe.explicit.braces=명시적 중괄호 삽입
desugar.enforce.parentheses.in.constructor.invocation=생성자 호출 시 소괄호 강제 적용
desugar.convert.parentheses.to.braces.in.for.comprehensions=내포를 위해 소괄호를 중괄호로 변환
desugar.expand.macro=매크로 확장
specify.return.type.explicitly=유형 지정(&T)
add.override.modifier="override" 삽입(&O)
copy.scaladoc=ScalaDoc 복사(&S)
select.method.override=재정의할 멤버 선택
select.method.implement=구현할 멤버 선택
action.implement.method=메서드 구현
action.override.method=메서드 재정의
library.type.scala.sdk=Scala SDK
title.fetching.available.this.versions=사용 가능한 {0} 버전 가져오는 중
scala.project.data.service.scalaLibraryNotFound=모듈 ''{0}''의 Scala SDK를 구성할 수 없습니다(모듈 ''{0}''의 프로젝트 Scala 라이브러리 {1}을(를) 찾을 수 없습니다)
sdk.notification.provider.setup.scala.sdk=Scala SDK 설치
sdk.notification.provider.no.scala.sdk.in.module=모듈에 Scala SDK가 없습니다
sdk.scan.title=Scala SDK 위치 찾는 중\: {0}
brew.packages=Brew 패키지
coursier.v1.cache=Coursier v1 캐시
ivy2.cache=Ivy2 캐시
maven.local.repo=Maven 로컬 저장소
local.project.libraries=로컬 프로젝트 라이브러리
sdkman=SDKMAN\!
system.wide.scala=시스템 전체 Scala
unresolved.artifact=해결되지 않은 아티팩트\: {0}
ambiguous.artifact.resolved=모호한 아티팩트가 해결되었습니다. {0}
unknown.resolve.issues=알 수 없는 해결 이슈\: {0}
unknown.exception=알 수 없는 예외\: {0}
displayname.scala.compiler=Scala 컴파일러
incrementality.type=증분 요소(&I)\:
scala.compiler.profiles.panel.profile.name=프로파일 이름
scala.compiler.profiles.panel.move.to=다음으로 이동
scala.compiler.profiles.panel.create.new.profile=새 프로파일 생성
scala.compiler.profiles.panel.profile.should.not.be.empty=프로파일 이름은 공백일 수 없습니다
scala.compiler.profiles.panel.profile.already.exists=프로파일 {0} 이(가) 이미 존재합니다
unchecked.warnings=확인되지 않은 경고(&U)
unchecked.warnings.tooltip=생성된 코드에서 추가 경고 활성화는 가정에 따라 달라집니다.
deprecation.warnings=사용 중단 경로(&D)
deprecation.warnings.tooltip=경고 및 사용 중단된 API 사용 위치 전송
feature.dynamics=동적 요소(&D)
feature.existential.types=존재 유형(&E)
explain.type.errors=유형 오류 설명(&E)
explain.type.errors.tooltip=유형 오류 자세히 설명
feature.warnings=기능 경고(&F)
feature.warnings.tooltip=언어 기능 경고를 전송합니다.
feature.higher.kinded.types=상류 유형(&E)
feature.implicit.conversions=묵시적 변환(&I)
feature.macros=매크로(&M)
optimise.bytecode=바이트 코스 최적화(신중히 사용*)(&O)
optimise.bytecode.tooltip=프로그램에 최적화를 적용하여 더 빠른 바이트 코드를 생성하세요. 다양한 컴파일 문제가 발생할 수 있습니다. 신중히 사용하세요.
feature.postfix.notation=접두사 연산자 사용(&P)
feature.reflective.calls=리플렉티브 호출(&R)
additional.compiler.options=추가 컴파일러 옵션(&O)\:
compile.order=컴파일 순서(&O)\:
compiler.plugins=컴파일러 플러그인
debugging.info.level=디버그 정보 레벨(&L)\:
feature.experimental.features=실험적 기능(&X)
enable.continuations=연속 활성화(&C)
enable.specialization=구체화 활성화(&S)
enable.specialization.tooltip=@specialize 어노테이션 준수
enable.warnings=경고 활성화(&W)
enable.warnings.tooltip=경고 생성
features=기능세부
options=옵션
compile.order.mixed=혼합
compile.order.java.then.scala=Java 다음 Scala
compile.order.scala.then.java=Scala 다음 Java
debug.info.level.none=Ninguno
debug.info.level.source=소스 파일 속성
debug.info.level.source.and.line.number=소스 및 줄 번호 정보
debug.info.level.source.line.number.and.local.variable=소스, 줄 번호 및 지역 변수 정보
debug.info.level.complete.no.tail.call.optimization=완전함, 테일 호출 최적화 없음
idea.based.scala.project=IDEA 기반 Scala 프로젝트
module.with.a.scala.sdk=Scala SDK를 포함하는 모듈
package.prefix.label=패키지 접두사\:
package.prefix.example=예\: ''org.example.application''
package.prefix.help=패키지 접두사가 <code>org.example.application</code>인 경우, 소스 디렉토리 내 <code>PATH</code>는 <code>org/example/application/PATH</code>를 의미하므로, 명시적 <code>org</code>, <code>example</code>, <code>application</code> 하위 디렉토리를 생성할 필요가 없습니다.
title.download=Descargar
title.error.downloading.scala.libraries=Scala 라이브러리 라운로드 오류
no.versions.available.for.download=다운로드 가능한 버전 없음
downloading.scala.version=Scala {0} 다운로드 중
error.downloading.scala.version=Scala {0} 다운로드 오류
invalid.scala.version.format=올바르지 않은 Scala 버전 형식\: {0}
sdk.create.select.files=새 Scala SDK용 JAR 선택
scala.sdk.selection.button.download=다운로드...
scala.sdk.selection.button.browse=찾아보기...
scala.sdk.component.name.compiler.classpath=컴파일러 클래스 경로
scala.sdk.component.name.library=라이브러리
scala.sdk.component.name.library.source=라이브러리 소스
scala.sdk.component.name.library.scaladoc=라이브러리 scaladoc
scala.sdk.descriptor.contains.duplicated.files=Scala SDK 설명자에 중복된 {0} 파일이 있습니다.
sdk.table.model.location=위치
sdk.table.model.version=버전
sdk.table.model.sources=소스
sdk.table.model.docs=Documento
title.scala.sdk.files=Scala SDK 파일
choose.either.a.scala.sdk.directory.or.scala.jar.files=Scala SDK 디렉터리 또는 Scala jar 파일 중 하나를 선택하세요(허용\: 바이너리, 소스, 문서)
no.program.arguments=프로그램 인수가 없습니다
main.method.parameters.table.column.title.name=이름
main.method.parameters.table.column.title.type=유형
main.method.parameters.table.column.title.value=값
provide.program.arguments=Proporcionar argumentos del programa
indent.pasted.lines.at.caret=캐럿 위치에 붙여넣은 줄 들여쓰기
insert.pair.multiline.quotes=다중 중 문자열에 쌍따옴표 삽입
wrap.single.expression.body=''{'' 입력 후 닫는 중괄호를 가진 단일 표현식 본문 줄 바꿈
delete.closing.brace='{'를 삭제하고 닫는 괄호 삭제
upgrade.to.interpolated=''${'' 입력 후 단순 문자열을 보간된 문자열로 업그레이드
insert.block.braces.automatically.based.on.indentation=중괄호를 자동으로 추가
insert.block.braces.automatically.based.on.indentation.tooltip=코드 편집 시 단일 줄 블록이 여러 줄 블록으로 바뀔 때 중괄호 추가
remove.block.braces.automatically.based.on.indentation=중괄호를 자동으로 제거
remove.block.braces.automatically.based.on.indentation.tooltip=코드 편집 시 여러 줄 블록이 단일 줄 블록으로 바뀔 때 중괄호 제거
control.curly.braces.based.on.line.indents=줄 들여쓰기에 따라 중괄호 제어\:
scala.project.settings=Scala 프로젝트 설정
scala.project.settings.form.tabs.editor=Editor
scala.project.settings.form.tabs.project.view=Vista del proyecto
scala.project.settings.form.tabs.performance=성능
scala.project.settings.form.tabs.worksheet=워크시트
scala.project.settings.form.tabs.base.packages=기본 패키지
scala.project.settings.form.base.package.inherit=소스 폴더의 패키지 접두사에서 상속
scala.project.settings.form.base.package.custom=사용자 지정 사용\:
scala.project.settings.form.tabs.misc=Otros
scala.project.settings.form.tabs.updates=업데이트
scala.project.settings.form.tabs.extensions=확장
scala.project.settings.form.alias.export.semantics=Scala 및 Scala.Predef의 별칭\:
scala.project.settings.form.collection.type.highlighting.option=컬렉션 유형 강조 표시\:
scala.project.settings.form.sbt.index.ivy2.mode=로컬 ivy2 캐시 색인화 모드
scala.project.settings.form.sbt.index.ivy2.mode.hint=비활성화됨 - 완료된 색인화 없음\n\
scala.project.settings.form.scala.meta.settings.annot212=scala.meta 프로그램 실챙
scala.project.settings.form.scala.meta.settings.annot212.tooltip=2진 호환성 때문에 2.12 모듈의 어노테이션이 매우 느린 문자열 기반의 직렬화 및 재파싱을 사용해야 합니다. 이는 전반적인 성능에 심각하게 영향을 미칠 수 있습니다.
scala.project.settings.form.scala.meta.settings.modeOptions.tooltip=활성화됨 - 유형 추론 도중 메타프로그램이 실행됩니다\n\
scala.project.settings.form.scala.meta.settings.trimBodies.caption=Trim 메서드 본문이 scala.meta에 의해 확장됩니다
scala.project.settings.form.scala.meta.settings.trimBodies.tooltip=생성된 메서드의 명시적 반환 유형에 의존합니다(본문이 ???로 대체됩니다). 메서드 본문 유형 검사를 건너뛰어 유형 추론 속도를 높입니다.
scala.project.settings.form.error.highlighting=오류 강조 표시
scala.project.settings.form.error.highlighting.use.compiler.ranges=Scala 컴파일러가 보고한 텍스트 범위 사용
scala.project.settings.form.highlighting=강조 표시
scala.project.settings.form.highlight.implicit.conversions=묵시적 변환 강조 표시
scala.project.settings.form.show.hints.if.no.implicit.arguments.found=묵시적 인수를 찾을 수 없는 경우 힌트 표시
scala.project.settings.form.show.hints.if.ambiguous.implicit.arguments.found=모호한 묵시적 인수가 발견되면 힌트 표시
scala.project.settings.form.highlight.arguments.to.by.name.parameters=by-name 매개변수 인수 강조 표시
scala.project.settings.form.include.block.expressions=블록 표현식 포함
scala.project.settings.form.include.literals=리터럴 포함
scala.project.settings.form.custom.scalatest.keywords.highlighting=사용자 정의 scalaTest 키워드 강조 표시
scala.project.settings.form.autocomplete=자동 완성
scala.project.settings.form.ahead.of.time.completion=AOT 코드 완성(매개변수 및 변수 이름 지정)
scala.project.settings.form.use.scala.classes.priority.over.java=Java 클래스보다 Scala 클래스 우선 사용
scala.project.settings.form.code.conversion=코드 변환
scala.project.settings.form.convert.java.code.to.scala.on.copy.paste=복사-붙여넣기 시 Java 코드를 Scala로 변환
scala.project.settings.form.automatically.convert.to.scala.code.without.dialog=붙여넣기 시 대화상자 표시 안 함, Scala 코드로 자동 변환
scala.project.settings.form.add.override.keyword.to.method.implementation=메서드 구현에 재정의 키워드 추가
scala.project.settings.form.group.package.object.with.package=패키지 객체를 패키지와 그룹화(&G)
scala.project.settings.form.highlight.nodes.with.errors=오류가 있는 노드 강조 표시(&H)
scala.project.settings.form.implicit.parameters.search.depth=묵시적 매개변수 검색 깊이 (아무것도 없는 경우 -1)\:
scala.project.settings.form.search.all.symbols=모든 심볼(로컬 심볼 포함) 검색
scala.project.settings.form.disable.parsing.of.documentation.comments=문서 주석 파싱을 비활성화합니다. 이는 매우 큰 파일에 대해 에디터 성능을 향상시킬 수 있습니다. (SCL-2900)
scala.project.settings.form.disable.language.injection.in.scala.files=Scala 파일 내 언어 삽입 비활성화 (삽입된 언어는 자동 팝업 코드 완성 기능으로 입력을 중지시킬 수 있습니다)
scala.project.settings.form.dont.cache.compound.types=복합 유형 캐시 안 함(GC에서 심한 멈춤 현상이 발생하는 경우 사용하세요)
scala.project.settings.form.treat.sc.files.as=.sc 파일을 다음으로 처리\:
scala.project.settings.form.output.cutoff.limit=출력 컷오프 제한\:
scala.project.settings.form.output.cutoff.limit.units=행
scala.project.settings.form.delay.before.auto.run=자동 실행 전 지연\:
scala.project.settings.form.delay.before.auto.run.units=밀리초
scala.project.settings.form.run.worksheet.in.the.compiler.process=컴파일러 프로세스에서 워크시트 실행(일반 모드만 해당)
scala.project.settings.form.use.eclipse.compatibility.mode="eclipse 호환성" 모드 사용
scala.project.settings.form.treat.scala.scratch.files.as.worksheet.files=Scala 스크래치 파일을 워크시트 파일로 처리
scala.project.settings.form.collapse.long.output.by.default=디폴트로 긴 출력 접기
scala.project.settings.form.scalatest.default.super.class=ScalaTest 디폴트 상위 클래스\:
scala.project.settings.form.trailing.commas=후행 쉼표\:
scala.project.settings.form.plugin.update.channel=채널 업데이트\:
scala.project.settings.form.check.for.updates=지금 확인
scala.project.settings.form.info=언제든지 "안정화된 릴리스" 또는 "얼리 액세스 프로그램"을 선택하여 더 안정적인 빌드로 돌아갈 수 있습니다
support.back.references.in.shared.sources=공유된 소스에서 역참조 지원(실험적 기능)(&S)
support.back.references.in.shared.sources.tooltip=이 설정이 활성화되면 IntelliJ가 공유 소스 모듈에서<br>종속 모듈의 선언으로 참조를 처리할 수 있습니다
scala.collection.highlighting.type.none=Ninguno
scala.collection.highlighting.type.only.non.qualified=정규화되지 않은 항목만
scala.collection.highlighting.type.all=모두
scala.plugin.chanel.nightly=야간 빌드
scala.plugin.chanel.eap=얼리 액세스 프로그램
scala.plugin.chanel.release=안정화된 릴리스
scala.project.settings.form.alias.definition=정의
scala.project.settings.form.alias.export=내보내기
scala.project.settings.form.tabs.base.package=기본 패키지
scala.meta.mode.enabled=사용
scala.meta.mode.disabled=Deshabilitar
scala.meta.mode.manual=Manual
ivy2.indexing.mode.disabled=Deshabilitar
ivy2.indexing.mode.metadata=메타데이터
ivy2.indexing.mode.classes=클래스
trailing.commas.mode.enabled=사용
trailing.commas.mode.disabled=Deshabilitar
trailing.commas.mode.auto=자동
type.checker.built.in=기본 제공
type.checker.compiler=컴파일러
type.checker.help=<html><strong>기본 제공\: </strong> 더 많은 기능을 제공하며 반응이 더 빠르고 가볍습니다. 복잡한 코드에서는 거짓 오류가 발생할 수 있습니다.<br><br><strong>컴파일러\:</strong> 더 정확합니다. 그러나 더 느리고 더 많은 리소스를 소비하며 타입 비교, 빠른 수정, 검사 등의 기능을 지원하지 않습니다.<br><br>특정 코드 베이스에서 거짓 오류가 대량으로 발생하지 않는 한, 기본 제공 타입 검사기를 사용하는 것이 좋습니다.</html>
use.compiler.ranges.help=<html><strong>오류 강조 표시가 컴파일러로 설정된 Scala 3 프로젝트에 적용됩니다.</strong><br><br>활성화 시 에디터 내의 코드를 강조 표시할 때 Scala 컴파일러가 보고한 텍스트 범위가 사용됩니다. 선택된 컴파일 오류에 대해 큰 텍스트 범위가 강조 표시될 수 있습니다.<br><br>비활성화 시 선택된 컴파일 오류에 대해 작은 텍스트 범위가 강조 표시됩니다.</html>
script.file.mode.always.worksheet=항상 워크시트
script.file.mode.ammonite.in.test.sources.otherwise.worksheet=테스트 소스에서 Ammonite, 그 외의 경우 워크시트
script.file.mode.always.ammonite=항상 Ammonite
invalid.update.channel=잘못된 업데이트 채널
changes.in.scalatest.highlighting.will.be.processed...=ScalaTest 강조 표시에 적용된 변경 내용은 새로 강조 표시된 파일에서만 올바르게 처리됩니다. 사용 경험을 최적화하려면 Intellij IDEA를 다시 시작하세요
base.package.help=<html>기본 패키지가 <code>org.example.application</code>인 경우, 패키지 <code>org.example.application.NAME</code>은<br><code>package org.example.application</code><br><code>package NAME</code>으로 정의되어야 합니다</html>
scala.compile.task.measure.start={0}...
scala.compile.task.measure.end={0} - done in {1}
default.notification.title=경고
