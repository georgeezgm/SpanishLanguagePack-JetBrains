action.DlvDumpAction.text=고루틴 덤프
action.DlvRewindAction.description=이전 중단점까지 프로그램을 뒤로 실행
action.DlvRewindAction.text=되돌리기
action.DlvShowPointerAddressesToggleAction.text=포인터 주소 표시
action.DlvShowTypesToggleAction.text=타입 표시
action.DlvToggleThreadsAction.description=스레드 표시
action.DlvToggleThreadsAction.text=스레드 표시
action.FilterStacktraces.description=지정된 문자열을 포함하는 스택만 표시
action.FilterStacktraces.task.name=스택 필터링
action.Go.NewGoFile.description=새로운 Go 파일 생성
action.Go.NewGoFile.text=Go 파일
action.GoAddContentRootFromGopath.description=선택한 디렉터리를 현재 프로젝트에 추가
action.GoAddContentRootFromGopath.text=디렉터리를 현재 프로젝트에 추가
action.GoCallHierarchyPopupMenu.BaseOnThisDeclaration.text=이 선언에 기반
action.GoCoreDumpAction.text=코어 덤프 열기…
action.GoFmtFileAction.description=선택한 파일을 go fmt 도구로 서식 지정
action.GoFmtFileAction.text=Go Fmt 파일
action.GoFmtProjectAction.description=프로젝트를 go fmt 도구로 서식 지정
action.GoFmtProjectAction.text=Go Fmt 프로젝트
action.GoGenerateConstructorAction.description=구조체에 대한 생성자 함수 생성
action.GoGenerateConstructorAction.text=생성자
action.GoGenerateFileAction.description=선택한 파일에서 go generate 실행
action.GoGenerateFileAction.text=Go Generate 파일
action.GoGenerateGetterAction.description=필드의 getter 메서드 생성
action.GoGenerateGetterAction.text=Getter
action.GoGenerateGetterSetterAction.description=필드의 getter 및 setter 메서드 생성
action.GoGenerateGetterSetterAction.text=Getter 및 Setter
action.GoGenerateMethodAction.text=메서드
action.GoGenerateSetterAction.description=필드의 setter 메서드 생성
action.GoGenerateSetterAction.text=Setter
action.GoGenerateStructFieldsFromJsonAction.description=JSON에서 구조체 필드 생성
action.GoGenerateStructFieldsFromJsonAction.text=JSON에서 구조체 필드
action.GoGenerateTypeFromJsonAction.description=JSON에서 타입 생성
action.GoGenerateTypeFromJsonAction.text=JSON의 타입
action.GoIdeNewProjectAction.text=프로젝트…
action.GoImportsFileAction.description=선택한 파일의 import 문을 goimports 도구로 최적화
action.GoImportsFileAction.text=Goimports 파일
action.GoIntroduceTypeAction.text=타입 삽입…
action.GoOpenInPlaygroundAction.description=Go Playground에서 코드 열기
action.GoOpenInPlaygroundAction.text=Playground
action.GoOpenProjectFromGopath.description=선택한 디렉터리를 프로젝트로 열기
action.GoOpenProjectFromGopath.text=디렉터리를 프로젝트로 열기
action.GoOpenSettings.description=프로젝트의 Go 설정을 엽니다
action.GoOpenSettings.text=Go 설정 열기
action.GoRemoveContentRootAction.description=선택한 콘텐츠 루트를 현재 프로젝트에서 제거
action.GoRemoveContentRootAction.text=디렉터리 연결 해제…
action.GoReplayTraceAction.text=저장된 추적 디버그…
action.GoShareInPlaygroundAction.confirmation={0}을(를) Go Playground에 업로드하고 public으로 만드시겠어요?
action.GoShareInPlaygroundAction.description=Go Playground에서 현재 파일을 공유합니다
action.GoShareInPlaygroundAction.empty.id=Playground가 빈 ID를 반환합니다
action.GoShareInPlaygroundAction.error=Go Playground에서 파일을 공유하지 못했습니다. {0}
action.GoShareInPlaygroundAction.notification.copyUrl=URL을 클립보드로 복사
action.GoShareInPlaygroundAction.notification.text=Go Playground에 공유된 파일: <a href="{0}">{0}</a>
action.GoShareInPlaygroundAction.text=Playground에서 공유
action.GoToggleCachingAction.cachingDisabled=Go 플러그인 캐시가 비활성화됨
action.GoToggleCachingAction.cachingEnabled=Go 플러그인 캐시가 활성화됨
action.GoToggleCachingAction.description=Go 플러그인에서 캐싱을 전환합니다.
action.GoToggleCachingAction.disableCaching=Go 플러그인 캐시 비활성화
action.GoToggleCachingAction.enableCaching=Go 플러그인 캐시 활성화
action.GoToggleCachingAction.text=Go 플러그인 캐싱 전환
action.GoVetFileAction.description=선택한 파일 또는 디렉터리를 go vet 도구로 린트
action.GoVetFileAction.text=Go Vet 파일
action.HideGoroutine=고루틴 숨기기
action.HideSimilarGoroutines=동일한 스택을 가진 모든 고루틴 숨기기
action.MergeIdenticalStacktraces.text=동일한 스택 추적 병합
action.ResetHiddenAction.description=숨겨진 고루틴 재설정
action.ResetHiddenAction.text=숨겨진 고루틴 재설정
action.Vgo.NewVgoFile.description=Go 모듈 파일 생성
action.Vgo.NewVgoFile.text=Go 모듈 파일
action.Vgo.NewVgoWorkspaceFile.description=Go 작업공간 파일 생성
action.Vgo.NewVgoWorkspaceFile.text=Go 작업공간 파일
action.WelcomeScreen.CreateDirectoryProject.text=새 프로젝트
action.com.goide.vgo.actions.VgoSyncAction.description=go 모듈 동기화
action.com.goide.vgo.actions.VgoSyncAction.text=Go 모듈 동기화
action.com.goide.vgo.actions.VgoTidyAction.description=모듈에서 'go mod tidy' 실행
action.com.goide.vgo.actions.VgoTidyAction.text=Go Mod Tidy
action.com.goide.vgo.actions.VgoVendorAction.description=모듈에서 'go mod vendor' 실행
action.com.goide.vgo.actions.VgoVendorAction.text=Go Mod Vendor
action.go.exclude.package.from.import.and.completion=''{0}''을(를) 가져오기 및 완성에서 제외
action.go.fill.paragraph=단락 채우기
exportable.GoSdkList.presentable.name=알려진 Go SDK 경로 목록
exportable.vgo.presentable.name=알려진 Go 관련 환경 변수 목록
filetype.go.build.description=Go:build 제약
filetype.go.cgo.description=Cgo 파일
filetype.go.description=Go 파일
filetype.go.plus.build.description=Go +build 제약
filetype.go.settings.modules.dependency.description=Go 모듈 종속성 파일
filetype.go.tag.description=Go 태그
filetype.go.time.description=Go 시간
go.action.playground.connection.failed=서버에 연결 실패
go.add.import.command.name=가져오기 추가
go.add.import.with.alias.presentation=\ {1}(으)로서의 {0}
go.app.engine.not.gae.sdk.validation.message=App Engine은 Go 1.11 이후 버전만 지원합니다
go.app.engine.wizard.description=Go App Engine을 사용하는 Go 애플리케이션 개발을 위해 Go App Engine 프로젝트를 생성합니다.<br/>새 모듈에는 디폴트 구성과 Go 기본 핸들러가 포함됩니다.
go.app.engine.wizard.name=App Engine
go.attach.directory.action.text=디렉터리 "{0}" 연결
go.auto.import.and.completion.add.exclude.label=자동 가져오기 및 코드 완성에서 제외할 가져오기 경로를 입력하세요.
go.auto.import.and.completion.title=자동 가져오기 및 코드 완성
go.background.task.compiling.title=컴파일 중…
go.background.task.running.title=실행 중…
go.before.check.in.show.fmt.error.button=세부 정보(&D)…
go.call.hierarchy.respect.interface.calls.action.name=인터페이스 호출에 따름
go.call.hierarchy.respect.interface.calls.description=인터페이스 호출에 따름
go.cannot.be.represented.by.type={0}은(는) 타입 {1}(으)로 나타낼 수 없습니다
go.checkin.factory.fmt.commit.anyway.question=그래도 커밋하시겠어요?
go.checkin.factory.fmt.failed.message=일부 파일에서 GoFmt가 0이 아닌 코드를 반환합니다.
go.checkin.factory.fmt.not.started.message=gofmt을 실행할 수 없습니다. {0}
go.code.smells.commit.local.paths=로컬 경로 커밋은 이식이 불가능할 수 있습니다
go.code.vision.implementations={0, choice, 1#1개 구현|2#{0,number}개 구현}
go.code.vision.usages={0,choice, 0#0개의 사용위치|1#1개 사용 위치|2#{0,number}개 사용 위치}
go.codeLens.inheritors.description=인터페이스에 있는 하위 항목 수입니다. 힌트를 클릭하면 이 인터페이스에서 상속하는 코드로 이동합니다.
go.codeLens.references.description=프로젝트 내에서 최상위 선언이 사용되는 위치의 수입니다. 사용 위치로 이동하려면 힌트를 클릭하세요.
go.codeLens.vcs.code.vision.description=타입, 메서드 또는 다른 코드 요소를 작성한 사람의 이름입니다. 이름은 VCS에서 가져옵니다.
go.colors.and.fonts.bad.character=잘못된 문자
go.colors.and.fonts.braces.and.operators=중괄호 및 연산자
go.colors.and.fonts.braces.and.operators.braces=중괄호
go.colors.and.fonts.braces.and.operators.brackets=대괄호
go.colors.and.fonts.braces.and.operators.colon=콜론
go.colors.and.fonts.braces.and.operators.comma=쉼표
go.colors.and.fonts.braces.and.operators.dot=마침표
go.colors.and.fonts.braces.and.operators.operator=연산자
go.colors.and.fonts.braces.and.operators.parentheses=소괄호
go.colors.and.fonts.braces.and.operators.semicolon=세미콜론
go.colors.and.fonts.comments=주석
go.colors.and.fonts.comments.block.comment=블록 주석
go.colors.and.fonts.comments.build.constraints=빌드 제약 조건
go.colors.and.fonts.comments.build.constraints.operators=연산자
go.colors.and.fonts.comments.build.constraints.parens=소괄호
go.colors.and.fonts.comments.build.constraints.tag=꼬리표
go.colors.and.fonts.comments.comment.keyword=주석 키워드
go.colors.and.fonts.comments.comment.reference=주석 참조
go.colors.and.fonts.comments.line.comment=줄 주석
go.colors.and.fonts.declarations=선언
go.colors.and.fonts.declarations.constants=상수
go.colors.and.fonts.declarations.constants.builtin.constant=기본 제공 상수
go.colors.and.fonts.declarations.constants.local.constant=지역 상수
go.colors.and.fonts.declarations.constants.package.exported.constant=내보낸 상수 패키징
go.colors.and.fonts.declarations.constants.package.local.constant=지역 상수 패키징
go.colors.and.fonts.declarations.function.parameter=함수 매개변수
go.colors.and.fonts.declarations.functions=함수
go.colors.and.fonts.declarations.functions.builtin.function=기본 제공 함수
go.colors.and.fonts.declarations.functions.exported.function=내보낸 함수
go.colors.and.fonts.declarations.functions.package.local.function=지역 함수 패키징
go.colors.and.fonts.declarations.label=라벨
go.colors.and.fonts.declarations.method.receiver=메서드 리시버
go.colors.and.fonts.declarations.package=패키지
go.colors.and.fonts.declarations.struct.tags=구조체 태그
go.colors.and.fonts.declarations.struct.tags.arbitraryText=임의의 텍스트
go.colors.and.fonts.declarations.struct.tags.colon=콜론
go.colors.and.fonts.declarations.struct.tags.key=키
go.colors.and.fonts.declarations.struct.tags.value=값
go.colors.and.fonts.declarations.types=타입
go.colors.and.fonts.declarations.types.package.exported.interface=내보낸 인터페이스 패키징
go.colors.and.fonts.declarations.types.package.exported.struct=내보낸 구조체 패키징
go.colors.and.fonts.declarations.types.package.local.interface=지역 인터페이스 패키징
go.colors.and.fonts.declarations.types.package.local.struct=지역 구조체 패키징
go.colors.and.fonts.declarations.types.type.specification=타입 사양
go.colors.and.fonts.declarations.variables=변수
go.colors.and.fonts.declarations.variables.builtin.variable=기본 제공 변수
go.colors.and.fonts.declarations.variables.local.variable=지역 변수
go.colors.and.fonts.declarations.variables.package.exported.variable=내보낸 변수 패키징
go.colors.and.fonts.declarations.variables.package.local.variable=지역 변수 패키징
go.colors.and.fonts.declarations.variables.reassignment.in.short.variable.declaration=짧은 변수 선언 재대입
go.colors.and.fonts.declarations.variables.scope.declared.variable=선언된 변수 범위 지정
go.colors.and.fonts.declarations.variables.shadowing.variable=가리는(Shadowing) 변수
go.colors.and.fonts.declarations.variables.struct.exported.member=구조체의 내보낸 멤버
go.colors.and.fonts.declarations.variables.struct.local.member=구조체의 지역 멤버
go.colors.and.fonts.identifier=식별자
go.colors.and.fonts.keyword=키워드
go.colors.and.fonts.number=숫자
go.colors.and.fonts.references=참조
go.colors.and.fonts.references.function.calls=함수 호출
go.colors.and.fonts.references.function.calls.builtin.function.call=기본 제공 함수 호출
go.colors.and.fonts.references.function.calls.exported.function.call=내보낸 함수 호출
go.colors.and.fonts.references.function.calls.local.function.call=지역 함수 호출
go.colors.and.fonts.references.type.references=타입 참조
go.colors.and.fonts.references.type.references.builtin.type.reference=기본 제공 타입 참조
go.colors.and.fonts.references.type.references.package.exported.interface=내보낸 인터페이스 패키징
go.colors.and.fonts.references.type.references.package.exported.struct=내보낸 구조체 패키징
go.colors.and.fonts.references.type.references.package.local.interface=지역 인터페이스 패키징
go.colors.and.fonts.references.type.references.package.local.struct=지역 구조체 패키징
go.colors.and.fonts.references.type.references.type.specification=타입 사양
go.colors.and.fonts.references.variable.calls=변수 호출
go.colors.and.fonts.references.variable.calls.exported.variable.call=내보낸 변수 호출
go.colors.and.fonts.references.variable.calls.local.variable.call=지역 변수 호출
go.colors.and.fonts.references.variable.calls.package.local.variable.call=지역 변수 호출 패키징
go.colors.and.fonts.references.variable.calls.struct.exported.member.call=구조체의 내보낸 멤버
go.colors.and.fonts.references.variable.calls.struct.local.member.call=구조체의 지역 멤버 호출
go.colors.and.fonts.string=문자열
go.colors.and.fonts.string.invalid.escape=잘못된 이스케이프
go.colors.and.fonts.string.text=텍스트
go.colors.and.fonts.string.valid.escape=올바른 이스케이프
go.command.line.inspection.project.configurator.description=Go 프로젝트를 구성합니다
go.command.line.inspection.project.configurator.download.dependencies=Go 모듈 종속성 다운로드 중…
go.completion.add.tag.key.to.all.fields=모든 필드에 태그 키 추가…
go.completion.fill.all.fields.lookup.string=모든 필드 입력…
go.completion.fill.selected.fields.lookup.string=선택한 필드 입력…
go.completion.generate.struct.fields.from.json=JSON에서 구조체 필드 생성…
go.completion.insert.if.not.nil.statement.command.name=''if value != nil {...}'' 구문 삽입
go.completion.insert.literal.command.name=Go 리터럴 삽입
go.completion.insert.type.name.command.name=타입 이름 삽입
go.completion.method.like.completion.advertisement=첫 인수로 표현식을 허용하는 함수를 보려면 {0}을(를) 누르세요
go.completion.method.like.completion.command.name=함수를 메서드처럼 코드 완성
go.converter.build.run.configuration.description='Go Build' 실행 구성이 변경되었습니다. 기존 구성이 변환되어야 합니다.
go.converter.build.tags.description=Go 프로젝트 설정 저장 메커니즘이 변경되었으므로 프로젝트 및 모듈을 업데이트하세요.
go.converter.project.model.description=Go 프로젝트 모델이 변경되었으므로 프로젝트 및 모듈을 업데이트하세요
go.converter.sdk.description=Go 프로젝트 모델이 변경되었으므로 프로젝트 및 모듈을 업데이트하세요
go.converter.single.file.run.configuration.description=Go 'Run single file' 실행 구성이 제거되었습니다. 기존 구성이 변환되어야 합니다.
go.core.dump.dialog.dump.path.label=코어 덤프(&C):
go.core.dump.dialog.executable.label=실행 파일(&E):
go.core.dump.dialog.invalid.core.dump.validation.message=올바른 코어 덤프 파일이 아닙니다
go.core.dump.dialog.invalid.executable.validation.message=실행 가능한 파일이 아닙니다
go.core.dump.dialog.specify.core.dump.validation.message=코어 덤프 지정
go.core.dump.dialog.specify.executable.validation.message=실행 파일 지정
go.core.dump.failed.to.start.error.message=코어 덤프 {0}에 대해 디버거를 시작하지 못했습니다. {1}
go.core.dump.session.name=코어 덤프 {0}
go.create.intermediate.variable.declaration.fix.name=중간 변수 생성
go.create.new.file.action.command.name=Go 파일 {0} 생성
go.create.new.file.action.name=Go 파일
go.create.new.file.dialog.title=새 Go 파일
go.create.new.file.empty.file.kind.name=빈 파일
go.create.new.file.simple.application.kind.name=간단한 애플리케이션
go.debug.show.goroutines.action.name=고루틴 표시
go.debug.show.threads.action.name=스레드 표시
go.debugger.and.n.more=및 그 외 {0}개
go.debugger.another.command.is.in.progress=또 다른 명령어가 실행 중입니다
go.debugger.async.stacktrace.caption=비동기 스택 추적
go.debugger.breakpoint.title=Go 중단점
go.debugger.cannot.calculate.string.presentation=문자열 프리젠테이션 계산 불가: {0}
go.debugger.cannot.calculate.value=값을 계산할 수 없습니다
go.debugger.cannot.connect.non.remote=Delve 프로세스가 원격 연결을 사용하지 않기 때문에 해당 프로세스에 연결할 수 없습니다
go.debugger.cannot.connect.twice=Delve 프로세스는 두 번 연결될 수 없습니다
go.debugger.cannot.evaluate.call=호출을 평가할 수 없습니다. {0}
go.debugger.cannot.evaluate.expression=''{0}'' 표현식을 평가할 수 없습니다. {1}
go.debugger.cannot.find.debugger.path={0} 디버거 경로를 찾을 수 없습니다
go.debugger.cannot.find.file=파일 {0}을(를) 찾을 수 없음
go.debugger.cannot.find.free.port=디버거에 사용할 가용 TCP 포트를 찾을 수 없습니다
go.debugger.cannot.get.current.goroutine=현재 고루틴을 가져올 수 없습니다
go.debugger.cannot.get.current.stack=현재 스택을 가져올 수 없습니다
go.debugger.cannot.load.remaining.call.result.children=호출 결과의 남은 하위 항목을 로드할 수 없습니다.
go.debugger.cannot.pause=일시 중지 불가
go.debugger.cannot.resolve.localhost=로컬 호스트 주소를 확인할 수 없습니다
go.debugger.cannot.retrieve.go.processes=Go 프로세스를 검색할 수 없습니다
go.debugger.cannot.retrieve.interface.value.type=인터페이스 값의 타입을 검색할 수 없습니다
go.debugger.connecting.to.address.message={0}에 연결 중…
go.debugger.connecting.to.unknown.address.message=원격 주소 연결 중…
go.debugger.connection.failed.generic.message={0}에 연결 실패
go.debugger.create.dump.background.task.progress.text=스택({0}) 덤프 중…
go.debugger.create.dump.background.task.title=스택 덤프 중…
go.debugger.custom.delve.extended.notification=사용자 지정 Delve로 디버그 중입니다. {0}. 번들로 포함된 Delve를 사용하려면 ''dlv.path'' <a href=''customProperties''>사용자 지정 프로퍼티</a>를 삭제하고 IDE를 다시 시작하세요.
go.debugger.custom.delve.notification=사용자 지정 Delve로 디버그 중입니다. {0}
go.debugger.disconnected.unexpectedly=디버거 연결이 예기치 않게 해제됨
go.debugger.error.breakpoint.display.text=치명적인 오류
go.debugger.error.breakpoint.title=Go 오류 중단점
go.debugger.expression.is.nil=''{0}''은(는) nil입니다
go.debugger.expression.is.not.a.function=''{0}''은(는) 함수가 아닙니다
go.debugger.failed.to.compute.node.presentation=노드 프레젠테이션 계산 실패
go.debugger.failed.to.create.breakpoint=중단점을 생성하지 못했습니다
go.debugger.failed.to.run.to.position=위치까지 실행하지 못했습니다
go.debugger.failed.to.stop.mozilla.rr.recording=mozilla rr 기록 중지에 실패했습니다
go.debugger.failed.to.stop.mozilla.rr.recording.details=mozilla rr 기록 중지에 실패했습니다. {0}
go.debugger.fmt.sprintf.cannot.format.value=(값 서식 지정 불가)
go.debugger.fmt.sprintf.unsupported.format=(지원되지 않는 형식)
go.debugger.fmt.sprintf.unsupported.verb=(지원되지 않는 동사)
go.debugger.go.version.is.not.officially.supported=Go {0} 버전은 디버거에서 공식적으로 지원되지 않으며 일부 기능에서 오류가 발생할 수 있습니다. Go {1} 또는 최신 버전으로 업데이트하세요.
go.debugger.go.version.is.not.supported=Go {0} 버전은 디버거에서 지원되지 않습니다. Go {1} 또는 최신 버전으로 업데이트하세요.
go.debugger.goroutine=고루틴
go.debugger.hidden.group.name=숨김({0})
go.debugger.install.gops.to.attach.to.go.processes={0}을(를) 설치하여 Go 프로세스에 연결
go.debugger.internal.messaging.error=내부 메시징 오류
go.debugger.kill.existing.process.message=디버거가 연결되어 있던 원격 프로세스를 강제 종료하시겠어요?
go.debugger.kill.existing.process.title=원격 프로세스 강제 종료
go.debugger.local.attach.group.name=Go
go.debugger.missing.current.function=현재 함수 누락
go.debugger.missing.function.name=<누락>
go.debugger.no.debug.information.for.file=실행 파일은 {0}에 대한 디버그 정보를 포함하지 않습니다
go.debugger.non.top.frame.selected=최상위가 아닌 프레임이 선택되었습니다
go.debugger.obsolete.value=<사용 중지>
go.debugger.only.first.goroutines.are.shown=첫 {0}개의 고루틴만 표시됩니다
go.debugger.process.terminated.stop.remote.delve.message=원격 프로세스가 종료되었습니다. 원격 Delve 인스턴스도 중지하시겠어요?
go.debugger.record.and.debug.action.name=기록 및 디버그
go.debugger.record.and.debug.cannot.find.rr.message=<html><a href="https://rr-project.org">mozilla rr</a> 실행 파일을 찾을 수 없습니다. 해당 파일을 설치하고 경로에 추가하세요.</html>
go.debugger.record.and.debug.description=기록 및 디버그
go.debugger.record.and.debug.start.action.text=기록 및 디버그
go.debugger.recording.in.progress=프로그램 실행을 기록합니다. 기록을 디버그하려면 프로그램 종료를 기다리거나 <a href=''{0}''>기록을 중지</a>하세요.
go.debugger.renderers.binary.name=2진수
go.debugger.renderers.decimal.name=10진수
go.debugger.renderers.hex.name=16진수
go.debugger.smart.step.into.failed=스마트 스텝인투 실패: {0}
go.debugger.smart.step.into.popup.title=함수에 스텝인투
go.debugger.stop.remote.delve.message=원격 Delve 인스턴스를 중지하시겠어요?
go.debugger.stop.remote.delve.title=원격 Delve 중지
go.debugger.thread=스레드
go.debugger.thread.dump.display.name={0} 덤프
go.debugger.thread.dump.error=스레드 덤프 가져오기 실패: {0}
go.debugger.thread.dump.incomplete.display.name=불완전한 덤프 {0}
go.debugger.thread.dump.is.in.progress=스레드 덤프가 실행 중입니다
go.debugger.thread.dump.n.goroutines={0}개의 {0,choice,0#고루틴|1#고루틴|2#고루틴}
go.debugger.thread.dump.n.goroutines.matched.by.filter=필터와 일치하는 {0}개의 {0,choice,0#고루틴|1#고루틴|2#고루틴}
go.debugger.thread.dump.n.hidden.goroutines={0}개의 숨겨진 {0,choice,0#고루틴|1#고루틴|2#고루틴}
go.debugger.thread.dump.n.unique.stacks={0}개의 고유한 {0,choice,0#스택|1#스택|2#스택}
go.debugger.unknown.function.name=<알 수 없음>
go.debugger.unreadable.error=\ 읽을 수 없음: {0}
go.debugger.unsupported.architecture.error=디버그는 64비트 시스템 및 32비트 Linux 시스템에서만 지원됩니다
go.debugger.unsupported.go.arch.on.darwin.arm64.error={0}(으)로 컴파일된 프로그램의 디버그는 지원되지 않습니다. darwin/arm64에서는 go sdk를 사용하세요.
go.debugger.unsupported.go.version.on.darwin.arm64.error=darwin/arm64에서 디버그하려면 Go 1.16이 필요합니다
go.debugger.unsupported.type=<지원되지 않는 타입: {0}>
go.debugger.unsupported.wsl1=WSL1에서의 디버그는 지원되지 않으므로 WSL2를 사용하세요
go.debugger.unused.functions.are.not.included.message=" (사용하지 않는 기능은 실행 파일에 포함되지 않습니다)"
go.debugger.unused.methods.are.not.included.message=" (사용하지 않는 메서드는 실행 파일에 포함되지 않습니다)"
go.declarations.intentions.category=Go/선언
go.detach.directory.action.text=디렉터리 "{0}" 연결 해제
go.edit.actions.on.save.action.description=저장할 때 실행할 수 있는 액션을 편집합니다
go.edit.actions.on.save.action.text=저장 시 액션…
go.edit.auto.import.settings.action.name=자동 가져오기 설정 편집
go.edit.settings.action.description=Go 전용 {0} 편집
go.element.is.not.go.expression.error.hint=선택 영역이 Go 표현식을 포함하지 않습니다
go.empty.element.text=<비어 있음>
go.enable.template.plugin.action.text=플러그인 활성화
go.enable.template.plugin.notification.text=html/templates 패키지에서 강조 표시, 코드 완성 기능, 탐색 기능을 향상하려면 Go 템플릿을 활성화하세요
go.error.annotator.argument.is.not.a.type={0}은(는) 타입이 아닙니다
go.error.annotator.array.bound.must.be.a.constant.expression=잘못된 배열 바운드 ''{0}''. 상수식이어야 합니다
go.error.annotator.array.bound.must.be.non.negative=잘못된 배열 바운드 ''{0}''. 음수여서는 안 됩니다
go.error.annotator.array.bound.must.be.representable.by.int.type=잘못된 배열 바운드 ''{0}''. 값을 ''int'' 타입으로 표시할 수 있어야 합니다
go.error.annotator.assignment.count.mismatch=대입 수 불일치: {0} = {1}
go.error.annotator.bad.octal.escape=8진 이스케이프는 3개의 8진수를 포함해야 하며 첫 번째 8진수는 3 이하여야 합니다
go.error.annotator.binary.digits.are.not.supported=2진수는 Go 1.13부터 지원됩니다
go.error.annotator.break.statement.not.inside.a.for.loop.select.or.switch='break' 문이 'for', 'select' 또는 'switch' 문 외부에 있습니다
go.error.annotator.call.used.as.value.but.it.returns.nothing={0}은(는) 값으로 사용되지만 아무것도 반환하지 않습니다
go.error.annotator.can.only.use.triple.dot.as.final.argument=목록에서 마지막 인수로 '...' 만 사용할 수 있습니다
go.error.annotator.cannot.assign.to.expression={0}에 대입할 수 없습니다
go.error.annotator.cannot.call.pointer.method=''{0}''에서 포인터 메서드를 호출할 수 없습니다
go.error.annotator.cannot.declare.in.post.statement.of.for.loop=for 루프의 후행 문에서 변수를 선언할 수 없습니다
go.error.annotator.cannot.declare.init.must.be.a.function=init을 선언할 수 없습니다. 함수여야 합니다
go.error.annotator.cannot.embed.type.parameter=유형 매개변수를 포함할 수 없습니다.
go.error.annotator.cannot.fallthrough.final.case.in.switch='switch' 문의 마지막 case에서 'fallthrough'를 사용할 수 없습니다
go.error.annotator.cannot.fallthrough.in.type.switch=타입 switch에서 'fallthrough'를 사용할 수 없습니다
go.error.annotator.cannot.infer.types={0}을(를) 추론할 수 없습니다
go.error.annotator.cannot.make.type={0} 생성 불가
go.error.annotator.cannot.make.type.no.single.underlying.type={0}을(를) 만들 수 없습니다. 타입 세트에 단일한 기본 타입이 없습니다
go.error.annotator.cannot.reassign.a.constant=상수를 다시 대입할 수 없습니다
go.error.annotator.cannot.use.comparable.in.union=공용체에서 비교할 수 없음
go.error.annotator.cannot.use.generic.function.without.instantiation=제네릭 함수를 인스턴스화하지 않고 쓸 수 없습니다
go.error.annotator.cannot.use.interface.with.methods.in.union=공용체에서 메서드가 있는 인터페이스를 사용할 수 없음
go.error.annotator.cannot.use.triple.dot.for.output.arguments=출력 인수 목록에서 '...'를 사용할 수 없습니다
go.error.annotator.cannot.use.type.assertion.on.type.parameter=타입 매개변수 값 {0}에 타입 어설션을 사용할 수 없습니다.
go.error.annotator.cannot.use.type.embedding.comparable.in.union=''{0}''을(를) 공용체에서 사용할 수 없음( ''{0}''은(는) 비교할 수 있는 항목 포함)
go.error.annotator.cannot.use.type.parameter.as.constraint=타입 매개변수를 제약으로 사용할 수 없습니다
go.error.annotator.cannot.use.type.parameter.as.rhs.in.type.declaration=타입 매개변수를 타입 선언에서 RHS로 사용할 수 없습니다
go.error.annotator.cannot.use.type.switch.on.type.parameter=타입 매개변수 값 {0}에 타입 스위치를 사용할 수 없습니다.
go.error.annotator.closing.single.quote.expected=닫는 ' 필요
go.error.annotator.comparable.outside.of.type.parameter=타입 제약 밖에서 comparable 타입을 사용할 수 없습니다. 인터페이스(또는 임베드)가 comparable입니다
go.error.annotator.const.initializer.is.not.a.constant=상수 이니셜라이저 ''{0}''은(는) 상수가 아닙니다
go.error.annotator.constraint.elements.outside.of.type.parameter=인터페이스에는 제약 {0,choice,1#요소|2#요소} {1}이(가) 포함되며 오직 타입 매개변수에서만 사용할 수 있습니다
go.error.annotator.constraint.outside.of.type.parameter=인터페이스에는 제약 요소가 포함되며 오직 타입 매개변수에서만 사용할 수 있습니다
go.error.annotator.constraint.term.on.interface=유효하지 않은 ~의 사용(''{0}''은(는) 인터페이스입니다)
go.error.annotator.constraint.term.underlying.type.is.not.self=유효하지 않은 ~의 사용(기본 유형 ''{0}''은(는) ''{0}''이(가) 아닙니다)
go.error.annotator.continue.statement.not.inside.a.for.loop='continue' 문이 'for' 루프 외부에 있습니다
go.error.annotator.conversion.in.defer.or.go={0}에는 변환이 아닌 함수 호출이 필요합니다
go.error.annotator.cyclic.definition.detected=순환 정의가 탐지되었습니다
go.error.annotator.defer.or.go.requires.function.call={0} 내 표현식은 함수 호출이어야 합니다
go.error.annotator.digit.separator.is.not.supported=숫자 구분 기호는 Go 1.13부터 지원됩니다
go.error.annotator.embedded.type.cannot.be.a.pointer=임베디드 타입은 포인터가 될 수 없습니다
go.error.annotator.embedded.type.cannot.be.a.pointer.to.a.type.parameter=포함된 유형은 유형 매개변수에 대한 포인터일 수 없습니다.
go.error.annotator.embedded.type.cannot.be.a.pointer.to.interface=임베디드 타입은 인터페이스의 포인터가 될 수 없습니다
go.error.annotator.embedded.type.cannot.be.a.type.parameter=포함된 유형은 유형 매개변수일 수 없습니다.
go.error.annotator.empty.rune.literal=빈 rune 리터럴
go.error.annotator.end.of.file.in.comment=주석 내 EOF
go.error.annotator.evaluated.but.not.used={0}은(는) 평가되었지만 사용되지 않습니다
go.error.annotator.extra.expression.in.const.declaration=상수 선언에 추가 표현식이 있습니다
go.error.annotator.fallthrough.statement.out.of.place='fallthrough' 문의 위치가 부적절합니다
go.error.annotator.func.literal.cannot.have.type.parameters=함수 리터럴에는 타입 매개변수를 사용할 수 없습니다.
go.error.annotator.function.not.permitted.in.defer.or.go=이 함수는 {0} 문에서 호출할 수 없습니다
go.error.annotator.function.type.cannot.have.type.parameters=함수 타입은 타입 매개변수를 가질 수 없습니다
go.error.annotator.generic.type.cannot.be.alias=제네릭 타입은 별칭일 수 없습니다
go.error.annotator.got.n.arguments.but.m.type.parameters=인수를 {0}개 받았으나 타입 매개변수는 {1}개입니다
go.error.annotator.hex.floats.are.not.supported=16진 부동소수점은 Go 1.13부터 지원됩니다
go.error.annotator.interface.method.must.have.no.type.parameters=Interface 메서드는 타입 매개변수를 가질 수 없습니다
go.error.annotator.invalid.argument.for.cap=cap 함수의 잘못된 인수
go.error.annotator.invalid.argument.for.len=\ len 함수의 잘못된 인수
go.error.annotator.invalid.constant.type=잘못된 상수 타입
go.error.annotator.invalid.embedded.type=잘못된 타입 {0}: typeName 또는 *typeName이어야 합니다
go.error.annotator.invalid.escape.sequence=잘못된 이스케이프 시퀀스
go.error.annotator.invalid.hex.escape.sequence.syntax=\\x 다음에 16진수 2개가 있어야 합니다
go.error.annotator.invalid.index.or.slice.operation=잘못된 연산 {0}(문자열의 3-색인 슬라이스)
go.error.annotator.invalid.long.unicode.escape.sequence.syntax=\\U 다음에 16진수 8개가 있어야 합니다
go.error.annotator.invalid.package.name=잘못된 패키지 이름
go.error.annotator.invalid.select.assignment=select 대입은 오른쪽에 수신 연산이 있어야 합니다
go.error.annotator.invalid.select.case=select case에는 수신 연산, 송신 연산, 대입, 또는 짧은 var 선언이 필요합니다
go.error.annotator.invalid.type.assertion=잘못된 타입 어설션: {0}(왼쪽의 비 인터페이스 타입 {1})
go.error.annotator.invalid.type.switch.guard=잘못된 타입 switch 보호: {0}(왼쪽의 비 인터페이스 타입 {1})
go.error.annotator.invalid.unicode.code.point=잘못된 유니코드 코드포인트
go.error.annotator.invalid.unicode.escape.sequence.syntax=\\u 다음에 16진수 4개가 있어야 합니다
go.error.annotator.is.not.a.generic.type={0}은(는) 제네릭 타입이 아닙니다.
go.error.annotator.list.of.type.arguments.must.not.be.empty=유형 인수 목록은 비어 있을 수 없습니다
go.error.annotator.list.of.type.parameters.must.not.be.empty=타입 매개변수 목록은 비워 둘 수 없습니다.
go.error.annotator.main.or.init.has.invalid.signature=함수 {0}에는 인수와 반환 값이 포함될 수 없습니다
go.error.annotator.map.key.type.is.not.comparable=잘못된 맵 키 타입: 비교 연산자 == 및 !=는 키 타입으로 완전히 정의되어야 합니다
go.error.annotator.method.cannot.have.type.parameters=메서드는 타입 매개변수를 가질 수 없습니다
go.error.annotator.method.name.in.interface.cannot.be.blank=인터페이스의 메서드 이름은 공백일 수 없습니다
go.error.annotator.missing.argument.to.make=생성할 인수 누락
go.error.annotator.missing.condition.in.if.statement='if' 문 내 조건 누락
go.error.annotator.missing.function.body=누락된 {0} 본문
go.error.annotator.missing.key.in.map.literal=맵 리터럴의 누락된 키
go.error.annotator.missing.len.argument.to.make=make 함수 내 len 인수 누락
go.error.annotator.missing.value.in.const.declaration=상수 선언에서 값이 누락되었습니다
go.error.annotator.multiple.defaults={0} 내 여러 디폴트 값이 있습니다
go.error.annotator.multiple.value.in.single.value.context=단일 값 컨텍스트의 다중 값 {0}
go.error.annotator.named.and.unnamed.parameters=매개변수 ''{1}'' 중 이름이 있는 것과 없는 것이 {0}에 모두 있습니다
go.error.annotator.named.and.unnamed.return.parameters=반환 매개변수 ''{1}'' 중 이름이 있는 것과 없는 것이 {0}에 모두 있습니다
go.error.annotator.new.line.in.string=문자열에 새 줄이 있습니다
go.error.annotator.no.new.variables=':=' 왼쪽에 새 변수가 없습니다
go.error.annotator.non.integer.capacity.argument.to.make=make 함수 내 정수가 아닌 용량 인수
go.error.annotator.non.integer.size.argument.to.make=make 함수 내 정수가 아닌 크기 인수
go.error.annotator.octal.prefix.is.not.supported=8진 접두사는 Go 1.13부터 지원됩니다
go.error.annotator.parenthesized.expression.in.defer.or.go={0} 내 표현식은 소괄호 안에 포함되어야 합니다
go.error.annotator.problem.capacity.less.than.size.to.make=용량은 크기보다 작아야 합니다
go.error.annotator.problem.negative.capacity.to.make=make 함수 내 음수인 용량 인수
go.error.annotator.problem.negative.size.to.make=make 함수 내 음수인 크기 인수
go.error.annotator.problem.redundant.capacity.hint.to.make=불필요한 용량 힌트
go.error.annotator.problem.redundant.size.hint.to.make=불필요한 크기 힌트
go.error.annotator.reference.is.not.a.type={0}은(는) 타입이 아닙니다
go.error.annotator.semicolon.is.missing=; 누락
go.error.annotator.shadowed.receiver.is.not.a.generic.type={0}은(는) 제네릭 타입이 아닙니다(타입 매개변수가 리시버를 가립니다)
go.error.annotator.too.many.arguments.to.make=make 함수 내 인수가 너무 많음
go.error.annotator.too.many.arguments.to.new=new에 인수가 너무 많습니다
go.error.annotator.too.many.characters.in.rune.literal=rune 리터럴에 문자가 너무 많습니다
go.error.annotator.too.many.variables.in.range=범위 안에 변수가 너무 많습니다
go.error.annotator.type.aliases.are.available.since.go.1.9=타입 선언의 예기치 않은 '='. 타입 별칭은 Go 1.9부터 지원됩니다
go.error.annotator.type.cannot.be.declared.in.generic.function=제네릭 함수에서 타입을 선언할 수 없습니다.
go.error.annotator.type.cannot.be.declared.in.generic.method=제네릭 메서드에는 타입을 선언할 수 없습니다.
go.error.annotator.type.constraint.is.missing=유형 제약 조건이 없습니다.
go.error.annotator.type.is.not.an.expression=타입 ''{0}''은(는) 표현식이 아닙니다
go.error.annotator.type.parameters.are.not.supported=제네릭은 Go 1.18부터 지원됩니다
go.error.annotator.unexpected.assign.operator=예기치 않은 {0}. '':='', ''='' 또는 '','' 필요
go.error.annotator.unexpected.end.of.statement=구문 오류: 예기치 않은 구문의 종료. ':=', '=', 또는 ';' 필요
go.error.annotator.unexpected.newline.after.if=예기치 않은 줄 바꿈. 'if' 절 뒤에 '{' 필요
go.error.annotator.unexported.reference.usage=현재 패키지에서 엑스포트되지 않은 {0} ''{1}''을(를) 사용할 수 없습니다
go.error.annotator.use.of.generic.type.without.instantiation=인스턴스화 없이 제네릭 타입이 사용됨
go.error.annotator.use.of.package.without.selector=선택자 없는 패키지 ''{0}'' 사용
go.error.annotator.use.of.type.outside.type.switch=.(type)의 사용 위치가 타입 switch 외부에 있습니다
go.error.go.build.after.package=go:build 지시문은 패키지 절 앞에 와야 합니다
go.error.go.build.and.plus.build.lines.dont.match=//+build 줄이 //go:build 조건과 일치하지 않습니다
go.error.go.build.expression.is.too.complex=//+build 줄에 대한 표현식이 너무 복잡합니다
go.error.go.build.non.first.element=go:build 지시문은 줄의 첫 번째 요소여야 합니다
go.error.go.build.only.one.allowed=파일당 한 개의 //go:build 지시문만 허용됩니다
go.error.go.build.without.plus.build=//+build 주석 없는 //go:build 주석
go.error.go.embed.all.prefix.not.supported=유효하지 않은 경로 패턴입니다. 'all:' 접두사는 Go 1.18이 필요합니다
go.error.go.embed.empty.directory=빈 디렉터리를 포함할 수 없습니다
go.error.go.embed.file.must.import.embed=go:embed를 포함한 Go 파일은 "embed" 패키지를 가져와야 합니다
go.error.go.embed.invalid.path.elements=경로는 '.' 또는 '..' 경로 요소를 포함하거나 선행 슬래시로 시작할 수 없습니다
go.error.go.embed.invalid.path.pattern=잘못된 파일 패턴
go.error.go.embed.invalid.syntax.of.paths=경로 패턴의 잘못된 구문
go.error.go.embed.must.be.above.var.declaration=go:embed는 단일 전역 변수의 선언 위에 배치해야 합니다
go.error.go.embed.no.path.arguments=go:embed 뒤에 경로 패턴이 필요합니다
go.error.go.embed.not.supported=go:embed는 Go 1.16 이후 버전에서 지원됩니다
go.error.go.embed.path.must.resolve.to.file=타입 'string' 및 '[]byte'의 변수는 단일 파일만 포함할 수 있습니다
go.error.go.embed.single.path.expected=타입 'string' 및 '[]byte'의 변수는 단일 경로 패턴만 가질 수 있습니다
go.error.go.embed.unresolved.path=해결되지 않은 경로
go.error.go.embed.var.has.wrong.type=go:embed 변수는 'string', '[]byte' 또는 'embed.FS' 타입이어야 합니다
go.error.go.plus.build.can.be.converted.to.go.build=//+build 주석을 //go:build 지시문으로 변환할 수 있습니다
go.error.go.plus.build.can.be.removed=//+build 주석을 제거할 수 있습니다
go.error.invalid.double.negation=잘못된 이중 부정
go.error.invalid.non.alphanumeric.character=영숫자가 아닌 잘못된 문자
go.error.parser.expected=필요 항목: ''{0}''
go.error.parser.expected.got=''{0}''이(가) 필요하나 ''{1}''을(를) 얻었습니다
go.error.parser.expected.or=''{0}'' 또는 ''{1}''이(가) 필요합니다.
go.error.parser.expected.or.got=''{0}'' 또는 ''{1}''이(가) 필요하나 ''{2}''이(가) 있습니다
go.error.parser.unexpected=예기치 않은 ''{0}''
go.error.windows.project.wsl.sdk=WSL SDK를 사용해 Windows 프로젝트를 컴파일할 수 없습니다
go.error.wsl.project.requires.wsl.sdk=WSL의 프로젝트에는 WSL의 Go SDK가 필요합니다
go.error.wsl.project.requires.wsl.sdk.from.same.instance=WSL의 프로젝트에는 같은 WSL 인스턴스의 Go SDK가 필요합니다
go.error.wsl.project.windows.sdk=Windows SDK를 사용해 WSL 프로젝트를 컴파일할 수 없습니다
go.error.wsl.sdk.cannot.be.used.for.windows.project=WSL의 Go SDK는 Windows 프로젝트에서 사용할 수 없습니다
go.exclude.import.path.dialog.empty.path.validation.message=가져오기 경로는 공백일 수 없습니다
go.exclude.import.path.dialog.title=가져오기 경로 제외
go.exclude.import.path.from.completion.action.name=\ ''{0}'' 제외
go.execution.application.process.name=프로세스
go.execution.application.run.configuration.description=Go 빌드 실행 구성
go.execution.application.run.configuration.display.name=Go 빌드
go.execution.before.run.task.command.should.not.start.with.go.error=Go 명령어는 'go'로 시작될 수 없습니다
go.execution.before.run.task.description=''{0}'' 실행
go.execution.before.run.task.edit.go.command.dialog.title=Go 명령어 작업 편집
go.execution.before.run.task.empty.command.error=빈 Go 명령어는 허용되지 않습니다
go.execution.before.run.task.error.dialog.title=Go 명령어 작업
go.execution.before.run.task.executing.presentable.name=''{0}'' 실행 중
go.execution.before.run.task.name=Go 명령어 실행
go.execution.before.run.task.supports.only.go.modules.error=Go 명령어 작업은 활성화된 Go 통합이 있는 모듈만 지원합니다
go.execution.before.run.task.supports.only.go.run.configurations.error=Go 명령어 작업은 Go 실행 구성만 지원합니다
go.execution.can.not.run.go.local.process.error=로컬 프로세스를 실행할 수 없습니다
go.execution.cannot.create.output.file.error={0} 출력 파일을 생성할 수 없습니다
go.execution.cannot.create.output.file.in.error={0}에서 출력 파일을 생성할 수 없습니다
go.execution.cannot.create.temp.output.file.error=임시 출력 파일을 생성할 수 없습니다
go.execution.cannot.find.directory.error=디렉터리 <code>{0}</code>을(를) 찾을 수 없습니다
go.execution.cannot.find.input.file.error=입력 파일 <code>{0}</code>을(를) 찾을 수 없습니다
go.execution.cannot.find.package.error=패키지 <code>{0}</code>을(를) 찾을 수 없습니다
go.execution.cannot.find.target.error=타깃 {0}을(를) 찾을 수 없습니다
go.execution.cannot.find.target.to.compile.error=컴파일 타깃을 찾을 수 없습니다
go.execution.cannot.find.working.directory.error=<code>{0}</code> 작업 디렉터리를 찾을 수 없습니다
go.execution.cannot.make.temporary.file.executable.error=임시 실행 파일 {0}을(를) 생성할 수 없습니다
go.execution.change.goroot.action.name=GOROOT 변경
go.execution.compilation.failed.notification.title=컴파일 실패
go.execution.compilation.finished.with.exit.code=종료 코드 $EXIT_CODE$(으)로 완료된 컴파일
go.execution.compiled.binary.cannot.be.executed=컴파일된 바이너리를 실행할 수 없습니다
go.execution.could.not.bind.remote.debugging.port.error=원격 디버그 포트를 바인드할 수 없습니다
go.execution.coverage.cannot.run.coverage.on.directory.kind.run.configurations.error=디렉터리 형식의 실행 구성에서는 커버리지를 실행할 수 없습니다
go.execution.coverage.covered=포함됨
go.execution.coverage.downloading.coverage.report.progress.title=커버리지 보고서 다운로드 중…
go.execution.coverage.engine.name=Go 커버리지
go.execution.coverage.loading.coverage.data=커버리지 데이터 로드 중…
go.execution.coverage.percent.files=% 파일
go.execution.coverage.percent.statements=% 구문
go.execution.coverage.runner.name=Go
go.execution.debugger.process.name=디버거
go.execution.directory.is.not.specified.error=디렉터리가 지정되지 않았습니다
go.execution.dlv.not.found.for={0}/{1}에 대한 Delve 실행 파일을 찾을 수 없습니다. ''Help(도움말) | Edit Custom Properties(사용자 지정 프로퍼티 편집)''에 ''dlv.path=/path/to/delve''를 추가하여 Delve 위치를 지정하세요.
go.execution.dlv.not.found.for.target.platform=타깃 플랫폼에 대한 Delve 실행 파일을 찾을 수 없습니다. 'Help(도움말) | Edit Custom Properties(사용자 지정 프로퍼티 편집)'에 'dlv.path=/path/to/delve'를 추가하여 Delve 위치를 지정하세요.
go.execution.duplicate.file.error=파일이 이미 목록에 있습니다. {0}
go.execution.enter.sudo=sudo 비밀번호 입력:
go.execution.failed.to.prepare.remote.environment.error=원격 환경을 준비하지 못했습니다. {0}
go.execution.file.is.not.specified.error=파일이 지정되지 않았습니다
go.execution.file.not.found.error=파일을 찾을 수 없습니다. <code>{0}</code>
go.execution.files.must.be.in.one.directory.error=이름이 지정된 파일은 모두 하나의 디렉터리에 있어야 합니다
go.execution.go.is.not.configured.error=실행 구성에서 Go가 구성되지 않았습니다. {0}
go.execution.go.sdk.is.not.downloaded.yet=Go SDK가 아직 다운로드되지 않았습니다
go.execution.go.setup.folding.placeholder=<{0} go 설정 {0,choice,1#호출|2#호출}>
go.execution.input.file.is.not.specified.error=입력 파일이 지정되지 않았습니다
go.execution.install.lldb.notification.text=xcode-select --install을 사용하여 lldb 설치
go.execution.module.does.not.exist.error=프로젝트에 모듈 <code>{0}</code>이(가) 없습니다
go.execution.not.go.file.error=파일이 Go 파일이 아닙니다. {0}
go.execution.outdated.go.notification.text=모든 디버그 기능을 완벽하게 지원하려면 Go 버전을 업데이트하세요.
go.execution.outdated.go.notification.title=오래된 Go 버전
go.execution.package.contains.several.mains.error=패키지 <code>{0}</code>에 <code>main</code> 함수가 2개 이상 있습니다.<br>대신 파일 종류를 사용해보세요.
go.execution.package.is.not.specified.error=패키지가 지정되지 않았습니다
go.execution.process.cancelled=취소됨
go.execution.process.failed.to.run=실행 실패
go.execution.process.finished.successfully=성공적으로 완료함
go.execution.process.finished.with.exit.code=종료 코드 {0}(으)로 완료된 {0}
go.execution.process.interrupted=중단됨
go.execution.remote.run.configuration.description=Go Remote
go.execution.remote.run.configuration.display.name=Go Remote
go.execution.remote.run.configuration.host.label=호스트(&H):
go.execution.remote.run.configuration.port.label=포트(&P):
go.execution.remote.run.configuration.start.delve.text=이 구성을 실행하기 전에 아래 설명대로 애플리케이션 및 Delve를 시작하세요.<br><br>Delve가 애플리케이션을 컴파일링하도록 허용합니다.<br><pre>dlv debug --headless --listen=:{0} --api-version=2 --accept-multiclient</pre><br>또는 Go {3} 이상을 사용하여 애플리케이션을 컴파일링합니다.<br><pre>go build -gcflags "all=-N -l" github.com/app/demo</pre><br>그 후 다음 명령어를 사용해 Delve로 애플리케이션을 실행합니다.<br><pre>dlv --listen=:{1} --headless=true --api-version=2 --accept-multiclient exec ./{2}</pre>
go.execution.run.after.build.is.not.possible.incompatible.os.error=빌드 후 실행할 수 없습니다.<br>결과 바이너리가 OS와 호환되지 않습니다
go.execution.run.after.build.is.not.possible.main.not.found.many.files.error=빌드 후 실행할 수 없습니다.<br>선택한 파일 중 어느 것도 'main' 패키지 및 'main' 함수를 포함하지 않습니다
go.execution.run.after.build.is.not.possible.main.not.found.single.file.error=빌드 후 실행할 수 없습니다.<br>'main' 파일이 main이 아닌 패키지를 포함하거나 'main' 함수를 포함하지 않습니다
go.execution.run.application.tooltip=애플리케이션 실행
go.execution.scratch.runconfig.extension.different.contexts.notification=''{0}'' 실행 구성은 컨텍스트에서 다른 모듈을 사용하는 스크래치 파일을 대상으로 합니다. 컨텍스트에서 하나의 동일한 모듈을 사용하는 스크래치 파일을 대상으로 설정하세요.
go.execution.scratch.runconfig.extension.edit.notification.action=실행 구성 편집
go.execution.scratch.runconfig.extension.edit.notification.title=실행 구성의 잘못된 대상
go.execution.scratch.runconfig.extension.wrong.kind.notification=''{0}'' 실행 구성은 {1} 실행 종류를 사용합니다. 스크래치 파일은 실행 구성에서 ''File'' 실행 종류를 사용하세요.
go.execution.sdk.is.not.specified.error=모듈 <code>{0}</code>에 Go SDK가 지정되지 않았습니다
go.execution.sdk.not.set.or.sdk.home.path.empty.for.module.error=모듈에 대해 SDK가 설정되어 있지 않거나 SDK 홈 경로가 비어 있습니다
go.execution.test.collecting.build.tags.progress.title=빌드 태그 수집 중…
go.execution.unknown.error=알 수 없는 오류. 자세한 내용은 로그를 참조하세요
go.execution.unknown.target.delve.socket.error=Delve를 실행할 수 없습니다. 타깃 소켓을 알 수 없습니다. RunState: {0}
go.execution.working.directory.is.not.specified.error=작업 디렉터리가 지정되지 않았습니다.
go.external.system.auto.import.is.disabled='external.system.auto.import.disabled' 레지스트리 키가 설정되어 IDE가 올바르게 작동하지 않습니다. 이 설정을 비활성화하고 IDE를 다시 시작하세요.
go.file.watcher.go.fmt.description=Go 파일에서 'go fmt' 실행
go.file.watcher.go.imports.description=Go 파일에서 'goimports' 실행
go.file.watcher.golangci.description=현재 Go 파일 디렉터리에서 'golangci-lint' 실행
go.find.usages.of.interface.methods.dialog.base.methods.checkbox=기본 메서드(&B)
go.find.usages.of.interface.methods.dialog.message=''{0}'' 타입은 인터페이스를 구현하며 ''{1}'' 메서드는 메서드를 재정의합니다. 인터페이스 메서드의 사용 위치를 검색하시겠어요?
go.find.usages.of.interface.methods.dialog.title=인터페이스 메서드의 사용 위치를 검색하시겠어요?
go.find.usages.of.interface.methods.notification.show.options.text={0} 옵션 표시
go.find.usages.of.interface.methods.notification.title=인터페이스 메서드의 사용 위치를 검색 중
go.find.usages.show.usages.in.comments.description=주석 내 요소의 사용 위치 표시
go.find.usages.show.usages.in.comments.text=주석 내 사용 위치 표시
go.fix.add.comma.name=쉼표 추가
go.fix.add.comment.name=주석 추가
go.fix.add.explicit.dereference.name=명시적 역참조 추가
go.fix.add.function.block.name=본문 추가
go.fix.add.function.call.name=함수 호출 추가
go.fix.add.import.for.side.effects.name=부수 효과 가져오기
go.fix.add.keys.to.struct.literal.value.name=키 추가 및 제로 값 삭제
go.fix.add.local.var.for.expression.name=지역 변수 삽입
go.fix.add.missing.new.line.name=누락된 줄 바꿈 추가
go.fix.add.missing.return.value.name=누락된 반환 값 추가
go.fix.add.plus.build.comments=//+build 주석 추가
go.fix.add.pointer.name=포인터 추가
go.fix.add.prefix.to.comment.name=주석에 ''{0}'' 접두사 추가
go.fix.add.return.statement.name=return 문을 추가합니다.
go.fix.add.square.brackets=대괄호 추가
go.fix.add.whitespace.name=공백 추가
go.fix.always.false.for.name='for' 루프 제거
go.fix.always.false.if.name='if' 브랜치 제거
go.fix.always.true.for.name=불필요한 조건 제거
go.fix.always.true.if.name=다른 브랜치 제거 및 현재 'if' 문 단순화
go.fix.call.receiver.is.not.an.expression=예기치 않은 호출 리시버. 표현식이 아님
go.fix.change.array.size.to=배열 크기를 {0}(으)로 변경
go.fix.change.array.size.to.family.name=배열 크기 변경
go.fix.change.import.sorting.settings.name=정렬 설정 가져오기 변경
go.fix.change.parameters.name=매개변수 변경
go.fix.change.parameters.parameter={0,choice,0#매개변수|1#매개변수|2#매개변수}
go.fix.change.result.parameters.in.assignment.name=대입에서 결과 매개변수 변경
go.fix.change.result.parameters.in.call.name=호출에서 결과 매개변수 변경
go.fix.change.result.parameters.in.return.name=반환에서 결과 매개변수 변경
go.fix.change.result.parameters.in.variable.specification.name=변수 사양에서 결과 매개변수 변경
go.fix.change.result.parameters.name=결과 매개변수 변경
go.fix.change.result.parameters.result.parameter={0,choice,0#결과 매개변수|1#결과 매개변수|2#결과 매개변수}
go.fix.change.signature.from.function.type.name=함수 타입에서 시그니처 변경
go.fix.change.signature.from.function.type.text={0}의 시그니처 ''{1}''을(를) ({2}) ({3})(으)로 변경
go.fix.change.signature.from.usage.add=''{0}''을(를) {1,number,ordinal}번째 {2}(으)로 {3} ''{4}''에 추가
go.fix.change.signature.from.usage.change=\ {2} ''{3}''의 {0,number,ordinal} {1}을(를) ''{4}''에서 ''{5}''(으)로 변경
go.fix.change.signature.from.usage.mix={1} ''{2}''의 {0}을(를) ({3})(으)로 변경
go.fix.change.signature.from.usage.remove={2} ''{3}''에서 {0,number,ordinal}번째 {1}을(를) 제거
go.fix.change.signature.from.usage.text=사용 위치에서 시그니처 변경
go.fix.change.signature.to.expected.name=필요한 시그니처로 변경
go.fix.choose.package.name=패키지 이름 선택
go.fix.configure.go.sdk.text=Go SDK 구성
go.fix.convert.double.quoted.string.to.raw.string=큰따옴표로 묶인 문자열을 원시 문자열로 변환
go.fix.convert.int.to.rune=정수를 rune으로 변환
go.fix.convert.int.to.string.using.conversion.call={0} 호출을 사용해 정수를 문자열로 변환
go.fix.convert.plus.build.comments.to.go.build.directive=//+build 주석을 //go:build 지시문으로 변환
go.fix.convert.raw.string.to.double.quoted.string=원시 문자열을 큰따옴표로 묶인 문자열로 변환
go.fix.convert.string.to.byte.name=문자열을 바이트로 변환
go.fix.convert.to.expected.type.name=다음으로 변환
go.fix.convert.to.expected.type.text=''{0}''(으)로 변환
go.fix.convert.to.format.function.name=서식 지정 함수로 변경
go.fix.convert.to.format.function.text=서식 지정 함수로 ''{0}'' 변경
go.fix.convert.to.is.equal.name=다음으로 변환 '=='
go.fix.create.directory.text={1}에 디렉터리 {0} 생성
go.fix.create.wrapper.type.name=타입 생성
go.fix.delete.all.unused.parameters.name=사용되지 않는 매개변수 모두 삭제
go.fix.delete.ampersand.and.type.in.composite.lit.name=중복 타입 삭제
go.fix.delete.blank.argument.name=빈 인수 삭제
go.fix.delete.conversion.name=변환 삭제
go.fix.delete.conversion.with.side.effects.name=변환 삭제(의미가 변경될 수 있음)
go.fix.delete.extra.expressions.name=추가 표현식 삭제
go.fix.delete.import.name=import 문 삭제
go.fix.delete.name={0} 삭제
go.fix.delete.parameter.names.name=매개변수 이름 삭제
go.fix.delete.range.name=요소 삭제
go.fix.delete.redundant.capacity.hint.to.make=용량 인수 삭제
go.fix.delete.redundant.index.name=불필요한 색인 삭제
go.fix.delete.redundant.size.hint.to.make=크기 인수 삭제
go.fix.delete.text={0} ''{1}'' 삭제
go.fix.delete.third.index.name=세 번째 색인 삭제
go.fix.delete.type.arguments.in.index.or.slice.expr=타입 인수 삭제
go.fix.delete.type.arguments.name=타입 인수 삭제
go.fix.delete.type.parameters.name=타입 매개변수를 제거합니다
go.fix.delete.unused.parameter.name=사용되지 않는 매개변수 삭제
go.fix.drop.suffix.name=유닛용 접미사 삭제
go.fix.drop.suffix.text=유닛용 접미사 ''{0}'' 삭제
go.fix.empty.signature.name=시그니처 수정
go.fix.enable.gopath.indexing.name=GOPATH 색인 생성 활성화
go.fix.error.string.format=오류 문자열 형식 수정
go.fix.exclude.from.unhandled.inspection.name=이 메서드/함수를 더 이상 보고 안 함
go.fix.export.field.name=필드 내보내기
go.fix.export.name=내보내기
go.fix.export.text={0} 내보내기
go.fix.extract.empty.slice.to.var.declaration.name=nil 슬라이스 선언으로 바꾸기(의미 변경)
go.fix.extract.to.own.declaration.name=자체 선언으로 추출
go.fix.failed.to.handle.error=오류를 처리하지 못했습니다
go.fix.failed.to.introduce.variables.from.call=호출의 변수를 삽입하지 못했습니다
go.fix.failed.to.resolve.called.function.signature=호출의 시그니처를 해결하지 못했습니다
go.fix.failed.to.simplify.if.statement='if' 문을 단순화하지 못했습니다
go.fix.field.repeats.tag.with.value=필드 ''{1}''이(가) ''{3}'' 필드의 ''{2}'' 값을 가진 ''{1}'' 태그를 반복합니다
go.fix.field.with.the.same.tag=''{1}'' 태그가 같은 필드 ''{0}''
go.fix.finish.call.name=호출식 종료
go.fix.handle.error.name=오류 처리
go.fix.ignore.explicitly.name=명시적으로 무시
go.fix.ignore.explicitly.using.closure.name=클로저를 사용해 명시적으로 무시
go.fix.ignore.unused.call.result.name=사용되지 않는 호출 결과 무시
go.fix.implement.missing.methods.name=누락된 메서드 구현
go.fix.import.embed.package="embed" 가져오기
go.fix.insert.blank.identifiers.name=대입 구문의 왼쪽에 빈 식별자 삽입
go.fix.introduce.function.name=함수 생성
go.fix.introduce.function.text=함수 ''{0}'' 생성
go.fix.introduce.local.variable.for.expression=''{0}''에 지역 변수 삽입
go.fix.introduce.method.name=메서드 생성
go.fix.introduce.method.text=메서드 ''{0}'' 생성
go.fix.multiple.packages.command.name=패키지 이름을 {0}(으)로 변경
go.fix.multiple.packages.name=패키지 이름 변경
go.fix.multiple.packages.text=패키지 이름을 {0}(으)로 변경
go.fix.navigate.to.name=다음으로 이동
go.fix.navigate.to.text={0}(으)로 이동
go.fix.optimize.imports.name=import 문 최적화
go.fix.place.build.tag.before.package.name=패키지 전 빌드 태그 배치
go.fix.place.go.build.before.package=패키지 앞에 go:build 배치
go.fix.remove.leading.whitespace.go.directive=Go 지시문 앞에 있는 선행 공백 제거
go.fix.remove.plus.build.comments=//+build 주석 제거
go.fix.remove.redundant.bool.literal.name=다음으로 단순화
go.fix.rename.all.receivers.name=모든 리시버 이름 변경
go.fix.rename.all.receivers.text=모든 리시버 이름을 ''{0}''(으)로 변경
go.fix.rename.to.blank=_로 이름 변경
go.fix.rename.to.name=다음으로 이름 변경
go.fix.rename.to.text=''{0}''(으)로 이름 변경
go.fix.replace.and.return=''{0}'' 및 ''return''으로 바꾸기
go.fix.replace.assign.with.equals.name=':='을 '='로 바꾸기
go.fix.replace.equality.check.with.errors.is=상등 검사를 'errors.ls'로 바꾸기
go.fix.replace.equals.with.assign.name=':='로 바꾸기
go.fix.replace.expression.name=앞에 '\\&' 추가
go.fix.replace.field.type.with.pointer={0,choice,0#필드|1#필드|2#필드} ''{1}'' 타입을 포인터로 바꾸기
go.fix.replace.switch.on.errors.with.errors.is='errors.ls'를 사용하도록 switch 구문을 업데이트
go.fix.replace.switch.on.types.with.errors.as='errors.As'를 사용하도록 타입 switch를 업데이트
go.fix.replace.switch.on.types.with.errors.as.error.hint.message=타입 가드 변수 및 하나 이상의 case 절이 있는 경우 타입 switch를 오류 발생 시 'erros.As'로 대체할 수 없습니다
go.fix.replace.switch.on.types.with.errors.as.error.hint.title=타입 스위치를 오류 발생 시 'errors.As'로 대체할 수 없습니다
go.fix.replace.tilda.with.hat.name='~'를 '^'로 바꾸기
go.fix.replace.type.assertion.with.errors.as=타입 어설션을 'errors.As'로 대체
go.fix.replace.type.assertion.with.errors.as.hint.message=타입 어설션의 ok 결과가 if 조건 내에서 1회 이상 사용되는 경우 타입 어설션을 'errors.As'로 대체할 수 없습니다. 이 액션을 실행하기 전에 식을 더 간소화하세요.
go.fix.replace.type.assertion.with.errors.as.hint.title=타입 어설션을 'errors.As'로 대체할 수 없습니다
go.fix.replace.with.correct.defer.name=올바른 defer 구문으로 바꾸기
go.fix.replace.with.name=다음으로 바꾸기
go.fix.replace.with.nil.with.side.effects.name=nil로 바꾸기(의미 변경)
go.fix.replace.with.text=''{0}''(으)로 바꾸기
go.fix.searching.for.usages.progress.title=사용 위치 검색 중…
go.fix.signature.name=시그니처 수정
go.fix.simplify.bool.expr.name=표현식 단순화
go.fix.simplify.expression.to.boolean.literal.name=조건 단순화
go.fix.simplify.something.to.text=''{0}''을(를) ''{1}''(으)로 단순화
go.fix.simplify.to.text=\ ''{0}''(으)로 단순화
go.fix.sort.imports=가져오기 정렬
go.fix.suppress.all.inspections.for.text={0}에 대한 모든 검사 억제
go.fix.suppress.inspection.for.text={0}에 대해 억제
go.fix.unpack.slice.name=슬라이스 패킹 해제
go.fix.unwrap.parens.name=소괄호 줄 바꿈 해제
go.fix.update.plus.build.comments=//+build 주석 업데이트
go.fix.uppercase.type.parameter.name=타입 매개변수에 대문자 사용
go.fix.uppercase.type.parameter.text=타입 매개변수 ''{0}''에 대문자 사용
go.fix.view.all.duplicates.name=중복 이름 보기
go.fix.view.all.duplicates.targets.code.usages.string=발견된 중복
go.fix.view.all.duplicates.targets.tab.text=''{0}'' 중복
go.fix.view.all.duplicates.targets.tool.window.title={1} 내 {0}
go.fix.view.all.duplicates.text=''{0}''의 중복 이름 보기
go.fix.wrap.error.handling.in.closure=클로저 안에 오류 처리 래핑
go.fmt.add.leading.space.to.comments=주석에 선행 공백 추가
go.fmt.add.parentheses.for.single.import=단일 import 문에 소괄호 추가
go.fmt.create.local.group.label=그룹
go.fmt.fill.paragraph.width.label=단락 모양의 열 너비:
go.fmt.for.current.project.packages=현재 프로젝트 패키지
go.fmt.for.imports.starting.with.prefix=다음으로 시작하는 import 문:
go.fmt.for.imports.starting.with.prefix.comment='goimports -local'과 동일한 접두사를 쉼표로 구분한 목록
go.fmt.formatting.service.error.title={0}에서 gofmt를 실행할 수 없음
go.fmt.group.stdlib.imports=Go SDK의 그룹 패키지
go.fmt.import.sorting.type=정렬 타입
go.fmt.imports.prefix.error.empty.message=import 문 접두사는 공백일 수 없습니다
go.fmt.imports.prefix.error.title=잘못된 import 문 접두사
go.fmt.imports.tab.title=가져오기
go.fmt.move.all.imports.in.single.declaration=단일 선언의 모든 import 문 이동
go.fmt.move.all.stdlib.imports.in.single.group=모든 패키지를 단일 그룹으로 이동
go.fmt.remove.redundant.import.aliases=불필요한 import 문의 별칭 제거
go.fmt.run.gofmt.on.code.reformat.label='코드 서식 다시 지정' 액션 시
go.fmt.run.gofmt.panel.border.title=gofmt 실행
go.fmt.use.back.quotes.for.imports=import 문에 역따옴표 사용
go.format.playground.could.not.format.message=코드의 서식을 지정할 수 없습니다
go.generate.type.from.json.dialog.json.label=이곳에 JSON 배치:
go.generate.type.from.json.dialog.ok.label=생성
go.generate.type.from.json.dialog.title=JSON에서 Go 타입 생성
go.generate.type.from.json.error.invalid.json=잘못된 JSON에서 Go 타입을 생성할 수 없습니다
go.generate.type.from.json.error.no.top.value=JSON에는 단일 최상위 값이 필요합니다
go.generate.type.from.json.on.paste.dialog.title=JSON에서 Go 타입 생성
go.generate.type.from.json.on.paste.struct.fields.message=삽입된 텍스트는 JSON으로 보입니다. 이 텍스트에서 구조체 필드를 생성하시겠어요?
go.generate.type.from.json.on.paste.type.message=삽입된 텍스트는 JSON으로 보입니다. 이 텍스트에서 Go 타입을 생성하시겠어요?
go.generate.type.from.json.properties.on.paste.struct.fields.message=삽입된 텍스트는 JSON 프로퍼티 시퀀스처럼 보입니다. 이 텍스트에서 구조체 필드를 생성하시겠어요?
go.generate.type.from.json.properties.on.paste.type.message=삽입된 텍스트는 JSON 프로퍼티 시퀀스처럼 보입니다. 이 텍스트에서 Go 타입을 생성하시겠어요?
go.get.package.fix.family.name='go get' 실행
go.go.inspection.problem.replace.can.be.migrated=Go 작업공간으로 마이그레이션할 수 있습니다
go.go.mod.error.annotator.missing.dependency=종속성 누락
go.go.mod.error.annotator.multiple.module.statements=파일에 여러 모듈 구문이 있습니다
go.go.mod.error.annotator.multiple.version.statements=파일에 여러 go 버전 구문이 있습니다
go.go.mod.error.annotator.no.module.statement=파일에 모듈 구문이 없습니다
go.go.mod.error.annotator.unresolved.dependency=해결되지 않는 종속성
go.go.mod.error.module.version.expected=모듈 버전이 필요합니다
go.go.mod.error.prohibited.directive=go.mod 파일에서 지시문은 쓸 수 없습니다
go.go.mod.retract.not.supported='retract'는 Go 1.16부터 지원됩니다
go.go.mod.retract.wrong.range.format=버전 범위의 형식은 '[start, end]'여야 합니다
go.go.mod.toolchain.not.supported='toolchain'은 Go 1.21부터 지원됩니다
go.go.work.error.prohibited.directive=go.work 파일에서 지시문은 쓸 수 없습니다
go.go.work.error.unresolved.path=해결되지 않은 경로
go.go.work.multiple.use.directives=여러 'use' 지시문을 하나로 병합할 수 있습니다.
go.ignore.template.plugin.action.text=이 프로젝트의 플러그인 무시
go.import.optimizer.removed.aliases={0} 개의 {0,choice,1#별칭|2#별칭}이 제거되었습니다
go.import.optimizer.removed.imports={0} 개의 {0,choice,1#import 문|2#import 문}이 제거되었습니다
go.import.optimizer.removed.imports.and.aliases={0}개의 {0,choice,1#import 문|2#import 문} 및 {1}개의 {1,choice,1#별칭|2#별칭}이 제거되었습니다
go.import.package.cannot.invoke.fix.with.ambiguous.imports.error=에디터 {0}에서 모호한 가져오기로 수정을 호출할 수 없습니다. 패키지: {1}
go.import.package.fix.family.name=패키지 가져오기
go.import.package.fix.text=패키지 가져오기
go.import.package.fix.text.many.variants={0}을(를) 가져오시겠어요?(다중 선택...)
go.import.package.fix.text.no.variants=패키지를 가져오시겠어요?
go.import.package.fix.text.single.variant={0}을(를) 가져오시겠어요?
go.import.package.popup.title=가져올 패키지
go.index.entire.gopath.checkbox=전체 GOPATH 색인 생성
go.index.entire.gopath.tooltip=비활성화 상태에서는 프로젝트 및 벤더링된 패키지만 색인 생성됩니다.<br/>따라서 전반적인 성능이 향상되지만 GOPATH 패키지를 사용할 수 없습니다.
go.init.with.zero.value=제로 값으로 초기화
go.inlays.display.constant.definition=상수 정의 값 표시
go.inlays.show.return.parameters.option=반환 매개변수 표시
go.inlays.show.unnamed.fields.in.structure.values.option=구조 값 내 이름 없는 필드 표시
go.inspection.ambiguous.reference.message=모호한 참조 {0}
go.inspection.assignment.nil.without.explicit.type.message=명시적 타입이 없는 nil을 대입할 수 없습니다
go.inspection.assignment.to.receiver.display.name=리시버에 대입
go.inspection.bool.condition.display.name=bool 조건
go.inspection.change.context.todo=명확하게 정의된 컨텍스트 사용 고려
go.inspection.comment.has.no.leading.space.display.name=주석에 선행 공백이 없습니다
go.inspection.comment.of.exported.element.starts.with.incorrect.name.display.name=내보낸 요소의 주석이 잘못된 이름으로 시작됨
go.inspection.comment.should.be.meaningful.message=주석은 의미 있어야 하며 그렇지 않으면 제거되어야 합니다
go.inspection.comment.should.be.without.article.message=댓글이 ''{0} ...'' 형식이어야 합니다(선택적 선행 아티클 포함)
go.inspection.comment.should.have.package.prefix.message=패키지 주석이 ''Package {0} ...'' 양식이어야 합니다
go.inspection.convert.string.literals.display.name=문자열 리터럴 변환
go.inspection.defer.go.statement.calls.recover.or.panic.directly.display.name=Defer/go 문은 'recover' 또는 'panic'을 직접 호출합니다
go.inspection.defer.in.loop.display.name=루프 내 'defer'
go.inspection.defer.or.go.should.not.call.function.message={0}은(는) {1}을(를) 직접 호출할 수 없습니다
go.inspection.deprecated.element.display.name=곧 사용할 수 없게 될 요소
go.inspection.direct.comparison.of.errors.display.name=오류의 직접 비교
go.inspection.discarded.context.cancel.function=컨텍스트 누수를 피하기 위해 cancel 함수를 삭제하지 말고 호출해야 합니다
go.inspection.division.by.zero.display.name=0으로 나누기
go.inspection.empty.declaration.display.name=빈 선언
go.inspection.empty.declaration.message=빈 선언 {0}
go.inspection.empty.slice.declared.via.literal.display.name=리터럴을 사용해 선언된 빈 슬라이스
go.inspection.error.string.should.not.be.capitalized.or.end.with.punctuation.display.name=오류 문자열은 대문자로 처리하거나 문장 부호로 끝낼 수 없음
go.inspection.exceeded.shift.expression.display.name=초과된 시프트 표현식
go.inspection.execution.ends.without.context.cancel.function.after.instruction=''{0}'' 함수를 호출하지 않고 이 지침 뒤에 실행이 종료될 수 있으며 이로 인해 컨텍스트 누수가 발생합니다
go.inspection.execution.ends.without.context.cancel.function.after.statement=''{1}'' 함수를 호출하지 않고 이 ''{0}'' 구문 뒤에 실행이 종료될 수 있으며 이로 인해 컨텍스트 누수가 발생합니다
go.inspection.expected.colon.after.key=키 뒤에 ':' 필요
go.inspection.expected.opening.double.quote.character.after.colon=':' 뒤에 여는 큰따옴표 문자 필요
go.inspection.explicit.dereference.accessing.field.message={1}(타입 {2})의 필드 {0}에 액세스하려면 명시적 역참조가 필요합니다
go.inspection.explicit.dereference.calling.method.with.receiver.message=리시버 {1}(타입 {2})이(가) 있는 메서드 {0}을(를) 호출하려면 명시적 역참조가 필요합니다
go.inspection.exported.element.should.have.comment.display.name=내보낸 요소에 주석이 포함되어야 함
go.inspection.exported.element.should.have.its.own.declaration.display.name=내보낸 요소에 자체 선언이 포함되어야 함
go.inspection.extended.method.expression.syntax.before.go.1.10.message=예기치 않은 리시버 타입. 확장된 메서드 표현식 구문은 Go 1.10부터 사용 가능합니다
go.inspection.fail.now.called.from.non.test.goroutine=이 메서드는 테스트나 벤치마크를 실행하는 고루틴에서 호출되어야 합니다
go.inspection.fail.now.in.non.test.goroutine=비 테스트 고루틴 내 'FailNow'
go.inspection.function.returns.without.calling.context.cancel.function=이 cancel 함수를 호출하지 않는 실행 경로가 있으며 이로 인해 컨텍스트 누수가 발생합니다
go.inspection.imported.package.name.as.name.identifier.display.name=이름 식별자로서 가져온 패키지 이름
go.inspection.impossible.interface.type.assertion=불가능한 인터페이스 타입 어설션
go.inspection.incorrect.call.to.unmarshal.display.name='Unmarshal'이 올바르지 않은 인수와 함께 호출됨
go.inspection.incorrect.strings.replace.count.argument.display.name=잘못된 'strings.Replace' 계산 인수
go.inspection.incorrect.usage.of.printf.display.name=잘못된 'fmt.Printf' 및 'fmt.Println' 함수 사용
go.inspection.incorrect.usage.of.the.errors.as.function.display.name='errors.As' 함수의 잘못된 사용
go.inspection.incorrect.usage.of.the.sync.atomic.display.name=잘못된 'sync/atomic' 패키지 사용
go.inspection.infinite.for.loop.display.name=무한 'for' 루프
go.inspection.int.to.string.conversion=정수에서 문자열로 타입 변환
go.inspection.invalid.conversions.of.uintptr.to.unsafe.Pointer='uintptr'을 'unsafe.Pointer'로 변환할 수 없음
go.inspection.key.is.empty.or.starts.from.incorrect.symbol=키가 비어 있거나 올바르지 않은 심볼에서 시작
go.inspection.key.is.not.separated.by.space.from.previous.pair=키가 이전 쌍과 공백으로 구분되어 있지 않음
go.inspection.leading.whitespace.in.directive.comment=지시문 주석에 선행 공백
go.inspection.locks.mistakenly.passed.by.value=값에 의해 실수로 전달된 잠금
go.inspection.loop.closure.display.name=함수 리터널에 의해 캡처된 루프 변수
go.inspection.loop.closure.message=<code>{0}</code> 문에서 <code>func</code> 리터럴에 사용된 루프 변수가 예기치 않은 값을 가질 수 있습니다
go.inspection.lost.cancel='context.CancelFunc'이 호출되지 않았습니다
go.inspection.malformed.build.tag.display.name=형식이 잘못된 빌드 태그
go.inspection.malformed.struct.tag.display.name=형식이 잘못된 구조체 태그
go.inspection.missing.closing.double.quote.character.in.value=값에서 닫는 큰따옴표 문자 누락
go.inspection.missing.trailing.comma.before.newline.in.composite.literal.display.name=복합 리터럴의 줄 바꿈 앞에 후행 쉼표 누락
go.inspection.mixed.receiver.types=구조체 {0}에 값 및 포인터 리시버에 대한 메서드가 있습니다. 이러한 사용 위치는 Go 문서에서 권장하지 않습니다.
go.inspection.mixed.receiver.types.display.name=혼합 값 및 포인터 리시버
go.inspection.name.starts.with.package.name.display.name=이름이 패키지 이름으로 시작됨
go.inspection.nilness.analyzer.display.name=Nilness Analyzer
go.inspection.non-standard.signature.for.well.known.function.names.display.name=잘 알려진 함수 이름의 비표준 시그니처
go.inspection.options.panel.exclude=제외:
go.inspection.options.panel.function.name=함수 이름
go.inspection.options.panel.import.path=가져오기 경로
go.inspection.options.panel.method.name=메서드 이름
go.inspection.options.panel.receiver=리시버
go.inspection.options.panel.reported.functions=보고된 함수/메서드:
go.inspection.options.panel.string.methods=문자열 메서드:
go.inspection.possible.misuse.of.unsafe.pointer={0}이(가) 잘못 사용되었을 수 있음
go.inspection.problem.accessing.field.may.lead.to.nil.pointer.dereference=필드 {0}이(가) 액세스되면 nil 포인터 역참조가 발생할 수 있습니다
go.inspection.problem.argument.causes.recursive.call.to.string.method=인수 {0}(으)로 인해 {1} 메서드에 재귀 호출이 발생합니다
go.inspection.problem.argument.is.not.a.function.call=인수 {0}이(가) 함수 호출이 아닙니다
go.inspection.problem.assignment.copies.lock.value=대입이 lock 값을 {0}에 복사합니다. {1}
go.inspection.problem.assignment.to.entry.may.panic.because.of.nil.map={0} 맵으로 인해 항목에 대입하면 panic이 발생할 수 있습니다
go.inspection.problem.assignment.to.method.receiver.doesnt.propagate=메서드 리시버 대입은 다른 호출로 전달되지 않습니다
go.inspection.problem.assignment.to.method.receiver.propagates.only.to.callees=메서드 리시버 대입은 호출자가 아닌 피호출자에만 전달됩니다
go.inspection.problem.assignment.used.as.value={0}이(가) 값으로 사용됩니다
go.inspection.problem.at.is.not.allowed.in.import.paths=@은 가져오기 경로에서 허용되지 않습니다
go.inspection.problem.bad.count.argument.of.strings.replace={0}의 Count 인수는 {1}일 수 없습니다
go.inspection.problem.bad.error.string=오류 문자열은 대문자로 처리되거나 문장 부호 표시로 끝날 수 없습니다
go.inspection.problem.build.constraints.exclude.all.go.files=빌드 제약은 {0} 내 모든 Go 파일을 제외합니다
go.inspection.problem.call.copies.lock.value={0} 호출이 lock 값을 복사합니다. {1}
go.inspection.problem.cannot.assign.in.multiple.assignment=여러 대입에서 {0}을(를) {1}에 대입할 수 없습니다
go.inspection.problem.cannot.assign.value.to.blank.field=값을 빈 필드에 대입할 수 없습니다
go.inspection.problem.cannot.assign.value.to.unexported.field=내보내지 않은 필드 {0}에 값을 대입할 수 없습니다
go.inspection.problem.cannot.call.non.function=타입이 {1}인 비 함수 {0}을(를) 호출할 수 없습니다
go.inspection.problem.cannot.convert.constant=잘못된 연산: {0}(상수 {1}을(를) 타입 {2}(으)로 변환할 수 없습니다)
go.inspection.problem.cannot.convert.expression=타입 {0} 표현식을 타입 {1}(으)로 변경할 수 없습니다
go.inspection.problem.cannot.convert.known.value.to.type={0}을(를) {1}(으)로 변환할 수 없습니다
go.inspection.problem.cannot.convert.nil=''nil''을 타입 {0}(으)로 변환할 수 없습니다
go.inspection.problem.cannot.convert.nil.to.type={0}을(를) 타입 {1}(으)로 변환할 수 없습니다
go.inspection.problem.cannot.convert.value.to.type=값을 {0}(으)로 변환할 수 없습니다
go.inspection.problem.cannot.import={0}을(를) 가져올 수 없습니다
go.inspection.problem.cannot.import.absolute.path=절대 경로를 가져올 수 없습니다
go.inspection.problem.cannot.import.builtin.package='builtin' 패키지를 가져올 수 없습니다
go.inspection.problem.cannot.range=범위가 {0}을(를) 초과할 수 없습니다
go.inspection.problem.cannot.rename.import.c=import 'C'의 이름을 변경할 수 없습니다
go.inspection.problem.cannot.slice={0}(타입 {1})을(를) 슬라이스할 수 없습니다
go.inspection.problem.cannot.take.address={0}의 주소를 가져올 수 없음
go.inspection.problem.cannot.take.address.of.non.addressable.operand=주소를 지정할 수 없는 피연산자의 주소를 가져올 수 없습니다
go.inspection.problem.cannot.use.underscore.as.value={0}을(를) 값으로 사용할 수 없습니다
go.inspection.problem.comment.should.start.with.whitespace=주석은 공백으로 시작해야 합니다
go.inspection.problem.comparison.with.errors.using.equality.fails.on.wrapped.errors=상등 연산자를 사용하여 오류를 직접 비교하면 래핑된 오류에서 실패합니다
go.inspection.problem.condition.is.always.true.or.false=조건 {0}이(가) 항상 {1}입니다
go.inspection.problem.condition.is.always.true.or.false.because.of.nil={1}이(가) 항상 {2}이기 때문에 조건이 항상 {0}입니다
go.inspection.problem.condition.is.always.true.or.false.because.of.not.nil={1}이(가) 항상 {2}이(가) 아니기 때문에 조건이 항상 {0}입니다
go.inspection.problem.contains=포함
go.inspection.problem.conversion.from.int.to.string={0}을(를) {1}(으)로 변환하면 정수 값을 코드 포인트로 해석합니다
go.inspection.problem.convert.string.literals=문자열 리터럴 변환
go.inspection.problem.corresponding.error.may.be.not.nil=해당 오류 변수가 {2}이(가) 아닐 수 있으므로 {0}에 {1} 또는 다른 예기치 않은 값이 있을 수 있습니다
go.inspection.problem.declaration.shadows.declaration={0}의 선언이 선언을 가립니다
go.inspection.problem.declaration.shadows.declaration.at={0}의 선언이 {1}의 선언을 가립니다
go.inspection.problem.defer.is.called.in.a.for.loop=리소스 누수가 있을 가능성이 있습니다. {0}이(가) {1} 루프에서 호출됩니다
go.inspection.problem.deprecated.is.still.used=곧 사용할 수 없게 될 {0}이(가) 계속 사용되고 있습니다
go.inspection.problem.direct.assignment.to.atomic.value=atomic 값에 직접 대입
go.inspection.problem.division.by.zero=0으로 나누기
go.inspection.problem.duplicate.argument=인수 {0} 중복
go.inspection.problem.duplicate.case=case {0} 중복
go.inspection.problem.duplicate.field=필드 {0} 중복
go.inspection.problem.duplicate.index=색인 중복: {0}
go.inspection.problem.duplicate.key.in.map.literal=맵 리터럴 내 키 {0} 중복
go.inspection.problem.duplicate.method=메서드 {0} 중복
go.inspection.problem.duplicate.type.param=타입 매개변수 중복: {0}
go.inspection.problem.eliminate.snake.case=스네이크 표기법 제거
go.inspection.problem.empty.interface.usage='interface{}'를 타입으로 사용
go.inspection.problem.empty.slice.declaration.via.literal=리터럴을 사용한 빈 슬라이스 선언
go.inspection.problem.example.for.unknown.field.or.method=예시가 알 수 없는 필드 또는 메서드를 참조: {0}.{1}
go.inspection.problem.example.for.unknown.identifier=예시가 알 수 없는 식별자를 참조: {0}
go.inspection.problem.exported.const.should.have.its.own.declaration=내보낸 상수 {0}에 자체 선언이 있어야 합니다
go.inspection.problem.exported.element.should.have.comment=내보낸 {0} {1}은(는) 주석이 있거나 내보내지 않아야 합니다
go.inspection.problem.exported.function.with.unexported.return.type=내보내지 않은 반환 타입이 있는 내보낸 {0}
go.inspection.problem.exported.var.should.have.its.own.declaration=내보낸 변수 {0}에 자체 선언이 있어야 합니다
go.inspection.problem.expression.can.be.simplified=표현식을 단순화할 수 있습니다
go.inspection.problem.expression.can.be.simplified.to.other={0}을(를) {1}(으)로 단순화할 수 있습니다
go.inspection.problem.expression.is.always.true.or.false=표현식 {0}이(가) 항상 {1}입니다
go.inspection.problem.expression.is.too.small.for.shift={0}({1} 비트)이(가) {2} 시프트로 너무 작습니다
go.inspection.problem.expression.with.type={0}(타입 {1})
go.inspection.problem.fields.are.assigned.without.explicit.names=필드가 명시적 이름 없이 대입되었습니다
go.inspection.problem.fmt.parameter.with.non.integer.expression={0,choice,0#너비|1#정확도|2#동사}가 정수가 아닌 표현식 {1}(으)로 지정되었습니다{2}
go.inspection.problem.found.several.packages={1}에서 여러 패키지[{0}]가 발견되었습니다
go.inspection.problem.function.call.may.lead.to.nil.pointer.dereference=함수 호출 {0}(으)로 인해 nil 포인터 역참조가 발생할 수 있습니다
go.inspection.problem.function.does.not.take.writer=함수는 {0}을(를) 가질 수 없는데 첫 번째 인수가 {1}입니다
go.inspection.problem.function.passes.lock.by.value={0}이(가) 값으로 lock을 전달합니다. {1}
go.inspection.problem.fuzzing.is.not.supported=퍼징은 Go 1.18부터 지원됩니다
go.inspection.problem.go.plus.build.empty.tag='+build' 주석에 'ignore' 태그와 동일한 빈 태그가 포함되어 있습니다
go.inspection.problem.imports.are.not.sorted=import 문이 정렬되지 않았습니다
go.inspection.problem.impossible.interface.assertion={0}에서 {1}(으)로의 인터페이스 어설션은 불가능합니다. 모호함: {2}
go.inspection.problem.impossible.type.assertion=불가능한 타입 어설션: {0}이(가) {1}을(를) 구현하지 않습니다
go.inspection.problem.impossible.type.switch.case=불가능한 타입 switch case: {0}이(가) {1}을(를) 구현하지 않습니다
go.inspection.problem.incompatible.empty.type.set=<b color={1}>제약 타입 세트가 비어 있으므로</b> 타입이 {0} 제약을 구현하지 않습니다
go.inspection.problem.incompatible.method.has.pointer.receiver=<b color={1}>{2} 메서드가 포인터 리시버</b>이므로 타입이 {0}을(를) 구현하지 않습니다
go.inspection.problem.incompatible.need.method.have.method=타입이 {0}을(를) 구현하지 않습니다<br/><b color={1}>필요 메서드: {2}<br/>현재 메서드: {3}</b>
go.inspection.problem.incompatible.not.comparable=<b color={1}>타입이 호환되지 않으므로</b> {0} 제약을 구현하지 않습니다
go.inspection.problem.incompatible.not.in.type.set=<b color={1}>타입이 타입 세트({2})에 포함되지 않으므로</b> {0} 제약을 구현하지 않습니다
go.inspection.problem.incompatible.types={0}을(를) 타입 {1}(으)로 사용할 수 없습니다
go.inspection.problem.incompatible.types.ambiguous.methods=<b color={1}>{2}이(가) 모호</b>하여 타입이 {0}을(를) 구현하지 않습니다
go.inspection.problem.incompatible.types.in.switch=switch 내 잘못된 case {0}{1}
go.inspection.problem.incompatible.types.in.switch.on.expression={1}의 switch 내 잘못된 case {0}{2}
go.inspection.problem.incompatible.types.some.methods.are.missing=<b color={1}>일부 메서드가 누락되어</b> 타입이 {0}을(를) 구현하지 않습니다.<br/>{2}
go.inspection.problem.incompatible.unexported.method=<b color={1}>내보내기되지 않은 메서드가 포함되고 다른 패키지에 정의</b>되어 있기 때문에 타입이 {0}을(를) 구현할 수 없습니다
go.inspection.problem.index.must.be.a.non.negative.integer.constant=색인 {0}이(가) 양의 상수여야 합니다
go.inspection.problem.index.out.of.bounds=색인이 범위를 벗어납니다. {0}
go.inspection.problem.index.zero.is.illegal=색인 값 [0]이(가) 잘못되었습니다{0}
go.inspection.problem.indexing.may.panic.because.of.nil.slice={0} 슬라이스로 인해 색인 생성 시 panic이 발생할 수 있습니다
go.inspection.problem.infinite.for.loop=무한 {0} 루프
go.inspection.problem.invalid.argument.must.be.complex.type=복합 타입이어야 합니다
go.inspection.problem.invalid.argument.must.be.send.channel.type=양방향이거나 보내기 전용 채널이어야 합니다
go.inspection.problem.invalid.composite.literal.type=잘못된 복합 리터럴 타입: {0}
go.inspection.problem.invalid.conversion=잘못된 변환
go.inspection.problem.invalid.conversion.type.comparable=변환에서 비교할 수 있는 인터페이스를 사용할 수 없음
go.inspection.problem.invalid.conversion.type.with.constraints=변환에서 유형 제약이 있는 인터페이스를 사용할 수 없음
go.inspection.problem.invalid.field.name=잘못된 필드 이름
go.inspection.problem.invalid.inc.dec.operation=잘못된 연산: {0}(비 숫자 타입 {1})
go.inspection.problem.invalid.indirect=잘못된 {0}({1} 타입) 간접 참조
go.inspection.problem.invalid.iterable.index=잘못된 {0} 색인 {1}({2})
go.inspection.problem.invalid.low.high.indices=잘못된 색인 값. low <= high여야 합니다
go.inspection.problem.invalid.low.high.max.indices=잘못된 색인 값. low <= high <= max여야 합니다
go.inspection.problem.invalid.operation.mismatched.types=잘못된 연산: {0} (일치하지 않는 타입 {1}와(과) {2})
go.inspection.problem.invalid.receiver.interface.type=인터페이스 타입
go.inspection.problem.invalid.receiver.nonlocal.type=비 로컬 타입
go.inspection.problem.invalid.receiver.pointer.type=포인터 타입
go.inspection.problem.invalid.receiver.type=잘못된 리시버 타입 {0}({1}은(는) {2}입니다)
go.inspection.problem.invalid.receiver.unnamed.type=이름 없는 타입
go.inspection.problem.invalid.recursive.type=잘못된 재귀 {0} {1}{2}
go.inspection.problem.invalid.second.argument.to.errors.as={0}의 두 번째 인수가 인터페이스 또는 오류 인터페이스를 구현하는 타입의 포인터여야 합니다
go.inspection.problem.invalid.slice.index=유효하지 슬라이스 색인 {0}({1})
go.inspection.problem.invalid.unary.operation=잘못된 연산: {0}
go.inspection.problem.invalid.use.of.triple.dot=잘못된 '...' 사용. 해당하는 매개변수가 비가변적입니다
go.inspection.problem.irregular.iota.usage='iota'의 변칙적 사용 위치
go.inspection.problem.label.already.defined=라벨 {0}이(가) 이미 정의되어 있습니다
go.inspection.problem.last.argument.ends.with.redundant.newline={0}의 마지막 인수가 불필요한 줄 바꿈으로 끝납니다
go.inspection.problem.leading.whitespace.in.directive.comment=Go 지시문은 // 바로 뒤에 와야 하며 사이에 공백이 없어야 합니다(예: //go:embed)
go.inspection.problem.literal.copies.lock.value=리터럴이 lock 값을 {0}에 복사합니다. {1}
go.inspection.problem.malformed.benchmark.name=형식이 잘못된 벤치마크 이름: 'Benchmark' 뒤 첫 문자는 소문자여야 합니다
go.inspection.problem.malformed.example.suffix=형식이 잘못된 예시 이름: 접미사 {0}이(가) 소문자로 시작해야 합니다
go.inspection.problem.malformed.test.name=형식이 잘못된 테스트 이름: 'Test' 뒤 첫 문자는 소문자여야 함
go.inspection.problem.method.call.may.lead.to.nil.pointer.dereference=메서드 호출 {0}(으)로 인해 nil 포인터 역참조가 발생할 수 있습니다
go.inspection.problem.method.has.non.standard.signature=메서드 {0}에 시그니처 {1}이(가) 있어야 합니다
go.inspection.problem.method.has.non.standard.signature.unwrap=메서드 {0}은(는) 시그니처 <code>Unwrap() error</code> 또는 <code>Unwrap() []error</code>가 있어야 합니다
go.inspection.problem.method.redeclared=메서드가 {0}을(를) 다시 선언합니다
go.inspection.problem.mismatched.types=\ (일치하지 않는 타입 {0} 및 {1})
go.inspection.problem.mismatched.types.byte.and.string=일치하지 않는 타입: 바이트 및 문자열
go.inspection.problem.missing.argument.to.conversion={0}(으)로의 변환을 위한 인수가 누락되었습니다. {1}
go.inspection.problem.missing.expression=표현식 누락
go.inspection.problem.missing.key.in.map.literal=맵 리터럴 내 키 누락
go.inspection.problem.missing.return=함수 끝에 'return' 문 누락
go.inspection.problem.missing.type.in.composite.literal=복합 리터럴 내 타입 누락
go.inspection.problem.mixture.of.field=필드 혼용: 값 및 값 이니셜라이저
go.inspection.problem.multiple.packages.in.directory=디렉터리 내 여러 패키지: {0}
go.inspection.problem.must.be.imported.as={0}(으)로 가져와야 합니다
go.inspection.problem.must.be.non.negative=음수가 아니어야 합니다
go.inspection.problem.must.be.of.integer.type=정수 타입이어야 합니다
go.inspection.problem.must.be.representable.by.int=값을 'int' 타입으로 표시할 수 있어야 합니다
go.inspection.problem.name.collides.with.builtin={0} {1}이(가) ''builtin'' {2}와(과) 충돌합니다
go.inspection.problem.name.collides.with.imported.package={0} {1}이(가) 가져온 패키지 이름과 충돌합니다
go.inspection.problem.name.collides.with.name.declared.in.this.package={0}이(가) 이 패키지에 선언된 이름과 충돌합니다
go.inspection.problem.name.redeclared.as.imported.package={0}이(가) 가져온 패키지 이름으로 다시 선언되었습니다
go.inspection.problem.name.redeclared.in.this.block={0}이(가) 이 블록에서 다시 선언되었습니다
go.inspection.problem.name.redeclared.in.this.function={0}이(가) 이 함수에서 다시 선언되었습니다
go.inspection.problem.name.redeclared.in.this.package={0}이(가) 이 패키지에서 다시 선언되었습니다
go.inspection.problem.name.starts.with.package.name=이름이 패키지 이름으로 시작됩니다
go.inspection.problem.need.trailing.comma.in.argument.list=인수 목록에는 줄 바꿈 전에 후행 쉼표가 필요합니다
go.inspection.problem.need.trailing.comma.in.composite.literal=복합 리터널에는 줄 바꿈 전에 후행 쉼표가 필요합니다
go.inspection.problem.need.trailing.comma.in.index.expression=색인 표현식에는 줄 바꿈 전에 후행 쉼표가 필요합니다
go.inspection.problem.need.trailing.comma.in.parameter.list=매개변수 목록에는 줄 바꿈 전에 후행 쉼표가 필요합니다
go.inspection.problem.need.trailing.comma.in.type.arguments.list=유형 인수 목록에는 줄 바꿈 전에 후행 쉼표가 필요합니다
go.inspection.problem.need.trailing.comma.in.type.parameters.list=유형 매개변수 목록에는 줄 바꿈 전에 후행 쉼표가 필요합니다
go.inspection.problem.negative.index=음수 색인: {0}
go.inspection.problem.negative.shift.count=잘못된 연산: {0}(음수 시프트 개수)
go.inspection.problem.nil.is.not.allowed={0}은(는) 허용되지 않습니다. {1}이(가) 되어야 합니다
go.inspection.problem.nil.loop.is.always.skipped={0}이(가) 항상 {1} 이기 때문에 루프를 항상 건너뜁니다
go.inspection.problem.no.argument.for.placeholder.part={0,choice,0#너비|1#정확도|2#동사}의 인수가 없습니다. 인수 색인 = {1}, 인수 개수 = {2}{3}
go.inspection.problem.no.non.test.go.files=패키지가 테스트 Go 파일만 포함합니다. {0}
go.inspection.problem.no.placeholders.in.format.string=서식 문자열에 자리표시자가 없습니다
go.inspection.problem.non.bool.used.as.condition=bool이 아닌 값 {0}이(가) 조건으로 사용됩니다
go.inspection.problem.non.canonical.import.path=비표준 가져오기 경로: {0}은(는) {1}이(가) 되어야 합니다
go.inspection.problem.non.strict.comparability.not.supported=기본 인터페이스는 Go 1.20부터 'comparable' 타입 확인 규칙을 만족합니다
go.inspection.problem.not.enough.arguments.in.call={0} 호출에 인수가 부족합니다
go.inspection.problem.not.enough.arguments.to.return=반환할 인수가 충분하지 않음
go.inspection.problem.operator.not.defined=잘못된 연산: {0}({2}에 연산자 {1}이(가) 정의되지 않았습니다)
go.inspection.problem.out.of.bounds.for.array={0}요소 배열 범위를 벗어납니다
go.inspection.problem.out.of.bounds.for.string={0}바이트 문자열 범위를 벗어납니다
go.inspection.problem.path.imports.package.that.expects.canonical.import={0}이(가) import "{1}"이(가) 필요한 패키지를 가져옵니다
go.inspection.problem.path.imports.package.with.invalid.import.comment={0}이(가) 잘못된 import 주석이 있는 패키지를 가져옵니다
go.inspection.problem.path.is.a.program.not.an.importable.package={0}은(는) 프로그램이며 가져올 수 있는 패키지가 아닙니다
go.inspection.problem.placeholder.argument.causes.recursive.call.to.string=자리표시자 인수로 인해 {0} 메서드에 재귀 호출이 발생합니다{1}
go.inspection.problem.placeholder.argument.has.wrong.type=자리표시자 인수 {0}에 잘못된 타입 {1}이(가) 있습니다{2}
go.inspection.problem.placeholder.argument.is.not.a.function.call=자리표시자 인수가 함수 호출이 아닙니다{0}
go.inspection.problem.placeholder.syntax.error=자리표시자 구문 오류{0}
go.inspection.problem.possible.formatting.directive={0}에 서식 지정 지시문이 있을 수 있습니다
go.inspection.problem.possible.malformed.build.comment='+build' 주석 형식이 잘못되었을 수 있습니다
go.inspection.problem.possibly.redundant.type.conversion=불필요한 타입 변환이 있을 수 있습니다
go.inspection.problem.possibly.unused.dependency=사용되지 않을 수 있는 종속성
go.inspection.problem.potential.nil.pointer.dereference=잠재적 nil 포인터 역참조
go.inspection.problem.range.var.copies.lock=범위 변수 {0}이(가) lock을 복사합니다. {1}
go.inspection.problem.receive.from.non.chan.type=잘못된 연산: {0}(비 chan 타입 {1}으)로부터 수신)
go.inspection.problem.receive.from.send.only.type=잘못된 연산: {0}(전송 전용 타입 {1}(으)로부터 수신)
go.inspection.problem.receive.may.block.because.of.nil.channel={0} 채널로 인해 수신 연산자가 고루틴을 차단할 수 있습니다
go.inspection.problem.receive.no.core.type=잘못된 작업: {0}(타입이 {2}인 표현식 {1}의 코어 타입이 없음)
go.inspection.problem.receiver.has.generic.name=리시버 이름이 제네릭입니다
go.inspection.problem.receiver.may.be.nil.in.call=리시버 {0}이(가) 호출 내 {1}일 수 있습니다
go.inspection.problem.receiver.names.are.different=리시버 이름이 다릅니다
go.inspection.problem.redundant.alias=불필요한 별칭
go.inspection.problem.redundant.blank.expression=불필요한 {0} 표현식
go.inspection.problem.redundant.comma=중복된 쉼표
go.inspection.problem.redundant.for.condition=조건이 불필요합니다
go.inspection.problem.redundant.index=불필요한 색인 {0}
go.inspection.problem.redundant.parentheses=불필요한 소괄호
go.inspection.problem.redundant.semicolon=불필요한 세미콜론
go.inspection.problem.redundant.type=불필요한 타입
go.inspection.problem.redundant.type.conversion=중복 형식 변환
go.inspection.problem.reference.is.deprecated={0}은(는) 더 이상 사용되지 않습니다
go.inspection.problem.reference.jumps.over.declaration={0}이(가) {1} 선언을 건너뜁니다
go.inspection.problem.return.copies.lock.value=반환이 lock 값을 복사합니다. {0}
go.inspection.problem.return.value.has.a.function.type={0}의 반환 값에 함수 타입이 있습니다
go.inspection.problem.return.value.of.placeholder.argument.has.a.function.type=자리표시자 인수의 반환 값에 함수 타입이 있습니다{0}
go.inspection.problem.self.import.is.not.allowed=자기 가져오기는 허용되지 않습니다
go.inspection.problem.send.may.block.because.of.nil.channel={0} 채널로 인해 전송 연산자가 고루틴을 차단할 수 있습니다
go.inspection.problem.send.to.non.chan.type=잘못된 연산: {0}(비 chan 타입 {1}(으)로 전송)
go.inspection.problem.send.to.receive.only.type=잘못된 연산: {0}(수신 전용 타입 {1}(으)로 전송)
go.inspection.problem.shift.count.must.be.integer=잘못된 연산: {0} (시프트 개수 타입 {1}이(가) 정수여야 합니다)
go.inspection.problem.shift.count.must.be.unsigned.integer=잘못된 연산: {0} (시프트 개수 타입 {1}이(가) 부호 없는 정수여야 함)
go.inspection.problem.switch.on.error.fails.on.wrapped.errors=switch 구문에서 오류를 비교하면 래핑된 오류에서 실패합니다
go.inspection.problem.this.verb.can.be.used.only.in.fmt.errorf=이 동사는 {0} 호출에서만 사용할 수 있습니다{1}
go.inspection.problem.this.verb.can.be.used.only.once.in.a.format.string=이 동사는 서식 문자열에서 한 번만 사용될 수 있습니다{0}
go.inspection.problem.too.few.values=값이 너무 적습니다
go.inspection.problem.too.many.arguments.for.format.string=서식 문자열의 인수가 너무 많습니다. 필요 = {0}, 실제 = {1}
go.inspection.problem.too.many.arguments.in.call={0} 호출에 인수가 너무 많습니다
go.inspection.problem.too.many.arguments.to.conversion={0}(으)로의 변환을 위한 인수가 너무 많습니다. {1}
go.inspection.problem.too.many.arguments.to.return=반환할 인수가 너무 많음
go.inspection.problem.too.many.values=값이 너무 많습니다
go.inspection.problem.type.assertion.on.errors.fails.on.wrapped.errors=오류 발생 시 타입 어설션은 래핑된 오류에서 실패합니다
go.inspection.problem.type.does.not.support.indexing=잘못된 연산: {0}(타입 {1}이(가) 색인 생성을 지원하지 않습니다)
go.inspection.problem.type.has.both.field.and.method.with.name=타입 {0}에 이름이 {1}인 필드와 메서드가 모두 있습니다
go.inspection.problem.type.has.same.named.field.and.method=타입 {0}에 이름이 {1}인 필드와 메서드가 모두 있습니다
go.inspection.problem.type.is.sync.locker=타입 %s이(가) <code>sync.Locker</code>입니다
go.inspection.problem.type.or.type={0} 또는 {1}
go.inspection.problem.type.parameters.are.not.supported=지원되지 않는 타입 매개변수 입니다
go.inspection.problem.type.switch.on.errors.fails.on.wrapped.errors=오류 발생 시 타입 switch는 래핑된 오류에서 실패합니다
go.inspection.problem.type.which.is.sync.locker=<code>sync.Locker</code>인 타입 %s
go.inspection.problem.unhandled.error=처리되지 않는 오류
go.inspection.problem.unit.specific.suffix=유닛용 접미사 {0}
go.inspection.problem.unknown.verb=알 수 없는 동사 {0}{1}
go.inspection.problem.unmarshal.argument.must.be.a.pointer=이 인수에 포인터 타입이 있어야 합니다
go.inspection.problem.unnecessarily.exported.element=불필요하게 내보낸 {0} {1}
go.inspection.problem.unreachable.code=도달할 수 없는 코드
go.inspection.problem.unused.dependency=사용되지 않는 종속성
go.inspection.problem.unused.import=사용되지 않는 import 문
go.inspection.problem.unused.result=사용되지 않는 결과: {0}
go.inspection.problem.usage.of.cgo.in.tests=테스트에서 cgo 사용이 지원되지 않습니다
go.inspection.problem.use.camelcase.instead.of.snake.case=스네이크 표기법 대신 낙타 표기법 사용
go.inspection.problem.use.of.internal.package.is.not.allowed=내부 패키지 사용은 허용되지 않습니다
go.inspection.problem.use.of.vendored.package.is.not.allowed=벤더 패키지 사용은 허용되지 않습니다
go.inspection.problem.value.is.assigned.to.itself={0}의 값이 자신에게 대입됩니다
go.inspection.problem.variable.declaration.copies.lock.value=변수 선언이 lock 값을 {0}에 복사합니다. {1}
go.inspection.problem.variable.repeated.on.left.side={0}이(가) := 왼쪽에서 반복됩니다
go.inspection.problem.verb.will.ignore.flag=동사가 {0} 플래그를 무시합니다{1}
go.inspection.problem.verb.will.ignore.flags=동사가 {0} 플래그를 무시합니다{1}
go.inspection.problem.wrong.example.signature=잘못된 예시 시그니처
go.inspection.problem.wrong.location.of.build.comment='build' 주석은 패키지 절 앞에 있어야 하며 뒤에 빈 줄이 와야 합니다
go.inspection.problem.wrong.test.signature=잘못된 테스트 시그니처
go.inspection.problematic.execution.path.end=문제가 있는 실행 경로의 끝
go.inspection.receiver.has.generic.name.display.name=리시버에 제네릭 이름이 있음
go.inspection.redundant.blank.argument.in.range.display.name=범위 내 불필요한 빈 인수
go.inspection.redundant.comma.display.name=불필요한 쉼표
go.inspection.redundant.import.alias.display.name=불필요한 import 별칭
go.inspection.redundant.parentheses.display.name=불필요한 소괄호
go.inspection.redundant.second.index.in.slices.display.name=슬라이스 내 불필요한 두 번째 색인
go.inspection.redundant.semicolon.display.name=불필요한 세미콜론
go.inspection.redundant.true.in.for.loop.display.name=for 루프 조건 내 불필요한 'true'
go.inspection.redundant.type.conversion.display.name=불필요한 타입 변환
go.inspection.redundant.types.in.composite.literals.display.name=복합 리터럴 내 불필요한 타입
go.inspection.reserved.word.used.as.name.display.name=이름으로 사용되는 예약 단어
go.inspection.self.assignment.display.name=자기 대입
go.inspection.shadowing.variable.display.name=가리는(Shadowing) 변수
go.inspection.struct.field.has.tag.but.is.not.exported=구조체 필드 ''{0}''에 ''{1}'' 태그가 있지만 내보내지지 않았습니다
go.inspection.struct.initialization.settings.report.for.literals.without.type.checkbox=타입이 없는 구조체 리터럴 보고
go.inspection.struct.initialization.settings.report.for.local.type.checkbox=현재 패키지에 정의된 타입 보고
go.inspection.struct.initialization.without.field.names.display.name=필드 이름이 없는 구조체 초기화
go.inspection.struct.tag.value.consists.only.of.spaces=구조체 태그 값이 모두 공백임
go.inspection.suspicious.extra.space.in.struct.tag.value=구조체 태그 값에 있는 의심스러운 추가 공백
go.inspection.suspicious.space.in.struct.tag.value=구조체 태그 값 내 의심스러운 공백
go.inspection.suspicious.space.in.the.beginning.of.the.struct.tag.value=구조체 태그 값의 시작 부분에 있는 의심스러운 공백
go.inspection.suspicious.space.in.the.end.of.the.struct.tag.value=구조체 태그 값의 끝 부분에 있는 의심스러운 공백
go.inspection.test.name.display.name=형식이 잘못된 함수 이름
go.inspection.type.can.be.omitted.display.name=타입 생략 가능
go.inspection.type.can.be.omitted.message=타입 생략 가능
go.inspection.type.parameter.declared.in.lower.case.display.name=타입 매개변수가 소문자로 선언되었습니다
go.inspection.type.parameter.declared.in.lower.case.message=타입 매개변수 ''{0}''이(가) 소문자로 선언되었습니다
go.inspection.unexported.return.type.of.exported.function.display.name=내보낸 함수의 내보내지지 않은 반환 타입
go.inspection.unhandled.error.display.name=처리되지 않은 오류
go.inspection.unit.specific.suffix.for.time.duration.display.name='time.Duration' 유닛용 접미사
go.inspection.unknown.field.message=구조체 리터럴 내 알 수 없는 필드 {0}
go.inspection.unnecessarily.exported.identifier.display.name=불필요하게 내보낸 식별자
go.inspection.unreachable.code.display.name=도달할 수 없는 코드
go.inspection.unresolved.disabled.gopath.indexing.display.name=비활성화된 GOPATH 색인 생성
go.inspection.unresolved.disabled.gopath.indexing.message=GOPATH 색인 생성이 비활성화되면 적절한 참조 해결이 수행되지 않을 수 있습니다
go.inspection.unresolved.label.message=해결되지 않은 라벨 {0}
go.inspection.unresolved.reference.message=해결되지 않은 참조 {0}
go.inspection.unresolved.type.message=해결되지 않은 타입 {0}
go.inspection.unsorted.imports.display.name=정렬되지 않은 import 문
go.inspection.unused.constant.display.name=사용되지 않는 상수
go.inspection.unused.constant.message=사용되지 않는 상수 {0}
go.inspection.unused.exported.function.display.name=사용되지 않는 노출 함수
go.inspection.unused.exported.type.display.name=사용되지 않는 노출 타입
go.inspection.unused.function.display.name=사용되지 않는 함수
go.inspection.unused.function.message=사용되지 않는 함수 {0}
go.inspection.unused.function.or.method.call.result.display.name=사용되지 않는 함수 또는 메서드 호출 결과
go.inspection.unused.global.variable.display.name=사용되지 않는 전역 변수
go.inspection.unused.label.message=사용되지 않은 라벨 {0}
go.inspection.unused.parameter.display.name=사용되지 않는 매개변수
go.inspection.unused.parameter.message=사용되지 않는 매개변수 {0}
go.inspection.unused.type.display.name=사용되지 않는 타입
go.inspection.unused.type.message=사용되지 않는 타입 {0}
go.inspection.unused.type.parameter.display.name=사용되지 않는 유형 매개변수
go.inspection.unused.type.parameter.message=사용되지 않는 유형 매개변수 {0}
go.inspection.unused.variable.message=사용되지 않는 변수 {0}
go.inspection.usage.of.context.todo=context.TODO() 사용 위치
go.inspection.usage.of.snake.case.display.name=SnakeCase 표기법 사용(_C)
go.install.template.plugin.action.text=플러그인 설치
go.install.template.plugin.notification.text=html/templates 패키지에서 강조 표시, 코드 완성 기능, 탐색 기능을 향상하려면 Go 템플릿을 설치하세요
go.intention.add.declaration.parens.name=선언에 소괄호 추가
go.intention.add.dot.import.alias.name=마침표(.) import 문 별칭 추가
go.intention.add.fmt.string.argument.name=서식 문자열 인수 추가
go.intention.add.import.alias.name=import 문 별칭 추가
go.intention.add.tag.key=태그에 키 추가
go.intention.change.field.name.style.command=태그의 필드 이름 스타일 변경
go.intention.change.field.name.style.in.tags=태그의 필드 이름 스타일 변경
go.intention.change.field.name.style.select.style=필드 이름 스타일 선택:
go.intention.chop.arguments=인수를 별도의 줄에 배치
go.intention.chop.composite.literal.elements=요소를 별도의 줄에 배치
go.intention.chop.parameters=매개변수를 별도의 줄에 배치
go.intention.convert.to.short.var.declaration.name=짧은 var 선언으로 변환
go.intention.convert.to.var.declaration.name=var 선언으로 변환
go.intention.create.field.getter.and.setter.command.name=필드 접근자 생성
go.intention.create.field.getter.and.setter.name=getter 및 setter 생성
go.intention.create.field.getter.name=getter 생성
go.intention.create.field.setter.name=setter 생성
go.intention.download.all.missing.modules.fix.text=모든 모듈을 모듈 캐시에 다운로드
go.intention.download.single.missing.module.fix.family.name=모듈을 모듈 캐시에 다운로드
go.intention.download.single.missing.module.fix.from.replacement.text={1}에서 {0} (을)를 모듈 캐시에 다운로드
go.intention.download.single.missing.module.fix.text={0}(을)를 모듈 캐시에 다운로드
go.intention.expand.signature.types.name=시그니처 타입 확장
go.intention.export.name=내보내기
go.intention.fill.all.fields.command.name=구조체 입력
go.intention.fill.all.fields.enforce.multiline.checkbox=여러 줄 강제 실행
go.intention.fill.all.fields.name=모든 필드 입력
go.intention.fill.all.fields.recursively.checkbox=재귀적으로
go.intention.fill.all.fields.recursively.name=재귀적으로 모든 필드 입력
go.intention.fill.fields.name=필드 입력…
go.intention.flip.binary.operator.changes.operator.text=''{0}''을(를) ''{1}''(으)로 반전
go.intention.flip.binary.operator.changes.semantics.text=''{0}'' 반전(의미 변경)
go.intention.flip.binary.operator.name=이항 연산자 반전
go.intention.flip.binary.operator.text=''{0}'' 반전
go.intention.fmt.string.argument.bad.position.error.message=잘못된 위치
go.intention.fmt.string.argument.explicit.indices.error.message=문자열에 명시적 색인이 있습니다
go.intention.fmt.string.argument.percent.with.args.error.message=문자열에 인수가 있는 %%이(가) 있습니다
go.intention.fmt.string.argument.syntax.error.message=문자열에 구문 오류가 있습니다
go.intention.fmt.string.argument.too.few.arguments.error.message=문자열의 인수가 너무 적습니다
go.intention.fmt.string.argument.variadic.arg.error.message=문자열에 ...인수가 있습니다
go.intention.fmt.string.title.error.message=Fmt 문자열 인수를 추가할 수 없음
go.intention.generate.constructor.name=생성자 생성
go.intention.generate.method.name=메서드 생성
go.intention.generate.struct.fields.from.json=JSON에서 구조체 필드 생성
go.intention.generate.struct.fields.from.json.error=JSON의 최상위 값은 객체나 객체 배열이어야 합니다
go.intention.generate.type.from.json=JSON에서 타입 생성
go.intention.go.to.implementation.name=구현으로 이동
go.intention.go.to.implementation.text=구현으로 이동…
go.intention.go.to.super.name=인터페이스로 이동
go.intention.go.to.super.text=인터페이스로 이동…
go.intention.implement.interface.name=인터페이스 구현
go.intention.implement.interface.text=인터페이스 구현…
go.intention.invert.if.name=if 반전
go.intention.join.arguments=인수를 한 줄에 배치
go.intention.join.composite.literal.elements=인수를 한 줄에 배치
go.intention.join.parameters=매개변수를 한 줄에 배치
go.intention.merge.all.declarations.name=모든 선언 병합
go.intention.merge.declaration.up.name=선언 병합
go.intention.merge.declarations.by.comma.name=쉼표를 통해 선언 병합
go.intention.migrate.function.parameter.to.method.receiver=함수 매개변수를 메서드 리시버로 마이그레이션
go.intention.migrate.function.parameter.to.method.receiver.error.hint.invalid.receiver.type=그 결과로 발생하는 리시버 타입 {0}은(는) 유효하지 않습니다({1}은(는) {2}입니다).
go.intention.migrate.function.parameter.to.method.receiver.error.hint.message=함수 매개변수를 메서드 리시버로 마이그레이션할 수 없습니다.\n\
{0}
go.intention.migrate.function.parameter.to.method.receiver.error.hint.method.with.type.parameter=메서드는 타입 매개변수를 가질 수 없으므로 그 결과로 나오는 메서드는 유효하지 않을 것입니다.
go.intention.migrate.function.parameter.to.method.receiver.error.hint.title=함수 매개변수를 메서드 리시버로 마이그레이션하지 못했습니다
go.intention.migrate.function.parameter.to.method.receiver.name=함수 매개변수를 메서드 리시버로 마이그레이션
go.intention.migrate.method.receiver.to.function.parameter=메서드 리시버를 함수 매개변수로 마이그레이션
go.intention.move.to.struct.initialization.name=필드 대입을 구조체 초기화로 이동
go.intention.negate.boolean.expression.name=표현식 부정
go.intention.negate.boolean.expression.name.recursively.suffix=재귀적으로
go.intention.negate.boolean.expression.text=''{0}''을(를) ''{1}''(으)로 부정
go.intention.negate.boolean.topmost.expression.name=최상위 표현식 부정
go.intention.negate.boolean.topmost.expression.text=최상위 ''{0}''을(를) ''{1}''(으)로 부정
go.intention.remove.declaration.parens.name=선언에서 소괄호 제거
go.intention.remove.dot.import.alias.name=마침표(.) import 문 별칭 제거
go.intention.remove.keys.from.struct.literal.value.name=구조체 리터럴에서 키 제거
go.intention.reuse.signature.types.name=시그니처 타입 재사용
go.intention.run.go.generate.name=주석에서 go generate 실행
go.intention.run.go.generate.on.file.name=파일에서 go generate 실행
go.intention.run.go.generate.on.package.name=패키지에서 go generate 실행
go.intention.run.go.generate.text=Go generate ''{0}''
go.intention.select.fields.dialog.title=필드 선택
go.intention.specify.type.name=명시적으로 타입 지정
go.intention.split.all.declarations.name=모든 선언 분할
go.intention.split.declarations.by.comma.name=쉼표로 선언 분할
go.intention.split.declarations.name=선언을 두 그룹으로 분할
go.intention.update.value.in.tags=태그의 키 값 업데이트
go.intentions.category=Go
go.libraries.configurable.path.source.prefix.default=[디폴트]
go.libraries.configurable.path.source.prefix.gopath=[GOPATH]
go.live.template.context.type.block.presentable.name=블록
go.live.template.context.type.expression.presentable.name=표현식
go.live.template.context.type.file.presentable.name=파일
go.live.template.context.type.statement.presentable.name=구문
go.live.template.context.type.tag.literal.presentable.name=태그 리터럴
go.live.template.context.type.tag.presentable.name=태그
go.live.template.context.type.type.presentable.name=타입
go.load.file.dialog.invalid.file=잘못된 파일 경로
go.load.file.dialog.invalid.url=https://go.dev/로 시작하는 URL을 사용하세요
go.load.file.dialog.radio.file=파일
go.load.file.dialog.radio.url=URL
go.load.file.dialog.title=스크래치 파일로 코드를 가져올 소스 선택:
go.load.file.dialog.url.comment=https://go.dev/로 시작하는 URL을 사용
go.load.to.playground.could.not.load.message=//공유된 코드를 로드할 수 없습니다
go.load.to.playground.dialog.title=스크래치 파일로 가져오기
go.macro.bin.dirs.description=Go 도구가 있는 bin 디렉터리 경로
go.macro.executable.path.description=Go 실행 파일 경로
go.macro.file.go.path.description=GOPATH 값
go.macro.file.go.root.description=프로젝트 SDK 경로
go.macro.file.import.path.description=현재 파일의 가져오기 경로
go.microservices.http.server.endpoint.title=Go HTTP-서버
go.module=모듈
go.modules.automatic.dependencies.download.task.text=''go mod download'' 을 {0}에서 실행 중({1}/{2})
go.modules.background.task.updating.dependencies.text={0} ''go.mod'' {0,choice,0#파일|1#파일|2#파일}에서 ''go list'' 실행 중…
go.modules.background.task.updating.dependencies.title=Go 모듈 종속 요소 업데이트 중
go.modules.dependency.diagram=Go 모듈 종속성 다이어그램
go.modules.scratch.file.notification.text=모듈 컨텍스트 사용 중
go.modules.tree.structure.replaced=(대체됨)
go.modules.tree.structure.replacement=대체: {0}
go.modules.unknown.dependencies.notification.retry=''{0}'' 다시 실행
go.modules.unknown.dependencies.notification.text=모듈 종속 요소 전체 집합을 알 수 없음, 일부 Go 모듈 특정 기능이 제공되지 않을 수 있습니다.
go.modules.unknown.dependencies.notification.tooltip=네트워크 연결 문제 또는 명시적 GOPROXY=off로 인해 발생했을 수 있습니다
go.modules.unsupported.workspace.mode=Go SDK {0}은(는) ''go.work'' 파일을 지원하지 앟ㄴ습니다. Go 1.18 이상을 사용하세요
go.modules.wizard.description=종속성 관리를 위해 Go 모듈을 사용하는 Go 애플리케이션 및 라이브러리를 개발하려면 Go 모듈 프로젝트를 생성하세요
go.modules.wizard.name=Go
go.mozilla.rr.dialog.specify.trace.directory.validation.message=추적 디렉터리 지정
go.mozilla.rr.dialog.trace.directory.label=추적 디렉터리(&T):
go.mozilla.rr.failed.to.start.error.message=rr trace {0} 디버거를 시작하지 못했습니다. {1}
go.mozilla.rr.session.name={0} 추적
go.navigation.go.to.implementation=구현으로 이동
go.navigation.go.to.implementation.find.usages.title={0}의 구현
go.navigation.go.to.method.implementation.popup.title=메서드 {0}이(가) {1}개 {1,choice,0#타입|1#타입|2#타입}에서 구현됨
go.navigation.go.to.shadowed.method=가려진(Shadowed) 메서드로 이동
go.navigation.go.to.shadowed.method.popup.title=메서드 {0}이(가) {1}개 {1,choice,0#타입|1#타입|2#타입}의 메서드를 가립니다
go.navigation.go.to.shadowing.method=가리는(Shadowing) 메서드로 이동
go.navigation.go.to.shadowing.method.find.usages.title={0}의 가리는(Shadowing) 메서드
go.navigation.go.to.shadowing.method.popup.title=메서드 {0}이(가) {1}개 {1,choice,0#타입|1#타입|2#타입}에서 가려짐
go.navigation.go.to.super=인터페이스로 이동
go.navigation.go.to.super.find.usages.title={0}의 구현된 인터페이스
go.navigation.go.to.super.method=메서드 사양으로 이동
go.navigation.go.to.super.method.find.usages.title.kind={0}의 구현된 메서드 사양
go.navigation.go.to.super.method.popup.title=메서드 {0}이(가) {1}개의 {1,choice,0#인터페이스|1#인터페이스|2#인터페이스}에서 메서드를 구현합니다
go.navigation.go.to.super.popup.title=타입 {0}이(가) {1} {1,choice,0#인터페이스|1#인터페이스|2#인터페이스}를 구현합니다
go.navigation.go.to.type.implementation.popup.title=타입 {0}이(가) {1} {1,choice,0#타입|1#타입|2#타입}에서 구현됨
go.navigation.progress.title={0} 검색 중…
go.navigation.recursive.call=재귀적 호출
go.navigation.shadowed.method.usages.title={0}의 가려진(Shadowed) 메서드
go.new.project.step.other.group.name=기타
go.new.project.step.web.group.name=웹
go.notification.add.to.gopath.action.text=GOPATH에 추가
go.notification.add.to.module.action.text=모듈에 추가
go.notification.add.vendored.package.to.project.action.text=프로젝트에 ''{0}'' 추가
go.notification.automatic.dependencies.download.text=연결이 제한되어 있거나 모든 종속요를 필요로 하지 않는 경우 설정에서 자동 다운로드를 해제하세요.
go.notification.automatic.dependencies.download.title=Go 모듈 종속 요소 자동 다운로드
go.notification.automatic.download.open.settings=설정 열기…
go.notification.cgo.optimizations.are.not.disabled=CGO_CFLAGS가 '-O0 -g'로 설정되지 않았으므로, cgo 코드가 최적화될 수 있습니다.
go.notification.code.insight.disabled.for.vendored.files.text=라이브러리 내 벤더 파일에서 코드 분석 기능 편집이 비활성되었습니다
go.notification.code.insight.features.are.disabled.text=코드 분석 기능을 사용할 수 없습니다
go.notification.create.go.mod.file.action.text='go.mod' 파일 생성
go.notification.disable.cgo.support.action.text=cgo 지원 비활성화
go.notification.disable.go.modules.integration.action.text=Go 모듈 통합 비활성화
go.notification.do.not.show.action.text=다시 보지 않기
go.notification.download.missing.module.successfully.done={0}개 {0,choice,0#모듈|1#모듈|2#모듈}이 처리되었습니다
go.notification.enable.cgo.support.action.text=cgo 지원 활성화
go.notification.file.does.not.match.target.system.text=''{0}''이(가) 타깃 시스템과 일치하지 않습니다. 파일이 빌드 도구에서 무시됩니다.
go.notification.file.exceeds.size.limit.text=파일 크기({0})가 구성된 제한({1})을 초과합니다. {2}
go.notification.file.ignore.navigate.to.build.constraints.action.text=빌드 제약으로 이동
go.notification.file.ignore.navigate.to.cgo.import.action.text=cgo import 문으로 이동
go.notification.file.is.ignored.because.arch.mismatch.text=''{0}''은(는) 아키텍처 불일치 때문에 빌드 도구에서 무시됩니다
go.notification.file.is.ignored.because.bad.syntax.text=''{0}''은(는) 잘못된 구문 때문에 빌드 도구에서 무시됩니다
go.notification.file.is.ignored.because.cgo.mismatch.text=''{0}''은(는) cgo 지원 불일치 때문에 빌드 도구에서 무시됩니다
go.notification.file.is.ignored.because.compiler.mismatch.text=''{0}''은(는) 컴파일러 불일치 때문에 빌드 도구에서 무시됩니다
go.notification.file.is.ignored.because.custom.flag.text=''{0}''은(는) 사용자 지정 플래그 때문에 빌드 도구에서 무시됩니다
go.notification.file.is.ignored.because.non.go.file.text=''{0}''은(는) Go 파일이 아니기 때문에 빌드 도구에서 무시됩니다
go.notification.file.is.ignored.because.os.mismatch.text=''{0}''은(는) OS 불일치 때문에 빌드 도구에서 무시됩니다
go.notification.file.is.ignored.because.version.mismatch.text=''{0}''은(는) Go 버전 불일치 때문에 빌드 도구에서 무시됩니다
go.notification.file.starts.with.dot.text=''{0}''은(는) 이름이 ''.''로 시작하므로 빌드 도구에서 무시됩니다
go.notification.file.starts.with.underscore.text=''{0}''은(는) 이름이 ''_''로 시작하므로 빌드 도구에서 무시됩니다
go.notification.go.edit.project.settings.action.text=설정 편집
go.notification.go.root.is.incorrect.text=GOROOT가 올바르지 않습니다
go.notification.go.root.is.not.defined.text=GOROOT가 정의되지 않았습니다
go.notification.go.setup.action.text=GOROOT 설정
go.notification.go.support.enable.action.text=Go 지원 활성화
go.notification.go.support.is.disabled.in.module.text=모듈 ''{0}''에서 Go 지원이 비활성화되어 있습니다
go.notification.go.tool.is.missing.run.go.get.invoke.go.get.action.text=''go get {0}'' 호출
go.notification.go.tool.is.missing.run.go.get.text=GOPATH에서 ''{0}''을(를) 찾을 수 없습니다.
go.notification.go.tool.is.missing.text=실행 파일 ''{0}''이(가) GOPATH에서 누락되었습니다. 해당 실행 파일을 설치하시겠어요?
go.notification.gopath.configure.action.text=GOPATH 구성
go.notification.gopath.detected.configure.gopath.action.text=GOPATH 구성
go.notification.gopath.detected.text=GOPATH에서 라이브러리를 탐지했습니다. GOPATH 설정에 추가 라이브러리를 추가하세요.
go.notification.gopath.detected.title=GOPATH가 탐지됨
go.notification.gopath.is.empty.text=GOPATH가 비어 있습니다
go.notification.inspections.are.disabled.enabled.action.text=검사 활성화
go.notification.inspections.are.disabled.text=파일에서 검사가 비활성화되어 있습니다
go.notification.install.as.tool.action.text=도구로 설치
go.notification.install.go.tool.action.text=Go 도구 설치
go.notification.install.package.action.text={0} 설치
go.notification.modules.file.is.absent.title='go.mod' 파일 누락
go.notification.obsolete.imports.code.style.detected.title=사용되지 않는 import 문의 코드 스타일 설정이 탐지됨
go.notification.open.imports.settings=가져오기 설정 열기
go.notification.package.was.excluded={0}이(가) 가져오기에서 제외되었습니다
go.notification.rename.file.action.text=파일 이름 변경
go.notification.review.code.style.settings.action.text=코드 스타일 설정 검토
go.playground.actions.format.description=Go Playground API를 사용하여 코드의 서식을 지정합니다
go.playground.actions.format.text=형식
go.playground.actions.go.context.description.prefix=선택한 컨텍스트:
go.playground.actions.go.version.description.prefix=선택한 버전:
go.playground.actions.go.version.label=Go 버전
go.playground.actions.load.description=제공된 URL 또는 파일에서 지정된 playground 파일로 코드를 로드합니다
go.playground.actions.load.text=로드
go.playground.actions.run.description=Go Playground에서 파일을 실행합니다
go.playground.actions.run.locally.text=로컬로 실행
go.playground.actions.run.text=실행
go.playground.actions.share.description=공유 가능한 링크를 제공하여 Go Playground에서 파일 코드를 공유합니다
go.playground.actions.share.text=공유
go.profiler.allocated.objects.metric.name=할당된 객체
go.profiler.allocated.space.metric.name=할당된 공간
go.profiler.application.configurable.name=Go 프로파일러
go.profiler.blocking.profile.prefix=차단 중인 프로파일
go.profiler.blocking.profiler.name=차단 중인 프로파일러
go.profiler.cpu.profile.prefix=CPU 프로파일
go.profiler.cpu.profiler.name=CPU 프로파일러
go.profiler.cpu.time.metric.name=CPU 시간
go.profiler.downloading.profiler.dump.progress.title=프로파일러 덤프 다운로드 중…
go.profiler.in.use.objects.metric.name=사용 중인 객체
go.profiler.in.use.space.metric.name=사용 중인 공백
go.profiler.memory.profile.prefix=메모리 프로파일
go.profiler.memory.profiler.name=메모리 프로파일러
go.profiler.mutex.profile.prefix=Mutex 프로파일
go.profiler.mutex.profiler.name=Mutex 프로파일러
go.profiler.not.a.pprof.profile.error=pprof 프로파일이 아님
go.profiler.parse.error=프로파일 파싱 도중 오류 발생: {0}
go.profiler.parse.error.empty=프로파일이 비어 있습니다
go.profiler.parse.error.eof=예기치 않은 파일의 끝(EOF)
go.profiler.profile.fraction.comment.text=프로파일에 보고된 mutex 경합 이벤트의 프랙션(fraction)을 제어합니다. 평균적으로 1/프랙션 이벤트가 보고됩니다. 디폴트 프랙션 1을 사용하려면 공백으로 남겨둡니다.
go.profiler.profile.fraction.label.text=프로파일 프랙션:
go.profiler.profile.illegal.profile.fraction.validation.message=잘못된 프로파일 비율: {0}
go.profiler.profile.illegal.rate.validation.message=잘못된 프로파일 속도: {0}
go.profiler.profile.rate.cpu.comment.text=프로파일에 보고된 고루틴 차단 이벤트를 제어합니다. 평균적으로 프로파일러는 프로그램이 차단에 소요한 시간당 1개의 차단 이벤트를 샘플링하는 것을 목표로 합니다. 시간은 나노초로 설정됩니다. 프로파일에 모든 차단 이벤트를 포함하려면 값을 1로 설정하세요. 디폴트 프로파일 속도(1)를 사용하려면 공백으로 남겨두세요.
go.profiler.profile.rate.label.text=프로파일 속도:
go.profiler.profile.rate.memory.comment.text=프로파일에 기록 및 보고된 메모리 할당을 제어합니다. 평균적으로 프로파일러는 할당된 바이트 수당 1개의 할당을 샘플링하는 것을 목표로 합니다. 프로파일에 할당된 모든 차단을 포함하려면 속도를 1로 설정합니다. 디폴트 속도(512KB)를 사용하려면 공백으로 남겨두세요.
go.project.configurable.name=Go
go.quick.doc.assign.iota='iota'에 값을 대입해도 'builtin.iota'의 카운터가 다시 설정되지 않습니다. 대신 대입은 'builtin.iota'를 숨기는 새 상수 'iota'를 정의합니다.
go.quick.doc.blank.identifier.hint=빈 식별자('_')는 모든 유형의 값으로 대입하거나 선언할 수 있습니다. 빈 식별자는 삭제되고 컴파일러에서 사용되지 않습니다. 예를 들어, 반환 값을 catch하려면 빈 식별자를 사용하지만, 나중에 이 값을 사용할 의도는 없습니다.
go.quick.doc.channel.direction.label=채널 방향:
go.quick.doc.channel.receive.label=채널로부터 받기
go.quick.doc.channel.send.label=채널로 보내기
go.quick.doc.composite.literal.hint=이 복합 리터럴은 지정된 값으로 새 {0} 인스턴스를 할당합니다.
go.quick.doc.empty.interface.hint=빈 인터페이스인 'interface{}'는 모든 타입 세트를 의미합니다. 빈 인터페이스 타입의 변수는 모든 타입의 값을 저장할 수 있습니다.
go.quick.doc.iota.example=예를 들어, 'const (C0 = iota; C1; C2)'는 '0', '1' 및 '2'를 인쇄합니다. 코드에서 'const'를 사용할 때마다 개수가 '0'으로 재설정됩니다. 'iota' 대입된 상수 값을 보려면 상수 사양 위에 마우스 포인터를 가져다 놓습니다.
go.quick.doc.keyword.resource.effective.go.label=Effective Go
go.quick.doc.keyword.resource.go.blog.label=Go 블로그
go.quick.doc.keyword.resource.language.spec.label=Go 언어 사양
go.quick.doc.keyword.type.switch=switch 타입은 인터페이스 값 'x'의 동적 타입과 일치합니다. 동적 타입은 'switch' case의 타입과 일치됩니다. 'v := x.(type)'과 같은 짧은 변수 대입이 switch guard로 사용되고 switch case는 단일 타입에만 사용되는 경우, 'v'는 일치하는 switch case에 지정된 타입을 갖게 됩니다.
go.quick.doc.methods.on.label=메서드:
go.quick.doc.package.label=패키지:
go.quick.doc.resolved.value.label=해결된 값:
go.quick.doc.struct.literal.hint=필드 값을 순서대로 지정하거나 필드 이름을 사용할 수 있습니다.
go.quick.doc.too.large.to.render=렌더링하기에는 너무큽니다
go.quick.doc.type.alias.and.definition.hint.link.text=Go Spec: 타입 ID
go.quick.doc.type.alias.hint=타입 {0}은(는) 타입 {1}의 별칭입니다. 이러한 타입은 서로 동일합니다. 자세한 정보는 {2}을(를) 참조하세요
go.quick.doc.type.assertions.hint=타입 어설션은 변수가 일부 유형인지 확인하고 기본 인터페이스 값을 반환하는 데 사용됩니다. 타입 어설션은 인터페이스에서만 작동합니다. 예를 들어, 다음 코드에서 'var x interface{} = 42 t := x.(int)', 'x'에는 내부 int 값('42')이 있는 'interface{}' 유형이 있고 'int'는 확인할 구체적인 유형입니다. 't'를 인쇄하면 출력은 '42'가 됩니다. 구체적인 유형을 'string' ('t := x.(string)')으로 변경하면 런타임 패닉이 발생합니다. 타입 어설션은 두 값을 반환할 수 있습니다. 예를 들어, 't, ok := x.(int)' 표현식에 'ok' 부울이 있습니다. 이 부울은 어설션이 정확하면 'true'를 반환합니다. 'ok'가 'false'이면 't'가 0으로 설정되고 패닉이 발생하지 않습니다.
go.quick.doc.type.definition.hint=타입 {0}은(는) 기본 타입 {1}을(를) 포함하는 새로운 타입입니다. 이러한 타입은 서로 다릅니다. 자세한 정보는 {2}을(를) 참조하세요
go.quick.doc.type.parameter.hint={0} 선언에서 유형 매개변수를 선언합니다. 이러한 유형 매개변수는 {0}을(를) 제네릭으로 만듭니다. 제네릭 {0}은(는) 여러 유형을 처리할 수 있습니다. 가능한 유형 집합은 유형 매개변수의 제약에 의해 관리됩니다. 제네릭에 대한 자세한 내용은 {1}을(를) 참조하세요.
go.quick.doc.type.parameter.hint.hyperlink.text=튜토리얼: go.dev에서 제네릭 시작하기
go.quick.doc.type.parameter.in.method.hint=리시버의 기본 유형이 제네릭 유형이므로 메서드가 제네릭입니다. 메서드 사양에서 리시버 기본 유형의 유형 매개변수에 해당하는 유형 매개변수를 선언해야 합니다. 메서드 유형 인수는 리시버 기본 유형에 사용되는 유형 제약을 사용해야 합니다. 제네릭에 대한 자세한 내용은 {0}을(를) 참조하세요.
go.refactoring.change.signature.current.method.option=현재 메서드만 {0}
go.refactoring.change.signature.function.will.not.perform.initialization.validation.message=이제 함수 {0}은(는) 초기화를 수행하지 않습니다
go.refactoring.change.signature.function.will.not.start.application.validation.message=이제 함수 {0}은(는) 애플리케이션을 시작하지 않습니다
go.refactoring.change.signature.method.specification.and.implementations.option=메서드 사양 및 모든 구현 {0}
go.refactoring.change.signature.named.and.unnamed.parameters.validation.message=이름이 지정된 매개변수와 이름 없는 매개변수는 동시에 사용할 수 없습니다.
go.refactoring.change.signature.new.parameter.validation.message.part=새 매개변수
go.refactoring.change.signature.not.legal.identifier.validation.message=''{0}''은(는) 올바른 식별자가 아닙니다.
go.refactoring.change.signature.parameter.without.type.validation.message={0,number,ordinal}번째 매개변수에는 타입이 있어야 합니다.
go.refactoring.change.signature.renamed.parameter.validation.message.part=이름이 변경된 매개변수
go.refactoring.change.signature.result.parameters.tab.title=결과 매개변수
go.refactoring.change.signature.reuse.types.checkbox=타입 재사용
go.refactoring.change.signature.target.not.found.error.message=캐럿은 리팩터링하려는 함수 또는 메서드 이름에 있어야 합니다
go.refactoring.change.signature.used.multiple.times.validation.message=''{0}''이(가) 여러 번 사용됩니다.
go.refactoring.change.signature.variadic.is.not.last.validation.message=가변 매개변수는 항상 마지막이어야 합니다.
go.refactoring.change.signature.variadic.parameter.in.result.validation.message=가변 매개변수는 결과에서 허용되지 않습니다.
go.refactoring.declarations.separator=선언
go.refactoring.different.package.name.validation.message=패키지 이름은 기존 파일과 다를 수 없습니다.
go.refactoring.empty.target.directory.path.validation.message=타깃 디렉터리 경로는 공백일 수 없습니다.
go.refactoring.empty.target.file.name.validation.message=타깃 파일 이름은 공백일 수 없습니다.
go.refactoring.empty.target.package.validation.message=타깃 패키지 이름은 공백일 수 없습니다.
go.refactoring.exported.column.name=내보냄
go.refactoring.extract.interface.caret.should.be.inside.type.error.message=캐럿이 리팩터링할 타입 내부에 있어야 합니다
go.refactoring.extract.interface.empty.type.name.validation.message=타입 이름은 공백일 수 없습니다.
go.refactoring.extract.interface.incorrect.type.name.validation.message=타입 이름이 올바르지 않습니다.
go.refactoring.extract.interface.rename.type.and.use.interface.radio.button=원본 타입 이름 변경 및 가능한 경우 인터페이스 사용(&E)
go.refactoring.extract.interface.rename.type.spec.label=타입 사양의 이름을 다음으로 변경:
go.refactoring.extract.interface.unexported.method.specification.validation.message={0} {1}은(는) 내보내지 않은 메서드 사양을 구현하지 않습니다
go.refactoring.extract.interface.unexported.not.be.accessible.validation.message=내보내지 않은 {0}은(는) {1}에서 액세스할 수 없습니다
go.refactoring.failed.to.create.directory.error.message=디렉터리 ''{0}''을(를) 찾거나 생성할 수 없습니다
go.refactoring.failed.to.create.file.for.package.error.message=패키지 ''{1}''의 파일 ''{0}''을(를) 찾거나 생성할 수 없습니다
go.refactoring.file.chooser.dialog.title=타깃 디렉터리 또는 파일 선택
go.refactoring.file.label=파일로:
go.refactoring.implement.methods.checkbox=비 &&프로젝트(&N)
go.refactoring.implement.methods.command={0} 구현
go.refactoring.implement.methods.create.type.name=타입 생성…
go.refactoring.implement.methods.dummy.background.updater.task.title=타입 검색 중…
go.refactoring.implement.methods.preparing.template.progress.title=템플릿 준비 중…
go.refactoring.implement.methods.prompt=구현할 인터페이스 선택:
go.refactoring.incorrect.file.name.validation.message=타깃 파일 이름이 올바르지 않습니다.
go.refactoring.incorrect.package.name.validation.message=타깃 패키지 이름이 올바르지 않습니다.
go.refactoring.inline.cannot.inline.call.from.defer='defer' 문의 호출에 인라인 리팩터링을 적용할 수 없습니다
go.refactoring.inline.cannot.inline.call.from.go='go' 문의 호출에 인라인 리팩터링을 적용할 수 없습니다
go.refactoring.inline.cannot.inline.in.loop.condition=루프 조건의 여러 줄 함수 또는 패키지 수준의 'var' 또는 'const' 선언에 인라인 리팩터링을 적용할 수 없습니다
go.refactoring.inline.cannot.inline.many.returns=여러 반환이 있는 함수에 인라인 리팩터링을 적용할 수 없습니다
go.refactoring.inline.cannot.inline.no.body=본문이 없는 함수에 인라인 리팩터링을 적용할 수 없습니다
go.refactoring.inline.cannot.inline.recursive.functions=재귀 함수에 인라인 리팩터링을 적용할 수 없습니다
go.refactoring.inline.cannot.inline.variadic.parameter=varargs 매개변수의 인라인화는 지원되지 않습니다
go.refactoring.inline.command.name=함수/메서드 인라인화
go.refactoring.inline.defer.statements=이 함수에는 주변 함수 호출 후 실행되는 defer 문이 포함됩니다
go.refactoring.inline.defined.in.goroot.error.message={0} {1}이(가) GOROOT에 정의되어 있습니다
go.refactoring.inline.defined.in.multi.value.context.error.message=다중 값 컨텍스트에서 정의된 {0} {1}
go.refactoring.inline.found.usages.in.goroot.message=GOROOT에서 ''{1}''의 {0, choice, 1#1개 사용 위치|2#{0}개 사용 위치} 발견.
go.refactoring.inline.kept.definition.and.inlined.message=정의를 유지했습니다{0, choice, 0#|1# 그리고 프로젝트와 GOPATH에서 1개의 사용위치를 인라인했습니다|2# 그리고 프로젝트와 GOPATH에서 {0}개의 사용 위치를 인라인했습니다.} 
go.refactoring.inline.no.initializer.error.message={0} {1}에 이니셜라이저가 없습니다
go.refactoring.inline.no.parameter.value.error.message=매개변수 {0}의 값을 찾을 수 없습니다
go.refactoring.inline.options.dialog.all.keep=모든 호출 인라인화 및 선언 유지(&K)
go.refactoring.inline.options.dialog.all.remove=모든 호출 인라인화 및 선언 제거(&A)
go.refactoring.inline.options.dialog.name.label=인라인 리팩터링을 수행하는 방법은?
go.refactoring.inline.options.dialog.this.keep=이 호출만 인라인화 및 선언 유지(&T)
go.refactoring.inline.reassigned.error.message={0}이(가) 다시 대입되었습니다
go.refactoring.introduce.analyzing.before.extraction=추출 전 코드 분석 중…
go.refactoring.introduce.collecting.free.vars=비어 있는 변수 수집 중…
go.refactoring.introduce.continue.statement.interrupts.execution.flow.error.message=continue 문이 실행 흐름을 방해하는 경우 리팩터링이 지원되지 않습니다
go.refactoring.introduce.does.not.return.value.error.message=표현식 {0}이(가) 값을 반환하지 않습니다
go.refactoring.introduce.extract.function.command=함수 추출
go.refactoring.introduce.extract.function.title=함수 추출
go.refactoring.introduce.extract.method.command=메서드 추출
go.refactoring.introduce.extract.method.or.function.title=메서드 또는 함수 추출
go.refactoring.introduce.extract.title=추출
go.refactoring.introduce.extract.variable.command=변수 추출
go.refactoring.introduce.generating.code.template=코드 템플릿 생성 중…
go.refactoring.introduce.label.definition.selected.with.all.references.error.message=라벨 정의가 모든 참조와 함께 선택된 경우에만 리팩터링이 지원됩니다
go.refactoring.introduce.label.reference.interrupts.execution.flow.error.message=라벨 참조가 실행 흐름을 방해하는 경우 리팩터링이 지원되지 않습니다
go.refactoring.introduce.method.with.receiver.renderer={0} 리시버가 있는 메서드
go.refactoring.introduce.not.constant.value.error.message=표현식 {0}이(가) 상수 값이 아닙니다
go.refactoring.introduce.range.contains.defer.message=선택한 범위에는 추출 중 재정렬될 수 있는 'defer' 문이 포함되어 있습니다
go.refactoring.introduce.receiver.without.name.error.message=리시버에는 이름이 있어야 합니다
go.refactoring.introduce.type.chooser.title=타입 선택
go.refactoring.introduce.type.command=타입 삽입
go.refactoring.introduce.type.dialog.title=타입 삽입
go.refactoring.less.than.one.declaration.validation.message=하나 이상의 선언을 선택해야 합니다.
go.refactoring.merge.declarations.action.text=병합 선언
go.refactoring.merge.declarations.with.iota.warning=선언 이니셜라이저는 'iota' 때문에 병합 후 다른 값을 갖게 됩니다
go.refactoring.move.affect.initialization.order.validation.message=함수 {0}을(를) 이동하면 애플리케이션의 초기화 순서에 영향을 줄 수 있습니다
go.refactoring.move.break.initialization.validation.message=변수 {0}을(를) 이동하면 변수 {1}의 초기화가 중단됩니다
go.refactoring.move.exported.function.will.not.perform.initialization.validation.message=이제 내보낸 함수 {0}은(는) 초기화를 수행하지 않습니다
go.refactoring.move.exported.function.will.not.start.application.validation.message=이제 내보낸 함수 {0}은(는) 애플리케이션을 시작하지 않습니다
go.refactoring.move.file.should.differ.validation.message=타깃 파일은 소스 파일과 다를 수 있습니다
go.refactoring.move.function.will.not.start.application.validation.message=이제 패키지 {1}의 외부에 있는 함수 {0}은(는) 애플리케이션을 시작하지 않습니다
go.refactoring.move.required.by.validation.message={0}에 필요
go.refactoring.move.type.will.become.non.local.for.method.validation.message=타입 {0}은(는) 메서드 {1}에 대해 지역이 아니게 됩니다
go.refactoring.move.type.will.not.implement.interface.validation.message=이제 타입 {0}은(는) 인터페이스 {1}을(를) 구현하지 않습니다
go.refactoring.move.value.will.change.validation.message=상수 {0}의 값은 {1}을(를) 사용하여 선언될 때 변경됩니다
go.refactoring.non.go.file.validation.message=타깃 파일은 Go 파일이어야 합니다.
go.refactoring.non.writable.directory.validation.message=타깃 디렉터리는 쓰기 가능하지 않습니다.
go.refactoring.non.writeable.file.validation.message=타깃 파일은 쓰기 가능하지 않습니다.
go.refactoring.redeclare.validation.message={0}에서 동일한 이름의 {1}을(를) 다시 선언합니다
go.refactoring.refactor.action=리팩터링
go.refactoring.rename.action=이름 변경
go.refactoring.rename.all.receivers.option=모든 리시버 이름 변경
go.refactoring.rename.current.receiver.option=현재 리시버 이름만 변경
go.refactoring.rename.directory.message=패키지 디렉터리 ''{0}''의 이름도 변경하시겠어요?
go.refactoring.rename.looking.for.anonymous.field.usages.progress.title=익명 필드의 사용 위치 검색 중
go.refactoring.rename.looking.for.method.usages.progress.title=메서드 사용 위치 검색 중
go.refactoring.rename.package.title=패키지 ''{0}''의 이름도 ''{1}''(으)로 변경하시겠어요?
go.refactoring.rename.production.file.title=프로덕션 파일 ''{0}''의 이름도 변경하시겠어요?
go.refactoring.rename.test.file.title=테스트 파일 ''{0}''의 이름도 변경하시겠어요?
go.refactoring.rename.type.parameter.option.all=타입 정의와 모든 리시버에서 이름 변경
go.refactoring.rename.type.parameter.option.current.only=이 타입 매개변수만 이름 변경
go.refactoring.split.declarations.action.text=선언 분할
go.refactoring.split.declarations.with.iota.warning=선언 이니셜라이저는 'iota' 때문에 분할 후 다른 값을 갖게 됩니다
go.refactoring.unexported.validation.message=내보내지 않은 {0}은(는) {1}에서 액세스할 수 없습니다
go.remote.debug.disconnect.delve.label=연결 해제 시:
go.remote.debug.disconnect.delve.option.ask=확인하기
go.remote.debug.disconnect.delve.option.leave=계속 실행하기
go.remote.debug.disconnect.delve.option.stop=원격 Delve 프로세스 중지
go.remove.else=else 제거
go.replace.field.type.with.pointer.family.name=필드 타입을 포인터로 바꾸기
go.run.configuration.add.go.tool.argument.label=추가
go.run.configuration.build.on.remote.target.checkbox=원격 타깃에서 빌드(&B)
go.run.configuration.environment.label=환경(&V):
go.run.configuration.go.tool.arguments.label=Go 도구 인수(&G):
go.run.configuration.kind.directory=디렉터리
go.run.configuration.kind.file=파일
go.run.configuration.kind.package=패키지
go.run.configuration.module.label=모듈(&M):
go.run.configuration.output.directory.label=출력 디렉터리(&O):
go.run.configuration.program.arguments.label=프로그램 인수(&P):
go.run.configuration.run.after.build.checkbox=빌드 후 실행(&R):
go.run.configuration.run.kind.label=실행 종류(&K):
go.run.configuration.run.with.sudo.label=sudo로 실행(&I) 
go.run.configuration.run.with.sudo.mnemonic=높은 권한으로 실행(&I)
go.run.configuration.run.with.sudo.tooltip=슈퍼 유저 권한으로 구성 실행
go.run.configuration.target.directory.label=디렉터리(&D):
go.run.configuration.target.files.label=파일(&F):
go.run.configuration.target.package.label=패키지 경로(&E):
go.run.configuration.test.framework=테스트 프레임워크(&R):
go.run.configuration.test.kind.label=테스트 종류(&K):
go.run.configuration.test.pattern.label=패턴(&T):
go.run.configuration.use.all.custom.build.tags.label=모든 사용자 지정 빌드 태그 사용(&L)
go.run.configuration.use.all.custom.build.tags.tooltip=빌드 프로세스 중 설정 내 모든 사용자 지정 빌드 태그가 추가됩니다('Go | 태그 빌드' 참조)
go.run.playground.could.not.run.message=코드를 실행할 수 없습니다
go.run.target.compiled.executables.description=타깃에서 컴파일된 실행 파일의 출력 경로
go.run.target.compiled.executables.directory.browsing.title=컴파일된 실행 파일
go.run.target.compiled.executables.directory.label=컴파일된 실행 파일 디렉터리:
go.run.target.configure.label=Go 구성
go.run.target.executable.path.label=Go 실행 파일:
go.run.target.executable.path.title=Go 실행 파일
go.run.target.gopath.label=GOPATH:
go.run.target.gopath.title=GOPATH
go.run.target.project.sources.description=타깃에서 프로젝트 소스의 출력 경로
go.run.target.project.sources.directory.browsing.title=프로젝트 소스
go.run.target.project.sources.directory.label=프로젝트 소스 디렉터리:
go.run.target.run.label=Go 애플리케이션 실행
go.run.target.version.label=버전:
go.sdk.no.version.text=<버전 없음>
go.settings.build.tags.any.sdk.value=임의
go.settings.build.tags.arch.label=Arch
go.settings.build.tags.cgo.support.label=Cgo 지원
go.settings.build.tags.compiler.label=컴파일러
go.settings.build.tags.custom.tags.hint=<html><body><p>공백으로 구분된 추가 태그 목록. 'go build' 명령어에서 <a href="https://www.jetbrains.com/help/go/configuring-build-constraints-and-vendoring.html">사용 가능</a>합니다.</p></body></html>
go.settings.build.tags.custom.tags.label=사용자 지정 태그
go.settings.build.tags.description=<html><body><p>다음 옵션은 에디터의 타깃 시스템을 나타냅니다. IDE는 이러한 값을 사용해 검증, 해결, 코드 완성에 사용할 파일을 정의합니다. 이러한 옵션에 대한 자세한 정보는 <a href="https://golang.org/pkg/go/build/#hdr-Build_Constraints">Go 제약에 관한 문서</a>를 참조해주세요.</p></body></html>
go.settings.build.tags.display.name=태그 빌드
go.settings.build.tags.group.name=에디터 제약
go.settings.build.tags.os.label=OS
go.settings.build.tags.version.label=Go 버전
go.settings.common.ask.for.confirmation.in.playground.checkbox=Go Playground에서 공유하기 전에 묻기
go.settings.common.confirmation.show.options.option=옵션 표시
go.settings.common.convert.json.on.paste.convert.option=Go 타입으로 JSON 변환
go.settings.common.convert.json.on.paste.insert.as.is.option=JSON 그대로 삽입
go.settings.common.convert.json.on.paste.option=JSON이 붙여넣기된 경우
go.settings.common.detect.go.packages.from.clipboard.checkbox=클립보드에서 Go 패키지 탐지
go.settings.common.directory.rename.do.not.rename.package.option=패키지 이름 변경 안 함
go.settings.common.directory.rename.option=디렉터리 이름이 변경된 경우
go.settings.common.directory.rename.rename.package.option=패키지 이름 변경
go.settings.common.indent.on.enter.in.raw.strings.checkbox=원시 문자열에서 Enter 입력 시 들여쓰기
go.settings.common.package.rename.do.not.rename.directory.option=디렉터리 이름 변경 안 함
go.settings.common.package.rename.option=패키지 이름이 변경된 경우
go.settings.common.package.rename.rename.directory.option=디렉터리 이름 변경
go.settings.common.show.auto.import.in.completion.popup.checkbox=입력 시 추가 가져오기가 필요한 항목 제안
go.settings.common.show.documentation.in.parameter.info.checkbox=매개변수 정보에 문서 표시
go.settings.common.suggest.parameter.names.checkbox=코드 완성 시 매개변수 이름 제안
go.settings.common.test.do.not.rename.corresponding.file.option=해당하는 테스트 또는 프로덕션 파일 이름 변경 안 함
go.settings.common.test.rename.corresponding.file.option=해당하는 테스트 또는 프로덕션 파일 이름 변경
go.settings.common.test.rename.option=파일 이름이 변경된 경우
go.settings.completion.ml.display.name=Go
go.settings.debugger.dataViews.section.name=Go
go.settings.debugger.default.integer.format.label=디폴트 정수 형식:
go.settings.debugger.general.section.name=Go
go.settings.debugger.goroutines.limit.name=고루틴 제한
go.settings.debugger.max.array.values=배열, 슬라이스 혹은 맵에서 읽어 올 요소의 최대 개수
go.settings.debugger.max.string.len=문자열에서 읽어올 최대 바이트 수
go.settings.debugger.max.string.len.in.call=함수 호출 결과로 발생한 문자열에서 읽어올 바이트 수
go.settings.debugger.max.struct.fields=구조체에서 읽어 올 최대 필드 개수(-1로 설정하면 모든 필드를 읽습니다)
go.settings.debugger.rebuild.transitive.packages.checkbox=이행적 패키지 재구성(&R)
go.settings.debugger.rebuild.transitive.packages.description=디버그 경험을 향상하려면 Delve가 $GOROOT/pkg에서 최적화된 모듈을 다시 컴파일해야 합니다.
go.settings.debugger.show.pointer.addresses=포인터 주소 표시
go.settings.debugger.show.types=타입 표시
go.settings.debugger.stack.depth.name=스택 깊이
go.settings.debugger.use.custom.delve.settings=Delve 디버그 설정 구성
go.settings.default.value=디폴트 값({0})
go.settings.diff.ignore.imports.and.formatting.description=import 문 및 서식 지정 무시
go.settings.disabled=비활성화됨
go.settings.enabled=활성화됨
go.settings.folding.format.strings.checkbox=서식 문자열
go.settings.folding.one.line.panics.checkbox=한 줄 패닉
go.settings.folding.one.line.return.checkbox=한 줄 반환
go.settings.formatter.add.space.except.for.comments.label=다음으로 시작하는 주석 제외:
go.settings.formatter.comment.prefix.cannot.be.empty.validation.message=주석 접두사는 공백일 수 없습니다
go.settings.formatter.comment.prefix.dialog.title=주석 접두사
go.settings.formatter.no.exceptions.empty.text=예외 없음
go.settings.formatter.wrap.call.arguments=함수 호출 인수
go.settings.formatter.wrap.comp.lit=복합 리터럴
go.settings.formatter.wrap.func.params=함수 매개변수
go.settings.formatter.wrap.func.result=함수 결과 매개변수
go.settings.global.gopath.group.name=전역 GOPATH
go.settings.imports.display.name=가져오기
go.settings.invalid.build.tag.error=올바르지 않은 빌드 태그: ''{0}''
go.settings.module.gopath.group.name=모듈 GOPATH
go.settings.modules.add.other.environment.variable=기타
go.settings.modules.automatic.dependencies.download.checkbox.link=빌드 도구 페이지로 이동
go.settings.modules.automatic.dependencies.download.checkbox.tooltip=<p>프로젝트가 열리고 종속 요소가 변경될 때마다 자동으로 'go mod download'를 실행합니다. 인터넷 연결이 제한되는 경우에는 이 옵션을 비활성화하세요.</p><p>Go 모듈의 변경 사항 모니터링은 Build, Execution, Deployment | Build Tools(빌드, 실행, 배포 | 빌드 도구) 페이지에서 구성할 수 있습니다</p>
go.settings.modules.automatic.dependencies.download.disable.for.all=모든 프로젝트에서 비활성화
go.settings.modules.automatic.dependencies.download.disable.for.current.project=현재 프로젝트에서는 비활성화하고 다른 프로젝트에서는 활성화
go.settings.modules.automatic.dependencies.download.enable.for.all=모든 프로젝트에서 활성화
go.settings.modules.automatic.dependencies.download.enable.for.current.project=현재 프로젝트에서는 활성화하고 다른 프로젝트에서는 비활성화
go.settings.modules.automatic.dependencies.download.label=Go 모듈 종속 요소 다운로드:
go.settings.modules.choose.module.dialog.title=Go 모듈 선택
go.settings.modules.choose.module.validation.message=최소 하나의 모듈을 선택하세요
go.settings.modules.display.title=Go 모듈
go.settings.modules.enable.integration.checkbox=Go 모듈 통합 활성화
go.settings.modules.environment.context.help=GOPROXY, GOPRIVATE, 기타 환경 변수
go.settings.modules.environment.label=환경:
go.settings.modules.explain.environment.variable=변수 설명
go.settings.modules.gomodcache.description=GOMODCACHE는 모듈 캐시 위치를 설정합니다.
go.settings.modules.gomodcache.documentation.link.title=Go 1.15 릴리스 노트
go.settings.modules.gonoproxy.description=GONOPROXY는 private으로 간주되는 패키지를 나열합니다. 이 패키지를 다운로드하는 동안에는 Go 명령어가 프록시를 사용하지 않습니다. GOPRIVATE을 재정의합니다.
go.settings.modules.gonosumdb.description=GONOSUMDB는 private으로 간주되는 패키지를 나열합니다. 이 패키지에 대해 유효성 검사를 실행하는 동안에는 Go 명령어가 체크섬 데이터베이스를 사용하지 않습니다. GOPRIVATE을 재정의합니다.
go.settings.modules.goprivate.description=GOPRIVATE은 private으로 간주되는 패키지를 나열합니다. 이 패키지를 다운로드하거나 유효성 검사를 실행하는 동안에는 Go 명령어가 프록시나 체크섬 데이터베이스를 사용하지 않습니다.
go.settings.modules.goprivate.documentation.link.title=비 public 모듈의 모듈 구성
go.settings.modules.goproxy.documentation.link.title=모듈 다운로드 및 검증
go.settings.modules.goproxy.tooltip=GOPROXY는 종속성 다운로드 시 go 명령어가 특정 프록시 서버를 사용하도록 지시합니다.
go.settings.modules.gosumdb.description=GOSUMDB는 체크섬 데이터베이스 이름을 식별합니다. 이 값은 다운로드한 종속성의 체크섬이 변경되지 않았는지 확인하기 위해 Go 명령어에서 사용합니다.
go.settings.modules.gosumdb.documentation.link.title=모듈 인증 실패
go.settings.modules.gotoolchain.description=GOTOOLCHAIN이 사용할 Go SDK 버전을 설정합니다.
go.settings.modules.gotoolchain.documentation.link.title=Go 툴체인
go.settings.modules.sync.dependencies.fix.family.name=종속성 동기화
go.settings.modules.sync.dependencies.fix.text={0}의 종속성 동기화
go.settings.modules.vendoring.checkbox=벤더링 지원 지동 활성화
go.settings.modules.vendoring.checkbox.tooltip=모듈에 'vendor' 디렉터리가 포함되는 경우 벤더링 지원을 활성화합니다. 'vendor' 디렉터리가 Go 언어로 생성되지 않고 Go 종속 요소를 포함하지 않는 경우 이 체크박스를 해제하세요. 이 옵션을 끄면 'go' 도구가 '-mod=mod' 혹은 '-mod=readonly' 옵션으로 호출됩니다.
go.settings.modules.vendoring.documentation.link.title=모듈과 함께 벤더링을 사용하는 방법
go.settings.postfix.choose.type.action.name=타입 선택…
go.settings.postfix.choose.type.prompt.text=타입 선택
go.settings.postfix.enter.type.action.name=타입 이름 입력…
go.settings.postfix.enter.type.empty.type.validation.message=타입 이름을 지정하세요
go.settings.postfix.enter.type.import.path.label=가져오기 경로(&I):
go.settings.postfix.enter.type.name.label=타입 이름(&T):
go.settings.project.gopath.group.name=프로젝트 GOPATH
go.settings.project.sdk.value=프로젝트 SDK({0})
go.settings.sdk.add.action.name=로컬…
go.settings.sdk.add.button=SDK 추가…
go.settings.sdk.add.button.tooltip=SDK({0}) 추가
go.settings.sdk.add.local.title=Go SDK 홈 디렉터리 선택
go.settings.sdk.combo.tooltip=SDK 추가…
go.settings.sdk.detected.notification.configure.go.sdk.action.text=Go SDK 구성
go.settings.sdk.detected.notification.text=<b>{0}</b>이(가) 프로젝트 SDK로 자동 설정되었습니다. GOROOT 구성에서 이를 변경할 수 있습니다.
go.settings.sdk.detected.notification.title=GOROOT가 탐지됨
go.settings.sdk.discovering.go.sdks.progress.title=Go SDK 찾는 중…
go.settings.sdk.download.action.name=다운로드…
go.settings.sdk.download.checksum.of.downloaded.file.mismatched.error=다운로드한 파일의 체크섬이 일치하지 않습니다
go.settings.sdk.download.could.not.copy.unpacked.sdk.error=패킹 해제된 SDK를 복사할 수 없습니다
go.settings.sdk.download.could.not.find.go.directory.in.downloaded.file.error=다운로드한 파일에서 Go 디렉터리를 찾을 수 없습니다
go.settings.sdk.download.could.not.get.checksum.error=체크섬을 가져올 수 없습니다. {0}
go.settings.sdk.download.could.not.unpack.downloaded.file.error=다운로드한 파일을 패킹 해제할 수 없습니다
go.settings.sdk.download.dialog.cannot.create.directory.validation.message=주어진 경로에 디렉터리를 생성할 수 없습니다.
go.settings.sdk.download.dialog.cannot.load.go.versions.validation.message=SDK 버전을 로드할 수 없습니다. {0}
go.settings.sdk.download.dialog.location.is.not.specified.validation.message=타깃 디렉터리를 지정하세요.
go.settings.sdk.download.dialog.location.label=위치:
go.settings.sdk.download.dialog.progress.versions.status=Go SDK 버전
go.settings.sdk.download.dialog.reload.versions.action.name=다시 로드
go.settings.sdk.download.dialog.title=Go SDK 다운로드
go.settings.sdk.download.dialog.version.is.not.specified.validation.message=버전을 지정하세요.
go.settings.sdk.download.dialog.version.label=버전:
go.settings.sdk.download.failed.to.download.notification.title=SDK 다운로드 실패
go.settings.sdk.download.installed.notification.title={0} {1} 설치 완료
go.settings.sdk.download.progress.copying.detailed.status={0} 복사 중…
go.settings.sdk.download.progress.copying.status=SDK 복사 중…
go.settings.sdk.download.progress.downloading.status={0} {1} 다운로드 중
go.settings.sdk.download.progress.unpacking.status=SDK 패킹 해제 중…
go.settings.sdk.download.progress.verifying.status=다운로드한 아카이브 검사 중…
go.settings.sdk.download.unpacked.sdk.is.corrupted.error=패킹 해제된 SDK가 손상되었습니다
go.settings.sdk.enable.integration.label=모듈에서 Go 지원 활성화:
go.structure.view.exportability.sorter.text=내보내기 가능 여부로 정렬
go.structure.view.method.location={0}
go.structure.view.private.members.filter.text=private 멤버 표시
go.structure.view.show.package.structure.action.text=패키지 구조 표시
go.sum.generated.sources.filter.notification.text=해당 파일은 Go 도구에서만 사용하도록 되어 있으므로 편집해서는 안 됩니다. 변경하면 빌드 프로세스가 중단될 수 있습니다.
go.template.intention.add.type.hint.name=마침표 타입 지정
go.template.intention.associate.file.extension.with.go.template=Go 템플릿과 파일 확장자 연결
go.template.intention.extension.associated.with.template=''{0}'' 확장이 Go 템플릿과 연결되었습니다
go.template.intention.open.file.type.settings=Go 템플릿 파일 타입 설정 열기
go.template.intention.undo=실행 취소
go.terms.anonymous.field=익명 필드
go.terms.array=배열
go.terms.case=case
go.terms.chan=chan
go.terms.closure=클로저
go.terms.comma=쉼표
go.terms.comment=주석
go.terms.constant=상수
go.terms.declaration=선언
go.terms.duplicate=중복
go.terms.duplicated.case=case 중복
go.terms.duplicated.default=디폴트 중복
go.terms.empty.declaration=빈 선언
go.terms.field=필드
go.terms.function=함수
go.terms.global.constant=전역 상수
go.terms.global.variable=전역 변수
go.terms.go.statement=go 구문
go.terms.import=가져오기
go.terms.import.alias=import 문 별칭
go.terms.interface=인터페이스
go.terms.label=라벨
go.terms.map=맵
go.terms.method=메서드
go.terms.method.specification=메서드 사양
go.terms.module.statement=모듈 구문
go.terms.package=패키지
go.terms.package.capitalized=패키지
go.terms.package.statement=패키지 구문
go.terms.parameter=매개변수
go.terms.pointer=포인터
go.terms.receiver=리시버
go.terms.semicolon=세미콜론
go.terms.shadowed.declaration=가려진 선언
go.terms.slice=슬라이스
go.terms.statement=구문
go.terms.string=문자열
go.terms.struct=구조체
go.terms.type=타입
go.terms.type.alias=타입 별칭
go.terms.type.parameters=타입 매개변수
go.terms.type.pluralized=타입
go.terms.variable=변수
go.terms.version.statement=버전 구문
go.test.cannot.find.files.compatible.with.framework.error=<code>{0}</code>에서 프레임워크 <code>{1}</code>와(과) 호환되는 Go 테스트 파일을 찾을 수 없습니다
go.test.cannot.run.compiling.on.directory.kind.run.configurations.error=디렉터리 종류의 실행 구성에서는 테스트를 디버그할 수 없습니다. <a href="edit">테스트 종류: 패키지</a>를 사용하여 각 패키지에 대한 테스트를 디버그할 수 있습니다.
go.test.creator.cannot.find.field.type={0}의 필드 타입을 찾을 수 없습니다
go.test.creator.cannot.find.function.signature=함수 시그니처를 찾을 수 없습니다
go.test.creator.cannot.find.method.receiver={0}의 메서드 리시버를 찾을 수 없습니다
go.test.creator.cannot.find.method.receiver.type={0}의 메서드 리시버 타입을 찾을 수 없습니다
go.test.creator.cannot.find.test.import.path=테스트 가져오기 경로를 찾을 수 없습니다
go.test.creator.cannot.find.test.package.name=테스트 패키지 이름을 찾을 수 없음
go.test.creator.empty.test.file.name=빈 테스트 파일
go.test.creator.gotests.failed.to.create.test.file=테스트 파일 {0}을(를) 생성하지 못했습니다
go.test.creator.gotests.generation.failed.notification.title=테스트 생성 실패
go.test.creator.gotests.generation.name=테스트 생성
go.test.creator.gotests.no.tests.generated=생성된 테스트가 없습니다
go.test.creator.progress.title.searching.for.functions.for.test=테스트할 함수 검색 중…
go.test.creator.progress.title.searching.for.tests.for.function=함수용 테스트 검색 중...
go.test.creator.test.for.file.name=파일 테스트
go.test.creator.test.for.function.name=함수 테스트
go.test.creator.test.for.package.name=패키지 테스트
go.test.creator.test.for.selection.name=선택 항목 테스트
go.test.file.does.not.exist.error=파일이 없습니다. {0}
go.test.framework.is.not.available.on.files.error=프레임워크 <code>{0}</code>은(는) 모든 <code>{1}</code> 파일에서 지원되지 않습니다
go.test.framework.not.available.in.module.error=프레임워크 <code>{0}</code>은(는) 선택한 모듈에서 지원되지 않습니다
go.test.fuzzing.duplicate.header=중복 헤더
go.test.fuzzing.header.expected='go test fuzz v1' 헤더 필요
go.test.fuzzing.incorrect.header.position=헤더는 파일의 시작 부분에 있어야 합니다
go.test.fuzzing.label.corpus.label=Go fuzz 시드 코퍼스
go.test.fuzzing.value.expected=최소 하나의 값이 필요
go.test.generate.benchmark.text=벤치마크
go.test.generate.example.text=예
go.test.generate.function.description={0} 함수 생성
go.test.generate.fuzz.text=퍼징
go.test.generate.table.benchmark.description=테이블 벤치마크 함수 생성
go.test.generate.table.benchmark.text=테이블 벤치마크
go.test.generate.table.test.description=테이블 테스트 함수 생성
go.test.generate.table.test.text=테이블 테스트
go.test.generate.test.main.text=Test_main
go.test.generate.test.text=테스트
go.test.no.tests.were.run=실행된 테스트가 없습니다
go.test.non.a.package.error=<code>{0}</code>은(는) 패키지가 아닙니다.<br>디렉터리 형식의 실행 구성을 사용하여 디렉터리에서 재귀적으로 테스트를 실행하세요.
go.test.not.go.file.error=''{0}'' 파일은 Go 파일이 아닙니다.
go.test.run.configuration.description=Go 테스트 실행 구성
go.test.run.configuration.name=Go 테스트
go.test.run.fuzzing.tooltip=퍼징 실행
go.test.run.test.tooltip=테스트 실행
go.test.suggested.run.configuration.name={1} 내 {0}
go.test.template.run.configuration.name=Go 테스트
go.test.testify.run.configuration.name={1} 내 {0}
go.test.testify.unknown.target.name=알 수 없음
go.test.testing.directory.does.not.exist.error=테스트 디렉터리가 없습니다
go.test.working.directory.should.be.ancestor.of.testing.directory.error=작업 디렉터리는 테스트 디렉터리의 상위 디렉터리여야 합니다
go.unknown.type.information.hint=<알 수 없음>
go.unwrap.argument=인수 줄 바꿈 해제
go.unwrap.argument.description={0} 줄 바꿈 해제
go.unwrap.else=else 줄 바꿈 해제
go.unwrap.for=줄 바꿈 해제
go.unwrap.if=if 줄 바꿈 해제
go.usage.type.call=호출
go.usage.type.const.declaration=상수 선언
go.usage.type.field.declaration=필드 선언
go.usage.type.function.argument=함수 인수
go.usage.type.import=가져오기
go.usage.type.parameter.declaration=매개변수 선언
go.usage.type.receiver=리시버
go.usage.type.return.type=반환 타입
go.usage.type.struct.initialization=구조체 초기화
go.usage.type.type.alias=타입 별칭
go.usage.type.type.assertion=타입 어설션
go.usage.type.type.constraint=타입 제약
go.usage.type.type.conversion=타입 변환
go.usage.type.type.instantiation=타입 인스턴스화
go.usage.type.type.parameter.declaration=유형 매개변수 선언
go.usage.type.variable.declaration=변수 선언
go.use.gopath.from.system.environment.checkbox=시스템 환경에 정의된 GOPATH 사용
go.value.cannot.be.represented.by.type={0}의 값은 타입 {1}(으)로 나타낼 수 없습니다
go.wizard.description=애플리케이션 및 라이브러리를 개발하려면 GOPATH 아래에 Go 프로젝트를 생성하세요
go.wizard.name=Go(GOPATH)
go.wsl.attach.host.group.name=WSL
go.wsl.resolving.user.home=WSL 사용자 홈 디렉터리 해결 중
go.wsl.sdk.unpack.error=패킹 해제 명령어가 종료 코드 {0}(으)로 실패했습니다
group.DlvDebugger.ViewAsGroup.text=다음으로 표시
group.GoTools.description=Go 외부 도구
group.GoTools.text=Go 도구
inlay.go.inlays.display.constant.definition.description=상수 정의 값을 확인합니다.
inlay.parameters.go.return.parameters=return 문의 매개변수 이름을 표시합니다.
inlay.parameters.go.struct.unnamed.struct.fields=익명 필드 이름을 표시합니다.
notification.group.build=Go 빌드
notification.group.debug=Go 디버그
notification.group.execution=Go 실행
notification.group.general=Go
notification.group.tools=Go 도구 통합
notification.group.tools.sticky=Go 도구 통합(중요)
postfix.template.condition.array.name=배열
postfix.template.condition.assignable.slice.name=대입 가능한 슬라이스
postfix.template.condition.boolean.name=부울
postfix.template.condition.builtin.append.applicable.name=기본 제공 append 적용 가능
postfix.template.condition.builtin.cap.applicable.name=기본 제공 cap 적용 가능
postfix.template.condition.builtin.len.applicable.name=기본 제공 len 적용 가능
postfix.template.condition.channel.name=채널
postfix.template.condition.comparable.to.nil.name=nil과 비교 가능
postfix.template.condition.error.expr.result.name=오류 결과를 포함하는 표현식
postfix.template.condition.error.name=오류
postfix.template.condition.expr.in.if.with.missing.block.name=블록이 누락된 if 조건 내 표현식
postfix.template.condition.floats.slice.name=float64의 슬라이스
postfix.template.condition.interface.impls.slice.name=sort 인터페이스 구현의 슬라이스
postfix.template.condition.ints.slice.name=int의 슬라이스
postfix.template.condition.map.name=맵
postfix.template.condition.non.void.name=비 void
postfix.template.condition.number.name=숫자
postfix.template.condition.slice.name=슬라이스
postfix.template.condition.slice.with.no.sort.name=전용 sort 함수가 없는 슬라이스
postfix.template.condition.string.name=문자열
postfix.template.condition.strings.slice.name=문자열의 슬라이스
postfix.template.provider.name=Go
project.files.and.vendor.scope.name=프로젝트 파일 및 벤더
vgo.fix.delete.replacement=대체 삭제
vgo.fix.dependency-deprecated.family-name=사용 중단 공지 표시
vgo.fix.dependency-deprecated.message={0} 사용 중단 공지 표시
vgo.fix.dependency-update.family-name=종속 요소 버전 업데이트
vgo.fix.dependency-update.single.message=최신 버전인 {0}(으)로 업데이트
vgo.fix.dependency-version-retracted.family-name=철회 공지 표시
vgo.fix.dependency-version-retracted.message={0} 철회 공지 표시
vgo.inspection.dependency-deprecated-retracted.option.deprecation-notice=사용 중단 공지
vgo.inspection.dependency-deprecated-retracted.option.retraction-notice=철회 공지
vgo.inspection.dependency-deprecated-retracted.tooltip-template=<html><body>{0}.<p><span style="color:{3}">{1}:</span> {2}</body></html>
vgo.inspection.dependency-deprecated.display-name=사용이 중단된 종속 요소
vgo.inspection.dependency-deprecated.message=사용이 중단된 모듈 {0}
vgo.inspection.dependency-update.display-name=종속 요소를 업데이트할 수 있음
vgo.inspection.dependency-update.message={0}@{1}의 최신 버전을 사용할 수 있습니다. {2}
vgo.inspection.dependency-update.tooltip=새로운 버전 사용 가능: {0}
vgo.inspection.dependency-version-retracted.display-name=철회된 종속 요소 버전
vgo.inspection.dependency-version-retracted.message=철회된 모듈 버전 {0}@{1}
vgo.inspection.dependency-version-retracted.tooltip=철회된 모듈 버전 {0}
vgo.intention.add.all.replaced.modules.to.workspace.fix.text=작업공간에 로컬로 대체된 모든 모듈 추가
vgo.intention.add.module.to.workspace.fix.family.name=작업공간에 모듈 추가
vgo.intention.add.module.to.workspace.fix.text=작업공간에 ''{0}'' 모듈 추가
vgo.intention.add.or.update.go.version.fix.family.name='go.mod'의 Go 버전을 추가 또는 업데이트
vgo.intention.add.or.update.go.version.fix.text=''go.mod''의 Go 버전을 {0}(으)로 설정
vgo.intention.dependency-update.aggregated.message=업데이트…
vgo.intention.dependency-update.aggregated.popup.title=업데이트…
vgo.intention.dependency-update.all.message=모든 종속 요소를 {0} 버전으로 업데이트
vgo.intention.dependency-update.direct.message=직접 종속 요소를 {0} 버전으로 업데이트
vgo.intention.dependency-update.option.latest=최신
vgo.intention.dependency-update.option.latest-patch=최신 패치
vgo.intention.merge.use.directives.family.name=여러 'use' 지시문을 하나로 병합
vgo.intention.run.why.command.fix.family.name='go mod why -m' 실행
vgo.intentions.category=Go 모듈
vgo.update-service.command-presentation-name={0}의 종속 요소 업데이트를 가져오는 중