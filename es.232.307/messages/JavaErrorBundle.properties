abstract.cannot.be.instantiated=''{0}'' es abstracto; no se puede instanciar
abstract.method.0.cannot.be.accessed.directly.method.reference.context=No se puede acceder directamente al método abstracto ''{0}''
abstract.method.in.non.abstract.class=Método abstracto en clase no abstracta
abstract.methods.cannot.have.a.body=Los métodos abstractos no pueden tener cuerpo
actual.type.argument.contradict.inferred.type=El argumento de tipo real y el tipo inferido se contradicen entre sí
ambiguous.method.call=Llamada al método ambiguo: ambos ''{0}'' y ''{1}'' coinciden
ambiguous.method.call.no.match=No se puede resolver el método ''{0}'' en ''{1}''
ambiguous.method.html.tooltip=0>{0}>Llamada de método ambigua. Ambos</td></tr>''padding: 0px 16px 8px 4px;color: {5}''>Tipo obligatorio:</td><td style=''padding: 0px 4px 8px 0px;''>{0}</td>{1}</tr>Los métodos abstractos de la interfaz no pueden tener cuerpo
an.enclosing.instance.of.type.not.in.scope.method.reference.context=Una instancia adjunta de tipo {0} no está en el alcance
annotation.annotation.type.expected=Se esperaba Tipo de anotación
annotation.cannot.be.local=No se permiten anotaciones locales
annotation.container.abstract=La anotación de contenedor ''{0}'' no tiene un valor predeterminado para ''{1}''
annotation.container.bad.type=Anotación de contenedor no válida ''{0}'': el método '' valor '' debe tener el tipo ''{1}''
annotation.container.low.retention=La anotación de contenedor ''{0}'' tiene una retención más corta (''{1}'') que la anotación contenida
annotation.container.missed.annotation=La anotación del contenedor ''{0}'' no tiene la anotación @{1} requerida
annotation.container.no.value=Anotación de contenedor no válida ''{0}'': ningún método de '' valor '' declarado
annotation.container.not.applicable=La anotación de contenedor ''@{0}'' no se aplica a {1}
annotation.container.wide.target=El objetivo de la anotación del contenedor ''{0}'' no es un subconjunto del objetivo de esta anotación
annotation.container.wrong.place=La anotación de contenedor ''{0}'' no debe estar presente al mismo tiempo que el elemento que contiene
annotation.cyclic.element.type=Tipo de elemento de anotación cíclica
annotation.duplicate.annotation=Anotación duplicada
annotation.duplicate.attribute=Atributo duplicado ''{0}''
annotation.duplicate.explained=Anotación duplicada. {0}
annotation.illegal.array.initializer=Inicializador ilegal para ''{0}''
annotation.interface.members.may.not.have.parameters=@interface miembros pueden no tener parámetros
annotation.invalid.annotation.member.type=Tipo no válido ''{0}'' para miembro de anotación
annotation.may.not.have.extends.list=@interface puede no tener una lista de extensiones
annotation.may.not.have.type.parameters=@interface puede no tener parámetros de tipo
annotation.members.may.not.have.throws.list=@interface miembros pueden no tener lista de lanzamientos
annotation.missing.attribute={0} falta aunque es obligatorio
annotation.missing.method=No se puede encontrar el método ''{0}''
annotation.non.class.literal.attribute.value=El valor del atributo debe ser un literal de clase
annotation.non.constant.attribute.value=El valor del atributo debe ser constante
annotation.non.enum.constant.attribute.value=El valor del atributo debe ser una constante de enumeración
annotation.non.repeatable=La declaración de ''{0}'' no tiene una anotación java.lang.annotation.Repetible válida
annotation.not.allowed.class=El tipo de literal de clase no se puede anotar
annotation.not.allowed.here=Aquí no se permiten anotaciones
annotation.not.allowed.ref=Anotación no aplicable a este tipo de referencia
annotation.not.allowed.static=No se puede anotar el tipo de miembro estático que califica
annotation.not.allowed.var=No se puede anotar el tipo ''var''
annotation.not.allowed.void=El tipo 'void' no puede ser anotado
annotation.not.applicable=''@{0}'' no se aplica a {1}
annotation.on.static.member.qualifying.type.family.name=Mover tipo de anotación
annotation.type.permits=La cláusula de permiso no está permitida para el tipo de anotación.
annotation.unknown.method=No se puede resolver el método ''{0}''
anonymous.class.implements.interface.cannot.have.qualifier=La clase anónima implementa la interfaz; no puede tener calificador para nuevo
anonymous.class.implements.interface.cannot.have.type.arguments=La clase anónima implementa la interfaz; no puede tener argumentos de tipo
anonymous.classes.must.not.extend.sealed.classes=Las clases anónimas no deben extender las clases selladas
array.creation.with.type.arguments=No se puede crear una matriz con argumentos de tipo
array.initializer.not.allowed=El inicializador de matriz no está permitido aquí
array.type.expected=Tipo de matriz esperado; encontrado: ''{0}''
assert.identifier.warn=El uso de 'assert' como identificador no se admite en las versiones desde Java 1.4
assignment.to.final.variable=No se puede asignar un valor a la variable final ''{0}''
auto.closeable.resource=Recursos que pueden cancelarse automáticamente
bad.qualifier.in.super.method.reference.extended=Calificador de tipo no válido en superllamada predeterminada: interfaz innecesaria {0} extendida en {1}
bad.qualifier.in.super.method.reference.overridden=Calificador de tipo no válido en la superllamada predeterminada: el método {0} se redefine en {1}
bad.type.in.switch.expression=Tipo incorrecto en la expresión de cambio: {0} no se puede convertir a {1}
binary.numbers.must.contain.at.least.one.hexadecimal.digit=Los números binarios deben contener al menos un dígito binario
binary.operator.not.applicable=El operador ''{0}'' no se puede aplicar a ''{1}'', ''{2}''
break.outside.switch.expr=Romper fuera de la expresión del interruptor adjunto
break.outside.switch.or.loop=Romper el interruptor o bucle exterior
call.to.super.is.not.allowed.in.enum.constructor=La llamada a super no está permitida en el constructor de enumeración
cannot.access.member.on.type=No se puede acceder al miembro ''{0}'' porque es de tipo primitivo {1}
cannot.be.referenced.from.static.context=''{0}'' no puede ser referenciado desde un contexto estático
cannot.call.method.on.type=No se puede llamar al método porque ''{0}'' es un tipo primitivo {1}
cannot.create.array.with.empty.diamond=No se puede crear una matriz con '<>'
cannot.find.class=No se puede encontrar la clase {0}
cannot.infer.functional.interface.type=No se puede inferir el tipo de interfaz funcional
cannot.resolve.constructor=No se puede resolver el constructor ''{0}''
cannot.resolve.method=No se puede resolver el método ''{0}''
cannot.resolve.package=No se puede resolver el paquete {0}
cannot.resolve.symbol=No se puede resolver el símbolo ''{0}''
cannot.select.dot.class.from.type.variable=No se puede seleccionar de una variable de tipo
cannot.select.from.a.type.parameter=No se puede seleccionar de un parámetro de tipo
cannot.select.from.parameterized.type=No se puede seleccionar del tipo parametrizado
case.statement.outside.switch=Declaración de caso fuera del interruptor
catch.without.try=Intenta 'pecar' atrapar
clash.methods.message={0}'' choca con ''{1}
clash.methods.message.show.classes={0}'' en ''{2}'' choca con ''{1}'' en ''{3}
class.already.imported=''{0}'' ya está definido en esta unidad de compilación
class.cannot.be.inherited.with.different.arguments={0} no se puede heredar con diferentes argumentos: {1}
class.cannot.extend.multiple.classes=La clase no puede extender varias clases
class.cannot.inherit.from.its.type.parameter=La clase no puede heredar de su parámetro de tipo
class.clashes.with.package=La clase ''{0}'' choca con el paquete del mismo nombre
class.expected=Nombre de clase esperado aquí
class.in.default.package=Class ''{0}'' está en el paquete predeterminado
class.is.already.defined.in.single.static.import=La clase ''{0}'' ya está definida en una única importación estática
class.is.ambiguous.in.single.static.import=Class ''{0}'' es ambigua en una sola importación estática
class.is.not.used=La clase ''{0}'' nunca se usa
class.member.declared.outside=Miembro de la clase declarado fuera de una clase
class.must.be.abstract=La clase ''{0}'' debe ser declarada abstracta o implementar el método abstracto ''{1}'' en ''{2}''
class.must.implement.method=La clase ''{0}'' debe implementar el método abstracto ''{1}'' en ''{2}''
class.name.expected=Nombre de clase esperado
class.not.allowed.to.extend.sealed.class.from.another.module=La clase no puede extender la clase sellada desde otro módulo
class.not.allowed.to.extend.sealed.class.from.another.package=La clase no puede extender la clase sellada de otro paquete
classes.extends.prohibited.super=Las clases no pueden extender directamente ''{0}''
compact.constructor.in.regular.class=Lista de parámetros esperada
constant.expression.required=Expresión constante requerida
constructor.call.must.be.first.statement=La llamada a ''{0}'' debe ser la primera declaración en el cuerpo del constructor
constructor.is.not.used=El constructor ''{0}'' nunca se usa
continue.outside.loop=Continuar fuera del bucle
continue.outside.switch.expr=Continuar fuera de la expresión del interruptor adjunto
create.class.action.this.not.valid.java.qualified.name=No es un nombre completo de Java válido
cyclic.inheritance=Herencia cíclica que involucra ''{0}''
declaration.not.allowed=Declaración no permitida aquí
declaration.or.variable.expected=Declaración, variable final o efectivamente final esperada
deconstruction.pattern.requires.record=Los patrones de desestructuración sólo se pueden aplicar a registros. ''{0}'' no es un registro
deconstruction.pattern.type.contain.annotation=No se permiten anotaciones dentro de los tipos de patrones de desestructuración.
default.label.must.not.contains.case.keyword=La etiqueta del caso predeterminado debe usar solo la palabra clave 'default' sin 'case'
default.label.not.allowed.here=Aquí no se permiten etiquetas predeterminadas. 'predeterminado' puede usarse como una etiqueta de caso único o combinarse solo con 'nulo'
default.method.overrides.object.member=El método predeterminado ''{0}'' anula un miembro de '' java.lang.Object ''
deprecated.default.constructor=El constructor predeterminado en ''{0}'' está obsoleto
deprecated.symbol=''{0}'' está obsoleto
different.case.kinds.in.switch=Diferentes tipos de casos usados en el interruptor
direct.abstract.method.access=No se puede acceder al método abstracto ''{0}'' directamente
dot.expected.after.super.or.this=Se esperaba '.'
duplicate.class=Clase duplicada: ''{0}''
duplicate.class.in.other.file=Clase duplicada encontrada en el archivo ''{0}''
duplicate.default.switch.label=Etiqueta predeterminada duplicada
duplicate.label=Etiqueta ''{0}'' ya en uso
duplicate.method={0}'' ya está definido en ''{1}
duplicate.switch.label=Etiqueta duplicada ''{0}''
duplicate.unconditional.pattern.label=Duplicación de patrones incondicional
else.without.if=Si no 'pecado' si
empty.character.literal=Literal de carácter vacío
enum.constant.must.implement.method=Enum constante ''{0}'' debe implementar el método abstracto ''{1}'' en ''{2}''
enum.identifier.warn=El uso de 'enum' como identificador no se admite en las versiones desde Java 1.5
enum.is.not.used=Enum ''{0}'' nunca se usa
enum.types.cannot.be.instantiated=No se pueden crear instancias de tipos de enumeración
error.cannot.infer.pattern.type=No se pudo inferir el tipo de patrón. {0}
error.cannot.resolve.class=No se puede resolver la clase ''{0}''
error.cannot.resolve.class.or.package=No se puede resolver la clase o el paquete ''{0}''
error.guard.allowed.after.patterns.only=Los guardias solo están permitidos después del patrón.
error.interface.member.clashes=@interface miembro choca con ''{0}'' en {1}
error.raw.deconstruction=No se permiten patrones desestructurantes originales.
exception.already.caught=La excepción ''{0}'' ya ha sido detectada
exception.already.caught.warn=Sección inaccesible: {1, choice, 0#excepción|2#excepciones} ''{0}'' {1, choice, 0#| 2#han} ya sido detectadas
exception.is.never.thrown=La excepción ''{0}'' nunca se lanza en el método
exception.must.be.disjoint=Los tipos de captura múltiple deben estar separados: ''{0}'' es una subclase de ''{1}''
exception.never.thrown.try=La excepción ''{0}'' nunca se lanza en el bloque try correspondiente
expected.boolean.expression=Se esperaba una expresión booleana
expected.catch.or.finally=Se esperaba 'catch' o 'finally'
expected.class.or.package=Clase o paquete esperado
expected.comma=Se esperaba ','
expected.expression=Expresión esperada
expected.identifier=Identificador esperado
expected.identifier.or.type=Identificador o tipo esperado
expected.lbrace=Se esperaba '{'
expected.lparen=Se esperaba '('
expected.lparen.or.lbracket=Se esperaba '(' o '['
expected.parameter=Se esperaba Parámetro
expected.rbrace=Se esperaba '}'
expected.rbracket=Se esperaba ']'
expected.rparen=Se esperaba ')'
expected.semicolon=Se esperaba ';'
expected.statement=Declaración esperada
expected.switch.label=Se esperaba 'case', 'default' o '}'
expected.switch.rule=Se esperaba una expresión, bloque o declaración throw
expected.while=Se esperaba 'while'
expression.expected=Expresión esperada
expression.with.type.void.not.allowed.as.string.template.embedded.expression=Las expresiones de tipo 'void' no se pueden usar con plantillas de cadenas incrustadas
extends.after.enum=No se permite la cláusula de extensión para enum
extension.method.in.class=Los métodos de extensión solo se pueden usar dentro de una interfaz
extension.method.should.have.a.body=El método de extensión debe tener un cuerpo
field.is.already.defined.in.single.static.import=El campo ''{0}'' ya está definido en una única importación estática
field.is.ambiguous.in.single.static.import=El campo ''{0}'' es ambiguo en una sola importación estática
field.is.not.used=El campo ''{0}'' nunca se usa
field.is.not.used.for.reading=El campo {0} ''{1}'' está asignado pero nunca se accede
final.method.override=''{0}'' no se puede anular ''{1}'' en ''{2}''; el método anulado es final
finally.without.try=Intenta' pecar' por fin
floating.point.number.too.large=Número de coma flotante demasiado grande
floating.point.number.too.small=Número de coma flotante demasiado pequeño
foreach.not.applicable=Foreach no aplicable al tipo ''{0}''
formal.varargs.element.type.inaccessible.here=El tipo de elemento formal de varargs {0} es inaccesible aquí
functional.interface.must.not.be.sealed.error.description=La interfaz funcional no se puede declarar como ''{0}''
generic.array.creation=Creación de matriz genérica
generic.extend.exception=La clase genérica no puede extender 'java.lang.Throwable'
generics.annotation.members.may.not.have.type.parameters=@interface miembros pueden no tener parámetros de tipo
generics.cannot.be.inherited.as.raw.and.generic={0}'' es un tipo primitivo y no se puede heredar utilizando el argumento de tipo genérico ''{1}
generics.cannot.be.inherited.with.different.type.arguments={0}'' no se puede heredar con argumentos de tipo diferente: ''{1}'' y ''{2}
generics.cannot.catch.type.parameters=No se pueden capturar los parámetros de tipo
generics.cannot.instanceof.type.parameters=Clase o matriz esperada
generics.diamond.not.applicable=El operador de diamante no es aplicable para tipos no parametrizados
generics.duplicate.type.parameter=Parámetro de tipo duplicado: ''{0}''
generics.enum.may.not.have.type.parameters=Enum puede no tener parámetros de tipo
generics.holder.method=Método
generics.holder.type=Tipo
generics.inferred.type.for.type.parameter.is.not.within.its.bound.extend=El tipo inferido ''{2}'' para el parámetro de tipo ''{0}'' no está dentro de su límite; debería extender ''{1}''
generics.inferred.type.for.type.parameter.is.not.within.its.bound.implement=El tipo inferido ''{2}'' para el parámetro de tipo ''{0}'' no está dentro de su límite; debería implementar ''{1}''
generics.methods.have.same.erasure={0}; ambos métodos tienen el mismo borrado
generics.methods.have.same.erasure.hide={0}; Ambos métodos tienen el mismo borrado, pero ninguno oculta el otro.
generics.methods.have.same.erasure.override={0}; Ambos métodos tienen el mismo borrado, pero ninguno anula al otro.
generics.reference.parameters.not.allowed=Los parámetros de referencia no están permitidos aquí
generics.select.static.class.from.parameterized.type=No se puede seleccionar la clase estática ''{0}'' del tipo parametrizado
generics.type.argument.cannot.be.of.primitive.type=El argumento de tipo no puede ser de tipo primitivo
generics.type.arguments.on.raw.method=Escriba los argumentos dados en un método sin procesar
generics.type.arguments.on.raw.type=Argumentos de tipo dados en un tipo sin formato
generics.type.or.method.does.not.have.type.parameters={0} ''{1}'' no tiene parámetros de tipo
generics.type.parameter.cannot.be.instantiated=El parámetro de tipo ''{0}'' no se puede instanciar directamente
generics.type.parameter.is.not.within.its.bound.extend=El parámetro de tipo ''{0}'' no está dentro de su límite; debería extender ''{1}''
generics.type.parameter.is.not.within.its.bound.implement=El parámetro de tipo ''{0}'' no está dentro de su límite; debería implementar ''{1}''
generics.unchecked.assignment=Asignación sin marcar: ''{0}'' a ''{1}''
generics.unchecked.call=Invocación del método no verificado ''{0}''
generics.unchecked.call.to.member.of.raw.type=Llamada sin marcar a ''{0}'' como miembro del tipo sin formato ''{1}''
generics.unchecked.cast=Reparto sin marcar: ''{0}'' a ''{1}''
generics.wildcard.not.expected=No se esperan comodines
generics.wildcards.may.be.used.only.as.reference.parameters=Los comodines solo pueden usarse como parámetros de referencia
generics.wrong.number.of.type.arguments=Número incorrecto de argumentos de tipo: {0}; requerido: {1}
guarded.pattern.variable.must.be.final=Las variables utilizadas en patrones protegidos deben ser finales o efectivamente finales
guarded.patterns.unavailable=Los patrones antiguos que se originan en JEP 406 no están disponibles a partir de la vista previa de Java 19
hexadecimal.numbers.must.contain.at.least.one.hexadecimal.digit=Los números hexadecimales deben contener al menos un dígito hexadecimal
identifier.is.not.allowed.here=No se permiten identificadores
illegal.escape.character.in.character.literal=Carácter de escape ilegal en carácter literal
illegal.escape.character.in.string.literal=Carácter de escape ilegal en literal de cadena
illegal.forward.reference=Referencia hacia adelante ilegal
illegal.generic.type.for.instanceof=Tipo genérico ilegal, por ejemplo
illegal.initializer=Inicializador ilegal para ''{0}''
illegal.line.end.in.string.literal=Final de línea ilegal en literal de cadena
illegal.self.reference=Autorreferencia ilegal
illegal.to.access.static.member.from.enum.constructor.or.instance.initializer=Es ilegal acceder al miembro estático ''{0}'' desde el constructor de enumeración o el inicializador de instancia
illegal.type.void=Tipo ilegal: 'void'
illegal.underscore=Subrayado ilegal
illegal.unicode.escape=Secuencia de escape Unicode no válida
implements.after.interface=No se permite ninguna cláusula de implementos para la interfaz
impossible.assign.declared.outside.guard=La variable ''{0}'' se declara fuera de la guardia y no se le puede asignar un valor
inaccessible.type=''{0}'' es inaccesible aquí
incompatible.modifiers=Combinación ilegal de modificadores: ''{0}'' y ''{1}''
incompatible.parameter.types.in.lambda=Tipos de parámetros incompatibles en la expresión lambda: esperado {0} pero encontrado {1}
incompatible.parameter.types.in.lambda.wrong.number.of.parameters=Tipos de parámetros incompatibles en la expresión lambda: número incorrecto de parámetros: esperado {0} pero encontrado {1}
incompatible.return.type=Intentando utilizar un tipo de retorno incompatible
incompatible.switch.null.type=No se puede convertir ''{0}'' a ''{1}''
incompatible.types=Tipos incompatibles. Encontrado: ''{1}'', obligatorio: ''{0}''
incompatible.types.html.tooltip=<br/> motivo: la referencia del método es ambigua: tanto ''{0}'' como ''{1}'' coinciden
inconvertible.type.cast=Tipos inconvertibles; no se puede transmitir ''{0}'' a ''{1}''
incorrect.number.of.nested.patterns=La cantidad de patrones anidados es incorrecta. {0} es obligatorio, pero se encontró {1}.
inheritance.from.final.class=No se puede heredar de {1} ''{0}''
initializer.must.be.able.to.complete.normally=El inicializador debe poder completarse normalmente
instance.method.cannot.override.static.method=El método de instancia ''{0}'' en ''{1}'' no puede anular el método estático ''{2}'' en ''{3}''
instanceof.pattern.equals=El tipo de patrón ''{0}'' es el mismo que el tipo de expresión
instanceof.pattern.supertype=El tipo de patrón ''{0}'' es un supertipo del tipo de expresión ''{1}''
insufficient.language.level={0} no se admiten en el nivel de lenguaje ''{1}''
integer.number.too.large=Número entero demasiado grande
interface.expected=Interfaz esperada aquí
interface.is.not.used=La interfaz ''{0}'' nunca se usa
interface.methods.cannot.have.body=Los métodos abstractos de la interfaz no pueden tener cuerpo
invalid.case.label.combination.constants.and.patterns=Combinación de etiquetas de caso no válida. La etiqueta del caso debe ser una lista de constantes de caso o un patrón de caso único.
invalid.case.label.combination.constants.and.patterns.unnamed=Combinación de etiquetas de caso no válida. Las etiquetas de casos deben ser una lista de constantes de casos o una lista de patrones de casos.
invalid.case.label.combination.several.patterns=Combinación de etiquetas de caso no válida. Una etiqueta de caso no puede tener más de un patrón de caso.
invalid.case.label.combination.several.patterns.unnamed=Combinación de etiquetas de caso no válida. Se permiten múltiples patrones solo si no se declara ninguna variable de patrón
invalid.default.and.null.order=Orden de etiqueta de caso no válida. 'nulo' debe ir primero y 'predeterminado' debe ser segundo
invalid.package.annotation.containing.file=Las anotaciones del paquete deben estar en el archivo package-info.java
invalid.permits.clause=Cláusula de permisos inválidos: ''{0}'' debe estar sellado
invalid.permits.clause.direct.implementation=Cláusula de permisos no válidos: ''{0}'' debe {1, choice, 1#extend|2#implement} ''{2}'' directamente
invalid.qualified.new=Nuevo calificado no válido
invalid.statement=Declaración no válida
is.not.an.enclosing.class=''{0}'' no es una clase adjunta
label.without.statement=Etiqueta sin declaración
lambda.expression.not.expected=No se espera una expresión lambda aquí
lambda.parameters.consistency.message=No se pueden mezclar 'var' y parámetros escritos explícitamente en la expresión lambda
lambda.variable.must.be.final=La variable utilizada en la expresión lambda debe ser final o efectivamente final
local.class.is.not.used=La clase local ''{0}'' nunca se usa
local.classes.must.not.extend.sealed.classes=Las clases locales no deben extender las clases selladas
local.variable.is.never.used=La variable ''{0}'' nunca se usa
local.variable.is.not.assigned=La variable ''{0}'' nunca se asigna
local.variable.is.not.used.for.reading=La variable ''{0}'' está asignada pero nunca se accede
long.number.too.large=Número largo demasiado grande
lvti.array='var' no está permitido como tipo de elemento de una matriz
lvti.compound='var' no está permitido en una declaración compuesta
lvti.lambda=No se puede inferir el tipo: la expresión lambda requiere un tipo de destino explícito
lvti.method.ref=No se puede inferir el tipo: la referencia del método requiere un tipo de destino explícito
lvti.no.initializer=No se puede inferir el tipo: 'var' en la variable sin inicializador
lvti.null=No se puede inferir el tipo: el inicializador de la variable es 'nulo'
lvti.selfReferenced=No se puede inferir el tipo: el inicializador de variable es autoreferenciado
lvti.void=No se puede inferir el tipo: el inicializador de la variable es 'vacío'
malformed.floating.point.literal=Literal de punto flotante con formato incorrecto
marked.for.removal.default.constructor=El constructor predeterminado en ''{0}'' está obsoleto y marcado para su eliminación
marked.for.removal.symbol=''{0}'' está obsoleto y marcado para su eliminación
member.referenced.before.constructor.called=No se puede hacer referencia a ''{0}'' antes de que se haya llamado al constructor de supertipo
method.call.expected=Se esperaba una llamada al método
method.does.not.override.super=El método no anula el método de su superclase
method.is.not.used=El método ''{0}'' nunca se usa
method.reference.expression.is.not.expected=Aquí no se espera la expresión de referencia del método
missing.method.body=Falta el cuerpo del método o declarar abstracto
missing.package.statement=Falta la declaración del paquete: ''{0}''
missing.package.statement.package.name.invalid=Falta la sintaxis del paquete, pero el nombre del paquete ''{0}'' correspondiente a la ruta del archivo no es válido
missing.return.statement=Falta la declaración de devolución
missing.return.type=Declaración de método no válida; tipo de retorno requerido
missing.return.value=Falta el valor de retorno
modifier.not.allowed=Modificador ''{0}'' no permitido aquí
modifiers.for.enum.constants=No se permiten modificadores para las constantes de enumeración
module.access.bad.name=El paquete ''{0}'' se declara en el módulo con un nombre no válido (''{1}'')
module.access.does.not.read=El paquete ''{0}'' está declarado en el módulo ''{1}'', pero el módulo ''{2}'' no lo lee
module.access.from.named=El paquete ''{0}'' se declara en el módulo ''{1}'', que no lo exporta al módulo ''{2}''
module.access.from.unnamed=El paquete ''{0}'' se declara en el módulo ''{1}'', que no lo exporta al módulo sin nombre
module.access.not.in.graph=El paquete ''{0}'' se declara en el módulo ''{1}'', que no está en el gráfico del módulo
module.access.to.unnamed=El paquete ''{0}'' está declarado en el módulo sin nombre, pero el módulo ''{1}'' no lo lee
module.ambiguous=Referencia de módulo ambiguo: {0}
module.conflicting.packages=El paquete ''{0}'' existe en otro módulo: {1}
module.conflicting.reads=Módulo ''{0}'' lee el paquete ''{1}'' tanto de ''{2}'' como de ''{3}''
module.cyclic.dependence=Dependencia cíclica: {0}
module.duplicate.exports=Duplicar ''exports'': {0}
module.duplicate.exports.target=Destino de ''exports'' duplicado: {0}
module.duplicate.impl=Implementación duplicada: {0}
module.duplicate.opens=Duplicar ''opens'': {0}
module.duplicate.opens.target=Duplicar ''opens'' objetivo: {0}
module.duplicate.provides=Duplicar ''provides'': {0}
module.duplicate.requires=Duplicar ''requires'': {0}
module.duplicate.uses=Duplicar ''uses'': {0}
module.file.duplicate='module-info.java' ya existe en el módulo
module.file.wrong.location=La declaración del módulo debe estar ubicada en la raíz de origen de un módulo
module.file.wrong.name=La declaración del módulo debe estar en un archivo llamado 'module-info.java'
module.no.package=Un archivo de módulo no debe tener la declaración 'paquete'
module.not.found=Módulo no encontrado: {0}
module.not.on.path=El módulo no está en dependencias: {0}
module.open.duplicate.text=Ir a duplicar
module.opens.in.weak.module='opens' no está permitido en un módulo abierto
module.service.abstract=La implementación del servicio es una clase abstracta: {0}
module.service.alien=La implementación del servicio debe definirse en el mismo módulo que la directiva proporciona
module.service.enum=La definición del servicio es una enumeración: {0}
module.service.impl=El tipo de implementación del servicio debe ser un subtipo del tipo de interfaz de servicio, o tener un método de 'proveedor' público estático no-args
module.service.inner=La implementación del servicio es una clase interna: {0}
module.service.no.ctor=La implementación del servicio no tiene un constructor público predeterminado: {0}
module.service.provider.type=El tipo de retorno del método '' proveedor '' debe ser un subtipo del tipo de interfaz de servicio: {0}
module.service.unused=Interfaz de servicio proporcionada pero no exportada ni utilizada
module.unwanted.modifier.warn=Los modificadores en 'requires java.base' están prohibidos en las versiones desde Java 10
multiple.non.overriding.abstract.methods.found.in.0=Múltiples métodos abstractos no invalidantes encontrados en {0}
multiple.non.overriding.abstract.methods.found.in.interface.0=Se encontraron varios métodos abstractos no invalidantes en la interfaz {0}
multiple.switch.labels=Se permiten varias etiquetas de cambio en un grupo de declaraciones al que se asigna una etiqueta de cambio solo si la etiqueta de cambio no declara una variable de patrón
native.methods.cannot.have.a.body=Los métodos nativos no pueden tener cuerpo
no.default.constructor.available=No hay ningún constructor predeterminado disponible en ''{0}''
no.enclosing.instance.in.scope=Ninguna instancia adjunta del tipo ''{0}'' está en el alcance
no.interface.expected=No se espera ninguna interfaz aquí
no.target.method.found=No se encontró ningún método de destino
non.static.method.cannot.be.referenced.from.a.static.context.method.reference.context=No se puede hacer referencia al método no estático desde un contexto estático
non.static.symbol.referenced.from.static.context=No se puede hacer referencia a {0} ''{1}'' no estático desde un contexto estático
not.a.functional.interface={0} no es una interfaz funcional
not.a.statement=No es una declaración
not.allowed.in.interface=No permitido en la interfaz
not.allowed.in.sealed.hierarchy={0} no está permitido en la jerarquía sellada
not.inner.class=''{0}'' no es una clase interna
not.loop.label=No es una etiqueta de bucle: ''{0}''
null.label.not.allowed.here=Combinación de etiquetas de caso no válida. 'nulo' puede usarse como una etiqueta de caso único o combinarse solo con 'predeterminado'
numeric.overflow.in.expression=Desbordamiento numérico en expresión
overridden.method.does.not.throw={0}; El método anulado no arroja ''{1}''
override.not.allowed.in.interfaces=@Override no está permitido al implementar el método de interfaz
overrides.deprecated.method=Anula el método obsoleto en ''{0}''
overrides.marked.for.removal.method=Anula el método que está obsoleto y marcado para su eliminación en ''{0}''
package.clashes.with.class=El paquete ''{0}'' choca con la clase del mismo nombre
package.is.empty=El paquete está vacío: {0}
package.local.symbol=''{0}'' no es público en ''{1}''. No se puede acceder desde el paquete externo
package.name.file.path.mismatch=El nombre del paquete ''{0}'' no corresponde a la ruta del archivo ''{1}''
package.not.found=Paquete no encontrado: {0}
parameter.excluding.hierarchy.disable.text=No resaltar parámetros de métodos heredados.
parameter.is.not.used=El parámetro ''{0}'' nunca se usa
parameterized.qualifier.on.static.method.reference.context=Calificador parametrizado en referencia de método estático
pattern.is.not.exhaustive=El patrón ''{0}'' está incompleto para ''{1}''
pattern.variable.is.not.used=La variable de patrón ''{0}'' nunca se usa
permit.list.must.contain.outside.inheritors=La cláusula de permisos de una clase sellada debe incluir todas las subclases.
permits.after.enum=La cláusula de permiso no está permitida en enumeraciones
permits.list.generics.are.not.allowed=Los genéricos no están permitidos en la lista de permisos.
permitted.subclass.must.have.modifier=Todas las subclases de clase sellada deben ser finales, selladas o no selladas.
private.constructor.is.not.used=El constructor privado ''{0}'' nunca se usa
private.field.is.not.assigned=El campo privado ''{0}'' nunca se asigna
private.field.is.not.used=El campo privado ''{0}'' nunca se usa
private.inner.class.is.not.used=La clase interna privada ''{0}'' nunca se usa
private.inner.interface.is.not.used=La interfaz interna privada ''{0}'' nunca se usa
private.method.is.not.used=El método privado ''{0}'' nunca se usa
private.methods.in.interfaces.should.have.body=Los métodos privados en las interfaces deben tener un cuerpo
private.symbol={0}'' tiene acceso privado en ''{1}
protected.symbol={0}'' tiene acceso protegido en ''{1}
public.class.should.be.named.after.file=La clase ''{0}'' es pública, debe declararse en un archivo llamado '' {0} .java ''
qualified.class.reference.not.allowed.in.qualified.new=No se permite la referencia de clase calificada en calificados nuevos
qualified.enum.constant.in.switch=Una etiqueta de caso de cambio de enumeración debe ser el nombre no calificado de una constante de enumeración
qualified.enum.constant.in.switch.remove.fix=Eliminar calificador
qualified.new.of.static.class=Nuevo calificado de clase estática
qualifier.must.be.expression=El calificador debe ser una expresión
receiver.name.mismatch=El nombre del receptor no coincide con el tipo de clase adjunto
receiver.static.context=El receptor no se puede utilizar en un contexto estático
receiver.type.mismatch=El tipo de receptor no coincide con el tipo de clase adjunto
receiver.wrong.context=No se permiten receptores fuera de la lista de parámetros del método
receiver.wrong.position=El receptor debe ser el primer parámetro
record.accessor=Accesor de componente de registro
record.accessor.wrong.return.type=Tipo de retorno de acceso de componente incorrecto. Esperado: ''{0}'', encontrado: ''{1}''
record.canonical.constructor=Constructor canónico
record.canonical.constructor.wrong.parameter.name=Los nombres de los parámetros del constructor canónico deben coincidir con los nombres de los componentes del registro. Esperado: ''{0}'', encontrado: ''{1}''
record.canonical.constructor.wrong.parameter.type=Tipo de parámetro incorrecto para el componente de registro ''{0}''. Esperado: ''{1}'', encontrado: ''{2}''
record.compact.constructor=Constructor compacto
record.compact.constructor.return=La declaración 'return' no está permitida en el constructor compacto
record.component.cstyle.declaration=No se permiten declaraciones de componentes de registros estilo C
record.component.not.initialized=Es posible que el componente de registro ''{0}'' no esté inicializado en el constructor canónico
record.component.restricted.name=Nombre de componente de registro ilegal ''{0}''
record.component.vararg.not.last=El componente de registro de Vararg debe ser el último en la lista
record.constructor.call.in.canonical=El constructor canónico no puede delegar en otro constructor
record.extends=No se permite la cláusula de extensiones para el registro
record.header.regular.class=Encabezado de registro declarado para no registro
record.instance.field=El campo de instancia no está permitido en el registro
record.instance.initializer=El inicializador de instancia no está permitido en el registro
record.no.constructor.call.in.non.canonical=El constructor de registros no canónicos debe delegar en otro constructor
record.no.header=El registro no tiene ningún encabezado declarado
record.permits=La cláusula de permiso no está permitida en el registro.
record.special.method.non.public={0} debe ser ''public''
record.special.method.stronger.access={0} el nivel de acceso no puede ser más restrictivo que el nivel de acceso al registro (''{1}'')
record.special.method.throws={0} no puede declarar excepciones lanzadas
record.special.method.type.parameters={0} no puede tener parámetros de tipo
recursive.constructor.invocation=Invocación de constructor recursivo
repeated.annotation.target=Objetivo de anotación repetida
repeated.interface=Interfaz repetida
resource.variable.must.be.final=La variable utilizada como recurso de prueba con recursos debe ser final o efectivamente final
restricted.identifier=''{0}'' es un identificador restringido y no se puede utilizar para declaraciones de tipo
restricted.identifier.reference=Referencia ilegal al tipo restringido ''{0}''
restricted.identifier.warn=El uso de ''{0}'' como nombre de clase no se admite en las versiones desde Java {1}
return.from.void.method=No se puede devolver un valor de un método con tipo de resultado nulo
return.outside.method=Método de retorno externo
return.outside.switch.expr=Regresar fuera de la expresión del interruptor adjunto
safevararg.annotation.cannot.be.applied.for.record.component=La anotación @SafeVarargs no se puede aplicar a un componente de registro
safevarargs.not.allowed.non.final.instance.methods=@SafeVarargs no está permitido en métodos de instancia no final
safevarargs.not.allowed.on.methods.with.fixed.arity=@SafeVarargs no está permitido en métodos con arity fijo
safevarargs.not.applicable.for.reifiable.types=@SafeVarargs no es aplicable para tipos confiables
safevarargs.not.suppress.potentially.unsafe.operations=@SafeVarargs no suprime operaciones potencialmente inseguras
sealed.cannot.be.functional.interface=Las clases selladas no se pueden utilizar como interfaces funcionales.
sealed.must.have.inheritors=La clase sellada debe tener subclases
sealed.type.inheritor.expected.modifiers={0}, {1} o {2} modificadores esperados
single.import.class.conflict=''{0}'' ya está definido en una importación de tipo único
statement.must.be.prepended.with.case.label=La declaración debe ir precedida de la etiqueta del caso
static.interface.method.call.qualifier=El método estático se puede invocar solo en la clase de interfaz que contiene
static.member.accessed.via.instance.reference=Miembro estático ''{0}.{1}'' al que se accede mediante referencia de instancia
static.method.cannot.be.annotated.with.override=No puedes anotar métodos estáticos con @Override.
static.method.cannot.override.instance.method=El método estático ''{0}'' en ''{1}'' no puede anular el método de instancia ''{2}'' en ''{3}''
static.method.referenced.through.non.static.qualifier.method.reference.context=Método estático al que se hace referencia mediante un calificador no estático
static.method.referenced.through.receiver.method.reference.context=Método estático referenciado a través del receptor
static.methods.in.interfaces.should.have.body=Los métodos estáticos en las interfaces deben tener un cuerpo
suspicious.name.assignment={0}'' probablemente no debería asignarse a ''{1}
suspicious.name.parameter={0}'' probablemente no debería pasarse como parámetro ''{1}
suspicious.name.return={0}'' probablemente no debería devolverse del método ''{1}
switch.class.or.array.type.expected=Clase o matriz
switch.constant.expression.required=Requiere expresión constante, patrón o nulo
switch.dominance.of.preceding.label=La etiqueta está dominada por la etiqueta de caso anterior ''{0}''
switch.expr.empty=La expresión 'switch' no tiene cláusulas de caso
switch.expr.incomplete=La expresión 'switch' no cubre todos los valores de entrada posibles
switch.expr.no.result=La expresión de cambio no tiene ninguna expresión de resultado
switch.expr.rule.should.produce.result=La regla de expresión de cambio debe producir un resultado en todas las rutas de ejecución
switch.expr.should.produce.result=La expresión de cambio debe producir un resultado en todas las rutas de ejecución
switch.expression.cannot.be.void=El tipo de destino para la expresión de cambio no puede ser nulo
switch.illegal.fall.through.from=Caída incorrecta del patrón
switch.illegal.fall.through.to=Caída incorrecta en el patrón
switch.invalid.selector.types=El tipo de selector ''{0}'' no es compatible
switch.pattern.expected=El tipo de selector de interruptor ''{0}'' requiere patrón
switch.statement.empty=La declaración de 'cambio' no tiene cláusula de caso
switch.statement.incomplete=La declaración 'switch' no incluye todos los valores de entrada posibles
switch.unconditional.pattern.and.default.exist='switch' tiene un patrón incondicional y una etiqueta predeterminada
target.method.is.generic=El método de destino es genérico
target.type.of.a.lambda.conversion.must.be.an.interface=El tipo de destino de una conversión lambda debe ser una interfaz
text.block.new.line=Inicio ilegal del bloque de texto: falta una nueva línea después de abrir las comillas
text.block.unclosed=Bloque de texto sin cerrar
text.class.cannot.access=No se puede acceder a {0}
text.class.inherits.abstract.and.default={0} hereda el resumen y el valor predeterminado de {1} de los tipos {2} y {3}
text.class.inherits.unrelated.defaults={0} hereda un valor predeterminado no relacionado para {1} de tipo {2}
text.class.is.not.accessible={0} no es accesible en el contexto actual
text.improper.formed.type=El formato tipográfico es inadecuado. Faltan algunos parámetros de tipo
too.many.array.dimensions=La matriz tiene demasiadas dimensiones.
too.many.characters.in.character.literal=Demasiados caracteres en el carácter literal
two.methods.are.inherited.with.same.signature=Los métodos {0} de {1} y {2} de {3} se heredan con la misma firma
type.parameter.cannot.be.followed.by.other.bounds=El parámetro de tipo no puede ser seguido por otros límites
type.parameter.has.incompatible.upper.bounds=El parámetro de tipo {0} tiene límites superiores incompatibles: {1}
type.parameter.is.not.used=El parámetro de tipo ''{0}'' nunca se usa
type.pattern.expected=Se requiere patrón de tipo
unary.operator.not.applicable=El operador ''{0}'' no se puede aplicar a ''{1}''
unchecked.overriding.incompatible.return.type=Anulación sin marcar: el tipo de retorno requiere una conversión sin marcar. Encontrado ''{0}'', obligatorio ''{1}''
unclosed.char.literal=Literal de carácter no cerrado
unclosed.comment=Comentario sin cerrar
underscore.identifier.error=A partir de Java 9, '_' es una palabra clave y no se puede utilizar como identificador
underscore.identifier.error.unnamed=No se permite utilizar '_' como referencia
underscore.identifier.warn=El uso de '_' como identificador no se admite en versiones desde Java 9
underscore.lambda.identifier=No se permite el uso de '_' como nombre de parámetro lambda
unexpected.token=Token inesperado
unexpected.type=Tipo inesperado. Encontrado: ''{1}'', Requerido: ''{0}''
unexpected.type.class.expected=Tipo inesperado: se espera una clase
unhandled.close.exceptions=Excepci{1, choice, 0#ón no controlada|2#ones no controladas} de {2}: {0}
unhandled.exceptions=Excepci{1, choice, 0#ón no controlada|2#ones no controladas}: {0}
unknown.class=Clase desconocida: ''{0}''
unqualified.super.disallowed=No se permite la super referencia no calificada en el método de extensión
unreachable.statement=Declaración inalcanzable
unreachable.statement.false.condition=El cuerpo del bucle es inalcanzable porque la condición del bucle siempre es falsa
unrelated.overriding.methods.return.types=Los métodos tienen tipos de retorno no relacionados
unresolved.label=Etiqueta no definida: ''{0}''
unsafe.cast.in.instanceof={0}'' no se puede convertir de forma segura a ''{1}
valid.switch.1_7.selector.types=char, byte, short, int, carácter, byte, corto, entero, cadena y enumeración
valid.switch.selector.types=Byte, char, corto o int
vararg.cstyle.array.declaration=No se permiten declaraciones de matrices estilo C dentro de argumentos vararg
vararg.not.last.parameter=El parámetro Vararg debe ser el último en la lista
variable.already.assigned=Es posible que la variable ''{0}'' ya se haya asignado a
variable.already.defined=La variable ''{0}'' ya está definida en el alcance
variable.assigned.in.loop=La variable ''{0}'' podría asignarse en bucle
variable.expected=Variable esperada
variable.must.be.final=Se accede a la variable ''{0}'' desde dentro de la clase interna, debe declararse final
variable.must.be.final.or.effectively.final=Se accede a la variable ''{0}'' desde dentro de la clase interna, debe ser final o efectivamente final
variable.not.initialized=Es posible que la variable ''{0}'' no se haya inicializado
visibility.access.problem=No se puede acceder a ''{0}'' en ''{1}''
visibility.module.access.problem={2} impide el acceso a ''{0}'' en ''{1}''
void.type.is.not.allowed=El tipo 'void' no está permitido aquí
weaker.privileges={0}; intentar asignar privilegios de acceso más débiles (''{1}''); era ''{2}''
when.expression.is.false=Esta etiqueta de caso tiene una expresión constante con el valor "falso"
wildcard.type.cannot.be.instantiated=El tipo de comodín ''{0}'' no se puede instanciar directamente
wrong.constructor.arguments={0}'' no se puede aplicar a ''{1}
wrong.method.arguments={0}'' in ''{1}'' no se puede aplicar a ''{2}
yield.unexpected=Rendimiento fuera de la expresión de cambio
yield.unqualified.method.warn=Es posible que la llamada no calificada al método 'yield' no sea compatible con versiones desde Java 14
yield.void=El tipo de expresión no debe ser 'void'
