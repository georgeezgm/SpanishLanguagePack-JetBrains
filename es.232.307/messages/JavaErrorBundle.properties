abstract.cannot.be.instantiated=''{0}''은(는) abstract이며, 인스턴스화할 수 없습니다
abstract.method.0.cannot.be.accessed.directly.method.reference.context=추상 메서드 ''{0}''에 직접 액세스할 수 없습니다
abstract.method.in.non.abstract.class=비 abstract 클래스에 추상 메서드가 있습니다
abstract.methods.cannot.have.a.body=추상 메서드는 본문을 가질 수 없습니다
actual.type.argument.contradict.inferred.type=실제 타입 인수 및 추론 타입이 서로 모순됩니다
ambiguous.method.call=모호한 메서드 호출: ''{0}'' 및 ''{1}''이(가) 모두 일치합니다
ambiguous.method.call.no.match=''{0}''의 메서드 ''{0}''을(를) 해결할 수 없습니다
ambiguous.method.html.tooltip=<html><body><table border=0><tr><td colspan={0}>모호한 메서드 호출입니다. </td></tr><tr><td><b>{2}</b>의 {1}\\&nbsp;및</td></tr><tr><td><b>{4}</b>의 {3}\\&nbsp;모두 일치</td></tr></table></body></html>
ambiguous.reference=''{0}'' 참조가 모호합니다. ''{1}'' 및 ''{2}''이(가) 모두 일치합니다
an.enclosing.instance.of.type.not.in.scope.method.reference.context=''{0}'' 타입을 둘러싸는 인스턴스가 범위 안에 없습니다
annotation.annotation.type.expected=어노테이션 타입이 필요합니다
annotation.cannot.be.local=지역 어노테이션은 허용되지 않습니다
annotation.container.abstract=컨테이너 어노테이션 ''{0}''에 ''{1}''에 대한 디폴트 값이 없습니다
annotation.container.bad.type=잘못된 컨테이너 어노테이션 ''{0}'': ''value'' 메서드 타입에 ''{1}''이(가) 있어야 합니다
annotation.container.low.retention=컨테이너 어노테이션 ''{0}''은(는) 포함된 어노테이션보다 보존 기간이 짧습니다(''{1}'')
annotation.container.missed.annotation=컨테이너 어노테이션 ''{0}''에 필수 @{1} 어노테이션이 없습니다
annotation.container.no.value=잘못된 컨테이너 어노테이션 ''{0}'': ''value'' 메서드가 선언되지 않았습니다
annotation.container.not.applicable=컨테이너 어노테이션 ''@{0}''을(를) {1}에 적용할 수 없습니다
annotation.container.wide.target=컨테이너 어노테이션 ''{0}''의 타깃이 해당 어노테이션 타깃의 하위 집합이 아닙니다
annotation.container.wrong.place=컨테이너 어노테이션 ''{0}''은(는) 포함된 요소와 동시에 존재할 수 없습니다
annotation.cyclic.element.type=순환 어노테이션 요소 타입
annotation.duplicate.annotation=어노테이션 중복
annotation.duplicate.attribute=속성 ''{0}'' 중복
annotation.duplicate.explained=어노테이션이 중복되었습니다. {0}
annotation.illegal.array.initializer=''{0}''에 대한 올바르지 않은 이니셜라이저
annotation.interface.members.may.not.have.parameters=@interface 멤버는 매개변수를 가질 수 없습니다
annotation.invalid.annotation.member.type=잘못된 어노테이션 멤버 타입 ''{0}''
annotation.may.not.have.extends.list=@interface는 확장 목록을 가질 수 없습니다
annotation.may.not.have.type.parameters=@interface는 타입 매개변수를 가질 수 없습니다
annotation.members.may.not.have.throws.list=@interface 멤버는 throw 목록을 가질 수 없습니다
annotation.missing.attribute=필수 {0} 누락
annotation.missing.method=메서드 ''{0}''을(를) 찾을 수 없습니다
annotation.non.class.literal.attribute.value=속성 값은 클래스 리터럴이어야 합니다
annotation.non.constant.attribute.value=속성 값은 상수여야 합니다
annotation.non.enum.constant.attribute.value=속성 값은 열거형 상수여야 합니다
annotation.non.repeatable=''{0}'' 의 선언에 올바른 java.lang.annotation.Repeatable 어노테이션이 없습니다
annotation.not.allowed.class=클래스 리터럴 타입에는 어노테이션을 추가할 수 없습니다
annotation.not.allowed.here=어노테이션은 여기에서 허용되지 않습니다
annotation.not.allowed.ref=이러한 종류의 참조에 적용할 수 없는 어노테이션
annotation.not.allowed.static=static 멤버 정규화 타입에는 어노테이션을 추가할 수 없습니다
annotation.not.allowed.var='var' 타입에는 어노테이션을 추가할 수 없습니다
annotation.not.allowed.void='void' 타입에는 어노테이션을 추가할 수 없습니다
annotation.not.applicable='' @{0}''을(를) {1}에 적용할 수 없습니다
annotation.on.static.member.qualifying.type.family.name=타입 어노테이션 이동
annotation.type.permits=허가 절은 어노테이션 타입에 허용되지 않습니다
annotation.unknown.method=메서드 ''{0}''를 해결할 수 없습니다
anonymous.class.implements.interface.cannot.have.qualifier=익명 클래스가 인터페이스를 구현하므로 new에 대한 한정자를 가질 수 없습니다
anonymous.class.implements.interface.cannot.have.type.arguments=익명 클래스는 인터페이스를 구현하므로 타입 인수를 가질 수 없습니다
anonymous.classes.must.not.extend.sealed.classes=익명 클래스는 sealed 클래스를 확장할 수 없습니다
array.creation.with.type.arguments=타입 인수를 사용하여 배열을 생성할 수 없습니다
array.initializer.not.allowed=배열 이니셜라이저는 허용되지 않습니다
array.type.expected=배열 타입이 필요합니다. 발견: ''{0}''
assert.identifier.warn='assert'는 Java 1.4 이후 릴리스에서 식별자로 사용할 수 없습니다
assignment.to.final.variable=final 변수 ''{0}''에 값을 대입할 수 없습니다
auto.closeable.resource=자동 종료 가능한 리소스
bad.qualifier.in.super.method.reference.extended=디폴트 super 호출 내 잘못된 타입 한정자: 불필요한 인터페이스 {0}이(가) {1}에 의해 확장되었습니다
bad.qualifier.in.super.method.reference.overridden=디폴트 super 호출 내 잘못된 타입 한정자: 메서드 {0}이(가) {1}에서 재정의되었습니다
bad.type.in.switch.expression=switch 식 내 타입이 잘못되었습니다. {0}은(는) {1}(으)로 변환할 수 없습니다.
binary.numbers.must.contain.at.least.one.hexadecimal.digit=2진수는 하나 이상의 2진 숫자를 포함해야 합니다
binary.operator.not.applicable=연산자 ''{0}''을(를) ''{1}'', ''{2}''에 적용할 수 없습니다
break.outside.switch.expr=switch 식 외부에 break를 사용하는 것은 허용되지 않습니다
break.outside.switch.or.loop=break가 switch 또는 루프 외부에 있습니다
call.to.super.is.not.allowed.in.enum.constructor=super 호출은 열거형 생성자에서 허용되지 않습니다
cannot.access.member.on.type=''{0}''이(가) 기본 타입 {1}이므로 멤버를 액세스할 수 없습니다
cannot.be.referenced.from.static.context=''{0}''은(는) static 컨텍스트에서 참조할 수 없습니다
cannot.call.method.on.type=''{0}''이(가) 기본 타입 {1}이므로 메서드를 호출할 수 없습니다
cannot.create.array.with.empty.diamond='<>'로 배열을 생성할 수 없습니다
cannot.find.class={0} 클래스를 찾을 수 없습니다
cannot.infer.functional.interface.type=함수 인터페이스 타입을 추론할 수 없습니다
cannot.resolve.constructor=생성자 ''{0}''를 해결할 수 없습니다
cannot.resolve.method=메서드 ''{0}''를 해결할 수 없습니다
cannot.resolve.package=패키지 {0}를 해결할 수 없습니다
cannot.resolve.symbol=심볼 ''{0}''를 해결할 수 없습니다
cannot.select.dot.class.from.type.variable=타입 매개변수의 클래스 객체에 액세스할 수 없습니다
cannot.select.from.a.type.parameter=타입 매개변수에서 선택할 수 없습니다
cannot.select.from.parameterized.type=매개변수화된 타입의 클래스 객체에 액세스할 수 없습니다
case.statement.outside.switch=case 문이 switch 외부에 있습니다
catch.without.try='try'가 없는 'catch'
clash.methods.message=''{0}''이(가) ''{1}''와(과) 충돌합니다
clash.methods.message.show.classes=''{2}''의 ''{0}''이(가) ''{3}''의 ''{1}''와(과) 충돌합니다
class.already.imported=''{0}''이(가) 이 컴파일 유닛에 이미 정의되어 있습니다
class.cannot.be.inherited.with.different.arguments={0}을(를) 다른 타입 인수로 상속할 수 없습니다. {1}
class.cannot.extend.multiple.classes=클래스는 여러 클래스를 확장할 수 없습니다
class.cannot.inherit.from.its.type.parameter=클래스는 자신의 타입 매개변수로부터 상속할 수 없습니다
class.clashes.with.package=클래스 ''{0}''이(가) 동일한 이름의 패키지와 충돌합니다
class.expected=클래스 이름 필요
class.in.default.package=클래스 ''{0}''이(가) 디폴트 패키지에 있습니다
class.is.already.defined.in.single.static.import=클래스 ''{0}''이(가) 이미 하나의 static import 문에 정의되어 있습니다
class.is.ambiguous.in.single.static.import=하나의 정적 import문에 모호한 클래스 ‘{0}''이(가) 있습니다
class.is.not.used=클래스 ''{0}''이(가) 한 번도 사용되지 않습니다
class.member.declared.outside=클래스 멤버가 클래스 외부에서 선언되었습니다
class.must.be.abstract=클래스 ''{0}''은(는) abstract로 선언되거나 ''{2}''에서 추상 메서드 ''{1}''을(를) 구현해야 합니다
class.must.implement.method=클래스 ''{0}''은(는) ''{2}''에서 추상 메서드 ''{1}''을(를) 구현해야 합니다
class.name.expected=클래스 이름이 필요합니다
class.not.allowed.to.extend.sealed.class.from.another.module=클래스는 다른 모듈의 sealed 클래스를 확장할 수 없습니다
class.not.allowed.to.extend.sealed.class.from.another.package=클래스는 다른 패키지의 sealed 클래스를 확장할 수 없습니다
classes.extends.prohibited.super=클래스가 ''{0}''을(를) 직접 확장할 수 없습니다
compact.constructor.in.regular.class=매개변수 목록이 필요합니다
constant.expression.required=상수 표현식 필요
constructor.call.must.be.first.statement=''{0}'' 호출은 생성자 본문의 첫 번째 구문이어야 합니다
constructor.is.not.used=생성자 ''{0}''이(가) 한 번도 사용되지 않습니다
continue.outside.loop=continue가 루프 외부에 있습니다
continue.outside.switch.expr=continue가 switch 식 외부에 있습니다
create.class.action.this.not.valid.java.qualified.name=올바른 Java 정규화된 이름이 아닙니다
cyclic.inheritance=''{0}'' 관련 순환 상속
declaration.not.allowed=선언은 허용되지 않습니다
declaration.or.variable.expected=선언, final 또는 유사 final 변수 필요
deconstruction.pattern.requires.record=구조 분해 패턴은 레코드에만 적용할 수 있습니다. ''{0}''은(는) 레코드가 아닙니다
default.label.must.not.contains.case.keyword=디폴트 case의 라벨은 'case' 없이 'default' 키워드만 사용해야 합니다
default.label.not.allowed.here=디폴트 라벨은 이곳에서 허용되지 않습니다. 'default'는 단일 case 라벨으로 사용되거나 'null'과만 쌍이 될 수 있습니다
default.method.overrides.object.member=디폴트 메서드 ''{0}''이(가) ''java.lang.Object''의 멤버를 재정의합니다
deprecated.default.constructor=''{0}''의 디폴트 생성자는 더 이상 사용되지 않습니다
deprecated.symbol=''{0}''은(는) 더 이상 사용되지 않습니다
different.case.kinds.in.switch=switch에 다양한 case 종류가 사용되어 있습니다
direct.abstract.method.access=추상 메서드 ''{0}''에 직접 액세스할 수 없습니다
dot.expected.after.super.or.this='.' 필요
duplicate.class=클래스 중복: ''{0}''
duplicate.class.in.other.file=파일 ''{0}''에서 클래스 중복이 발견되었습니다
duplicate.default.switch.label=디폴트 라벨 중복
duplicate.label=라벨 ''{0}''을(를) 이미 사용 중입니다
duplicate.method=''{0}''이(가) ''{1}''에 이미 정의되어 있습니다
duplicate.switch.label=라벨 ''{0}'' 중복
duplicate.unconditional.pattern.label=조건 없는 패턴 중복
else.without.if='if'가 없는 'else'
empty.character.literal=빈 문자 리터럴
enum.constant.must.implement.method=열거형 상수 ''{0}''은(는) ''{2}''에서 추상 메서드 ''{1}''을(를) 구현해야 합니다
enum.identifier.warn='enum'은 Java 1.5 이후 릴리스에서 식별자로 사용할 수 없습니다
enum.is.not.used=열거형 ''{0}''이(가) 한 번도 사용되지 않습니다
enum.types.cannot.be.instantiated=열거형 타입은 인스턴스화할 수 없습니다
error.cannot.infer.pattern.type=패턴 타입을 추론할 수 없습니다. {0}
error.cannot.resolve.class=클래스 ''{0}''를 해결할 수 없습니다
error.cannot.resolve.class.or.package=클래스 또는 패키지 ''{0}''를 해결할 수 없습니다
error.interface.member.clashes={1}에서 @interface 멤버가 ''{0}''와(과) 충돌합니다
error.raw.deconstruction=원시 구조 분해 패턴은 허용되지 않습니다
exception.already.caught=예외 ''{0}''이(가) 이미 포착되었습니다
exception.already.caught.warn=도달할 수 없는 섹션: {1, choice, 0#예외|2#예외} ''{0}'' {1, choice, 0#이(가)|2#이(가)} 이미 포착되었습니다
exception.is.never.thrown=예외 ''{0}''은(는) 메서드에서 한 번도 던져지지 않습니다
exception.must.be.disjoint=다중 catch 문에서 타입이 분리되어 있어야 합니다. ''{0}''은(는) ''{1}''의 하위 클래스입니다
exception.never.thrown.try=예외 ''{0}''은(는) 해당 try 블록에서 한 번도 던져지지 않습니다
expected.boolean.expression=bool 표현식 필요
expected.catch.or.finally='catch' 또는 'finally' 필요
expected.class.or.package=클래스 또는 패키지 필요
expected.comma=','가 필요합니다
expected.expression=표현식 필요
expected.identifier=식별자 필요
expected.identifier.or.type=식별자 또는 타입 필요
expected.lbrace='{'가 필요합니다
expected.lparen='(' 필요
expected.lparen.or.lbracket='(' 또는 ']' 필요
expected.parameter=매개변수 필요
expected.rbrace='}' 필요
expected.rbracket=']' 필요
expected.rparen=')' 필요
expected.semicolon=';'이 필요합니다
expected.statement=명령문 필요
expected.switch.label='case', 'default' 또는 '}' 필요
expected.switch.rule=표현식, 블록 또는 throw 문 필요
expected.while='while' 필요
expression.expected=표현식 필요
extends.after.enum=확장 절은 열거형에 대해 허용되지 않습니다
extension.method.in.class=확장 메서드는 인터페이스 내에서만 사용할 수 있습니다
extension.method.should.have.a.body=확장 메서드는 본문이 있어야 합니다
field.is.already.defined.in.single.static.import=필드 ''{0}''이(가) 이미 하나의 static import 문에 정의되어 있습니다
field.is.ambiguous.in.single.static.import=필드 ''{0}''이(가) 하나의 정적 static import 문에서 모호합니다
field.is.not.used=필드 ''{0}''이(가) 사용되지 않습니다
field.is.not.used.for.reading={0} 필드 ''{1}''이(가) 대입되었지만 한 번도 액세스되지 않았습니다
final.method.override=''{0}''은(는) ''{2}''에서 ''{1}''을(를) 재정의할 수 없습니다. 재정의된 메서드는 final입니다
finally.without.try='try'가 없는 'finally'
floating.point.number.too.large=부동 소수점 수가 너무 큽니다
floating.point.number.too.small=부동 소수점 수가 너무 작습니다
foreach.not.applicable=Foreach는 타입 ''{0}''에 적용할 수 없습니다
formal.varargs.element.type.inaccessible.here=형식 vararg 요소 타입 {0}에 액세스할 수 없습니다
functional.interface.must.not.be.sealed.error.description=함수 인터페이스를 ''{0}''(으)로 선언할 수 없습니다
generic.array.creation=제네릭 배열 생성
generic.extend.exception=제네릭 클래스는 'java.lang.Throwable'을 확장할 수 없습니다
generics.annotation.members.may.not.have.type.parameters=@interface 멤버는 타입 매개변수를 가질 수 없습니다
generics.cannot.be.inherited.as.raw.and.generic=제네릭 타입 인수 ''{1}''을(를) 사용하여 ''{0}''을(를) 원시 타입으로서 상속할 수 없습니다
generics.cannot.be.inherited.with.different.type.arguments=''{0}''을(를) 다른 타입 인수로 상속할 수 없습니다. ''{1}'' 및 ''{2}''
generics.cannot.catch.type.parameters=타입 매개변수를 포착할 수 없습니다
generics.cannot.instanceof.type.parameters=클래스 또는 배열이 필요합니다
generics.diamond.not.applicable=다이아몬드 연산자는 매개변수가 아닌 타입에 적용할 수 없습니다
generics.duplicate.type.parameter=타입 매개변수 중복: ''{0}''
generics.enum.may.not.have.type.parameters=열거형은 타입 매개변수를 가질 수 없습니다
generics.holder.method=메서드
generics.holder.type=타입
generics.inferred.type.for.type.parameter.is.not.within.its.bound.extend=타입 매개변수 ''{0}''에 대한 추론 타입 ''{2}''이(가) 해당 바운드 내에 없으며, ''{1}''을(를) 확장해야 합니다
generics.inferred.type.for.type.parameter.is.not.within.its.bound.implement=타입 매개변수 ''{0}''에 대한 추론 타입 ''{2}''이(가) 해당 바운드 내에 없으며, ''{1}''을(를) 구현해야 합니다
generics.methods.have.same.erasure={0}. 두 메서드가 동일한 이레이저를 가집니다
generics.methods.have.same.erasure.hide={0}; 두 메서드가 동일한 이레이저를 가지나, 한 메서드가 다른 메서드를 숨기지 않습니다
generics.methods.have.same.erasure.override={0}; 두 메서드가 동일한 이레이저를 가지나, 한 메서드가 다른 메서드를 재정의하지 않습니다
generics.reference.parameters.not.allowed=참조 매개변수는 허용되지 않습니다
generics.select.static.class.from.parameterized.type=클래스 ''{0}''이(가) static이므로 타입 인수는 이곳에서 허용되지 않습니다
generics.type.argument.cannot.be.of.primitive.type=타입 인수는 기본 타입일 수 없습니다
generics.type.arguments.on.raw.method=원시 메서드에 주어진 타입 인수
generics.type.arguments.on.raw.type=원시 타입에 주어진 타입 인수
generics.type.or.method.does.not.have.type.parameters={0} ''{1}''에 타입 매개변수가 없습니다
generics.type.parameter.cannot.be.instantiated=타입 매개변수 ''{0}''을(를) 직접 인스턴스화할 수 없습니다
generics.type.parameter.is.not.within.its.bound.extend=타입 매개변수 ''{0}''이(가) 해당 바운드 내에 없으며, ''{1}''을(를) 확장해야 합니다
generics.type.parameter.is.not.within.its.bound.implement=타입 매개변수 ''{0}''이(가) 바운드 내에 없습니다. ''{1}''을(를) 구현해야 합니다
generics.unchecked.assignment=확인되지 않은 대입: ''{0}''을(를) ''{1}''에
generics.unchecked.call=확인되지 않은 메서드 ''{0}'' 호출
generics.unchecked.call.to.member.of.raw.type=원시 타입 ''{1}''의 멤버로서 ''{0}''에 대한 확인되지 않은 호출
generics.unchecked.cast=확인되지 않은 형 변환: ''{0}''에서 ''{1}''(으)로
generics.wildcard.not.expected=와일드카드가 필요하지 않습니다
generics.wildcards.may.be.used.only.as.reference.parameters=와일드카드는 참조 매개변수로만 사용할 수 있습니다
generics.wrong.number.of.type.arguments=타입 인수의 개수가 잘못되었습니다. {0}, 필요: {1}
guarded.pattern.variable.must.be.final=보호된 패턴에서 사용되는 변수는 final 또는 실질적으로 final이어야 합니다
guarded.patterns.unavailable=JEP 406의 보호된 패턴은 Java 19 테스트 버전부터 사용할 수 없습니다
hexadecimal.numbers.must.contain.at.least.one.hexadecimal.digit=16진수는 하나 이상의 16진수 숫자를 포함해야 합니다
identifier.is.not.allowed.here=식별자는 여기에서 허용되지 않습니다
illegal.escape.character.in.character.literal=문자 리터럴 내 올바르지 않은 이스테이프 문자
illegal.escape.character.in.string.literal=문자열 리터럴의 올바르지 않은 문자 이스케이프
illegal.forward.reference=올바르지 않은 전방 참조
illegal.generic.type.for.instanceof=instanceof에 대한 올바르지 않은 제네릭 타입
illegal.initializer=''{0}''에 대한 올바르지 않은 이니셜라이저
illegal.line.end.in.string.literal=문자열 리터럴 내 올바르지 않은 줄 끝
illegal.self.reference=올바르지 않은 자기 참조
illegal.to.access.static.member.from.enum.constructor.or.instance.initializer=열거형 생성자 또는 인스턴스 이니셜라이저에서 static 멤버 ''{0}''에 액세스하는 것은 올바르지 않습니다
illegal.type.void=올바르지 않은 타입: 'void'
illegal.underscore=올바르지 않은 밑줄
illegal.unicode.escape=잘못된 유니코드 이스케이프 시퀀스
implements.after.interface=구현 절은 인터페이스에 허용되지 않습니다
inaccessible.type=''{0}''에 액세스할 수 없습니다
incompatible.modifiers=올바르지 않은 제어자 조합: ''{0}'' 및 ''{1}''
incompatible.parameter.types.in.lambda=람다 식에서 호환되지 않는 매개변수 타입: {0}이(가) 필요하지만, {1}이(가) 발견되었습니다
incompatible.parameter.types.in.lambda.wrong.number.of.parameters=람다 식에서 호환되지 않는 매개변수 타입: 매개변수 개수 오류: {0}이(가) 필요하지만, {1}이(가) 발견되었습니다
incompatible.return.type=호환되지 않는 반환 타입 사용 시도
incompatible.switch.null.type=''{0}''을(를) ''{1}''(으)로 변환할 수 없습니다
incompatible.types=호환되지 않는 타입입니다. 발견: ''{1}'', 필요: ''{0}''
incompatible.types.html.tooltip=<html><body><table><tr><td style=''padding: 0px 16px 8px 4px;color: {5}''>필요 타입:</td><td style=''padding: 0px 4px 8px 0px;''>{0}</td>{1}</tr><tr><td style=''padding: 0px 16px 0px 4px;color: {5}''>제공된 타입:</td><td style=''padding: 0px 4px 0px 0px;''>{2}</td>{3}</tr></table>{4}</body></html>
incompatible.types.reason.ambiguous.method.reference=<br/>이유: 메서드 참조가 모호합니다.{0}'' 및 ''{1}''이(가) 모두 일치합니다
inconvertible.type.cast=변환할 수 없는 타입; ''{0}''을(를) ''{1}''(으)로 형 변환할 수 없습니다
incorrect.number.of.nested.patterns=중첩된 패턴 수가 올바르지 않습니다. {0}개가 필요하지만 {1}개가 발견되었습니다
inheritance.from.final.class={1} ''{0}''으로부터 상속할 수 없습니다
initializer.must.be.able.to.complete.normally=이니셜라이저는 정상적으로 완료할 수 있어야 합니다
instance.method.cannot.override.static.method=''{1}''의 인스턴스 메서드 ''{0}''은(는) ''{3}''의 static 메서드 ''{2}''을(를) 재정의할 수 없습니다
instanceof.pattern.equals=패턴 타입 ''{0}''은(는) 표현식 타입과 같습니다
instanceof.pattern.supertype=패턴 타입 ''{0}''은(는) 표현식 타입 ''{1}''의 상위 타입입니다
insufficient.language.level={0}은(는) 언어 수준 ''{1}''에서 지원되지 않습니다
integer.number.too.large=integer 숫자가 너무 큽니다
interface.expected=인터페이스 필요
interface.is.not.used=인터페이스 ''{0}''이(가) 한 번도 사용되지 않습니다
interface.methods.cannot.have.body=인터페이스 추상 메서드는 본문을 가질 수 없습니다
invalid.case.label.combination.constants.and.patterns=잘못된 case 라벨 조합입니다. case 라벨은 case 상수의 목록이거나 단일 case 패턴이어야 합니다
invalid.case.label.combination.several.patterns=유효하지 않은 case 라벨 조합입니다. case 라벨은 하나를 초과하는 case 패턴을 가질 수 없습니다
invalid.default.and.null.order=잘못된 case 라벨 순서입니다. 'null'이 처음에 오고 'default'가 두 번째여야 합니다
invalid.package.annotation.containing.file=패키지 어노테이션이 파일 package-info.java에 있어야 합니다
invalid.permits.clause=잘못된 permits 절: ''{0}''이(가) sealed여야 합니다
invalid.permits.clause.direct.implementation=잘못된 permits 절: ''{0}''이(가) ''{2}''을(를) 직접 {1, choice, 1#확장|2#구현}해야 합니다
invalid.qualified.new=잘못된 정규화된 new
invalid.statement=잘못된 구문
is.not.an.enclosing.class=''{0}''은(는) 둘러싸는 클래스가 아닙니다
label.without.statement=구문이 없는 라벨
lambda.expression.not.expected=람다 식은 필요하지 않습니다
lambda.parameters.consistency.message='var'과 명시적으로 타입 지정된 매개변수를 람다 식에서 혼용할 수 없습니다
lambda.variable.must.be.final=람다 표현식에 사용되는 변수는 final 또는 유사 final이어야 합니다
local.class.is.not.used=지역 클래스 ''{0}''이(가) 한 번도 사용되지 않습니다
local.classes.must.not.extend.sealed.classes=지역 클래스는 sealed 클래스를 확장할 수 없습니다
local.variable.is.never.used=변수 ''{0}''이(가) 사용되지 않습니다
local.variable.is.not.assigned=변수 ''{0}''이(가) 한 번도 대입되지 않았습니다
local.variable.is.not.used.for.reading=변수 ''{0}''이(가) 대입되었지만 한 번도 액세스되지 않았습니다
long.number.too.large=long 숫자가 너무 큽니다
lvti.array='var'은 배열의 요소 타입으로 허용되지 않습니다
lvti.compound='var'은 복합 선언에서 허용되지 않습니다
lvti.lambda=타입을 추론할 수 없습니다. 람다 표현식에는 명시적 타깃 타입이 필요합니다
lvti.method.ref=타입을 추론할 수 없습니다. 메서드 참조에는 명시적 타깃 타입을 필요합니다
lvti.no.initializer=타입을 유추할 수 없습니다. 이니셜라이저가 없는 변수에 'var'이 있습니다
lvti.null=타입을 추론할 수 없습니다. 변수 이니셜라이저가 'null'입니다
lvti.selfReferenced=''{0}''의 유형을 추론 할 수 없습니다. 변수 이니셜라이저에서 사용되고 있습니다.
lvti.void=타입을 추론할 수 없습니다. 변수 이니셜라이저가 'void'입니다
malformed.floating.point.literal=잘못된 부동 소수점 리터럴 형식
marked.for.removal.default.constructor=''{0}''의 디폴트 생성자는 더 이상 사용되지 않으며 제거용으로 표시되어 있습니다
marked.for.removal.symbol=''{0}''은(는) 더 이상 사용되지 않으며 제거용으로 표시되어 있습니다
member.referenced.before.constructor.called=상위 타입 생성자가 호출되기 전에 ''{0}''을(를) 참조할 수 없습니다
method.call.expected=메서드 호출 필요
method.does.not.override.super=메서드는 상위 클래스의 메서드를 재정의하지 않습니다
method.is.not.used=메서드 ''{0}''이(가) 한 번도 사용되지 않습니다
method.reference.expression.is.not.expected=메서드 참조식은 필요하지 않습니다
missing.method.body=메서드가 본문이 누락되었거나 abstract로 선언되어 있습니다
missing.package.statement=package 문 누락: ''{0}''
missing.package.statement.package.name.invalid=패키지 구문이 누락되었으나 파일 경로에 대응하는 패키지 이름 ''{0}''이(가) 유효하지 않습니다
missing.return.statement=return 문 누락
missing.return.type=잘못된 메서드 선언. 반환 타입이 필요합니다
missing.return.value=반환 값 누락
modifier.not.allowed=제어자 ''{0}''은(는) 허용되지 않습니다
modifiers.for.enum.constants=열거형 상수에 대한 제어자가 허용되지 않습니다
module.access.bad.name=패키지 ''{0}''이(가) 이름이 잘못된 모듈(''{1}'')에 선언되어 있습니다
module.access.does.not.read=패키지 ''{0}''이(가) 모듈 ''{1}''에 선언되어 있지만 모듈 ''{2}''이(가) 패키지를 읽지 않습니다
module.access.from.named=패키지 ''{0}''이(가) 모듈 ''{1}''에 선언되어 있지만 이 모듈은 패키지를 모듈 ''{2}''(으)로 내보내지 않습니다
module.access.from.unnamed=패키지 ''{0}''이(가) 모듈 ''{1}''에 선언되어 있지만 이 모듈은 패키지를 이름 없는 모듈로 내보내지 않습니다
module.access.not.in.graph=패키지 ''{0}''이(가) 모듈 ''{1}''에 선언되어 있지만 이 모듈은 모듈 그래프에 없습니다
module.access.to.unnamed=패키지 ''{0}''이(가) 이름 없는 모듈에 선언되어 있지만 모듈 ''{1}''이(가) 패키지를 읽지 않습니다
module.ambiguous=모호한 모듈 참조: {0}
module.conflicting.packages=패키지 ''{0}''이(가) 다른 모듈에 있습니다. {1}
module.conflicting.reads=모듈 ''{0}''이(가) ''{2}'' 및 ''{3}'' 모두에서 패키지 ''{1}''을(를) 읽습니다
module.cyclic.dependence=순환 종속성: {0}
module.duplicate.exports=''exports'' 중복: {0}
module.duplicate.exports.target=''exports'' 타깃 중복: {0}
module.duplicate.impl=구현 중복: {0}
module.duplicate.opens=''opens'' 중복: {0}
module.duplicate.opens.target=''opens'' 타깃 중복: {0}
module.duplicate.provides=''provides'' 중복: {0}
module.duplicate.requires=''requires'' 중복: {0}
module.duplicate.uses=''uses'' 중복: {0}
module.file.duplicate='module-info.java'가 모듈에 이미 있습니다
module.file.wrong.location=모듈 선언은 모듈의 소스 루트에 있어야 합니다
module.file.wrong.name=모듈 선언이 'module-info.java'라는 이름의 파일에 있어야 합니다
module.no.package=모듈 파일에는 'package' 문을 사용할 수 없습니다
module.not.found=모듈을 찾을 수 없습니다. {0}
module.not.on.path=모듈이 종속성에 없습니다. {0}
module.open.duplicate.text=중복으로 이동
module.opens.in.weak.module='opens'는 열린 모듈에서 허용되지 않습니다
module.service.abstract=서비스 구현이 abstract 클래스입니다. {0}
module.service.alien=서비스 구현은 provides 지시문과 동일한 모듈에서 정의되어야 합니다
module.service.enum=서비스 정의가 열거형입니다. {0}
module.service.impl=서비스 구현 타입은 서비스 인터페이스 타입의 하위 타입이거나 인수가 없는 public static 'provider' 메서드가 필요합니다
module.service.inner=서비스 구현이 내부 클래스입니다. {0}
module.service.no.ctor=서비스 구현에는 공용 디폴트 생성자가 없습니다. {0}
module.service.provider.type=''provider'' 메서드 반환 타입은 서비스 인터페이스 타입의 하위 타입이어야 합니다. {0}
module.service.unused=서비스 인터페이스가 제공되었지만 내보내지거나 사용되지 않습니다
module.unwanted.modifier.warn='requires java.base'에 대한 제어자는 Java 10 이후 릴리스에서 사용이 금지됩니다
multiple.non.overriding.abstract.methods.found.in.0=재정의하지 않는 추상 메서드 여러 개가 {0}에서 발견되었습니다
multiple.non.overriding.abstract.methods.found.in.interface.0=재정의하지 않는 추상 메서드 여러 개가 인터페이스 {0}에서 발견되었습니다
multiple.switch.labels=switch 라벨이 패턴 변수를 선언하지 않을 때만 switch 라벨이 지정된 구문 그룹에서 다수의 switch 라벨이 허용됩니다
native.methods.cannot.have.a.body=네이티브 메서드는 본문을 가질 수 없습니다
no.default.constructor.available=''{0}''에서 사용할 수 있는 디폴트 생성자가 없습니다
no.enclosing.instance.in.scope=타입 ''{0}''을(를) 둘러싸는 인스턴스가 범위 안에 없습니다
no.interface.expected=인터페이스가 필요하지 않습니다
no.target.method.found=타깃 메서드를 찾을 수 없습니다
non.static.method.cannot.be.referenced.from.a.static.context.method.reference.context=static 컨텍스트에서 비 static 메서드를 참조할 수 없습니다
non.static.symbol.referenced.from.static.context=비 static {0} ''{1}''은(는) static 컨텍스트에서 참조할 수 없습니다
not.a.functional.interface={0}은(는) 함수 인터페이스가 아닙니다
not.a.statement=구문이 아닙니다
not.allowed.in.interface=인터페이스에서 허용되지 않습니다
not.allowed.in.sealed.hierarchy=''{0}''은(는) sealed 계층 구조에서 허용되지 않습니다
not.inner.class=''{0}''은(는) 내부 클래스가 아닙니다
not.loop.label=루프 라벨이 아닙니다. ''{0}''
null.label.not.allowed.here=잘못된 case 라벨 조합입니다. 'null'은 단일 case 라벨로 사용되거나 'default'와만 쌍이 될 수 있습니다
numeric.overflow.in.expression=표현식 내 숫자 오버플로
overridden.method.does.not.throw={0}. 재정의된 메서드가 ''{1}''을(를) 던지지 않습니다
override.not.allowed.in.interfaces=@Override는 인터페이스 메서드 구현 시 허용되지 않습니다
overrides.deprecated.method=''{0}''에서 곧 사용할 수 없게 될 메서드를 재정의합니다
overrides.marked.for.removal.method=''{0}''에서 곧 사용할 수 없게 될 제거 표시된 메서드를 재정의합니다
package.clashes.with.class=패키지 ''{0}''이(가) 동일한 이름의 클래스와 충돌합니다
package.is.empty=패키지가 비어 있습니다. {0}
package.local.symbol=''{0}''이(가) ''{1}''에서 public이 아닙니다. 외부 패키지에서 액세스할 수 없습니다
package.name.file.path.mismatch=패키지 이름 ''{0}''이(가) 파일 경로 ''{1}''에 해당하지 않습니다
package.not.found=패키지를 찾을 수 없습니다. {0}
parameter.excluding.hierarchy.disable.text=상속된 메서드의 매개변수를 강조 표시 안 함
parameter.is.not.used=매개변수 ''{0}''이(가) 한 번도 사용되지 않습니다
parameterized.qualifier.on.static.method.reference.context=static 메서드 참조에서 매개변수화된 한정자
pattern.is.not.exhaustive=패턴 ''{0}''은(는) ''{1}''에서 완전하지 않습니다
pattern.variable.is.not.used=패턴 변수 ''{0}''이(가) 한 번도 사용되지 않습니다
permit.list.must.contain.outside.inheritors=봉인된 클래스의 permits 절은 모든 하위 클래스를 포함해야 합니다
permits.after.enum=허가 절은 열거형에 허용되지 않습니다
permits.list.generics.are.not.allowed=제네릭은 허가 목록에서 허용되지 않습니다
permitted.subclass.must.have.modifier=sealed 클래스의 하위 클래스는 final, sealed, non-sealed 중 하나여야 합니다
private.constructor.is.not.used=private 생성자 ''{0}''이(가) 한 번도 사용되지 않습니다
private.field.is.not.assigned=private 필드 ''{0}''이(가) 한 번도 대입되지 않았습니다
private.field.is.not.used=private 필드 ''{0}''이(가) 사용되지 않습니다
private.inner.class.is.not.used=private 내부 클래스 ''{0}''이(가) 한 번도 사용되지 않습니다
private.inner.interface.is.not.used=private 내부 인터페이스 ''{0}''이(가) 한 번도 사용되지 않습니다
private.method.is.not.used=private 메서드 ''{0}''이(가) 한 번도 사용되지 않습니다
private.methods.in.interfaces.should.have.body=인터페이스의 private 메서드는 본문이 있어야 합니다
private.symbol=''{0}''이(가) ''{1}''에서 private 액세스를 가집니다
protected.symbol=''{0}''이(가) ''{1}''에서 protected 액세스를 가집니다
public.class.should.be.named.after.file=클래스 ''{0}''은(는) public이며, 이름이 ''{0}.java''인 파일에 선언되어야 합니다
qualified.class.reference.not.allowed.in.qualified.new=정규화된 클래스 참조는 정규화된 new에서 허용되지 않습니다
qualified.enum.constant.in.switch=열거형 switch case 라벨은 열거형 상수의 정규화되지 않은 이름이어야 합니다
qualified.enum.constant.in.switch.remove.fix=한정자 제거
qualified.new.of.static.class=static 클래스의 정규화된 new
qualifier.must.be.expression=한정자는 표현식이어야 합니다
receiver.name.mismatch=리시버 이름이 둘러싸는 클래스 타입과 일치하지 않습니다
receiver.static.context=리시버는 static 컨텍스트에서 사용할 수 없습니다
receiver.type.mismatch=리시버 타입이 둘러싸는 클래스 타입과 일치하지 않습니다
receiver.wrong.context=리시버는 메서드 매개변수 목록 외부에서 허용되지 않습니다
receiver.wrong.position=리시버는 첫 번째 매개변수여야 합니다
record.accessor=레코드 구성 요소 접근자
record.accessor.wrong.return.type=잘못된 구성 요소 접근자 반환 타입. 필요: ''{0}'', 발견: ''{1}''
record.canonical.constructor=표준 생성자
record.canonical.constructor.wrong.parameter.name=표준 생성자 매개변수 이름이 레코드 구성 요소 이름과 일치해야 합니다. 필요: ''{0}'', 발견: ''{1}''
record.canonical.constructor.wrong.parameter.type=레코드 구성 요소에 대한 잘못된 매개변수 타입 ''{0}''. 필요: ''{1}'', 발견: ''{2}''
record.compact.constructor=압축 생성자
record.compact.constructor.return='return' 문은 압축 생성자에서 허용되지 않습니다
record.component.cstyle.declaration=레코드 구성 요소 내에서 C 스타일의 배열 선언은 허용되지 않습니다
record.component.not.initialized=레코드 구성 요소 ''{0}''이(가) 표준 생성자에서 초기화되지 않을 수 있습니다
record.component.restricted.name=올바르지 않은 레코드 구성 요소 이름 ''{0}''
record.component.vararg.not.last=vararg 레코드 구성 요소는 목록의 마지막 구성 요소여야 합니다
record.constructor.call.in.canonical=표준 생성자는 다른 생성자에 위임할 수 없습니다
record.extends=확장 절은 레코드에서 허용되지 않습니다
record.header.regular.class=레코드 헤더가 비 레코드에 대해 선언되었습니다
record.instance.field=인스턴스 필드는 레코드에서 허용되지 않습니다
record.instance.initializer=인스턴스 이니셜라이저는 레코드에서 허용되지 않습니다
record.no.constructor.call.in.non.canonical=비 표준 레코드 생성자는 다른 생성자에 위임해야 합니다
record.no.header=레코드에 헤더가 선언되지 않았습니다
record.permits=허가 절은 레코드에 허용되지 않습니다
record.special.method.non.public={0}은(는) ''public''이어야 합니다
record.special.method.stronger.access={0} 액세스 수준은 레코드 액세스 수준(''{1}'')보다 제한적일 수 없습니다
record.special.method.throws={0}은(는) 던져진 예외를 선언할 수 없습니다
record.special.method.type.parameters={0}은(는) 타입 매개변수를 가질 수 없습니다
recursive.constructor.invocation=재귀 생성자 호출
repeated.annotation.target=어노테이션 타깃 반복
repeated.interface=반복된 인터페이스
resource.variable.must.be.final=try-with-resources 리소스로 사용된 변수는 final 또는 유사 final이어야 합니다
restricted.identifier=''{0}''은(는) 제한된 식별자이므로 타입 선언에 사용될 수 없습니다
restricted.identifier.reference=제한된 타입 ''{0}''에 대한 올바르지 않은 참조
restricted.identifier.warn=Java {1} 이후 릴리스에서는 클래스 이름으로 ''{0}''을(를) 사용할 수 없습니다
return.from.void.method=void 결과 타입이 있는 메서드로부터 값을 반환할 수 없습니다
return.outside.method=외부 메서드 반환
return.outside.switch.expr=return이 switch 식 외부에 있습니다
safevararg.annotation.cannot.be.applied.for.record.component=@SafeVarargs는 레코드 구성 요소에서는 허용되지 않습니다
safevarargs.not.allowed.non.final.instance.methods=@SafeVarargs는 final이 아닌 인스턴스 메서드에서 허용되지 않습니다
safevarargs.not.allowed.on.methods.with.fixed.arity=@SafeVarargs은 매개변수 개수가 고정된 인스턴스 메서드에서 허용되지 않습니다
safevarargs.not.applicable.for.reifiable.types=@SafeVarargs를 구체화 타입에 적용할 수 없습니다
safevarargs.not.suppress.potentially.unsafe.operations=@SafeVarargs가 안전하지 않을 수 있는 연산을 억제합니다
sealed.cannot.be.functional.interface=sealed 클래스는 함수 인터페이스로 사용할 수 없습니다
sealed.must.have.inheritors=sealed 클래스는 하위 클래스가 있어야 합니다
sealed.type.inheritor.expected.modifiers={0}, {1} 또는 {2} 제어자가 필요합니다
single.import.class.conflict=''{0}''이(가) 단일 타입 import 문에 이미 정의되어 있습니다
statement.must.be.prepended.with.case.label=구문은 case 라벨 뒤에 사용해야 합니다
static.interface.method.call.qualifier=static 메서드는 인터페이스 클래스를 포함할 때만 호출할 수 있습니다
static.member.accessed.via.instance.reference=static 멤버 ''{0}.{1}''이(가) 인스턴스 참조를 통해 액세스됩니다
static.method.cannot.be.annotated.with.override=정적 메서드에 @Override를 사용하여 어노테이션을 추가할 수 없습니다.
static.method.cannot.override.instance.method=''{1}''의 static 메서드 ''{0}''은(는) ''{3}''의 인스턴스 메서드 ''{2}''을(를) 재정의할 수 없습니다
static.method.referenced.through.non.static.qualifier.method.reference.context=비 static 한정자를 통해 참조되는 static 메서드
static.method.referenced.through.receiver.method.reference.context=리시버를 통해 참조되는 static 메서드
static.methods.in.interfaces.should.have.body=인터페이스의 static 메서드는 본문이 있어야 합니다
suspicious.name.assignment=''{0}''을(를) ''{1}''에 대입할 수 없습니다
suspicious.name.parameter=''{0}''을(를) 매개변수 ''{1}''(으)로 전달할 수 없습니다
suspicious.name.return=''{0}''을(를) 메서드 ''{1}''에서 반환할 수 없습니다
switch.class.or.array.type.expected=클래스 또는 배열
switch.constant.expression.required=상수식, 패턴 또는 null이 필요합니다
switch.dominance.of.preceding.label=라벨은 선행 case 라벨 ''{0}''에 의해 지배됩니다
switch.expr.empty='switch' 식에 case 절이 없습니다
switch.expr.incomplete='switch' 식이 모든 가능한 입력 값을 포함하지 않습니다
switch.expr.no.result=switch 식에 결과식이 없습니다.
switch.expr.rule.should.produce.result=switch 식 규칙은 모든 실행 경로에서 결과를 생성해야 합니다
switch.expr.should.produce.result=switch 식은 모든 실행 경로에서 결과를 생성해야 합니다
switch.expression.cannot.be.void=switch 식의 타깃 타입은 void일 수 없습니다.
switch.illegal.fall.through.from=패턴으로부터의 잘못된 fall-through
switch.illegal.fall.through.to=패턴으로의 잘못된 fall-through
switch.invalid.selector.types=''{0}''의 선택자 타입은 지원되지 않습니다
switch.statement.empty='switch' 문에 case 절이 없습니다
switch.statement.incomplete='switch' 문이 모든 가능한 입력 값을 포함하지 않습니다
switch.unconditional.pattern.and.default.exist='switch'에 조건이 없는 패턴 및 디폴트 라벨이 모두 있습니다
target.method.is.generic=타깃 메서드는 제네릭입니다
target.type.of.a.lambda.conversion.must.be.an.interface=람다 변환의 타깃 타입은 인터페이스여야 합니다.
text.block.new.line=잘못된 텍스트 블록 시작: 여는 따옴표 뒤에 새 줄이 누락되었습니다
text.block.unclosed=닫히지 않은 텍스트 블록
text.class.cannot.access={0}에 액세스할 수 없습니다
text.class.inherits.abstract.and.default={0}이(가) 타입 {2} 및 {3}의 {1}에 대해 추상 및 디폴트를 상속합니다
text.class.inherits.unrelated.defaults={0}이(가) 타입 {2}의 {1}에 대해 관련 없는 디폴트를 상속합니다
text.class.is.not.accessible={0}은(는) 현재 컨텍스트에서 액세스할 수 없습니다
text.improper.formed.type=타입의 양식이 부적절합니다. 일부 타입 매개변수가 누락되었습니다
too.many.array.dimensions=배열 차원이 너무 많습니다
too.many.characters.in.character.literal=문자 리터럴에 문자가 너무 많습니다
two.methods.are.inherited.with.same.signature={1}의 메서드 {0} 및 {3}의 {2}이(가) 같은 시그니처로 상속되었습니다
type.parameter.cannot.be.followed.by.other.bounds=타입 매개변수 다음에 다른 바운드가 올 수 없습니다
type.parameter.has.incompatible.upper.bounds=타입 매개변수 {0}이(가) 호환되지 않는 상위 바운드를 포함합니다. {1}
type.parameter.is.not.used=타입 매개변수 ''{0}''이(가) 한 번도 사용되지 않습니다
type.pattern.expected=타입 패턴이 필요합니다
unary.operator.not.applicable=연산자 ''{0}''을(를) ''{1}''에 적용할 수 없습니다
unchecked.overriding.incompatible.return.type=확인되지 않은 재정의: 반환 타입에 확인되지 않은 변환이 필요합니다. 발견: ''{0}'', 필요: ''{1}''
unclosed.char.literal=닫히지 않은 문자 리터럴
unclosed.comment=닫히지 않은 주석
underscore.identifier.error=Java 9에서 '_'은 키워드이며 식별자로 사용할 수 없습니다
underscore.identifier.warn='_'은 Java 9 이후 릴리스에서 식별자로 사용할 수 없습니다
underscore.lambda.identifier='_'을 람다 매개변수 이름으로 사용할 수 없습니다
unexpected.token=예기치 않은 토큰
unexpected.type=예기치 않은 타입입니다. 발견: ''{1}'', 필요: ''{0}''
unexpected.type.class.expected=예기치 않은 타입입니다. 클래스가 필요합니다.
unhandled.close.exceptions=\ {2}에서 처리되지 않은 {1, choice, 0#예외|2#예외}: {0}
unhandled.exceptions=처리되지 않은 {1, choice, 0#예외|2#예외}: {0}
unknown.class=알 수 없는 클래스: ''{0}''
unqualified.super.disallowed=정규화되지 않은 super 참조는 확장 메서드에서 허용되지 않습니다
unreachable.statement=도달할 수 없는 명령문
unreachable.statement.false.condition=루프 조건이 항상 거짓이므로 루프 본문에 도달할 수 없습니다
unrelated.overriding.methods.return.types=메서드에 관련 없는 반환 타입이 있습니다
unresolved.label=정의되지 않은 라벨: ''{0}''
unsafe.cast.in.instanceof=''{0}''을(를) ''{1}''(으)로 안전하게 형 변환할 수 없습니다
valid.switch.17.selector.types=char, byte, short, int, Character, Byte, Short, Integer, String 또는 enum
valid.switch.selector.types=byte, char, short 또는 int
vararg.cstyle.array.declaration=vararg 인수 내에서 C 스타일의 배열 선언은 허용되지 않습니다
vararg.not.last.parameter=vararg 매개변수는 목록의 마지막 매개변수여야 합니다
variable.already.assigned=변수 ''{0}''이(가) 다음에 이미 대입되었을 수 있습니다
variable.already.defined=변수 ''{0}''은(는) 범위에 이미 정의되어 있습니다
variable.assigned.in.loop=변수 ''{0}''이(가) 루프에 대입되어 있을 수 있습니다
variable.expected=변수 필요
variable.must.be.final=변수 ''{0}''은(는) 내부 클래스 내에서 액세스되므로 final로 선언해야 합니다
variable.must.be.final.or.effectively.final=변수 ''{0}''은(는) 내부 클래스 내에서 액세스되므로 final 또는 유사 final이어야 합니다
variable.not.initialized=변수 ''{0}''이(가) 초기화되지 않았을 수 있습니다
visibility.access.problem=''{1}''의 ''{0}''에 액세스할 수 없습니다
visibility.module.access.problem={2}(으)로 인해 ''{1}''의 ''{0}''에 액세스할 수 없습니다
void.type.is.not.allowed='void' 타입은 허용되지 않습니다
weaker.privileges={0}. 기존의 ''{2}''보다 약한 액세스 권한(''{1}'')을 할당하려고 합니다
when.expression.is.false=이 case 라벨에 'false' 값을 가진 상수 식인 guard가 있습니다
wildcard.type.cannot.be.instantiated=와일드카드 타입 ''{0}''을(를) 직접 인스턴스화할 수 없습니다
wrong.constructor.arguments=''{0}''을(를) ''{1}''에 적용할 수 없습니다
wrong.method.arguments=''{1}''의 ''{0}''을(를) ''{2}''에 적용할 수 없습니다
yield.unexpected=yield가 switch 식 외부에 있습니다
yield.unqualified.method.warn='yield' 메서드에 대한 정규화되지 않은 호출은 Java 14 이후 릴리스에서 지원되지 않습니다
yield.void=표현식 타입이 'void'일 수 없습니다