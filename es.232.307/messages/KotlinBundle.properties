0.1.be.lifted.out.of.2={0}을(를) ''{2}''에서 제거{1}.
0.1.could.be.private={0} ''{1}''은(는) private이 될 수 있습니다.
0.1.is.never.used={0} ''{1}''이(가) 한 번도 사용되지 않습니다.
0.already.exists={0} 이(가) 이미 존재합니다
0.always.returns.non.null.type=''{0}''이(가) null이 아닌 유형을 항상 반환합니다
0.call.could.be.simplified.to.1={0} 호출을 {1}(으)로 단순화할 수 있습니다.
0.call.should.be.replaced.with.array.literal=''{0}'' 호출을 배열 리터럴 [...]로 바꿔야 합니다.
0.from.1={1}의 {0}
0.has.detected.1.code.fragments.in.2.that.can.be.replaced.with.3={0}이(가) {3}(으)로 대체 가능한 {2}에서 {1} 코드 {1,choice,1\#조각|2\#조각}을 탐지했습니다. {1,choice,1\#코드 조각|2\#코드 조각}을 검토 후 바꾸시겠어요?
0.has.empty.body=''{0}''의 본문이 비어 있습니다.
0.in.1.will.require.class.instance={1}의 ''{0}''에 클래스 인스턴스가 필요합니다
0.interface.1=인터페이스 ''{1}''을(를) {0}합니다.
0.is.always.non.null.type=''{0}''이(가) 항상 null이 아닌 유형입니다
0.is.expected.to.be.used.since.kotlin.1.3=''{0}''은(는) Kotlin 1.3부터 사용될 예정입니다
0.is.missing.documentation={0}에 문서가 누락되었습니다.
0.is.overridden.by.declaration.s.in.a.subclass={0}이(가) 하위 클래스의 선언으로 재정의되어 있습니다
0.may.break.code={0}(코드를 손상시킬 수 있음)
0.on.a.readonly.1.creates.a.new.1.under.the.hood=읽기 전용 {1}에 있는 ''{0}''이(가) 내부적으로 새 {1}을(를) 생성합니다
0.references.type.parameters.of.the.containing.class=포함된 클래스의 {0} 참조 유형 매개변수
0.should.return.unit={0}이(가) Unit을 반환해야 합니다.
0.try.1.with.2.fails.and.3.verifications={0} [{1}회 시도 중 {2}회 실패, {3}회 검증]
0.will.become.invisible.after.extraction={0} 은(는) 추출 후 보이지 않게 됩니다.
0.will.no.longer.be.accessible.after.extraction={0} 은(는) 추출 후 액세스할 수 없게 됩니다.
a.constructor.call.is.not.yet.supported=생성자 호출은 아직 지원되지 않습니다
a.field.without.an.initializer.is.not.yet.supported=이니셜라이저가 없는 필드는 아직 지원되지 않습니다
accessing.non.final.property.0.in.constructor=생성자 내 final이 아닌 프로퍼티 {0}에 액세스
action.CacheResetOnProcessCanceledToggleAction.text=ProcessCanceledException의 캐시 재설정
action.CheckComponentsUsageSearchAction.text=구성 요소 함수 사용 위치 검색 확인
action.ConfigureKotlinInProject.text=Configurar Kotlin en el proyecto
action.ConvertJavaToKotlin.text=Convierta archivos Java a archivos Kotlin
action.CopyAsDiagnosticTest.text=Copiar el archivo actual como prueba de diagnóstico
action.CopyKotlinProjectInformation.text=Copiar el esquema del proyecto de Kotlin al portapapeles
action.DecompileKotlinToJava.text=Descompilar Kotlin a Java
action.DumbModeTremble.text=Tremble Dumb 모드
action.ExtractFunction.text=_Función…
action.ExtractFunctionToScope.text=함수를 범위로(_S)…
action.FindImplicitNothingAction.text=묵시적 Nothing 호출 찾기
action.GotoSuperClass.MainMenu.text=상위 클래스(_U)
action.GotoSuperClass.text=상위 클래스로 이동(_U)
action.GotoSuperInterface.MainMenu.text=상위 인터페이스(_U)
action.GotoSuperInterface.text=상위 인터페이스로 이동(_U)
action.GotoSuperProperty.MainMenu.text=상위 프로퍼티(_U)
action.GotoSuperProperty.description=현재 프로퍼티가 재정의하거나 구현하는 프로퍼티의 선언으로 이동합니다
action.GotoSuperProperty.text=상위 프로퍼티로 이동(_U)
action.HighlightingBenchmarkAction.text=벤치마크 강조 표시
action.InspectBreakpointApplicability.text=Comprobación de la aplicabilidad del punto de interrupción
action.IntroduceProperty.text=_Propiedad…
action.IntroduceTypeAlias.text=유형 별칭(_A)…
action.IntroduceTypeParameter.text=Parámetro de _tipo…
action.Kotlin.ClearScratch.description=Kotlin 스크래치 지우기
action.Kotlin.ClearScratch.text=Kotlin 스크래치 지우기
action.Kotlin.Gradle.ShowDslLogs.text=Kotlin Gradle DSL 로그 표시
action.Kotlin.NewFile.description=새 Kotlin 클래스 또는 파일을 생성합니다
action.Kotlin.NewFile.text=Kotlin 클래스/파일
action.Kotlin.NewScript.description=새 Kotlin 스크립트나 워크시트를 생성합니다
action.Kotlin.NewScript.text=Kotlin 스크립트
action.Kotlin.RunScratch.description=Kotlin 스크래치 실행
action.Kotlin.RunScratch.text=Kotlin 스크래치 실행
action.Kotlin.StopScratch.description=스크래치 실행 중지
action.Kotlin.StopScratch.text=스크래치 실행 중지
action.Kotlin.XDebugger.CoroutinesDump.text=Obtener volcado de rutina
action.Kotlin.XDebugger.ToggleKotlinVariableView.text=Mostrar solo variables de Kotlin
action.KotlinCodeMigration.text=Ejecutar la migración de código
action.KotlinCodeMigrationToggle.text=Habilitar la detección de migración(experimental)
action.KotlinConfigureUpdates.description=Configurar actualizaciones automáticas para complementos de Kotlin
action.KotlinConfigureUpdates.text=Configurar las actualizaciones del complemento de Kotlin
action.KotlinConsoleREPL.text=Kotlin REPL
action.KotlinFormattingSettingsStatusAction.text=서식 지정 도구 설정 정보
action.KotlinGenerateDataMethod.text=매개변수 함수
action.KotlinGenerateEqualsAndHashCode.text=equals() 및 hashCode()
action.KotlinGenerateMavenCompileExecutionAction.text=Kotlin 컴파일 실행
action.KotlinGenerateMavenPluginAction.text=Kotlin 플러그인
action.KotlinGenerateMavenTestCompileExecutionAction.text=Kotlin 테스트 컴파일 실행
action.KotlinGenerateSecondaryConstructor.text=보조 생성자
action.KotlinGenerateSetUpMethod.text=SetUp 함수
action.KotlinGenerateTearDownMethod.text=TearDown 함수
action.KotlinGenerateTestMethod.text=Test 함수
action.KotlinGenerateToString.text=toString()
action.KotlinShellExecute.description=콘솔에서 Kotlin 코드를 실행합니다
action.KotlinShellExecute.text=Kotlin 코드 실행
action.KotlinThrowException.text=Kotlin 플러그인의 오류 삭제
action.LibraryToSourceDependencySupportToggleAction.text=Cambiar la biblioteca al soporte de dependencia de origen
action.LocalCompletionBenchmarkAction.text=Escenario local
action.PrintOutNotPropertyMatches.text=프로퍼티가 아닌 후보 검색
action.ShowKotlinBytecode.text=Visualización del código de bytes de Kotlin
action.StoredExceptionsThrowToggleAction.text=캐싱된 PCE 던지기
action.TestMoveRefactiringAction.text=열려 있는 프로젝트에서 이동 리팩터링 테스트
action.TopLevelCompletionBenchmarkAction.text=최상위 시나리오
action.add.import.chooser.title=Importar
action.generate.equals.choose.equals=Seleccionar propiedades para incluir en' 'equals ()' 
action.generate.equals.choose.hashcode=Seleccionar propiedades para incluir en' 'hashCode ()' 
action.generate.functions.already.defined=La función {0} ya está definida para la clase {1}. ¿Está seguro de que desea eliminar esa función y continuar?
action.generate.secondary.constructor.choose.properties=Seleccionar propiedades para inicializar con el constructor
action.generate.secondary.constructor.error.already.exists=El constructor ya existe.
action.generate.test.support.choose.framework=Elija un marco
action.generate.test.support.choose.test.name=Elija el nombre de la prueba\:
action.generate.test.support.edit.template=Editar plantilla
action.generate.test.support.error.cant.convert.java.template=No se pudo convertir la plantilla Java a Kotlin.
action.generate.test.support.error.cant.generate.method=No se pudo crear el método {0}.
action.generate.test.support.error.no.template.found=No se pudo encontrar la plantilla para {0}. {1}
action.generate.tostring.choose.implementation=Elija implementación\:
action.generate.tostring.choose.implementation.mnemonic=i
action.generate.tostring.generate.super.call=generar llamada a super.toString()
action.generate.tostring.generate.super.call.mnemonic=s
action.generate.tostring.name=crear toString()
action.generate.tostring.template.multiple=Varias plantillas con conexiones
action.generate.tostring.template.single=Plantilla única
action.hints.settings.text=힌트 설정...
action.j2k.correction.errors.multiple=''{0}'' y {1} otros archivos Java contienen errores de sintaxis, que pueden resultar en conversiones incorrectas.
action.j2k.correction.errors.single=''{0}'' contiene un error de sintaxis, que puede dar como resultado resultados de conversión incorrectos.
action.j2k.correction.investigate=Investigar errores
action.j2k.correction.proceed=Conversión en curso
action.j2k.correction.required=Esta transformación puede requerir que corrija algo de código en el resto de su proyecto. ¿Le gustaría encontrar el código y arreglarlo juntos?
action.j2k.error.cant.find.document=No se encontró documentación para ''{0}''.
action.j2k.error.cant.save.result=No se pudo guardar el resultado de la conversión {0}.
action.j2k.error.nothing.to.convert=변환할 것이 없습니다.<br>쓰기 가능한 Java 파일을 찾을 수 없습니다
action.j2k.error.read.only=El archivo ''{0}'' es de solo lectura
action.j2k.name=Convertir Java a Kotlin
action.j2k.task.name=Convertir archivo de Java a Kotlin
action.move.method=메서드 이동...
action.new.file.dialog.annotation.title=Anotación
action.new.file.dialog.class.title=Clase
action.new.file.dialog.data.class.title=Clase de datos
action.new.file.dialog.enum.title=Clase Enum
action.new.file.dialog.file.title=Archivo
action.new.file.dialog.interface.title=Interfaz
action.new.file.dialog.object.title=Objeto
action.new.file.dialog.sealed.class.title=Clase sellada
action.new.file.dialog.sealed.interface.title=Sealed 인터페이스
action.new.file.dialog.title=Nuevas clases/archivo Kotlin
action.new.file.error.empty.name=Debe tener un nombre.
action.new.file.error.empty.name.part=El nombre no debe contener espacios en blanco.
action.new.script.dialog.title=새 Kotlin 스크립트
action.new.script.name=Script de Kotlin
action.new.worksheet.name=Hoja de trabajo de Kotlin
action.text.append=Añadir
action.text.cancel=Cancelar
action.text.install=설치
action.text.overwrite=겹쳐쓰기
action.usage.update.command=사용 위치 업데이트
add.0.constructor.to.1={0} 생성자를 ''{1}''에 추가합니다.
add.0.to.argument=''{0} \=''를 인수에 추가
add.0.to.module.1.compiler.arguments=''{0}''을(를) 모듈 {1} 컴파일러 인수에 추가합니다.
add.an.opt.in.requirement.marker.compiler.argument=선택 요구 사항 마커 컴파일러 인수를 추가합니다.
add.braces=중괄호 추가
add.braces.to.0.statement=''{0}'' 문에 중괄호를 추가합니다.
add.braces.to.all.branches=모든 브랜치에 중괄호 추가
add.braces.to.if.all.statements=모든 'if' 문에 중괄호 추가
add.braces.to.when.all.entries=모든 'when' 항목에 중괄호 추가
add.braces.to.when.entry=''when'' 항목에 중괄호 추가
add.call.or.unwrap.type.fix.text=''.{0}()''을(를) 함수 결과에 추가합니다(use-sites 분리).
add.call.or.unwrap.type.fix.text1=''{0}'' 반환 유형을 래핑 해제합니다(use-sites 분리).
add.constructor.keyword=''constructor'' 키워드를 추가합니다.
add.constructor.parameters.from.0.1={0}{1}의 생성자 매개변수를 추가합니다.
add.constructor.parameters.from.superclass=상위 클래스의 생성자 매개변수를 추가합니다.
add.documentation.fix.text=문서를 추가합니다.
add.empty.argument.list=빈 인수 목록 추가
add.empty.brackets.after.primary.constructor=기본 생성자 뒤에 빈 대괄호를 추가합니다.
add.explicit.parameter.to.outer.lambda.fix.text=외부 람다에 명시적 매개변수 이름을 추가합니다.
add.explicit.type.arguments=명시적 유형 인수 추가
add.external.keyword=external 키워드 추가
add.full.qualifier=완전한 한정자 추가
add.fun.modifier.to.0=''{0}''에 ''fun'' 제어자 추가
add.import.for.0=''{0}''의 import 문 추가
add.import.for.member=멤버의 import 문 추가
add.indices.to.for.loop=''for'' 루프에 색인 추가
add.initializer=이니셜라이저를 추가합니다.
add.jvminline.annotation='@ JvmInline' 어노테이션 추가
add.jvmoverloads.annotation=''@JvmOverloads'' 어노테이션 추가
add.jvmoverloads.annotation.to.0=''@JvmOverloads'' 어노테이션을 {0}에 추가
add.jvmstatic.annotation=''@JvmStatic'' 어노테이션 추가
add.labeled.return.to.last.expression.in.a.lambda=람다 내 마지막 표현식에서 라벨 지정된 return 제거
add.method=메서드 추가
add.method.0.to.1=메서드 ''{0}''을(를) ''{1}''에 추가합니다.
add.missing.class.keyword=누락된 ''class'' 키워드 추가
add.missing.component=누락된 구성 요소 추가
add.modifier=제어자 추가
add.name.to.argument=인수에 이름 추가
add.names.in.comment.to.call.arguments=주석 내 이름을 호출 인수에 추가
add.names.to.call.arguments=호출 인수에 이름 추가
add.names.to.this.argument.and.following.arguments=이 인수 및 다음 인수에 이름 추가
add.operator.modifier=''operator'' 제어자를 추가합니다.
add.remaining.branches=남아 있는 브랜치를 추가합니다.
add.replacewith.argument.to.specify.replacement.pattern=''replaceWith'' 인수를 추가하여 대체 패턴을 지정합니다.
add.return.at.0=return@ 추가{0}
add.return.expression='return' 표현식을 추가합니다
add.source.retention=소스 보관 항목을 추가합니다.
add.throws.annotation=''@Throws'' 어노테이션 추가
add.underscores=밑줄 추가
add.use.site.target=사용 사이트 대상 추가
add.val.to.parameter.0=''val''을 매개변수 ''{0}''에 추가
add.val.var.to.parameter.0=val/var을 매개변수 ''{0}''에 추가
add.val.var.to.primary.constructor.parameter=val/var을 기본 생성자 매개변수에 추가
add.variance.fix.family.name=분산 추가
add.variance.fix.text=''{0}'' 분산을 추가합니다.
advanced.setting.kotlin.mpp.experimental=실험적 멀티플랫폼
advanced.setting.kotlin.mpp.experimental.description=실험적 멀티플랫폼 IDE 기능을 활성화합니다
all.expected.and.actual.classes.must.be.sealed.classes=모든 기대 및 실제 클래스는 봉인된 클래스여야 합니다.\n
all.inheritors.must.be.nested.objects.of.the.class.itself.and.may.not.inherit.from.other.classes.or.interfaces=모든 상속자는 클래스 자체의 중첩된 객체여야 하며 다른 클래스나 인터페이스에서 상속받으면 안 됩니다.\n
ambiguous.coroutinecontext.due.to.coroutinescope.receiver.of.suspend.function=suspend 함수의 CoroutineScope 리시버로 인해 모호해진 coroutineContext
ambiguous.non.local.break.or.continue=로컬이 아닌 모호한 ''{0}''입니다(''{1}'' 대 ''{2}''). 명확히 구분하는 라벨을 사용하거나 ''callsInPlace'' 컨트랙트를 추가하세요.
ambiguous.non.local.break.or.continue.display.name=로컬이 아닌 모호한 'break' 또는 'continue'
analyzed.0.classes.no.difference.found={0}개의 클래스를 분석했으나 차이점이 발견되지 않았습니다.
analyzing.functions=함수 분석 중...
analyzing.members=멤버 분석 중 ...
and.delete.initializer=\ 및 이니셜라이저 삭제
apply.also.to.internal.members=내부 멤버에도 적용합니다.
apply.also.to.private.members=private 멤버에도 적용합니다.
apply.in.the.project.0=프로젝트에서 적용\: {0}
apply.only.to.public.or.protected.members=public 또는 protected 멤버에만 적용합니다.
applying.0=''{0}'' 적용
array.property.in.data.class.it.s.recommended.to.override.equals.hashcode=데이터 클래스의 배열 프로퍼티\: equals()/hashCode()를 재정의하는 것이 좋습니다.
assert.should.be.replaced.with.operator=어설션을 연산자로 바꿔야 합니다.
assign.backing.field.fix.text=백킹 필드를 대입합니다.
base.property.0=기본 프로퍼티 {0}
block.body=블록 본문
boolean.literal.argument.without.parameter.name=매개변수 이름이 없는 부울 리터럴 인수
boolean.property.in.external.interface.should.be.nullable=외부 인터페이스 내의 부울 프로퍼티는 null이 가능해야 합니다
breadcrumbs.tooltip.indexing=Indexación…
button.add.package=패키지 추가
button.text.move.nested.class.0.to.another.class=중첩된 클래스 {0} 을(를) 다른 클래스로 이동(&M)
button.text.move.nested.class.0.to.upper.level=중첩된 클래스 {0} 을(를) 상위 수준으로 이동(&N)
call.chain.length.to.transform=변환할 호출 체인 길이\:
call.chain.on.collection.could.be.converted.into.sequence.to.improve.performance=성능 향상을 위해 컬렉션의 호출 체인을 ''Sequence''로 변환할 수 있습니다.
call.chain.on.collection.type.may.be.simplified=컬렉션 유형에 대한 호출 체인을 단순화할 수 있습니다.
call.is.replaceable.with.another.scope.function=호출을 다른 범위 함수로 바꿀수 있습니다.
call.of.inline.function.with.nullable.extension.receiver.can.cause.npe.in.kotlin.1.2=Kotlin 1.2 이전 버전에서 null 가능한 리시버가 있는 'inline fun'을 호출하면 'NPE'가 발생할 수 있습니다
call.of.java.mutator.0.on.immutable.kotlin.collection.1=불변 Kotlin 컬렉션 ''{1}''에서의 Java 변경자 ''{0}''의 호출
call.on.collection.type.may.be.reduced=컬렉션 유형에 대한 호출을 줄일 수 있습니다.
call.on.not.null.type.may.be.reduced=null이 아닌 유형에 대한 호출을 줄일 수 있습니다.
call.replaceable.with.binary.operator=2진 연산자로 대체 가능한 호출
call.with.arguments.will.be.skipped.0=인수가 있는 호출을 건너뜁니다. {0}
callable.reference.fix.family.name=명시적 ''{0}'' 추가
callable.reference.transformation.is.not.supported.0=호출 가능한 참조 변환이 지원되지 않습니다. {0}
calling.non.final.function.0.in.constructor=생성자 내 final이 아닌 함수 {0} 호출
calls.with.explicit.extension.receiver.won.t.be.processed.0=명시적 확장 리시버가 있는 호출은 처리되지 않습니다. {0}
can.be.converted.to.to=''to''로 변환할 수 있습니다.
can.be.joined.with.assignment=대입과 결합할 수 있습니다
can.convert.argument.to.set=성능 향상을 위해 인수를 'Set'으로 변환할 수 있습니다
can.t.finish.while.indexing.is.in.progress=색인 생성이 진행되는 동안에는 완료할 수 없습니다.
can.t.modify.0={0}을(를) 수정할 수 없습니다
can.t.replace.foreign.reference.with.call.expression.0=외부 참조를 호출 표현식으로 바꿀 수 없습니다. {0}
can.t.replace.non.kotlin.reference.with.call.expression.0=Kotlin이 아닌 참조를 호출 표현식으로 바꿀 수 없습니다. {0}
cannot.extract.super.call=상위 호출을 추출할 수 없습니다.
cannot.get.or.create.results.file=결과 파일을 가져오거나 생성할 수 없습니다
cannot.get.project.root.directory=프로젝트 루트 디렉터리를 가져올 수 없습니다
cannot.infer.type.for.this.declaration=이 선언의 유형을 추론할 수 없습니다
cannot.inline.property.with.accessor.s.and.backing.field=접근자 및 백킹 필드가 있는 프로퍼티를 인라인화할 수 없습니다.
cannot.introduce.parameter.of.0.type=유형 ''{0}''의 매개변수를 삽입할 수 없습니다.
cannot.refactor.expression.has.unit.type=유닛 유형의 표현식을 삽입할 수 없습니다.
cannot.refactor.no.container=이곳에서 리팩터링할 수 없습니다.
cannot.refactor.no.expression=표현식 없이 리팩터링을 수행할 수 없습니다.
cannot.refactor.no.type=유형 없이 리팩터링을 수행할 수 없습니다.
cannot.refactor.not.expression=삽입할 표현식을 찾을 수 없습니다.
cannot.refactor.package.expression=패키지 참조를 삽입할 수 없습니다.
cannot.refactor.syntax.errors=잘못된 코드로 인해 리팩터링할 수 없습니다.
cannot.refactor.synthesized.function=통합 함수 ''{0}''을(를) 리팩터링할 수 없습니다.
cascade.if.should.be.replaced.with.when=캐스케이드 if를 when으로 바꿔야 합니다.
cast.explicitly.fix.text=명시적으로 형 변환합니다.
category.class=Kotlin/클래스 기반
category.comments=Kotlin/주석, KDoc 및 메타데이터
category.declaration=Kotlin/선언
category.expressions=Kotlin/표현식
category.interesting=Kotlin/관심
category.operators=Kotlin/연산자
change.all.usages.of.0.in.this.file.to.1=이 파일에 있는 ''{0}''의 모든 사용 위치를 ''{1}''(으)로 변경합니다.
change.all.usages.of.0.in.this.file.to.a.kotlin.class=이 파일에 있는 ''{0}''의 모든 사용 위치를 Kotlin 클래스로 변경합니다.
change.existent.retention.to.source=기존 보관 항목을 소스로 변경합니다.
change.main.function.return.type.to.unit.fix.text=명시적 Unit 반환 유형을 추가합니다.
change.main.function.return.type.to.unit.fix.text2=반환 유형을 Unit으로 변경합니다.
change.signature.conflict.text.kotlin.default.parameter.in.non.kotlin.files=디폴트 매개변수가 다른 언어에서 지원되지 않을 수 있습니다
change.signature.conflict.text.kotlin.default.value.in.non.kotlin.files=디폴트 Kotlin 호출 값으로 인해 다른 언어에서 잘못된 코드가 생길 수 있습니다
change.to.0=''{0}''(으)로 변경합니다.
change.to.constructor.invocation=생성자 호출로 변경합니다.
change.to.correct.long.suffix.l=올바른 긴 접미사 ''L''로 변경합니다.
change.to.correct.primitive.type=올바른 기본 유형으로 변경합니다.
change.to.kotlin.class=Kotlin 클래스로 변경합니다.
change.to.val=val로 변경합니다.
change.to.var=var로 변경합니다.
change.type.of.0.to.1={0}의 유형을 ''{1}''(으)로 변경합니다.
change.type.to.0=유형을 ''{0}''(으)로 변경
change.type.to.mutable.fix.text=유형을 가변으로 변경합니다.
change.visibility.modifier=가시성 제어자 변경
checkbox.text.declare.with.var=var로 선언(&V)
checkbox.text.delete.empty.source.files=빈 소스 파일 삭제(&D)
checkbox.text.extension.property=Propiedades e&xtendidas\:
checkbox.text.introduce.default.value=디폴트 값 삽입(&D)
checkbox.text.open.moved.files.in.editor=에디터에서 이동된 멤버 열기
checkbox.text.replace.all.occurrences.0=모든 사용 위치 바꾸기({0})(&R)
checkbox.text.search.references=참조 검색(&R)
checkbox.text.specify.type.explicitly=명시적으로 유형 지정(&T)
checkbox.text.update.package.directive=패키지 지시문 업데이트(Kotlin 파일)
checking.data.class.0.of.1=데이터 클래스 {0}/{1} 확인 중...
checking.data.classes=데이터 클래스 확인
choose.actual.members.title=실제 멤버 선택
choose.an.appropriate.kotlin.class=적절한 Kotlin 클래스를 선택합니다.
choose.class.container=클래스 컨테이너를 선택합니다.
choose.target.class.or.interface=대상 클래스 또는 인터페이스를 선택합니다.
class=클래스
class.0.already.contains.1=클래스'' {0}''에 {1}이(가) 이미 포함되어 있습니다
class.name.prompt=클래스 이름(&N)\:
class.should.be.external.interface=클래스는 외부 인터페이스여야 합니다
clipboard.content.copied.from.java.file.do.you.want.to.convert.it.to.kotlin.code=클립보드 내용이 Java 파일에서 복사되었습니다. Kotlin 코드로 변환하시겠어요?
code.insight.workspace.settings.title=Kotlin
codestyle.layout.import.aliases.separately=별칭을 개별적으로 가져오기
codestyle.name.kotlin=Kotlin
column.name.default.parameter=디폴트 매개변수:
column.name.receiver=리시버\:
column.name.val.var=Val/Var
command.generate.test.support.generate.test.function=테스트 함수 생성
command.move.declarations=선언 이동
comment=Comentario
companion.object.already.contains.0=컴패니언 객체에 {0}이(가) 이미 포함되어 있습니다
compiling.project=프로젝트 컴파일 중...
condition.is.always.0=조건이 항상 ''{0}''입니다.
configuration.kotlin.code.style.group.name=Kotlin 공식 코드 스타일 사용 가능
configuration.maven.group.name=Kotlin Maven 프로젝트 가져오기
configuration.message.enter.fully.qualified.method.name=정규화된 메서드 이름 입력\:
configuration.migration.group.name=Kotlin: 최신 버전으로 마이그레이션 가능
configuration.name.method=메서드
configuration.status.text.installing=Instalar...
configuration.title.add.exclusion=제외 추가
configuration.title.edit.exclusion=제외 편집
const.might.be.used.instead.of.jvmfield=''@JvmField'' 대신 ''const''를 사용할 수 있습니다.
const.property=Const 프로퍼티
constructor=생성자
constructor.has.non.null.self.reference.parameter=생성자에 null이 아닌 자체 참조 매개변수가 있습니다.
constructor.parameter.is.never.used.as.a.property=생성자 매개변수는 속성으로 사용되지 않습니다.
context.default=디폴트
context.property.getter.or.setter=명시적 getter/setter가 있는 프로퍼티
convert.0.to.1=''{0}''을(를) ''{1}''(으)로 변환
convert.anonymous.function.to.lambda.expression=익명 함수를 람다 식으로 변환
convert.argument.to.set.fix.text=인수를 'Set'으로 변환
convert.body.to.expression=본문을 표현식으로 변환
convert.boolean.const.to.elvis=Boolean? \=\= const를 elvis로 변환
convert.call.chain.into.sequence.fix.text=호출 체인을 ''Sequence''로 변환합니다.
convert.class.0.to.kotlin=클래스 ''{0}''을(를) Kotlin으로 변환
convert.collection.constructor.to.function=컬렉션 생성자를 함수로 변환
convert.concatenation.to.build.string=연결을 'buildString' 호출로 변환
convert.concatenation.to.raw.string=연결을 원시 문자열로 변환
convert.concatenation.to.template=연결을 템플릿으로 변환
convert.concatenation.to.template.before.text='String' 연결을 템플릿으로 변환할 수 있습니다
convert.expression.to.0=표현식을 ''{0}''(으)로 변환합니다.
convert.expression.to.0.by.inserting.1=''.{1}''을(를) 삽입하여 표현식을 ''{0}''(으)로 변환합니다.
convert.extension.function.type.to.regular.function.type=확장 함수 유형을 일반 함수 유형으로 변환합니다.
convert.extension.property.initializer.to.getter=확장 프로퍼티 초기자를 getter로 변환합니다.
convert.from.class.to.kclass='KClass'를 'Class'로 변환
convert.function.to.property=함수를 프로퍼티로 변환
convert.function.type.parameter.to.receiver=함수 유형 매개변수를 리시버로 변환
convert.function.type.receiver.to.parameter=함수 유형 리시버를 매개변수로 변환
convert.lambda.expression.to.anonymous.function=람다 식을 익명 함수로 변환
convert.lambda.to.reference=람다를 참조로 변환
convert.lambda.to.reference.before.text=람다를 참조로 변환할 수 있습니다
convert.left.hand.side.to.0=왼쪽을 ''{0}''(으)로 변환
convert.member.to.extension=멤버를 확장으로 변환합니다.
convert.na.n.equality.quick.fix.text=''isNaN()''으로 바꿉니다.
convert.object.literal.to.class=객체 리터럴을 클래스로 변환
convert.object.literal.to.lambda=객체 리터럴을 람다로 변환
convert.pair.constructor.to.to.fix.text=''to''로 변환합니다.
convert.parameter.to.receiver=매개변수를 리시버로 변환
convert.property.getter.to.initializer=프로퍼티 getter를 이니셜라이저로 변환
convert.property.initializer.to.getter=프로퍼티 이니셜라이저를 getter로 변환
convert.property.to.function=프로퍼티를 함수로 변환
convert.put.to.assignment=put을 대입으로 변환합니다.
convert.receiver.to.parameter=리시버를 매개변수로 변환
convert.reference.to.lambda=참조를 람다로 변환
convert.reference.to.lambda.before.text=참조를 람다로 변환할 수 있습니다
convert.right.hand.side.to.0=오른쪽을 ''{0}''(으)로 변환
convert.scope.function.fix.family.name=''{0}''(으)로 변환
convert.sealed.subclass.to.object.fix.family.name=봉인된 하위 클래스를 객체로 변환
convert.string.template.to.build.string='buildString' 호출로 변환
convert.string.to.character.literal=문자열을 문자 리터럴로 변환
convert.supertype.to.0=상위 유형을 ''{0}''(으)로 변환합니다.
convert.template.to.concatenated.string=템플릿을 연결된 문자열로 변환
convert.to.0={0}(으)로 변환합니다.
convert.to.0.as.1=''{1}(으)로서 {0}으(로)'' 변환
convert.to.0.unsafecast.1=''{0}.unsafeCast<{1}>()''로 변환
convert.to.a.range.check=범위 검사로 변환합니다.
convert.to.anonymous.function=익명 함수로 변환
convert.to.anonymous.object=익명 객체로 변환합니다.
convert.to.array.parameter=배열 매개변수로 변환
convert.to.assignment.expression=대입을 대입식으로 변환
convert.to.block.body=블록 본문으로 변환
convert.to.comparisons=비교로 변환
convert.to.concatenated.string.statement.analyzing.entry.type=항목 타입 분석 중...
convert.to.data.object='data object'로 변환
convert.to.enum.class=열거형 클래스로 변환
convert.to.expression.body.fix.text=표현식 본문으로 변환합니다.
convert.to.indexed.function.call=색인화된 함수 호출로 변환
convert.to.lambda=람다로 변환
convert.to.lambda.expression=람다 식으로 변환
convert.to.lateinit.var=lateinit var로 변환
convert.to.lazy.property=lazy 프로퍼티로 변환
convert.to.notnull.delegate=notNull 위임으로 변환합니다.
convert.to.nullable.type=null 가능 타입으로 변환
convert.to.nullable.type.fix.text=null 가능 유형으로 변환합니다.
convert.to.nullable.var=null 가능 var로 변환
convert.to.object.declaration=객체 선언으로 변환
convert.to.ordinary.property=일반 프로퍼티로 변환
convert.to.ordinary.string.literal=일반 문자열 리터럴로 변환
convert.to.primary.constructor=기본 생성자로 변환
convert.to.primary.constructor.before.text=보조 생성자를 기본 생성자로 변환해야 합니다
convert.to.raw.string.literal=원시 문자열 리터럴로 변환
convert.to.sealed.class=봉인된 클래스로 변환
convert.to.secondary.constructor=보조 생성자로 변환
convert.to.trim.indent='trimIndent()' 호출로 변환
convert.to.trim.margin='trimMargin()' 호출로 변환
convert.to.unicode.escape=유니코드 이스케이프로 변환
convert.to.unsafe.cast=안전하지 않은 형 변환으로 변환
convert.to.unsafecast.call=unsafeCast() 호출로 변환
convert.to.vararg.parameter=vararg 매개변수로 변환
convert.too.long.character.literal.to.string=너무 긴 문자 리터럴을 문자열로 변환합니다.
convert.try.finally.to.use=try-finally를 .use()로 변환
convert.try.finally.to.use.before.text=try-finally를 'use()'로 바꿀 수 있습니다
copy.concatenation.text.to.clipboard=연결 텍스트를 클립보드에 복사
copy.method.of.data.class.is.called.without.named.arguments=데이터 클래스의 ''copy'' 메서드가 이름 지정된 인수 없이 호출됩니다.
copy.paste.reference.notification=Se agregaron {0} {0, choice,1\#import statement|2\#import statement}. <p><span><a href\=''show''> Revise las declaraciones de importación agregadas....</ A ></span>
copy.paste.resolve.references=Resolver referencias pegadas
copy.text.adding.imports=Añadiendo declaraciones de importación...
copy.text.clipboard.content.seems.to.be.java.code.do.you.want.to.convert.it.to.kotlin=El contenido del portapapeles parece ser código Java. ¿Le gustaría convertir a Kotlin?
copy.text.convert.java.to.kotlin.title=Java를 Kotlin으로 변환
copy.text.copied.kotlin.code=Código Kotlin copiado
copy.text.resolving.references=Resolviendo referencias...
copy.title.convert.code.from.java=Convertir código en Java
could.be.replaced.with.size=''size''로 바꿀수 있습니다.
could.be.replaced.with.unboxed.first=박싱되지 않은 ''first''로 바꿀수 있습니다.
could.be.replaced.with.unboxed.last=박싱되지 않은 ''last''로 바꿀수 있습니다.
create.0={0} 생성
create.0.1={0} ''{1}'' 생성합니다.
create.0.in.1={1}에서 {0}을(를) 생성합니다.
create.actual.0.for.module.1.2=모듈 {1}에 대한 실제 {0}을(를) 생성합니다({2}).
create.expected.0.in.common.module.1=일반 모듈 {1}에서 필요한 {0}을(를) 생성합니다.
create.file=Crear archivo
create.kotlin.file=Kotlin 파일 생성
create.kotlin.subclass=Kotlin 하위 클래스 생성
create.label=라벨을 생성합니다.
create.label.0=라벨 {0}@을(를) 생성합니다.
create.package.0=패키지 ''{0}''을(를) 생성합니다.
create.parameter.0=매개변수 ''{0}'' 생성
create.property.0.as.constructor.parameter=프로퍼티 ''{0}''을(를) 생성자 매개변수로서 생성합니다.
create.subclass=하위 클래스 생성
create.test=테스트 생성
dangerous.array.comparison=위험한 배열 비교
declaration.has.type.inferred.from.a.platform.call.which.can.lead.to.unchecked.nullability.issues=선언에 플랫폼 호츨에서 추론된 유형이 있어, 확인되지 않은 null 값 가능성 문제로 이어질 수 있습니다. 유형을 명시적으로 null 가능 또는 null 불가능으로 지정합니다.
declarations.are.used.outside.of.selected.code.fragment=다음 선언은 선택한 코드 조각 외부에서 사용됩니다.
declarations.will.move.out.of.scope=다음 선언은 추출된 함수 본문의 외부에서 사용할 수 없습니다.
deferred.result.is.never.used=연기된 결과가 한 번도 사용되지 않습니다.
delegating.to.var.property.does.not.take.its.changes.into.account=''var'' 속성으로 위임해도 해당 변경이 고려되지 않습니다.
delete.0={0} 삭제
delete.equals.and.hash.code.fix.text=equals()/hashCode()를 삭제합니다.
delete.fix.family.name=화살표 제거
delete.redundant.extension.property=중복 확장 프로퍼티를 삭제합니다.
delete.with.usage.search=삭제(사용 위치 검색 사용)
demorgan.law=드모르간 법칙
deprecated.annotation.without.replacewith.argument=''replaceWith'' 인수가 없는 @Deprecated 어노테이션
description.a.reference.to.extracted.type.parameter=추출된 유형 매개변수에 대한 참조
destination.not.found.for.package.0=패키지에 ''{0}''의 대상을 찾을 수 없습니다.
diagnostic.name.should.be.replaced.by.the.new.one=진단 이름을 새 이름으로 바꿔야 합니다.
dialog.import.on.paste.title3=Seleccione la importación para eliminar
dialog.message.incorrect.target.path.directory.not.specified=잘못된 대상 경로입니다. 디렉터리가 지정되지 않았습니다.
dialog.message.none.elements.were.selected=선택된 요소가 없습니다
dialog.progress.collect.members.to.generate=멤버 수집...
dialog.title.resolving.inheritable.status=상속 가능한 상태로 해결 중…
difference.found.for.data.class.0.found.1.2=데이터 클래스 {0}에 대해 발견된 차이점이 없습니다. {1}개의 사용 위치가 발견되었으나 필요한 것은 {2}개입니다.
disable.tremble.dumb.mode=Tremble Dumb 모드 비활성화
do.you.want.to.delete.expected.declaration.together.with.all.related.actual.ones=기대되는 선언 및 모든 관련된 실제 선언을 삭제하시겠어요?
do.you.want.to.delete.this.parameter.in.expected.declaration.and.all.related.actual.ones=기대되는 선언 및 모든 관련된 실제 선언에서 이 매개변수를 삭제하시겠어요?
do.you.want.to.make.new.extension.an.expected.declaration=새로운 확장을 기대 선언으로 만드시겠어요?
doesn.t.match.regex.0=정규식 ''{0}''와(과) 일치하지 않습니다.
don.t.show.this.dialog.next.time=다음에는 이 대화상자를 표시 안 함(&D)
double.negation.fix.text=중복 부정을 제거합니다.
editor.checkbox.title.auto.add.val.keyword.to.data.value.class.constructor.parameters=데이터/값 클래스 생성자 매개변수에 'val' 키워드 자동 추가
editor.checkbox.title.convert.pasted.java.code.to.kotlin=Convertir código Java pegado a Kotlin
editor.checkbox.title.don.t.show.java.to.kotlin.conversion.dialog.on.paste=No mostrar en el diálogo de conversión de Java a Kotlin al pegar
editor.title.kotlin=Kotlin
enable.tremble.dumb.mode=Tremble Dumb 모드 활성화
enter.package.fqname=패키지 FqName을 입력합니다.
enum.entry=열거형 항목
equality.check.0.be.used.instead.of.elvis.for.nullable.boolean.check=elvis 대신 상등 검사 {0}을(를) null 가능한 부울 검사에 사용
equality.check.with.nan.should.be.replaced.with.isnan=NaN과의 상등 검사를 ''isNaN()''으로 바꿔야 합니다.
equals.between.objects.of.inconvertible.types=변환할 수 없는 유형의 객체 간의 ''equals()''
equals.hashcode.in.object.declaration=객체 선언의 equals()/hashCode()
equals.should.take.any.as.its.argument=''equals''가 ''Any?''를 인수로 취해야 합니다.
equals.text=''equals()'' 생성
error.cant.refactor.vararg.functions=변수 인수가 있는 함수는 리팩터링할 수 없습니다.
error.context.getter.or.setter=이 컨텍스트는 명시적 getter/setter가 있는 프로퍼티에만 해당됩니다. (파일 형식을 Kotlin으로 설정)
error.expected.an.expression=표현식이 필요합니다
error.expected.catch.or.finally='catch' 또는 'finally'가 필요합니다
error.hint.cannot.modify.0.declaration.from.1.file={1}'' 파일의 ''{0}'' 선언을 변경할 수 없습니다
error.hint.library.declarations.cannot.be.changed=라이브러리 선언은 변경할 수 없습니다
error.hint.text.cannot.inline.0.from.a.decompiled.file=디컴파일된 파일의 ''{0}''은(는) 인라인화할 수 없습니다.
error.param.can.t.be.null.at.index.0.in.1=매개변수는 {1}의 색인 {0}에서 null일 수 없습니다.
error.text.can.t.change.signature.of.method={0} 메서드의 시그니처를 변경할 수 없습니다.
error.text.can.t.copy.class.to.the.containing.file=포함 파일에 클래스를 복사할 수 없습니다.
error.text.can.t.generate.0.1={0}을(를) 생성할 수 없습니다. {1}
error.text.can.t.introduce.constant.for.this.expression=이 표현식에 대해 상수를 삽입할 수 없습니다
error.text.can.t.introduce.constant.for.this.expression.because.not.constant=비상수 표현식에 대해 상수를 삽입할 수 없습니다
error.text.can.t.introduce.lambda.parameter.for.this.expression=이 표현식에 대한 람다 매개변수를 삽입할 수 없습니다.
error.text.can.t.introduce.property.for.this.expression=이 표현식에 대한 프로퍼티를 삽입할 수 없습니다.
error.text.different.name.expected=다른 이름이 기대됩니다.
error.text.expression.has.no.type=표현식에 유형이 없습니다.
error.text.extraction.from.expect.class.is.not.yet.supported=expect 클래스에서 추출하는 것은 아직 지원되지 않습니다.
error.text.extraction.from.non.jvm.class.is.not.yet.supported=JVM이 아닌 클래스에서 추출하는 것은 아직 지원되지 않습니다.
error.text.inline.function.is.not.supported.for.functions.with.multiple.return.statements=함수 인라인화는 여러 반환문이 있는 함수에는 지원되지 않습니다.
error.text.inline.function.is.not.supported.for.functions.with.return.statements.not.at.the.end.of.the.body=함수 인라인화는 반환문이 본문 끝에 없는 함수에는 지원되지 않습니다.
error.text.interface.cannot.be.extracted.from.an.annotation.class=인터페이스는 어노테이션 클래스에서 추출할 수 없습니다
error.text.introduce.parameter.is.not.available.for.default.value=매개변수 삽입은 디폴트 값에 사용할 수 없습니다.
error.text.introduce.parameter.is.not.available.inside.of.annotation.entries=매개변수 삽입은 어노테이션 항목의 내부에서 사용할 수 없습니다
error.text.invalid.name=잘못된 이름
error.text.invalid.parameter.name=잘못된 매개변수 이름
error.text.invalid.parameter.type=잘못된 매개변수 유형
error.text.invalid.receiver.type=잘못된 리시버 유형
error.text.invalid.return.type=잘못된 반환 유형
error.text.no.type.to.refactor=리팩터링할 유형이 없습니다.
error.text.refactoring.is.not.applicable.in.the.current.context=현재 컨텍스트에서는 리팩터링을 적용할 수 없습니다.
error.text.superclass.cannot.be.extracted.from.an.annotation.class=상위 클래스는 어노테이션 클래스에서 추출할 수 없습니다
error.text.type.reference.is.expected=유형 참조가 필요합니다.
error.types.in.generated.function=잘못된 반환 유형이 있는 함수는 생성할 수 없습니다.
error.wrong.caret.position.function.or.constructor.name=캐럿이 리팩터링할 함수 또는 생성자 이름의 위치에 있어야 합니다.
evaluate.compile.time.expression=compile-time 표현식 평가
excluded.methods=제외된 메서드
existing.backing.field.is.not.assigned.by.the.setter=기존 백킹 필드가 setter로 대입되지 않았습니다
expand.boolean.expression.to.if.else=bool 표현식을 ''if else'' 문으로 확장
experimental.coroutines.usages.are.obsolete.since.1.3=실험적 코루틴 사용 위치는 1.3부터 지원 중단됩니다.
explicit.0.call=명시적인 ''{0}'' 호출
explicit.this.expression.fix.family.name=중복 ''{0}'' 제거
explicitly.given.type.is.redundant.here=명시적으로 지정된 유형이 여기에서 중복됩니다.
expression=표현식
external.interface.contains.non.nullable.property.name=외부 인터페이스에 null이 불가능한 부울 프로퍼티가 있습니다
external.interface.contains.val.property.name=외부 인터페이스에 val 프로퍼티가 있습니다
extract.function=함수 추출
extract.new.parameter.name.receiver=<리시버>
failed.to.create.a.wrapper.for.inlining.to.kotlin=Kotlin로 인라인화할 래퍼를 생성하지 못했습니다
family.name.update.usages.on.declarations.cut.paste=선언 잘라내기/붙여넣기 시 사용 위치 업데이트
file.0.already.exists.but.does.not.correspond.to.kotlin.file=파일 {0}이(가) 이미 존재하지만 Kotlin 파일에 해당하지 않습니다.
file.lines=파일 줄
files.to.visit=참조할 파일
find.declaration.constructor.usages.checkbox=생성자 사용 위치(&C)
find.declaration.derived.classes.checkbox=파생 클래스(&D)
find.declaration.derived.interfaces.checkbox=파생 인터페이스(&I)
find.declaration.functions.usages.checkbox=함수 사용 위치(&F)
find.declaration.implementing.methods.checkbox=함수 구현(&I)
find.declaration.implementing.properties.checkbox=프로퍼티 구현(&I)
find.declaration.include.overloaded.methods.checkbox=오버로드된 함수 및 확장자 포함(&V)
find.declaration.overriding.methods.checkbox=함수 재정의(&R)
find.declaration.overriding.properties.checkbox=프로퍼티 재정의(&R)
find.declaration.properties.usages.checkbox=프로퍼티 사용 위치(&P)
find.declaration.property.readers.checkbox=리더
find.declaration.property.writers.checkbox=라이터
find.usages.checkbox.name.expected.classes=필요 클래스
find.usages.checkbox.name.expected.functions=필요 함수
find.usages.checkbox.name.expected.properties=필요 프로퍼티
find.usages.checkbox.text.fast.data.class.component.search=빠른 데이터 클래스 구성 요소 검색
find.usages.class=클래스
find.usages.class.name.anonymous=익명
find.usages.companion.object=컴패니언 객체
find.usages.constructor=생성자
find.usages.facade.class=퍼사드 클래스
find.usages.for.property=프로퍼티의 {0}
find.usages.function=함수
find.usages.getter=getter
find.usages.import.alias=import 문 별칭
find.usages.interface=인터페이스
find.usages.label=라벨
find.usages.lambda=람다
find.usages.object=객체
find.usages.parameter=매개 변수
find.usages.prepare.dialog.progress=대화 상자 준비
find.usages.progress.text.declaration.superMethods=Resolviendo el método principal...
find.usages.property=프로퍼티
find.usages.property.accessor=프로퍼티 접근자
find.usages.setter=setter
find.usages.text.find.usages.for.data.class.components.and.destruction.declarations=<p>데이터 클래스 구성 요소 및 구조 분해 선언의 사용 위치 검색이<br/> <a href="{0}">한 번 비활성화</a>되었거나 <a href="{1}">프로젝트에서 비활성화</a>되었을 수 있습니다.</p>
find.usages.tool.tip.text.disable.search.for.data.class.components.and.destruction.declarations.project.wide.setting=데이터 클래스 구성 요소 및 구조 분해 선언에 대한 검색을 비활성화합니다(프로젝트 전체 설정).
find.usages.type.alias=유형 별칭
find.usages.type.callable.reference=호출 가능한 참조
find.usages.type.class.object=중첩된 클래스/객체
find.usages.type.companion.object=컴패니언 객체
find.usages.type.constructor.delegation.reference=생성자 위임 참조
find.usages.type.delegate=위임
find.usages.type.extension.receiver.type=확장 리시버 유형
find.usages.type.function.call=함수 호출
find.usages.type.function.return.type=함수 반환 유형
find.usages.type.implicit.get=묵시적 'get'
find.usages.type.implicit.invoke=묵시적 'invoke'
find.usages.type.implicit.iteration=묵시적 반복
find.usages.type.implicit.set=묵시적 'set'
find.usages.type.is='is' 연산의 타깃 유형
find.usages.type.named.argument=이름 지정된 인수
find.usages.type.nonLocal.property.type=클래스/객체 프로퍼티 유형
find.usages.type.packageDirective=패키지 지시문
find.usages.type.packageMemberAccess=패키지 멤버 액세스
find.usages.type.parameter=타입 매개변수
find.usages.type.property.delegation=프로퍼티 위임
find.usages.type.receiver=리시버
find.usages.type.super.type.qualifier=상위 유형 한정자
find.usages.type.superType=상위 유형
find.usages.type.type.alias=유형 별칭
find.usages.type.type.constraint=유형 제약 조건
find.usages.type.value.parameter.type=매개변수 타입
find.usages.variable=변수
fix.add.annotation.family=Agregar anotación
fix.add.annotation.target=Agregar destino de anotación
fix.add.annotation.text.constructor=생성자에 ''@{0}'' 어노테이션 추가
fix.add.annotation.text.containing.class='@{0} '' Agregar anotación a la clase contenedora ''{1}'
fix.add.annotation.text.containing.file=포함하는 파일 ''{1}''에 ''@{0}'' 어노테이션 추가
fix.add.annotation.text.declaration='@{0} '' Agregar anotación a ''{1}'
fix.add.annotation.text.self=''@{0} '' agregar anotación
fix.add.annotation.with.arguments.text.copy=''{1}''에서 ''{2}''(으)로 ''@{0} 어노테이션 복사
fix.add.argument.name.family=Agregar nombre al argumento
fix.add.argument.name.step.choose.parameter.title=매개변수 이름 선택
fix.add.argument.name.text=Agregar nombre al argumento ''{0}''.
fix.add.argument.name.text.generic=Agregar nombre al argumento...
fix.add.array.of.type.family='' arrayOf '' Agregar contenedor
fix.add.array.of.type.text=Agregue el contenedor {0}.
fix.add.constructor.parameter=Agregar parámetro de constructor ''{0}''.
fix.add.default.constructor='' esperar '' Agregar un constructor predeterminado a la clase.
fix.add.else.branch.when=Agregar otra rama.
fix.add.eq.eq.true=''\=\= true'' 추가
fix.add.exception.to.throws=''{0}'' 추가
fix.add.explicit.import=Agregar declaración de importación explícita.
fix.add.function.body=Agregar cuerpo de función.
fix.add.function.parameters.add.parameter.constructor={0, number, ordinal} th {1, choice,1\#parameter|2\#parameter} add to constructor ''{2}'' do.
fix.add.function.parameters.add.parameter.function={0, number, ordinal} th {1, choice,1\#parameter|2\#parameter} add to function ''{2}'' do.
fix.add.function.parameters.add.parameter.generic.constructor={0, choice,1\#parameters|2\#parameters} to constructor ''{1}''
fix.add.function.parameters.add.parameter.generic.function={0, choice,1\#parameter|2\#parameter} to function ''{1}''
fix.add.function.parameters.change.signature.constructor=Cambiar la firma del constructor ''{0}''
fix.add.function.parameters.change.signature.function=Cambiar la firma de la función ''{0}''
fix.add.generic.upperbound.family=Agregar límite principal genérico
fix.add.generic.upperbound.text=Agregar ''{0}'' como límite superior de ''{1}''.
fix.add.is.to.when=Agregue '' es '' antes de ''{0}''.
fix.add.loop.label.text=Agregue ''{0}'' a {1}.
fix.add.loop.label.text.generic=Agregar etiqueta al bucle.
fix.add.member.supertype.add.to=''{0}''을(를) ''{1}''에 추가합니다
fix.add.member.supertype.choose.type=타입 선택
fix.add.member.supertype.family={0}을(를) 상위 타입에 추가
fix.add.member.supertype.progress={0}을(를) 타입에 추가
fix.add.member.supertype.text={0}을(를) 상위 타입에 추가…
fix.add.modifier.family=Agregar modificador
fix.add.modifier.inline.function.family=Agregar '' en línea '' a la función
fix.add.modifier.inline.function.text=Agregar '' en línea '' a la función ''{0}''.
fix.add.modifier.inline.parameter.family=Agregue ''{0}'' al parámetro.
fix.add.modifier.inline.parameter.text=Agregue ''{0}'' al parámetro ''{1}''.
fix.add.modifier.text=Hacer {0} ''{1}''
fix.add.modifier.text.generic=''{0}'' agregar modificador
fix.add.new.line.after.annotations=Agregar una nueva línea después de las anotaciones
fix.add.remaining.branches=Agregar ramas restantes.
fix.add.remaining.branches.with.star.import=* Agregue las ramas restantes con declaraciones de importación.
fix.add.return.before.expression=Agregar '' return '' antes de la expresión.
fix.add.return.before.lambda.expression=Agregar '' ejecutar '' antes de la expresión lambda.
fix.add.return.last.expression=Agregue '' return '' a la última expresión.
fix.add.semicolon.lambda.expression=Terminar la llamada anterior con punto y coma.
fix.add.spread.operator.after.sam=Agregue el operador de propagación antes de la matriz cuando pase como '' vararg ''.
fix.add.star.projection.family=Agregar proyección de estrella
fix.add.star.projection.text=Agregue ''{0}''.
fix.add.suspend.modifier.function=suspender {0}
fix.add.suspend.modifier.function.generic=Pausar la función de inclusión
fix.add.suspend.modifier.receiver=Tipo de pausa {0}.
fix.add.suspend.modifier.receiver.generic=Pausar tipo de receptor.
fix.add.tostring.call.family=agregar llamada '' toString() ''
fix.add.tostring.call.text=Agregar una llamada a '' toString() ''
fix.add.tostring.call.text.safe=Agregar llamada segura ''? .toString() ''.
fix.add.type.annotation.family=타입 어노테이션 추가
fix.add.type.annotation.text=타입 ''{0}''을(를) 매개변수 ''{1}''에 추가합니다
fix.assign.to.property=Asignar a propiedad.
fix.cast.expression.family=Convertir expresión
fix.cast.expression.text=Transmitir expresión ''{0}'' a ''{1}''.
fix.change.accessor.family=Cambiar tipo de acceso
fix.change.accessor.getter=cambia el tipo de captador a {0}
fix.change.accessor.setter.parameter=cambiar el tipo de parámetro del setter a {0}
fix.change.jvm.name=JVM 이름 변경
fix.change.mutability.change.to.val=Cambiar ''{0}'' a val.
fix.change.object.to.class=' objeto '' a '' clase '
fix.change.package.family=Cambiar el paquete en el archivo para que coincida con el directorio
fix.change.package.text=Cambie el paquete en el archivo a {0}.
fix.change.progress.analyzing.class.hierarchy=Analizando la jerarquía de clases…
fix.change.progress.looking.inheritors=Buscando herederos de la clase {0}…
fix.change.return.type.command.function=함수 ''{1}''의 매개변수 ''{0}'' 타입을 ''{2}''(으)로 변경
fix.change.return.type.command.primary.constructor=클래스 ''{1}''의 기본 생성자의 매개변수 ''{0}'' 타입을 ''{2}''(으)로 변경
fix.change.return.type.family=Tipo de cambio
fix.change.return.type.lambda=Cambiar el tipo de retorno de la expresión lambda a {0}.
fix.change.return.type.presentation.accessed={0} accedido
fix.change.return.type.presentation.base=base {0}
fix.change.return.type.presentation.called=Llamado {0}
fix.change.return.type.presentation.called.function=Función llamada
fix.change.return.type.presentation.enclosing=Incluyendo {0}
fix.change.return.type.presentation.enclosing.function=Función de cierre
fix.change.return.type.presentation.function=función {0}
fix.change.return.type.presentation.property=propiedad {0}
fix.change.return.type.remove.explicit.return.type=Eliminar un tipo de retorno especificado explícitamente.
fix.change.return.type.remove.explicit.return.type.of={0}의 명시적으로 지정된 반환 타입을 제거합니다.
fix.change.return.type.return.type.text=Cambiar el tipo de retorno a ''{0}''.
fix.change.return.type.return.type.text.of=Cambiar el tipo de retorno de {0} a ''{1}''
fix.change.return.type.text.function=Cambiar parámetro ''{0}'' tipo de función ''{1}'' a ''{2}''.
fix.change.return.type.text.primary.constructor=Cambiar parámetro ''{0}'' tipo de constructor primario de clase ''{1}'' a ''{2}''.
fix.change.return.type.type.text=Cambiar tipo a ''{0}''
fix.change.return.type.type.text.of=Cambiar el tipo de {0} a ''{1}''
fix.change.signature.error=<error>
fix.change.signature.family=Cambiar la firma de la función/constructor
fix.change.signature.function.family=Cambiar la firma de la función
fix.change.signature.function.popup.title=Seleccionar firma
fix.change.signature.function.text=Cambiar la firma de la función a ''{0}''.
fix.change.signature.function.text.generic=Cambiar la firma de la función...
fix.change.signature.lambda=Cambiar la firma de la expresión lambda
fix.change.signature.lambda.command=람다 식의 시그니처 변경
fix.change.signature.remove.parameter=Eliminar parámetro ''{0}''.
fix.change.signature.remove.parameter.command=매개변수 ''{0}'' 제거
fix.change.signature.unavailable=<no disponible>
fix.change.signature.unnamed.parameter=Parámetros
fix.change.suspend.hierarchy.add=Agrega el modificador '' suspender '' a todas las funciones en la jerarquía.
fix.change.suspend.hierarchy.remove=Elimina el modificador '' suspender '' de todas las funciones de la jerarquía.
fix.change.to.function.invocation=Cambio a la invocación de función.
fix.change.to.labeled.return.family=Cambiar para devolver con etiqueta
fix.change.to.labeled.return.text=Cambiar a ''{0}''
fix.change.to.mutable.type=Cambiar el tipo a {0}.
fix.change.to.property.access.family.change=Cambiar al acceso a la propiedad
fix.change.to.property.access.family.remove=Eliminar llamada
fix.change.to.star.projection.family=Cambiar a proyección de estrellas
fix.change.to.star.projection.text=Cambiar tipo de argumento a {0}.
fix.change.to.use.spread.operator.family=Cambiar para usar el operador de propagación
fix.change.to.use.spread.operator.text='{0}'' a ''{1}'
fix.change.type.argument=Cambiar tipo de argumento a {0}.
fix.change.type.family=Tipo de cambio
fix.change.type.text=Tipo de cambio de ''{0}'' a ''{1}''.
fix.convert.to.is.array.of.call='isArrayOf' 호출로 변환
fix.create.declaration.error=No se pudo crear {0}. {1}
fix.create.declaration.error.inaccessible.type=Tipo inaccesible
fix.create.declaration.error.some.types.inaccessible=Tipos no accesibles\:
fix.create.expect.actual=Cree una declaración wait/actual.
fix.create.from.usage.dialog.title=Crear desde la ubicación de uso
fix.create.from.usage.family=Crear desde la ubicación de uso
fix.create.from.usage.local.variable=Crear variable local ''{0}''.
fix.create.missing.actual.declarations=누락된 실제 선언 추가
fix.create.missing.actual.declarations.title=누락된 실제 선언 추가
fix.create.missing.actual.members=Agregar miembros reales que faltan.
fix.import=Importar
fix.import.exclude=Excluir ''{0}'' de la importación automática.
fix.import.kind.0.name.1.2={0} ''{1}''{2,choice,0#|1# 및 그 외 {2}개} 가져오기
fix.import.kind.0.name.1.and.name.2={0} ''{1}'', ''{2}'' 가져오기
fix.import.kind.component.functions=Funciones de los componentes
fix.import.kind.delegate.accessors=Acceso delegado.
fix.import.question={0}을(를) 가져오시겠어요?
fix.insert.delegation.call=Insertar llamada '' {0}()''
fix.introduce.non.null.assertion=Agregar llamadas de aserción no nulas (\! \!).
fix.make.data.class=Hacer ''{0}'' una clase de datos.
fix.make.field.public=필드 ''{0}''을(를) public으로 만들기
fix.make.type.parameter.reified=Refinar {0} y en línea {1}.
fix.make.upperbound.not.nullable.any.text=''Any''를 {0}의 상한선으로 추가하여 null이 불가능하게 만들기
fix.make.upperbound.not.nullable.family=일반적인 유형 매개변수를 null이 불가하게 만들기
fix.make.upperbound.not.nullable.remove.nullability.text={0}의 상한선을 ''{1}''(으)로 변경하여 {0}을(를) null이 불가하게 만들기
fix.move.file.to.package.dir.name.text=소스 루트
fix.move.file.to.package.family=Mover el archivo al directorio donde coincide el paquete
fix.move.file.to.package.text=Mueva el archivo a {0}.
fix.move.to.sealed.family=계층 멤버를 해당 sealed 부모의 패키지/모듈로 이동
fix.move.to.sealed.text={0}을(를) {1}의 패키지/모듈로 이동
fix.move.typealias.to.top.level=유형 별칭을 최상위 수준으로 이동
fix.opt_in.annotation.family=옵트인 기능 사용 위치 어노테이션
fix.opt_in.migrate.experimental.annotation.remove=더는 사용되지 않는 '@Experimental' 어노테이션 제거
fix.opt_in.migrate.experimental.annotation.replace=더는 사용되지 않는 '@Experimental' 어노테이션을 '@RequiresOptIn'으로 대체
fix.opt_in.move.requirement.from.getter.to.property=''{0}'' 옵트인 요구사항을 getter에서 프로퍼티로 이동
fix.opt_in.move.requirement.from.value.parameter.to.property=''{0}'' 옵트인 요구사항을 값 매개변수에서 프로퍼티로 이동
fix.opt_in.remove.all.forbidden.targets=금지된 옵트인 어노테이션 타깃 제거
fix.opt_in.remove.forbidden.retention=금지된 옵트인 어노테이션 보관 항목 제거
fix.opt_in.text.propagate.constructor=''{0}'' 옵트인 요구사항을 ''{0}''(으)로 전달
fix.opt_in.text.propagate.containing.class=''{0}'' 옵트인 요구사항을 포함하는 클래스 ''{1}''(으)로 전달
fix.opt_in.text.propagate.declaration=''{0}'' 옵트인 요구사항을 ''{1}''(으)로 전달
fix.opt_in.text.use.constructor=생성자에서 ''{0}'' 옵트인
fix.opt_in.text.use.containing.class=포함하는 클래스 ''{1}''에서 ''{0}'' 옵트인
fix.opt_in.text.use.containing.file=포함하는 파일인 ''{1}''에서 ''{0} 옵트인
fix.opt_in.text.use.declaration=''{1}''에서 ''{0}'' 옵트인
fix.potentially.broken.inheritance.message=이 변경사항은 잠재적으로 상속자에서 문제를 일으킬 수 있습니다.\n계속하시겠어요?
fix.potentially.broken.inheritance.title=잠재적으로 문제가 있는 상속
fix.remove.annotation.text=어노테이션 제거
fix.remove.argument.text=인수 제거
fix.remove.non.null.assertion=Eliminar aserciones innecesarias no nulas (\! \!)
fix.remove.redundant.star.text=중복 * 제거
fix.replace.annotation.family=어노테이션 바꾸기
fix.replace.annotation.text=어노테이션을 ''@{0}''(으)로 대체
fix.replace.with.assign.function.call=Reemplazar con la llamada ''{0}''.
fix.replace.with.declaring.java.class='declaringJavaClass'로 대체
fix.text=중복 세미콜론을 제거합니다.
fix.unused.receiver.parameter.remove=Eliminar parámetros duplicados del receptor.
fix.use.fully.qualified.call=완전히 정규화된 호출 사용
fix.with.asdynamic=''asDynamic''으로 수정합니다.
flatten.when.expression=''when'' 식 평면화
flip.0=Invertir ''{0}''
flip.binary.expression=이진 표현식 반전
flip.equals=Invertir ''equals''
floating.point.literal.precision.inspection=부동 소수점 리터럴은 요구된 정확도로 나타낼 수 없습니다
floating.point.literal.precision.inspection.display.name=부동 소수점 리터럴이 사용 가능한 정확도를 초과
foldable.if.then=접을 수 있는 if-then
following.expression.won.t.be.processed.since.refactoring.can.t.preserve.its.semantics.0=다음 표현식은 리팩터링에서 해당 의미를 유지할 수 없으므로 처리되지 않습니다. {0}
following.problems.are.found=다음 문제가 발견되었습니다.\n
for.0=''{0}''에 대한
for.api.stability.it.s.recommended.to.specify.explicitly.declaration.types=API 안정성을 위해 선언 유형을 명시적으로 지정하는 것이 좋습니다.
for.api.stability.it.s.recommended.to.specify.explicitly.public.protected.declaration.types=API 안정성을 위해 public 및 protected 선언 유형을 명시적으로 지정하는 것이 좋습니다.
for.loop.over.indices.could.be.replaced.with.loop.over.elements=색인에 대한 for 루프를 요소에 대한 루프로 바꿀수 있습니다.
formatter.button.text.use.import.with=Usando una declaración de importación con '' * ''
formatter.button.text.use.import.with.when.at.least=Usar declaraciones de importación con '' * '' cuando
formatter.button.text.use.single.name.import=Usar declaración de importación de nombre único
formatter.checkbox.text.insert.imports.for.nested.classes=Insertar declaraciones de importación para clases anidadas
formatter.checkbox.text.use.trailing.comma=Usar coma al final
formatter.settings.title=Configuración del formateador de Kotlin
formatter.text.names.used=\ Nombres utilizados
formatter.text.use.defaults.from=Usar valores predeterminados\:
formatter.title.after.colon.before.declaration.type=Después de dos puntos, antes del tipo de declaración
formatter.title.after.colon.in.new.type.definition=Después de dos puntos en la nueva definición de tipo
formatter.title.align.when.branches.in.columns=Alinear '' cuando '' se ramifica en columnas
formatter.title.around.arrow.in="when" alrededor de la flecha en la cláusula
formatter.title.around.arrow.in.function.types=Alrededor de flechas de tipos de funciones
formatter.title.around.when.branches.with=around branch '' when '' with {}
formatter.title.before.colon.after.declaration.name=Antes de los dos puntos, después del nombre de la declaración
formatter.title.before.colon.in.new.type.definition=Antes de los dos puntos en la nueva definición de tipo
formatter.title.before.declaration.with.comment.or.annotation=Antes de la declaración anotada o anotada
formatter.title.before.lambda.arrow=Antes de la flecha lambda
formatter.title.chained.function.calls=Llamar a funciones encadenadas
formatter.title.elvis.expressions=Expresiones de Elvis
formatter.title.expression.body.functions=Funciones del cuerpo de la expresión
formatter.title.function.annotations=Anotaciones de funciones
formatter.title.function.call.arguments=Argumentos de llamada a función
formatter.title.function.declaration.parameters=Parámetros de declaración de función
formatter.title.function.parentheses=Paréntesis de funciones
formatter.title.in.simple.one.line.methods=Un método simple de una línea
formatter.title.java.statics.and.enum.members=Miembros de enumeración y estática de Java
formatter.title.line.break.after.multiline.when.entry=여러 줄의 입력 이후 새로운 줄
formatter.title.load.save=Cargar/Guardar
formatter.title.other=Otro
formatter.title.property.annotations=Anotaciones de propiedad
formatter.title.put.left.brace.on.new.line=Coloque la llave izquierda en la nueva línea
formatter.title.range.operator=Operador de rango (..)
formatter.title.top.level.symbols=Símbolos principales
formatter.title.trailing.comma=Coma final
formatter.title.use.continuation.indent=연속 들여쓰기 사용
formatter.title.use.continuation.indent.in.conditions=조건에서 연속 들여쓰기 사용
formatter.title.when.parentheses=''when'' 소괄호
formatter.title.when.statements=''when'' 구문
function=함수
function.0=함수 ''{0}''
function.0.returning.1.without.the.corresponding='{3}''을(를) 반환하는 함수 ''{2}'' 없이 ''{1}''을(를) 반환하는 함수 ''{0}'
function.01=함수 "{0}"
function.name.is.invalid=함수 이름이 잘못되었습니다.
function.returning.0.with.a.name.that.does.not.end.with.1=이름이 {1}(으)로 끝나지 않는 {0}을(를) 반환하는 함수
function.should.have.operator.modifier=함수에 ''operator'' 제어자가 있어야 합니다.
generate.equals.and.hashcode.fix.text=equals() 및 hashCode() 생성
generate.identity.equals.fix.family.name=ID별로 equals 및 hashCode 생성
goto.super.chooser.class.title=Seleccione la clase o interfaz principal
goto.super.chooser.function.title=Seleccionar función principal
goto.super.chooser.property.title=Seleccionar propiedad principal
group.InternalKotlin.text=Kotlin 내부 액션
group.KotlinCompletionBenchmarkGroup.text=벤치마크 완성
group.KotlinInternalGroup.text=Kotlin
group.KotlinRefactoringTesting.text=Kotlin 리팩터링 테스트
group.KotlinToolsGroup.text=Kotlin
group.advanced.settings.kotlin=Kotlin
group.names.gradle=Gradle
group.names.java.interop.issues=Java 상호운용성 문제
group.names.kotlin=Kotlin
group.names.logging=기록 중
group.names.maven=Maven
group.names.migration=마이그레이션
group.names.naming.conventions=이름 생성 규칙
group.names.other.problems=기타 문제
group.names.probable.bugs=발생할 수 있는 버그
group.names.redundant.constructs=불필요한 구문
group.names.style.issues=스타일 문제
hash.code.text=''hashCode()'' 생성
hierarchy.legend.member.defined.in.superclass=멤버는 클래스가 아닌 상위 클래스에 정의되어 있습니다.
hierarchy.legend.member.is.defined.in.class=멤버는 클래스에 정의되어 있습니다.
hierarchy.legend.member.should.be.defined=클래스가 추상적이지 않으므로 멤버를 정의해야 합니다.
hierarchy.text.anonymous=[익명]
hierarchy.text.in=\ {0} 내
highlighter.action.text.go.to.actual.declarations=actual 선언으로 이동
highlighter.action.text.go.to.expected.declaration=expected 선언으로 이동
highlighter.action.text.go.to.implementations=구현으로 이동
highlighter.action.text.go.to.overridden.methods=재정의된 메서드로 이동
highlighter.action.text.go.to.overridden.properties=재정의된 프로퍼티로 이동
highlighter.action.text.go.to.subclasses=하위 클래스로 이동
highlighter.action.text.go.to.super.method=상위 메서드로 이동
highlighter.action.text.go.to.super.property=상위 프로퍼티로 이동
highlighter.descriptor.text.android.extensions.property=프로퍼티 및 변수//Android Extensions 통합 프로퍼티
highlighter.descriptor.text.annotation=어노테이션//어노테이션 이름
highlighter.descriptor.text.annotation.attribute.name=어노테이션//어노테이션 속성 이름
highlighter.descriptor.text.arrow=괄호 및 연산자//화살표
highlighter.descriptor.text.builtin.annotation=키워드//제어자
highlighter.descriptor.text.builtin.keyword=키워드//키워드
highlighter.descriptor.text.builtin.keyword.val=키워드//''val''
highlighter.descriptor.text.builtin.keyword.var=키워드//''var''
highlighter.descriptor.text.captured.variable=프로퍼티 및 변수//클로저에서 캡처된 변수 및 값
highlighter.descriptor.text.closure.braces=괄호 및 연산자//람다 식 괄호 및 화살표
highlighter.descriptor.text.colon=괄호 및 연산자//콜론
highlighter.descriptor.text.constructor.call=함수//생성자 호출
highlighter.descriptor.text.double.colon=괄호 및 연산자//이중 콜론
highlighter.descriptor.text.dynamic.fun.call=함수//동적 함수 호출
highlighter.descriptor.text.dynamic.property=프로퍼티 및 변수//동적 프로퍼티
highlighter.descriptor.text.enum=클래스 및 인터페이스//열거형
highlighter.descriptor.text.enumEntry=클래스 및 인터페이스//열거형 항목
highlighter.descriptor.text.exclexcl=괄호 및 연산자//null이 아닌 어설션
highlighter.descriptor.text.extension.fun.call=함수//확장 함수 호출
highlighter.descriptor.text.extension.property=프로퍼티 및 변수//확장 프로퍼티
highlighter.descriptor.text.field=프로퍼티 및 변수//백킹 필드 변수
highlighter.descriptor.text.fun=함수//함수 선언
highlighter.descriptor.text.fun.call=함수//함수 호출
highlighter.descriptor.text.instance.property=프로퍼티 및 변수//인스턴스 프로퍼티
highlighter.descriptor.text.instance.property.custom.property.declaration=프로퍼티 및 변수//사용자 지정 프로퍼티 선언이 있는 인스턴스 프로퍼티
highlighter.descriptor.text.it=매개변수//람다 식 디폴트 매개변수
highlighter.descriptor.text.kdoc.comment=주석//KDoc//KDoc 주석
highlighter.descriptor.text.kdoc.tag=주석//KDoc//KDoc 태그
highlighter.descriptor.text.kdoc.value=주석//KDoc//KDoc 태그 내 링크
highlighter.descriptor.text.label=라벨
highlighter.descriptor.text.local.variable=프로퍼티 및 변수//지역 변수 또는 값
highlighter.descriptor.text.named.argument=이름 지정된 인수
highlighter.descriptor.text.object=클래스 및 인터페이스//객체
highlighter.descriptor.text.package.fun.call=함수//패키지 수준 함수 호출
highlighter.descriptor.text.package.property=프로퍼티 및 변수//패키지 수준 프로퍼티
highlighter.descriptor.text.package.property.custom.property.declaration=프로퍼티 및 변수//사용자 지정 프로퍼티 선언이 있는 패키지 수준 프로퍼티
highlighter.descriptor.text.quest=괄호 및 연산자//유형 null 값 가능성 마커
highlighter.descriptor.text.safe.access=괄호 및 연산자//안전한 액세스 마침표
highlighter.descriptor.text.smart.cast=스마트 캐스트//스마트 캐스트 값
highlighter.descriptor.text.smart.cast.receiver=스마트 캐스트//스마트 캐스트 묵시적 리시버
highlighter.descriptor.text.smart.constant=스마트 캐스트//스마트 상수
highlighter.descriptor.text.string.escape=문자열// 문자열 및 템플릿 괄호 내 이스케이프
highlighter.descriptor.text.suspend.fun.call=함수//함수 호출 일시 중지
highlighter.descriptor.text.synthetic.extension.property=프로퍼티 및 변수//통합 확장 프로퍼티
highlighter.descriptor.text.typeAlias=클래스 및 인터페이스//유형 별칭
highlighter.descriptor.text.var=프로퍼티 및 변수//Var(가변 변수, 매개변수 또는 프로퍼티)
highlighter.descriptor.text.variable.as.function.call=프로퍼티 및 변수//함수 호출로서의 변수
highlighter.descriptor.text.variable.as.function.like.call=프로퍼티 및 변수//함수 같은 호출로서의 변수
highlighter.message.suspend.function.call=함수 호출 일시 중지
highlighter.message.suspending.iteration=반복 일시 중지
highlighter.name.dsl.markers=DSL 마커
highlighter.name.expect.actual.line.markers=Kotlin 'expect'//'actual' 줄 마커
highlighter.name.implemented.declaration=구현된 선언
highlighter.name.implementing.declaration=선언 구현
highlighter.name.kotlin.line.markers=Kotlin 줄 마커
highlighter.name.multiplatform.actual.declaration=멀티플랫폼 실제 선언
highlighter.name.multiplatform.expect.declaration=멀티플랫폼 기대 선언
highlighter.name.overridden.declaration=재정의된 선언
highlighter.name.overriding.declaration=선언 재정의
highlighter.notification.text.navigation.to.overriding.classes.is.not.possible.during.index.update=색인 업데이트 중에는 클래스를 재정의하는 탐색이 불가능합니다.
highlighter.prefix.text.has.actuals.in=실제 포함
highlighter.text.click.for.navigate={0}을(를) 클릭하여 탐색
highlighter.text.has.functional.implementations=함수 구현 포함
highlighter.text.implements=구현
highlighter.text.in=''{1}'' 내 {0}
highlighter.text.or.press=\ 또는 {0} 누르기
highlighter.text.overrides=재정의
highlighter.title.overriding.declarations.of={0}의 선언 재정의
highlighter.title.searching.for.overriding.declarations=재정의하는 선언 검색
highlighter.title.searching.for.overriding.methods=재정의하는 메서드 검색
highlighter.tool.tip.has.expect.declaration.in={0}개의 {1, choice, 0#모듈|1#모듈}에 기댓값이 있음
highlighter.tool.tip.marker.annotation.for.dsl=DSL에 대한 마커 어노테이션
highlighter.tool.tip.text.function=함수
highlighter.tool.tip.text.property=프로퍼티
highlighter.tool.tip.text.recursive.call=재귀적 호출
hint.text.no.expression.found=표현식을 찾을 수 없습니다
hints.codevision.implementations.format={0, choice,1\#1개 구현|2\#{0,number}개 구현}
hints.codevision.implementations.too_many.format={0,number}개 이상의 구현
hints.codevision.inheritors.format={0, choice,1\#1개 상속자|2\#{0,number}개 상속자}
hints.codevision.inheritors.to_many.format={0,number}개 이상의 상속자
hints.codevision.overrides.format={0, choice,1\#1개 재정의|2\#{0,number}개 재정의}
hints.codevision.overrides.to_many.format={0,number}개 이상의 재정의
hints.codevision.settings=설정...
hints.codevision.usages.format={0, choice,1\#1 referencia|2\#{0,number} referencia}
hints.codevision.usages.too_many.format={0,number}개 이상의 사용 위치
hints.ranges.greaterOrEqual=≥
hints.ranges.less=<
hints.ranges.lessOrEqual=≤
hints.settings.common.items=Mostrar sugerencias para\:
hints.settings.dont.show.lambda.receivers.parameters=묵시적 리시버 및 매개변수 힌트 표시 안 함
hints.settings.dont.show.lambda.return=반환 식 힌트 표시 안 함
hints.settings.dont.show.ranges=범위 힌트 표시 안 함
hints.settings.dont.show.suspending=중지 중인 호출 힌트 표시 안 함
hints.settings.dont.show.types.parameter=함수 매개변수 타입 힌트 표시 안 함
hints.settings.dont.show.types.property=프로퍼티 타입 힌트 표시 안 함
hints.settings.dont.show.types.return=함수 반환 타입 힌트 표시 안 함
hints.settings.dont.show.types.variable=지역 변수 타입 힌트 표시 안 함
hints.settings.lambda.receivers.parameters=Receptores y parámetros implícitos
hints.settings.lambda.return=expresión de retorno
hints.settings.lambdas=Lambdas
hints.settings.ranges=범위
hints.settings.show.lambda.receivers.parameters=묵시적 리시버 및 매개변수 힌트 표시
hints.settings.show.lambda.return=반환 식 힌트 표시
hints.settings.show.ranges=범위 힌트 표시
hints.settings.show.suspending=중지 중인 호출 힌트 표시
hints.settings.show.types.parameter=함수 매개변수 타입 힌트 표시
hints.settings.show.types.property=프로퍼티 타입 힌트 표시
hints.settings.show.types.return=함수 반환 타입 힌트 표시
hints.settings.show.types.variable=지역 변수 타입 힌트 표시
hints.settings.suspending=Suspender llamadas
hints.settings.types=Tipos
hints.settings.types.parameter=Tipos de parámetros de función
hints.settings.types.property=Tipos de propiedad
hints.settings.types.return=Tipo de retorno de función
hints.settings.types.variable=Tipos de variables locales
hints.settings.values.ranges=범위
hints.title.argument.name.enabled=Nombre del argumento
hints.title.codevision=Code Vision
hints.title.dont.show.argument.name.enabled=인수 이름 힌트 표시 안 함
hints.title.show.argument.name.enabled=인수 이름 힌트 표시
hints.types=타입 힌트
if.null.return.break.foldable.to=''?\:''로 접을 수 있는 If-Null return/break/...
if.then.foldable.to=''?\:''로 접을 수 있는 If-Then
implement.abstract.class=추상 클래스 구현
implement.abstract.function=추상 함수 구현
implement.abstract.member=추상 멤버 구현
implement.abstract.property=추상 프로퍼티 구현
implement.as.constructor.parameter=생성자 매개변수로서 구현
implement.interface=인터페이스 구현
implement.sealed.class=봉인된 클래스 구현
implicit.nothing.s=묵시적 Nothing
implicit.parameter.it.of.enclosing.lambda.is.shadowed=둘러싸는 람다의 묵시적 매개변수 ''it''이 그림자화되어 있습니다.
implicit.unsafe.cast.from.dynamic.to.0=동적에서 {0}(으)로의 묵시적인 (안전하지 않은) 형 변환
import.members.from.0=''{0}''의 멤버 가져오기
import.members.with=''*''가 있는 멤버 가져오기
import.optimizer.notification.text.unused.imports.not.found=사용되지 않는 import 문을 찾을 수 없습니다.
import.optimizer.progress.indicator.text.collect.imports.for={0}에 대한 import 문을 수집합니다.
import.optimizer.text.import={0, choice, 0\#import 문|2\#import 문}
import.optimizer.text.non.zero={0} {1} 제거{2, choice, 0\#|1\# 및 {2} {3} 추가}
import.optimizer.text.zero=재정렬된 import 문
import.order.button.text.add.package=패키지 추가
import.order.button.text.down=아래로
import.order.button.text.remove=제거
import.order.button.text.up=위로
import.progress.text.resolve.imports=모든 import 문 찾기…
import.text.all.alias.imports=모든 별칭 import 문
import.text.all.other.imports=기타 모든 import 문
import.text.import=import 문
in.class.0=\ 클래스 ''{0}'' 내
inaccessible.declaration=액세스할 수 없는 선언
incomplete.destructuring.declaration.text=불완전한 구조 분해 선언
incomplete.destructuring.fix.family.name=누락된 변수를 구조 분해 선언에 추가
indent.raw.string=원시 문자열 들여쓰기
index.is.not.used.in.the.loop.body=색인이 루프 본문에서 사용되고 있지 않습니다
inheritance.of.kotlin.sealed=Java {0,choice,0#인터페이스|1#클래스}는 Kotlin의 Sealed 계층 구조에 포함될 수 없습니다
initialize.with.constructor.parameter=생성자 매개변수로 초기화합니다.
inlay.kotlin.call.chains.hints=호출 체인에 대한 인레이 힌트 표시
inlay.kotlin.lambdas.hints=Lambda에 대한 인레이 힌트 표시
inlay.kotlin.lambdas.hints.hints.lambda.receivers.parameters=묵시적 리시버 및 매개변수에 대한 인레이 힌트 표시
inlay.kotlin.lambdas.hints.hints.lambda.return=반환 표현식에 대한 인레이 힌트 표시
inlay.kotlin.references.types.hints=타입에 대한 인레이 힌트 표시
inlay.kotlin.references.types.hints.hints.type.function.parameter=함수 매개변수 타입에 대한 인레이 힌트 표시
inlay.kotlin.references.types.hints.hints.type.function.return=함수 반환 타입에 대한 인레이 힌트 표시
inlay.kotlin.references.types.hints.hints.type.property=프로퍼티 타입에 대한 인레이 힌트 표시
inlay.kotlin.references.types.hints.hints.type.variable=지역 변수 타입에 대한 인레이 힌트 표시
inlay.kotlin.values.hints=값에 대한 인레이 힌트 표시
inlay.kotlin.values.hints.kotlin.values.ranges=범위에 대한 인레이 힌트 표시
inline.type.parameter=유형 매개변수를 인라인화합니다.
inline.variable=변수 인라인화
inline.when.argument='when' 인수 인라인화
insert.curly.braces.around.variable=중괄호를 변수 주위에 삽입
insert.explicit.delegation.call=명시적 위임 호출을 삽입합니다.
insert.number.conversion=숫자 변환을 삽입합니다.
inspection.add.conversion.call.display.name=1.9부터는 'Int'로부터 명시적으로 변환해야 합니다
inspection.add.operator.modifier.display.name=함수에 ''operator'' 제어자가 있어야 합니다.
inspection.add.variance.modifier.display.name=유형 매개변수가 ''in'' 또는 ''out'' 분산을 가질 수 있음
inspection.ambiguous.expression.when.branch.migration.display.name=1.7부터는 모호한 논리적 표현이 'when' 브랜치에 있음
inspection.array.in.data.class.display.name=데이터 클래스 내 배열 프로퍼티
inspection.boolean.literal.argument.display.name=매개변수 이름이 없는 부울 리터럴 인수
inspection.can.be.parameter.display.name=생성자 매개변수는 프로퍼티로 사용되지 않습니다.
inspection.can.be.primary.constructor.property.display.name=프로퍼티가 생성자 매개변수에 명시적으로 대입되어 있음
inspection.can.be.val.display.name=지역 ''var''은 한정되지 않으며 ''val''로서 선언 가능
inspection.can.sealed.subclass.be.object.display.name=상태도 없고 재정의된 equals도 없는 sealed 하위 클래스
inspection.cascade.if.display.name=캐스케이드 if를 when으로 바꾸기 가능
inspection.class.name.display.name=클래스 이름 지정 규칙
inspection.complex.redundant.let.display.name=인수 기반 ''let'' 호출 중복
inspection.conflicting.extension.property.display.name=확장 프로퍼티가 통합 프로퍼티와 충돌
inspection.const.property.name.display.name=Const 프로퍼티 이름 지정 규칙
inspection.constant.condition.if.display.name=''if'' 표현식의 조건은 상수임
inspection.control.flow.with.empty.body.display.name=본문이 비어 있는 제어 흐름
inspection.convert.argument.to.set.display.name=성능 향상을 위해 인수를 'Set'으로 변환할 수 있음
inspection.convert.call.chain.into.sequence.display.name=성능 향상을 위해 컬렉션의 호출 체인을 ''Sequence''로 변환할 수 있습니다.
inspection.convert.lambda.to.reference.display.name=함수 참조로 바꾸기 가능
inspection.convert.na.n.equality.display.name=''NaN''을 통한 상등 검사를 ''isNaN'' 호출로 변환
inspection.convert.object.to.data.object.display.name='object'를 'data object'로 변환
inspection.convert.pair.constructor.to.to.function.display.name=Pair 생성자를 ''to'' 함수로 변환
inspection.convert.reference.to.lambda.display.name=람다로 바꾸기 가능
inspection.convert.secondary.constructor.to.primary.display.name=기본 생성자로 변환
inspection.convert.to.string.template.display.name=문자열 템플릿으로 변환 가능한 문자열 연결
inspection.convert.try.finally.to.use.call.display.name=try/finally를 use() 호출로 변환
inspection.convert.two.comparisons.to.range.check.display.name=두 개의 비교 항목을 범위 검사로 변환해야 합니다.
inspection.copy.without.named.arguments.display.name=데이터 클래스의 ''copy'' 메서드가 이름 지정된 인수 없이 호출됩니다.
inspection.data.class.private.constructor.display.name=private 데이터 클래스 생성자가 ''copy'' 메서드를 통해 노출됨
inspection.deferred.is.result.display.name=Deferred를 직접 반환하는 함수
inspection.deferred.result.unused.display.name=연기된 결과가 한 번도 사용되지 않습니다.
inspection.delegation.to.var.property.display.name=''var'' 프로퍼티로 위임
inspection.deprecated.callable.add.replace.with.display.name=''replaceWith'' 인수가 없는 @Deprecated 어노테이션
inspection.deprecated.enum.declaring.class.property=지원 중단된 'Enum.declaringClass' 프로퍼티
inspection.deprecated.gradle.dependency.display.name=Gradle에서 사용되지 않는 라이브러리가 사용되었습니다
inspection.deprecated.inline.class.text=지원 중단된 인라인 클래스
inspection.deprecated.inline.classes.migration.display.name=인라인 클래스는 1.5부터 지원 중단됩니다
inspection.deprecated.maven.dependency.display.name=Se utilizó una biblioteca obsoleta en Maven
inspection.destructure.display.name=구조 분해 선언 사용
inspection.destructuring.wrong.name.display.name=구조 분해 선언의 변수가 잘못된 데이터 클래스 프로퍼티의 이름을 사용
inspection.different.kotlin.gradle.version.display.name=Kotlin Gradle과 IDE 플러그인 버전이 다릅니다
inspection.different.kotlin.maven.version.display.name=Maven과 IDE 플러그인 버전이 다릅니다
inspection.different.maven.stdlib.version.display.name=라이브러리와 Maven 플러그인 버전이 다릅니다
inspection.different.stdlib.gradle.version.display.name=Kotlin 라이브러리와 Gradle 플러그인 버전이 다릅니다
inspection.do.not.propagate.method.deprecation.through.overrides=1.9부터 재정의를 통해 메서드 중단 폐기를 전달하지 마세요
inspection.empty.range.display.name=endInclusive보다 큰 start가 있는 범위는 비어 있게 됨
inspection.enum.entry.name.display.name=열거형 항목 이름 지정 규칙
inspection.enum.values.method.soft.deprecate.in.java.display.name=Kotlin 1.9부터 'Enum.values()'를 'Enum.getEntries()'로 대체하는 것이 좋습니다
inspection.enum.values.method.soft.deprecate.migration.display.name=1.9부터 'Enum.values()'를 'Enum.entries'로 대체하는 것이 좋습니다
inspection.equals.or.hash.code.display.name=''equals()'' 및 ''hashCode()''가 쌍으로 되어 있지 않습니다
inspection.explicit.this.display.name=중복 명시적 this''
inspection.fake.jvm.field.constant.display.name=const가 아닌 Kotlin 프로퍼티가 Java 상수로 사용됨
inspection.fold.initializer.and.if.to.elvis.display.name=''?\:''로 접을 수 있는 If-Null return/break/...
inspection.for.each.parameter.not.used.display.name=반복 요소가 forEach에서 사용되지 않음
inspection.from.closed.range.migration.display.name=1.3부터 fromClosedRange()에 있는 MIN_VALUE 단계
inspection.function.name.display.name=함수 이름 지정 규칙
inspection.function.with.lambda.expression.body.display.name=''\={... }''이(가) 있는 함수 및 추론된 반환 유형
inspection.gradle.kotlinx.coroutines.deprecation.display.name=Gradle에서 호환되지 않는 kotlinx.coroutines 종속성은 Kotlin 1.3 이상에서 사용됩니다
inspection.has.platform.type.display.name=함수 또는 프로퍼티에 플랫폼 유형이 있음
inspection.if.then.to.elvis.display.name=''?\:''로 접을 수 있는 If-Then
inspection.if.then.to.safe.access.display.name=''?.''로 접을 수 있는 If-Then
inspection.implicit.nullable.nothing.type.display.name=묵시적 ''Nothing?'' 유형
inspection.implicit.this.action.name=명시적 'this' 추가
inspection.implicit.this.display.name=묵시적 ''this''
inspection.incomplete.destructuring.declaration.display.name=불완전한 구조 분해 선언
inspection.inconsistent.comment.for.java.parameter.display.name=Java 매개변수에 대한 일관되지 않은 주석
inspection.introduce.when.subject.display.name=인수 삽입으로 단순화 가능한 ''when''
inspection.java.collections.static.method.display.name=Java 컬렉션 static 메서드 호출을 Kotlin stdlib으로 바꾸기 가능
inspection.java.collections.static.method.on.immutable.list.display.name=불변 Kotlin 컬렉션''에서의 Java 변경자 호출
inspection.java.io.serializable.object.must.have.read.resolve.display.name=Serializable 객체는 반드시 'readResolve'를 구현해야 합니다
inspection.java.io.serializable.object.must.have.read.resolve.quick.fix.name='readResolve' 구현
inspection.java.io.serializable.object.must.have.read.resolve.warning=Serializable 객체는 반드시 'readResolve'를 구현해야 합니다
inspection.java.map.for.each.display.name=Java Map.forEach 메서드 호출을 Kotlin의 forEach로 바꿔야 합니다.
inspection.join.declaration.and.assignment.display.name=선언 및 할당 결합
inspection.k.doc.missing.documentation.display.name=public 선언의 KDoc 주석 누락
inspection.k.doc.unresolved.reference.display.name=KDoc 내 해결되지 않은 참조
inspection.kotlin.catch.may.ignore.exception.display.name='catch' 블록이 예외를 무시할 수 있음
inspection.kotlin.constant.conditions.display.name=상수 조건
inspection.kotlin.covariant.equals.display.name=공분산 ''equals()''
inspection.kotlin.deprecation.display.name=중복되거나 사용되지 않는 구문 또는 사용되지 않는 심볼의 사용 위치
inspection.kotlin.double.negation.action.name=불필요한 이중 부정 제거
inspection.kotlin.double.negation.display.name=중복 이중 부정
inspection.kotlin.equals.between.inconvertible.types.display.name=변환할 수 없는 유형의 객체 간의 ''equals()''
inspection.kotlin.internal.in.java.display.name=Java의 Kotlin 내부 선언 사용 위치
inspection.kotlin.invalid.bundle.or.property.display.name=잘못된 프로퍼티 키
inspection.kotlin.jvm.annotation.in.java.description=Kotlin JVM 어노테이션 ''{0}''은(는) Java에서 효과가 없습니다
inspection.kotlin.jvm.annotation.in.java.display.name=Java에서 Kotlin JVM 어노테이션
inspection.kotlin.maven.plugin.phase.display.name=Kotlin Maven Plugin이 잘못 구성되었습니다
inspection.kotlin.redundant.override.display.name=중복 재정의 메서드
inspection.kotlin.redundant.suppression.display.name=불필요한 진단 억제
inspection.kotlin.sealed.in.java.display.name=Java에서 Kotlin Sealed 인터페이스/클래스 상속
inspection.kotlin.test.j.unit.display.name=kotlin-test-junit을 사용할 수 있습니다
inspection.kotlin.throwable.not.thrown.display.name=throwable이 던져지지 않음
inspection.kotlin.unused.import.display.name=사용되지 않는 import 지시문
inspection.kotlin.unused.variable.display.name=사용되지 않는 변수
inspection.lateinit.var.overrides.lateinit.var.display.name=lateinit var 프로퍼티가 lateinit var 프로퍼티를 재정의
inspection.leaking.this.display.name=생성자 내 ''this'' 누수
inspection.lift.return.or.assignment.display.name=return 또는 대입을 제거 가능
inspection.local.variable.name.display.name=지역 변수 이름 지정 규칙
inspection.logger.initialized.with.foreign.class.display.name=로거가 외부 클래스로 초기화되었습니다
inspection.logger.placeholder.count.matches.argument.count.display.name=자리표시자 수가 로깅 호출의 인수 수와 일치하지 않음
inspection.loop.to.call.chain.display.name=루프를 stdlib 연산으로 바꾸기 가능
inspection.main.function.return.unit.display.name=진입점 함수는 Unit을 반환해야 함
inspection.map.get.with.not.null.assertion.operator.display.name=null이 아닌 어설션 연산자 (\!\!)가 있는 ''map.get()''
inspection.maven.coroutines.deprecation.display.name=La dependencia de kotlinx.coroutines incompatible de Maven se usa en Kotlin 1.3+
inspection.may.be.constant.display.name=''const''일 수 있습니다.
inspection.member.visibility.can.be.private.display.name=클래스 멤버는 ''private'' 가시성을 가질 수 있음
inspection.message.cast.will.always.fail=형 변환이 항상 실패합니다
inspection.message.condition.always.false=''{0}'' 조건은 항상 false입니다
inspection.message.condition.always.false.when.reached=조건 ''{0}''은(는) 도달 시 항상 false입니다
inspection.message.condition.always.true=''{0}'' 조건은 항상 true입니다
inspection.message.condition.always.true.when.reached=조건 ''{0}''은(는) 도달 시 항상 true입니다
inspection.message.empty.catch.block=빈 catch 블록
inspection.message.for.never.visited='for' 범위는 항상 공백입니다
inspection.message.inconsistent.parameter.name.for.0=''{0}''에 대한 일관되지 않은 매개변수 이름
inspection.message.index.out.of.bounds=색인이 항상 범위를 벗어납니다
inspection.message.nonnull.cast.will.always.fail=피연산자가 항상 null이므로 연산은 항상 실패합니다
inspection.message.object.with.manual.tostring.can.be.converted.to.data.object=수동 'toString'이 있는 'object'는 'data object'로 변환할 수 있습니다
inspection.message.sealed.object.can.be.converted.to.data.object='sealed' 하위 객체는 'data object'로 변환할 수 있습니다
inspection.message.value.always.false=''{0}''의 값은 항상 false입니다
inspection.message.value.always.null=''{0}''의 값은 항상 null입니다
inspection.message.value.always.true=''{0}''의 값은 항상 true입니다
inspection.message.value.always.zero=''{0}''의 값은 항상 0입니다
inspection.message.when.condition.always.false='when' 브랜치에 절대 도달할 수 없습니다
inspection.migrate.diagnostic.suppression.display.name=진단 이름을 바꿔야 함
inspection.move.lambda.outside.parentheses.display.name=소괄호 내 람다 인수
inspection.move.suspicious.callable.reference.into.parentheses.display.name=람다 결과로서 사용되는 의심스러운 호출 가능한 참조
inspection.move.variable.declaration.into.when.display.name=변수 선언을 ''when'' 내부로 이동 가능
inspection.nested.lambda.shadowed.implicit.parameter.display.name=중첩된 람다에 가려진 묵시적 매개변수가 있음
inspection.non.exhaustive.when.statement.migration.display.name=완전하지 않은 'when' 구문은 1.7 이후 금지됩니다
inspection.null.checks.to.safe.call.display.name=안전한 호출로 바꾸기 가능한 null 검사
inspection.nullable.boolean.elvis.action.name=elvis 대신 상등 검사를 null 가능한 부울 검사에 사용
inspection.nullable.boolean.elvis.display.name=elvis 대신 상등 검사를 null 가능한 부울 검사에 사용 가능
inspection.object.literal.to.lambda.display.name=객체 리터럴을 람다로 변환 가능
inspection.object.private.property.name.display.name=객체 private 프로퍼티 이름 지정 규칙
inspection.object.property.name.display.name=Object 프로퍼티 이름 지정 규칙
inspection.obsolete.experimental.coroutines.display.name=실험적 코루틴 사용 위치는 1.3부터 지원 중단됨
inspection.obsolete.kotlin.js.packages.display.name=''kotlin.browser'' 민 ''kotlin.dom'' 패키지는 1.4부터 더 이상 사용되지 않습니다
inspection.optional.expectation.display.name=선택적으로 필요한 어노테이션에 실제 어노테이션이 없습니다
inspection.package.directory.mismatch.display.name=패키지 이름이 포함하는 디렉터리와 일치하지 않음
inspection.package.name.display.name=패키지 이름 지정 규칙
inspection.platform.extension.receiver.of.inline.display.name=null 가능한 확장 리시버가 있는 인라인 함수의 안전하지 않은 호출
inspection.private.property.name.display.name=Private 프로퍼티 이름 지정 규칙
inspection.progression.resolution.change.migration.display.name=1.9부터 진행 해상도 변경
inspection.prohibit.jvm.overloads.on.constructors.of.annotation.classes.migration.display.name=1.4부터 ''@JvmOverloads'' 어노테이션은 어노테이션 클래스의 생성자에서 사용할 수 없음
inspection.prohibit.repeated.use.site.target.annotations.migration.display.name=''@Repeatable'' 없는 반복 가능한 어노테이션은 1.4부터 허용되지 않음
inspection.prohibit.type.parameters.for.local.variables.migration.display.name=1.4부터 지역 변수는 유형 매개변수를 가질 수 없습니다
inspection.prohibit.use.site.target.annotations.on.super.types.migration.display.name=상위 클래스의 어노테이션은 1.4부터 의미가 없음
inspection.property.name.display.name=프로퍼티 이름 지정 규칙
inspection.protected.in.final.display.name=''protected'' 가시성은 final 클래스에서 사실상 ''private''입니다.
inspection.public.api.implicit.type.display.name=public API 선언에 묵시적 반환 유형이 있음
inspection.recursive.equals.call.display.name=재귀적 equals 호출
inspection.recursive.property.accessor.display.name=재귀적 프로퍼티 접근자
inspection.redundant.anonymous.function.description=중복 익명 함수 생성
inspection.redundant.assequence.call=중복 ''asSequence'' 호출
inspection.redundant.async.display.name=중복 ''async'' 호출
inspection.redundant.companion.reference.display.name=중복 컴패니언 참조
inspection.redundant.else.in.if.display.name=''if'' 내 ''else'' 중복
inspection.redundant.elvis.return.null.descriptor=중복 ''?\: return null''
inspection.redundant.elvis.return.null.display.name=중복 ''?\: return null''
inspection.redundant.empty.initializer.block.display.name=중복된 빈 이니셜라이저 블록
inspection.redundant.enum.constructor.invocation.display.name=중복된 열거형 생성자 호출
inspection.redundant.explicit.type.display.name=명시적으로 지정된 유형이 여기에서 중복됩니다.
inspection.redundant.getter.display.name=중복 프로퍼티 getter
inspection.redundant.if.display.name=중복 ''if'' 문
inspection.redundant.inner.class.modifier.descriptor=중복 ''inner'' 제어자
inspection.redundant.inner.class.modifier.display.name=중복 ''inner'' 제어자
inspection.redundant.label.migration.display.name=1.4부터 중복 라벨
inspection.redundant.label.text=중복 라벨
inspection.redundant.lambda.arrow.display.name=중복된 람다 화살표
inspection.redundant.lambda.description=중복 람다 생성
inspection.redundant.lambda.or.anonymous.function.display.name=람다 또는 익명 함수의 중복 생성
inspection.redundant.lambda.or.anonymous.function.fix=본문 인라인화
inspection.redundant.modality.modifier.display.name=중복된 모달리티 제어자
inspection.redundant.not.null.extension.receiver.of.inline.display.name=인라인 함수의 null이 아닌 확장 리시버를 null 가능하도록 만들 수 있음
inspection.redundant.nullable.return.type.display.name=중복된 null 가능한 반환 유형
inspection.redundant.object.type.check.display.name=객체에 대한 중복 유형 검사
inspection.redundant.require.not.null.call.display.name=중복 ''requireNotNull'' 또는 ''checkNotNull'' 호출
inspection.redundant.return.label.display.name=중복 ''return'' 라벨
inspection.redundant.run.catching.display.name=중복 ''runCatching'' 호출
inspection.redundant.sam.constructor.display.name=중복 SAM 생성자
inspection.redundant.semicolon.display.name=중복 세미콜론
inspection.redundant.setter.display.name=중복 프로퍼티 setter
inspection.redundant.suspend.modifier.display.name=중복 ''suspend'' 제어자
inspection.redundant.unit.expression.display.name=중복 ''Unit''
inspection.redundant.unit.return.type.action.name=불필요한 'Unit' 반환 타입 제거
inspection.redundant.unit.return.type.display.name=중복 ''Unit'' 반환 유형
inspection.redundant.value.argument.annotation=값 인수가 매개변수 ''{0}''의 디폴트 값과 일치합니다
inspection.redundant.value.argument.display.name=불필요한 값 인수
inspection.redundant.visibility.modifier.display.name=중복된 가시성 제어자
inspection.redundant.with.display.name=중복 ''with'' 호출
inspection.remove.curly.braces.from.template.display.name=문자열 템플릿의 중복 중괄호
inspection.remove.empty.class.body.display.name=빈 클래스 본문 바꾸기
inspection.remove.empty.parentheses.from.annotation.entry.display.name=불필요한 소괄호를 제거합니다.
inspection.remove.empty.parentheses.from.lambda.call.action.name=람다가 있는 함수 호출에서 불필요한 소괄호 제거
inspection.remove.empty.parentheses.from.lambda.call.display.name=람다가 있는 함수 호출에서 불필요한 소괄호 제거
inspection.remove.empty.primary.constructor.display.name=빈 기본 생성자 제거
inspection.remove.empty.secondary.constructor.body.display.name=빈 생성자 본문 제거
inspection.remove.explicit.super.qualifier.display.name=불필요한 상위 유형 정규화
inspection.remove.explicit.type.arguments.display.name=불필요한 유형 인수
inspection.remove.for.loop.indices.display.name=사용되지 않는 루프 색인
inspection.remove.redundant.backticks.display.name=중복 백틱을 제거합니다.
inspection.remove.redundant.calls.of.conversion.methods.display.name=변환 메서드의 중복 호출 제거
inspection.remove.redundant.qualifier.name.display.name=중복 한정자 이름을 제거합니다.
inspection.remove.redundant.spread.operator.display.name=중복 스프레드 연산자
inspection.remove.setter.parameter.type.display.name=중복 setter 매개변수 유형
inspection.remove.single.expression.string.template.display.name=중복 문자열 템플릿 제거
inspection.remove.to.string.in.string.template.display.name=문자열 템플릿 내 중복 ''toString()'' 호출 제거
inspection.replace.array.equality.op.with.arrays.equals.display.name=''\=\=''를 ''Arrays.equals''로 바꾸기
inspection.replace.array.of.with.literal.display.name=''arrayOf'' 호출을 배열 리터럴 [...]로 바꾸기 가능
inspection.replace.assert.boolean.with.assert.equality.display.name=어설션 부울을 어설션 상등으로 바꿉니다.
inspection.replace.associate.function.display.name=''associate''를 ''associateBy'' 또는 ''associateWith''로 바꾸기
inspection.replace.call.with.binary.operator.display.name=2진 연산자로 바꾸기 가능
inspection.replace.collection.count.with.size.display.name=컬렉션 집계를 크기로 변환 가능
inspection.replace.get.or.set.display.name=명시적 ''get'' 또는 ''set'' 호출
inspection.replace.guard.clause.with.function.call.display.name=guard 절을 Kotlin의 함수 호출로 바꿉니다
inspection.replace.isempty.with.ifempty.display.name='if' 조건을 람다 호출로 바꿀 수 있음
inspection.replace.java.static.method.with.kotlin.analog.display.name=Java static 메서드를 Kotlin 아날로그로 바꾸기
inspection.replace.manual.range.with.indices.calls.display.name=Convertir un rango manual para indexar o repetir colecciones
inspection.replace.mapIndexed.with.list.generator.display.name='mapIndexed'를 List 제너레이터로 바꾸기
inspection.replace.negated.is.empty.with.is.not.empty.display.name=부정된 ''isEmpty''/''isBlank''를 ''isNotEmpty''/''isNotBlank''로 바꾸기
inspection.replace.not.null.assertion.with.elvis.return.display.name=''\!\!''를 ''?\: return''으로 바꿉니다.
inspection.replace.put.with.assignment.display.name=''map.put()''을 대입으로 변환할 수 있습니다
inspection.replace.range.start.end.inclusive.with.first.last.display.name=범위 ''start'' 또는 ''endInclusive''를 ''first'' 또는 ''last''로 바꾸기
inspection.replace.range.to.with.rangeUntil.display.name='rangeTo' 또는 '..' 호출을 '..<'로 바꿔야 함
inspection.replace.range.to.with.until.display.name=''rangeTo'' 또는 ''..'' 호출을 ''until''로 바꾸기 가능
inspection.replace.readline.with.readln.display.name='readLine'을 'readln' 혹은 'readlnOrNull'로 대체 가능
inspection.replace.size.check.with.is.not.empty.display.name=크기 검사를 ''isNotEmpty()''로 바꾸기
inspection.replace.size.zero.check.with.is.empty.display.name=제로 크기 검사를 ''isEmpty()''로 바꾸기
inspection.replace.string.format.with.literal.display.name=문자열 템플릿으로 바꾸기
inspection.replace.substring.with.drop.last.display.name=''substring'' 호출을 ''dropLast'' 호출로 바꿉니다.
inspection.replace.substring.with.indexing.operation.display.name=''substring'' 호출을 색인 생성 작업 호출로 바꿉니다.
inspection.replace.substring.with.substring.after.display.name=''substring'' 호출을 ''substringAfter'' 호출로 바꿉니다.
inspection.replace.substring.with.substring.before.display.name=''substring'' 호출을 ''substringBefore'' 호출로 바꿉니다.
inspection.replace.substring.with.take.display.name=''substring'' 호출을 ''take'' 호출로 바꿉니다.
inspection.replace.to.string.with.string.template.display.name=''toString''을 문자열 템플릿으로 바꿉니다.
inspection.replace.to.with.infix.form.display.name=''to''를 infix 형식으로 바꾸기
inspection.replace.until.with.rangeUntil.operator.display.name='until'을 '..<' 연산자로 바꾸기
inspection.replace.with.enum.map.display.name=EnumMap으로 바꿉니다.
inspection.replace.with.ignore.case.equals.display.name=''equals(..., ignoreCase \= true)''로 바꾸기
inspection.replace.with.import.alias.display.name=완전히 정규화된 이름을 기존 import 별칭으로 바꿀 수 있음
inspection.replace.with.operator.assignment.display.name=연산자 대입으로 바꾸기 가능한 대입
inspection.replace.with.string.builder.append.range.display.name=JVM상의 'StringBuilder.append(CharArray, offset, len)' 호출
inspection.restrict.return.statement.target.migration.display.name=1.4부터 대상 라벨이 함수를 표시하지 않음
inspection.safe.cast.with.return.display.name=''return''이 있는 안전한 형 변환은 ''if'' 유형 검사로 바꿔야 함
inspection.scope.function.conversion.display.name=범위 함수를 다른 함수로 변환 가능
inspection.self.assignment.display.name=변수의 자기 대입
inspection.self.reference.constructor.parameter.display.name=생성자에 null이 아닌 자체 참조 매개변수가 있습니다.
inspection.setter.backing.field.assignment.display.name=기존 백킹 필드가 setter로 대입되지 않았습니다.
inspection.simple.redundant.let.display.name=리시버 기반 ''let'' 호출 중복
inspection.simplifiable.call.chain.display.name=컬렉션 유형에 대한 호출 체인을 단순화 가능
inspection.simplifiable.call.display.name=라이브러리 함수 호출을 단순화 가능
inspection.simplifiable.scope.function.display.name=중첩된 forEach가 있는 범위 함수를 단순화할 수 있습니다
inspection.simplify.assert.not.null.display.name=''assert'' 호출을 ''\!\!'' 또는 ''?\:''으로 바꾸기 가능
inspection.simplify.boolean.with.constants.display.name=단순화 가능한 bool 표현식
inspection.simplify.negated.binary.expression.display.name=단순화 가능한 부정된 bool 표현식
inspection.simplify.when.with.boolean.constant.condition.display.name=''when'' 단순화 가능
inspection.sort.modifiers.display.name=비표준 제어자 순서
inspection.suspend.function.on.coroutine.scope.display.name=suspend 함수의 CoroutineScope 리시버로 인해 모호해진 coroutineContext
inspection.suspicious.as.dynamic.display.name=의심스러운 ''asDynamic'' 멤버 호출
inspection.suspicious.collection.reassignment.display.name=증강 대입이 내부에 새 컬렉션을 생성
inspection.suspicious.equals.combination.display.name=\=\=와 \=\=\=의 의심스러운 조합
inspection.suspicious.var.property.display.name=의심스러운 ''var'' 프로퍼티\: 해당 setter가 해당 getter 결과에 영향을 미치지 않습니다.
inspection.test.function.name.display.name=Test 함수 이름 지정 규칙
inspection.this.class.does.not.have.a.constructor=금지된 생성자 호출
inspection.trailing.comma.add.line.break=줄 바꿈 추가
inspection.trailing.comma.add.trailing.comma=후행 쉼표 추가
inspection.trailing.comma.comma.loses.the.advantages.in.this.position=이 위치에서는 쉼표의 이점이 소실됨
inspection.trailing.comma.display.name=후미 쉼표 권장
inspection.trailing.comma.fix.comma.position=Corregir la posición de la coma
inspection.trailing.comma.missing.line.break=줄 바꿈 누락
inspection.trailing.comma.missing.trailing.comma=후행 쉼표 누락
inspection.trailing.comma.remove.trailing.comma=후행 쉼표를 제거합니다.
inspection.trailing.comma.report.also.a.missing.comma=누락된 쉼표 또는 줄 바꿈도 보고
inspection.trailing.comma.useless.trailing.comma=불필요한 후행 쉼표
inspection.unlabeled.return.inside.lambda.display.name=람다 내부의 라벨 지정되지 않은 반환
inspection.unnecessary.opt_in.annotation.display.name=불필요한 '@OptIn' 어노테이션
inspection.unnecessary.opt_in.redundant.annotation=옵트인 마커가 중복됩니다. 일치하는 실험적 API가 사용되지 않았습니다.
inspection.unnecessary.opt_in.redundant.marker=옵트인 마커가 중복됩니다. ''{0}''(으)로 표시된 실험적 API가 사용되지 않았습니다.
inspection.unnecessary.opt_in.remove.annotation.fix.family.name=어노테이션 제거
inspection.unnecessary.opt_in.remove.marker.fix.family.name=옵트인 마커 제거
inspection.unnecessary.variable.display.name=불필요한 지역 변수
inspection.unsafe.cast.from.dynamic.display.name=동적 유형으로부터의 묵시적인 (안전하지 않은) 형 변환
inspection.unused.equals.display.name=사용되지 않는 equals 식
inspection.unused.lambda.expression.body.display.name=람다 식 본문이 있는 함수의 사용되지 않는 반환값
inspection.unused.main.parameter.display.name=주요 매개변수가 필요하지 않습니다
inspection.unused.receiver.parameter=El parámetro del receptor no se utiliza en absoluto.
inspection.unused.receiver.parameter.display.name=사용되지 않는 리시버 매개변수
inspection.unused.result.of.data.class.copy=사용되지 않는 데이터 클래스 복사 결과
inspection.unused.symbol.display.name=Símbolo no utilizado
inspection.unused.unary.operator.display.name=사용되지 않는 단항 연산자
inspection.use.expression.body.display.name=여기에는 표현식 본문 구문을 권장
inspection.use.property.access.syntax.display.name=프로퍼티 액세스 구문으로 바꾸기 가능한 접근자 호출
inspection.use.with.index.display.name=수동으로 증분된 색인 변수는 ''withIndex()''를 사용하여 바꾸기 가능
inspection.useless.call.on.collection.display.name=컬렉션 유형에 대한 불필요한 호출
inspection.useless.call.on.not.null.display.name=null이 아닌 유형에 대한 불필요한 호출
inspection.verbose.nullability.and.emptiness.call=다음의 검사를 ''{0}()'' 호출로 대체하세요
inspection.verbose.nullability.and.emptiness.display.name=장황한 null 값 가능성 및 공백 체크
inspection.warning.on.main.unused.parameter.migration.display.name=''main''의 ''args''는 1.4부터 사용되지 않음
inspection.when.with.only.else.action.name=하나의 'else' 브랜치로만 'when' 단순화
inspection.when.with.only.else.display.name=''when''에 ''else'' 브랜치만 있으므로 단순화 가능
inspection.wrap.unary.operator.display.name=숫자 상수를 가진 모호한 단항 연산자 사용
intention.add.import.alias.group.name=import 문 별칭 추가
intention.change.package.text=패키지 변경
intention.convert.lambda.line={0,choice,0\#단일|1\#여러} 줄의 람다로 변환
intention.extract.declarations.from.file.text=현재 파일에서 선언 추출
intention.extract.declarations.from.file.text.details=현재 파일에서 ''{0}'' {1, choice, 0#| 1#및 하위 클래스 }추출
intention.flow.on.dispatchers.io='Dispatchers.IO'의 Flow
intention.name.specify.supertype=상위 타입 지정
intention.name.use.correct.parameter.name=올바른 매개변수 이름을 사용하세요
intention.switch.context.to.dispatchers.io='Dispatchers.IO' 컨텍스트로 전환
intention.trailing.comma.custom.text=서식 지정 도구에서 후행 쉼표를 디폴트로 {0,choice,0\#활성화|1\#비활성화}
intention.trailing.comma.text=서식 지정 도구에서 후행 쉼표를 활성화/비활성화
intention.wrap.in.with.context='withContext'로 호출 래핑
interface=인터페이스
interface.member.dependency.required.by.interfaces={0,choice,1#인터페이스|2#인터페이스}에 필요
interface.should.be.external=인터페이스는 external이어야 합니다
internal.toggle.throwing.cached.pce.title=내부: 캐싱된 PCE 던지기 전환
introduce.0.as.subject.0.when=''{0}''을(를) ''when''의 대상으로서 삽입합니다.
introduce.anonymous.parameter.fix.family.name=익명 매개변수 삽입
introduce.backing.property=backing 프로퍼티
introduce.constant=상수 삽입
introduce.import.alias=import 문 별칭 삽입
introduce.property=프로퍼티 삽입
introduce.type.parameter=유형 매개변수 삽입
introduce.type.parameter.to.declaration=선언에 유형 매개변수를 삽입합니다.
introduce.variable=변수 삽입
introduce.when.subject=''when'' 대상을 삽입합니다.
invert.if.condition=''if'' 조건을 반전시킵니다.
it.s.prohibited.to.call.0.with.min.value.step.since.1.3=1.3부터 MIN_VALUE 단계로 {0} 호출하는 것은 금지됩니다.
iterate.over.0=''{0}'' 반복
iterate.over.collection=컬렉션 반복
java.collections.static.method.call.should.be.replaced.with.kotlin.stdlib=Java 컬렉션 정적 메서드 호출을 Kotlin stdlib으로 바꿔야 합니다.
java.map.foreach.method.call.should.be.replaced.with.kotlin.s.foreach=Java Map.forEach 메서드 호출을 Kotlin의 forEach로 바꿔야 합니다.
join.declaration.and.assignment=선언 및 할당 결합
join.with.initializer.fix.text=이니셜라이저로 결합합니다.
junit.static.methods=JUnit 정적 메서드
kdoc.comment.unresolved=Sin resolver
kdoc.section.title.author=Autor
kdoc.section.title.constructor=Constructor
kdoc.section.title.parameters=Parámetros
kdoc.section.title.properties=Propiedades
kdoc.section.title.receiver=Receptor
kdoc.section.title.returns=Devoluciones
kdoc.section.title.samples=Muestras
kdoc.section.title.see.also=Temas relacionados
kdoc.section.title.since=Hora de inicio
kdoc.section.title.suppress=Suprimir
kdoc.section.title.throws=Procesando
kotlin.call.chains.hints=Kotlin: 호출 체인에 대한 인레이 힌트 표시
kotlin.compiler.configurable=Kotlin 컴파일러
kotlin.dist.downloading.failed.group.name=Kotlin dist 다운로드가 실패했습니다
kotlin.external.compiler.updates.notification.group.name=Kotlin 외부 컴파일러 업데이트 이용 가능
kotlin.jps.plugin.group.name=Kotlin JPS 플러그인
kotlin.lambdas.hints=Kotlin: 람다에 대한 인레이 힌트 표시
kotlin.lambdas.hints.hints.lambda.receivers.parameters=Kotlin: 묵시적 리시버 및 매개변수에 대한 인레이 힌트 표시
kotlin.lambdas.hints.hints.lambda.return=Kotlin: 반환 표현식에 대한 인레이 힌트 표시
kotlin.language.configurable=Kotlin
kotlin.references.types.hints=Kotlin: 타입에 대한 인레이 힌트 표시
kotlin.references.types.hints.hints.type.function.parameter=Kotlin: 함수 매개변수 타입에 대한 인레이 힌트 표시
kotlin.references.types.hints.hints.type.function.return=Kotlin: 함수 반환 타입에 대한 인레이 힌트 표시
kotlin.references.types.hints.hints.type.property=Kotlin: 프로퍼티 타입에 대한 인레이 힌트 표시
kotlin.references.types.hints.hints.type.variable=Kotlin: 지역 변수 타입에 대한 인레이 힌트 표시
kotlin.script.definitions.model.name.autoReloadScriptDependencies=자동 다시 로드
kotlin.script.definitions.model.name.autoReloadScriptDependencies.description=파일 변경 시 스크립트 구성을 자동으로 로드하려면 자동 다시 로드를 활성화하세요
kotlin.script.definitions.model.name.is.enabled=Habilitado
kotlin.script.definitions.model.name.name=이름
kotlin.script.definitions.model.name.pattern.extension=패턴/확장
kotlin.script.definitions.title=스크립트 정의 관리
kotlin.script.in.beta.stage=Kotlin 스크립팅은 현재 베타 단계입니다
kotlin.script.in.beta.stage.link=https://kotlinlang.org/docs/components-stability.html#stability-levels-explained
kotlin.script.in.project.sources=<html>해당 스크립트는 소스 루트 내부에 있으면 안 됩니다. 그러면 Kotlin 1.9부터 스크립트가 모듈 컴파일 중에 무시됩니다.</html>
kotlin.script.in.project.sources.allow=허용...
kotlin.script.in.project.sources.hide=숨기기
kotlin.script.in.project.sources.later=나중에 결정
kotlin.script.in.project.sources.link=https://youtrack.jetbrains.com/issue/KT-52735
kotlin.script.in.project.sources.move=다음으로 이동...
kotlin.script.lookup.definitions=Kotlin 스크립트 정의 찾는 중…
kotlin.script.sources.index=색인
kotlin.script.sources.not.yet.indexed=프로젝트 시작 시간을 줄이도록 소스 파일이 색인 생성되지 않았습니다
kotlin.script.warning.more.info=정보 더보기
kotlin.scripting.configurable=Kotlin 스크립트
kotlin.values.hints=값에 대한 인레이 힌트 표시
kotlin.values.hints.kotlin.values.ranges=Kotlin: 범위에 대한 인레이 힌트 표시
label.text.default.receiver.value=디폴트 리시버 값(&D)\:
label.text.destination=대상:
label.text.destination.directory=대상 디렉터리(&D)\:
label.text.file=파일:
label.text.file.name=&Nombre del archivo\:
label.text.introduce.as=다음으로 삽입(&I)\:
label.text.move.expect.actual.counterparts=기대/실제 대응 항목 이동(&M)
label.text.name=이름(&N)\:
label.text.package=패키지:
label.text.package.name=패키지 이름(&G)\:
label.text.receiver.type=리시버 유형(&T)\:
label.text.source.sets=소스 세트:
label.text.target.file.name=대상 파일 이름\:
label.text.to.class=클래스로\:
label.text.to.file=대상 파일(&F)\:
label.text.to.object=객체로\:
label.text.to.package=패키지로(&A)\:
label.text.type=유형(&T)\:
label.text.visibility=가시성(&V)\:
lambda.argument.0.be.moved.out=람다 인수 {0}을(를) 소괄호 밖으로 이동{0}.
leaking.this.in.constructor.of.enum.class.0.with.overridable.members=열거형 클래스 {0}(재정의 가능한 멤버 포함)의 생성자 내 ''this'' 누수
leaking.this.in.constructor.of.non.final.class.0=final이 아닌 클래스 {0}의 생성자 내 ''this'' 누수
let.0.1={0}이(가) {1}하도록 합니다.
let.type.implement.interface=유형이 인터페이스를 구현하도록 합니다.
lift.assignment.out.fix.text.0=''{0}''에서 대입을 제거합니다.
lift.assignment.out.of.try.expression=''try'' 표현식에서 대입을 제거합니다.
lift.function.call.out.of.if='if'에서 함수 호출 제거
lift.return.out.fix.text.0=''{0}''에서 return 제거
lift.return.out.of.if.expression=''if'' 식에서 return 제거
listbox.import.package=패키지
listbox.import.with.subpackages=하위 패키지 포함
livetemplate.description.anonymous=Clase anónima
livetemplate.description.closure=Cierre (función sin nombre)
livetemplate.description.exfun=Función de extensión
livetemplate.description.exval=Propiedad extendida de solo lectura
livetemplate.description.exvar=Propiedades extendidas de lectura/escritura
livetemplate.description.fun0=Función sin parámetros
livetemplate.description.fun1=Función con 1 parámetro
livetemplate.description.fun2=Función con 2 parámetros
livetemplate.description.ifn=Inserte la expresión '' if null ''.
livetemplate.description.inn=Inserte la expresión '' si no es nulo ''.
livetemplate.description.interface=Interfaz
livetemplate.description.iter=Iterar sobre un elemento iterable (bucle for-in).
livetemplate.description.main=función main ()
livetemplate.description.maina=main(args) 함수
livetemplate.description.singleton=Singleton
livetemplate.description.soutp=Salida de los nombres y valores de los parámetros de la función a System.out.
livetemplate.description.void=La función no devuelve nada
local.variable=지역 변수
logger.initialized.with.foreign.class=로거가 외부 클래스 ''{0}''(으)로 초기화되었습니다
looking.for.usages.and.conflicts=사용 위치 및 충돌 검색 중...
looking.for.usages.in.java.files=Java 파일 내 사용 위치 검색 중...
loop.can.be.replaced.with.stdlib.operations=루프를 stdlib 연산으로 바꿀수 있습니다
loop.parameter.0.is.unused=루프 매개변수 ''{0}''이(가) 사용되지 않습니다.
loop.to.call.fix.family.name=stdlib 연산으로 바꾸기
loop.to.call.fix.family.name2=''asSequence()''를 사용하는 stdlib 연산으로 바꾸기
make.0={0}을(를) 만듭니다.
make.0.1=Hacer de ''{0}'' un {1}
make.0.1.explicitly=''{0}''을(를) {1}(으)로 명시적으로 만듭니다.
make.0.an.annotation.class=''{0}'' 을(를) 어노테이션 클래스로 만듭니다
make.0.explicitly={0}을(를) 명시적으로 만듭니다.
make.0.in.1.open={1}의 ''{0}''을(를) 엽니다.
make.0.not.1={0}을(를) {1}이(가) 아니도록 만듭니다.
make.class.an.annotation.class=클래스를 어노테이션 클래스로 만듭니다
make.constructor.parameter.a.property.0=생성자 매개변수를 프로퍼티 {0}(으)로 만듭니다.
make.member.static.quickfix=''{0}''을(를) 정적으로 설정하세요
make.not.nullable=null이 되지 않도록 만듭니다.
make.open=open 생성
make.open.fix.text=클래스를 엽니다.
make.primary.constructor.0=기본 생성자 {0} 생성
make.private.and.0.1=private 및 {0} ''{1}''(으)로 만듭니다.
make.private.fix.text=private으로 설정
make.type.parameter.reified.and.function.inline=유형 매개변수를 구체화하고 함수를 인라인화합니다.
making.member.static=멤버를 static으로 만드는 중…
map.get.with.not.null.assertion.operator=null이 아닌 어설션 연산자 (\!\!)가 있는 map.get()
map.put.should.be.converted.to.assignment=map.put()을 대입으로 변환해야 합니다.
mark.as.deprecated.level.deprecationlevel.hidden=@Deprecated(..., level \= DeprecationLevel.HIDDEN)로 표시합니다.
max.functions.to.visit=참조할 최대 함수
maximum.count.of.applied.refactoring.before.validity.check=유효성 검사 전에 적용되는 리팩터링의 최대 수
may.contain.only.letters.and.digits=문자와 숫자만 포함할 수 있습니다.
may.contain.only.letters.digits.or.underscores=문자, 숫자 또는 밑줄만 포함할 수 있습니다.
member.info.abstract.0=추상 {0}
member.info.companion.0=컴패니언 {0}
merge.else.if=''else if'' 문 병합
merge.if.s=''if'' 문 병합
message.change.signature.is.not.applicable.to.dynamically.invoked.functions=시그니처 변경은 동적으로 호출된 함수에 적용되지 않습니다.
message.do.not.show.for.local.variables.in.future=이후 지역 변수에 대해 표시하지 않습니다.
message.text.property.receiver.type.cannot.be.resolved=프로퍼티 리시버 타입 ''{0}''을(를) 해결할 수 없습니다.\n계속하시겠어요?
message.text.property.type.cannot.be.resolved=프로퍼티 타입 ''{0}''을(를) 해결할 수 없습니다.\n계속하시겠어요?
message.text.return.type.cannot.be.resolved=반환 유형 ''{0}''을(를) 해결할 수 없습니다.\n계속하시겠어요?
message.type.for.cannot.be.resolved=''{1}''의 유형 ''{0}''을(를) 해결할 수 없습니다.\n계속하시겠어요?
methods.are.absent.in.coroutines.class.since.1.3=메서드는 1.3부터 코루틴 클래스에서 사라집니다.
microservices.url.path.inlay.hints=Kotlin: URL 경로에 대한 인레이 힌트 표시
might.be.const=''const''일 수 있습니다.
migrate.type.parameter.list.syntax=유형 매개변수 목록 구문을 마이그레이션합니다.
migrate.unsupported.yield.syntax=지원되지 않는 yield 구문을 마이그레이션합니다.
minimal.line.count=최소 줄 수
missing.documentation=문서가 누락되었습니다.
modifiers.should.follow.annotations=제어자는 어노테이션 다음에 와야 합니다
move.annotation.to.receiver.type=어노테이션을 리시버 유형으로 이동합니다
move.else.branch.to.the.end=else 브랜치를 끝으로 이동합니다.
move.lambda.argument.into.parentheses=람다 인수를 소괄호 안으로 이동
move.lambda.argument.out.of.parentheses=람다 인수를 소괄호 밖으로 이동합니다.
move.members.from=다음의 멤버를 이동\:
move.out.of.companion.object=컴패니언 객체 외부로 이동
move.refactoring.error.text.cannot.perform.refactoring.since.the.following.files.already.exist=다음 파일이 이미 있으므로 리팩터링을 수행할 수 없습니다.\n\n
move.refactoring.test=리팩터링 테스트 이동
move.refactoring.testing=리팩터링 테스트 이동
move.reference.into.parentheses=참조를 소괄호 안으로 이동
move.to.class.body=클래스 본문으로 이동
move.to.companion.object=컴패니언 객체 내부로 이동
move.to.companion.object.command=컴패니언 객체로 이동
move.to.constructor=생성자로 이동
move.to.constructor.parameters=생성자 매개변수로 이동합니다.
move.to.top.level=최상위 수준으로 이동
move.type.parameter.constraint.to.where.clause=유형 매개변수 제약 조건을 ''where'' 절로 이동합니다.
move.unary.operator.to.previous.line.fix.text=단항 연산자를 이전 행으로 이동
move.variable.declaration.into.when=변수 선언을 ''when''으로 이동합니다.
moving.to.companion.object=컴패니언 객체로 이동 중…
name=이름(&N)\:
name.extract.interface=인터페이스 추출
name.introduce.import.alias=import 문 별칭 삽입
name.introduce.lambda.parameter=람다 매개변수 삽입
name.introduce.parameter1=매개변수 삽입
name.introduce.type.alias=유형 별칭 삽입
name.specify.supertype.command.title=상위 타입 지정
naming.convention.will.be.violated.after.rename=이름을 변경하면 이름 지정 규칙에 위반됩니다.
negated.operation.can.be.simplified=부정 연산을 단순화할 수 있습니다
nested.1.call.in.0.could.be.simplified.to.2=''{0}''에 있는 중첩된 ''{1}'' 호출을 {2}(으)로 단순화할 수 있습니다
non.canonical.modifiers.order=비표준 제어자 순서
non.external.classifier.extending.state.or.props.name=State 또는 Props를 확장하는 비외부 분류자
not.found.in.0.files={0}개의 파일에서 발견되지 않았습니다.
nothing.to.do=수행할 것이 없습니다.
notification.navigation.to.overriding.classes=색인 업데이트 중에는 재정의하는 클래스로 이동할 수 없습니다
notification.text.kotlin.js.compiler.body=새로운 Kotlin/JS IR 컴파일러를 사용하여 애플리케이션의 번들 크기를 줄이고 TypeScript 정의(d.ts)를 자동 생성합니다.
notification.text.kotlin.js.compiler.learn.more=자세히 알아보기
notification.text.kotlin.js.compiler.link=https://kotl.in/jsirstable
notification.text.kotlin.js.compiler.title=Kotlin/JS IR은 버전 1.8.0 이상에서 안정적입니다!
null.checks.replaceable.with.safe.calls=안전한 호출로 대체 가능한 null 검사
null.checks.to.safe.call.check.fix.text=체인 null 검사를 안전한 호출로 바꿉니다.
number.of.attempts.then.files.in.project.0=시도 횟수 > 프로젝트 내 파일, {0}
object.0=객체 "{0}"
object.or.top.level.property=객체 또는 최상위 프로퍼티
object.private.property=객체 private 프로퍼티
object.should.be.external.interface=객체는 외부 인터페이스여야 합니다
obsolete.coroutine.usage.fix.family.name=실험적인 코루틴 사용 위치 수정
obsolete.coroutine.usage.in.whole.fix.family.name=프로젝트에서 실험적 코루틴 사용 위치 수정
obsolete.kotlin.js.packages.usage.in.whole.fix.family.name=프로젝트에서 ''kotlin.dom'' 및 ''kotlin.browser'' 패키지의 사용을 수정
obsolete.package.usage.fix.family.name=''{0}'' 패키지의 사용을 수정
one.line.return=한 줄 반환
open.moved.members.in.editor=에디터에서 이동된 멤버 열기
open.moved.method.in.editor=에디터에서 이동된 메서드 열기
optimize.imports=Optimización de declaración import
optimize.imports.collect.unused.imports=Recopilar declaraciones de importación no utilizadas
optimize.imports.task.removing.redundant.imports=Eliminar declaraciones de importación duplicadas
optionally.expected.annotation.has.no.actual.annotation.in.module.0.for.platform.1=플랫폼 {1} 에 대한 모듈 {0} 에서 선택적으로 필요한 어노테이션에 실제 어노테이션이 없습니다
overridden.marker.implementation=implementado en <br/>
overridden.marker.implementations.choose.implementation.find.usages=Propiedad reemplazada de {0}
overridden.marker.implementations.choose.implementation.title=Selección de implementación de {0}
overridden.marker.implementations.multiple=Hay implementaciones.
overridden.marker.overrides=Anulado desde. <br/>
overridden.marker.overrides.choose.implementation.find.usages=mayor implementación de {0}
overridden.marker.overrides.choose.implementation.title=elija la implementación principal de {0}
overridden.marker.overrides.multiple=Anulado en subclases.
override.declaration.choose.to.delete=Elija un elemento para eliminar.
override.declaration.delete.multiple.parameters={0} es parte de la jerarquía del método. ¿Está seguro de que desea eliminar varios parámetros?
override.declaration.member=Miembro
override.declaration.unused.overriding.methods.description=Tiene un miembro obsoleto que reemplaza un método que acaba de eliminar
override.declaration.unused.overriding.methods.title=Miembro superior obsoleto
override.declaration.x.implements.y=implementar {0} en {1} a {2} en {3}.
override.declaration.x.in.y={0} de {1}
override.declaration.x.overrides.y.in.class.list={0} anula la declaración en la siguiente clase/interfaz, {1}. ¿Le gustaría {2} declaraciones predeterminadas?
package.0.already.contains.1=패키지 ''{0}''에 {1}이(가) 이미 포함되어 있습니다
package.name=패키지 이름
package.usages.are.obsolete.since.1.4=''{0}'' 패키지의 사용은 1.4부터 지원 중단됩니다
parameter.0=Parámetro "{0}"
parameter.hints.old=Kotlin: 매개변수에 대한 인레이 힌트 표시
parameter.name.is.invalid=매개변수 이름 ''{0}''이(가) 유효하지 않습니다
parameter.name.prompt=매개변수 이름(&M)\:
parameter.type.is.invalid=매개변수 유형 ''{0}''이 유효하지 않습니다
parameter.types.are.not.denotable=다음 유형은 대상 범위에서 표시할 수 없으므로 메서드를 추출할 수 없습니다.
parameter.used.in.declaration.body.warning=''{0}이(가) 선언 본문에서 사용됩니다
parentheses.should.be.removed=소괄호를 제거해야 합니다.
pass.outer.class.instance.as.parameter=외부 클래스의 인스턴스를 매개변수로 전달(&O)
perform.refactoring=리팩터링 수행...
placeholder.count.matches.argument.count.fewer.problem.descriptor=지정된 자리표시자 수({1})보다 인수의 수({0})가 적습니다 #loc
placeholder.count.matches.argument.count.more.problem.descriptor=지정된 자리표시자 수({1})보다 인수의 수({0})가 많습니다 #loc
plugin.verifier.compatibility.issue.message=La versión instalada del complemento de Kotlin ({0}) no es compatible con {1}.\nAlgunas funciones pueden estar dañadas.\n\nVuelva a instalar el complemento de Kotlin.
plugin.verifier.compatibility.issue.title=Problema de compatibilidad
popup.title.choose.supertype=상위 타입 선택
popup.title.elements=요소
popup.title.expressions=표현식
popup.title.types=타입
predefined.configuration.all.methods.of.the.class=클래스의 모든 메서드
predefined.configuration.all.vars.of.the.class=클래스의 모든 var
predefined.configuration.all.vars.of.the.object=객체의 모든 var
predefined.configuration.also.match.vals=var와 val 모두 일치
predefined.configuration.annotations=<html>어노테이션</html>
predefined.configuration.anonymous.class=익명 클래스
predefined.configuration.array.access=배열 액세스
predefined.configuration.assert.not.null=null이 아닌 어설션 연산자
predefined.configuration.assignments=대입
predefined.configuration.casts=형 변환
predefined.configuration.class.annotation=어노테이션이 추가된 클래스
predefined.configuration.comments.containing.word=주어진 단어를 포함하는 주석
predefined.configuration.companion.object.method.calls=컴패니언 객체로부터의 메서드 호출
predefined.configuration.do.while=Do...while 루프
predefined.configuration.elvis=Elvis 연산자
predefined.configuration.for=For 루프
predefined.configuration.function.annotation=어노테이션이 추가된 함수
predefined.configuration.function.explicit.inferred.type=명시적이고 추론된 타입
predefined.configuration.function.signature=함수 시그니처
predefined.configuration.ifs=If
predefined.configuration.instance=인스턴스
predefined.configuration.kdoc.tag=KDoc 태그
predefined.configuration.lambda=람다 식
predefined.configuration.method.calls=메서드 호출
predefined.configuration.object.companion.object=객체 및 컴패니언 객체 생성
predefined.configuration.properties.getter=명시적 getter가 있는 프로퍼티
predefined.configuration.safe.call.operator=안전한 호출 연산자
predefined.configuration.string.literals=문자열 리터럴
predefined.configuration.strings=문자열
predefined.configuration.strings.with.long.template=긴 템플릿이 포함된 문자열
predefined.configuration.trys=Try
predefined.configuration.vars.of.given.type=유형의 var
predefined.configuration.when=when 표현식
predefined.configuration.while=While 루프
premature.end.of.template=템플릿이 제대로 완료되지 않았습니다.
presentation.text.for.receiver.in.container.paren=(objetivo {0} dentro de {1})
presentation.text.for.receiver.in.container.paren.no.brackets=대상: {1} 내 {0}
presentation.text.in.container={0} de {1}
presentation.text.in.container.paren=(dentro de {0})
presentation.text.in.container.paren.no.brackets={0} 내
presentation.text.object.in.container={0} mi objeto
presentation.text.paren=({0})
presentation.text.paren.no.brackets={0}
private.data.class.constructor.is.exposed.via.the.generated.copy.method=private 데이터 클래스 생성자가 생성된 ''copy'' 메서드를 통해 노출됩니다.
private.property=Private 프로퍼티
progress.finding.implicit.nothing.s=묵시적 Nothing 찾는 중
progress.looking.up.add.annotation.usage=어노테이션 사용 위치 찾는 중…
progress.looking.up.sealed.subclass.usage=sealed 하위 클래스 사용 위치를 찾는 중…
progress.title.analyze.extraction.data=추출 데이터 분석...
progress.title.calculating.type=타입 계산 중...
progress.title.collect.hierarchy=''{0}'' 계층 구조 수집...
project.view.class.error.name=Nombre no proporcionado
project.view.class.initializer=\ inicializador de clase
project.view.expression=표현식
property=프로퍼티
property.0=프로퍼티 "{0}"
property.has.an.actual.declaration.in.the.class.constructor=프로퍼티의 실제 선언이 클래스 생성자에 있습니다
property.in.external.interface.should.be.var=외부 인터페이스의 프로퍼티는 var이어야 합니다
property.is.explicitly.assigned.to.parameter.0.can=프로퍼티가 매개변수 {0}에 명시적으로 대입되어 생성자에서 바로 프로퍼티를 선언할 수 있습니다.
property.overloaded.in.child.class.constructor=하위 클래스 생성자에서 오버로드된 프로퍼티
protected.visibility.is.effectively.private.in.a.final.class=''protected'' 가시성은 final 클래스에서 사실상 ''private''입니다.
provide.return.value=반환 값을 제공하세요
put.arguments.on.one.line=인수를 한 줄에 배치
put.arguments.on.separate.lines=인수를 별도의 줄에 배치
put.calls.on.separate.lines=호출을 별도의 줄에 배치
put.expressions.on.separate.lines=표현식을 별도의 줄에 배치
put.parameters.on.one.line=매개변수를 한 줄에 배치
put.parameters.on.separate.lines=매개변수를 별도의 줄에 배치
quick.doc.no.documentation=No hay documentación disponible.
quick.doc.section.deprecated=Funciones obsoletas\:
quick.doc.section.java.declaration=Declaración de Java\:
quick.doc.section.replace.with=Reemplazar con\:
quick.doc.text.enum.ordinal=enum constante ordinal\: {0}
quick.doc.text.lateinit='' lateinit '' es el <a href\="https\://kotlinlang.org/docs/reference/properties.html\#late-initialized-properties-and-variables"> constructor Permite la inicialización de propiedades externas no nulas</a>.
quick.doc.text.tailrec='' tailrec '' hace que las funciones <a href\="https\://kotlinlang.org/docs/reference/functions.html\#tail-recursive-functions"> tail sean recursivas</ a> (permite al compilador convertir la recursividad en iteración).
quickFix.add.property.text=''{0}{1}'' 프로퍼티 ''{2}''을(를) ''{3}''에 추가
quickfix.add.property.familyName=프로퍼티 추가
random.seed=랜덤 시드
range.could.be.replaced.with.indices.call=범위를 ''.indices'' 호출로 바꿀수 있습니다.
recursive.equals.call=재귀적 equals 호출
recursive.property.accessor=재귀적 프로퍼티 접근자
recursive.synthetic.property.accessor=재귀적 통합 프로퍼티 접근자
redundant.0=중복 ''@{0}''
redundant.0.call=중복 ''{0}'' 호출
redundant.0.modifier=불필요한 ''{0}'' 제어자
redundant.async.call.may.be.reduced.to.0=중복 ''async'' 호출을 ''{0}''(으)로 줄일 수 있습니다.
redundant.companion.reference=중복 컴패니언 참조
redundant.constructor.keyword=불필요한 'constructor' 키워드
redundant.curly.braces.in.string.template=문자열 템플릿의 중복 중괄호
redundant.double.negation=중복 이중 부정
redundant.else=중복 ''else''
redundant.empty.class.body=빈 클래스 본문 중복
redundant.empty.initializer.block=중복된 빈 이니셜라이저 블록
redundant.enum.constructor.invocation=중복된 열거형 생성자 호출
redundant.explicit.this=중복 명시적 this
redundant.getter=중복 getter
redundant.if.option.ignore.chained=체인 'if' 문 무시
redundant.if.statement=중복 ''if'' 문
redundant.if.statement.analyzing.type=조건 타입 분석 중...
redundant.lambda.arrow=중복된 람다 화살표
redundant.let.call.could.be.removed=중복된 ''let'' 호출을 제거할 수 있습니다.
redundant.modality.modifier=중복된 모달리티 제어자
redundant.override.fix.text=중복 재정의 메서드를 제거합니다.
redundant.overriding.method=중복 재정의 메서드
redundant.qualifier.name=중복 한정자 이름
redundant.qualifier.unnecessary.non.direct.parent.class.qualifier=불필요한 비 직접적 상위 클래스 한정자
redundant.runcatching.call.may.be.reduced.to.0=중복 ''runCatching'' 호출을 ''{0}''(으)로 줄일 수 있습니다.
redundant.sam.constructor=중복 SAM 생성자
redundant.sam.constructors=중복 SAM 생성자
redundant.semicolon=중복 세미콜론
redundant.setter=중복 setter
redundant.setter.parameter.type=중복 setter 매개변수 유형
redundant.string.template=문자열 템플릿 중복
redundant.suspend.modifier=중복 ''suspend'' 제어자
redundant.tostring.call.in.string.template=문자열 템플릿 내 중복 ''toString()'' 호출
redundant.type.checks.for.object=객체에 대한 중복 유형 검사
redundant.unit=중복 ''Unit''
redundant.unit.return.type=중복 ''Unit'' 반환 유형
redundant.visibility.modifier=중복된 가시성 제어자
refactoring.cannot.be.applied.no.sources.attached=연결된 소스가 없어 {0} 리팩터링을 적용할 수 없습니다
refactoring.cannot.be.applied.to.abstract.declaration={0} 리팩터링은 abstract 선언에 적용할 수 없습니다
refactoring.cannot.be.applied.to.anonymous.function.without.invocation={0} 리팩터링은 호출이 없는 익명 함수에 적용할 수 없습니다
refactoring.cannot.be.applied.to.expect.declaration={0} 리팩터링은 expect 선언에 적용할 수 없습니다
refactoring.cannot.be.applied.to.lambda.expression.without.invocation={0} 리팩터링은 호출이 없는 람다 식에 적용할 수 없습니다
refactoring.extract.to.separate.file.text=별도의 파일로 추출
refactoring.move.non.kotlin.file=대상은 Kotlin 파일이어야 합니다.
refactoring.the.function.cannot.be.converted.to.anonymous.function=함수는 익명 함수로 변환할 수 없습니다
refactoring.the.function.not.found=함수를 찾을 수 없습니다
refactoring.the.invocation.cannot.be.resolved=호출은 해결할 수 없습니다
remove.0=''.{0}'' 제거
remove.0.from.parameter=매개변수에서 ''{0}''을(를) 제거합니다.
remove.0.from.property=프로퍼티에서 {0}을(를) 제거합니다.
remove.0.modifier=''{0}'' 한정자를 제거합니다.
remove.0.variance.from.1=''{1}''에서 ''{0}'' 분산을 제거합니다.
remove.all.argument.names=모든 인수 이름 제거
remove.annotation.doesnt.have.any.effect=어노테이션이 아무런 효과가 없으므로 제거합니다. 참조: https://youtrack.jetbrains.com/issue/KT-48141
remove.argument.name=인수 이름 제거
remove.as.dynamic.call.fix.text=''asDynamic'' 호출을 제거합니다.
remove.assequence.call.fix.text=''asSequence'' 호출 제거
remove.braces=중괄호 제거
remove.braces.fix.text=중괄호 제거
remove.braces.from.0.statement=''{0}'' 문의 중괄호를 제거합니다.
remove.braces.from.all.branches=모든 브랜치에서 중괄호 제거
remove.braces.from.if.all.statements=모든 'if' 문에서 중괄호 제거
remove.braces.from.when.all.entries=모든 'when' 항목에서 중괄호 제거
remove.braces.from.when.entry=''when'' 항목에 중괄호 제거
remove.branch=Quitar rama
remove.condition=조건 제거
remove.conflicting.import.0=충돌하는 import 문 {0}을(를) 제거합니다.
remove.constructor.call=생성자 호출을 제거합니다.
remove.conversion.from.kclass.to.class=''KClass''에서 ''Class''로의 변환을 제거합니다.
remove.curly.braces=중괄호를 제거합니다.
remove.default.parameter.value=디폴트 매개변수 값을 제거합니다.
remove.deprecated.symbol.import=더 이상 사용되지 않는 심볼의 import 문을 제거합니다.
remove.element=요소를 제거합니다.
remove.else=''{0}'' para eliminar el else.
remove.else.branch=else 브랜치를 제거합니다.
remove.empty.constructor.body=빈 생성자 본문 제거
remove.empty.parentheses.from.annotation.entry.fix.text=불필요한 소괄호를 제거합니다.
remove.empty.primary.constructor=빈 기본 생성자 제거
remove.enum.constructor.invocation.fix.text=열거형 생성자 호출을 제거합니다.
remove.explicit.lambda.parameter.types.may.break.code=Eliminar tipos de parámetros lambda explícitos (puede romper el código)
remove.explicit.supertype.qualification=명시적 상위 유형 정규화 제거
remove.explicit.type.arguments=명시적 유형 인수 제거
remove.explicit.type.specification=명시적 유형 사양 제거
remove.explicit.type.specification.from.0=''{0}''에서 명시적 타입 사양 제거
remove.expression=' Eliminar {0} '
remove.expression.target=표현식 대상을 제거합니다.
remove.extension.function.type.annotation=적용할 수 없는 @ExtensionFunctionType 어노테이션 제거
remove.final.upper.bound=final 상위 바운드를 제거합니다.
remove.fix.text=표현식을 삭제합니다.
remove.from.annotation.argument=어노테이션 인수에서 @을 제거합니다
remove.function.body=함수 본문을 제거합니다.
remove.identifier.from.anonymous.function=익명 함수에서 식별자를 제거합니다.
remove.indices.in.for.loop=''for'' 루프의 색인 제거
remove.initializer.block.fix.text=이니셜라이저 블록을 제거합니다.
remove.jvmfield.annotation=@JvmField 어노테이션 제거
remove.jvmoverloads.annotation=@JvmOverloads 어노테이션을 제거합니다
remove.labeled.return.from.last.expression.in.a.lambda=람다 내 마지막 표현식에서 라벨 지정된 반환 제거
remove.let.call=''let'' 호출을 제거합니다.
remove.modifier=제어자 제거
remove.modifier.fix=''{0}''을(를) {1}이(가) 아니도록 만들기
remove.modifier.fix.family={0}(으)로 만들지 않음
remove.parameter.0=매개변수 ''{0}''을(를) 제거합니다.
remove.parts.from.property=프로퍼티에서 일부분을 제거합니다.
remove.redundant=중복 ''?''를 제거합니다.
remove.redundant.0.modifier=중복 ''{0}'' 제어자를 제거합니다.
remove.redundant.assignment=중복 할당 제거
remove.redundant.backticks.quick.fix.text=중복 백틱을 제거합니다.
remove.redundant.call.fix.text=불필요한 호출 제거
remove.redundant.calls.of.the.conversion.method=변환 메서드의 중복 호출 제거
remove.redundant.companion.reference.fix.text=중복 컴패니언 참조를 제거합니다.
remove.redundant.constructor.keyword.fix.text=불필요한 'constructor' 키워드 제거
remove.redundant.else.fix.text=중복 ''else''를 제거합니다.
remove.redundant.elvis.return.null.text=중복 ''?\: return null'' 제거
remove.redundant.empty.class.body=불필요한 빈 클래스 본문 제거
remove.redundant.getter.fix.text=중복 getter를 제거합니다.
remove.redundant.if.expression=중복 ''if'' 식을 제거합니다.
remove.redundant.if.may.change.semantics.with.floating.point.types=불필요한 'if' 구문 제거(부동소수점 타입의 의미가 변경될 수 있습니다)
remove.redundant.if.text=중복 ''if'' 문을 제거합니다.
remove.redundant.initializer=불필요한 이니셜라이저 제거
remove.redundant.label=중복 라벨을 제거합니다.
remove.redundant.modality.modifier=불필요한 모달리티 제어자 제거
remove.redundant.qualifier.name.quick.fix.text=중복 한정자 이름을 제거합니다
remove.redundant.sam.constructor=중복 SAM 생성자를 제거합니다.
remove.redundant.sam.constructors=중복 SAM 생성자를 제거합니다.
remove.redundant.setter.fix.text=중복 setter를 제거합니다
remove.redundant.spread.operator.quickfix.text=중복 스프레드 연산자를 제거합니다.
remove.redundant.unit.fix.text=중복 ''Unit''을 제거합니다.
remove.redundant.visibility.modifier=불필요한 가시성 제어자 제거
remove.redundant.with.fix.text=중복 ''with'' 호출을 제거합니다.
remove.require.not.null.call.fix.text=''{0}'' 호출 제거
remove.return.0=return@{0} 제거
remove.return.label.fix.family=중복 라벨을 제거합니다.
remove.return.label.fix.text=중복 ''@{0}''을(를) 제거합니다.
remove.self.assignment.fix.text=자체 할당 제거
remove.single.expression.string.template=단일 표현식 문자열 템플릿 제거
remove.single.lambda.parameter.declaration=단일 람다 매개변수 선언을 제거합니다.
remove.star=''*'' 제거
remove.supertype=상위 유형 제거
remove.to.string.fix.text=''toString()'' 호출을 제거합니다.
remove.token.from.function.declaration=함수 선언에서 ''\='' 토큰을 제거합니다.
remove.type.arguments=유형 인수 제거
remove.type.parameters=유형 매개변수를 제거합니다.
remove.unary.operator.fix.text=사용되지 않는 단항 연산자를 제거합니다.
remove.underscores=밑줄 제거
remove.unnecessary.parentheses=불필요한 소괄호를 제거합니다.
remove.unnecessary.parentheses.from.function.call.with.lambda=람다가 있는 함수 호출에서 불필요한 소괄호 제거
remove.use.site.get.target=어노테이션을 유효하게 만들기 위해 'get:'을 제거합니다(의미가 변경됩니다. 참조: https://youtrack.jetbrains.com/issue/KT-48141)
remove.useless=필요 없는 ''?''를 제거합니다.
remove.useless.cast=필요 없는 형 변환을 제거합니다.
remove.useless.elvis.operator=필요 없는 elvis 연산자를 제거합니다.
remove.useless.is.check=필요 없는 is 검사를 제거합니다.
remove.val.or.var.from.parameter=매개변수에서 'val' 또는 'var' 제거
remove.var.keyword.text=var 제거
remove.variable=변수 제거
remove.variable.0=변수 ''{0}''을(를) 제거합니다.
rename.base.0=기본 {0,choice,1#함수|2#프로퍼티|3#멤버|4#메서드|11#함수|12#프로퍼티|13#멤버|14#메서드}의 이름 변경
rename.class.to.0=클래스 이름을 {0}(으)로 변경
rename.class.to.containing.file.name=클래스 이름을 포함된 파일 이름으로 변경
rename.declaration.title.0.implements.1.2.of.3={3}의 {0} {1,choice,1#구현|2#재정의} {2}
rename.file.to.0.1=파일 이름을 {0}.{1}(으)로 변경
rename.file.to.match.top.level.class.name=최상위 클래스 이름과 일치하도록 파일 이름 변경
rename.identifier.fix.text=이름 바꾸기
rename.only.current.0=현재의 {0,choice,1#함수|2#프로퍼티} 이름만 변경
rename.parameter.to.match.overridden.method=매개변수 이름을 변경하여 재정의된 메서드와 일치시킵니다.
rename.searching.for.all.overrides=모든 재정의 검색 중
rename.searching.for.super.declaration=최하단 super 선언 검색 중
rename.to.0=''{0}''로 이름 바꾸기
rename.to.01={0}(으)로 이름 변경
rename.to.fix.text=''{0}''로 이름 바꾸기
rename.to.underscore=다음으로 이름 변경 _
rename.useless.call.fix.text=호출을 ''{0}''(으)로 변경합니다.
reorder.parameters=매개변수 다시 정렬
reorder.parameters.command=매개변수 다시 정렬
repair.actual.members=실제 멤버를 수정합니다.
replace.&&.with.||='\\&\\&'를 '||'로 바꾸기
replace.0.call.with.indexing.operator=''{0}'' 호출을 색인 생성 연산자로 바꿉니다.
replace.0.name.with.spaces={0} 이름을 공백으로 바꾸기
replace.0.with=''{0}()''을(를) ''+\=''로 바꾸기
replace.0.with.1=''{0}''을(를) ''{1}''(으)로 바꾸기
replace.0.with.1.and.vice.versa=''{0}''을(를) ''{1}''(으)로, 또는 그 반대로 바꾸기
replace.annotation=어노테이션을 바꿉니다
replace.annotation.with.0=어노테이션을 {0} (으)로 바꿉니다
replace.array.of.boxed.with.array.of.primitive=박싱의 배열을 기본 배열로 바꿉니다.
replace.assert.boolean.with.assert.equality=어설션 부울을 어설션 상등으로 바꿉니다.
replace.assert.with.operator=어설션을 연산자로 바꿉니다.
replace.assignment.with.if.expression=대입을 ''if'' 식으로 바꾸기
replace.assignment.with.when.expression=대입을 ''when'' 식으로 바꾸기
replace.by.0=''{0}''(으)로 바꾸기
replace.by.reconstructed.type=재생성된 유형으로 바꾸기
replace.call.with.unary.operator=호출을 단항 연산자로 바꾸기
replace.cast.with.call.to.to.0=형 변환을 ''to{0}()'' 호출로 바꿉니다.
replace.cast.with.primitive.conversion.method=형 변환을 기본 변환 메서드로 바꿉니다.
replace.collection.count.with.size.quick.fix.text=''count''를 ''size''로 바꿉니다.
replace.contains.call.with.in.operator=''contains'' 호출을 ''in'' 연산자로 바꾸기
replace.deprecated.symbol.usage=더 이상 사용되지 않는 심볼의 사용 위치를 바꿉니다.
replace.deprecated.symbol.usage.in.whole.project=더 이상 사용되지 않는 심볼의 사용 위치를 전체 프로젝트에서 대체합니다.
replace.diagnostic.name.fix.family.name=진단 이름 바꾸기
replace.diagnostic.name.fix.text={0}을(를) {1}(으)로
replace.elvis.expression.with.if.expression=elvis 식을 ''if'' 식으로 바꾸기
replace.explicit.lambda.parameter.with.it=명시적 람다 매개변수를 ''it''으로 바꾸기
replace.explicit.parameter.0.with.it=명시적 매개변수 ''{0}''을(를) ''it''으로 바꾸기
replace.expression.with.if.expression=''\!\!'' 식을 ''if'' 식으로 바꾸기
replace.function.call.with.if=함수 호출을 'if'로 바꾸기
replace.function.call.with.the.opposite=함수 호출을 반대 함수 호출로 바꾸기
replace.get.or.set.call.with.indexing.operator=get 또는 set 호출을 색인 생성 연산자로 바꿉니다.
replace.guard.clause.with.kotlin.s.function.call=guard 절을 Kotlin의 함수 호출로 바꿉니다
replace.if.expression.with.elvis.expression=''if'' 식을 elvis 식으로 바꿉니다.
replace.if.expression.with.return=''if'' 식을 return으로 바꾸기
replace.if.expression.with.safe.access.expression=''if'' 식을 안전한 액세스 식으로 바꿉니다.
replace.if.expression.with.safe.cast.expression=''if'' 식을 안전한 형 변환 식으로 바꿉니다.
replace.if.with.elvis.operator=''if''를 elvis 연산자로 바꿉니다.
replace.if.with.when=''if''를 ''when''으로 바꾸기
replace.index.loop.with.collection.loop.quick.fix.text=요소에 대한 루프로 바꿉니다.
replace.infix.call.with.ordinary.call=infix 호출을 ordinary 호출로 바꾸기
replace.int.range.end.inclusive.with.last.quick.fix.text=''endInclusive''를 ''last''로 바꿉니다.
replace.int.range.start.with.first.quick.fix.text=''start''를 ''first''로 바꿉니다.
replace.invalid.positioned.arguments.for.annotation=어노테이션에 대해 잘못 배치된 인수를 바꿉니다
replace.invoke.with.direct.call=''invoke''를 직접 호출로 바꾸기
replace.it.with.explicit.parameter=''it''을 명시적 매개변수로 바꾸기
replace.jvmfield.with.const=''@JvmField''를 ''const''로 바꿉니다.
replace.manual.range.with.indices.call.quick.fix.text=색인으로 바꿉니다.
replace.modifier=제어자를 바꿉니다.
replace.negated.0.operation.with.1=부정된 ''{0}'' 연산을 ''{1}''(으)로 바꿉니다.
replace.negated.0.operation.with.1.may.change.semantics.with.floating.point.types=부정 ''{0}'' 연산을 ''{1}''(으)로 바꾸기(부동소수점 타입으로 의미가 변경될 수 있음)
replace.negated.0.with.1=부정된 ''{0}''을(를) ''{1}''(으)로 바꿉니다.
replace.overloaded.operator.with.function.call=오버로드된 연산자를 함수 호출로 바꾸기
replace.property.initializer.with.if.expression=프로퍼티 이니셜라이저를 ''if'' 식으로 바꾸기
replace.property.initializer.with.when.expression=프로퍼티 이니셜라이저를 ''when'' 식으로 바꾸기
replace.return.with.if.expression=return을 ''if'' 식으로 바꾸기
replace.return.with.when.expression=return을 ''when'' 식으로 바꾸기
replace.safe.access.expression.with.if.expression=안전한 액세스 표현식을 ''if'' 식으로 바꾸기
replace.scope.function.with.safe.call=범위 함수를 안전한 (?.) 호출로 바꿉니다.
replace.size.check.with.0=크기 검사를 ''{0}''(으)로 바꾸기
replace.size.check.with.isnotempty=크기 검사를 ''isNotEmpty''로 바꾸기
replace.size.zero.check.with.isempty=제로 크기 검사를 ''isEmpty''로 바꾸기
replace.substring.call.with.droplast.call=''substring'' 호출을 ''dropLast'' 호출로 바꿉니다.
replace.substring.call.with.indexing.operation.call=''substring'' 호출을 색인 생성 작업 호출로 바꿉니다.
replace.substring.call.with.substringafter.call=''substring'' 호출을 ''substringAfter'' 호출로 바꿉니다.
replace.substring.call.with.substringbefore.call=''substring'' 호출을 ''substringBefore'' 호출로 바꿉니다.
replace.substring.call.with.take.call=''substring'' 호출을 ''take'' 호출로 바꿉니다.
replace.to.with.infix.form.quickfix.text=''to''를 infix 형식으로 바꿉니다.
replace.tostring.with.string.template=''toString''을 문자열 템플릿으로 바꿉니다.
replace.total.order.equality.with.ieee.754.equality=total order 상등을 IEEE 754 상등으로 바꿉니다.
replace.usages.of.0.in.whole.project=''{0}''의 사용 위치를 전체 프로젝트에서 대체합니다.
replace.when.with.if=''when''을 ''if''로 바꾸기
replace.with.0=''{0}''(으)로 바꾸기
replace.with.0.1.2={0}[{1}] ?\: {2}(으)로 바꾸기
replace.with.0.call=''{0}()'' 호출로 바꿉니다.
replace.with.0.operator=''{0}'' 연산자로 바꾸기
replace.with.a.for.loop=''for'' 루프로 바꾸기
replace.with.a.foreach.function.call=''forEach'' 함수 호출로 바꾸기
replace.with.array.call=배열 호출로 바꿉니다.
replace.with.array.literal.fix.family.name=[...](으)로 바꾸기
replace.with.arrayof='arrayOf'로 바꾸기
replace.with.assignment.fix.text=대입으로 바꿉니다(원본이 비어 있음).
replace.with.binary.operator=2진 연산자로 바꿉니다.
replace.with.block.comment=블록 주석으로 바꾸기
replace.with.contentequals=''\!\=''를 ''contentEquals''로 바꿉니다.
replace.with.contentequals2=''\=\=''를 ''contentEquals''로 바꿉니다.
replace.with.contentequals3=''contentEquals''로 바꿉니다.
replace.with.dot.call=마침표 호출로 바꿉니다.
replace.with.elvis.error.fix.text=''?\: error("")''로 바꿉니다.
replace.with.elvis.return.fix.text=''?\: return{0}''(으)로 바꿉니다.
replace.with.end.of.line.comment=줄 주석의 끝으로 바꾸기
replace.with.enum.map.fix.text=EnumMap으로 바꿉니다.
replace.with.equality.check.fix.text=상등 검사로 바꿉니다.
replace.with.equality.fix.text=''{0}''을(를) ''{1}''(으)로 바꾸기
replace.with.error=''?\: error(...)''로 바꿉니다.
replace.with.explicit.type='_'을 명시적 타입으로 바꾸기
replace.with.field.fix.text=''field''로 바꿉니다.
replace.with.filter.fix.text=필터로 바꿉니다.
replace.with.generated.publishedapi.bridge.call.0=생성된 @PublishedApi 브리지 호출 ''{0}''(으)로 바꿉니다.
replace.with.get.or.else.fix.text=''getOrElse'' 호출로 바꿉니다.
replace.with.get.value.call.fix.text=''getValue'' 호출로 바꿉니다.
replace.with.if.fix.text=''if'' 유형 검사로 바꿉니다.
replace.with.import.alias=가져오기 별칭으로 바꾸기
replace.with.in.when=when에서 '',''를 ''||''로 바꾸기합니다.
replace.with.indexing.and.elvis.operator=색인 생성 연산자 및 elvis 연산자로 바꾸기
replace.with.infix.function.call=infix 함수 호출로 바꾸기
replace.with.kotlin.analog.function.family.name=Kotlin 아날로그로 바꾸기
replace.with.kotlin.analog.function.text=''{0}'' 함수로 바꾸기
replace.with.kotlin.s.foreach=Kotlin의 forEach로 바꿉니다.
replace.with.kotlin.s.function.call=Kotlin의 함수 호출로 바꿉니다
replace.with.label.0.at={0}@으로 바꿉니다.
replace.with.list.generator.fix.text=List 제너레이터로 바꾸기
replace.with.operator.assignment=연산자 대입으로 바꿉니다.
replace.with.ordinary.assignment=일반 대입으로 바꾸기
replace.with.parameter.name=''_''를 매개변수 이름으로 바꾸기
replace.with.publishedapi.bridge.call=@PublishedApi 브리지 호출로 바꿉니다.
replace.with.rangeUntil.quick.fix.text='..<'로 바꾸기
replace.with.repeat.fix.family.name=''repeat()''으로 바꾸기
replace.with.return=''\!\!''를 ''?\: return''으로 바꿉니다.
replace.with.safe.call=안전한 (?.) 호출로 바꿉니다.
replace.with.safe.this.call=안전한 (this?.) 호출로 바꿉니다.
replace.with.std.lib.fix.text={0}.{1}(으)로 바꿉니다.
replace.with.stdlib.operations=stdlib 연산으로 바꾸기
replace.with.stdlib.operations.with.use.of.assequence=''asSequence()''를 사용하는 stdlib 연산으로 바꾸기
replace.with.string.literal.fix.family.name=문자열 템플릿으로 바꾸기
replace.with.underscore=명시적 타입을 '_'로 바꾸기
replace.with.until.quick.fix.text=until로 바꿉니다.
replace.with1=''+\=''로 바꾸기
replace.||.with.&&='||'를 '\\&\\&'로 바꾸기
replaceable.with.enummap=EnumMap으로 바꿀 수 있습니다.
replaceable.with.operator.assignment=연산자 대입으로 바꿀 수 있습니다.
report.also.for.a.variables.without.a.whitespace.around=주위에 공백이 없는 변수에 대해서도 보고합니다.
report.also.on.call.with.single.boolean.literal.argument=단일 부울 리터럴 인수가 있는 호출에서도 보고합니다.
report.also.on.statement=구문세서도 보고합니다.
report.for.types.with.platform.arguments=플랫폼 인수가 있는 유형에 대해 보고합니다.
reporter.button.text.ignore=무시
reporter.button.text.update=업데이트
reporter.message.text.you.re.running.kotlin.plugin.version=현재 실행 중인 Kotlin 플러그인 버전은 {0}이며 최신 버전은 {1}입니다.
reporter.text.can.t.report.exception.from.patched.plugin=패치 플러그인의 예외를 보고할 수 없습니다.
reporter.title.update.kotlin.plugin=Actualizar del complemento de Kotlin
reports.only.function.calls.from.kotlinx.coroutines=kotlinx.coroutines의 함수 호출만 보고합니다.
reset.files=파일 재설정...
resolve.pasted.references=붙여넣은 참조 해결
result.of.0.call.is.not.thrown=''{0}'' 호출의 결과가 던져지지 않습니다.
rethrow.stored.pce.as.a.new.runtime.exception=저장된 PCE를 새 런타임 예외로 다시 던지기
return.type=반환 유형(&R)\:
return.type.is.invalid=반환 유형이 유효하지 않습니다.
return.when=when 반환
revert.applied.imports.command=적용된 import 문 되돌리기
roots.description.text.update.source.roots.for.non.jvm.modules.in.kotlin.project=Kotlin 프로젝트에서 JVM이 아닌 모듈에 대한 소스 루트를 업데이트합니다.
round.using.0={0}()을(를) 사용하여 반올림합니다.
safe.delete.constructor=안전한 delete 생성자
saving.files=파일 저장 중...
scanning.files.0.fo.1.file.2.occurrences.found=파일 검사 중\: {0}/{1} 파일. {2}개의 사용 위치가 발견되었습니다.
script.action.text.ignore=무시
script.action.text.open.settings=설정 열기
script.action.text.show.all=Mostrar todo
script.name.kotlin.scripting=Kotlin 스크립트
script.text.multiple.script.definitions.are.applicable.for.this.script=이 스크립트에는 여러 스크립트 정의를 적용할 수 있습니다. {0}이(가) 사용됩니다.
sealed.sub.class.has.no.state.and.no.overridden.equals=봉인된 하위 클래스에 상태도 없고 재정의된 equals도 없습니다.
search.for.not.property.candidates=프로퍼티가 아닌 후보를 검색합니다.
search.for.text.occurrences=텍스트 사용 위치 검색(&T)
search.in.comments.and.strings=주석 및 문자열에서 검색(&C)
searching.0={0} 검색 중...
searching.for.0={0} 검색 중
searching.for.imports.to.delete.title=삭제할 import 문 검색 중
searching.for.not.property.candidates=프로퍼티가 아닌 후보 검색
searching.for.overriding.methods=Buscar métodos de reemplazo
searching.inheritors=상속자 검색 중...
searching.usages.of.0.parameter=''{0}'' 매개변수의 사용 위치 검색 중
select.lambda.to.label=라벨을 지정할 람다를 선택합니다.
select.loop.statement.to.label=라벨을 지정할 루프 문을 선택합니다.
select.target.code.block.file=대상 코드 블록/파일을 선택합니다.
select.target.file=대상 파일을 선택합니다.
selected.code.fragment.has.multiple.exit.points=선택한 코드 조각에 종료점이 여러 개 있습니다.
selected.code.fragment.has.multiple.output.values=선택한 코드 조각에 3개 이상의 출력값이 있습니다.
selected.code.fragment.has.output.values.and.exit.points=선택한 코드 조각에 출력값과 대체 종료점이 있습니다.
setter.of.0.will.become.invisible.after.extraction={0} 의 setter는 추출 후 보이지 않게 됩니다
should.be.replaced.with.if.type.check=''if'' 유형 검사로 바꿔야 합니다.
should.be.replaced.with.indexing=색인 생성으로 바꿔야 합니다.
should.be.replaced.with.kotlin.function=Kotlin 함수로 바꿔야 합니다.
should.be.replaced.with.list.generator=List 제너레이터로 바꿔야 합니다
should.not.contain.lowercase.letter=소문자는 사용할 수 없습니다
should.not.contain.underscores=밑줄이 있으면 안 됩니다.
should.not.contain.underscores.in.the.middle.or.the.end=중간 또는 끝에 밑줄이 있으면 안 됩니다.
should.not.contain.underscores.with.camel.case=낙타 표기법을 사용하는 곳에 밑줄을 쓸 수 없습니다
should.not.start.with.an.underscore=밑줄로 시작하면 안 됩니다.
should.not.start.with.an.uppercase.letter=대문자로 시작하면 안 됩니다.
should.start.with.a.lowercase.letter=소문자로 시작해야 합니다.
should.start.with.an.uppercase.letter=대문자로 시작해야 합니다.
signature.preview=시그니처 미리보기
simplify.0.to.1={0}을(를) ''{1}''(으)로 단순화합니다.
simplify.boolean.expression=부울 표현식 단순화
simplify.call.chain.fix.text=호출 체인을 ''{0}''에 병합합니다.
simplify.call.fix.text=''{0}'' 호출을 ''{1}''(으)로 변환합니다.
simplify.comparison=비교를 단순화합니다.
simplify.fix.text=표현식 단순화
simplify.foldable.if.then=접을 수 있는 if-then을 단순화합니다.
simplify.negated.operation=부정된 연산을 단순화합니다.
simplify.when.fix.text=''when''을 단순화합니다.
since.kotlin.1.3.main.parameter.is.not.necessary=Kotlin 1.3부터 주요 매개변수가 필요하지 않습니다.
slicer.text.in=내
slicer.text.tracking.enclosing.lambda=\ (둘러싸는 람다 추적)
slicer.text.tracking.lambda.argument=\ (람다 매개변수 추적)
slicer.text.tracking.lambda.calls=\ (람다 호출 추적)
slicer.text.tracking.lambda.receiver=\ (람다 리시버 추적)
slicer.title.dataflow.from.here=여기에서 유입되는 데이터 흐름
slicer.title.dataflow.to.here=여기로 유입되는 데이터 흐름
slicer.tool.tip.text.variable.dereferenced=역참조된 변수
some.types.are.not.accessible.from.0.1={0}에서 액세스할 수 없는 유형\:\n{1}
sort.modifiers=제어자 정렬
specify.all.types.explicitly.in.destructuring.declaration=구조 분해 선언에서 모든 유형을 명시적으로 지정
specify.explicit.lambda.signature=명시적 람다 시그니처 지정
specify.override.explicitly=재정의를 명시적으로 지정합니다.
specify.override.for.0.explicitly=''{0}''에 대한 재정의를 명시적으로 지정합니다.
specify.return.type.explicitly=명시적으로 반환 유형을 지정합니다.
specify.super.type=상위 타입 ''{0}''을(를) 명시적으로 지정
specify.type.explicitly=유형을 명시적으로 지정합니다.
split.if.into.two=''if''를 두 부분으로 분할
split.property.declaration=프로퍼티 선언 분할
spring.secured.urls.inlay.hints=Kotlin: 보안 Spring URL에 인레이 힌트 표시
ssr.modifier.match.call.semantically=의미적으로 호출 일치
ssr.modifier.match.companion.object=컴패니언 객체 일치
ssr.modifier.match.val=val 일치
ssr.modifier.match.var=val 일치
start.import.button.text.add=추가
start.import.button.text.remove=제거
statement=구문
status=(상태)
step.1.collecting.0.1.2=1단계\: {0}\:{1}\:{2} 수집
step.2.0.of.1=2단계\: {0}의 {1}
step.3.0.of.1=3단계\: {0}의 {1}
surround.with.0=*{0}(...)(으)로 둘러싸기
surround.with.array.of=arrayOf로 둘러싸기(...)
surround.with.lambda=람다로 둘러쌉니다.
surround.with.null.check=null 검사로 둘러쌉니다.
surround.with.star.0=*{0}(...)(으)로 둘러쌉니다.
suspicious.asdynamic.member.invocation=의심스러운 ''asDynamic'' 멤버 호출
suspicious.callable.reference.as.the.only.lambda.element=유일한 람다 요소로서의 의심스러운 호출 가능한 참조
suspicious.combination.of.and=\=\=와 \=\=\=의 의심스러운 조합
suspicious.var.property.its.setter.does.not.influence.its.getter.result=의심스러운 ''var'' 프로퍼티\: 해당 setter가 해당 getter 결과에 영향을 미치지 않습니다.
test.function=테스트 함수
test.integration.button.text.cancel=Cancelar
test.integration.button.text.rewrite=재작성
test.integration.message.text.create.test.in.the.same.source.root=동일한 소스 루트에서 테스트를 생성하시겠어요?
test.integration.message.text.kotlin.class=Kotlin 클래스 ''{0}''이(가) 이미 있습니다. 업데이트하시겠어요?
test.integration.title.no.test.roots.found=테스트 루트를 찾을 수 없음
test.result.log.file.will.be.placed.here=테스트 결과 로그 파일이 여기에 배치됩니다
text.0.1.must.be.moved.with.sealed.parent.class.and.all.its.subclasses={0} ''{1}''은(는) 봉인된 상위 클래스 및 모든 하위 클래스와 함께 이동해야 합니다.
text.0.already.contains.1={0}에 {1}이(가) 이미 포함되어 있습니다.
text.0.already.contains.nested.class.1=이름이 {1}인 중첩된 클래스가 {0}에 이미 포함되어 있습니다.
text.0.already.declared.in.1={0}이(가) {1}에 이미 정의되어 있습니다.
text.0.have.no.inheritors.warning={0}에 상속자가 없습니다.\n멤버를 아래로 이동하면 해당 멤버가 삭제됩니다. 계속하시겠어요?
text.0.in.1.will.override.corresponding.member.of.2.after.refactoring={0}의 {1}이(가) 리팩터링 후에 {2}의 멤버를 재정의합니다.
text.0.inherits.from.1.it.will.not.be.affected.by.refactoring={0}이(가) {1}에서 상속됩니다.\n이는 리팩터링의 영향을 받지 않습니다.
text.0.is.invalid.destination.package=''{0}''은(는) 잘못된 대상 패키지 이름입니다.
text.0.is.not.allowed.in.the.target.context=''{0}''은(는) 인터페이스에서 허용되지 않습니다
text.0.is.not.valid.package.name={0} 은(는) 유효한 패키지 이름이 아닙니다.
text.0.to.inline=인라인화할 {0}
text.0.uses.1.which.is.not.accessible.from.2={0}이(가) {2}에서 액세스할 수 없는 {1}을(를) 사용합니다.
text.0.uses.1.which.will.be.inaccessible.after.move={0}이(가) 이동 후에 액세스할 수 없게 되는 {1}을(를) 사용합니다.
text.0.uses.1.which.will.not.be.accessible.from.subclass={0}이(가) 하위 클래스에서 액세스할 수 없게 되는 {1}을(를) 사용합니다.
text.0.uses.internal.1.which.will.be.inaccessible.after.move={0}이(가) 이동 후에 액세스할 수 없게 되는 내부 {1}을(를) 사용합니다.
text.0.will.be.shadowed.by.1={0}이(가) {1}으로 그림자화됩니다.
text.0.will.clash.with.existing.1.in.2=이름을 변경하면 {0}이(가) {2}의 기존 {1}와(과) 충돌합니다.
text.0.will.no.longer.be.accessible.after.signature.change={0} 은(는) 시그니처 변경 후에 액세스할 수 없게 됩니다.
text.Assignment=대입
text.Function=함수
text.Name=이름
text.Package=패키지
text.Property=프로퍼티
text.Return=반환
text.abstract=추상
text.add.getter=getter 추가
text.add.getter.and.setter=getter 및 setter 추가
text.add.setter=setter 추가
text.add.use.site.target.0=사용 사이트 대상 ''{0}'' 추가
text.all.declarations.must.belong.to.the.same.directory.or.class=모든 선언은 동일한 디렉터리 또는 클래스에 속해야 합니다.
text.annotation=어노테이션
text.annotation.class=어노테이션 클래스
text.anonymous=[익명]
text.anonymous.function=익명 함수
text.at.least.one.file.must.be.selected=하나 이상의 멤버를 선택해야 합니다.
text.callee.text.would.be.shown.here=피호출자 텍스트가 여기에 표시됩니다.
text.caller.text.with.highlighted.callee.call.would.be.shown.here=피호출자 호출이 강조 표시된\n호출자 텍스트가 여기에 표시됩니다.
text.can=할 수 있습니다
text.cannot.create.target.directory.0=대상 디렉터리 {0}을(를) 생성할 수 없습니다.
text.cannot.determine.source.directory=소스 디렉터리를 확인할 수 없습니다.
text.cannot.find.package.corresponding.to.0={0}에 해당하는 해당 패키지를 찾을 수 없습니다.
text.cannot.find.target.package.name=대상 패키지 이름을 찾을 수 없습니다.
text.cannot.inline.reference.from.0.to.1=참조를 {0}에서 {1}(으)로 인라인화할 수 없습니다
text.cannot.move.expect.actual.declaration.to.file=기대/실제 선언을 파일로 이동하지 못했습니다
text.cannot.move.for.current.project=현재 프로젝트에 대해 이동할 수 없습니다.
text.cannot.move.inner.class.0.into.itself=중첩된 클래스 {0}을(를) 그 자체 내에 이동할 수 없습니다.
text.cannot.move.to.original.file=원본 파일로 이동할 수 없습니다.
text.change.file.package.to.0=파일의 패키지를 ''{0}''(으)로 변경합니다.
text.choose.containing.file=포함 파일을 선택합니다.
text.class=클래스
text.class.0={0,choice,1#클래스|2#클래스}
text.class.0.already.contains.member.1={0}에 {1}이(가) 이미 포함되어 있습니다.
text.class.0.already.exists.in.package.1=클래스 {0}에 패키지 {1}이(가) 이미 있습니다.
text.class.0.already.exists.in.the.target.scope=클래스 {0}이(가) 대상 범위에 이미 있습니다.
text.class.0.is.final={0}이(가) final입니다.
text.constructor=생성자
text.convert._it_.to.explicit.lambda.parameter=''it''을 명시적 람다 매개변수로 변환합니다.
text.create=생성
text.create.destructuring.declaration=구조 분해 선언을 생성합니다.
text.create.single.variable=단일 변수를 생성합니다.
text.declaration=선언
text.declarations.clash.move.0.destination.1.declared.in.scope.2=다음 선언이 충돌합니다. 범위 {2}에서 선언된 {0} 및 대상 {1}을(를) 이동합니다.
text.default.value=\ // 디폴트 값 \={0}
text.destination.class.should.be.kotlin.class=대상 클래스가 Kotlin 클래스여야 합니다.
text.do.you.want.to.rename.0.as.well={0}()의 이름도 변경하시겠어요?
text.do.you.want.to.rename.base.property=기본 프로퍼티의 이름을 변경하시겠어요?
text.do.you.want.to.rename.base.property.from.0={0}에서 기본 프로퍼티의 이름을 변경하시겠어요?
text.done=완료
text.duplicating.local.variable=지역 변수 ''{0}'' 중복
text.duplicating.parameter=매개변수 ''{0}'' 중복
text.duplicating.property=프로퍼티 ''{0}'' 중복
text.enum=enum
text.enum.class=열거형 클래스
text.enum.constant=열거형 상수
text.explicit.receiver.is.already.present.in.call.element.0=명시적 리시버가 호출 요소에 이미 있습니다. {0}
text.extend=확장
text.extension=확장
text.extension.function=확장 함수
text.extension.function.0=확장 {0,choice,1#함수|2#함수}
text.extension.property=확장 프로퍼티
text.extension.property.0=확장 {0,choice,1#프로퍼티|2#프로퍼티}
text.extract.superclass=상위 클래스 추출
text.file.0.already.exists.in.1=파일 {0}이(가) {1}에 이미 있습니다.
text.file.name.cannot.be.empty=파일 이름이 비어 있지 않을 수 있습니다.
text.function=함수
text.function.0={0,choice,1#함수|2#함수}
text.function.already.exists=함수가 이미 있습니다. ''{0}''
text.function.in.ticks.0=함수 ''{0}''
text.getter=getter
text.implement=구현
text.implements=구현
text.implicit.companion.object.will.be.inaccessible.0=묵시적 컴패니언 객체에 액세스할 수 없게 됩니다. {0}
text.incorrect.target.path.directory.0.does.not.belong.to.current.project=잘못된 대상 경로입니다. 디렉터리 {0} 은(는) 현재 프로젝트에 속해 있지 않습니다.
text.indirect.outer.instances.will.not.be.extracted.0=간접 외부 인스턴스는 추출되지 않습니다. {0}
text.initializer=초기자
text.inline.0={0} 인라인화
text.inline.all.references.and.verb.0.the.kind.1.occurrences.2=모든 참조를 인라인화하고 {1} {2}을(를) {0}
text.inline.recursive.function.is.supported.only.on.references=재귀 함수 인라인화는 참조에서만 지원됩니다.
text.inline.this.reference.and.keep.the.0=이 참조를 인라인화하고 {0} 을(를) 유지합니다
text.inlined.0.overrides.0.1=인라인화된 {0}이(가) {0} {1}을(를) 재정의합니다
text.inlining.0.1={0} {1} 인라인화
text.inner.class.0.cannot.be.moved.to.interface={0}은(는) 내부 클래스이므로 인터페이스로 이동할 수 없습니다
text.interface=인터페이스
text.introduce.default.value=디폴트 값 삽입(&D)
text.invalid.target.path.0=잘못된 대상 경로 {0}
text.invalid.target.specified=잘못된 대상 지정
text.keep=유지
text.lambda.parameter=람다 매개변수
text.lambda.parameters=람다 매개변수(&P)\:
text.lambda.return.type=람다 반환 유형(&T)
text.lazy.property=지연 프로퍼티
text.local.property=프로퍼티
text.local.variable=지역 변수
text.looking.for.usages=사용 위치 검색 중
text.member=구성원
text.member.0.in.super.class.will.clash.with.existing.member.of.1=상위 클래스의 {0}(가) {1}의 기존 멤버와 충돌합니다.
text.member.extension.call.will.not.be.processed.0=멤버 확장 호출이 처리되지 않습니다. {0}
text.move.declaration.no.support.for.companion.objects=선언 이동은 컴패니언 객체에 지원되지 않습니다.
text.move.declaration.no.support.for.enums=선언 이동은 열거형 항목에 지원되지 않습니다.
text.move.declaration.proceed.move.without.mpp.counterparts.text=이 리팩터링을 수행하면 선택한 선언을 기대/실제 대응 항목 없이 이동하므로 컴파일 오류가 발생할 수 있습니다.\n계속 진행하시겠어요?
text.move.declaration.proceed.move.without.mpp.counterparts.title=이 리팩터링에서 MPP 선언 지원 안 됨
text.move.declaration.supports.only.top.levels.and.nested.classes=선언 이동은 최상위 선언 및 중첩된 클래스에만 지원됩니다.
text.move.declarations=선언 이동
text.move.file.0={0} 이동
text.move.method.is.not.supported.for.generic.classes=move 메서드는 제네릭 클래스에 지원되지 않습니다
text.move.method.is.not.supported.for.non.project.methods=move 메서드는 비 프로젝트 메서드에 지원되지 않습니다
text.move.method.is.not.supported.when.method.is.a.part.of.inheritance.hierarchy=move 메서드는 메서드가 상속 계층 구조의 일부인 경우 지원되지 않습니다
text.move.refactoring.not.available.during.indexing=색인 생성이 진행되는 동안 이동 리팩터링을 사용할 수 없습니다.
text.moving.multiple.nested.classes.to.top.level.not.supported=여러 중첩된 클래스를 최상위 수준으로 이동하는 것은 지원되지 않습니다.
text.name=이름
text.nested.classes.to.upper.level=중첩된 클래스에서 상위 수준으로
text.no.destination.object.specified=대상 객체가 지정되지 않았습니다
text.no.elements.to.move.are.selected=이동할 요소가 선택되지 않았습니다.
text.no.files.to.move=이동하도록 지정된 파일이 없습니다.
text.no.name.provided.for.type.alias=유형 별칭에 제공된 이름이 없습니다.
text.no.package.corresponds.to.directory=이 디렉터리에 해당하는 패키지가 없습니다.
text.non.kotlin.0.will.not.be.affected.by.refactoring=Kotlin이 아닌 {0} 은(는) 리팩터링의 영향을 받지 않습니다.
text.object=객체
text.object.0={0,choice,1#객체|2#객체}
text.operator.0={0,choice,1#연산자|2#연산자}
text.overload=오버로드
text.overrides=재정의
text.package.directive.dont.match.file.location=패키지 지시문이 파일 위치와 일치하지 않습니다.
text.parameter=매개변수
text.parameter.0=Parámetro ''{0}''
text.parameter.name=매개변수 이름(&N)\:
text.parameter.reference.can.t.be.safely.replaced.with.0.since.1.is.ambiguous.in.this.context={1}이(가) 이 컨텍스트에서 모호하여 매개변수 참조를 {0}(으)로 안전하게 바꿀 수 없습니다.
text.parameter.reference.can.t.be.safely.replaced.with.0.since.target.function.can.t.be.referenced.in.this.context=대상 함수를 이 컨텍스트에서 참조할 수 없으므로 매개변수 참조를 {0}(으)로 안전하게 바꿀 수 없습니다.
text.parameter.type=매개변수 유형(&T)\:
text.parameters=&Parámetro\:
text.part=부분
text.pattern=패턴
text.primary=기본
text.primary.constructor=기본 생성자
text.proceed.with.extraction=추출 진행
text.process.duplicates=프로세스 중복
text.processing.file.0={0} 처리 중
text.property=프로퍼티
text.property.0={0,choice,1#프로퍼티|2#프로퍼티}
text.property.in.ticks.0=프로퍼티 ''{0}''
text.property.with.getter=getter가 있는 프로퍼티
text.property.with.initializer=이니셜라이저가 있는 프로퍼티
text.pushed.member.will.not.be.available.in.0=푸시된 멤버는 ''{0}''에서 사용할 수 없게 됩니다.
text.qualified.call.will.not.be.processed.0=정규화된 호출은 처리되지 않습니다. {0}
text.receiver=리시버
text.receiver.can.t.be.safely.transformed.to.value.argument=리시버는 값 인수로 안전하게 변환할 수 없습니다. {0}
text.refactoring.can.t.be.performed.on.the.selected.code.element=선택한 코드 요소에서 리팩터링을 수행할 수 없습니다.
text.refactoring.is.not.applicable.to.this.code.fragment=이 코드 조각에는 리팩터링이 적용되지 않습니다.
text.reference.cannot.be.converted.to.a.lambda=참조는 람다로 변환할 수 없습니다
text.references.in.code.to.0.1.and.its.declarations={0} {1} 및 해당 선언에 대한 코드 내 참조
text.references.to.outer.classes.have.to.be.added.manually=외부 클래스에 대한 참조는 이동 후 수동으로 추가해야 합니다
text.remove=Eliminar
text.remove.0.no.longer.used=더 이상 사용되지 않는 {0}을(를) 제거합니다.
text.remove.question=\ ''?'' 제거
text.rename.as.part.of.phrase=이름 바꾸기
text.rename.is.not.applicable.to.secondary.constructors=이름 변경은 보조 생성자에는 적용되지 않습니다.
text.rename.is.not.applicable.to.synthetic.declarations=이름 변경은 통합 선언에 적용되지 않습니다.
text.rename.not.applicable.to.backing.field.reference=이름 변경은 백킹 필드 참조에 적용되지 않습니다.
text.rename.not.applicable.to.dynamically.invoked.methods=시그니처 변경은 동적으로 호출된 멤버에 적용되지 않습니다.
text.rename.overloads.title=오버로드 이름 변경
text.rename.parameters.title=매개변수 이름 변경
text.return=리턴
text.sealed.broken.hierarchy.none.in.target=''{0}''의 sealed 계층 구조가 분할됩니다. 모듈 ''{2}''의 패키지 ''{1}''에 멤버가 하나도 없습니다. {3}.
text.sealed.broken.hierarchy.still.in.source=''{0}''의 sealed 계층 구조가 분할됩니다. 모듈 ''{2}''의 패키지 ''{1}''에 멤버가 여전히 포함됩니다. {3}
text.sealed.class.0.must.be.moved.with.all.its.subclasses=봉인된 클래스 ''{0}''은(는) 모든 하위 클래스와 함께 이동해야 합니다.
text.secondary=보조
text.secondary.constructor=보조 생성자
text.select.target.code.block=대상 코드 블록을 선택합니다.
text.select.target.code.block.file=대상 코드 블록/파일을 선택합니다.
text.select.target.file=대상 파일을 선택합니다.
text.setter=setter
text.should=해야 합니다
text.there.is.already.a.parameter={1}에 매개변수 ''{0}''이(가) 이미 있으므로 새 매개변수와 충돌하게 됩니다.
text.there.is.already.a.variable.0.in.1.it.will.conflict.with.the.new.parameter={1}에 변수 ''{0}''이(가) 이미 있으므로 새 매개변수와 충돌하게 됩니다.
text.type=유형
text.type.alias=유형 별칭
text.type.alias.cannot.refer.to.types.which.aren.t.accessible.in.the.scope.where.it.s.defined=유형 별칭은 정의된 범위에서 액세스할 수 없는 유형을 참조할 수 없습니다.
text.type.alias.name.must.be.a.valid.identifier.0=유형 별칭 이름은 유효한 식별자여야 합니다. {0}
text.type.already.exists.in.the.target.scope=유형 {0}이(가) 대상 범위에 이미 있습니다.
text.type.parameter=유형 {0, choice, 0\#매개변수|2\#매개변수}
text.type.parameter.names.must.be.distinct=유형 매개변수 이름은 고유해야 합니다.
text.type.parameters=유형 매개변수(&P)
text.unexpected.element.type.0=예기치 않은 요소 유형\: {0}
text.update.usages.to.reflect.declaration.0.move={0, choice, 0\#선언|1\#선언}을 반영하도록 사용 위치를 업데이트합니다.
text.updating.usages.progress=사용 위치 업데이트 중...
the.anonymous.object=익명 객체
the.declaration.has.0.modifier=선언에 ''{0}'' 제어자가 있습니다
the.function.declaration.shouldn.t.have.a.default.implementation=함수 선언에 기본 구현이 없어야 합니다.
there.are.possible.side.effects.found.in.expressions.assigned.to.the.variable.0=변수 ''{0}에 대입된 표현식에서 잠재적 부작용이 발견되었습니다.<br>문제를 해결하려면 다음을 수행하세요.<br>-\\&nbsp;전체 대입을 <b>제거</b><br>-\\&nbsp;오른쪽 대입을 자체 내의 구문으로 <b>변환</b><br>
there.is.own.replacewith.on.0.that.is.used.through.this.alias.please.replace.usages.first=이 별칭을 통해 사용되는 ''{0}''에 고유한 ''ReplaceWith''가 있습니다. 먼저 사용 위치를 바꾸세요.
these.declarations.cannot.be.transformed=이 선언은 변환할 수 없습니다.
this.call.is.useless.with=이 호출은 ?.를 사용하면 필요 없습니다.
this.property.conflicts.with.synthetic.extension.and.should.be.removed.or.renamed.to.avoid.breaking.code.by.future.changes.in.the.compiler=이 속성은 통합 확장과 충돌하므로 컴파일러에서 향후 변경으로 인해 코드가 손상되지 않도록 하려면 해당 프로퍼티를 제거하거나 이름을 변경해야 합니다.
this.range.is.empty=이 범위는 비어 있습니다.
this.range.is.empty.did.you.mean.to.use.0=이 범위는 비어 있습니다. ''{0}''을(를) 사용하려고 하셨나요?
this.type.probably.can.be.changed.to.nullable=이 유형은 null 가능으로 변경할 수 있습니다.
this.when.is.simplifiable=이 ''when''을 단순화할 수 있습니다.
throwable.instance.0.is.not.thrown=던지기 가능한 인스턴스 ''{0}''이(가) 던져지지 않습니다.
titile.not.found=찾을 수 없음
title.choose.destination.object=대상 객체 선택
title.choose.logger.factory.class=로거 factory 클래스 선택
title.choose.use.site.target=사용 위치 타깃 선택
title.done=완료
title.error=Error
title.import.layout=레이아웃 가져오기
title.inline.function=인라인 함수
title.inline.property=인라인 프로퍼티
title.inline.type.alias=유형 별칭 인라인화
title.introduce.parameter.to.declaration=선언에 매개변수를 삽입합니다.
title.kdoc.for.abstracts=Abstract에 대한 KDoc
title.lateinit.var.overrides.lateinit.var='lateinit var'가 상위 'lateinit var'를 재정의합니다
title.logger.factory.class.name=로거 factory 클래스 이름
title.logger.factory.method.name=로거 factory 메서드 이름
title.move.method=move 메서드
title.move.nested.classes.to.upper.level=중첩된 클래스에서 상위 수준으로 이동
title.packages.to.use.import.with=''*''가 포함된 import 문을 사용하는 패키지
title.parameters=매개 변수
title.rename.overloads.to=오버로드 이름을 다음으로 변경:
title.rename.warning=이름 변경 경고
title.select.a.name.for.this.parameter=''this@{0}'' 매개변수의 이름 선택
title.select.target.code.block=대상 코드 블록 선택
title.success=Correcto
to.fully.qualified.name=대상 (정규화된 이름)\:
tooltip.implements.function=다음에서 함수 구현:
tooltip.implements.property=다음에서 프로퍼티 구현:
tooltip.is.implemented.by=다음에 의해 구현됨
tooltip.is.subclassed.by=다음의 하위 클래스가 됨
tooltip.overrides.function=다음에서 함수 재정의:
tooltip.overrides.property=다음에서 프로퍼티 재정의:
top.level=최상위
two.comparisons.should.be.converted.to.a.range.check=두 개의 비교 항목을 범위 검사로 변환해야 합니다.
type.0.1.is.not.accessible.from.target.module=대상 모듈에서 {0, choice, 0\#유형|2\#유형} {1}에 액세스할 수 없습니다.
type.alias.0=유형 별칭 "{0}"
type.arguments.will.be.lost.after.conversion.0=변환하면 유형 인수가 손실됩니다. {0}
type.parameter.0=유형 매개변수 "{0}"
type.parameter.can.have.0.variance=유형 매개변수에 {0} 분산이 있어야 합니다.
type.provider.anonymous.object=Objeto anónimo
type.provider.no.expression.found=Expresión no encontrada
type.provider.smart.cast.from=(transmisión inteligente de {0})
type.provider.unknown.type=Tipo desconocido
unclear.precedence.of.binary.expression.inspection=표현식에 명확히 구분 짓는 소괄호를 사용해야 합니다
unclear.precedence.of.binary.expression.inspection.display.name=우선 순위가 다른 여러 연산자
unclear.precedence.of.binary.expression.quickfix=명확히 구분 짓는 소괄호 추가
unclear.precedence.of.binary.expression.report.even.obvious.cases.checkbox=매우 명백한 사례 보고
unknown.types.title=알 수 없는 타입
unlabeled.return.inside.lambda=람다 내부의 라벨 지정되지 않은 반환
unrecognized.reference.will.be.skipped.0=인식되지 않는 참조는 건너뛰기됩니다. {0}
unsupported.usage.0=지원되지 않는 사용 위치\: {0}
until.can.be.replaced.with.rangeUntil.operator='until'은 '..<' 연산자로 바꿀 수 있습니다
unused.equals.expression=사용되지 않는 equals 식
unused.import.directive=사용되지 않는 import 지시문
unused.return.value.of.a.function.with.lambda.expression.body=람다 식 본문이 있는 함수의 사용되지 않는 반환값
unused.unary.operator=사용되지 않는 단항 연산자
unwrap.else=Desenvolver más en ''{0}''.
unwrap.expression=''{0}'' desenvolver
unwrap.parameter=''{0}'' arg ''{1}'' 래핑 해제
update.indices=색인 업데이트...
update.obsolete.label.syntax=사용되지 않는 라벨 구문을 업데이트합니다.
usage.of.kotlin.internal.declaration.from.different.module=다른 모듈의 Kotlin 내부 선언 사용 위치
usage.of.redundant.or.deprecated.syntax.or.deprecated.symbols=중복되거나 사용되지 않는 구문 또는 사용되지 않는 심볼의 사용 위치
usage.provider.text.property.of.0={1} 중 {0}
usage.provider.text.unnamed=<이름이 지정되지 않음>
usages.of.outer.class.instance.inside.of.property.0.won.t.be.processed=프로퍼티 ''{0}'' 내부에 있는 외부 클래스 인스턴스의 사용 위치가 처리되지 않습니다
use.destructuring.declaration=구조 분해 선언 사용
use.expression.body.instead.of.0={0} 대신 표현식 본문을 사용합니다.
use.inherited.visibility=상속된 가시성을 사용합니다.
use.of.getter.method.instead.of.property.access.syntax=프로퍼티 액세스 구문 대신 getter 메서드 사용
use.of.non.const.kotlin.property.as.java.constant.is.incorrect.will.be.forbidden.in.1.4=상수가 아닌 Kotlin 프로퍼티를 Java 상수로서 사용하는 것은 올바르지 않으며 1.4에서 금지됩니다.
use.of.setter.method.instead.of.property.access.syntax=프로퍼티 액세스 구문 대신 setter 메서드 사용
use.property.access.syntax=프로퍼티 액세스 구문 사용
use.property.access.syntax.option.report.non.trivial.accessors=자명하지 않은 접근자 보고
use.withindex.instead.of.manual.index.increment=수동 색인 증분 대신 withIndex() 사용
useless.call.on.collection.type=컬렉션 유형에 대한 불필요한 호출
useless.call.on.not.null.type=null이 아닌 유형에 대한 불필요한 호출
variable.0.is.assigned.to.itself=''{0}'' 변수는 자체 할당됩니다.
variable.declaration.could.be.inlined=변수 선언을 인라인화할 수 있습니다.
variable.declaration.could.be.moved.into.when=변수 선언을 ''when''으로 이동할 수 있습니다.
variable.is.never.modified.and.can.be.declared.immutable.using.val=변수는 한정되지 않으며 ''val''을 사용하여 불변으로 선언할 수 있습니다.
variable.is.same.as.0.and.should.be.inlined=변수가 ''{0}''와(과) 동일하고 인라인화되어야 합니다.
variable.name.0.matches.the.name.of.a.different.component=변수 이름 ''{0}''이(가) 다른 구성 요소의 이름과 일치합니다.
variable.used.only.in.following.return.and.should.be.inlined=변수가 다음 반환에서만 사용되고 인라인화되어야 합니다.
vcs.code.author=Kotlin: 코드 작성자에 대한 인레이 힌트 표시
version={버전}
visibility=가시성(&V)\:
when.has.only.else.branch.and.should.be.simplified=''when''에 ''else'' 브랜치만 있으므로 단순화해야 합니다.
when.with.subject.should.be.used=대상이 있는 ''when''을 사용해야 합니다.
wrap.argument.with.parentheses=소괄호로 인수 래핑
wrap.element.with.0.call=요소를 ''{0}()'' 호출로 래핑합니다.
wrap.expression.in.parentheses=표현식을 소괄호로 감쌉니다
wrap.run.fix.text={... }을(를) 실행하도록 변환합니다.
wrap.unary.operator.quickfix.text=단항 연산자와 값을 ()로 래핑합니다.
wrap.with=[]으로 래핑합니다.
wrap.with.array.literal=배열 리터럴로 래핑합니다.
wrap.with.collection.literal.call=컬렉션 리터럴 호출로 래핑합니다.
wrap.with.coroutine.scope.fix.family.name=coroutineScope로 래핑
wrap.with.coroutine.scope.fix.text=''coroutineScope {... }''로 함수 본문을 래핑합니다.
wrap.with.coroutine.scope.fix.text2=''coroutineScope {... }''로 호출을 래핑합니다.
wrap.with.coroutine.scope.fix.text3=리시버를 제거하고 ''coroutineScope {... }''로 래핑합니다.
wrap.with.let.call=''?.let {... }'' 호출로 래핑합니다.
