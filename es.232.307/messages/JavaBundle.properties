abstract.class.not.allowed=La clase abstracta no está permitida
access.static.via.instance=Acceder al miembro estático a través de la referencia de instancia
accessible.name.change.modifier=제어자 변경
action.GotoSuperClass.MainMenu.text=clas_e alta
action.GotoSuperClass.description=Vaya a la declaración de la clase que la clase actual extiende o implementa
action.GotoSuperClass.text=Ir a la clase padr_e
action.analyzing.cyclic.dependencies.in.scope=Dependencias cíclicas de {0}
action.create.new.class=Nueva clase Java
action.create.new.class.description=Crear nueva clase Java
action.create.new.module-info.description=Crear nuevo módulo-info.java
action.create.new.module-info.title=module-info.java
action.create.new.package-info.description=Crear nuevo paquete-info.java
action.create.new.package-info.title=package-info.java
action.cyclic.dependency.title=Análisis de dependencia cíclica
action.description.copy.whole.thread.dump.to.clipboard=Copiar el volcado de hilo completo al portapapeles
action.description.group.by.scope=Agrupar por tipo de alcance (producción, prueba, bibliotecas)
action.description.group.threads.with.identical.stacktraces=Agrupar subprocesos con stacktraces idénticos
action.description.infer.nullity.annotations=Inferir anotaciones de nulidad
action.description.mark.directory.as.a.0.for.generated.files=Marcar directorio como {0} para archivos generados
action.description.mark.directory.as.an.ordinary.0=Marcar directorio como un {0} ordinario
action.description.show.only.threads.containing.a.specific.string=Mostrar solo los hilos que contienen una cadena específica
action.dfa.from.stacktrace.text=Encuentre por qué ''{0}'' podría ser {1}
action.expand.static.import.text=static expande la declaración de importación
action.find.similar.stack.call.diverged=줄 번호가 분기되었을 수 있습니다. ''{0}.{1}()'' 내에서 현재 위치를 찾아보세요
action.find.similar.stack.call.location.not.found=''{0}.{1}()'' 내에 유사한 위치가 없습니다
action.find.similar.stack.call.methods=''{0}.{1}()''와 유사한 메서드
action.find.similar.stack.call.methods.not.found=''{0}.{1}()''와(과) 유사한 메서드가 없습니다
action.find.similar.stack.call.similar.calls=''{0}.{1}()'' 내 가능한 위치
action.go.to.implementation.text=Ir a implementación
action.go.to.overriding.methods.text=Ir al método de reemplazo
action.go.to.subclass.text=Ir a la subclase
action.go.to.super.method.text=Ir al método principal
action.group.by.package=Paquete
action.group.by.scope.type=Agrupar por tipo de alcance
action.implement.method=Implementar método
action.implement.methods=Implementar métodos
action.override.method=Método de anulación
action.override.methods=Anular métodos
action.sort.by.percent.classes.which.overrides.method.description=Ordenar por porcentaje de clases que anulan métodos
action.sort.by.percent.classes.which.overrides.method.text=Ordenar por porcentaje de clases que reemplazan métodos
action.text.0.on.parameter.1={0} en el parámetro ''{1}''
action.text.choose.class.in.0=elegir clase en {0}...
action.text.copy.to.clipboard=Copiar al portapapeles
action.text.edit.template=Editar plantilla
action.text.enter.class.name=ingrese el nombre de la clase...
action.text.generated.root.0=Generado {0}
action.text.merge.identical.stacktraces=Combinar Stacktraces idénticos
action.text.show.methods.to.implement=Mostrar métodos para implementar
action.text.unmark.generated.0=Desmarcar generado {0}
action.title.infer.nullity.annotations=nullability 어노테이션 추론
add.methods.dialog.or=\ o
add.to.permits.list=Agregar ''{0}'' a la lista de permisos para la clase sellada ''{1}''
add.to.permits.list.family.name=permits 목록에 클래스 추가
adds.ext.library.preview=라이브러리 ''{0}''을(를) 모듈 ''{1}''에 추가
adds.ext.library.preview.import=모듈 ''{1}''의 종속성에 라이브러리 ''{0}''을(를) 추가하고 ''{2}''을(를) 가져옵니다
adds.library.preview={0, choice, 1#라이브러리 ''''{1}''''을(를)|2#{2} 중 하나를} 모듈 ''{3}''의 종속성에 추가하고 미해결 ''{4}''을(를) 가져옵니다
adds.library.preview.no.import={0, choice, 1#라이브러리 ''''{1}''''을(를)|2#{2} 중 하나를} 모듈 ''{3}''의 종속성에 추가합니다
adds.module.dependencies.preview={0, choice, 1#모듈 ''''{1}''''을(를)|2#{2} 중 하나를} 모듈 ''{3}''의 종속성에 추가하고 미해결 클래스를 가져옵니다
advanced.setting.code.vision.java.minimal.usages=Code Vision: 인레이 힌트를 표시하기 위해 필요한 최소 사용 위치
advanced.setting.compiler.automake.allow.when.app.running=개발된 애플리케이션이 현재 실행 중인 경우에도 auto-make가 시작되도록 허용
advanced.setting.compiler.automake.allow.when.app.running.description=자동 시작된 make는 결과적으로 애플리케이션에 필요한 일부 클래스를 삭제할 수도 있습니다
advanced.setting.compiler.lower.process.priority=낮은 우선순위로 컴파일 실행
advanced.setting.compiler.lower.process.priority.description=외부 JPS 프로세스를 Windows에서 IDLE 우선순위로, Linux/macOS에서 nice level 10으로 실행
advanced.settings.group.compiler=컴파일러
advanced.settings.group.java=Java
align.types.in.multi.catch=여러 catch의 타입 정렬
annotate.intention.chooser.title=Elija la anotación para agregar
annotation.types.cannot.be.inlined=Los tipos de anotaciones no se pueden insertar
assignment.array.element.to.itself.problem.descriptor=배열 요소가 자기 대입됨
assignment.to.declared.variable.problem.descriptor=La variable ''{0}'' se inicializa con autoasignación
assignment.to.itself.problem.descriptor=La variable ''{0}'' se asigna a sí misma
assignment.to.itself.quickfix.name=Eliminar autoasignación
base.package.parameter.wizard.label=& paquete base\:
base.package.project.wizard.error.x.not.valid.package={0} no es un nombre de paquete válido
bean.property=Propiedad Bean
boolean.method.is.always.inverted.display.name=El método booleano siempre está invertido
boolean.method.is.always.inverted.problem.descriptor=El método booleano <code>#ref</code> siempre está invertido
button.add=추가...
button.add.blank=Agregar espacio en blanco
button.add.class=Agregar clase...
button.add.dependency=Agregar dependencia
button.add.package=Agregar paquete
button.add.pattern=Agregar patrón...
button.annotations=Anotaciones...
button.base.method=&Método base
button.code.patterns=Patrones de código...
button.current.method=&Método actual
button.text.settings=Configuración...
button.to.another.directory=대상 디렉터리(&D)
button.to.another.source.root=대상 소스 루트(&S)
caller.chooser.referenced.code.title=código referenciado
cast.expression=expresión de conversión
cast.to.0=Transmitir a ''{0}''
change.color.command.text=Cambiar color
change.signature.from.usage.short.name=<html>Cambiar la firma de {0} ({1})</html>
change.uid.action.name=Cambiar aleatoriamente el inicializador 'serialVersionUID'
checkbox.after.description=Después de la descripción
checkbox.after.parameter.descriptions=Después de las descripciones de los parámetros
checkbox.after.return.tag=Después de la etiqueta de devolución
checkbox.align.parameter.descriptions=Alinear descripciones de parámetros
checkbox.align.thrown.exception.descriptions=Alinear descripciones de excepciones lanzadas
checkbox.annotate.local.variables=Anotar variables locales
checkbox.collapse.annotations=Anotaciones
checkbox.collapse.anonymous.classes=Clases anónimas
checkbox.collapse.closures="Closures" (clases anónimas que implementan un método, antes de Java 8)
checkbox.collapse.end.of.line.comments=Secuencia de comentarios al final de la línea
checkbox.collapse.generic.constructor.parameters=Constructor genérico y parámetros de método
checkbox.collapse.i18n.messages=Cadenas I18n
checkbox.collapse.inferred.type=Reemplazar 'var' con el tipo inferido
checkbox.collapse.inner.classes=Clases internas
checkbox.collapse.multiline.comments=Comentarios de varias líneas
checkbox.collapse.one.line.methods=Métodos de una línea
checkbox.collapse.simple.property.accessors=Accesores de propiedad simples
checkbox.collapse.suppress.warnings=@SuppressWarnings
checkbox.comments.and.javadoc.count.as.content=Los comentarios y javadoc cuentan como contenido
checkbox.declare.var.type=지역 변수 선언에 'var' 사용
checkbox.deprecated.members=Miembros obsoletos
checkbox.do.not.indent.top.level.class.members=No sangra a los miembros de la clase de nivel superior
checkbox.do.not.wrap.after.single.annotation=No ajustar después de una sola anotación
checkbox.do.not.wrap.one.line.comments=No envuelva comentarios de una línea
checkbox.don.t.warn.in.case.of.multiline.lambda='List.replaceAll()'의 매개변수가 여러 줄의 람다인 경우 경고하지 않음
checkbox.enable.javadoc.formatting=Habilitar el formato JavaDoc
checkbox.enable.leading.asterisks=Habilitar asteriscos iniciales
checkbox.generate.p.on.empty.lines=Generar "<p>" en líneas vacías
checkbox.html.report.inaccessible.symbols=<html>Informar símbolos inaccesibles<br>(es posible que la herramienta javadoc no pueda crear hipervínculos)
checkbox.ignore.chains=체인화 가능한 메서드 무시
checkbox.ignore.fields.used.in.multiple.methods=Ignorar los campos utilizados en varios métodos
checkbox.insert.imports.for.inner.classes=Insertar importaciones para clases internas
checkbox.iterate.unknown.stream.sources.via.stream.iterator=Iterar fuentes de Stream desconocidas a través de Stream.iterator()
checkbox.keep.empty.lines=Mantener líneas vacías
checkbox.keep.empty.param.tags=Mantener las etiquetas @param vacías
checkbox.keep.empty.return.tags=Mantener las etiquetas @return vacías
checkbox.keep.empty.throws.tags=Mantener las etiquetas @throws vacías
checkbox.keep.invalid.tags=Mantener etiquetas inválidas
checkbox.make.generated.local.variables.final=Hacer definitivas las variables locales generadas
checkbox.make.generated.parameters.final=Hacer que los parámetros generados sean finales
checkbox.param.description.on.new.line=Descripciones de parámetros en la nueva línea
checkbox.param.indent.on.continuation=Sangrar las líneas de continuación
checkbox.prefer.longer.names=Prefiere nombres más largos
checkbox.preserve.line.feeds=Conservar los avances de línea
checkbox.spaces.around.annotation.eq=어노테이션 값 쌍 내의 '=' 주변
checkbox.spaces.before.colon.in.foreach=Antes de dos puntos en foreach
checkbox.spaces.before.deconstruction.list=구조 분해 목록
checkbox.spaces.inside.one.line.enum=Dentro de una línea enum llaves
checkbox.spaces.record.header=Encabezado de registro
checkbox.spaces.within.deconstruction.list=구조 분해 목록
checkbox.suggest.conversion.to.map.computeifabsent=Sugerir conversión a Map.computeIfAbsent
checkbox.suggest.conversion.to.map.getordefault=Sugerir conversión a Map.getOrDefault
checkbox.suggest.conversion.to.map.merge=Sugerir conversión a Map.merge
checkbox.suggest.conversion.to.map.putifabsent=Sugerir conversión a Map.putIfAbsent
checkbox.suggest.conversion.to.map.replaceall=Sugerir conversión a Map.replaceAll
checkbox.suggest.replacement.even.if.lambda.may.have.side.effects=Sugerir reemplazo incluso si lambda puede tener efectos secundarios
checkbox.suppress.with.suppresswarnings=Suprimir con @SuppressWarnings
checkbox.treat.get.k.null.the.same.as.containskey.k.may.change.semantics=Trate 'get (k)!=null' igual que 'containsKey (k)' (puede cambiar la semántica)
checkbox.use.fully.qualified.class.names=Use nombres de clase completamente calificados
checkbox.use.single.class.import=Usar importación de clase única
checkbox.use.throws.rather.than.exception=Use @throws en lugar de @exception
checkbox.warn.if.only.foreach.replacement.is.available=Advertir si solo está disponible el reemplazo 'forEach'
checkbox.warn.if.the.loop.is.trivial=Advertir si el bucle es trivial
checkbox.wrap.at.right.margin=Ajustar al margen derecho
choose.class=Elige clase
choose.super.class.popup.title=Elija la clase principal
chooser.text.choose.where.to.save.0=Elija dónde guardar ''{0}''
chooser.title.select.path.to.save.jar=Seleccionar ruta para guardar jar
class.can.be.record.conversion.make.member.more.accessible=변환하면 맴버를 액세스하기 용이해지는 경우:
class.can.be.record.conversion.strategy.convert.silently=Convertir sin confirmación
class.can.be.record.conversion.strategy.do.not.convert=No sugiera conversión a registro
class.can.be.record.conversion.strategy.show.members=Mostrar miembros afectados en la vista de conflictos
class.can.be.record.display.name=La clase se puede grabar
class.can.be.record.quick.fix=Convertir en registro
class.can.be.record.suggest.renaming.accessors=get/is Sugiere cambiar el nombre de los accesores
class.can.be.record.suppress.conversion.if.annotated=클래스가 다음으로 어노테이션된 경우 변환 억제:
class.can.be.record.suppress.conversion.if.annotated.fix.family.name=기록 변환 억제
class.can.be.record.suppress.conversion.if.annotated.fix.name=''{0}''(으)로 어노테이션이 추가된 경우 기록 변환 억제
class.cannot.be.inlined.because.a.call.to.its.constructor.is.unresolved=No se pudo inline class porque la llamada al constructor de la clase no se resolvió
class.cannot.be.inlined.because.an.interface.implemented.by.it.cannot.be.resolved=No se puede en la clase en línea porque la interfaz implementada por la clase no se puede resolver
class.cannot.be.inlined.because.it.has.static.fields.with.non.constant.initializers=No se puede inline class porque la clase tiene campos estáticos con inicializadores no constantes
class.cannot.be.inlined.because.it.has.static.initializers=No se puede inline class porque la clase tiene un inicializador estático
class.cannot.be.inlined.because.it.has.static.inner.classes=No se puede incluir una clase en línea porque la clase tiene una clase interna estática
class.cannot.be.inlined.because.it.has.static.methods=No se puede inline class porque la clase tiene métodos estáticos
class.cannot.be.inlined.because.it.has.static.non.final.fields=No se puede inline class porque la clase tiene campos estáticos no finales
class.cannot.be.inlined.because.it.has.usages.of.fields.not.inherited.from.its.superclass=La clase no se puede insertar porque usa un campo que no es heredado de su clase principal.
class.cannot.be.inlined.because.it.has.usages.of.its.class.literal=No se puede inline class porque se usa class literal
class.cannot.be.inlined.because.it.has.usages.of.its.inner.classes=No se puede inline class porque se utilizan clases internas
class.cannot.be.inlined.because.it.is.used.as.a.this.qualifier=La clase no se puede incluir porque usa '' este '' calificador
class.cannot.be.inlined.because.it.is.used.in.a.catch.clause=No se puede incluir porque la clase se usa en la cláusula '' catch ''
class.cannot.be.inlined.because.it.is.used.in.a.throws.clause=No se puede incluir porque la clase se usa en la cláusula '' throws ''
class.cannot.be.inlined.because.its.constructor.contains.return.statements=No se puede insertar la clase porque el constructor de la clase tiene una declaración '' return ''
class.cannot.be.inlined.because.its.superclass.cannot.be.resolved=No se puede inline class porque su superclase no se puede resolver
class.cannot.be.inlined.because.there.are.usages.of.its.methods.not.inherited.from.its.superclass.or.interface=Porque la clase usa un método que no es heredado de su clase padre o la interfaz no se puede insertar
class.decorator.or.has.default.constructor='{0}'' debe tener un constructor predeterminado o implementar el patrón '' Decorator '
class.filter.editor.add.dialog.title=Nuevo filtro
class.filter.editor.choose.class.title=Elegir clase
class.filter.editor.table.model.column.name.isActive=Activo
class.filter.editor.table.model.column.name.pattern=Patrón
class.has.no.default.constructor=''{0}'' no tiene un constructor predeterminado
class.is.not.a.subclass='{0}'' no se puede asignar a ''{1}'
class.is.not.concrete=''{0}'' no es una clase concreta
class.is.not.public=''{0}'' no es público
class.not.found.error.message=Clase ''{0}'' no encontrada
class.patterns.error.class.pattern.0.must.be.a.valid.java.qualifier=El patrón debe ser un nombre válido de Java completamente calificado, solo '' * '' están permitidos como marcadores de posición
class.patterns.error.method.pattern.0.must.be.a.valid.java.identifier=El patrón de método ''{0}'' debe ser un identificador de Java válido, solo '' * '' permitido como indicador
class.patterns.panel.add.class=Agregar clase
class.patterns.separator.mark.code.as.entry.point.if.qualified.name.matches=Marcar el código como punto de entrada si los nombres calificados coinciden
code.style.generation.override.method.signature=Anular firma del método
code.style.generation.repeat.synchronized.modifier=Modificador de repetición y sincronización
code.style.generation.replace.null.check=Reemplazar null-check con Objects::nonNull o Objects::isNull
code.style.generation.settings.error.not.valid.identifier.part.in.prefix=Prefix ''{0}'' tiene una parte de identificador de Java no válida
code.style.generation.settings.error.not.valid.identifier.part.in.suffix=El sufijo ''{0}'' contiene parte de un identificador de Java no válido
code.style.generation.use.class.isInstance=Use Class::isInstance y Class::cast cuando sea posible
code.style.generation.use.integer.sum=Use Integer::sum, etc. cuando sea posible
code.style.settings.angle.spacing.brackets=Corchetes
code.style.settings.spacing.after.closing.angle.bracket=Después de cerrar el corchete
code.style.settings.spacing.around.type.bounds=Alrededor de los límites de tipo
code.vision.implementations.hint={0, choice,1\# 1 implementations|2\# {0, number} implementations}
code.vision.inheritors.hint={0, choice,1\# 1 herederos|2\# {0, number} herederos}
code.vision.overrides.hint={0, choice,1\# 1 overrides|2\# {0, number} overrides}
column.name.class.entry.point=Clase
column.name.method.entry.point=Método
column.name.with.subclasses.entry.point=Incluir subclases
combobox.paste.insert.imports=&Insertar importaciones al pegar:
command.create.class.from.template=Crear clase a partir de plantilla
command.create.new.subdirectory=Crear nuevo subdirectorio
command.name.delegate.detected.change=Delegado
command.name.generate.tostring=crear toString()
command.name.insert.block.statement=Insertar declaración de bloque
command.name.replace.type=타입 바꾸기
command.name.updating.package.statement=Actualización de la declaración del paquete
comment.the.class.will.be.created.in.the.package.0=La clase se creará en el paquete ''{0}''
compiler.options=컴파일러 옵션
completion.class.name.hint.2=Presione {0} una vez más para ignorar las dependencias del módulo mientras busca
completion.generate.via.wizard=(마법사로 생성)
completion.inner.scope=내부
completion.inner.scope.tail.text=\ ({0} 블록에서)
completion.no.suggestions.of.type=No hay sugerencias de tipo {0}
completion.override.implement.methods=Anular/implementar métodos...
completion.smart.aslist.hint=Presione {0} una vez más para encontrar matrices de {1}
completion.smart.chain.hint=Presione {0} una vez más para buscar en las llamadas de métodos encadenados
completion.smart.hint=Presione {0} para mostrar solo las variantes que son adecuadas por tipo
completion.smart.toar.hint=Presione {0} una vez más para buscar colecciones de {1}
completion.smart.type.generate.anonymous.body=generar cuerpo anónimo
completion.unknown.type=Tipo desconocido {0}
configurable.EqualsHashCodeTemplatesPanel.display.name=Plantillas
configurable.GenerateToStringConfigurable.display.name=Configuración
configurable.TemplatesPanel.display.name=Plantillas
configure.annotations.option=Configurar anotaciones
conflict.message.method.will.override.method.base.class=이름 변경된 {0}은(는) 기본 {1}의 메서드를 재정의합니다
convert.compareto.expression.to.equals.call=Convertir expresión 'compareTo()' a llamada 'equals()'
convert.compareto.expression.to.equals.call.may.change.semantics=Convertir la expresión 'compareTo()' a la llamada 'equals()' (puede cambiar la semántica)
copy.abstract.method.intention.name=Usar la implementación existente de ''{0}''
copy.abstract.method.no.existing.implementations.found=No se encontraron implementaciones existentes
copy.abstract.method.popup.title=Elija la implementación para copiar
copy.abstract.method.title=Usar la implementación del método abstracto
copy.paste.reference.notification=<html>{0} {0,choice,1#import fue|2#import fueron} agregada <p><span><a href='show'> Revisar las importaciones añadidas...</a></span></html>
create.class.mapping.dialog.title={0} seleccionar clase
cyclic.dependencies.progress.text=Gráfico de dependencias de construcción
cyclic.dependencies.scope.dialog.module.button={0} &módulo ''{1}''
cyclic.dependencies.scope.dialog.project.button={0} todo el &proyecto
cyclic.dependencies.scope.dialog.title=Especificar {0} alcance
cyclic.dependencies.scope.include.test.sources.option=Incluir y probar fuentes
cyclic.dependencies.tree.cycle.node.text=ciclo
cyclic.dependencies.usage.view.initial.text=Seleccione el paquete para analizar del árbol de la izquierda
cyclic.dependencies.usage.view.root.node.text=Usos del paquete ''{0}'' en el paquete ''{1}''
dataflow.from.here=Flujo de datos desde aquí
dataflow.to.here=Flujo de datos hasta aquí
deannotate.intention.action.family.name=Eliminar anotación
deannotate.intention.action.several.text=Eliminar anotación...
deannotate.intention.action.text=Eliminar la anotación de {0}
deannotate.intention.chooser.title=Elija la anotación para eliminar
default.package.presentable.name=<predeterminado>
default.param.value.warning={0, choice, 0\#constructor |1\#method} con la firma seleccionada ya existe
dependant.sdk.unsatisfied.dependency.message=Primero debe configurar el SDK de Java
dependencies.libraries.node.text=Bibliotecas
dependencies.tree.node.default.package.abbreviation=<paquete predeterminado>
destination.combo.source.root.not.expected.conflict=Requiere una raíz de prueba, pero se ha seleccionado una raíz de origen
destination.combo.test.root.not.expected.conflict=Se requiere la raíz de origen pero se seleccionó la raíz de prueba
dfa.constraint.0.not.null={0}(no nulo)
dfa.constraint.not.null=no nulo
dfa.constraint.null.or.0=null o {0}
dialog.create.class.destination.package.label=Paquete de destino:
dialog.create.class.label=Crear {0}:
dialog.create.class.name=Crear {0} {1}
dialog.create.class.package.chooser.title=Elegir paquete de destino
dialog.edit.template.checkbox.smart.type.completion=Tipo inteligente c &ompleción
dialog.edit.template.checkbox.use.static.import=Utilice estática e importación si es posible
dialog.import.on.paste.title=Seleccionar clases para importar
dialog.import.on.paste.title2=Seleccionar elementos para importar
dialog.import.on.paste.title3=Seleccione Importar para eliminar
dialog.message.0.update.existing.class={0}. ¿Actualizar la clase existente?
dialog.message.class.not.found=템플릿 클래스 ''{0}''을(를) 찾을 수 없습니다
dialog.message.create.test.in.the.same.source.root=¿Crear prueba en la misma raíz de origen?
dialog.message.infer.nullity.annotations.requires.the.project.language.level=Infer Nullity Annotations requiere que el nivel de lenguaje del proyecto se establezca en 1.5 o superior.
dialog.message.jetbrains.annotations.library.is.missing=Falta la biblioteca de anotaciones JetBrains. \nSin la biblioteca, IntelliJ IDEA no puede ejecutar el análisis. ¿Le gustaría agregarlo?
dialog.message.modules.dont.refer.to.existing.annotations.library={0, choice, 0\#module|2\#module} {1} tiene una biblioteca ''{2}'' existente {0, opción, 0\# no|2\# no}. ¿Le gustaría agregar {0, choice, 0\#dependency|2\#dependency} ahora?
dialog.message.no.places.found.to.infer.nullable.notnull=No se encontraron lugares para inferir @Nullable/@NotNull
dialog.message.parameter.has.write.usages.inline.not.supported=매개변수에 쓰기 사용 위치가 있습니다. 인라인이 지원되지 않습니다
dialog.message.template.not.applicable=템플릿을 적용할 수 없습니다
dialog.message.template.not.found=템플릿을 찾을 수 없습니다
dialog.paste.on.import.text=<html>El fragmento de código que ha pegado utiliza clases a las que las importaciones no pueden acceder en el nuevo contexto.<br/> Seleccione las clases que desea importar al nuevo archivo.</html>
dialog.paste.on.import.text2=<html>El fragmento de código que ha pegado utiliza elementos a los que las importaciones no pueden acceder en el nuevo contexto.<br/> Seleccione los elementos que desea importar al nuevo archivo.</html>
dialog.paste.on.import.text3=<html>El fragmento de código que ha pegado introdujo nuevas importaciones en el contexto actual.<br/> Seleccione las importaciones que desea eliminar.</html>
dialog.title.check.configuration=구성 확인...
dialog.title.check.functional.interface.candidates=함수 인터페이스 후보 확인...
dialog.title.choose.0.parameters=Elija {0} Parámetros
dialog.title.choose.annotation=Seleccionar anotación {0}
dialog.title.choose.class=Elegir clase
dialog.title.configure.annotations=Configurar anotaciones
dialog.title.configure.code.patterns=Configurar patrones de código
dialog.title.copy.template=Copiar plantilla
dialog.title.create.class.in.package=Crear clase en paquete
dialog.title.create.missed.tests=Crear pruebas perdidas
dialog.title.create.new.template=Crea una nueva plantilla
dialog.title.edit.method.contract=Editar contrato de método
dialog.title.edit.range=Editar rango
dialog.title.infer.nullity=Inferir nulidad
dialog.title.infer.nullity.results=Inferir resultados de nulidad
dialog.title.move.directory=디렉터리 이동
dialog.title.no.test.roots.found=No se encontraron raíces de prueba
dialog.title.process.duplicates=Procesar duplicados
dialog.title.super.method.found=Súper método encontrado
dialog.title.testdatapath.file.generate=클래스에서 @TestDataPath로 파일을 생성
dialog.title.testdatapath.method.generate=@TestDataPath에서 메서드 생성
disable.report.inaccessible.symbols.fix=Sin informe de símbolos inaccesibles
do.not.import.inner.classes.for=Excluir clases internas por nombre corto:
do.not.import.inner.classes.no.classes=No hay clases internas definidas
edit.contract.dialog.checkbox.impure.method=메서드가 부수 효과(&S)를 일으킬 수 있습니다
edit.contract.dialog.hint=<html>Especifique el texto del contrato <p> Ejemplo\: <code> _, null -> false</code><br><small>Consulte la descripción de la acción de intención para obtener más detalles</small></html>
edit.contract.dialog.mutates.hint=쉼표로 구분된 요소 중 변형될 수 있는 요소를 지정하세요<p>예: <code>this,param1</code><p>지정되지 않은 부수 효과의 경우 비워두세요.
edit.range.dialog.message=<html>Especifique un rango de valores <p> Deje '' desde '' o '' a '' vacío si no hay límite</html>
edit.range.error.invalid.value=Valor no válido
edit.range.should.not.be.greater.than.to='to'보다 클 수 없습니다
edit.range.should.not.be.less.than.from='from'보다 작으면 안 됩니다
edit.range.value.should.be.bigger.than=no debe ser mayor que {0}
edit.range.value.should.be.less.than=no debe ser menor que {0}
editbox.blanklines.around.initializer=Alrededor del inicializador:
editbox.class.count.to.use.import.with.star=Recuento de clases para usar la importación con '*':
editbox.names.count.to.use.static.import.with.star=Los nombres cuentan para usar la importación estática con '*':
empty.title=Vacío
encapsulate.fields.dialog.javadoc.title=JavaDoc
enum.constant.ordinal=enum constante ordinal\:
enum.not.allowed=Enum no está permitido
enums.cannot.be.inlined=Las enumeraciones no se pueden insertar
environment.key.description.project.jdk=프로젝트 JDK의 절대 경로
environment.key.description.project.jdk.name=IDE에서 볼 수 있는 프로젝트 JDK 이름입니다.
error.attempt.to.generate.constructor.for.anonymous.class=No se puede agregar un constructor a una clase anónima
error.hint.no.expression.found=No se encontró ninguna expresión
error.message.ide.does.not.support.starting.processes.using.old.java=IDE는 Java {0}을(를) 사용하는 Java 프로세스 시작을 지원하지 않습니다. 최소 지원 버전은 1.7입니다. 실행 구성을 변경하여 최신 Java 버전을 사용하세요.
error.package.already.contains.package-info='package-info.java'' ya existe para el paquete ''{0}'
error.package.already.contains.package.html=El paquete ''{0}'' ya tiene un archivo ''package.html''. ¿Crear "package-info.java" de todos modos?
error.package.html.found.title=Se encontró 'paquete.html'
error.text.this.is.not.a.valid.java.class.name=Este no es un nombre de clase Java válido
exclude.0.from.auto.import=Excluir ''{0}'' de la importación automática
exclude.0.from.completion=Excluir ''{0}'' de la finalización
exclude.accessors=&Excluir descriptores de acceso
exclude.from.completion.group=Excluir de la importación automática y la finalización:
exclude.from.imports.no.exclusions=Agregar una clase, paquete o miembro
exclude.from.imports.no.exclusions.2=para excluir de la importación automática y la finalización
exclude.import.wildcard.comment=Use el comodín * para excluir a todos los miembros de una clase o paquete específico
exclude.table.mask=Clase, paquete o miembro
exclude.table.scope.column=Alcance
export.to.html.generate.hyperlinks.checkbox=Generar &hipervínculos a clases
external.annotation.prompt=Solicitud de anotación externa
external.annotations.external.option=Agregar &externamente
external.annotations.in.code.option=Agregar &código
external.annotations.open.file=어노테이션 파일 열기
external.annotations.problem.parse.error=파일: {0}<br>문제: {1}
external.annotations.problem.title=외부 어노테이션을 읽을 수 없음
external.annotations.root.chooser.description=Las anotaciones externas se guardarían en la carpeta apropiada
external.annotations.root.chooser.title=Seleccionar raíz de anotaciones externas para {0}
external.annotations.roots=Raíces de anotación
external.annotations.suggestion.message=<html><body> Si no desea anotaciones en su código, puede usar almacenamiento externo.<br>\
extract.interface.command.name=Extraer interfaz
extract.superclass.command.name=Extraer superclase
extracted.class.should.have.unique.name=추출된 클래스에는 고유한 이름이 있어야 합니다. 이름 ''{0}''은(는) 이미 내부 클래스 중 하나에서 사용되고 있습니다
filetype.spi.description=서비스 공급자 인터페이스
find.field.accessors.prompt=¿Buscar accesos del campo ''{0}''?
find.field.accessors.title=Accesores de campo encontrados
find.jar.hint.text.no.libraries.found.for.fqn=No se pudo encontrar la biblioteca para ''{0}''
find.options.include.accessors.base.checkbox=접근자 기본 메서드 검색(&E)
find.options.include.accessors.base.checkbox.comment=기본적으로 최상위 계층 메서드를 사용 위치 찾기 타깃으로 사용
find.options.include.accessors.checkbox=접근자 검색(&A)
find.options.include.overloaded.methods.checkbox=Incluir métodos sobrecargados
find.options.search.overriding.methods.checkbox=재정의하는 메서드에서 검색(&O)
find.what.derived.classes.checkbox=&Clases derivadas
find.what.derived.interfaces.checkbox=&Interfaces derivadas
find.what.fields.usages.checkbox=Usos de &fields
find.what.implementing.classes.checkbox=&Implementando clases
find.what.implementing.methods.checkbox=&Implementando métodos
find.what.implicit.to.string.checkbox=llamadas I &mplicit
find.what.methods.usages.checkbox=Usos de &métodos
find.what.overriding.methods.checkbox=Métodos de sobre &montar
find.what.search.for.base.methods.checkbox=기본 메서드 사용 위치 검색(&E)
find.what.search.for.base.methods.checkbox.comment=기본적으로 최상위 계층 메서드를 사용 위치 찾기 타깃으로 사용
find.what.usages.checkbox=&Usos
find.what.usages.of.classes.and.interfaces=Usos de &clases e interfaces
fix.move.to.source.root=소스 루트로 이동
generate.button.title=Generar
generate.constructor.already.exists=El constructor ya existe
generate.constructor.fields.chooser.title=Elija campos para inicializar por constructor
generate.constructor.super.constructor.chooser.title=Elegir constructor de superclase
generate.delegate.target.chooser.title=Seleccionar objetivo para generar delegados para
generate.equals.and.hashcode.already.defined.title=Generar equals() y hashCode()
generate.equals.and.hashcode.already.defined.warning=Los métodos ''boolean equals(Object)'' e ''int hashCode()'' ya están definidos \npara la clase {0}. ¿Quieres eliminarlos y continuar?
generate.equals.and.hashcode.already.defined.warning.anonymous=Los métodos 'boolean equals(Object)' e 'int hashCode()' ya están definidos \n para esta clase anónima. ¿Quieres eliminarlos y continuar?
generate.equals.hashcode.accept.sublcasses=Aceptar &subclasses como parámetro para el método equals()
generate.equals.hashcode.accept.sublcasses.explanation=<html><body> Aunque generalmente no cumple con la especificación Object.equals(), la aceptación de subclases<br>puede ser necesaria para la \
generate.equals.hashcode.equals.fields.chooser.title=Elija los campos &para incluirlos en equals()
generate.equals.hashcode.hashcode.fields.chooser.title=Elija los campos &para incluirlos en hashCode()
generate.equals.hashcode.internal.error=Error interno
generate.equals.hashcode.non.null.fields.chooser.title=Seleccionar todos los campos &no nulos
generate.equals.hashcode.template=&Plantilla:
generate.equals.hashcode.use.getters=Usar &getters durante la generación de código
generate.equals.hashcode.warning.hashcode.for.arrays.is.not.supported=hashCode() para matrices no es compatible
generate.equals.hashcode.wizard.title=Generar equals() y hashCode()
generate.equals.no.fields.for.generation=No se pudieron encontrar campos para incluir en equals/hashCode
generate.equals.template.title=Plantilla igual a:
generate.equals.warning.equals.for.nested.arrays.not.supported=No se admite equals() para matrices anidadas
generate.equals.warning.generated.equals.could.be.incorrect=Generado equals() para Object [] puede ser incorrecto
generate.file.extension.text=파일 확장자 입력: .php, .java, .kt, .cpp ....
generate.file.extension.validation.error=파일 확장자 ''{0}''은(는) 올바르지 않습니다. ''.''으로 시작해야 하며 공백을 포함하거나 비어 있을 수 없습니다
generate.getter.and.setter.error.no.fields=No se pudieron encontrar los campos para generar getter/setter para
generate.getter.and.setter.error.no.fields.without.getters.and.setters=Campo no encontrado sin getter/setter
generate.getter.and.setter.error.setters.for.read.only.not.generated=No se generó ningún setter para campos de solo lectura
generate.getter.error.no.fields=No se pueden encontrar campos para generar getter
generate.getter.error.no.fields.without.getters=No se pueden encontrar campos sin getter
generate.getter.fields.chooser.title=Seleccionar campos para generar captadores
generate.getter.setter.header.visibility.hint.=La visibilidad es '' Archivo | Configuraciones | editor | estilo de código | Java | La generación de código se aplica según
generate.getter.setter.title=Seleccionar campos para generar getters y setters
generate.getter.template=&plantilla Getter:
generate.hashcode.template.title=Plantilla HashCode:
generate.members.implement.command=implementación
generate.members.nothing.to.insert=Nada para insertar
generate.method.nofiles.warn=클래스 {0}에 테스트 메서드가 없습니다
generate.method.nosuites.warn=@TestDataPath(''{0}'')에 테스트 스위트가 없습니다
generate.missed.tests.action.error.no.tests.found=Prueba no encontrada.
generate.missed.tests.action.failed.to.detect.framework=No se pudo detectar el marco de prueba para {0}
generate.quickfix.files=QF 시나리오 생성('.after' 접미사 사용)
generate.record.constructor.title=Generar constructor de registros
generate.select.default.modifier.text=제어자 선택
generate.setter.fields.chooser.title=Seleccionar campos para generar setters
generate.setter.template=&plantilla de Setter:
generate.setters.no.fields=No se pudieron encontrar campos para generar establecedores para
generate.setters.no.fields.without.setters=No se pueden encontrar campos sin setter
generate.test.support.method.error.cannot.generate.method=No se pudo generar el método. {0}
generate.test.support.method.error.method.already.exists=El método {0} ya existe
generate.test.support.method.error.no.template.found.for.framework=No se encontró ninguna plantilla para {0}. {1}
generate.tostring.already.exist.border=Cuando el método ya existe
generate.tostring.available.implicit.variables.label=Variables implícitas disponibles:<br/> {0}
generate.tostring.exclude..transient=Excluir campos transitorios
generate.tostring.exclude.by.field.name=Excluir campos por nombre (reg exp)
generate.tostring.exclude.by.field.type=Excluir campos por nombre de tipo (reg exp)
generate.tostring.exclude.by.name=Excluir métodos por nombre (reg exp)
generate.tostring.exclude.by.return.type=Excluir métodos por nombre de tipo de retorno (reg exp)
generate.tostring.exclude.constant.fields=Excluir campos constantes
generate.tostring.exclude.enum.fields=Excluir campos de enumeración
generate.tostring.exclude.logger=Excluir campos del registrador (Log4j, JDK Logging, Jakarta Commons Logging)
generate.tostring.exclude.static.fields=Excluir campos estáticos
generate.tostring.fully.qualified.class.name=Use un nombre de clase completamente calificado en la generación de código ($ classname)
generate.tostring.getters.in.generated.code=Habilitar captadores en la generación de código ($ métodos)
generate.tostring.handle.exception.error.message=Se lanzó una excepción irrecuperable mientras se realizaba la acción; consulte el registro de IDEA para obtener más detalles (stacktrace debe estar en idea.log): \n{0}
generate.tostring.handle.exception.plugin.warning.message=Se lanzó una excepción PluginException mientras se realizaba la acción; consulte el registro de IDEA para obtener detalles (stacktrace debe estar en idea.log): \n{0}
generate.tostring.handle.exception.velocity.error.message=Código de generación de error de velocidad; consulte el registro de IDEA para obtener más detalles (stacktrace debe estar en idea.log): \n{0}
generate.tostring.insert.border=¿Dónde insertar?
generate.tostring.method.already.exists.dialog.me=ssage=기존 {0} 메서드 바꾸기
generate.tostring.method.already.exists.dialog.title=El método ya existe
generate.tostring.move.to.generated.checkbox=Mover el cursor al método generado
generate.tostring.settings=Configuración
generate.tostring.sort.ascending=Ascendente
generate.tostring.sort.checkbox=Ordenar elementos
generate.tostring.sort.descending=Descendente
generate.tostring.sort.super=Primero los miembros de la súper clase
generate.tostring.tab.title=toString() Configuración de generación
generate.tostring.template.label=Plantilla:
generate.tostring.title=Generar toString()
goto.super.class.chooser.title=Elija una superclase o interfaz
group.javadoc.alignment=Alineación
group.javadoc.blank.lines=Líneas en blanco
group.javadoc.invalid.tags=Etiquetas inválidas
group.javadoc.other=Otro
gutter.implemented.method=Método implementado
gutter.implementing.method=Método de implementación
gutter.overridden.method=Método anulado
gutter.overriding.method=Método de reemplazo
gutter.service=Servicio
gutter.sibling.inherited.method=Método heredado por hermanos
header.method.to.be.converted=변환할 메서드
hide.out.of.cyclic.packages.action.description=Ocultar paquetes sin dependencias cíclicas
hide.out.of.cyclic.packages.action.text=Ocultar paquetes sin dependencias cíclicas
highlight.exceptions.thrown.chooser.title=Elija clases de excepción para resaltar
highlight.imported.classes.chooser.title=Elija clases importadas para resaltar
highlight.imported.members.chooser.title=Elija miembros importados para resaltar
highlight.overridden.classes.chooser.title=Elija clases para resaltar los métodos anulados de
highlight.suppressed.warnings.choose.inspections=Elija inspecciones para resaltar los problemas suprimidos de
highlight.throws.class.name=Highlight Throws {0}
highlight.throws.popup.throwing.places=Lugares lanzando {0}
highlight.throws.popup.usages=Usos de {0}
hint.text.added.imports=, agregue {0} {0, choice,1\#import declaraciones|2\#import declaraciones}
hint.text.not.valid.java.identifier=올바른 Java 식별자가 아닙니다
hint.text.occurrences.were.inlined={1} usos en línea
hint.text.press.to.go.through.inlined.occurrences=presione {0} para explorar {1} usos en línea
hint.text.rearranged.imports=Declaraciones de importación reordenadas
hint.text.removed.imports=Eliminar {0} {0, choice,1\#import declaraciones|2\#import declaraciones}
hint.text.tostring.method.could.not.be.created.from.template=' toString() '' El método no se puede crear a partir de la plantilla ''{0}'
hint.text.tostring.template.invalid=toString() plantilla ''{0}'' no es válida
icon.preview=Vista previa del icono
ignore.imports.and.formatting=Ignorar las importaciones y el formato
ignored.suppressions=무시된 억제:
illegal.name.validation.info=Nombre ilegal: {0}
implement.abstract.method.potential.implementations.with.weaker.access=Se han encontrado posibles implementaciones con acceso débil. {0}
implement.method.no.methods.to.implement=No se encontró ningún método para implementar
import.layout.panel.all.other.imports=Todas las demás declaraciones de importación
import.layout.panel.blank.line.entry=<línea en blanco>
import.layout.panel.down.button=Abajo
import.layout.panel.up.button=Arriba
import.layout.static.imports.separately=Diseñar importaciones estáticas por separado
import.statically=Importar estáticamente
include.accessors=&Incluir descriptores de acceso
increase.language.level.preview.description=모듈 ''{0}''의 언어 수준이 ''{1}''(으)로 변경됩니다
infer.nullity.progress=Resultados de posprocesamiento...
inlay.MethodChainsInlayProvider.description=호출 체인 내 메서드 반환 타입.
inlay.annotation.hints.external.annotations=소스 코드 외부에 저장된 어노테이션입니다.<br>이러한 어노테이션은 어노테이션이 필요한 경우 유용하지만 소스 코드에 어노테이션 추가는 옵션이 아닙니다(예: 라이브러리 코드에서 작업할 경우).<br><br><a href='https://www.jetbrains.com/help/idea/external-annotations.html'>문서</a>
inlay.annotation.hints.inferred.annotations=IntelliJ IDEA가 라이브러리와 프로젝트 코드를 스캔하여 생성하는 어노테이션입니다. 이러한 어노테이션은 코드 컨트랙트를 이해하고 정적 분석의 기능을 향상하는 데 도움이 됩니다. 여기에는 다음이 포함됩니다. <br> @Contract <br> @Nullable <br> @NotNull <br> @Unmodifiable <br>@UnmodifiableView <br><br><a href='https://www.jetbrains.com/help/idea/inferring-nullity.html#inferred-annotations'>문서</a>
inlay.parameters.java.build.like.method=StringBuilder 체인의 호출 또는 Java 8 Stream API의 중간 연산 등 연산하는 클래스의 인스턴스를 반환하는 메서드.
inlay.parameters.java.clear.expression.type=삼항 연산자나 Java 13 switch 문 등 복잡한 표현식을 인수로 사용하는 메서드 호출.
inlay.parameters.java.enums=매개변수화된 생성자를 사용하는 열거형 상수 선언.
inlay.parameters.java.method.name.contains.parameter.name=접근자 메서드 등 필요한 인수를 메서드 이름에서 분명히 알 수 있는 경우 단일 인수를 취하는 메서드.
inlay.parameters.java.multiple.params.same.type=동일한 타입의 비 리터럴 인수가 두 개 이상 있는 메서드에 대한 호출.
inlay.parameters.java.new.expr=매개변수화된 생성자에 대한 호출.
inlay.parameters.java.simple.sequentially.numbered=문자 하나 뒤에 숫자가 나오는 이름을 가진 여러 매개변수를 취하는 메서드.
insert.override.annotation=Insertar @ &Anular anotación
inspection.anonymous.2.method.ref.display.name=El tipo anónimo se puede reemplazar con la referencia del método
inspection.assert.quickfix=Afirmar ''{0}''
inspection.bulk.file.attributes.read.description=일괄 'Files.readAttributes()' 호출을 사용할 수 있습니다
inspection.bulk.file.attributes.read.message=다수의 파일 속성 호출을 하나의 'Files.readAttributes()' 호출로 바꿀 수 있습니다
inspection.capturing.cleaner=Ejecutable pasado a Cleaner.register() captura la referencia ''{0}''
inspection.capturing.cleaner.description=El limpiador captura la referencia del objeto
inspection.cast.can.be.removed.narrowing.variable.type.fix.family.name=Cambiar el tipo de variable y eliminar el reparto
inspection.cast.can.be.removed.narrowing.variable.type.fix.name=Cambiar el tipo de ''{0}'' a ''{1}'' y eliminar el elenco
inspection.cast.can.be.removed.narrowing.variable.type.message=El elenco se puede eliminar cambiando el tipo de ''{0}'' a ''{1}''
inspection.cast.can.be.removed.narrowing.variable.type.name=Un tipo de variable demasiado débil conduce a una conversión innecesaria
inspection.charset.object.can.be.used.display.name=Se puede utilizar el objeto Conjunto de caracteres estándar
inspection.charset.object.can.be.used.fix.family.name=Usar constante Charset
inspection.charset.object.can.be.used.message={0} se puede usar en su lugar
inspection.collection.add.all.can.be.replaced.with.constructor.display.name=Llamada redundante 'Collection.addAll()'
inspection.collection.factories.fix.family.name=Reemplazar con llamada de fábrica de colección
inspection.collection.factories.fix.name=Reemplazar con ''{0}.{1}'' llamada
inspection.collection.factories.message=Puede ser reemplazado con ''{0}.{1}'' llamada
inspection.collection.factories.option.ignore.non.constant=No advertir cuando el contenido no sea constante
inspection.collection.factories.option.suggest.ofentries=Sugerir 'Map.ofEntries'
inspection.collection.used.as.vararg.display.name=Iterable se usa como vararg
inspection.collection.used.as.vararg.message=Iterable se pasa como vararg: probablemente se pretendía una matriz
inspection.comparator.combinators.display.name=Se puede utilizar el combinador del comparador
inspection.comparator.result.comparison.display.name=Uso sospechoso del método de comparación
inspection.comparator.result.comparison.fix.family.name=Corregir comparación de resultados del comparador
inspection.comparator.result.comparison.problem.display.name=Comparación del resultado del método de comparación con una constante específica
inspection.condition.covered.by.further.condition.display.name=La condición está cubierta por una condición adicional
inspection.conditional.break.in.infinite.loop=Mover condición al bucle
inspection.conditional.break.in.infinite.loop.allow.condition.fusion=기존 루프 조건과 병합 허용
inspection.conditional.break.in.infinite.loop.description=Interrupción condicional dentro del bucle infinito
inspection.conditional.break.in.infinite.loop.no.conversion.with.do.while=\ 'do while'로 바꾸기를 제안하지 않음
inspection.conditional.break.in.infinite.loop.suggest.conversion.when.if.is.single.stmt.in.loop='if'가 루프 내의 단일 구문일 경우 변환을 제안
inspection.conditional.can.be.optional.display.name=Condicional se puede reemplazar con Opcional
inspection.convert.2.method.ref.display.name=Lambda se puede reemplazar con referencia de método
inspection.convert.2.streamapi.display.name=El bucle se puede contraer con Stream API
inspection.convert.to.local.quickfix=Convertir a local
inspection.data.flow.constant.values.display.name=상숫값
inspection.data.flow.display.name=Condiciones constantes \\& excepciones
inspection.data.flow.filter.notnull.quickfix=Insertar paso 'filtro (Objetos::nonNull)'
inspection.data.flow.ignore.assert.statements=assert 문 무시
inspection.data.flow.nullable.quickfix.option=Sugerir una anotación @Nullable para métodos/campos/parámetros donde se utilizan valores que aceptan valores NULL
inspection.data.flow.optional.of.nullable.misuse.display.name=null 혹은 null이 아닌 인수와 Optional.ofNullable을 같이 사용
inspection.data.flow.report.not.null.required.parameter.with.null.literal.argument.usages=null 리터럴 인수가 사용되고 null이 아니여야 하는 매개변수 보고
inspection.data.flow.report.nullable.methods.that.always.return.a.non.null.value=null이 아닌 값을 항상 반환하는 null 가능한 메서드 보고
inspection.data.flow.report.problems.that.happen.only.on.some.code.paths=일부 코드 경로에서만 발생하는 문제 보고
inspection.data.flow.treat.non.annotated.members.and.parameters.as.nullable=어노테이션이 없는 멤버 및 매개변수를 @Nullable로 취급
inspection.data.flow.true.asserts.option=No informe afirmaciones con condición estáticamente probada para ser siempre <code> verdadera</code>
inspection.data.flow.use.computeifpresent.quickfix=Reemplazar 'compute' con 'computeIfPresent'
inspection.data.flow.warn.when.reading.a.value.guaranteed.to.be.constant=상수인 것으로 보장된 값을 읽을 시 경고
inspection.dead.code.option.applet=Applets
inspection.dead.code.option.external=Clases con usos en archivos que no son de Java
inspection.dead.code.option.main=<html><code> métodos void main(String args [])</code></html>
inspection.dead.code.option.servlet=Servlets
inspection.default.annotation.param=Valor del parámetro de anotación predeterminado
inspection.duplicate.branches.in.switch.default.message=La rama en 'conmutador' es un duplicado de la rama predeterminada
inspection.duplicate.branches.in.switch.delete.fix.family.name=Eliminar ramas 'conmutadas' redundantes
inspection.duplicate.branches.in.switch.delete.fix.name=Eliminar rama redundante de 'conmutador'
inspection.duplicate.branches.in.switch.display.name=Ramas duplicadas en 'switch'
inspection.duplicate.branches.in.switch.merge.fix.family.name=Fusionar ramas duplicadas en 'switch'
inspection.duplicate.branches.in.switch.merge.fix.name=Fusionar con ''{0}''
inspection.duplicate.branches.in.switch.merge.with.default.fix.name=Fusionar con la rama 'switch' predeterminada
inspection.duplicate.branches.in.switch.message=Rama duplicada en 'switch'
inspection.duplicate.expressions.complexity.threshold=Umbral de complejidad de expresión
inspection.duplicate.expressions.display.name=Varias apariciones de la misma expresión
inspection.duplicate.expressions.introduce.variable.fix.family.name=Introducir variable
inspection.duplicate.expressions.introduce.variable.fix.name=Introducir variable para ''{0}''
inspection.duplicate.expressions.message=Varias apariciones de <code>#ref</code> #loc
inspection.duplicate.expressions.replace.other.occurrences.fix.family.name=Reemplazar con variable otras ocurrencias de expresión
inspection.duplicate.expressions.replace.other.occurrences.fix.name=Reemplazar con ''{0}'' otras apariciones de ''{1}''
inspection.duplicate.expressions.reuse.variable.fix.family.name=Reutilizar variable
inspection.duplicate.expressions.reuse.variable.fix.name=Reutilizar variable ''{0}'' para ''{1}''
inspection.empty.method.delete.quickfix=Eliminar métodos innecesarios
inspection.empty.method.display.name=Método vacío
inspection.empty.method.problem.descriptor=El método solo llama a su super
inspection.empty.method.problem.descriptor1=El método vacío anula el método vacío
inspection.empty.method.problem.descriptor2=El método está vacío
inspection.empty.method.problem.descriptor3=El método y todos sus derivados están vacíos
inspection.empty.method.problem.descriptor4=Todas las implementaciones de este método están vacías
inspection.endless.stream.description=La operación sin cortocircuito consume flujo infinito
inspection.equals.hashcode.display.name='equals()' y 'hashCode()' no emparejados
inspection.equals.hashcode.generate.equals.quickfix=Generar 'equals()'
inspection.equals.hashcode.generate.equals.quickfix.preview='equals()' 생성을 구성하는 대화상자를 엽니다.
inspection.equals.hashcode.generate.hashcode.quickfix=Generar 'hashCode()'
inspection.equals.hashcode.generate.hashcode.quickfix.preview='hashCode()' 생성을 구성하는 대화상자를 엽니다.
inspection.excessive.lambda.fix.family.name=Reemplazar lambda con constante
inspection.excessive.lambda.fix.name=Usar método ''{0}'' sin lambda
inspection.excessive.lambda.message=Uso excesivo de lambda
inspection.excessive.lambda.usage.display.name=Uso excesivo de lambda
inspection.excessive.range.check.display.name=Comprobación de rango excesiva
inspection.explicit.argument.can.be.lambda.display.name=El argumento explícito puede ser lambda
inspection.explicit.argument.can.be.lambda.fix.family.name=Reemplazar el argumento explícito con la función
inspection.explicit.argument.can.be.lambda.fix.name=Use el método ''{0}'' con argumento funcional
inspection.explicit.argument.can.be.lambda.message=El argumento explícito se puede convertir a lambda
inspection.explicit.array.filling.description=Se puede reemplazar con una sola llamada al método '' Arrays. {0}() ''
inspection.explicit.array.filling.display.name=Relleno explícito de matriz
inspection.explicit.array.filling.fix.family.name=Reemplazar bucle con llamada al método '' Arrays. {0}() ''
inspection.explicit.array.filling.no.suggestion.for.set.all=No sugiera usar 'Arrays.setAll()'
inspection.explicit.array.filling.redundant.loop.description=Inicialización redundante de una matriz recién creada
inspection.explicit.array.filling.suggest.set.all=Sugerir 'Arrays.setAll()'
inspection.export.results.callees=Cadena de llamadas
inspection.export.results.implicit.constructor=constructor implícito de
inspection.export.results.overrides.library.methods=Anula los métodos de la biblioteca
inspection.export.results.package=paquete
inspection.export.results.type.references=Lo siguiente usa este tipo
inspection.field.can.be.local.display.name=El campo puede ser local
inspection.field.can.be.local.problem.descriptor=El campo se puede convertir a una variable local
inspection.field.can.be.local.quickfix.constructor=Convertir campo a variable local en el constructor
inspection.field.can.be.local.quickfix.initializer=Convertir campo a variable local en la sección de inicializador
inspection.field.can.be.local.quickfix.one.method=Convertir campo en variable local en el método ''{0}''
inspection.fill.permits.list.display.name=Falta la misma subclase de archivo en la cláusula de permisos de la clase sellada
inspection.fill.permits.list.fix.name=누락된 하위 클래스를 permits 절에 추가
inspection.fill.permits.list.no.missing.inheritors=봉인된 클래스에 누락된 상속자가 없습니다
inspection.fold.expression.fix.family.name=Doblar expresión
inspection.fold.expression.into.stream.display.name=La expresión se puede plegar en la cadena Stream
inspection.fold.expression.into.stream.fix.name=Doblar expresión en cadena de flujo
inspection.fold.expression.into.string.display.name=La expresión se puede plegar en 'String.join'
inspection.fold.expression.into.string.fix.name=Doblar expresión en 'String.join'
inspection.forward.compatibility.name=Compatibilidad con versiones posteriores
inspection.frequently.used.inheritor.inspection.display.name=La clase puede extender una clase base comúnmente utilizada
inspection.functional.expression.can.be.folded.display.name=La expresión funcional se puede plegar
inspection.fuse.stream.operations.display.name=Los pasos posteriores se pueden fusionar en la cadena Stream API
inspection.fuse.stream.operations.fix.family.name=Fusionar más declaraciones a la cadena de API Stream
inspection.fuse.stream.operations.fix.name=Fusionar {0} en la cadena de la API de Stream
inspection.fuse.stream.operations.message=La transmisión se puede extender reemplazando {0}
inspection.fuse.stream.operations.option.strict.mode=No sugiera colectores 'toList()' o 'toSet()'
inspection.handle.signature.change.type.fix.name=Cambiar tipo a ''{0}''
inspection.handle.signature.field.cannot.resolve=No se puede resolver el campo ''{0}''
inspection.handle.signature.field.not.static=El campo ''{0}'' no es estático
inspection.handle.signature.field.static=El campo ''{0}'' es estático
inspection.handle.signature.field.type=El tipo de campo ''{0}'' es ''{1}''
inspection.handle.signature.method.abstract=El método ''{0}'' es abstracto en ''{1}''
inspection.handle.signature.method.not.static=El método ''{0}'' no es estático
inspection.handle.signature.method.static=El método ''{0}'' es estático
inspection.handle.signature.name=No coinciden los tipos MethodHandle/VarHandle
inspection.handle.signature.not.subclass=La clase de llamada ''{0}'' debe ser una subclase de ''{1}''
inspection.handle.signature.use.constructor.fix.family.name=Usa una de las sobrecargas del constructor
inspection.handle.signature.use.constructor.fix.name=Usar constructor ''{0}''
inspection.handle.signature.use.method.fix.family.name=Use una de las sobrecargas de métodos
inspection.handle.signature.use.method.fix.name=Usar método ''{0}''
inspection.idempotent.loop.body=Cuerpo del bucle idempotente
inspection.illegal.character=Carácter ilegal
inspection.inconsistent.text.block.indent.message=텍스트 블록 들여쓰기는 탭과 공백으로 구성됩니다
inspection.inconsistent.text.block.indent.name=텍스트 블록의 일관되지 않은 공백 들여쓰기
inspection.inconsistent.text.block.indent.spaces.to.tabs.many.to.one.fix=공백을 탭으로 바꾸기({0} 공백 = 1 탭)
inspection.inconsistent.text.block.indent.spaces.to.tabs.one.to.one.fix=공백을 탭으로 바꾸기(1 공백 = 1 탭)
inspection.inconsistent.text.block.indent.tabs.to.spaces.one.to.many.fix=탭을 공백으로 바꾸기(1 탭 = {0} 공백)
inspection.inconsistent.text.block.indent.tabs.to.spaces.one.to.one.fix=탭을 공백으로 바꾸기(1 탭 = 1 공백)
inspection.input.stream.constructor.message='InputStream'은 'Files.newInputStream()'을 사용하여 생성할 수 있습니다
inspection.insert.literal.underscores.display.name=Literal numérico ilegible
inspection.insert.literal.underscores.family.name=Insertar guiones bajos en literal numérico
inspection.io.stream.constructor.description='InputStream'과 'OutputStream'은 'Files' 메서드로 생성될 수 있습니다
inspection.java.8.collection.remove.if.display.name=El bucle se puede reemplazar con Collection.removeIf()
inspection.java.8.list.replace.all.display.name=루프는 'List.replaceAll()'로 대체될 수 있습니다
inspection.java.8.map.api.display.name=Se puede utilizar el método de mapa único
inspection.java.9.collection.factory.display.name=La creación de colección inmutable se puede reemplazar con una llamada de fábrica de colección
inspection.javadoc.blank.lines.display.name=빈 줄은 <p>로 대체되어 줄을 나누어야 합니다
inspection.javadoc.blank.lines.fix.family.name=빈 줄을 <p>로 대체
inspection.javadoc.blank.lines.fix.name=삽입 <p>
inspection.javadoc.blank.lines.message=빈 줄은 무시됩니다
inspection.javadoc.label.text=Etiquetas Javadoc adicionales:
inspection.javadoc.link.as.plain.text.display.name=지정된 항목을 평문으로 연결
inspection.javadoc.link.as.plain.text.message=지정된 항목을 평문으로 연결
inspection.javadoc.lint.display.name=Problemas HTML en Javadoc(DocLint)
inspection.javadoc.method.problem.missing.param.tag=Falta la etiqueta obligatoria <code> @param</code> para el parámetro {0}
inspection.javadoc.method.problem.missing.tag.description=Falta la descripción de la etiqueta {0}
inspection.javadoc.option.ignore.deprecated=Ignorar elementos marcados como @deprecated
inspection.javadoc.option.ignore.period=Ignorar problemas de período
inspection.javadoc.option.ignore.self.ref=Ignorar Javadoc apuntando a sí mismo
inspection.javadoc.option.ignore.simple=Ignorar accesos de propiedad simples
inspection.javadoc.option.ignore.throws=Ignorar etiqueta duplicada 'throws'
inspection.javadoc.option.tab.title=Clase
inspection.javadoc.option.tab.title.field=Campo
inspection.javadoc.option.tab.title.inner.class=Clase interna
inspection.javadoc.option.tab.title.method=Método
inspection.javadoc.option.tab.title.module=Módulo
inspection.javadoc.option.tab.title.package=Paquete
inspection.javadoc.problem.add.param.tag=Agregar etiqueta @param para el parámetro ''{0}''
inspection.javadoc.problem.add.param.tag.family=Agregar etiqueta de parámetro Javadoc faltante
inspection.javadoc.problem.add.tag=Agregar etiqueta @{0} {1}
inspection.javadoc.problem.add.tag.family=Agregar etiqueta Javadoc faltante
inspection.javadoc.problem.cannot.resolve=No se puede resolver el símbolo {0}
inspection.javadoc.problem.descriptor=Javadoc requerido está ausente
inspection.javadoc.problem.descriptor1=Falta un punto en la documentación. La herramienta Javadoc utiliza el período para generar el comentario para la página de descripción general
inspection.javadoc.problem.disallowed.tag=La etiqueta {0} no está permitida aquí
inspection.javadoc.problem.duplicate.param=Etiqueta @param duplicada para el parámetro ''{0}''
inspection.javadoc.problem.duplicate.tag=Etiqueta @ {0} duplicada
inspection.javadoc.problem.duplicate.throws=Etiqueta @throws o @exception duplicada para la excepción ''{0}''
inspection.javadoc.problem.inaccessible=El símbolo {0} es inaccesible desde aquí
inspection.javadoc.problem.missing.tag=Falta la etiqueta obligatoria {0}
inspection.javadoc.problem.missing.tag.description=Falta {0} después de la etiqueta @ {1}
inspection.javadoc.problem.name.expected=Nombre esperado
inspection.javadoc.problem.pointing.to.itself=Javadoc apuntando a sí mismo
inspection.javadoc.problem.see.tag.expecting.ref=Se espera referencia de clase/método, texto entre comillas o enlace HTML después de la etiqueta @see
inspection.javadoc.problem.snippet.tag.is.not.available='@snippet' 태그는 이 언어 수준에서 사용할 수 없습니다
inspection.javadoc.problem.wrong.tag=Etiqueta incorrecta {0}
inspection.javadoc.ref.display.name=La declaración tiene problemas en las referencias de Javadoc
inspection.javadocDeclaration.display.name=Javadoc 선언 문제
inspection.join.declaration.and.assignment.display.name=La asignación se puede unir con la declaración
inspection.join.declaration.and.assignment.fix.family.name=Declaración de unión y asignación
inspection.join.declaration.and.assignment.message=La asignación se puede unir con la declaración ''{0}''
inspection.labeled.switch.rule.redundant.code.block.display.name=La regla del interruptor etiquetado tiene un bloque de código redundante
inspection.labeled.switch.rule.redundant.code.block.message=El bloque de código de la regla etiquetada es redundante
inspection.labeled.switch.rule.redundant.code.fix.name=Desenvolver bloque de código de la regla etiquetada
inspection.lambda.can.be.method.call.display.name=Lambda se puede reemplazar con una llamada al método
inspection.lambda.to.method.call.fix.family.name=Reemplazar expresión lambda con llamada al método
inspection.lambda.to.method.call.fix.name=Reemplazar expresión lambda con ''{0}''
inspection.magic.constant.display.name=Constante mágica
inspection.magic.constants.should.be.one.of.values=Debe ser uno de: {0} {1,choice,0#| 1#o su combinación}
inspection.manual.min.max.calculation.description=Puede ser reemplazado con la llamada '' Math. {0} ''
inspection.manual.min.max.calculation.disable.for.non.integral=Desactivar para flotación y doble
inspection.manual.min.max.calculation.display.name=Cálculo manual mínimo/máximo
inspection.map.foreach.display.name=Map.forEach() se puede utilizar
inspection.map.foreach.option.no.loops=No reportar bucles
inspection.meaningless.record.annotation.description=의미 없는 레코드 어노테이션
inspection.meaningless.record.annotation.message.method=어노테이션이 효과가 없습니다. 어노테이션의 타깃은 METHOD이지만 해당 접근자가 명시적으로 선언되어 있습니다
inspection.meaningless.record.annotation.message.method.and.parameter=어노테이션이 효과가 없습니다. 어노테이션의 타깃은 METHOD 및 PARAMETER이지만 접근자와 표준 생성자 모두 명시적으로 선언되어 있습니다
inspection.meaningless.record.annotation.message.parameter=어노테이션이 효과가 없습니다. 어노테이션의 타깃은 PARAMETER이지만 표준 생성자가 명시적으로 선언되어 있습니다
inspection.message.anonymous.ref.loc.can.be.replaced.with.method.reference=Anonymous#ref#loc se puede reemplazar con la referencia del método
inspection.message.can.be.replaced.with.0.constructor=Puede ser reemplazado con el constructor ''{0}''
inspection.message.can.be.replaced.with.files.readstring=Puede ser reemplazado con 'Files.readString()'
inspection.message.can.be.replaced.with.files.writestring=Puede ser reemplazado por 'Files.writeString()'
inspection.message.can.be.replaced.with.optional.of.nullable=Puede ser reemplazado por Optional.ofNullable()
inspection.message.can.be.replaced.with.single.expression.in.functional.style=Se puede reemplazar con una sola expresión en estilo funcional
inspection.message.can.be.replaced.with.string.repeat=Puede ser reemplazado por 'String.repeat()'
inspection.message.external.snippet.differs.from.inline.snippet=외부 스니펫이 인라인 스니펫과 다릅니다
inspection.message.filter.is.present.chain.can.be.replaced.with.anymatch=''filter().{0}().isPresent()'' cadena no se puede reemplazar con '' anyMatch () ' 'Hay
inspection.message.full.description=Descripción completa
inspection.message.lambda.parameter.type.is.redundant=El tipo de parámetro Lambda es redundante
inspection.message.pattern.variables.can.be.replaced.with.cast=패턴을 포함하여 'instanceof'를 사용
inspection.message.pattern.variables.can.be.replaced.with.cast.family.name=패턴 없이 바꾸기
inspection.message.pattern.variables.can.be.replaced.with.cast.fix.name=''{0}''을(를) 형 변환으로 바꾸기
inspection.message.pattern.variables.can.be.replaced.with.cast.preserve.option=빠른 수정 중 패턴에서 사용되지 않는 변수를 보존하도록 시도
inspection.message.pseudo.functional.style.code=Código de estilo pseudo funcional
inspection.message.record.can.be.converted.to.class=Puede convertir un registro en una clase
inspection.message.redundant.default.parameter.value.assignment=Asignación de valor de parámetro predeterminado redundante
inspection.message.replace.optional.with.if.statements=Reemplazar opcional con declaraciones if
inspection.message.snippet.file.not.found=스니펫 파일 ''{0}''을(를) 찾을 수 없습니다
inspection.message.snippet.region.not.found=리전을 찾을 수 없습니다
inspection.missingJavadoc.display.name=Javadoc 누락
inspection.missingJavadoc.label.minimalVisibility=최소 가시성:
inspection.missingJavadoc.label.requiredTags=필수 태그:
inspection.move.field.assignment.to.initializer.display.name=La asignación de campo se puede mover al inicializador
inspection.no.jdk.error.message=El JDK no está configurado correctamente para este proyecto. La inspección no puede continuar.
inspection.no.modules.error.message=Este proyecto no contiene módulos. La inspección no puede continuar.
inspection.notnull.field.not.initialized.display.name=@NotNull El campo no está inicializado
inspection.notnull.field.not.initialized.message={0} campos deben inicializarse
inspection.notnull.field.not.initialized.option.implicit=Ignorar campos que podrían inicializarse implícitamente
inspection.notnull.field.not.initialized.option.setup=Ignorar campos inicializados en el método setUp()
inspection.null.value.for.optional.assigned.ignore.fix.name=No advertir al comparar Opcional con nulo
inspection.null.value.for.optional.assigned.message=El valor opcional se compara con nulo
inspection.null.value.for.optional.context.assignment=asignación
inspection.null.value.for.optional.context.declaration=선언
inspection.null.value.for.optional.context.lambda=expresión lambda
inspection.null.value.for.optional.context.parameter=parámetro
inspection.null.value.for.optional.context.return=declaración de retorno
inspection.null.value.for.optional.fix.family.name=Reemplazar con método opcional vacío
inspection.null.value.for.optional.message=Null se usa para el tipo "Opcional" en {0}
inspection.null.value.for.optional.option.comparisons=Informe de comparación de Opcional con nulo
inspection.nullable.problems.display.name=@NotNull/@ Problemas que aceptan valores NULL
inspection.nullable.problems.ignore.external.notnull=&Ignorar externa @NotNull
inspection.nullable.problems.method.overrides.notnull.option=<html>Informar @NotNull y parámetros que anulan los métodos @Nullable y<br>@Nullable que anulan @NotNull</html>
inspection.nullable.problems.method.overrides.option=Informe de parámetros o métodos no anotados o anulados que anulan @NotNull
inspection.nullable.problems.not.annotated.getters.for.annotated.fields=Informar parámetros no anotados y de establecimiento o captadores de campos anotados
inspection.nullable.problems.notnull.overrides.option=Informe @NotNull y parámetros que anulan los no anotados
inspection.nullable.problems.notnull.parameters.with.null.literal.option=Informar de los parámetros @NotNull con usos de argumentos literales nulos
inspection.obvious.null.check.display.name=Se llama al método de verificación nula con un argumento obviamente no nulo
inspection.optional.assigned.to.null.display.name=Valor nulo para el tipo opcional
inspection.optional.get.without.is.present.display.name=Se llama a Optional.get() sin la verificación isPresent()
inspection.optional.get.without.is.present.message=<code> {0}.#ref()</code> sin la marca '' isPresent() ''
inspection.optional.get.without.is.present.method.reference.message='isPresent()' 확인이 없는 <code>#ref</code>
inspection.optional.is.present.display.name=Optional.isPresent() se puede reemplazar con una expresión de estilo funcional
inspection.optional.to.if.display.name=Opcional se puede reemplazar con la secuencia de instrucciones if
inspection.output.stream.constructor.message='OutputStream'은 'Files.newOutputStream()'을 사용하여 생성할 수 있습니다
inspection.overflowing.loop.index.inspection.description=El bucle se ejecuta cero o miles de millones de veces
inspection.overflowing.loop.index.inspection.name=Loop se ejecuta cero o miles de millones de veces
inspection.overwritten.key.array.message=덮어쓰기된 배열 요소
inspection.overwritten.key.display.name=Clave de mapa sobrescrita o elemento de conjunto
inspection.overwritten.key.map.message=Clave de mapa duplicado
inspection.overwritten.key.set.message=Elemento de conjunto duplicado
inspection.parameter.can.be.local.display.name=El parámetro puede ser local
inspection.parameter.can.be.local.problem.descriptor=El parámetro se puede convertir a una variable local
inspection.preview.feature=테스트 버전 기능 경고
inspection.preview.feature.0.is.preview.api.message={0}은(는) 테스트 버전 API이며 향후 릴리즈 버전에서 제거될 수 있습니다
inspection.quickfix.assert.family=Afirmar
inspection.raw.use.of.parameterized.type.problem.descriptor=매개변수화된 클래스 <code>#ref</code>의 원시 사용 #loc
inspection.read.write.string.can.be.used.display.name=Se puede utilizar 'Files.readString()' o 'Files.writeString()'
inspection.redundant.array.creation.display.name=Creación de matriz redundante
inspection.redundant.array.creation.for.varargs.call.descriptor=Creación de matriz redundante para llamar al método varargs
inspection.redundant.array.creation.quickfix=Eliminar la creación de matriz explícita
inspection.redundant.explicit.close=Redundante 'close()'
inspection.redundant.file.creation.description=<code>\#ref</code>이(가) 중복됩니다 \#loc
inspection.redundant.file.creation.display.name=중복 파일 객체 생성
inspection.redundant.file.creation.quickfix=파일 이름으로 바꾸기
inspection.redundant.lambda.parameter.type.display.name=Tipos de parámetros lambda redundantes
inspection.redundant.null.check.always.fail.message=La verificación nula siempre fallará: {0} nunca es nulo
inspection.redundant.null.check.fix.family.name=Eliminar verificación nula redundante
inspection.redundant.null.check.fix.notnull.family.name=Eliminar erróneo '!=null'
inspection.redundant.null.check.message=Verificación nula redundante: {0} nunca es nulo
inspection.redundant.operation.on.empty.array.message=Array <code>#ref</code> siempre está vacío
inspection.redundant.operation.on.empty.collection.message=La colección <code>#ref</code> siempre está vacía
inspection.redundant.operation.on.empty.container.display.name=Operación redundante en contenedor vacío
inspection.redundant.operation.on.empty.map.message=El mapa <code>#ref</code> siempre está vacío
inspection.redundant.record.constructor.can.be.compact.message=El constructor canónico se puede convertir a forma compacta
inspection.redundant.record.constructor.canonical.message=Constructor canónico redundante
inspection.redundant.record.constructor.compact.message=Constructor compacto redundante
inspection.redundant.record.constructor.description=Constructor de registros redundantes
inspection.redundant.record.constructor.fix.family.name=Convertir constructor canónico a forma compacta
inspection.redundant.record.constructor.statement.message=Asignación de campo redundante en constructor compacto
inspection.redundant.stream.optional.call.display.name=Paso redundante en Stream o cadena de llamadas opcional
inspection.redundant.stream.optional.call.explanation.at.most.one=el flujo contiene como máximo un elemento
inspection.redundant.stream.optional.call.explanation.distinct=ya había una llamada 'distinta' en la cadena
inspection.redundant.stream.optional.call.explanation.distinct.set=los elementos serán distintos de todos modos cuando se recopilen en el conjunto
inspection.redundant.stream.optional.call.explanation.filter=El predicado siempre es verdadero
inspection.redundant.stream.optional.call.explanation.map.flatMap=la llamada anterior 'map' puede reemplazar el paso 'flatMap'
inspection.redundant.stream.optional.call.explanation.parallel=hay una llamada ''{0}'' posterior que anula esta llamada
inspection.redundant.stream.optional.call.explanation.parallel.single=el flujo creado a partir de un solo elemento no se paralelizará
inspection.redundant.stream.optional.call.explanation.parallel.source=스트림이 'parallelStream()'을 통해 생성되었으므로 이미 병렬입니다
inspection.redundant.stream.optional.call.explanation.sequential.source=스트림이 'stream()'을 통해 생성되었으므로 이미 순차적입니다
inspection.redundant.stream.optional.call.explanation.sorted=la llamada ''{0}'' subsiguiente no depende del orden de clasificación
inspection.redundant.stream.optional.call.explanation.sorted.parallel=순차적인 ''{0}()'' 연산은 병렬 스트림의 정렬 순서에 의존하지 않습니다
inspection.redundant.stream.optional.call.explanation.sorted.twice=el contenido de la transmisión se ordena nuevamente después de eso
inspection.redundant.stream.optional.call.explanation.unordered=ya había una llamada 'desordenada' en la cadena
inspection.redundant.stream.optional.call.fix.bind.name=''{0}()'' 단계를 이전 ''{1}()'' 단계와 병합
inspection.redundant.stream.optional.call.fix.collect.to.ordered.family.name=Recopilar en 'LinkedHashSet'
inspection.redundant.stream.optional.call.fix.family.name=Eliminar llamada en cadena redundante
inspection.redundant.stream.optional.call.fix.name=Eliminar llamada ''{0}''
inspection.redundant.stream.optional.call.fix.replace.terminal=터미널 작업 바꾸기
inspection.redundant.stream.optional.call.fix.replace.terminal.text=터미널 작업을 ''{0}()''(으)로 바꾸기
inspection.redundant.stream.optional.call.message=Llamada ''{0}'' redundante
inspection.redundant.stream.optional.call.message.with.explanation=중복 ''{0}'' 호출\: {1}
inspection.redundant.stream.optional.call.option.streamboxing=Informar sobre boxeo redundante en Stream.map
inspection.redundant.unmodifiable.call.description=Uso duplicado de envoltorios de colección no modificables
inspection.redundant.unmodifiable.call.display.name=Uso duplicado del contenedor de ''{0}''
inspection.redundant.unmodifiable.call.unwrap.argument.quickfix=Desenvolver argumento
inspection.reflect.handle.invocation.argument.not.array=El argumento no es un tipo de matriz
inspection.reflect.handle.invocation.argument.not.exact=El tipo de argumento debe ser exactamente ''{0}''
inspection.reflect.handle.invocation.primitive.argument.null=El argumento del tipo ''{0}'' no puede ser '' nulo ''
inspection.reflect.handle.invocation.receiver.incompatible=El tipo de receptor de llamada es incompatible: se espera ''{0}''
inspection.reflect.handle.invocation.receiver.null=El receptor de la llamada es 'nulo'
inspection.reflect.handle.invocation.result.not.assignable=Debería ser lanzado a ''{0}'' o su superclase
inspection.reflect.handle.invocation.result.not.exact=Debería convertirse en ''{0}''
inspection.reflect.handle.invocation.result.null=El valor devuelto es siempre 'nulo'
inspection.reflect.handle.invocation.result.void=El tipo de retorno es 'void'
inspection.reflection.invocation.argument.count={0,choice,0#No hay argumentos|1#Un argumento es|1 <{0} argumentos son} esperados
inspection.reflection.invocation.argument.not.assignable=El argumento no se puede asignar a ''{0}''
inspection.reflection.invocation.array.not.assignable=Matriz {0,choice,1#elemento tiene|1 <elementos tienen} incompatible {0,choice,1#tipo|1 <tipos}
inspection.reflection.invocation.item.count={0,choice,0#La matriz vacía es|1#La matriz de un solo elemento es|1 <Se esperan {0} elementos de la matriz
inspection.reflection.invocation.item.not.assignable=El elemento de la matriz no se puede asignar a ''{0}''
inspection.reflection.invocation.name=Los argumentos de invocación reflectante no coinciden
inspection.reflection.member.access.cannot.resolve.constructor.arguments=No se puede resolver el constructor con tipos de argumentos especificados
inspection.reflection.member.access.cannot.resolve.field=No se puede resolver el campo ''{0}''
inspection.reflection.member.access.cannot.resolve.method=No se puede resolver el método ''{0}''
inspection.reflection.member.access.cannot.resolve.method.arguments=No se puede resolver el método ''{0}'' con tipos de argumentos especificados
inspection.reflection.member.access.check.exists=Verifique que el campo/método exista en clases no finales
inspection.reflection.member.access.check.exists.exclude.chooser=Clase para excluir
inspection.reflection.member.access.check.exists.exclude.label=클래스 제외:
inspection.reflection.member.access.constructor.not.public=El constructor no es público
inspection.reflection.member.access.field.not.in.class=El campo ''{0}'' no está declarado en la clase ''{1}''
inspection.reflection.member.access.field.not.public=El campo ''{0}'' no es público
inspection.reflection.member.access.fix.family.name=Use el método de reflexión apropiado
inspection.reflection.member.access.method.not.in.class=El método ''{0}'' no está declarado en la clase ''{1}''
inspection.reflection.member.access.method.not.public=El método ''{0}'' no es público
inspection.reflection.member.access.name=Acceso reflectante a miembro de clase inexistente/no visible
inspection.reflection.visibility.name=Problemas de acceso reflectante a través de módulos
inspection.remove.literal.underscores.display.name=Guiones bajos en literal numérico
inspection.remove.literal.underscores.family.name=Eliminar guiones bajos del literal numérico
inspection.replace.inefficient.stream.count.display.name=Cadenas de llamadas de la API de Stream ineficientes que terminan en count()
inspection.replace.javadoc.display.name=Javadoc으로 대체 가능한 주석
inspection.replace.methodref.ternary.quickfix=Reemplazar con lambda de verificación nula
inspection.replace.ternary.quickfix=Reemplazar con ''{0} != null ?:''
inspection.replace.with.bulk.file.attributes.read.fix.family.name=일괄 'Files.readAttributes()' 호출로 바꾸기
inspection.replace.with.bulk.fix.family.name=Reemplazar con llamada de método masivo
inspection.replace.with.bulk.fix.name=Reemplazar iteración con llamada masiva ''{0}''
inspection.replace.with.bulk.message=La iteración se puede reemplazar con una llamada masiva ''{0}''
inspection.replace.with.bulk.wrap.arrays=Use Arrays.asList() para envolver arreglos
inspection.replace.with.enhanced.switch.statement.fix.name=Reemplazar con declaración mejorada 'switch'
inspection.replace.with.javadoc=Javadoc 주석으로 바꾸기
inspection.replace.with.javadoc.comment=주석을 Javadoc으로 변환할 수 있습니다
inspection.replace.with.old.style.switch.statement.fix.name=Reemplazar con la declaración 'switch' de estilo antiguo
inspection.replace.with.regular.string.literal.fix=Reemplazar con literal de cadena regular
inspection.replace.with.switch.expression.fix.family.name=향상된 switch로 마이그레이션
inspection.replace.with.switch.expression.fix.name=Reemplazar con expresión 'cambiar'
inspection.replace.with.text.block.fix=Reemplazar con bloque de texto
inspection.replace.with.trivial.lambda.fix.family.name=Reemplazar con lambda trivial
inspection.replace.with.trivial.lambda.fix.name=Reemplazar con lambda devolviendo ''{0}''
inspection.require.non.null=Reemplazar verificación nula con llamada estática de Objetos/Stream
inspection.require.non.null.description=La verificación nula se puede reemplazar con una llamada al método
inspection.require.non.null.message=Reemplazar condición con {0}
inspection.require.non.null.no.warning.replacement.bigger=No advertir si la longitud del reemplazo es mayor que la original
inspection.require.non.null.quickfix={0, choice, 1#''if'' 문|2#조건식}을 ''{1}()'' 호출로 바꾸기
inspection.return.separated.from.computation.descriptor=Retorno separado del cálculo del valor de ''{0}''
inspection.return.separated.from.computation.family.quickfix=Mueva 'retorno' más cerca del cálculo del resultado
inspection.return.separated.from.computation.name='return' separado del cálculo del resultado
inspection.return.separated.from.computation.quickfix=Mueva ''return'' más cerca del cálculo del valor de ''{0}''
inspection.same.parameter.display.name=El parámetro del método real es la misma constante
inspection.same.parameter.fix.family.name=Parámetro en línea como valor constante
inspection.same.parameter.fix.name=Valor en línea ''{1}'' para el parámetro ''{0}''
inspection.same.parameter.problem.descriptor=El valor real del parámetro ''{0}'' es siempre ''{1}''
inspection.simplifiable.comparator.comparing.message=Innecesaria llamada ''{0}()''
inspection.simplifiable.comparator.display.name=El comparador se puede simplificar
inspection.simplifiable.comparator.entry.comparator.message=En su lugar, se puede utilizar ''{0}''
inspection.simplifiable.comparator.fix.comparing.family.name=Eliminar llamada redundante
inspection.simplifiable.comparator.fix.entry.comparator.family.name=Usar comparador de Map.Entry predefinido
inspection.simplifiable.comparator.fix.remove.name=Eliminar llamada ''{0}()''
inspection.simplifiable.comparator.fix.replace.name=Eliminar la llamada ''{0}()'' y usar '' {1}() ''
inspection.simplifiable.comparator.fix.reversed.family.name=Simplifique el comparador reemplazando 'max' por 'min'
inspection.simplifiable.comparator.fix.reversed.name=Reemplazar con ''{0}'' simplificando el comparador
inspection.simplifiable.comparator.reversed.message=El comparador se puede simplificar si la llamada '' {0}() '' se reemplaza por '' {1}() ''
inspection.simplify.collector.display.name=El recopilador se puede simplificar
inspection.simplify.collector.fix.family.name=Simplificar el colector en cascada
inspection.simplify.collector.fix.name=Utilice el recopilador '' Colectores. {0}''
inspection.simplify.collector.message=Puede simplificarse usando el colector ''{0}''
inspection.simplify.for.each.extract.intermediate.operations=Extraer operaciones intermedias
inspection.simplify.foreach.display.name=Llamada forEach() simplificable
inspection.simplify.optional.call.chains.display.name=La cadena de llamadas opcional se puede simplificar
inspection.simplify.stream.api.call.chains.display.name=La cadena de llamadas de la API de transmisión se puede simplificar
inspection.slow.abstract.set.remove.all.description='set.removeAll(list)' 호출은 느리게 작동할 수 있습니다
inspection.slow.abstract.set.remove.all.fix.family.name='Set.removeAll' 대신 'Set.remove' 사용
inspection.slow.list.contains.all.description='list.containsAll(collection)' 호출의 성능이 낮아질 수 있습니다
inspection.slow.list.contains.all.fix.family.name='HashSet' 생성자로 래핑
inspection.slow.list.contains.all.fix.name=''{0}''을(를) ''HashSet'' 생성자로 래핑
inspection.sorted.collection.with.non.comparable.keys.display.name=Colección ordenada con elementos no comparables
inspection.sorted.collection.with.non.comparable.keys.message=Construcción de colección ordenada con elementos no comparables
inspection.sorted.collection.with.non.comparable.keys.option.type.parameters=No informe parámetros de tipo no comparables
inspection.static.pseudo.functional.style.method.display.name=Expresión pseudo funcional usando clase estática
inspection.stream.api.migration.can.be.replaced.with.call=Puede ser reemplazado con la llamada ''{0}''
inspection.stream.to.loop.display.name=La cadena de llamadas de la API de transmisión se puede reemplazar con un bucle
inspection.string.repeat.can.be.used.display.name=Se puede utilizar String.repeat()
inspection.surround.if.family=Rodear con if
inspection.surround.if.quickfix=Rodear con ''if ({0}{1})''
inspection.suspicious.list.remove.display.name='List.remove()' sospechoso en el bucle
inspection.suspicious.return.byte.input.stream.convert.to.unsigned=부호가 없는 byte로 변환
inspection.suspicious.return.byte.input.stream.name='InputStream.read()'로부터 의심수러운 byte 값이 반환됨
inspection.suspicious.ternary.in.varargs.description=vararg 호출 내 삼항 연산자에 배열 및 배열이 아닌 브랜치가 포함되어 있습니다
inspection.suspicious.ternary.in.varargs.display.name=vararg 메서드 호출 내 의심스러운 삼항 연산자
inspection.suspicious.ternary.in.varargs.quickfix=배열 이니셜라이저 줄 바꿈
inspection.switch.expression.backward.expression.migration.inspection.name=La expresión 'switch' se puede reemplazar con una declaración de estilo antiguo 'switch'
inspection.switch.expression.backward.migration.inspection.name=El nuevo estilo 'interruptor' puede ser reemplazado por uno antiguo
inspection.switch.expression.backward.statement.migration.inspection.name=la declaración 'switch' se puede reemplazar con la declaración 'switch' de estilo antiguo
inspection.switch.expression.migration.expression.max.statements=한 브랜치 내에서 switch 식으로 변환할 최대 구문 수
inspection.switch.expression.migration.inspection.name=La declaración se puede reemplazar con un 'interruptor' mejorado
inspection.switch.expression.migration.inspection.switch.description=La instrucción Switch se puede reemplazar con 'switch' mejorado
inspection.switch.expression.migration.option.expression.max.statements=단일 브랜치 내에 {0}개 이상의 {0, choice, 1#구문|2#구문}이 있는 switch는 보고 안 함
inspection.switch.expression.migration.warn.only.on.expression=Mostrar advertencia solo si la conversión a expresión es posible
inspection.switch.labeled.rule.can.be.code.block.display.name=La regla del interruptor etiquetado puede tener un bloque de código
inspection.switch.labeled.rule.can.be.code.block.expression.message=La expresión del resultado de la regla etiquetada se puede ajustar con un bloque de código
inspection.switch.labeled.rule.can.be.code.block.fix.expression.name=Envuelva la expresión de resultado de la regla etiquetada con bloque de código
inspection.switch.labeled.rule.can.be.code.block.fix.statement.name=Envuelva la declaración de la regla etiquetada con el bloque de código
inspection.switch.labeled.rule.can.be.code.block.statement.message=La declaración de la regla etiquetada se puede envolver con un bloque de código
inspection.text.block.backward.migration.message=El bloque de texto se puede convertir en un literal de cadena normal
inspection.text.block.backward.migration.name=El bloque de texto se puede reemplazar con un literal de cadena regular
inspection.text.block.migration.concatenation.message=연결을 텍스트 블록으로 바꿀 수 있습니다
inspection.text.block.migration.name=Se puede utilizar un bloque de texto
inspection.text.block.migration.string.message=문자열을 텍스트 블록으로 바꿀 수 있습니다
inspection.text.block.migration.suggest.literal.replacement=Sugerir reemplazar cadena con saltos de línea
inspection.trailing.whitespaces.in.text.block.message=텍스트 블록 내 후행 공백이 있습니다
inspection.trailing.whitespaces.in.text.block.name=텍스트 블록 내 후행 공백
inspection.trailing.whitespaces.in.text.block.remove.whitespaces=후행 공백 제거
inspection.trailing.whitespaces.in.text.block.replaces.whitespaces.with.escapes=후행 공백 이스케이프
inspection.trivial.functional.expression.usage.display.name=Uso trivial de expresión funcional
inspection.unchecked.warning.display.name=Advertencia sin marcar
inspection.undeclared.service.usage.message=El uso del servicio ''{0}'' no está declarado en module-info
inspection.undeclared.service.usage.name=Uso del servicio no declarado en 'module-info'
inspection.unused.assignment.display.name=Asignación no utilizada
inspection.unused.assignment.option=Informe ++ i cuando puede ser reemplazado por (i + 1)
inspection.unused.assignment.option1=Informe i ++ cuando el valor modificado no se utilice posteriormente
inspection.unused.assignment.option2=Informar inicializadores redundantes
inspection.unused.assignment.option3=값이 한 번도 사용되지 않는 패턴 변수를 보고
inspection.unused.assignment.option4=값이 한 번도 사용되지 않는 반복 변수를 보고
inspection.unused.assignment.problem.descriptor1=La variable {0} nunca se usa
inspection.unused.assignment.problem.descriptor2=La variable {0} inicializador {1} es redundante
inspection.unused.assignment.problem.descriptor3=El valor {0} asignado a {1} nunca se usa
inspection.unused.assignment.problem.descriptor4=El valor cambiado en {0} nunca se usa
inspection.unused.assignment.problem.descriptor5=패턴 변수 <code>#ref</code> #loc의 값이 한 번도 사용되지 않습니다
inspection.unused.assignment.problem.descriptor6=foreach 반복 매개변수 <code>#ref</code> #loc의 값이 한 번도 사용되지 않습니다
inspection.unused.assignment.remove.assignment.quickfix=Eliminar asignación redundante
inspection.unused.assignment.remove.quickfix=Eliminar inicializador redundante
inspection.unused.display.name=Declaración no utilizada
inspection.unused.parameter.composer=El parámetro <code>#ref</code> no se utiliza en ninguna implementación
inspection.unused.parameter.composer1=El parámetro <code>#ref</code> no se utiliza en este método ni en ninguno de sus métodos derivados
inspection.unused.parameter.delete.family=사용되지 않는 매개변수를 안전하게 삭제
inspection.unused.parameter.delete.quickfix=Eliminar parámetros no utilizados
inspection.unused.parameter.problem.descriptor=매개변수 <code>#ref</code>가 사용되지 않습니다.
inspection.unused.return.value.display.name=El método puede ser nulo
inspection.unused.return.value.make.void.quickfix=Hacer que el método sea 'void'
inspection.unused.return.value.problem.descriptor=El valor de retorno del método nunca se usa
inspection.unused.symbol.check.accessors=Captadores/definidores
inspection.unused.symbol.check.classes=Clases:
inspection.unused.symbol.check.fields=Campos:
inspection.unused.symbol.check.inner.classes=Clases internas:
inspection.unused.symbol.check.localvars=Variables locales
inspection.unused.symbol.check.methods=Métodos:
inspection.unused.symbol.check.parameters=Parámetros en
inspection.unused.symbol.check.parameters.excluding.hierarchy=계층 구조 제외
inspection.use.bulk.operation.display.name=Se puede usar operación masiva en lugar de iteración
inspection.value.based.warnings=값 기준 경고
inspection.value.based.warnings.synchronization=값 기준 클래스 인스턴스에서 동기화 시도
inspection.variable.assigned.to.itself.display.name=La variable se asigna a sí misma
inspection.wrapper.type.may.be.primitive.display.name=El tipo de envoltura puede ser primitivo
inspection.wrapper.type.may.be.primitive.fix.name=Convertir el tipo de envoltorio en primitivo
inspection.wrapper.type.may.be.primitive.name=El tipo puede ser primitivo
intention.add.explicit.type.arguments.family=Agregar argumentos de tipo explícito
intention.add.on.demand.static.import.family=Agregar importación estática bajo demanda
intention.add.on.demand.static.import.text=Agregar importación estática bajo demanda para ''{0}''
intention.add.single.member.import.text=Agregar importación para ''{0}''
intention.add.single.member.static.import.family=Agregar importación estática de un solo miembro
intention.add.single.member.static.import.text=Agregar importación estática para ''{0}''
intention.assign.field.from.parameter.family=Asignar parámetro al campo
intention.assign.field.from.parameter.text=Asignar parámetro al campo ''{0}''
intention.bind.fields.from.parameters.family=Vincular parámetros a campos
intention.bind.fields.from.parameters.text=Vincular {0} parámetros a campos
intention.break.string.on.line.breaks.text=Cadena de ruptura en '\\n'
intention.category.annotations=Java/어노테이션
intention.category.collections=Java/컬렉션
intention.category.comments=Java/주석
intention.category.concurrency=Java/동시성
intention.category.conditional.operator=Java/조건
intention.category.control.flow=Java/제어 흐름
intention.category.declaration=Java/선언
intention.category.expressions=Java/표현식
intention.category.i18n=Java/국제화
intention.category.imports=Java/Import 문
intention.category.junit=Java/JUnit
intention.category.other=Java/기타
intention.category.refactorings=Java/리팩터링
intention.category.streams=Java/스트림
intention.category.strings=Java/문자열
intention.category.try.statements=Java/Try 문
intention.compose.function.family=Reemplazar llamada a función anidada con composición
intention.compose.function.text=Reemplazar la llamada a la función anidada con y Luego llamar
intention.convert.color.representation.family=Convertir representación de color
intention.convert.color.representation.text=Convertir a ''new Color{0}''
intention.convert.compact.constructor.to.canonical=Convertir constructor compacto a canónico
intention.convert.to.single.return.command.text=본문을 단일 종료점 형식으로 변환
intention.convert.to.single.return.name=Transforma el cuerpo en una forma de punto de salida único
intention.convert.to.single.return.progress.title=본문을 단일 종료점 형식으로 변환
intention.create.field.from.parameter.family=Crear campo para parámetro
intention.create.field.from.parameter.text=Crear campo para el parámetro ''{0}''
intention.create.switch.statement=switch 문 생성
intention.create.test.dialog.choose.super.class=Elija Superclase
intention.create.test.dialog.class.name=Nombre de la clase:
intention.create.test.dialog.fix.library=Arreglar
intention.create.test.dialog.generate=Generar:
intention.create.test.dialog.java=Java
intention.create.test.dialog.library.not.found={0} biblioteca no encontrada en el módulo
intention.create.test.dialog.select.methods=Generar prueba y métodos para:
intention.create.test.dialog.setUp=set&Up/@Before
intention.create.test.dialog.show.inherited=Mostrar y métodos heredados
intention.create.test.dialog.super.class=Superclase:
intention.create.test.dialog.tearDown=tear&Down/@After
intention.create.test.dialog.testing.library=Prueba y biblioteca:
intention.encapsulate.field.text=Encapsular campo
intention.error.cannot.create.class.message=No se puede crear la clase ''{0}''
intention.error.cannot.create.class.title=No se pudo crear la clase
intention.error.make.sealed.class.different.modules=일부 상속자가 다른 모듈에 있습니다
intention.error.make.sealed.class.different.packages=모듈 이름이 지정되지 않았으며 상속자 일부가 다른 패키지에 있습니다
intention.error.make.sealed.class.has.anonymous.or.local.inheritors=일부 상속자가 익명이거나 로컬입니다
intention.error.make.sealed.class.inheritors.not.in.java.file=일부 상속자가 Java 파일에 없습니다
intention.error.make.sealed.class.interface.has.no.inheritors=인터페이스에 상속자가 없습니다
intention.error.make.sealed.class.is.used.in.functional.expression=클래스가 함수 표현식에서 사용되었습니다
intention.extract.if.condition.family=Extraer si condición
intention.extract.if.condition.text=Extraer si ({0})
intention.extract.map.step.family=Extraer al método de mapeo separado
intention.extract.map.step.text=Extraer la variable ''{0}'' a la operación ''{1}''
intention.extract.method.text=Método de extracción
intention.extract.set.from.comparison.chain.duplicates={0} ha detectado {1} código {1,choice,1#fragment|2#fragments} en esta clase que se puede reemplazar usando Set recién creado. ¿Le gustaría reemplazar {1,choice,1#it|2#them}?
intention.extract.set.from.comparison.chain.family=Extraer conjunto de la cadena de comparación
intention.family.add.javadoc=Agregar Javadoc
intention.family.copy.abstract.method.implementation=Copiar la implementación del método abstracto
intention.family.create.a.class.in.package=Crear una clase en el paquete
intention.family.edit.method.contract=Editar contrato de método
intention.family.edit.range=Editar rango
intention.family.expand.static.import=Expandir importación estática
intention.family.fix.bounded.wildcards=Corregir comodines delimitados
intention.family.make.external.annotations.explicit=Hacer explícitas anotaciones externas
intention.family.make.inferred.annotations.explicit=Hacer explícitas anotaciones inferidas
intention.family.move.it=Moverlo
intention.family.name.box.primitive.in.conditional.branch=조건 분기의 원시값 박스
intention.family.name.convert.record.to.class=레코드를 클래스로 변환
intention.family.name.dismiss=닫기
intention.family.name.ignore.project=이 프로젝트에서 다시 표시 안 함
intention.family.name.make.sealed=sello de clase
intention.family.name.move.class.to.test.root=테스트 루트로 클래스 이동
intention.family.name.move.member.into.class=클래스로 멤버 이동
intention.family.name.set.explicit.variable.type=명시적 변수 유형 설정
intention.family.name.synchronize.inline.snippet=인라인 스니펫 동기화
intention.family.name.upgrade.jdk=JDK 업그레이드
intention.family.put.arguments.on.one.line=Pon los argumentos en una línea
intention.family.put.arguments.on.separate.lines=Coloque los argumentos en líneas separadas
intention.family.put.parameters.on.one.line=Coloque los parámetros en una línea
intention.family.put.parameters.on.separate.lines=Coloque los parámetros en líneas separadas
intention.family.put.record.components.on.one.line=레코드 구성 요소를 한 줄에 배치
intention.family.put.record.components.on.separate.lines=레코드 구성 요소를 별도의 줄에 배치
intention.family.replace.optional.ispresent.condition.with.functional.style.expression=Reemplazar la condición Optional.isPresent() con expresión de estilo funcional
intention.family.sort.content=Ordenar contenido
intention.family.swap.if.statements=Intercambiar declaraciones 'if'
intention.family.unimplement.interface.class=Interfaz/clase de unimplement
intention.family.variable.access.from.inner.class=Variable accessFromInnerClass
intention.implement.abstract.class.default.text=Implementar clase abstracta
intention.implement.abstract.class.family=Implementar clase o interfaz abstracta
intention.implement.abstract.method.command.name=Implementar método
intention.implement.abstract.method.error.no.classes.message=No se han encontrado clases donde se pueda implementar este método
intention.implement.abstract.method.error.no.classes.title=No se encontraron clases
intention.implement.abstract.method.family=Implementar método abstracto
intention.implement.abstract.method.searching.for.descendants.progress=Buscando descendientes...
intention.implement.abstract.method.text=Implementar método ''{0}''
intention.inline.map.family=Método de mapeo de flujo en línea
intention.inline.map.inline.text=Inline ''{0}'' cuerpo en la siguiente llamada ''{1}''
intention.inline.map.merge.text=Fusionar llamada ''{0}'' y llamada ''{1}''
intention.introduce.variable.text=Introducir variable local
intention.invert.if.condition=Invertir condición 'if'
intention.make.final.fixer.if=이니셜라이저를 ''if'' 문으로 이동하여 ''{0}''을(를) 실제로 final로 설정
intention.make.final.fixer.stream=스트림 API를 사용하여 ''{0}''을(를) 실제로 final로 설정
intention.make.sealed.class.hint.title=sealed로 설정
intention.make.sealed.class.task.title.set.inheritors.modifiers=상속자 제어자 설정 중
intention.merge.filter.family=Combinar filtros
intention.merge.filter.text=Combinar cadena de filtros
intention.move.field.assignment.to.declaration=Mover asignación a declaración de campo
intention.move.initializer.to.constructor=Mover inicializador al constructor
intention.move.initializer.to.set.up=Mover el inicializador al método de configuración
intention.name.collapse.into.loop=Colapsar en bucle
intention.name.copy.to.final.temp.variable=''{0}'' a {1, choice, 0\# |1\#actual} variable temporal final
intention.name.extract.method.to.new.interface=Extraer método ''{0}'' como nueva interfaz
intention.name.iterate.over={0} 반복
intention.name.make.variable.final={1, choice, 0\# '' ''{0}'' '' conjunto |1\#variable} final
intention.name.move.class.to.test.root=테스트 루트로 ''{0}'' 이동
intention.name.move.into.if.branches=Subir a las ramas de la declaración 'if'
intention.name.pull.method.up=Mover método ''{0}'' hacia arriba
intention.name.pull.method.up.and.make.it.abstract.conditionally=Mover método ''{0}'' a ''{1}'' {2, choice, establecido en 0\# abstract |1\#}
intention.name.pull.method.up.make.it.abstract=Mover el método ''{0}'' hacia arriba y hacerlo abstracto
intention.name.set.variable.type=변수 타입을 ''{0}''(으)로 설정
intention.name.transform.variables.into.final.one.element.array={1, choice, 0\# '' ''{0}'' '' a1\#variable} elemento único convertir a la matriz final de
intention.name.upgrade.jdk.to=JDK를 {0}+(으)로 업그레이드
intention.override.method.text=Anular método ''{0}''
intention.replace.concatenation.with.formatted.output.family=Reemplazar concatenación con salida formateada
intention.replace.concatenation.with.formatted.output.text=Reemplazar '+' con 'java.text.MessageFormat.format()'
intention.split.declaration.assignment.text=Dividir en declaración y asignación
intention.split.declaration.family=Declaración dividida
intention.split.filter.family=Filtro dividido
intention.split.filter.text=Dividir en cadena de filtros
intention.split.if.family=Dividir 'if'
intention.split.if.text=Dividir en 2 if's
intention.split.switch.branch.with.several.case.values.copy.text=Copiar rama 'switch'
intention.split.switch.branch.with.several.case.values.family=División de rama de interruptor con varios valores de caso en ramas de 'interruptor' individuales
intention.split.switch.branch.with.several.case.values.split.text=Valores divididos de la rama 'switch'
intention.surround.resource.with.ARM.block=Envolvente con bloque try-with-resources
intention.surround.with.ARM.block.template=try-with-resources
intention.text.add.method.contract.to.0=Agregar contrato de método a ''{0}''
intention.text.add.range.to.0=Agregar rango a ''{0}''
intention.text.annotate.externally=Anotar externamente
intention.text.collapse.repeating.annotations=Contraer anotaciones repetidas
intention.text.create.a.class.in.0=Crear una clase en ''{0}''
intention.text.create.a.class.in.package.preview=대화상자를 열어 패키지 ''{0}'' 내에 클래스를 생성합니다
intention.text.edit.method.contract.of.0=Editar contrato de método de ''{0}''
intention.text.edit.range.of.0=Editar rango de ''{0}''
intention.text.fix.method.0.parameters.with.bounded.wildcards=Corregir parámetros del método ''{0}'' con comodines delimitados
intention.text.generate.missed.test.methods=Generar métodos de prueba perdidos
intention.text.implements.list.remove.others=다른 ''{0}'' 참조 제거
intention.text.replace.implements.with.static.import=Reemplazar implementos con importación estática
intention.text.replace.static.import.with.qualified.access.to.0=Reemplazar importación estática con acceso calificado a {0}
intention.text.unimplement.0=Desimplementar {0}
intention.unroll.loop.family=Desenrollar bucle
intention.unwrap.else.branch=Desenvolver la rama 'else'
intention.unwrap.else.branch.changes.semantics=Desenvolver la rama 'else' (cambia la semántica)
intention.use.single.member.static.import.text=Usar importación estática para ''{0}''
intention.wrap.with.unmodifiable=Envolver con colección o mapa no modificable
intention.wrap.with.unmodifiable.list=Envolver con lista no modificable
intention.wrap.with.unmodifiable.map=Envolver con mapa no modificable
intention.wrap.with.unmodifiable.set=Envolver con un conjunto no modificable
interface.not.allowed=La interfaz no está permitida
interfaces.cannot.be.inlined=Las interfaces no se pueden insertar
introduce.functional.variable.accessibility.conflict=La variable {0} no es realmente final y, por lo tanto, no se puede acceder a ella dentro de una expresión de función
introduce.functional.variable.interface.chooser.title=Elija la interfaz funcional aplicable\: {0} -> {1}
introduce.functional.variable.nothing.found.message=No se encontró una interfaz de función aplicable
introduce.parameter.advertisement.text={0}을(를) 눌러 오버로드 메서드로 위임하거나 {1}을(를) 눌러 더 많은 옵션 표시
introduce.parameter.inlay.title.delegate=위임
introduce.parameter.inlay.tooltip.delegate=오버로딩 메서드를 통한 위임
introduce.parameter.object.no.accessor.conflict.message=requiere {0, choice, 0\#getter |1\#setter} del campo ''{1}''
introduce.variable.change.semantics.warning=Extraer la expresión seleccionada cambia el significado de toda la expresión.
introduce.variable.change.type.adv=Cambie el tipo presionando {0}
introduce.variable.reassign.adv=Reasigne una variable existente presionando {0}
invalid.extracted.class.name=''{0}'' es un nombre de clase extraído no válido
invert.quickfix.preview=선택한 부울을 반전하고 새 이름을 선택하는 대화상자를 엽니다.
java.completion.tag={0, choice, 1#태그:|2#태그:}
java.implicit.types.inlay.provider.name=묵시적 타입
java.line.markers=Marcadores de línea Java
java.method.chains.inlay.provider.name=메서드 체인
java.platform.module.system.name=Java 플랫폼 모듈 시스템
java.preview.features.accept.notification.link=Aceptar
java.preview.features.alert.title=Alerta de función experimental
java.preview.features.legal.notice=Debe aceptar los términos del aviso legal de la especificación beta de Java para habilitar la compatibilidad con "{0}".<br/><br/> \
java.preview.features.notification.title=Funciones de vista previa de Java
java.preview.features.warning=Cuando se lance Java {0}, es posible que se elimine la compatibilidad con el nivel de lenguaje {1} (Vista previa)
java.terms.exception=excepción
java.terms.instance.initializer=inicializador de instancia
java.terms.of.annotation.type={0} de tipo de anotación {1}
java.terms.of.anonymous.class={0} de clase anónima
java.terms.of.class={0} de clase {1}
java.terms.of.enum={0} de enumeración {1}
java.terms.of.interface={0} de interfaz {1}
java.terms.region=리전
java.terms.static.initializer=inicializador estático
java.terms.type.parameter=parámetro de tipo
java.terms.variable.of.method={0} de {1}
javadoc.apiNote=Nota API:
javadoc.author=Autor:
javadoc.candidates.not.found=<html>No se encontraron candidatos para la llamada al método <b>{0}</b>.</html>
javadoc.constructor.candidates=<html>Los candidatos para el nuevo <b>{0}</b>() son:<br>{1}</html>
javadoc.deprecated=Desaprobado
javadoc.description.copied.from.class=Descripción copiada de la clase:
javadoc.description.copied.from.field=Descripción copiada del campo:
javadoc.description.copied.from.interface=Descripción copiada de la interfaz:
javadoc.description.inferred.annotation.hint=i
javadoc.documentation.url.checked=다음 문서 {0, choice, 1#URL을|2#URL을} 확인했습니다.
javadoc.edit.api.docs.paths=API 문서 경로 편집
javadoc.gen.error.module.source.path.is.not.evaluated=module-source-path를 평가할 수 없으므로 IDEA에서 Javadoc을 생성할 수 없습니다
javadoc.gen.error.modules.without.module.info=No se puede generar Javadoc en IDEA porque el archivo module-info.java no existe en el módulo {0}
javadoc.generate.arguments=&Otros argumentos de la línea de comando:
javadoc.generate.exited=\n "javadoc" terminó con el código de salida $EXIT_CODE$
javadoc.generate.heap.size=&Tamaño máximo de pila (Mb):
javadoc.generate.include.jdk.library.sources.in.sourcepath.option=Incluir JDK y fuentes de biblioteca en -sourcepath
javadoc.generate.link.to.jdk.documentation.option=Enlace a la documentación JDK (use la opción -link)
javadoc.generate.locale=&Locale:
javadoc.generate.no.classes.in.selected.packages.error=El alcance seleccionado no contiene clases Java
javadoc.generate.no.javadoc.tool={0} 또는 {1}에 javadoc 도구가 없어 JavaDoc을 생성할 수 없습니다. ''설정 | 프로젝트 구조''에서 올바른 Java SDK를 지정하세요.
javadoc.generate.no.jdk=프로젝트에 대해 구성된 Java SDK가 없어 JavaDoc을 생성할 수 없습니다. ''설정 | 프로젝트 구조''에서 Java SDK를 지정하세요.
javadoc.generate.ok=생성
javadoc.generate.open.in.browser=Abrir documento &generado en el navegador
javadoc.generate.options.hierarchy=Generar árbol de jerarquía
javadoc.generate.options.index=Generar índice
javadoc.generate.options.index.per.letter=Índice separado por letra
javadoc.generate.options.navigator=Generar barra de navegación
javadoc.generate.options.separator=JavaDoc 옵션
javadoc.generate.output.directory=Salida y directorio:
javadoc.generate.output.directory.browse=Examinar directorio de salida
javadoc.generate.scope.row=가시성 수준:
javadoc.generate.sources.progress=Buscando fuentes para generar Javadoc
javadoc.generate.tag.list.deprecated=lista obsoleta
javadoc.generate.temp.file.does.not.exist=임시 파일이 없거나 해당 파일을 열 수 없습니다
javadoc.generate.temp.file.error=No se puede crear un archivo temporal
javadoc.generate.title=Generar JavaDoc
javadoc.generate.validation.error=출력 디렉터리를 지정하세요.
javadoc.implNote=Nota de implementación:
javadoc.implSpec=Requisitos de implementación:
javadoc.method.in.class={0} en la clase {1}
javadoc.method.in.interface={0} en la interfaz {1}
javadoc.method.overrides=Anulaciones:
javadoc.method.specified.by=Especificado por:
javadoc.option.automatically.insert.closing.tag.javadoc=Inserta automáticamente la etiqueta de cierre en JavaDoc
javadoc.option.javadoc.title=JavaDoc
javadoc.see.also=Ver también:
javadoc.settings.title=Javadoc
javadoc.since=Desde:
javadoc.snippet.error.both.substring.and.regex=@{0}: 정규식 또는 부분 문자열 중 하나만 지정해야 합니다
javadoc.snippet.error.duplicate.attribute=@{0}: 중복 속성: ''{1}''
javadoc.snippet.error.malformed.regular.expression=@{0}: 형식이 잘못된 정규식: {1}
javadoc.snippet.error.malformed.replacement=@{0}: 형식이 잘못된 정규식 대체 ''{1}'': {2}
javadoc.snippet.error.markup.tag.expected=마크업 태그 또는 속성이 필요합니다
javadoc.snippet.error.missing.required.attribute=@{0}: 누락된 ''{1}'' 속성
javadoc.snippet.error.regex.too.complex=@{0}: 너무 복잡한 정규식 ''{1}''
javadoc.snippet.error.unknown.enum.value=@{0}: 알 수 없는 {1} ''{2}''. {3}만 지원됩니다
javadoc.snippet.error.unsupported.attribute=@{0}: 지원되지 않는 속성: ''{1}''
javadoc.snippet.not.found=스니펫을 찾을 수 없습니다. {0}
javadoc.snippet.region.not.found=리전을 찾을 수 없습니다. {0}
javadoc.type.parameters=Tipo de parámetros:
javadoc.version=Versión:
jrt.node.short=[JRT]
label.add.math.max.0.count.to.avoid.possible.semantics.change=Agregue Math.max(0, count) para evitar posibles cambios de semántica
label.canonical.constructor=Constructor canónico
label.class.filter.editor.add.dialog.filter.pattern=Ingrese el patrón de filtro:
label.class.pattern.syntax.explanation=Deje el método en blanco para mostrar el constructor\nCualquier * coincidirá con uno o más caracteres en el nombre completo (incluido el punto)
label.compact.constructor=constructor de compresión
label.contract=Contrato:
label.enter.fully.qualified.class.name=Ingrese el nombre de la clase completamente calificado
label.entry.points=Puntos de entrada:
label.forbid.api.usages=Prohibir usos de API:
label.forbid.api.usages.project=(프로젝트 설정에 따라)
label.from.inclusive=Desde (inclusive):
label.ignore.complicated.fix=빠른 수정이 없는 경우 무시
label.implementation=Implementación:
label.implements.method.of_class_or_interface.name=implementa {0} {1} ''{2}''.
label.implements.method.of_interfaces=implementa métodos de las siguientes clases/interfaces:
label.jvm.class.name=JVM 클래스 이름
label.jvm.field.name=JVM 필드 이름
label.jvm.method.name=JVM 메서드 이름
label.maximal.reported.method.visibility=Visibilidad máxima del método informado:
label.method=Método ''{0}''
label.minimal.reported.method.usage.count=Recuento mínimo de uso del método informado:
label.mutates=Muta:
label.name.prefix=Prefijo de nombre:
label.name.suffix=Sufijo del nombre:
label.naming.field=Campo:
label.naming.local.variable=Variable local:
label.naming.parameter=Parámetro:
label.naming.static.field=Campo estático:
label.naming.subclass=Subclase:
label.naming.test.class=Clase de prueba:
label.new.template.name=Nuevo nombre de plantilla\:
label.overrides.method.of_class_or_interface.name=anula {0} {1} ''{2}''.
label.show.import.popup.for=Mostrar ventana emergente de importación para:
label.to.inclusive=Para (inclusive):
label.unused.declaration.reachable.from.tests.option=Cuando los puntos de entrada están en fuentes de prueba, marque los destinatarios como:
lambda.tree.node.presentation=Lambda
leave.in.same.source.root.item=Dejar en la misma raíz de origen
library.classes.cannot.be.inlined=Las clases de la biblioteca no se pueden insertar
line.marker.recursive.call=Llamada recursiva
line.marker.type.external.annotations=Anotaciones externas
line.marker.type.inferred.contract.annotations=Anotaciones de contrato inferidas
line.marker.type.inferred.nullability.annotations=Anotaciones de nulabilidad inferidas
link.configure.classes.excluded.from.completion=코드 완성에서 제외된 클래스 구성
list.item.configuration=[configuración] {0}
list.item.suite=[herramientas] {0}
listbox.import.package=Paquete
listbox.import.static=Estático
listbox.import.with.subpackages=Con subpaquetes
live.template.context.consumer.function=Función de consumidor
live.template.context.declaration=Declaración
live.template.context.else='else' 위치
live.template.context.expression=Expresión
live.template.context.statement=Declaración
loading.additional.annotations=추가 어노테이션 로드 중...
macro.array.variable=arrayVariable()
macro.class.name=Nombre de clase
macro.classpath.entry=Entrada en la ruta de clase a la que pertenece el elemento
macro.component.type.of.array=componentTypeOf(Array)
macro.descendant.classes.enum=descendantClassesEnum(String)
macro.expression.type=expressionType(Expresión)
macro.file.fully.qualified.package=Archivo paquete completo
macro.file.package=Paquete de archivos
macro.guess.element.type.of.container=guessElementType(contenedor)
macro.iterable.component.type=iterableComponentType(ArrayOrIterable)
macro.iterable.variable=iterableVariable()
macro.javadoc.output.directory=directorio de salida de JavaDoc
macro.project.classpath=Ruta de clases del proyecto
macro.variable.of.type=variableOfType(Tipo)
megabytes.unit=메가바이트
methods.to.implement.chooser.title=Seleccionar métodos para implementar
methods.to.override.chooser.title=Seleccionar métodos para anular
methods.to.override.generate.javadoc=빠진 JavaDoc 생성
methods.to.override.implement.chooser.title=Seleccionar métodos para anular/implementar
module.not.in.requirements=El módulo ''{0}'' no tiene el módulo ''{1}'' en los requisitos
module.package.not.exported=El módulo ''{0}'' no exporta el paquete ''{1}'' al módulo ''{2}''
module.package.not.open=El módulo ''{0}'' no abre el paquete ''{1}'' al módulo ''{2}''
module.type.java.description=Los módulos Java se utilizan para desarrollar aplicaciones web y de escritorio <b>basadas en JVM</b>, incluidas aplicaciones que utilizan <b>Java EE</b>y otros marcos de desarrollo empresarial.
module.type.java.name=Módulo Java
move.class.import.from.default.package.conflict=디폴트 패키지에서 {0}에 액세스할 수 없습니다
move.classes.destination.class.not.found.message=No se encontró la clase de destino
move.classes.invalid.destination.package.name.message=''{0}'' es un nombre de paquete de destino no válido
move.inner.select.target.package.title=Seleccionar paquete de destino
move.member.enum.conflict=No se puede aplicar la enumeración en el contexto actual
move.member.final.initializer.conflict=los inicializadores mutables finales no se pueden usar después del movimiento.
multiple.usages.of.static.import.found=Múltiples usos de la importación estática encontrados
navigate.to.duplicate.fix=Navegar para duplicar
no.jre.description=<Sin JRE>
no.methods.overriding.0.are.found=No se encuentran métodos que invaliden {0,choice,0#|1#''{1}''|2#estas clases}
no.patterns=No se han configurado patrones de clase
node.call.hierarchy.unknown.jsp=jsp desconocido
node.hierarchy.java.lang.object=Todas las clases se derivan de java.lang.Object
non.code.annotations.explanation.external.and.inferred.available=외부 및 <i>추론된</i> 어노테이션을 사용할 수 있습니다.
non.code.annotations.explanation.external.available=외부 어노테이션을 사용할 수 있습니다.
non.code.annotations.explanation.full.signature=전체 시그니처:
non.code.annotations.explanation.inferred.available=<i>추론된</i> 어노테이션을 사용할 수 있습니다.
notification.content.added.annotations={0}개 {0, choice, 1#어노테이션|2#어노테이션}이 추가되었습니다
notification.content.change.jdk=JDK 변경
notification.content.was.set.up=JDK ''{0}''이(가) 프로젝트에 설정되었습니다
notification.group.jdk.resolve.problems=JDK 해결 실패
notification.group.jshell=JShell 문제 발생
notification.group.language.level=Java 미리보기 언어 수준을 사용하려면 라이선스에 동의해야 합니다
notification.group.legacy.library=기존 라이브러리가 IDE 설치본에 의존합니다
notification.group.preview.features=Java 미리보기 언어 수준은 종료될 수 있습니다
notification.group.redundant.exports=불필요한 내보내기/열기는 제거될 수 있습니다
notification.group.repository=JAR 파일이 저장소와 동기화됨
notification.group.setup.external.annotations=외부 어노테이션을 로드할 수 없음
notification.group.setup.sdk=JDK 구성됨
notification.group.source.searcher=JAR 파일의 소스를 찾을 수 없음
notification.group.testintegration=@TestDataPath의 테스트를 생성하지 못했습니다
notification.navigation.to.overriding.classes=La navegación a clases anuladas no es posible durante la actualización del índice
notification.navigation.to.overriding.methods=La navegación a los métodos de anulación no es posible durante la actualización del índice
notification.text.full.thread.dump.was.successfully.copied.to.clipboard=El volcado de hilo completo se copió con éxito al portapapeles
null.check.surrounder.description=if (expr \! \=null) {...}
nullable.notnull.annotation.used.label=코드 생성에 사용된 어노테이션:
nullable.notnull.annotations.panel.title={0} anotaciones
nullable.notnull.annotations.runtime.instrumentation.tooltip=Agregar aserciones de tiempo de ejecución para métodos y parámetros sin anotaciones nulas
nullable.notnull.configuration.dialog.title=Configuración Nullable/NotNull
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.name=Navegar a usos de argumentos 'nulos'
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.preview='null'이 인수로 전달된 사용 위치의 목록을 표시합니다.
nullable.stuff.inspection.navigate.null.argument.usages.view.name=Usos de argumentos '' nulos '' para el parámetro {0}
offline.inspections.jdk.not.found={0} no encontrado
offline.inspections.library.urls.were.not.resolved=Las raíces {0} de la biblioteca ''{1}'' del módulo ''{2}'' no se resolvieron
offline.inspections.library.was.not.resolved=Configure la biblioteca ''{0}'' que se utiliza en el módulo ''{1}''
offline.inspections.no.source.roots=No se detectaron raíces de origen para el módulo ''{0}''
open.settings.dialog.for.module.preview.text=모듈 ''{0}''의 설정 대화상자 열기
options.java.attribute.descriptor.abstract.class=Clases e interfaces//Clase abstracta
options.java.attribute.descriptor.abstract.method=Métodos//Método abstracto
options.java.attribute.descriptor.annotation.attribute.name=Anotaciones//Nombre del atributo de anotación
options.java.attribute.descriptor.annotation.name=Annotations//Nombre de la anotación
options.java.attribute.descriptor.anonymous.class=Clases e interfaces//Clase anónima
options.java.attribute.descriptor.class=Clases e interfaces//Clase
options.java.attribute.descriptor.constructor.call=Métodos//Llamada al constructor
options.java.attribute.descriptor.constructor.declaration=Métodos//Declaración del constructor
options.java.attribute.descriptor.enum=Clases e interfaces//Enum
options.java.attribute.descriptor.implicit.anonymous.parameter=Parámetros//Parámetro de clase anónimo implícito
options.java.attribute.descriptor.inherited.method=Métodos//Método heredado
options.java.attribute.descriptor.instance.field=Campos de clase//Campo de instancia
options.java.attribute.descriptor.instance.final.field=Campos de clase//Campo final de la instancia
options.java.attribute.descriptor.interface=Clases e interfaces//Interfaz
options.java.attribute.descriptor.javadoc.comment=Comentarios//JavaDoc//Texto
options.java.attribute.descriptor.javadoc.markup=Comentarios//JavaDoc//Marcado
options.java.attribute.descriptor.javadoc.tag=Comentarios//JavaDoc//Etiqueta
options.java.attribute.descriptor.javadoc.tag.value=Comentarios//JavaDoc//Valor de etiqueta
options.java.attribute.descriptor.lambda.parameter=Parámetros//Parámetro Lambda
options.java.attribute.descriptor.method.call=Métodos//Llamada al método
options.java.attribute.descriptor.method.declaration=Métodos//Declaración del método
options.java.attribute.descriptor.method.imported.call=Métodos//Llamada estática al método importado
options.java.attribute.descriptor.package.private=가시성//Package-private
options.java.attribute.descriptor.private=가시성//Private
options.java.attribute.descriptor.protected=가시성//Protected
options.java.attribute.descriptor.public=가시성//Public
options.java.attribute.descriptor.reassigned.local.variable=Variables//Variable local reasignada
options.java.attribute.descriptor.reassigned.parameter=Parámetros//Parámetro reasignado
options.java.attribute.descriptor.static.field=Class Fields//Campo estático
options.java.attribute.descriptor.static.final.field=Campos de clase//Constante (campo final estático)
options.java.attribute.descriptor.static.final.imported.field=Campos de clase//Constante (campo importado final estático)
options.java.attribute.descriptor.static.imported.field=Campos de clase//Campo importado estático
options.java.attribute.descriptor.static.method=Métodos//Método estático
options.java.attribute.descriptor.type.parameter=Parámetros//Tipo de parámetro
options.java.display.name=Java
override.implement.broken.file.template.message=Corrija la plantilla "Cuerpo del método anulado/implementado"
override.implement.broken.file.template.title=Error de plantilla de archivo
override.methods.error.no.methods=No se encontró ningún método para anular
package.chooser.modal.progress.title=패키지 검색 중...
package.classes=패키지 절:
package.dependencies.production.node.text=Clases de producción
package.dependencies.test.node.text=Clases de prueba
package.pattern.provider.hint.label=프로젝트 내의 모든 'txt' 파일에 적용하려면 <b>*.txt</b>를 사용하고, 재귀적으로 디렉터리 내의 모든 파일에 적용하려면 <b>file:path_in_project//*</b>를, 재귀적으로 패키지 내의 모든 클래스에 적용하려면 <b>src:foo..*</b>를 사용하세요.
packaging.jlink.artifact.name=JLink
packaging.jlink.artifact.title=런타임 이미지(JLink)
packaging.jlink.compression.first.level=문자열 공유
packaging.jlink.compression.level=압축 수준
packaging.jlink.compression.second.level=Zip
packaging.jlink.compression.zero.level=압축하지 않음
packaging.jlink.verbose.tracing=상세 추적 활성화
paste.class.command.name=Pegar clase ''{0}''
please.report.a.bug=Informe un error
popup.content.tests.were.not.found.in.module=모듈 ''{0}''에서 테스트를 찾지 못했습니다.
popup.content.tests.were.not.found.in.module.search.in.dependencies=대신 모듈 종속성 전체를 검색하세요
popup.content.tests.were.not.found.in.module.use.instead=No se encontraron pruebas en el módulo ''{0}''.\nEn lugar de {1, choice, 0\#module {2} | No use\none de1\# {3}\n}
popup.title.choose.framework=Elegir marco
popup.title.choose.test=Elija Prueba
popup.title.debug.recent.tests=Depurar pruebas recientes
popup.title.effective.visibility=올바른 가시성
popup.title.select.a.jar.file=Seleccionar un archivo JAR
popup.title.select.qualified.name=Seleccionar nombre calificado
popup.title.select.target.code.block=타깃 코드 블록 선택
postfix.template.condition.array.name=Matriz
postfix.template.condition.boolean.name=Boolean
postfix.template.condition.non.void.name=non-void
postfix.template.condition.not.primitive.type.name=No es un tipo primitivo
postfix.template.condition.number.name=Número
postfix.template.condition.void.name=void
postfix.template.editor.choose.class.title=Elige clase
postfix.template.language.level.title=Nivel mínimo de lenguaje:
postfix.template.provider.name=Java
presentable.text.anonymous.class=Clase anónima
presentable.text.code.display=Código
presentable.text.code.from.context=Código de {0}
presentable.text.invalid.element.name=no es válido
press.0.to.see.inheritors.of.1=Presione {0} para ver los herederos de {1}
press.0.to.see.non.imported.classes=Presione {0} para ver las clases no importadas
pressing.0.twice.without.a.class.qualifier=Presionar {0} dos veces sin un calificador de clase mostraría todos los métodos estáticos accesibles
progress.creating.class=Creando clase {0}
progress.title.calculate.applicable.types=적용 가능한 타입 계산...
progress.title.check.applicability=Verificar aplicabilidad...
progress.title.checking.if.class.exists=타깃 클래스 ''{0}''이(가) 있는지 확인
progress.title.collect.method.overriders=메서드 재정의자 수집...
progress.title.detect.overridden.methods=재정의 메서드 확인
progress.title.detecting.jdk=JDK 탐지 중
progress.title.download.library.descriptor=Descargar descriptor de biblioteca
progress.title.find.references.in.implement.extends.lists=Buscar referencias en listas de implementación/extensión...
progress.title.finding.cause=Encontrar una causa
progress.title.looking.for.jdk=JDK 검색 중...
progress.title.looking.for.libraries=Buscando bibliotecas
progress.title.optimize.imports=Optimizar importaciones...
progress.title.preprocess.usages=Usos de preproceso
progress.title.restore.references=참조 복원 중
progress.title.search.for.overriding.methods=Buscar métodos de reemplazo...
progress.title.searching.for.sub.classes=Buscando subclases
project.problems.fix.description=Problemas encontrados relacionados con ''{0}''
project.problems.fix.text=Mostrar problemas relacionados
project.problems.hint.text={0} relacionado {0,choice,0#problema|2#problemas}
project.problems.title=Problemas relacionados
project.problems.window.title=Problemas relacionados con {0}
prompt.choose.base.class.of.the.hierarchy=Elija la clase base de la jerarquía para buscar en
prompt.create.non.existing.package=El paquete {0} no existe. \n¿Desea crearlo?
prompt.delete.class={0,choice,1#clase|2#clases}
prompt.delete.field={0,choice,1#campo|2#campos}
prompt.delete.interface={0,choice,1#interface|2#interfaces}
prompt.delete.method={0,choice,1#método|2#métodos}
prompt.delete.package={0,choice,1#paquete|2#paquetes}
prompt.delete.type.parameter={0,choice,1#parámetro de tipo|2#parámetros de tipo}
prompt.do.you.want.to.action_verb.the.method.from_class=¿Quiere {0} la base {1,choice,1#método|2#métodos} en su lugar?
psi.error.incorrect.class.template.message=No se puede crear {0} - plantilla {1} incorrecta.
psi.search.overriding.progress=Buscando métodos de reemplazo...
pull.members.up.fix.name=Mover miembro hacia arriba
pull.up.accessible.conflict=No se pudo acceder a {0}
pull.up.accessible.conflict.1={0} no es accesible desde {1}
pull.up.concrete.inherit.abstract.method.conflict=Concrete ''{0}'' hereda un nuevo método abstracto
pull.up.members.usage.view.description.code.references.node=Clase para agregar miembros a "{0}"
pull.up.members.usage.view.description.processed.elements.node=Mover miembros de la clase {0} hacia arriba
push.down.anonymous.conflict=No se puede enviar la implementación a una clase anónima
push.down.missed.implementation.conflict=Falta la implementación {0} no abstracta de {1}
push.down.static.nonstatic.conflict=static {0} no se puede enviar a no estático {1}
push.down.super.method.call.changed.conflict=Una llamada a un método principal se resuelve en otro método
push.method.down.command.name=Mover método hacia abajo...
qualify.static.access.command.name=static calificar para el acceso
qualify.static.call.fix.text=static Calificación de llamada
qualify.static.constant.access=static qualify acceso constante
quickfix.add.variable.family.name=Inicializar variable
quickfix.add.variable.text=Inicializar variable ''{0}''
quickfix.family.avoid.mutation.using.stream.api=Evite la mutación usando Stream API
quickfix.family.change.javadoc.to=Cambiar a...
quickfix.family.find.cause=Encontrar la causa
quickfix.family.remove.javadoc.tag=Eliminar etiqueta
quickfix.family.remove.redundant.parameter=Eliminar parámetro redundante
quickfix.family.remove.redundant.parameter.types=Eliminar tipos de parámetros redundantes
quickfix.family.replace.cast.type=Reemplazar el tipo de conversión
quickfix.family.replace.inefficient.stream.count=Reemplazar Stream.count() ineficiente
quickfix.family.replace.optional.chain.with.if.statements=Reemplazar cadena opcional con declaraciones if
quickfix.family.replace.stream.api.chain.with.loop=Reemplazar la cadena de la API de transmisión con un bucle
quickfix.family.replace.with.java.stream.api.pipeline=Reemplazar con la tubería de API de Java Stream
quickfix.family.replace.with.magic.constant=Reemplazar con constante mágica
quickfix.family.replace.with.method.reference=Reemplazar con la referencia del método
quickfix.family.replace.with.optional.of.nullable.chain=Reemplazar con Optional.ofNullable() cadena
quickfix.family.replace.with.stream.api.equivalent=Reemplazar con Stream API equivalente
quickfix.family.simplify.foreach.lambda=Simplificar para cada lambda
quickfix.family.simplify.stream.call.chain=Simplificar la cadena de llamadas de flujo
quickfix.family.use.flatmap=Usar 'flatMap'
quickfix.family.wrap.with.mutable.collection=Envolver con colección mutable
quickfix.find.cause.description=경고를 일으키는 코드 요소를 강조 표시하고 해당 코드가 어떤 역할을 하는지 설명합니다.
quickfix.name.find.jar.on.web=Buscar JAR en la web
quickfix.text.0.may.not.work.before.jdk.11.0.2={0} (puede que no funcione antes de JDK 11.0.2)
quickfix.text.avoid.mutation.using.stream.api.0.operation=Evite la mutación usando la operación Stream API ''{0}''
quickfix.text.remove.javadoc.0=''@{0}'' 태그 제거
quickfix.text.remove.javadoc.0.1=Eliminar @ {0} {1}
quickfix.text.remove.not.null.annotation=Eliminar anotación no nula
quickfix.text.replace.0.stream.with.1.2=Reemplaza {0} .stream() con {1}. {2}()
quickfix.text.replace.collect.0.with.1.2=Reemplazar '' collect ({0}()) '' por ''{1}'' {2}
quickfix.text.replace.filter.0.is.present.with.any.match=Reemplazar '' filter(). {0}(). isPresent() '' por '' anyMatch() ''
quickfix.text.replace.stream.0.with.1.2=Reemplazar '' stream(). {0}() '' con '' {1}() '' {2}
quickfix.text.replace.url.with.html=URL을 HTML 링크로 바꾸기
quickfix.text.suffix.may.change.semantics=\ (puede cambiar la semántica)
quickfix.text.wrap.0.with.1=Ajustar ''{0}'' con ''{1}''
radio.button.subclass.of.0=Subclase de ''{0}''
radio.button.unused.declaration.unused.option=unused
radio.button.unused.declaration.used.option=used
radio.button.with.provider.method=Con el método 'provider()'
radio.use.fully.qualified.class.names.in.javadoc=Use nombres de clase completamente calificados en JavaDoc:
radio.use.fully.qualified.class.names.in.javadoc.always=Siempre
radio.use.fully.qualified.class.names.in.javadoc.if.not.imported=Si aún no se ha importado
radio.use.fully.qualified.class.names.in.javadoc.never=Nunca, use un nombre corto y agregue import
raw.use.of.parameterized.type.ignore.new.objects.option=새 객체 생성 무시
raw.use.of.parameterized.type.ignore.overridden.parameter.option=재정의 메서드의 매개변수 타입 무시
raw.use.of.parameterized.type.ignore.quickfix.not.available.option=자동 빠른 수정을 사용할 수 없는 경우 무시
raw.use.of.parameterized.type.ignore.type.casts.option=형 변환 무시
raw.use.of.parameterized.type.ignore.uncompilable.option=타입 매개변수가 컴파일되지 않는 위치 무시
raw.variable.type.can.be.generic.cast.quickfix=형 변환 타입을 {0}(으)로 변경
raw.variable.type.can.be.generic.cast.quickfix.family=형 변환 타입 매개변수화
raw.variable.type.can.be.generic.family.quickfix=타입에 제네릭 매개변수 추가
raw.variable.type.can.be.generic.quickfix={0} 타입을 {1}(으)로 변경
refactoring.method.reference.to.lambda.conflict=La referencia del método se convierte a lambda
remove.var.keyword.text='var' 제거
rename.package.class.already.exist.conflict=La clase con el nombre completo ''{0}'' ya existe
rename.package.command.name=Cambiar el nombre del paquete
rename.package.ignored.name.warning=Está intentando crear un paquete con un nombre ignorado. Esto no mostrará ningún resultado.
rename.package.invalid.name.error=Nombre de paquete no válido
rename.super.base.chooser.popup.title={0} anula el método de {2} {1, choice, 0\# deployment |1\# override}
rename.super.methods.chooser.popup.title={0} tiene un método principal
replace.implements.with.static.import.field.usages.progress=Encuentra usos de campos constantes...
scheduled.thread.pool.executor.with.zero.core.threads.description='ScheduledThreadPoolExecutor'의 코어 스레드가 0이어서는 안 됩니다
scheduled.thread.pool.executor.with.zero.core.threads.display.name=코어 스레드가 0인 'ScheduledThreadPoolExecutor'
scope.hierarchy=Jerarquía de {0}
sdk.cannot.create=No se puede crear el SDK
sdk.configured.sdkmanrc=''{0}''은(는) 프로젝트 JDK로 설정되어 있습니다.
sdk.configured.sdkmanrc.title=JDK가 구성되었습니다(.sdkmanrc)
sdk.java.no.classes=No se pueden encontrar las clases JDK en ''{0}''
section.title.inspection.suspicious.names.ignore.methods=Ignorar métodos
separator.annotations.to.copy=Anotaciones para copiar
separator.mark.as.entry.point.if.annotated.by=Marcar como punto de entrada si se anota con
separator.mark.field.as.implicitly.written.if.annotated.by=Marcar el campo como escrito explícitamente cuando se anota con
set.language.level=Establecer nivel de lenguaje
set.language.level.to.0=Establecer el nivel de lenguaje en {0}
settings.completion.ml.java.display.name=Java
settings.inlay.java.annotations=Anotaciones
settings.inlay.java.builder.like.methods=Métodos tipo constructor
settings.inlay.java.complex.expressions.binary.functional.array.access.and.other=Expresiones complejas: binarias, funcionales, acceso a matrices y otras
settings.inlay.java.enum.constants=Constantes de enumeración
settings.inlay.java.external.annotations=Anotaciones externas
settings.inlay.java.implicit.types=Tipos implícitos
settings.inlay.java.implicit.types.description=추론 타입이 대입의 오른쪽에서 명확하지 않을 때(예: factory  메서드 사용 시) var 키워드를 사용하여 로컬 변수가 선언되었습니다.
settings.inlay.java.inferred.annotations=Anotaciones inferidas
settings.inlay.java.inheritors=Herederos
settings.inlay.java.insert.annotation=Insertar anotación
settings.inlay.java.methods.with.same.named.numbered.parameters=Métodos con parámetros numerados del mismo nombre
settings.inlay.java.new.expressions=Expresiones 'Nuevas'
settings.inlay.java.non.literals.in.case.of.multiple.parameters.with.the.same.type=No literales en el caso de varios parámetros con el mismo tipo
settings.inlay.java.parameters.with.names.that.are.contained.in.the.method.name=Parámetros con nombres que están contenidos en el nombre del método
settings.inlay.java.show.hints.for=Mostrar sugerencias para:
settings.inlay.java.show.parameter.hints.for=Mostrar sugerencias de parámetros para:
settings.inlay.java.show.parameter.hints.when.expression.type.is.clear.description=Array inicializador, conmutador, condicional, referencia, instancia de, asignación, llamada, calificado, conversión de tipos, expresiones de acceso a objetos de clase.
settings.inlay.java.turn.off.external.annotations=Desactivar anotaciones externas
settings.inlay.java.turn.off.inferred.annotations=Desactivar las anotaciones inferidas
settings.inlay.java.usages=Usos
show.import.popup.for.classes=&Clases
show.import.popup.for.static.methods.and.fields=Método&s y campos estáticos
show.siblings.choose.super.class.title=Seleccione la clase o interfaz principal
show.siblings.find.usages.class.title=clase principal/interfaz
show.siblings.find.usages.method.title=método principal
side.effects.expression.presentation=Expresión ''{0}''
side.effects.expressions.assigned.to.the.variable=expresión asignada a la variable ''{0}''
side.effects.non.fixable.message=<html><body> Posibles efectos secundarios encontrados en la expresión ''{0}'' <br> Resolución\: <b> Eliminar la referencia de clase con todas las expresiones asociadas</ b></cuerpo></html>
side.effects.pattern.message=<html>\n<body>\nPosibles efectos secundarios encontrados en {0} <br>\nSolution\:\n<br>\n - \\&nbsp;todo relacionado Dónde usar las variables con expresiones <b> Eliminar</b> o <br>\n - \\&nbsp;Convertir expresiones asignadas a variables en sintaxis de forma independiente <b> Convertir</b><br>\n<div style \="padding- izquierda\: 0.6cm; ">\n es decir, <br>\n<borde de la tabla \ =" 0 ">\n<tr>\n<td><code> {1};</ code></td>\n</tr>\n</table>\n Resultados\: <br>\n<borde de la tabla \="0">\n<tr>\n<td><código> {2};</ código></td>\n</tr>\n</table>\n</div>\n</body>\n</html>
simplify.optional.chain.inspection.fix.description.optional.chain.can.be.eliminated=Optional 체인을 제거할 수 있습니다
simplify.optional.chain.inspection.fix.description.replace.with.value.of.description=Optional 체인은 'String.valueOf()'로 바꿀 수 있습니다
simplify.optional.chain.inspection.fix.description.replace.with.value.of.name='String.valueOf()'로 바꾸기
simplify.optional.chain.inspection.fix.name.remove.redundant.optional.chain=불필요한 Optional 체인 제거
simplify.optional.chain.inspection.map.or.else.description=opcional Puede simplificar la cadena
simplify.optional.chain.inspection.optional.rewrapping.description=Volver a envolver innecesario opcional
simplify.optional.chain.inspection.optional.rewrapping.name=Unwrapped
simplify.optional.chain.inspection.or.else.non.null.fix.description=la comprobación nula se puede eliminar con '' ifPresent ''
simplify.optional.chain.inspection.or.else.non.null.fix.name=reemplace el cheque nulo con ifPresent ()
simplify.optional.chain.inspection.or.else.return.fix.description=la comprobación nula se puede eliminar
simplify.optional.chain.inspection.or.else.return.fix.name=reemplace el cheque nulo con {0} ({1})
simplify.optional.chain.inspection.remove.redundant.steps.from.optional.chain=Eliminar pasos redundantes de la cadena opcional
simplify.optional.chain.inspection.to.x=opcional Simplifique la cadena a ''{0}''
simplify.stream.collection.creation.fix.name=reemplazar con el constructor ''{0}''
simplify.stream.inspection.iterate.take.while.fix.message=3 argumentos se pueden reemplazar con ''iterate()''
simplify.stream.inspection.iterate.take.while.fix.name=reemplazar con 3 argumentos ''iterate()''
simplify.stream.inspection.message.can.be.replaced='{0}'' se puede reemplazar con ''{1}'
simplify.stream.inspection.message.can.be.replaced.may.change.semantics=''{0}'' se puede reemplazar con ''{1}'' (el significado puede cambiar si existe)
simplify.stream.match.negation.fix.name=reemplazar {0} con {1} (...)
simplify.stream.remove.boolean.identity.fix.message=Puede fusionarse con la llamada anterior ''map''
simplify.stream.remove.boolean.identity.fix.name=Fusionar con la llamada anterior ''map''
simplify.stream.replace.support.with.collection.fix.message=Se puede reemplazar llamando a ''{0}.{1}''
simplify.stream.replace.support.with.collection.fix.name=reemplazar con ''{0}.{1}'' llamada
simplify.stream.replace.with.element.iteration.fix.message=Se puede reemplazar con la repetición del elemento
simplify.stream.simple.stream.of.fix.name.use.stream.element.explicitly=Usar el elemento Stream explícitamente
simplify.stream.simple.stream.of.message=Flujo de elemento único innecesario
simplify.stream.swap.filter.and.map.fix.message=''filter()'' y ''map()'' son intercambiables
simplify.stream.swap.filter.and.map.fix.name='filter()'' reemplaza ''map()'
slice.filter.parse.error.enum.constant.not.found=Constante de enumeración no encontrada: {0}
slice.filter.parse.error.expression.must.evaluate.to.constant=La expresión debe evaluarse a una constante: {0}
slice.filter.parse.error.incorrect.constant.expected.number=Constante incorrecta (número esperado): {0}
slice.filter.parse.error.incorrect.constant.type=Tipo de constante incorrecto (obligatorio: {0})
slice.filter.parse.error.incorrect.expression=Expresión incorrecta: {0}
slice.filter.parse.error.not.null.filter.not.applicable.for.primitive.type=''! null '' filter no es aplicable para el tipo primitivo {0}
slice.filter.parse.error.null.filter.not.applicable.for.primitive.type=el filtro '' null '' no es aplicable para el tipo primitivo {0}
slice.usage.message.assertion.violated=(¡aserción violada!)
slice.usage.message.in.file.stopped.here=(en el archivo {0} - parado aquí)
slice.usage.message.location=en {0}
slice.usage.message.tracking.container.contents=(Seguimiento del contenido del contenedor ''{0} {1}'')
sort.threads.by.name=Ordenar hilos por nombre
sort.threads.by.type=Ordenar hilos por tipo
special.annotations.annotations.list=Anotaciones especiales adicionales
special.annotations.annotations.preview=''@{0}''을(를) 이 검사에서 무시될 어노테이션 목록에 추가합니다
special.annotations.list.add.annotation.class=Agregar clase de anotación
special.annotations.list.annotation.class=Clase de anotación
special.annotations.list.annotation.pattern=Agregar patrón de anotación
special.annotations.list.annotation.pattern.message=Agregar patrón de anotación
special.annotations.list.remove.pattern=Eliminar
spi.extension.error.message=La extensión registrada debe implementar {0}
spi.no.provider.error.message=No se encontró el proveedor de servicios "{0}"
status.bar.overridden.methods.highlighted.message={0} overridden {0,choice,1#method|2#methods} encontrado (presione {1} nuevamente para eliminar el resaltado, Escape para eliminar todo el resaltado)
stream.to.loop.inspection.message.replace.foreach.call.with.loop=Reemplazar llamada '' forEach '' con bucle
stream.to.loop.inspection.message.replace.stream.api.chain.with.loop=Reemplaza la cadena de API de flujo con un bucle
surround.with.cast=형 변환으로 둘러싸기
surround.with.dowhile.template=do/while
surround.with.for.template=for
surround.with.ifelse.expression.template=if (expr) {...} else {...}
surround.with.not.instanceof.template=!(expr instancia de tipo)
surround.with.runnable.template=Ejecutable
surround.with.synchronized.template=sincronizado
surround.with.try.catch.finally.template=probar/atrapar/finalmente
surround.with.try.catch.incorrect.template.message=¡Plantilla de archivo no válida para el cuerpo de captura!
surround.with.try.catch.incorrect.template.title=Envolvente con Try/Catch
surround.with.try.catch.template=try/catch
switch.stmt.template.description=switch (expr) {...}
tab.title.entry.points=Puntos de entrada
tab.title.infer.nullity.preview=vista previa de la inferencia de nulidad
tab.title.members.to.report=Miembros para informar
tab.title.slices.grouped.by.nullness=\ (agrupado por nulidad)
table.cell.constructors=constructores
target.code.block.presentable.text=포함하는 블록
title.cannot.create.class=No se puede crear una clase
title.code.vision=Code Vision
title.code.vision.inlay.hints=Code Vision
title.import.layout=Importar diseño
title.javadoc=JavaDoc
title.naming=Nombre
title.naming.final.modifier=Modificador final
title.naming.functional.expressions=Cuerpo Lambda
title.naming.variable=변수
title.package.not.found=Paquete no encontrado
title.packages=Paquetes
title.packages.to.use.import.with=Paquetes para usar Importar con '*'
title.related.problems.inlay.hints=관련 문제
to.import.a.method.statically.press.0=Para importar un método de forma estática, presione {0}
todo.index.not.available=No aplicable
tooltip.anonymous=익명
tooltip.has.several.functional.implementations=여러 함수 구현 포함
tooltip.implements.method=메서드를 구현합니다
tooltip.implements.method.in=다음에서 메서드 구현:
tooltip.is.functionally.implemented.in=다음에서 함수적으로 구현:
tooltip.is.implemented.by=다음에 의해 구현됨
tooltip.is.implemented.by.several.subclasses=여러 하위 클래스에 의해 구현됨
tooltip.is.implemented.in=다음에서 구현됨
tooltip.is.implemented.in.several.subclasses=여러 하위 클래스에서 구현됨
tooltip.is.overridden.by.several.subclasses=여러 하위 클래스에 의해 재정의됨
tooltip.is.overridden.in=다음에서 재정의됨
tooltip.is.overridden.in.several.subclasses=여러 하위 클래스에서 재정의됨
tooltip.is.subclassed.by=다음의 하위 클래스가 됨
tooltip.overrides.method=메서드를 재정의
tooltip.overrides.method.in=다음에서 메서드 재정의:
tooltip.reassigned.local.variable=재대입된 지역 변수
tooltip.reassigned.parameter=재대입된 매개변수
tooltip.recursive.call=Llamada recursiva
tooltip.via.subclass=하위 클래스를 통해
type.information.constraints=Restricciones
type.information.local.object=Objeto local
type.information.locality=Localidad
type.information.mutability=mutabilidad
type.information.not.equal.to=No es igual a
type.information.nullability=nulabilidad
type.information.range=rango
type.information.type=Tipo
type.information.value=Valor
type.migration.cannot.convert.message=표현식 <b>{0}</b>의 타입을{3, choice, 0#|1# '<'b'>'{1}'<'/b'>'에서} <b>{2}</b>(으)로 변환할 수 없습니다<br>
type.migration.cannot.convert.tooltip=No se puede convertir el tipo de expresión de {0} a {1}
type.migration.cannot.convert.vararg.message=호출 <b>{0}</b>을(를) vararg에서 비 vararg로 변환할 수 없습니다
type.migration.cannot.convert.vararg.tooltip=호출을 vararg에서 비 vararg로 변환할 수 없습니다
type.migration.command.name=TypeMigration
type.migration.dialog.message.disjunction.type.not.applicable=catch 블록 매개변수만 공용체 타입으로 마이그레이션될 수 있습니다
type.migration.dialog.message.invalid.type=''{0}'' es un tipo no válido
type.migration.dialog.message.vararg.type.not.applicable=메서드의 마지막 매개변수만 vararg 타입으로 마이그레이션될 수 있습니다
type.migration.dialog.message.void.not.applicable='' void '' no es aplicable
type.migration.getter.rename.suggestion.always.migrate.method.names=Migrar siempre los nombres de los métodos
type.migration.getter.rename.suggestion.never.migrate.method.names=No migrar nombres de métodos
type.migration.getter.rename.suggestion.text=Cambiar el nombre del getter de ''{0}'' a ''{1}'' después de migrar el tipo de retorno a ''{2}'' ¿Migrar a?
type.migration.multi.root.toolwindow.title=Tipo de migración de {0}
type.migration.processed.elements.header=Raíz del tipo de migración
type.migration.replaced.notification=Reemplazar con {0}
type.migration.single.root.toolwindow.title=Migrar tipo de {0} de ''{1}'' a ''{2}''
type.parameters.cannot.be.inlined=Los parámetros de tipo no se pueden insertar
unchecked.warning.inspection.message.unchecked.generics.array.creation.for.varargs.parameter=Crear una matriz genérica sin marcar para el parámetro vararg
unchecked.warning.inspection.reason.expr.has.raw.type.so.result.erased=. 이유: ''{0}''에 원시 타입이 있으므로 {1}의 결과가 지워집니다
unchecked.warning.inspection.settings.ignore.unchecked.assignment=Ignorar asignaciones sin marcar
unchecked.warning.inspection.settings.ignore.unchecked.call.as.member.of.raw.type=Ignora las llamadas sin marcar como miembros de tipos primitivos
unchecked.warning.inspection.settings.ignore.unchecked.cast=Ignorar los lanzamientos sin marcar
unchecked.warning.inspection.settings.ignore.unchecked.generics.array.creation.for.vararg.parameter=ignorar la creación de una matriz genérica sin marcar para el parámetro vararg
unchecked.warning.inspection.settings.ignore.unchecked.overriding=Ignorar anulaciones no marcadas
unresolved.class.reference.repair.message=클래스 참조 해결 시도
unscramble.detect.analyze.threaddump.from.clipboard.item=Detecta y analiza automáticamente los volcados de subprocesos copiados al portapapeles fuera de IntelliJ IDEA
unscramble.log.path.label=&Archivo de registro:
unscramble.no.unscrambler.item=<No hay un descifrador instalado>
unscramble.normalize.button=&Normalizar
unscramble.stacktrace.caption=Ponga un seguimiento de pila o un volcado de hilo completo aquí:
unscramble.unscrambled.deadlock.tab=<Deadlock>
unscramble.unscrambled.stacktrace.tab=<Stacktrace>
unscramble.unscrambled.threaddump.tab=<Hilos>
unscramble.unscrambler.combobox=Un &codificador:
unscramble.use.unscrambler.checkbox=&Descodificar seguimiento de pila
unwrap.anonymous=Desenvolver 'anónimo...'
unwrap.array.initializer=Desenvolver inicializador de matriz
unwrap.conditional=Desenvolver 'f? a: b'
unwrap.lambda=Desenvolver 'lambda...'
unwrap.switch.expression=Expresión de ruptura '' cambiar ''
unwrap.switch.statement='switch' 문 줄 바꿈 해제
unwrap.synchronized=Desenvolver 'sincronizado...'
update.external.annotations=Actualizar anotaciones externas
usage.target.exception=Excepción
usage.target.package.in.directory={0} (en {1})
usages.telescope={0,choice, 0#0개의 사용위치|1#1개 사용 위치|2#{0,number}개 사용 위치}
use.external.annotations=Usar &anotaciones externas
validator.text.class.not.found=클래스를 찾을 수 없습니다
validator.text.no.annotation=어노테이션이어야 합니다
validator.text.not.valid.class.name=유효한 클래스 이름이 아닙니다
validator.text.wrong.superclass=잘못된 상위 클래스
vm.option.description.category=카테고리:
vm.option.description.default.value=디폴트 값:
vm.option.description.description=설명:
vm.option.description.diagnostic=진단
vm.option.description.experimental=실험적
vm.option.description.option=옵션:
vm.option.description.product=제품
vm.option.description.requires=\ ({0} 필요)
vm.option.description.standard=표준
vm.option.description.type=타입:
warning.java.file.outside.source.root=Java 파일이 모듈 소스 루트 밖에 있으므로 컴파일링되지 않습니다
where.do.you.want.to.move.directory.prompt={0}\n\n디렉터리를 다른 소스 루트 또는 다른 디렉터리로 이동하시겠어요?
wrap.return.value.anonymous.class.presentation=Anónimo {0}
wrap.return.value.created.class.not.accessible.conflict=La clase creada no es accesible desde la ubicación de la llamada
wrap.return.value.existing.class.does.not.have.appropriate.constructor.conflict=기존 클래스에 적절한 생성자가 없습니다
wrap.return.value.existing.class.does.not.have.getter.conflict=La clase existente no tiene getter para el campo seleccionado
wrapping.annotation.parameters=Parámetros de anotación
wrapping.deconstruction.patterns=구조 분해 패턴
wrapping.multi.catch.types=여러 catch의 타입
wrapping.record.components=Componentes del registro
wrapping.text.blocks=Bloques de texto
wrong.package.statement=Declaración de paquete incorrecta
