assertequals.between.inconvertible.types.display.name=변환할 수 없는 타입의 객체 간의 'assertequals()'
can.t.build.uast.tree.for.file=No se pudo construir el árbol UAST para el archivo.
current.version=Versión actual
dialog.title.choose.annotation=Seleccione {0}
inspection.message.illegal.dependency.module.doesn.t.export=유효하지 않은 종속 요소: 모듈 ''{0}''은(는) 패키지 ''{1}''을(를) 내보내지 않습니다
jvm.inspection.logging.condition.disagrees.with.log.statement.display.name=로그 조건이 로깅 호출과 일치하지 않음
jvm.inspection.logging.condition.disagrees.with.log.statement.problem.descriptor=조건 ''{0}''의 레벨이 로그 호출 ''{1}''의 레벨과 일치하지 않습니다
jvm.inspection.logging.placeholder.count.matches.argument.count.display.name=자리표시자 수가 로깅 호출의 인수 수와 일치하지 않음
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.descriptor=지정된 자리표시자 수({1})보다 인수의 수({0})가 적습니다 #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.partial.descriptor=지정된 자리표시자 수(최소 {1}개)보다 제공된 인수의 수({0}개)가 적습니다 #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.incorrect.problem.descriptor=잘못된 서식 문자열 지정자 #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.more.problem.descriptor=지정된 자리표시자 수({1})보다 인수의 수({0})가 많습니다 #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option=SLF4J가 Log4j 2를 구현으로 사용합니다
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.auto=자동 확인
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.no=아니요
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.yes=예
jvm.inspection.logging.string.template.as.argument.all.levels.option=모든 로그 수준
jvm.inspection.logging.string.template.as.argument.debug.level.and.lower.option=디버그 수준 이하
jvm.inspection.logging.string.template.as.argument.display.name=문자열 템플릿을 로깅 호출에 인수로 전달
jvm.inspection.logging.string.template.as.argument.info.level.and.lower.option=정보 수준 이하
jvm.inspection.logging.string.template.as.argument.problem.descriptor=<code>#ref()</code> 로깅 호출에 문자열 템플릿을 인수로 전달 #loc
jvm.inspection.logging.string.template.as.argument.quickfix.name=자리표시자로 대체
jvm.inspection.logging.string.template.as.argument.skip.on.primitives=원시 타입, 래퍼 또는 문자열이 있는 표현식만 포함되었을 때 경고 안 함
jvm.inspection.logging.string.template.as.argument.trace.level.option=추적 수준
jvm.inspection.logging.string.template.as.argument.warn.level.and.lower.option=경고 수준 이하
jvm.inspection.logging.string.template.as.argument.warn.on.label=다음에 대해 경고:
jvm.inspection.test.failed.line.display.name=테스트에서 실패한 줄
jvm.inspections.1.5.problem.descriptor=@since {0}+로 기록된 API 사용
jvm.inspections.1.7.problem.descriptor=JDK {0}에 컴파일 문제를 일으킬 수 있는 1.6 이후에 일반화된 API 사용
jvm.inspections.1.8.problem.descriptor=디폴트 {0, choice, 0#|1#메서드가|2#메서드가} 재정의되지 않았습니다. JDK {1}에 컴파일 문제를 일으킬 수 있습니다.
jvm.inspections.1.8.problem.single.descriptor=디폴트 메서드 ''{0}''이(가) 재정의되지 않았습니다. 이로 인해 JDK {1}에 컴파일 문제가 발생할 수 있습니다
jvm.inspections.api.display.name=구성된 언어 수준에서 사용할 수 없는 API 사용
jvm.inspections.api.no.extension.class.description=La clase ''{0}'' no debe extenderse.
jvm.inspections.api.no.extension.display.name=La clase, la interfaz o el método no deben extenderse
jvm.inspections.api.no.extension.interface.extend.description=La interfaz ''{0}'' no debe extenderse.
jvm.inspections.api.no.extension.interface.implement.description=La interfaz ''{0}'' no debe implementarse.
jvm.inspections.api.no.extension.method.overriding.description=El método ''{0}'' no debe anularse.
jvm.inspections.api.override.only.description=El método ''{0}'' solo se puede anular.
jvm.inspections.api.override.only.display.name=Los métodos solo se pueden anular
jvm.inspections.assertequals.between.inconvertible.types.problem.descriptor=<code>#ref()</code>이(가) 변환할 수 없는 타입인 ''{0}'' 및 ''{1}''의 객체 사이에 있습니다. #loc
jvm.inspections.assertnotequals.between.inconvertible.types.problem.descriptor=어설션이 불필요할 수 있습니다. 호환되지 않는 타입, ''{0}'' 및 ''{1}''이(가) 비교됩니다
jvm.inspections.assertnotsame.between.inconvertible.types.problem.descriptor=어설션이 불필요합니다. 호환되지 않는 타입, ''{0}'' 및 ''{1}''이(가) 비교됩니다
jvm.inspections.blocking.method.annotation.blocking=Bloqueo de anotaciones
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=Agregar anotación de bloqueo
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=Non-Blocking 어노테이션 추가
jvm.inspections.blocking.method.annotation.non-blocking=비 블로킹 어노테이션:
jvm.inspections.blocking.method.consider.suspend.context.non.blocking=Kotlin 일시 중지 컨텍스트를 블로킹이 아닌 것으로 간주
jvm.inspections.blocking.method.consider.unknown.context.blocking=알 수 없는 컨텍스트를 블로킹으로 고려
jvm.inspections.blocking.method.consider.unknown.context.nonblocking=알 수 없는 컨텍스트를 비 블로킹으로 간주
jvm.inspections.blocking.method.display.name=Llamada al método de bloqueo de subprocesos no válida
jvm.inspections.blocking.method.in.implicit.ctr.problem.descriptor=블로킹이 아닌 컨텍스트에서 묵시적 생성자로부터의 블로킹 호출은 잠재적으로 스레드 기아 상태를 일으킬 수 있습니다
jvm.inspections.blocking.method.in.implicit.ctr.problem.wildcard.descriptor={0}에서 묵시적 생성자로부터의 블로킹 호출은 잠재적으로 스레드 기아 상태를 일으킬 수 있습니다
jvm.inspections.blocking.method.intention.text=검사 옵션 ''{0}''을(를) 활성화합니다.
jvm.inspections.blocking.method.problem.descriptor=Llamada al método de bloqueo no válida.
jvm.inspections.blocking.method.problem.wildcard.descriptor={0}에서 호출을 블로킹하면 스레드에서 기아 상태를 일으킬 수 있습니다
jvm.inspections.collection.contains.url.problem.descriptor=''{0}''에 URL 객체가 있습니다 #loc
jvm.inspections.dependency.display.name=잘못된 패키지 종속성
jvm.inspections.dependency.edit.rules.family=종속성 규칙 편집
jvm.inspections.dependency.edit.rules.text=종속성 규칙 "{0}" 편집
jvm.inspections.dependency.intention.description=스코프 간 종속성 규칙을 구성하는 대화상자를 엽니다.
jvm.inspections.dependency.on.internal.display.name=내부 패키지에 유효하지 않은 종속 요소
jvm.inspections.dependency.violator.problem.descriptor=종속성 규칙 ''{0}.''이(가) 위반되었습니다
jvm.inspections.equals.hashcode.called.on.url.display.name='URL' 객체에서 'equals()' 또는 'hashCode()' 호출
jvm.inspections.equals.hashcode.called.on.url.problem.descriptor=URL 객체에서 ''{0}''이(가) 호출되었습니다
jvm.inspections.group.name=Lenguaje JVM
jvm.inspections.junit.assertequals.may.be.assertsame.display.name='assertEquals()'가 'assertSame()'이 될 수 있음
jvm.inspections.junit.assertequals.may.be.assertsame.problem.descriptor=<code>#ref</code>이(가) 'assertSame()'이 될 수 있습니다 #loc
jvm.inspections.junit.assertequals.on.array.display.name=배열에서 'assertEquals()' 호출
jvm.inspections.junit.assertequals.on.array.problem.descriptor=<code>#ref()</code>이(가) 배열에서 호출됩니다 #loc
jvm.inspections.junit.ignored.test.class.problem.descriptor=테스트 클래스 ''{0}''이(가){1, choice, 1#|2# 이유 없이} 무시/비활성화되었습니다 #loc
jvm.inspections.junit.ignored.test.display.name=JUnit 테스트에 '@Ignore'/'@Disabled' 어노테이션 추가
jvm.inspections.junit.ignored.test.ignore.reason.option=이유 없이 사용된 어노테이션만 보고
jvm.inspections.junit.ignored.test.method.problem.descriptor=테스트 메서드 ''{0}()''이(가){1, choice, 1#|2# 이유 없이} 무시/비활성화되었습니다 #loc
jvm.inspections.junit.malformed.annotated.double.descriptor=''@{1}'' 어노테이션이 추가된 {0, choice, 0#필드|1#메서드} <code>#ref</code>은(는) {2} 및 {3}이어야 합니다
jvm.inspections.junit.malformed.annotated.double.typed.descriptor=''@{1}'' 어노테이션이 추가된 {0, choice, 0#필드|1#메서드} <code>#ref</code>은(는) {2} 및 {3}이고 ''{4}'' 타입이어야 합니다
jvm.inspections.junit.malformed.annotated.method.double.param.double.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) {1} 및 {2}이어야 하며 매개변수 ''{3}'' 및 ''{4}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.method.double.param.single.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) {1} 및 {2}이어야 하며 매개변수 ''{3}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.method.double.typed.param.double.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) {1} 및 {2}이고 ''{3}'' 타입이어야 하며 매개변수 {4} 및 ''{5}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.method.double.typed.param.single.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) {1} 및 {2}이고 ''{3}'' 타입이어야 하며 매개변수 ''{4}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.method.param.double.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) 매개변수 {1} 및 ''{2}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.method.param.single.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) 매개변수 ''{1}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.method.single.param.double.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) {1}이어야 하며 매개변수 ''{2}'' 및 ''{3}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.method.single.param.single.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) {1}이어야 하며 매개변수 ''{2}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.method.single.typed.param.double.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) {1}이고 ''{2}'' 타입이어야 하며 매개변수 {3} 및 ''{4}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.method.single.typed.param.single.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) {1}이고 ''{2}'' 타입이어야 하며 매개변수 ''{3}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.method.typed.param.double.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) ''{1}'' 타입이어야 하며 매개변수 {2} 및 ''{3}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.method.typed.param.single.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) ''{1}'' 타입이어야 하며 매개변수 ''{2}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.single.descriptor=''@{1}'' 어노테이션이 추가된 {0, choice, 0#필드|1#메서드} <code>#ref</code>은(는) {2}이어야 합니다
jvm.inspections.junit.malformed.annotated.single.typed.descriptor=''@{1}'' 어노테이션이 추가된 {0, choice, 0#필드|1#메서드} <code>#ref</code>은(는) {2}이고 ''{3}'' 타입이어야 합니다
jvm.inspections.junit.malformed.annotated.suspend.function.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) 일시 중지하는 함수가 아니어야 합니다
jvm.inspections.junit.malformed.annotated.typed.descriptor=''@{1}'' 어노테이션이 추가된 {0, choice, 0#필드|1#메서드} <code>#ref</code>은(는) ''{2}'' 타입이어야 합니다
jvm.inspections.junit.malformed.declaration.name=JUnit 잘못된 형식의 선언
jvm.inspections.junit.malformed.extension.class.level.descriptor={0}은(는) 클래스 수준에서 등록되어야 합니다
jvm.inspections.junit.malformed.fix.class.signature=클래스 시그니처 수정
jvm.inspections.junit.malformed.fix.class.signature.descriptor=''{0}'' 클래스 시그니처 수정
jvm.inspections.junit.malformed.fix.class.signature.multi=클래스 시그니처 수정
jvm.inspections.junit.malformed.fix.field.signature=필드 시그니처 수정
jvm.inspections.junit.malformed.fix.field.signature.descriptor=''{0}'' 필드 시그니처 수정
jvm.inspections.junit.malformed.fix.method.signature=메서드 시그니처 수정
jvm.inspections.junit.malformed.fix.method.signature.descriptor=''{0}'' 메서드 시그니처 수정
jvm.inspections.junit.malformed.missing.nested.annotation.descriptor=중첩 클래스 내의 테스트는 실행되지 않습니다
jvm.inspections.junit.malformed.no.arg.descriptor=메서드 <code>#ref</code>은(는) {0}, {1}이고 {2, choice, 0#매개변수가 없어야|1#, 매개변수가 없고 void 타입이어야} 합니다
jvm.inspections.junit.malformed.option.ignore.test.parameter.if.annotated.by=다음 어노테이션이 추가된 경우 테스트 매개변수 무시:
jvm.inspections.junit.malformed.param.duplicated.enum.descriptor='enum' 상수 이름 중복
jvm.inspections.junit.malformed.param.empty.source.unsupported.descriptor=메서드에 지원되지 않는 ''{1}'' 타입의 매개변수가 있으므로 ''@{0}''은(는) 메서드에 인수를 제공할 수 없습니다
jvm.inspections.junit.malformed.param.exactly.one.type.of.input.must.be.provided.descriptor=입력 타입은 정확히 하나만 제공되어야 합니다
jvm.inspections.junit.malformed.param.file.source.descriptor=파일 소스를 해결할 수 없습니다. ''{0}''
jvm.inspections.junit.malformed.param.method.source.assignable.descriptor=''{0}''을(를) ''{1}''(으)로 변환하는 묵시적 변환을 찾지 못했습니다
jvm.inspections.junit.malformed.param.method.source.no.params.descriptor=메서드 소스 ''{0}''에는 매개변수가 포함될 수 없습니다
jvm.inspections.junit.malformed.param.method.source.return.type.descriptor=메서드 소스 ''{0}''에는 다음 반환 타입 중 하나가 포함되어야 합니다. ''Stream<?>'', ''Iterator<?>'', ''Iterable<?>'' 또는 ''Object[]''
jvm.inspections.junit.malformed.param.method.source.static.descriptor=메서드 소스 ''{0}''은(는) static이어야 합니다
jvm.inspections.junit.malformed.param.method.source.unresolved.descriptor=타깃 메서드 소스를 확인할 수 없습니다. ''{0}''
jvm.inspections.junit.malformed.param.multiple.parameters.descriptor=이 소스는 여러 매개변수를 지원하지 않습니다
jvm.inspections.junit.malformed.param.no.sources.are.provided.descriptor=제공된 소스가 없어 스위트가 공백으로 남습니다
jvm.inspections.junit.malformed.param.no.value.source.is.defined.descriptor=정의된 값 소스가 없습니다
jvm.inspections.junit.malformed.param.unresolved.enum.descriptor='enum' 상수 참조를 해결할 수 없습니다.
jvm.inspections.junit.malformed.param.wrapped.in.arguments.descriptor=여러 매개변수는 'Arguments'로 감싸야 합니다
jvm.inspections.junit.malformed.repetition.number.descriptor=반복 횟수는 0보다 커야 합니다
jvm.inspections.junit.malformed.source.without.params.descriptor=\n메서드에 매개변수가 없으므로 ''@{0}''은(는) 메서드에 인수를 제공할 수 없습니다
jvm.inspections.junit.malformed.suspend.function.descriptor=메서드 <code>#ref</code>은(는) 일시 중지하는 함수가 아니어야 합니다
jvm.inspections.junit.malformed.test.combination.descriptor={0}와 ''@{1}''의 의심스러운 조합
jvm.inspections.junit.mixed.annotations.junit.descriptor=클래스 내에서 ''@{0}'' 어노테이션이 추가된 메서드 <code>#ref()</code>이(가) JUnit {1} TestCase를 확장합니다 #loc
jvm.inspections.junit.mixed.annotations.name=하나의 TestCase 내에 여러 버전의 JUnit API 사용
jvm.inspections.junit3.super.teardown.display.name=JUnit 3 'super.tearDown()'이 'finally' 블록에서 호출되지 않음
jvm.inspections.junit3.super.teardown.problem.descriptor=<code>#ref()</code>이(가) 'finally' 블록에서 호출되지 않습니다 #loc
jvm.inspections.junit4.converter.display.name=JUnit 3 테스트가 JUnit 4가 될 수 있음
jvm.inspections.junit4.converter.problem.descriptor=<code>#ref</code>을(를) JUnit4 테스트 케이스로 변환할 수 있습니다
jvm.inspections.junit4.converter.quickfix.conflict.call.compile={1}이(가) JUnit 4로 변환될 경우 메서드 호출 {0}이(가) 컴파일링하지 않습니다
jvm.inspections.junit4.converter.quickfix.conflict.name=메서드 {0}은(는) 상위 메서드와 이름이 충돌됩니다
jvm.inspections.junit4.converter.quickfix.conflict.semantics={1}이(가) JUnit 4로 변환될 경우 메서드 호출 {0}이(가) 의미를 변경할 수 있습니다
jvm.inspections.junit4.converter.quickfix.conflict.suite={0}의 suite 메서드 마이그레이션에 삭제될 부수 효과가 있습니다
jvm.inspections.junit4.converter.quickfix.name=JUnit4 테스트 케이스로 변환
jvm.inspections.junit5.converter.display.name=JUnit 4 테스트가 JUnit 5가 될 수 있음
jvm.inspections.junit5.converter.problem.descriptor=#ref이(가) JUnit 5 테스트일 수 있습니다
jvm.inspections.junit5.converter.quickfix=JUnit 5로 마이그레이션
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=호환되지 않는 상속자가 있으므로 클래스 {0}을(를) JUnit 5로 변환할 수 없습니다. {1}
jvm.inspections.junit5.converter.quickfix.presentation.text=어설션 변환
jvm.inspections.logging.frameworks.group.name=로깅
jvm.inspections.migrate.assert.to.matcher.description=어설션 표현식 <code>#ref</code>을(를) ''{0}'' 호출로 바꿀 수 있습니다 #loc
jvm.inspections.migrate.assert.to.matcher.option=매처 메서드를 정적으로 가져오기
jvm.inspections.migrate.assertion.name=JUnit 어설션은 'assertThat()' 호출이 될 수 있음
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=Las API que se eliminarán también deben estar marcadas con la anotación '' @Deprecated ''.
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=Falta la anotación '' @Deprecated '' en la API que se eliminará
jvm.inspections.must.already.be.removed.api.current.version.description=La API se ha eliminado de la versión actual {0}.
jvm.inspections.must.already.be.removed.api.display.name=La API ya ha sido eliminada.
jvm.inspections.must.already.be.removed.api.earlier.version.description=La API se ha eliminado de {0} pero la versión actual es {1}.
jvm.inspections.remove.annotation.quickfix.name=어노테이션 제거
jvm.inspections.remove.annotation.quickfix.text=''@{0}'' 어노테이션 제거
jvm.inspections.rename.quickfix.name=요소 이름 변경
jvm.inspections.rename.quickfix.text=''{0}''(으)로 이름 변경
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' está programado para ser eliminado de {3} ''{2}'' ha sido declarado en
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' está a punto de eliminarse de {1}.
jvm.inspections.scheduled.for.removal.future.version=Versiones futuras
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=El método reemplazado ''{0}'' programado para ser eliminado de {3} {1} ''{2}'' fue declarado.
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=El método anulado ''{0}'' está a punto de ser eliminado de {1}.
jvm.inspections.scheduled.for.removal.predefined.version=versión {0}
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' se eliminará de {3} {1 } ''{2}'' se hace referencia en su firma y se eliminará
jvm.inspections.serializable.class.without.serialversionuid.display.name='serialVersionUID'가 없는 serializable 클래스
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code>이(가) 'serialVersionUID' 필드를 정의하지 않습니다 #loc
jvm.inspections.source.to.sink.flow.assigned.unknown=알 수 없는 문자열이 안전한 변수에 대입됨
jvm.inspections.source.to.sink.flow.assigned.unsafe=안전하지 않은 문자열이 안전한 변수에 대입됨
jvm.inspections.source.to.sink.flow.common.unknown=알 수 없는 문자열이 안전한 컨텍스트에 사용됨
jvm.inspections.source.to.sink.flow.common.unsafe=안전하지 않은 문자열이 안전한 컨텍스트에 사용됨
jvm.inspections.source.to.sink.flow.display.name=안전하지 않은 문자열이 안전한 메서드로 전달됨
jvm.inspections.source.to.sink.flow.passed.unknown=알 수 없는 문자열이 안전한 매개변수로 사용됨
jvm.inspections.source.to.sink.flow.passed.unsafe=안전하지 않은 문자열이 안전한 매개변수로 사용됨
jvm.inspections.source.to.sink.flow.returned.unknown=알 수 없는 문자열이 안전한 메서드에서 반환됨
jvm.inspections.source.to.sink.flow.returned.unsafe=안전하지 않은 문자열이 안전한 메서드에서 반환됨
jvm.inspections.source.to.sink.flow.too.complex=너무 복잡해서 안전한 컨텍스트에서 문자열이 안전한지 확인할 수 없습니다
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods=private 메서드의 매개변수를 안전한 것으로 간주
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods.comment=활성화 시 private 메서드의 매개변수는 안전한 것으로 간주되며 그렇지 않은 경우는 알 수 없는 것으로 간주됩니다
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex=케이스가 확인하기에 너무 복잡한 경우 보고
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex.comment=복잡성으로 인해 확인할 수 없는 문자열을 보고해야 하는 경우 활성화하세요
jvm.inspections.source.unsafe.to.sink.flow.config=요소 ''{0}''에 대한 검사 설정에 Untainted 어노테이션이 추가됩니다
jvm.inspections.source.unsafe.to.sink.flow.impossible=Untainted 어노테이션은 요소 ''{0}''에 대해 지원되지 않습니다. 해당 요소는 무시됩니다
jvm.inspections.source.unsafe.to.sink.flow.index.parameter=매개변수 색인
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=검증 필요로 표시
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=검증 필요로 표시
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=요소를 검증 필요로 표시
jvm.inspections.source.unsafe.to.sink.flow.not.number=숫자가 아닙니다
jvm.inspections.source.unsafe.to.sink.flow.preview='@Untainted' 어노테이션 추가
jvm.inspections.source.unsafe.to.sink.flow.preview.propagate=전달 트리 표시
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=전달 트리
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.preview=안전한 어노테이션의 전달을 확인하기 위한 도구 창을 엽니다
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=여기에 전달 트리 표시
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=제외된 것만 빼고 모두 어노테이션 추가
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=안전하지 않은 멤버
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=안전하지 않은 흐름
jvm.inspections.source.unsafe.to.sink.flow.safe.class=안전한 클래스:
jvm.inspections.source.unsafe.to.sink.flow.safe.class.comment=클래스에 안전하지 않은 데이터가 없습니다
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations=Tainted 어노테이션:
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations.comment=이러한 어노테이션은 분석 중에는 '@Tainted' 어노테이션으로 사용됩니다
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods=Tainted 메서드:
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods.comment=이러한 메서드는 안전하지 않은 객체만 반환하는 것으로 간주됩니다
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters=Tainted 매개변수:
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters.comment=이러한 매개변수는 '@Tainted' 어노테이션이 있는 것으로 간주됩니다
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations=Untainted 어노테이션:
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations.comment=이러한 어노테이션은 분석 중에는 '@Tainted' 어노테이션으로 사용됩니다. 경로 상에 존재하면 목록의 첫 번째 어노테이션이 전달에 사용됩니다.
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields=Untainted 필드:
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.comment=이러한 필드는 안전한 객체만 포함하는 것으로 간주됩니다
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.name=필드 이름
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods=Untainted 메서드:
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods.comment=이러한 메서드는 안전한 객체만 반환하는 것으로 간주됩니다
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters=Untainted 매개변수:
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters.comment=이러한 매개변수는 '@Untainted' 어노테이션이 있는 것으로 간주됩니다
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments=리시버와 인수가 untainted인 경우 외부 메서드를 untainted인 것으로 간주
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments.comment=활성화된 경우 현재 클래스 밖의 외부 클래스는 리시버와 인수가 안전하면 안전한 것으로 간주됩니다. 일부 적용되지 않는 경우가 있으나 스테이트리스 클래스에는 유용할 수 있습니다. 그렇지 않으면 모든 외부 메서드가 안전하지 않은 것으로 간주됩니다
jvm.inspections.string.touppercase.tolowercase.without.locale.description=<code> String. Se llama a {0} ()</code> sin especificar una configuración regional que utilice una cadena internacionalizada.\#loc
jvm.inspections.test.case.in.product.source.display.name=제품 소스 내 테스트
jvm.inspections.test.case.in.product.source.problem.descriptor=테스트 케이스 <code>#ref</code>은(는) 테스트 소스 트리에 배치해야 할 수 있습니다 #loc
jvm.inspections.test.case.with.constructor.display.name=사소하지 않은 생성자가 있는 TestCase
jvm.inspections.test.case.with.constructor.problem.descriptor=수명 주기 메서드 'setup()'이 아닌 생성자 <code>#ref()</code>의 초기화 논리 #loc
jvm.inspections.test.case.with.constructor.problem.descriptor.initializer=생명주기 메서드 'setup()'이 아닌 이니셜라이저의 초기화 논리
jvm.inspections.test.frameworks.group.name=테스트 프레임워크
jvm.inspections.test.method.in.product.source.problem.descriptor=테스트 메서드 <code>#ref()</code>은(는) 테스트 소스 트리에 배치해야 할 수 있습니다 #loc
jvm.inspections.test.method.without.assertion.display.name=어설션이 없는 테스트 메서드
jvm.inspections.test.method.without.assertion.problem.descriptor=테스트 메서드 <code>#ref()</code>에 어설션이 없습니다 #loc
jvm.inspections.testonly.class.reference=테스트 전용 클래스가 프로덕션 코드에서 참조됩니다
jvm.inspections.testonly.display.name=프로덕션 코드 내 테스트 전용 사용 위치
jvm.inspections.testonly.field.reference=테스트 전용 필드가 프로덕션 코드에서 참조됩니다
jvm.inspections.testonly.method.call=테스트 전용 메서드가 프로덕션 코드에서 호출됩니다
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting은 @TestOnly 코드에서 의미가 없습니다
jvm.inspections.thread.run.display.name='Thread.run()' 호출
jvm.inspections.unstable.api.usage.annotations.list=Anotaciones API inestables
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}''이(가) @{3}(으)로 표시된 불안정한 {1} ''{2}''에서 선언되었습니다.
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' está marcado como inestable en @ {1}.
jvm.inspections.unstable.api.usage.display.name=Usando API inestable
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=이 프로젝트에서 선언된 API 무시
jvm.inspections.unstable.api.usage.ignore.inside.imports=ignorar dentro de la declaración de importación
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=Método anulado ''{0}'' marcado como inestable {1 como @ {3}} Declarado en '' {2 } ''.
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=El método anulado ''{0}'' está marcado como inestable en @ {1}.
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' marcado como @ {3} inestable {1} ''{2}'' se hace referencia por su firma y, por lo tanto, es inestable
jvm.inspections.unstable.type.used.in.class.signature.description=Anotado ''@{0} '' porque la clase hace referencia al tipo inestable ''{1}'' en su declaración, debería ser
jvm.inspections.unstable.type.used.in.field.signature.description=El campo está anotado con ''@{0} '' porque hace referencia al tipo inestable ''{1}'' debería ser
jvm.inspections.unstable.type.used.in.method.signature.description=Anotado ''@{0} '' porque el método hace referencia al tipo inestable ''{1}'' en su firma debe ser
jvm.inspections.unstable.type.used.in.signature.display.name=Tipo inestable utilizado en la firma
jvm.inspections.usages.of.obsolete.api.description=지원 중단된 API가 사용됩니다
jvm.inspections.usages.of.obsolete.api.display.name=ApiStatus.@Obsolete의 사용 위치
propagated.from=전달 이유:
propagated.to=전달할 대상:
title.uast=UAST
