cannot.perform.the.refactoring=리팩토링을 수행할 수 없습니다.
extract.class.title=위임자를 추출합니다
extract.class.from.label={0}에서 위임자 추출
name.for.new.class.label=새 클래스 이름(&N)\:
choose.destination.package.label=대상 패키지 선택
package.for.new.class.label=패키지 이름(&P)\:
members.to.extract.label=추출할 멤버(&B)
there.already.exists.a.class.with.the.chosen.name=선택한 이름의 클래스가 이미 존재합니다.
introduce.parameter.object=매개변수 오브젝트 소개
the.caret.should.be.positioned.within.a.class.to.be.refactored=캐럿이 리팩토링할 클래스 내부에 위치해야 합니다.
the.selected.class.is.an.enumeration=선택한 클래스는 열거형입니다.
remove.middleman=Middleman 제거
the.caret.should.be.positioned.at.the.name.of.the.field.to.be.refactored=캐럿이 리팩토링할 필드 이름에 위치해야 합니다.
field.selected.is.not.used.as.a.delegate=선택한 필드는 위임자로 사용되지 않습니다.
wrap.return.value=반환값 줄 바꿈
the.caret.should.be.positioned.at.the.name.of.the.method.to.be.refactored=캐럿은 리팩토링할 메소드의 이름, 매개변수 목록 내부 또는 메소드 호출 내부에 위치해야 합니다.
method.selected.returns.void=선택한 메소드는 'void'를 반환합니다.
constructor.returns.can.not.be.wrapped=생성자 반환은 래핑될 수 없습니다.
wrap.return.value.title=반환값 줄 바꿈
method.to.wrap.returns.from.label=반환을 줄 바꿈할 메소드\:
method.whose.return.are.to.wrapped=내부 반환을 줄 바꿈할 메소드
references.to.be.modified.usage.view=수정할 참조 {1, choice, 0\#|1\#{1}개 파일에서|2\#{1}개 파일에서} {0, choice, 0\# (찾을 수 없음)|1\#{0}개 참조|2\#{0}개 참조}
reference=참조
remove.middleman.field.header=middleman 필드 제거\:
references.to.expose.usage.view=노출할 참조 {1, choice, 0\#|1\#{1}개 파일에서|2\#{1}개 파일에서} {0, choice, 0\# (찾을 수 없음)|1\#{0}개 참조|2\#{0}개 참조}
remove.middleman.title=Middleman 제거
refactor=리팩토링
preview=미리보기
wrapped.return.command.name=\ {1}()에 대해 {0}(으)로 래핑된 반환
exposed.delegation.command.name={0}에 노출된 위임
annotation=어노테이션
the.selected.class.is.an.interface=선택한 클래스는 인터페이스입니다.
the.selected.class.is.an.annotation.type=선택한 클래스는 어노테이션 유형입니다.
the.refactoring.is.not.supported.on.non.static.inner.classes=리팩토링은 비 'static' 내부 클래스에서 지원되지 않습니다.
the.selected.class.has.no.members.to.extract=선택한 클래스에는 추출할 멤버가 없습니다.
the.selected.class.should.belong.to.project.sources=선택한 클래스는 프로젝트 소스에 속해 있어야 합니다
references.to.extract=추출할 참조 {1, choice, 0\#|1\#{1}개 파일에서|2\#{1}개 파일에서} {0, choice, 0\# (찾을 수 없음)|1\#{0}개 참조|2\#{0}개 참조})
extract.class.as.enum.column.title=열거형으로
extract.class.depends.on.0.from.1.tooltip={1}의 {0}에 종속
extract.class.depends.on.0.from.new.class=새 클래스 {1}의 {0}에 종속
extracting.from.class=클래스에서 추출\:
extracted.class.command.name=추출된 클래스 {0}
extracted.class.not.accessible.in.0=추출된 클래스는 {0}에서 액세스할 수 없습니다
method.selected.has.no.parameters=선택한 메소드에는 매개변수가 없습니다.
parameter=매개변수
the.selected.method.cannot.be.wrapped.because.it.is.defined.in.a.non.project.class=비 project 클래스에서 선언되므로 선택한 메소드는 래핑될 수 없습니다.
select.wrapper.class=매개변수 클래스 선택
could.not.find.selected.wrapping.class=선택한 래핑 클래스를 찾을 수 없습니다.
there.already.exists.a.class.with.the.selected.name=선택한 이름의 클래스가 이미 존재합니다.
dialog.message.invalid.inner.class.name=''{0}''은(는) 잘못된 내부 클래스 이름입니다
dialog.message.inner.class.with.name.already.exist=이름이 ''{0}''인 내부 클래스가 이미 있습니다
dialog.message.invalid.qualified.wrapper.class.name=''{0}''은(는) 잘못된 정규화된 래퍼 클래스 이름입니다
dialog.message.invalid.wrapper.class.name=''{0}''은(는) 잘못된 래퍼 클래스 이름입니다
dialog.message.wrapper.field.not.found=래퍼 필드를 찾을 수 없습니다
dialog.message.invalid.wrapper.class.package.name=''{0}''은(는) 잘못된 래퍼 클래스 패키지 이름입니다
popup.title.effective.visibility=유효한 가시성
field.needs.getter=필드 ''{0}''에는 getter가 필요합니다
field.needs.setter=필드 ''{0}''에는 setter가 필요합니다
initializer.requires.moved.members=클래스 이니셜라이저에는 이동된 멤버가 필요합니다
constructor.requires.moved.members=생성자에는 이동된 멤버가 필요합니다
case.value.can.not.be.replaced.with.enum={0}을(를) 열거형으로 대체할 수 없습니다
referenced.element.out.of.project={0}은(는) 프로젝트 외부에 있습니다
unable.to.migrate.statement.to.enum=구문을 열거형 상수로 마이그레이션할 수 없습니다. {0}
codestyle.settings.extractor.command.name=CodeStyleSettings 추출기

