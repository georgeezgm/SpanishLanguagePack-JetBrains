action.Swift.DumpSwiftFormatConfiguration.commandName=기본 SwiftFormat 구성 파일 생성
action.Swift.DumpSwiftFormatConfiguration.description=현재 파일의 디렉터리에 '.swift-format' 구성 파일을 생성합니다
action.Swift.DumpSwiftFormatConfiguration.synonym1=기본 '.swift-format' 구성 파일 생성
action.Swift.DumpSwiftFormatConfiguration.text=기본 SwiftFormat 구성 파일 생성
action.Swift.DumpSwiftFormatConfiguration.title=기본 '.swift-format' 구성 파일 생성 중
action.Swift.FormatFileWithSwiftFormat.commandName=SwiftFormat으로 코드 서식 재지정
action.Swift.FormatFileWithSwiftFormat.description=SwiftFormat으로 코드 서식 재지정
action.Swift.FormatFileWithSwiftFormat.synonym1=SwiftFormat으로 코드 서식 지정
action.Swift.FormatFileWithSwiftFormat.text=SwiftFormat으로 코드 서식 지정
action.Swift.FormatFileWithSwiftFormat.title=SwiftFormat으로 {0}의 서식 지정
action.Swift.Generate.DebugDescription.description=디버그 설명 생성
action.Swift.Generate.DebugDescription.text=debugDescription...
action.Swift.Generate.Description.description=설명 생성
action.Swift.Generate.Description.text=설명...
action.Swift.Generate.EqualsHashValue.description=equals 및 hash 생성
action.Swift.Generate.EqualsHashValue.text=equals 및 hash
action.Swift.Generate.Init.description=이니셜라이저 생성
action.Swift.Generate.Init.text=이니셜라이저
action.Swift.ShowSwiftIDETest.text=Swift IDE 보고서 실행
action.SwiftExtractFunction.text=함수 추출...
action.SwiftGenerateDocComment.text=문서 주석 생성
action.SwiftIntroduceClosureVariable.text=클로저...
action.SwiftToggleErrorHints.text=오류 힌트 표시
action.SwiftToggleGlobalErrorHints.text=Swift 오류 힌트 표시
action.SwiftToggleGlobalTypeHints.text=Swift 유형 힌트 표시
action.SwiftToggleTypeHints.text=유형 힌트 표시
auto.import.command.name=모듈 자동 가져오기
auto.import.completion.presentation.tail.from.0=({0})
auto.import.settings.checkbox.sort=가져오기 정렬
auto.import.settings.import.symbol=구체적인 기호를 자동으로 가져오기
auto.import.settings.import.symbol.help=심볼을 자동으로 가져올 때 심볼을 선언하는 전체 모듈을 가져오는 대신 심볼 자체의 임포트를 추가하는 것을 선호합니다
auto.import.settings.optimize.non.module=비 모듈 임포트 최적화
auto.import.settings.optimize.non.module.help=임포트를 최적화할 때 함수, 구조체, 클래스 및 다른 명시적인 임포트를 상위 모듈의 임포트로 대체합니다
call.hierarchy.usage.in=''{0}'' 내 사용 위치
change.info.async.throws.label=async/throws:
change.info.default.value.code.comment=Por defecto \={0}
change.info.default.value.label=Valor por defecto\:
change.info.dialog.invalid.function.name.0=유효하지 않은 함수 이름\: ''{0}''
change.info.dialog.invalid.parameter.internal.name.0=유효하지 않은 매개변수 내부 이름\: ''{0}''
change.info.dialog.invalid.parameter.name.0=유효하지 않은 매개변수 이름\: ''{0}''
change.info.dialog.no.function.name.specified=함수 이름이 지정되지 않았습니다
change.info.dialog.parameter.after.variadic.should.have.nonempty.name=가변 매개변수 다음에 오는 매개변수는 공백이 아닌 이름을 가져야 합니다
change.info.dialog.rethrows.should.have.throwing.parameter=''rethrows'' 함수는 던지는 함수 매개변수를 취해야 합니다
change.info.internal.name.label=내부 이름\:
change.info.name.label=이름\:
change.info.optional.label=선택적\:
change.info.options.label=옵션
change.info.return.type.label=반환 유형\:
change.info.type.label=유형\:
change.signature.0.1.will.no.longer.be.visible.from.overriding.0.in.2.3={0} ''{1}''이(가) {2} ''{3}''의 재정의 {0}에서 더 이상 표시되지 않습니다
change.signature.0.1.with.2.visibility.wont.be.accessible.from.3.4={2} 가시성을 가진 {0} ''{1}''은(는) {3} ''{4}''에서 액세스할 수 없습니다
change.signature.0.can.throw.but.thrown.errors.are.not.handled=''{0}'' 은(는) 던질 수 있으나 던져진 에러는 처리되지 않습니다
change.signature.0.is.async.but.not.awaited=''{0}''은(는) 호출을 대기하지만 async로 표시되지 않습니다
change.signature.dialog.title=시그니처 변경
change.signature.initializer.will.conflict.with.0.in.1.2=이니셜라이저는 {1} ''{2}'' 에서 {0} 와(과) 충돌합니다
change.signature.processed.elements.header=시그니처를 변경할 요소
change.signature.subscript.will.conflict.with.0.in.1.2=서브스크립트는 {1} ''{2}'' 에서 {0} 와(과) 충돌합니다
change.signature.target.not.found=캐럿은 함수, 이니셜라이저 또는 서브스크립트에 위치해야 합니다
change.signature.title=시그니처 변경
code.style.blank.lines.around.class=유형 선언 주위\:
code.style.blank.lines.around.field=Around 프로퍼티\:
code.style.blank.lines.around.field.in.protocol=프로토콜 내 프로퍼티 주위\:
code.style.blank.lines.around.method=메서드/함수 주위\:
code.style.blank.lines.around.method.in.protocol=프로토콜 내 메서드/함수 주위\:
code.style.blank.lines.before.method.body=메서드/함수 본문 앞\:
code.style.code.generation.doc.comment.style=줄(///) 문서 주석보다 블록(/** */) 주석을 선호
code.style.code.generation.doc.comment.tag.delimiter=목록 항목 구분자:
code.style.code.generation.prefer.explicit.return=명시적 반환 선호(&R)
code.style.code.generation.prefer.void=()보다 Void 선호(&V)
code.style.code.generation.tab.title=코드 생성
code.style.indent.directives.as.code=코드 들여쓰기 준수
code.style.indent.directives.children=하위 항목 들여쓰기
code.style.indent.group.title.directives=지시문
code.style.indent.method.chain=체인 메서드 들여쓰기:
code.style.indent.multiline.string.or.regex=여러 줄로 구성된 문자열이나 정규식을 들여쓰기
code.style.spaces.after.argument.colon=메서드/함수 호출 내 콜론 뒤
code.style.spaces.after.dictionary.literal.colon=사전 리터럴 ''key\:value'' 쌍 내 콜론 뒤
code.style.spaces.after.dictionary.type.colon=사전 유형 내 콜론 뒤
code.style.spaces.after.operator.in.function.declarations=함수 선언 내 연산자
code.style.spaces.after.semicolon=세미콜론 뒤
code.style.spaces.after.superclass.colon=유형 상속 절 내 콜론 뒤
code.style.spaces.after.type.colon=유형 어노테이션 내 콜론 뒤
code.style.spaces.around.range.operators=범위 연산자 (..., ..<)
code.style.spaces.attribute.parameters=속성 매개변수
code.style.spaces.attribute.parentheses=속성 소괄호
code.style.spaces.before.argument.colon=메서드/함수 호출 내 콜론 앞
code.style.spaces.before.class.lbrace=유형 선언이 왼쪽 중괄호
code.style.spaces.before.dictionary.literal.colon=사전 리터럴 ''key\:value'' 쌍 내 콜론 앞
code.style.spaces.before.dictionary.type.colon=사전 유형 내 콜론 앞
code.style.spaces.before.method.call.parentheses=메서드/함수 호출 소괄호
code.style.spaces.before.method.lbrace=메서드/함수 왼쪽 중괄호
code.style.spaces.before.method.parentheses=메서드/함수 선언 소괄호
code.style.spaces.before.semicolon=세미콜론 앞
code.style.spaces.before.superclass.colon=유형 상속 절 내 콜론 앞
code.style.spaces.before.type.colon=유형 어노테이션 내 콜론 앞
code.style.spaces.closure.arrow=클로저 화살표(->)
code.style.spaces.equality.operator=상등 연산자 ''\=\=''
code.style.spaces.group.title.colon=콜론 주위
code.style.spaces.group.title.in.ternary=삼항 조건 연산 내
code.style.spaces.shift.operators=시프트 연산자(<<, >>)
code.style.spaces.within.empty.method.call.parentheses=빈 메서드/함수 호출 소괄호
code.style.spaces.within.empty.method.parentheses=빈 메서드/함수 선언 소괄호
code.style.spaces.within.literal.brackets=배열 및 사전 리터럴 대괄호
code.style.spaces.within.method.call.parentheses=메서드/함수 호출 소괄호
code.style.spaces.within.method.parentheses=메서드/함수 선언 소괄호
code.style.spaces.within.string.interpolations=문자열 보간
code.style.wrapping.align.in.columns=열에 정렬
code.style.wrapping.align.when.multiline=여러 줄일 경우 정렬
code.style.wrapping.array.literal=배열 및 사전 리터럴
code.style.wrapping.array.new.line.after.left.bracket=''['' 뒤에 새 줄
code.style.wrapping.array.right.bracket.on.new.line=새 줄에 '']'' 배치
code.style.wrapping.brace.placement.class.declaration=유형 선언 내
code.style.wrapping.classes.annotation=유형 선언 속성
code.style.wrapping.closure.signature.on.next.line=여러 줄일 경우 매개변수를 새 줄에
code.style.wrapping.fields.annotation=프로퍼티 속성
code.style.wrapping.group.title.closure=클로저
code.style.wrapping.group.title.condition.clauses=조건 절
code.style.wrapping.group.title.do.while=''repeat … while'' 문
code.style.wrapping.group.title.guard=''guard'' 문
code.style.wrapping.group.title.if=''if'' 문
code.style.wrapping.group.title.method.arguments=메서드/함수 호출 인수
code.style.wrapping.group.title.method.parameters=메서드/함수 선언 매개변수
code.style.wrapping.group.title.superclass.list=기본 클래스 및 채택된 프로토콜 목록
code.style.wrapping.group.title.ternary=삼항 조건 연산
code.style.wrapping.group.title.try=''do'' 문
code.style.wrapping.group.title.variable.groups=변수 그룹
code.style.wrapping.guard.else=else
code.style.wrapping.guard.else.always=항상 줄 바꿈
code.style.wrapping.guard.else.never=줄 바꿈 안 함
code.style.wrapping.guard.else.wrapped=조건으로 래핑
code.style.wrapping.keep.control.statement.in.one.line=제어문을 한 줄로
code.style.wrapping.keep.simple.argument.blocks.in.one.line=클로저 인수를 한 줄에 배치
code.style.wrapping.keep.simple.blocks.in.one.line=블록 및 (후미) 클로저를 한 줄로
code.style.wrapping.keep.simple.methods.in.one.line=메서드 및 함수를 한 줄로
code.style.wrapping.local.variables.annotation=지역 변수 속성
code.style.wrapping.method.brace.placement=메서드 및 함수 내
code.style.wrapping.method.chain.dot.on.new.line=새 줄에 '.'
code.style.wrapping.methods.annotation=메서드 속성
code.style.wrapping.parameters.annotation=매개변수 속성
code.style.wrapping.structures.in.one.line=빈 유형 선언을 한 줄로
color.conditionally.not.compiled=키워드 및 지시문//조건으로 컴파일되지 않은 코드
color.settings.actor=타입//엑터
color.settings.anonymous.closure.parameter=식별자//익명의 클로저 매개변수
color.settings.argument.label=식별자//인수 라벨
color.settings.associated.type=타입//관련 타입
color.settings.attribute.argument=속성//속성 인수
color.settings.attribute.name=속성//속성 이름
color.settings.class=유형//클래스
color.settings.colon=괄호 및 연산자//콜론
color.settings.directive=키워드 및 지시문//지시문
color.settings.directive.condition=키워드 및 지시문//지시문 조건
color.settings.directive.flag=키워드 및 지시문//지시문 플래그
color.settings.enum.case.value=식별자//열거형 case 값
color.settings.external.parameter.name=식별자//외부 매개변수 이름
color.settings.function.and.method.call=함수//함수 및 메서드 호출
color.settings.function.and.method.declaration=함수//함수 및 메서드 선언
color.settings.inline.closure.parameter=식별자//인라인 클로저 매개변수
color.settings.inline.hints.error.hint=인라인 힌트//오류 힌트
color.settings.inline.hints.type.hint=인라인 힌트//유형 힌트
color.settings.keyword=키워드 및 지시문//키워드
color.settings.module.name=유형//모듈 이름
color.settings.nested.function.call=함수//중첩된 함수 호출
color.settings.nested.function.declaration=함수//중첩된 함수 선언
color.settings.operator.sign=괄호 및 연산자//연산자 기호
color.settings.property=식별자//프로퍼티
color.settings.protocol=유형//프로토콜
color.settings.self.and.super.keywords=키워드 및 지시문//''self'' 및 ''super'' 키워드
color.settings.struct.and.enum=유형//구조체 및 열거형
color.settings.tuple.label=식별자//튜플 라벨
color.settings.tuple.type.label=식별자//튜플 타입 라벨
color.settings.type.alias=유형//유형 별칭
color.settings.type.parameter=유형//제네릭 매개변수
color.settings.wildcard=식별자//와일드카드
command.name.extract.function=함수 추출
context.declaration=선언
context.statement=구문
create.file.action=Swift 파일 {0} 생성
create.file.description=새 Swift 파일을 생성합니다.
create.file.dialog.title=새 Swift 파일
create.file.kind=종류(&K)\:
create.file.kind.file=Archivo
create.file.or.type.description=새 Swift 파일 또는 유형 생성
create.file.or.type.title=Swift 파일/유형
create.file.title=Swift 파일
create.file.type.description=새 Swift 유형을 생성합니다.
create.file.type.dialog.title=새 Swift 유형
create.file.type.dialog.title.with.kind=새 Swift {0}
create.file.type.title=Swift 유형
create.from.usage.choose.target.type=대상 유형 선택
create.from.usage.create.function.command=사용 위치에서 함수 생성
create.from.usage.create.init.command=사용 위치에서 이니셜라이저 생성
create.from.usage.create.type.command=새 Swift 유형 생성
create.from.usage.create.variable.command=사용 위치에서 변수 생성
create.from.usage.location.in={0} 내
create.from.usage.location.new.file=새 파일
create.from.usage.location.this.file=이 파일
doc.comments.enable.markdown=문서 주석의 서식을 깔끔하게 지정하려면, Markdown 플러그인을 활성화하세요
editor.appearance.error.hints=Swift 오류 힌트 표시
editor.appearance.type.hints=Swift 유형 힌트 표시
error.cannot.perform.refactoring=리팩터링을 수행할 수 없습니다
error.no.expression.found=표현식을 찾을 수 없습니다
extract.method.0.1.will.be.shadowed.by.2.1={0} ''{1}''이(가) {2} ''{1}''으로 그림자화됩니다.
extract.method.at.least.two.parameters.have.name.0=이름이 ''{0}''인 매개변수가 2개 이상입니다.
extract.method.cannot.extract.mutable.value=가변 값을 추출할 수 없습니다.
extract.method.error.cannot.determine.expr.type=선택한 표현식의 유형을 파악할 수 없습니다.
extract.method.error.cannot.determine.function.result.type=함수 결과의 유형을 파악할 수 없습니다.
extract.method.error.cannot.determine.parameters.type=매개변수의 유형을 파악할 수 없습니다.
extract.method.error.cannot.extract.expr.with.var.declarations=변수 선언이 있는 표현식에서 추출할 수 없습니다.
extract.method.error.cannot.extract.with.returns=코드 조각 내부에 반환 명령이 있는 메서드를 추출할 수 없습니다.
extract.method.error.fragment.should.be.inside.code.block=선택된 코드 조각은 코드 블록 안에 있어야 합니다.
extract.method.error.multiple.exit.points=선택한 코드 조각에 여러 종료점이 있습니다.
extract.method.error.result.builder.block=결과 빌더 클로저에서 함수를 추출할 수 없습니다
extract.method.error.should.represent.expr.or.statements=선택한 블록은 구문 또는 표현식 모음을 나타내야 합니다.
extract.method.function.0.will.conflict.with.1.2=함수 ''{0}''이(가) {1} {2}와(과) 충돌합니다.
extract.method.method.0.will.conflict.with.1.in.2.3=메서드 ''{0}''이(가) {2} ''{3}''에서 {1}와(과) 충돌합니다.
extract.method.title.closure=클로저 추출
extract.method.title.function=함수 추출
extract.method.title.method=메서드 추출
extract.method.variable.0.will.no.longer.be.accessible=리팩터링 후 변수 ''{0}'' 에 더 이상 액세스할 수 없습니다
find.usages.base.member.warning.message.default.implementation.method={0} 은(는) {1}에 선언된 메서드의 기본 구현체입니다\n\n프로토콜 {3,choice,1\#메서드|2\#메서드}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.message.default.implementation.property={0} 은(는) {1}에 선언된 프로퍼티의 기본 구현체입니다\n\n프로토콜 {3,choice,1\#프로퍼티|2\#프로퍼티}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.message.default.implementation.subscript={0} 은(는) {1}에 선언된 서브스크립트의 기본 구현체입니다\n\n프로토콜 {3,choice,1\#서브스크립트|2\#서브스크립트}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.message.implements.method={0} 은(는) {1}에 선언된 메서드를 구현합니다\n\n프로토콜 {3,choice,1\#메서드|2\#메서드}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.message.implements.property={0} 은(는) {1}에 선언된 프로퍼티를 구현합니다\n\n프로토콜 {3,choice,1\#프로퍼티|2\#프로퍼티}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.message.implements.subscript={0} 은(는) {1}에 선언된 서브스크립트를 구현합니다\n\n프로토콜 {3,choice,1\#서브스크립트|2\#서브스크립트}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.message.override.implemented.method={0} 은(는) {2}에 선언된 메서드를 재정의하고 {1} 선언된 메서드를 구현합니다\n\n기본 및 프로토콜 {3,choice,1\#메서드|2\#메서드}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.message.override.implemented.property={0} 은(는) {2}에 선언된 프로퍼티를 재정의하고 {1} 선언된 프로퍼티를 구현합니다\n\n기본 및 프로토콜 {3,choice,1\#프로퍼티|2\#프로퍼티}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.message.override.implemented.subscript={0} 은(는) {2}에 선언된 서브스크립트를 재정의하고 {1} 선언된 서브스크립트를 구현합니다\n\n기본 및 프로토콜 {3,choice,1\#서브스크립트|2\#서브스크립트}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.message.override.method={0} 은(는) {2}에 선언된 메서드를 재정의합니다\n\n기본 {3,choice,1\#메서드|2\#메서드}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.message.override.property={0} 은(는) {2}에 선언된 프로퍼티를 재정의합니다\n\n기본 {3,choice,1\#프로퍼티|2\#프로퍼티}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.message.override.subscript={0} 은(는) {2}에 선언된 서브스크립트를 재정의합니다\n\n기본 {3,choice,1\#서브스크립트|2\#서브스크립트}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.title=경고
find.usages.option.search.in.not.compiled.code=조건부로 컴파일링되지 않은 코드 내의 잠재적인 사용 위치 표시
generate.0.title={0} 생성
generate.cannot.generate.0.for.1={1}에 대한 {0}을(를) 생성할 수 없습니다.
generate.description.multi.string.template=다중 줄 문자열
generate.description.single.string.template=단일 문자열
generate.description.string.concatenation.template=연결이 있는 여러 문자열 (+)
generate.equals.hash=equals 및 hash
generate.equals.hash.choose.in.0={0}에 포함할 프로퍼티 선택
generate.if.statements.equals.template=여러 개의 if 문
generate.init.choose.properties=초기화할 프로퍼티 선택
generate.init.choose.super.init=상위 클래스 이니셜라이저 선택
generate.init.init.already.exists=이니셜라이저가 이미 있습니다.
generate.method.0.and.operator.function.1.are.already.defined=메서드 ''{0}'' 및 연산자 함수 ''{1}'' 이(가) 이미 정의되어 있습니다. 해당 메서드 및 함수를 삭제하고 계속 진행하시겠어요?
generate.method.0.and.property.1.are.already.defined=메서드 ''{0}'' 및 프로퍼티 ''{1}'' 이(가) 이미 정의되어 있습니다. 해당 메서드 및 프로퍼티를 삭제하고 계속 진행하시겠어요?
generate.method.0.is.already.defined=메서드 ''{0}'' 이(가) 이미 정의되어 있습니다. 해당 메서드를 삭제하고 계속 진행하시겠어요?
generate.method.0.property.1.and.operator.function.2.are.already.defined=메서드 ''{0}'', 프로퍼티 ''{1}'' 및 연산자 함수 ''{2}'' 이(가) 이미 정의되어 있습니다. 해당 메서드. 프로퍼티 및 함수를 삭제하고 계속 진행하시겠어요?
generate.operator.function.0.is.already.defined=연산자 함수 ''{0}'' 이(가) 이미 정의되어 있습니다. 해당 함수를 삭제하고 계속 진행하시겠어요?
generate.preparing.generation.title=생성 준비 중…
generate.property.0.and.operator.function.1.are.already.defined=프로퍼티 ''{0}'' 및 연산자 함수 ''{1}'' 이(가) 이미 정의되어 있습니다. 해당 프로퍼티 및 함수를 삭제하고 계속 진행하시겠어요?
generate.property.0.is.already.defined=프로퍼티 ''{0}'' 이(가) 이미 정의되어 있습니다. 해당 프로퍼티를 삭제하고 계속 진행하시겠어요?
generate.single.expression.equals.template=단일 표현식
generate.template.title=Plan&tilla\:
got.it.no.refactoring.in.not.compiled.code.header=리팩터링 액션을 사용할 수 없습니다
got.it.no.refactoring.in.not.compiled.code.message=리팩터링 액션은 조건부로 컴파일되지 않은 코드에서는 사용할 수 없습니다. 다른 해결 컨텍스트로 전환하여 주위의 '#if directive' 브랜치를 활성화하세요.
got.it.search.not.compiled.code.header=조건부로 컴파일되지 않은 코드 내의 사용 위치
got.it.search.not.compiled.code.message=조건부로 컴파일링되지 않은 코드에서 사용 위치 검색은 이름 변경 대화상자에서 활성화할 수 있습니다. 이름 변경 대화상자를 표시하려면 {0}을(를) 다시 누르세요.
goto.base.type=기본 유형
goto.class.kind=Tipo
goto.class.kinds.title=Tipo
goto.super.action={0} 선택
goto.super.class=클래스 또는 프로토콜
goto.super.extension.of.0={0} 확장
goto.super.location={1} 내 {0}
goto.super.menu.action=상위 {0}(_U)
goto.super.typealias=유형 별칭 또는 관련 유형
inheritance.relation.implements={0} 구현
inheritance.relation.is.implemented=구현됨
inheritance.relation.is.overridden=재정의됨
inheritance.relation.is.subclassed=하위 클래스가 됨
inheritance.relation.overrides={0} 재정의
inline.0.action.1={0} {1} 인라인화
inline.0.command.1={0} {1} 인라인화
inline.all.invocations.and.keep.the.0=전체 인라인화, {0} 유지(&A)
inline.all.invocations.and.remove.the.0=전체 인라인화, {0} 제거(&A)
inline.all.references.and.keep.the.0=전체 인라인화, {0} 유지(&A)
inline.all.references.and.remove.the.0=전체 인라인화, {0} 제거(&A)
inline.all.typealias.and.keep.the.0=전체 인라인화, {0} 유지(&A)
inline.all.typealias.and.remove.the.0=전체 인라인화, {0} 제거(&A)
inline.error.cannot.access.symbol.0=심볼 {0}을(를) 액세스할 수 없습니다
inline.error.cannot.resolve.symbol=심볼을 해결할 수 없습니다
inline.error.function.definition.contains.no.body=함수 정의에 본문이 없습니다
inline.error.function.no.return.statement=함수에 return 문이 없습니다
inline.error.implements.function.from.0=인라인화된 메서드는 {0}의 메서드를 구현합니다
inline.error.inline.function.has.conditionally.compiled.code=조건부로 컴파일되지 않는 코드가 포함되어 함수가 적절하게 인라인화되지 않았습니다
inline.error.inline.function.only.in.swift.code=함수 인라인화는 Swift 코드에서만 지원됩니다
inline.error.inline.recursive.function.only.on.invocations=재귀 함수 인라인화는 호출에서만 지원됩니다
inline.error.inline.typealias.has.conditionally.compiled.code=조건부로 컴파일되지 않는 코드가 포함되어 타입 별칭이 적절하게 인라인화되지 않았습니다
inline.error.inline.variable.has.conditionally.compiled.code=조건부로 컴파일되지 않는 코드가 포함되어 변수가 적절하게 인라인화되지 않았습니다
inline.error.inline.variable.no.single.definition=인라인화할 단일 정의를 찾을 수 없습니다
inline.error.inlined.expression.should.be.part.of.statement=인라인화된 식은 구문의 일부여야 합니다
inline.error.invalid.function.arguments=잘못된 함수 인수
inline.error.is.overridden.by.function.from.0=인라인화된 메서드는 {0}의 메서드에 의해 재정의됩니다
inline.error.not.function.call=함수 호출이 아닙니다
inline.error.overrides.associated.type.from.0=인라인화된 타입 별칭이 {0}의 associatedtype을 재정의합니다
inline.error.overrides.function.from.0=인라인화된 메서드는 {0}의 메서드를 재정의합니다
inline.error.unexpected.error=인라인화 중 예기치 않은 오류
inline.function.description=함수 호출을 본문으로 바꾸기
inline.function.label.kind.0.name.1={0} {1} 인라인화:
inline.function.label.kind.0.name.1.2.occurrences={0} {1}의 {2} 호출을 인라인화:
inline.function.label.kind.0.name.1.occurence={0} {1} 호출을 인라인화:
inline.include.doc.comments=문서 주석에 적용
inline.recursively=재귀적 인라인화
inline.this.invocation.only.and.keep.the.0=이 호출만 인라인화 및 {0} 유지
inline.this.reference.only.and.keep.the.0=이 참조만 인라인화하고 {0}을(를) 유지합니다
inline.this.typealias.only.and.keep.the.0=이 사용 위치만 인라인화하고 {0}은(는) 유지
inline.title.0={0} 인라인화
inline.typealias.label.kind.0.name.1={0} {1} 인라인화:
inline.typealias.label.kind.0.name.1.2.occurrences={0} {1}의 사용 위치 {2}개를 인라인화
inline.typealias.label.kind.0.name.1.occurence={0} {1}의 사용 위치를 인라인화:
inline.variable.label.kind.0.name.1={0} {1} 인라인화:
inline.variable.label.kind.0.name.1.2.occurrences={0} {1}의 {2} 호출을 인라인화
inline.variable.label.kind.0.name.1.occurence={0} {1}의 호출을 인라인화
inspection.conditionally.not.compiled.code=조건으로 컴파일되지 않은 코드
inspection.missing.doc.comment.parameter.item=일치하지 않는 문서 주석 및 함수 시그니처
inspection.missing.doc.comment.parameter.item.error=매개변수 {0}이(가) 문서 주석에 설명되어 있지 않습니다
inspection.missing.doc.comment.parameter.item.fix=문서 주석 업데이트
inspection.missing.localization=로컬라이제이션 언어 누락
inspection.missing.localization.all.languages.only=모든 언어에서 누락된 현지화만 보고
inspection.redundant.attribute=중복 속성
inspection.redundant.attribute.error=속성 @{0}이(가) 중복되었습니다.
inspection.redundant.attribute.fix=중복 속성 @{0} 제거
inspection.redundant.closure=불필요한 클로저
inspection.redundant.closure.error=불필요한 클로저 생성
inspection.redundant.closure.fix=본문 인라인화
inspection.redundant.nullable.function.type.error=''{0}''이(가) null이 아닌 타입을 항상 반환합니다
inspection.redundant.nullable.type=중복된 null 가능한 타입
inspection.redundant.nullable.type.error=''{0}''이(가) 항상 null이 아닌 타입입니다
inspection.redundant.nullable.type.fix=중복 '?'를 제거합니다.
inspection.redundant.return=중복 반환
inspection.redundant.return.error=''return''이 중복되었습니다.
inspection.redundant.return.fix=중복 ''return''을 제거합니다.
inspection.unnecessary.argument.list=불필요한 인수 목록
inspection.unnecessary.argument.list.error=인수 목록이 불필요합니다
inspection.unnecessary.argument.list.fix=불필요한 인수 목록 제거
inspection.unnecessary.parentheses=불필요한 소괄호
inspection.unnecessary.parentheses.error=소괄호는 불필요합니다.
inspection.unnecessary.parentheses.fix=불필요한 소괄호를 제거합니다.
inspection.unnecessary.self=불필요한 self
inspection.unnecessary.self.error=''self''가 불필요합니다
inspection.unnecessary.self.fix=불필요한 ''self'' 제거
inspection.unnecessary.tuple.wrap=불필요한 튜플 둘러싸기
inspection.unnecessary.tuple.wrap.error=단일 요소 튜플을 유형으로 바꿀수 있습니다
inspection.unnecessary.tuple.wrap.fix=단일 요소 튜플을 유형으로 바꾸기
intention.access.control.error.access={0}에 액세스할 수 없습니다. 해당 항목은 {2}에서 {1}입니다.
intention.access.control.error.access.dynamic={0}에 액세스할 수 없습니다. 동적 멤버 서브스크립트는 {2}에서 {1}입니다.
intention.access.control.error.override={0}을(를) 재정의할 수 없습니다. 해당 항목은 {2}에서 {1}입니다.
intention.access.control.fix={2} 내 {0} {1} 생성
intention.access.control.remove.setter={0}에서 {1} 제거
intention.add.catch.clause=''catch'' 절 추가
intention.add.default.catch.clause=디폴트 ''catch'' 절 추가
intention.add.digit.separators=숫자 구분 기호 추가
intention.add.explicit.qualifier=명시적 한정자 추가
intention.add.explicit.type=명시적 유형 추가
intention.add.try.to.expression=Añadir ''try''
intention.add.try.to.iteration='try'를 반복에 추가
intention.category.swift=Swift
intention.convert.to.binary=2진수로 변환
intention.convert.to.closure.argument=클로저 인수로 변환
intention.convert.to.decimal=10진수로 변환
intention.convert.to.hex=16진수로 변환
intention.convert.to.multiline.string=여러 줄 문자열 리터럴로 변환
intention.convert.to.octal=8진수로 변환
intention.convert.to.string=한 줄 문자열 리터럴로 변환
intention.convert.to.trailing.closure=후행 클로저로 변환
intention.create.actor.0=액터 ''{0}'' 생성
intention.create.actor.0.in.new.file=새 파일에 액터 ''{0}'' 생성
intention.create.actor.0.nested.in.1=''{1}''에 중첩된 액터 ''{0}'' 생성
intention.create.class.0=클래스 ''{0}'' 생성
intention.create.class.0.in.new.file=새 파일에 클래스 ''{0}'' 생성
intention.create.class.0.nested.in.1=''{1}''에 중첩된 클래스 ''{0}'' 생성
intention.create.enum.0=열거형 ''{0}'' 생성
intention.create.enum.0.in.new.file=새 파일에 열거형 ''{0}'' 생성
intention.create.enum.0.nested.in.1=''{1}''에 중첩된 열거형 ''{0}'' 생성
intention.create.enum.case.0=열거형 케이스 ''{0}'' 생성
intention.create.global.function.0=전역 함수 ''{0}'' 생성
intention.create.global.variable.0=전역 변수 ''{0}'' 생성
intention.create.initializer=이니셜라이저 생성
intention.create.local.variable.0=지역 변수 ''{0}'' 생성
intention.create.method.0=메서드 ''{0}'' 생성
intention.create.method.0.in.extension=확장 메서드 ''{0}'' 생성
intention.create.new.swift.declaration=새 Swift 선언 생성
intention.create.new.swift.type.in.a.new.file=새 파일 내 새 Swift 유형
intention.create.property.0=프로퍼티 ''{0}'' 생성
intention.create.property.0.in.extension=확장 프로퍼티 ''{0}'' 생성
intention.create.protocol.0=프로토콜 ''{0}'' 생성
intention.create.protocol.0.in.new.file=새 파일에 프로토콜 ''{0}'' 생성
intention.create.protocol.0.nested.in.1=''{1}''에 중첩된 프로토콜 ''{0}'' 생성
intention.create.struct.0=구조체 ''{0}'' 생성
intention.create.struct.0.in.new.file=새 파일에 구조체 ''{0}'' 생성
intention.create.struct.0.nested.in.1=''{1}''에 중첩된 구조체 ''{0}'' 생성
intention.create.type.0=타입 ''{0}'' 생성
intention.create.type.0.in.new.file=새 파일에 타입 ''{0}'' 생성
intention.create.type.0.nested.in.1=''{1}''에 중첩된 타입 ''{0}'' 생성
intention.create.type.method.0=타입 메서드 ''{0}'' 생성
intention.create.type.method.0.in.extension=확장 타입 메서드 ''{0}'' 생성
intention.create.type.property.0=타입 프로퍼티 ''{0}'' 생성
intention.create.type.property.0.in.extension=확장 타입 프로퍼티 ''{0}'' 생성
intention.decrease.string.escape.level=문자열 이스케이프 수준 낮추기
intention.demorgans.law=드모르간 법칙
intention.demorgans.law.format=''{0}''을(를) ''{1}''(으)로 바꾸기
intention.extract.class.0.to.extension=클래스 ''{0}''을(를) 확장으로 추출
intention.extract.class.0.to.type.declaration=클래스 ''{0}''을(를) 타입 선언으로 추출
intention.extract.conformance.to.extension.cannot.add.protocol.conformance.to.protocol=프로토콜 확장은 다른 프로토콜을 따를 수 없습니다
intention.extract.conformance.to.extension.cannot.extract.class=클래스 상속 ''{0}''을(를) 확장으로 추출할 수 없습니다
intention.extract.conformance.to.extension.familyName=확장으로 추출 시 적합도
intention.extract.conformance.to.extension.type.cannot.be.local=지역 범위에서 확장을 생성할 수 없습니다
intention.extract.conformance.to.extension.type.must.be.fileprivate=타입은 최소 fileprivate이어야 합니다
intention.extract.enum.0.to.extension=열거형 ''{0}''을(를) 확장으로 추출
intention.extract.enum.0.to.type.declaration=열거형 ''{0}''을(를) 타입 선언으로 추출
intention.extract.from.extension.to.type.declaration.error.message.title=멤버를 원본 타입 선언으로 추출
intention.extract.from.extension.to.type.declaration.familyName=멤버를 원본 타입 선언으로 추출
intention.extract.from.extension.to.type.declaration.original.analysis.on.type.not.allowed=Original type declaration is out of scope
intention.extract.from.extension.to.type.declaration.original.type.not.found=원본 타입 선언이 발견되지 않음
intention.extract.function.0.to.extension=함수 ''{0}''을(를) 확장으로 추출
intention.extract.function.0.to.type.declaration=함수 ''{0}''을(를) 타입 선언으로 추출
intention.extract.initializer.to.extension=이니셜라이저를 확장으로 추출
intention.extract.initializer.to.type.declaration=이니셜라이저를 타입 선언으로 추출
intention.extract.member.to.extension.cannot.extract.from.protocol=포로토콜에서 추출할 수 없음
intention.extract.member.to.extension.type.cannot.be.local=지역 범위에서 확장을 생성할 수 없습니다
intention.extract.member.to.extension.type.must.be.fileprivate=타입은 최소 fileprivate이어야 합니다
intention.extract.members.to.extension.error.message.title=멤버를 확장으로 추출
intention.extract.members.to.extension.familyName=멤버를 확장으로 추출
intention.extract.multiple.members.to.extension=멤버를 확장으로 추출
intention.extract.multiple.members.to.type.declaration=멤버를 타입 선언으로 추출
intention.extract.property.0.to.extension=프로퍼티 ''{0}''을(를) 확장으로 추출
intention.extract.property.0.to.type.declaration=프로퍼티 ''{0}''을(를) 타입 선언으로 추출
intention.extract.struct.0.to.extension=구조체 ''{0}''을(를) 확장으로 추출
intention.extract.struct.0.to.type.declaration=구조체 ''{0}''을(를) 타입 선언으로 추출
intention.extract.subscript.to.extension=서브스크립트를 확장으로 추출
intention.extract.subscript.to.type.declaration=서브스크립트를 타입 선언으로 추출
intention.extract.typealias.0.to.extension=타입 별칭을 확장으로 추출
intention.extract.typealias.0.to.type.declaration=타입 별칭 ''{0}''을(를) 타입 선언으로 추출
intention.flip.binary.expression=이진 표현식 반전
intention.flip.binary.expression.format=Invertir ''{0}''
intention.flip.comparison=Invertir comparación.
intention.flip.comparison.format=Invertir ''{0}'' a ''{1}''
intention.generate.documentation.comment=문서 주석 추가
intention.implement.equals=누락된 등식 구현
intention.implement.hash=누락된 해시 구현
intention.implement.members.error=유형 {0}이(가) {1}을(를) 준수하지 않습니다.
intention.implement.members.implement.missing={0} 누락된 {0,choice,1\#멤버|2\#멤버} 구현
intention.implement.missing.equals.hash=누락된 등식 및 해시 구현
intention.increase.string.escape.level=문자열 이스케이프 수준 높이기
intention.invert.if.statement=구문인 경우 반전
intention.join.declaration.and.assignment=선언 및 할당 결합
intention.localize.string=문자열 로컬화
intention.localize.string.title.case=문자열 현지화
intention.mark.the.enclosing.function.as.throws=''throws''를 함수 시그니처에 추가
intention.merge.conditions=조건 병합
intention.merge.else.if=else if 문 병합
intention.merge.nested.if=중첩된 if 문 병합
intention.negate.comparison=Negar comparación
intention.negate.comparison.format=Negar ''{0}'' como ''{1}''
intention.remove.digit.separators=숫자 구분 기호 제거
intention.remove.explicit.type=명시적 유형 제거
intention.replace.guard.with.if=''guard''를 ''if''로 바꾸기
intention.replace.if.with.guard=''if''를 ''guard''로 바꾸기
intention.replace.rethrows.with.throws=''rethrows''를 ''throws''로 바꾸기
intention.simplifyifelse.collapse.conditional.expression=조건식 접기
intention.simplifyifelse.collapse.guard='guard' 접기
intention.simplifyifelse.collapse.ifelse='if else' 접기
intention.simplifyifelse.familyName=if-else 단순화
intention.simplifyifelse.replace.guard.with.0=''guard''를 ''{0}''(으)로 바꾸기
intention.simplifyifelse.replace.if.else.with.0=''if else''를 ''{0}''(으)로 바꾸기
intention.simplifyifelse.simplify=단순화
intention.simplifyifelse.simplify.guard='guard' 단순화
intention.simplifyifelse.simplify.if.else='if else' 단순화
intention.split.condition=개별 조건으로 분할
intention.split.declaration.and.assignment=선언 및 할당 분할
intention.split.else.if=else if 문 분할
intention.split.into.separate.declarations=개별 선언으로 분할합니다.
intention.split.nested.if=중첩된 if로 분할
intention.suppress.call.error.with.try=''try\!''로 오류 억제
intention.surround.with.do.catch=''do/catch''로 둘러싸기
intention.swift.module.info=모듈 정보 표시
intention.switch.resolve.configuration.specified=''{0}''(으)로 전환하여 이 브랜치를 활성화
intention.unresolved.reference.0.1={0} ''{1}'' 가져오기
intention.unwrap.with.guard.let='guard let'으로 래핑 해제
intention.unwrap.with.if.let='if let'으로 래핑 해제
intention.wrong.return.type.fix=''{0}''이(가) ''{1}''을(를) 반환하도록 설정
intention.wrong.return.type.fix.with.types=''{0}''이(가) ''{1}''을(를) 반환하도록 만들기
introduce.variable.declare.with.var=var로 선언(&V)
introduce.variable.expression.will.be.ambiguous.without.explicit.type=명시적 유형  없이는<br/>  표현식이 모호합니다.
introduce.variable.specify.type.explicitly=명시적으로 유형 지정(&T)
notification.group.plugin.errors=Swift 언어 서비스 실패
optimize.imports.rearranged.imports=재정렬된 import 문
optimize.imports.removed.0.added.1.imports={0}개의 {0,choice,0#import 문|1#import 문|1<import 문}을 제거하고, {1}개의 {1,choice,0#import 문|1#import 문|1<import 문}을 추가했습니다
optimize.imports.removed.0.imports={0}개의 {0,choice,0#import 문|1#import 문|1<import 문}이 제거되었습니다
override.implement.elements.to.implement.chooser.title=구현할 멤버 선택
override.implement.elements.to.override.chooser.title=재정의할 멤버 선택
override.implement.elements.to.override.implement.chooser.title=재정의/구현할 멤버 선택
override.implement.implement.not.allowed=구현할 수 없음
override.implement.nothing.to.implement=구현할 항목 없음
override.implement.nothing.to.override=재정의할 항목 없음
override.implement.override.not.allowed=재정의할 수 없음
override.implement.progress=재정의/구현할 멤버 처리 중…
override.implement.show.members.to.implement.title=구현할 멤버 표시
override.implement.show.no.optional.members=선택적 멤버 표시(선택적 항목 없음)
override.implement.show.only.optional.members=선택적 멤버 표시(선택적 항목만)
override.implement.show.optional.member=1개의 선택적 멤버 표시(&O)
override.implement.show.optional.members={0}개의 선택적 멤버 표시(&O)
refactor.0.overrides.associated.type.of.1={0} 이(가) {1} 의 연관 유형을 재정의합니다
refactor.0.overrides.declaration.in.1={0} 이(가) {1} 내 선언을 재정의합니다
refactor.0.overrides.initializer.of.1={0} 이(가) {1} 의 이니셜라이저를 재정의합니다
refactor.0.overrides.method.of.1={0} 이(가) {1} 의 메서드를 재정의합니다
refactor.0.overrides.property.of.1={0} 이(가) {1} 의 프로퍼티를 재정의합니다
refactor.0.overrides.subscript.of.1={0} 이(가) {1} 의 서브스크립트를 재정의합니다
refactor.base.declaration=기본 {0,choice,1\#선언|2\#선언} 리팩터링
refactor.only.current.declaration=현재 선언만 리팩터링
refactoring.option.search.in.not.compiled.code=조건부로 컴파일되지 않은 코드에 적용
rename.containing.file.dialog.description=다음 이름을 가진 포함 파일의 이름 변경\:
rename.containing.file.dialog.title=포함하는 파일 이름 변경
rename.containing.file.entity.name=포함 파일
rename.error.dynamic.called.values=동적으로 호출된 값의 이름은 변경할 수 없습니다.
rename.error.message.renaming.swift.member.elements.in.objective.c.code.is.not.supported=Objective-C 코드 내 Swift 멤버 요소의 이름 변경은 지원되지 않습니다.
rename.error.title=Swift - 이름 변경
rename.inheritor.entity.name=상속자
rename.inheritors=상속자 이름 변경
rename.inheritors.to=상속자 이름을 다음으로 변경\:
rename.init.is.not.supported=swift 이니셜라이저의 이름 변경은 지원되지 않습니다.
rename.related.dialog.description=다음 이름을 가진 관련 선언의 이름을 변경\:
rename.related.dialog.title=관련 선언의 이름 변경
rename.related.entity.name=관련 선언
rename.self.is.not.supported=self 매개변수의 이름 변경은 지원되지 않습니다.
rename.title=Swift 이름 변경
searching.for.implementations=구현 검색 중...
searching.for.overriders=재정의자 검색 중...
searching.for.subclasses=하위 클래스 검색 중...
sourcekit.fix.it=Fix-it 적용
sourcekit.inspections=SourceKit 검사
swift.name=Swift
syntax.error.call.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=호출은 던질 수 있지만 던지지 않는 autoclosure에서 실행됩니다.
syntax.error.call.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=호출은 던질 수 있지만 ''try''로 표시되지 않으며 던지지 않는 autoclosure에서 실행됩니다.
syntax.error.call.can.throw.in.default.argument=디폴트 인수에서 호출은 던질 수 있지만 오류는 던질 수 없습니다.
syntax.error.call.can.throw.in.property.initializer=프로퍼티 이니셜라이저에서 호출은 던질 수 있지만 오류는 던질 수 없습니다.
syntax.error.call.can.throw.not.marked.with.try=호출은 던질 수 있지만 ''try''로 표시되지 않습니다.
syntax.error.call.can.throw.not.marked.with.try.not.exhaustive=호출은 던질 수 있지만 ''try''로 표시되지 않으며 둘러싼 catch가 완전하지 않습니다.
syntax.error.call.can.throw.not.marked.with.try.not.handled=호출은 던질 수 있지만 ''try''로 표시되지 않으며 오류가 처리되지 않습니다.
syntax.error.call.rethrows.function.can.only.throw.parameter.call.not.handled=호출은 던질 수 있지만 오류는 처리되지 않습니다. 'rethrows'로 선언된 함수는 해당 매개변수가 던질 경우에만 던집니다
syntax.error.call.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=호출은 던질 수 있지만 'try'로 표시되지 않으며 오류가 처리되지 않습니다. 'rethrows'로 선언된 함수는 해당 매개변수가 던질 경우에만 던집니다
syntax.error.duplicate.platform=플랫폼 ''{0}''은(는) 이미 지정되어 있습니다
syntax.error.error.is.not.handled=둘러싼 함수가 ''throws''로 던져지지 않기 때문에 오류가 처리되지 않습니다.
syntax.error.error.is.not.handled.not.exhaustive=둘러싼 catch가 완전하지 않기 때문에 오류가 처리되지 않습니다.
syntax.error.errors.are.not.handled=여기에서 던져진 오류는 처리되지 않습니다.
syntax.error.errors.are.not.handled.not.exhaustive=둘러싼 catch가 완전하지 않기 때문에 여기에서 던져진 오류는 처리되지 않습니다.
syntax.error.hashbang.line.is.allowed.only.in.the.first.line.of.the.file=Hashbang 줄은 파일의 첫 번째 줄에서만 허용됩니다.
syntax.error.hashbang.line.is.allowed.only.in.the.first.line.of.the.main.file=Hashbang 줄은 기본 파일의 첫 번째 줄에서만 허용됩니다.
syntax.error.hashbang.line.is.allowed.only.in.the.main.file=Hashbang 줄은 기본 파일에서만 허용됩니다.
syntax.error.interpolation.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=보간은 던질 수 있지만 던지지 않는 autoclosure에서 실행됩니다
syntax.error.interpolation.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=보간은 던질 수 있지만 'try'로 표시되지 않으며 던지지 않는 autoclosure에서 실행됩니다
syntax.error.interpolation.can.throw.in.default.argument=디폴트 인수에서 보간은 던질 수 있지만 오류는 던질 수 없습니다
syntax.error.interpolation.can.throw.in.property.initializer=프로퍼티 이니셜라이저에서 보간은 던질 수 있지만 오류는 던질 수 없습니다
syntax.error.interpolation.can.throw.not.marked.with.try=보간은 던질 수 있지만 'try'로 표시되지 않습니다
syntax.error.interpolation.can.throw.not.marked.with.try.not.exhaustive=보간은 던질 수 있지만 'try'로 표시되지 않으며 둘러싼 catch가 완전하지 않습니다
syntax.error.interpolation.can.throw.not.marked.with.try.not.handled=보간은 던질 수 있지만 'try'로 표시되지 않으며 오류가 처리되지 않습니다
syntax.error.interpolation.rethrows.function.can.only.throw.parameter.call.not.handled=보간은 던질 수 있지만 오류는 처리되지 않습니다. 'rethrows'로 선언된 함수는 해당 매개변수가 던질 경우에만 던집니다
syntax.error.interpolation.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=보간은 던질 수 있지만 'try'로 표시되지 않으며 오류가 처리되지 않습니다. 'rethrows'로 선언된 함수는 해당 매개변수가 던질 경우에만 던집니다
syntax.error.iteration.can.throw.not.marked.with.try=반복은 던질 수는 있지만 'try'로 표시되지 않습니다
syntax.error.iteration.can.throw.not.marked.with.try.not.exhaustive=반복은 던질 수는 있지만 'try'로 표시되지 않으며 둘러싼 catch가 완전하지 않습니다
syntax.error.iteration.can.throw.not.marked.with.try.not.handled=반복은 던질 수는 있지만 'try'로 표시되지 않으며 오류가 처리되지 않습니다
syntax.error.operator.can.throw.not.marked.with.try=연산자는 던질 수 있지만 표현식은 ''try''로 표시되지 않습니다.
syntax.error.property.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=프로퍼티 액세스는 던질 수 있지만 던지지 않는 autoclosure에서 실행됩니다
syntax.error.property.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=프로퍼티 액세스는 던질 수 있지만 'try'로 표시되지 않으며 던지지 않는 autoclosure에서 실행됩니다
syntax.error.property.can.throw.in.default.argument=디폴트 인수에서 프로퍼티 액세스는 던질 수 있지만 오류는 던질 수 없습니다
syntax.error.property.can.throw.in.property.initializer=프로퍼티 이니셜라이저에서 프로퍼티 액세스는 던질 수 있지만 오류는 던질 수 없습니다
syntax.error.property.can.throw.not.marked.with.try=프로퍼티 액세스는 던질 수 있지만 'try'로 표시되지 않습니다
syntax.error.property.can.throw.not.marked.with.try.not.exhaustive=프로퍼티 액세스는 던질 수 있지만 'try'로 표시되지 않으며 둘러싼 catch가 완전하지 않습니다
syntax.error.property.can.throw.not.marked.with.try.not.handled=프로퍼티 액세스는 던질 수 있지만 'try'로 표시되지 않으며 오류가 처리되지 않습니다
syntax.error.property.rethrows.function.can.only.throw.parameter.call.not.handled=프로퍼티 액세스는 던질 수 있지만 오류는 처리되지 않습니다. 'rethrows'로 선언된 함수는 해당 매개변수가 던질 경우에만 던집니다
syntax.error.property.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=프로퍼티 액세스는 던질 수 있지만 'try'로 표시되지 않으며 오류가 처리되지 않습니다. 'rethrows'로 선언된 함수는 해당 매개변수가 던질 경우에만 던집니다
syntax.error.rethrows.function.can.only.throw.parameter.call=''rethrows''로 선언된 함수는 해당 매개변수가 던질 경우에만 던집니다.
syntax.error.rethrows.function.must.take.a.throwing.function.argument=''rethrows'' 함수에는 던지는 함수 인수가 있어야 합니다.
syntax.error.rethrows.is.not.allowed.in.closures=클로저에서는 ''rethrows''가 허용되지 않습니다.
syntax.error.rethrows.is.not.allowed.in.function.type.elements=함수 선언만 ''rethrows''로 표시될 수 있습니다
syntax.error.rethrows.is.not.allowed.in.subscripts=하위 스크립트에서는 ''rethrows''가 허용되지 않습니다.
syntax.error.subscript.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=서브스크립트 액세스는 던질 수 있지만 던지지 않는 autoclosure에서 실행됩니다
syntax.error.subscript.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=서브스크립트 액세스는 던질 수 있지만 'try'로 표시되지 않으며 던지지 않는 autoclosure에서 실행됩니다
syntax.error.subscript.can.throw.in.default.argument=디폴트 인수에서 서브스크립트 액세스는 던질 수 있지만 오류는 던질 수 없습니다
syntax.error.subscript.can.throw.in.property.initializer=프로퍼티 이니셜라이저에서 서브스크립트 액세스는 던질 수 있지만 오류는 던질 수 없습니다
syntax.error.subscript.can.throw.not.marked.with.try=서브스크립트 액세스는 던질 수 있지만 'try'로 표시되지 않습니다
syntax.error.subscript.can.throw.not.marked.with.try.not.exhaustive=서브스크립트 액세스는 던질 수 있지만 'try'로 표시되지 않으며 둘러싼 catch가 완전하지 않습니다
syntax.error.subscript.can.throw.not.marked.with.try.not.handled=서브스크립트 액세스는 던질 수 있지만 'try'로 표시되지 않으며 오류가 처리되지 않습니다
syntax.error.subscript.rethrows.function.can.only.throw.parameter.call.not.handled=서브스크립트 액세스는 던질 수 있지만 오류는 처리되지 않습니다. 'rethrows'로 선언된 함수는 해당 매개변수가 던질 경우에만 던집니다
syntax.error.subscript.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=서브스크립트 액세스는 던질 수 있지만 'try'로 표시되지 않으며 오류가 처리되지 않습니다. 'rethrows'로 선언된 함수는 해당 매개변수가 던질 경우에만 던집니다
syntax.error.thrown.expression.type.0.does.not.conform.to.ErrorType=던져진 표현식 유형 ''{0}''이(가) ''{1}''을(를) 준수하지 않습니다.
syntax.error.throws.is.not.allowed.in.subscripts=하위 스크립트에서는 ''throws''가 허용되지 않습니다.
syntax.error.try.cannot.appear.to.the.right=''try''는 대입되지 않은 연산자의 오른쪽에 표시될 수 없습니다.
syntax.error.try.cannot.appear.to.the.right.fix=''try''를 왼쪽으로 이동
syntax.error.typealias.without.assignment=유형 별칭 선언에서 대입이 누락되어 있습니다.
syntax.error.unrecognized.platform.name.0=인지되지 않은 플랫폼 이름 ''{0}''
syntax.error.variable.declaration.with.multiple.variables.cannot.have.explicit.getters.setters=여러 변수를 가진 ''var'' 선언에는 명시적 getter/setter를 사용할 수 없습니다
syntax.error.variable.declaration.with.multiple.variables.cannot.have.implicit.getter.clause=여러 변수를 가진 ''var'' 선언에는 묵시적 getter 절을 사용할 수 없습니다
syntax.error.variable.declaration.with.multiple.variables.cannot.have.willset.didset.clause=여러 변수를 가진 ''var'' 선언에는 willSet/didSet 절을 사용할 수 없습니다.
usage.type.argument.label=인수 라벨
usage.type.conditionally.not.compiled=조건부로 컴파일링되지 않은 코드 내의 잠재적인 사용 위치
usage.type.extension=확장
usage.type.function.declaration=함수 선언
usage.type.key.path=키 경로 표현식
usage.type.operator.declaration=연산자 선언
usage.type.precedence.group.declaration=우선순위 그룹 선언
usage.type.raw.value=원시 값
usage.type.requirement=요구 사항 내 사용 위치
usage.type.type.alias=유형 별칭
usage.type.type.parameter=유형 매개변수
