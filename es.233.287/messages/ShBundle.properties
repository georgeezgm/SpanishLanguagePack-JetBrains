0.is.true.use.false.instead='[ 0 ]'은 true입니다. 대신 'false'를 사용하세요.
action.ShGenerateForLoop.description=for 루프 생성
action.ShGenerateForLoop.text=for 루프
action.ShGenerateUntilLoop.description=until 루프 생성
action.ShGenerateUntilLoop.text=until 루프
action.ShGenerateWhileLoop.description=while 루프 생성
action.ShGenerateWhileLoop.text=while 루프
action.runShellFileAction.description=터미널에서 현재 셸 파일 실행
action.runShellFileAction.text=파일 실행
add.dev.null.to.prevent.ssh.from.swallowing.stdin=ssh가 표준 입력을 읽지 않도록 '< /dev/null'을 추가하세요.
aliases.can.t.use.positional.parameters.use.a.function=별칭은 위치 매개변수를 사용할 수 없습니다. 함수를 사용하세요.
argument.mixes.string.and.array.use.or.separate.argument=인수에 문자열과 배열이 혼재되어 있습니다. '*' 또는 별도의 인수를 사용하세요.
argument.to.implicit.n.is.always.true.due.to.literal.strings=묵시적 '-n'에 대한 인수는 리터럴 문자열로 인해 항상 true입니다.
arrays.don.t.work.as.operands.in.use.a.loop.or.concatenate.with.instead.of=배열은 '[ ]' 안에서 피연산자로 작동하지 않습니다. 루프를 사용하세요(또는 '@'이 아닌 '*'로 연결하세요).
arrays.implicitly.concatenate.in.use.a.loop.or.explicit.instead.of=배열이 `[[ ]]`에서 묵시적으로 연결됩니다. 루프(또는 '@' 대신 명시적 '*')를 사용하세요.
ash.scripts.will.be.checked.as.dash.add.shellcheck.shell.dash.to.silence=Ash 스크립트는 Dash로서 확인됩니다. 경고를 표시하지 않으려면 '# shellcheck shell=dash'를 추가하세요.
assigning.an.array.to.a.string.assign.as.array.or.use.instead.of.to.concatenate=배열을 문자열에 대입하고 있습니다! 배열로서 대입하거나 '@' 대신 '*'를 사용하여 연결하세요.
bash.does.not.support.multidimensional.arrays.use.1d.or.associative.arrays=Bash는 다차원 배열을 지원하지 않습니다. 1차원 또는 연관 배열을 사용하세요.
bash.doesn.t.support.variables.in.brace.range.expansions=Bash는 중괄호 범위 확장에서 변수를 지원하지 않습니다.
bin.sh.was.specified.so.is.not.supported.even.when.sh.is.actually.bash='#!/bin/sh'가 지정되었으므로 sh가 실제로 bash인 경우에도 ____는 지원되지 않습니다.
brace.expansion.doesn.t.happen.in.use.a.loop=중괄호 확장은 '[[ ]]'에서 발생하지 않습니다. 루프를 사용하세요.
brace.expansions.and.globs.are.literal.in.assignments.quote.it.or.use.an.array=중괄호 확장 및 glob는 대입에서 리터럴입니다. 따옴표 또는 배열을 사용하세요.
brace.expansions.don.t.work.as.operands.in.use.a.loop=중괄호 확장은 '[ ]' 안에서 피연산자로 작동하지 않습니다. 루프를 사용하세요.
break.is.only.valid.in.loops='break'는 루프에서만 유효합니다.
can.only.exit.with.status.0.255.other.data.should.be.written.to.stdout.stderr=0~255 상태에서만 종료할 수 있습니다. 다른 데이터는 표준 출력/표준 오류로 작성해야 합니다.
can.only.return.0.255.other.data.should.be.written.to.stdout=0~255만 반환할 수 있습니다. 다른 데이터는 표준 출력으로 작성해야 합니다.
can.t.match.globs.use.or.grep='[ .. ]'는 glob에 대응하지 않습니다. '[[ .. ]]'또는 grep을 사용하세요.
can.t.use.in.use.instead='[ ]'에서 '=~'를 사용할 수 없습니다. 대신 '[[..]]'를 사용하세요.
can.t.use.sudo.with.builtins.like.cd.did.you.want.sudo.sh.c.instead='cd'와 같은 기본 제공 기능과 함께 'sudo'를 사용할 수 없습니다. 대신 'sudo sh -c'를 사용하세요.
check.1008.this.shebang.was.unrecognized.shellcheck.only.supports.sh.bash.dash.ksh.add.a.shell.directive.to.specify=이 shebang은 인식되지 않았습니다. ShellCheck은 sh/bash/dash/ksh만 지원합니다. 지정할 'shell' 지시문을 추가하세요.
check.1009.the.mentioned.parser.error.was.in=언급된 파서 오류는 …에 있습니다
check.1010.use.semicolon.or.linefeed.before.done.or.quote.to.make.it.literal='done' 앞에 세미콜론 또는 라인피드를 사용하세요(또는 따옴표를 사용하여 리터럴로 만드세요).
check.1011.this.apostrophe.terminated.the.single.quoted.string=이 아포스트로피가 작은따옴표로 묶인 문자열을 종료했습니다!
check.1012.is.just.literal.t.here.for.tab.use.printf.instead=`\t`는 여기에서 단순히 리터럴 `t`입니다. 탭을 추가하려면 대신 '$(printf ' ')'를 사용하세요.
check.1014.use.if.cmd.then.to.check.exit.code.or.if.cmd.to.check.output='if cmd; then ...'을 사용하여 종료 코드를 확인하거나 'if [ "$(cmd)" = .. ]'를 사용하여 출력을 확인하세요.
check.1015.this.is.a.unicode.double.quote.delete.and.retype.it=이것은 유니코드 큰따옴표입니다. 삭제하고 다시 입력하세요.
check.1016.this.is.a.unicode.single.quote.delete.and.retype.it=이것은 유니코드 작은따옴표입니다. 삭제하고 다시 입력하세요.
check.1017.literal.carriage.return.run.script.through.tr.d=리터럴 캐리지 리턴입니다. ''tr -d ''\n''''를 통해 스크립트를 실행하세요.
check.1018.this.is.a.unicode.non.breaking.space.delete.it.and.retype.as.space=이것은 유니코드 비 분리 공백입니다. 삭제하고 스페이스 키로 다시 입력하세요.
check.1019.expected.this.to.be.an.argument.to.the.unary.condition=이것은 단항 조건의 인수여야 합니다.
check.1020.you.need.a.space.before.the.if.single.then.else=']' 또는 ']]' 앞에 공백 추가
check.1026.if.grouping.expressions.inside.use=[[..]] 내 표현식을 그룹화하려는 경우 ( .. )를 사용하세요.
check.1028.in.you.have.to.escape.or.preferably.combine.expressions=[..]에서 \\(\\)를 이스케이프하거나 되도록 [..] 표현식을 결합해야 합니다.
check.1029.in.you.shouldn.t.escape.or='[[..]]'에서 '(' 또는 ')'를 이스케이프하면 안 됩니다.
check.1035.you.need.a.space.here=여기에 공백을 추가합니다.
check.1036.is.invalid.here.did.you.forget.to.escape.it='('는 여기에서 올바르지 않습니다. 이스케이프하는 것을 잊으셨나요?
check.1037.braces.are.required.for.positionals.over.9.e.g.10=9가 넘는 위치(예: 10)에는 중괄호가 필요합니다.
check.1038.shells.are.space.sensitive.use.cmd.not.cmd=셸은 공백을 구분합니다. '< <(cmd)'가 아닌 '<<(cmd)'를 사용하세요.
check.1039.remove.indentation.before.end.token.or.use.and.indent.with.tabs=종료 토큰 앞의 들여쓰기를 제거하세요(또는'<<-'를 사용하고 탭으로 들여쓰기).
check.1040.when.using.you.can.only.indent.with.tabs=<<- 사용 시 탭으로만 들여쓰기하세요.
check.1041.found.eof.further.down.but.not.on.a.separate.line=더 아래에서 'eof'를 찾았지만 별도의 줄에는 없습니다.
check.1042.found.eof.further.down.but.not.on.a.separate.line=더 아래에서 'eof'를 찾았지만 별도의 줄에는 없습니다.
check.1044.couldn.t.find.end.token.eof.in.the.here.document=here 문서에서 종료 토큰 'EOF'를 찾을 수 없습니다.
check.1045.expected.then='then'이 필요합니다.
check.1045.it.s.not.foo.bar.just.foo.bar='foo \\&; bar' 내 불필요한 세미콜론이 있습니다. 'foo \\& bar'여야 합니다.
check.1046.couldn.t.find.fi.for.this.if=이 'if'에 대한 'fi'를 찾을 수 없습니다.
check.1047.expected.fi.matching.previously.mentioned.if=이전에 언급된 'if'에 대응하는 'fi'가 필요합니다.
check.1048.can.t.have.empty.then.clauses.use.true.as.a.no.op=then 절을 비워두면 안 됩니다( 'true'를 no-op로 사용).
check.1049.did.you.forget.the.then.for.this.if=이 'if'에 대해 'then'을 지정하는 것을 잊으셨나요?
check.1051.semicolons.directly.after.then.are.not.allowed.just.remove.it='then' 바로 뒤에 오는 세미콜론은 허용되지 않습니다.
check.1052.semicolons.directly.after.then.are.not.allowed.just.remove.it='then' 바로 뒤에 오는 세미콜론은 허용되지 않습니다.
check.1053.semicolons.directly.after.else.are.not.allowed.just.remove.it='else' 바로 뒤에 오는 세미콜론은 허용되지 않습니다.
check.1054.you.need.a.space.after.the='{' 뒤에 공백을 추가하세요.
check.1058.expected.do='do'가 필요합니다.
check.1061.couldn.t.find.done.for.this.do=이 'do'에 대한 'done'을 찾을 수 없습니다.
check.1062.expected.done.matching.previously.mentioned.do=이전에 언급된 'do'에 대응하는 'done'이 필요합니다.
check.1064.expected.a.to.open.the.function.definition=함수 정의를 여는 '{'가 필요합니다.
check.1065.trying.to.declare.parameters.don.t.use.and.refer.to.params.as.1.2=매개변수를 선언하면  안 됩니다. ()를 사용하고 $1, $2 등으로 매개변수를 참조하세요.
check.1066.don.t.use.on.the.left.side.of.assignments=대입의 왼쪽에 '$'를 사용하면 안 됩니다.
check.1068.don.t.put.spaces.around.the.in.assignments=대입 내 '=' 주위에 공백을 두면 안 됩니다.
check.1069.you.need.a.space.before.the='[' 앞에 공백을 추가합니다.
check.1071.shellcheck.only.supports.sh.bash.dash.ksh.scripts.sorry=ShellCheck은 sh/bash/dash/ksh 스크립트만 지원합니다.
check.1072.unexpected=예기치 않은 항목 ..
check.1073.couldn.t.parse.this.thing.fix.to.allow.more.checks=이 항목을 분석할 수 없습니다. 검사를 더 진행하려면 수정하세요.
check.1075.use.elif.instead.of.else.if='else if' 대신 'elif'를 사용하세요.
check.1077.for.command.expansion.the.tick.should.slant.left.vs=명령어를 확장하려면 백틱을 사용하세요. (` vs ´)
check.1078.did.you.forget.to.close.this.double.quoted.string=이 큰따옴표가 붙은 문자열을 닫는 것을 잊으셨나요?
check.1079.this.is.actually.an.end.quote.but.due.to.next.char.it.looks.suspect=이것은 종료 따옴표이지만 그 다음 문자 때문에 의심스러워 보입니다.
check.1081.scripts.are.case.sensitive.use.if.not.if=스크립트는 대소문자를 구분합니다. 'If'가 아닌 'if'를 사용하세요.
check.1082.this.file.has.a.utf.8.bom.remove.it.with.lc.ctype.c.sed.1s.yourscript=이 파일은 UTF-8 BOM을 포함합니다. 다음 명령어를 사용해 제거하세요. LC_CTYPE=C sed '1s/^...//' < yourscript
check.1083.this.is.literal.check.expression.missing.or.quote.it='{`/`}'는 리터럴입니다. ';'이 빠졌는지 확인하거나 표현식을 인용하세요.
check.1084.use.not.for.the.shebang=shebang이 '!#'이 아닌 '#!'입니다.
check.1086.don.t.use.on.the.iterator.name.in.for.loops=for 루프 내 반복자 이름에 '$'를 사용하면 안 됩니다.
check.1087.use.braces.when.expanding.arrays.e.g.array.idx.or.var.to.quiet=배열 확장 시 ${array[idx]}와 같이 중괄호를 사용하세요(또는 경고를 표시하지 않도록 ${var}[..를 사용하세요).
check.1088.parsing.stopped.here.invalid.use.of.parentheses=분석이 여기에서 중지되었습니다. 소괄호가 잘못 사용되었나요?
check.1089.parsing.stopped.here.is.this.keyword.correctly.matched.up=분석이 여기에서 중지되었습니다. 이 키워드가 올바르게 일치되나요?
check.1090.can.t.follow.non.constant.source.use.a.directive.to.specify.location=상수가 아닌 소스는 따를 수 없습니다. 지시문을 사용하여 위치를 지정하세요.
check.1091.not.following.error.message.here=따를 수 없습니다. (여기에 오류 메시지)
check.1094.parsing.of.sourced.file.failed.ignoring.it=소스로 참조된 파일을 분석하지 못했습니다. 해당 파일을 무시합니다.
check.1095.you.need.a.space.or.linefeed.between.the.function.name.and.body=함수 이름과 본문 사이에 공백이나 라인피드가 필요합니다.
check.1097.unexpected.for.assignment.use.for.comparison.use=예기치 않은 '=='입니다. 대입하려면 '='를 사용하세요. 비교하려면 '==' 표현식을 대괄호로 묶으세요.
check.1098.quote.escape.special.characters.when.using.eval.e.g.eval.a.b=eval 사용 시 특수 문자를 따옴표로 묶거나 이스케이프하세요(예: eval "a=(b)").
check.1099.you.need.a.space.before.the='#' 앞에 공백을 추가합니다.
check.1100.this.is.a.unicode.dash.delete.and.retype.as.ascii.minus=이것은 유니코드 대시입니다. 삭제하고 ASCII 마이너스 문자로 다시 입력하세요.
check.1101.delete.trailing.spaces.after.to.break.line.or.use.quotes.for.literal.space=\\ 뒤의 후행 공백을 삭제하여 줄을 바꾸세요(또는 리터럴 공백에 따옴표 사용하세요).
check.1102.shells.disambiguate.differently.or.not.at.all.if.the.first.should.start.command.substitution.add.a.space.after.it=셸이 $((를 다르게 명확히 하거나 전혀 명확히 하고 있지 않습니다. 첫 번째 $(가 명령어 대체를 시작해야 하는 경우 그 뒤에 공백을 추가하세요.
check.1104.use.not.just.for.the.shebang=shebang이 '!'가 아닌 '#!'입니다.
check.1105.shells.disambiguate.differently.or.not.at.all.if.the.first.should.start.a.subshell.add.a.space.after.it=셸이 ((를 다르게 명확히 하거나 전혀 명확히 하고 있지 않습니다. 첫 번째 (가 하위 셸을 시작해야 하는 경우 그 뒤에 공백을 추가하세요.
check.1107.this.directive.is.unknown.it.will.be.ignored=이 지시문은 알 수 없습니다. 무시됩니다.
check.1108.you.need.a.space.before.and.after.the='=' 앞뒤에 공백을 추가하세요.
check.1109.this.is.an.unquoted.html.entity.replace.with.corresponding.character=이것은 따옴표로 묶이지 않은 HTML 엔티티입니다. 해당하는 문자로 바꾸세요.
check.1110.this.is.a.unicode.quote.delete.and.retype.it.or.quote.to.make.literal=이것은 유니코드 따옴표입니다. 삭제하고 다시 입력하세요(또는 따옴표를 사용하여 리터럴로 만드세요).
check.1111.this.is.a.unicode.quote.delete.and.retype.it.or.ignore.singlequote.for.literal=이것은 유니코드 따옴표입니다. 삭제하고 다시 입력하세요(또는 작은따옴표를 사용하여 리터럴로 만드세요).
check.1112.this.is.a.unicode.quote.delete.and.retype.it.or.ignore.doublequote.for.literal=이것은 유니코드 따옴표입니다. 삭제하고 다시 입력하세요(또는 큰따옴표를 사용하여 리터럴로 만드세요).
check.1113.use.not.just.for.the.sheban=shebang이 '#'이 아닌 '#!'입니다.
check.1114.remove.leading.spaces.before.the.shebang=shebang 앞의 선행 공백을 제거하세요.
check.1115.remove.spaces.between.and.in.the.shebang=shebang에서 '#'과 '!' 사이의 공백을 제거하세요.
check.1116.missing.on.a.expression.or.use.for.arrays='$((..))' 식에 '$'가 누락되었나요? 배열인 경우, '( ('를 사용하세요.
check.1117.backslash.is.literal.in.prefer.explicit.escaping.n=백슬래시는 " " 내 리터럴입니다.\n명시적으로 이스케이프하는 것이 좋습니다. "\\n"
check.1118.delete.whitespace.after.the.here.doc.end.token=here 문서 종료 토큰 뒤의 공백을 삭제하세요.
check.1119.add.a.linefeed.between.end.token.and.terminating=종료 토큰과 종료하는 ')' 사이에 라인피드를 추가하세요.
check.1120.no.comments.allowed.after.here.doc.token.comment.the.next.line.instead=문서 토큰 뒤에 주석은 허용되지 않습니다. 대신 다음 줄에 주석을 추가하세요.
check.1121.add.terminators.and.other.syntax.on.the.line.with.the.not.here=여기가 아닌 '<<'가 있는 줄에 ;/\\& 종료자(및 기타 구문)를 추가하세요.
check.1122.nothing.allowed.after.end.token.to.continue.a.command.put.it.on.the.line.with.the=종료 토큰 뒤에는 아무것도 허용되지 않습니다. 명령어를 계속 작성하려면 '<<'가 있는 줄에 입력하세요.
check.1123.shellcheck.directives.are.only.valid.in.front.of.complete.compound.commands.like.if.not.e.g.individual.elif.branches=ShellCheck 지시문은 개별 `elif` 브랜치가 아닌 `if`와 같은 완전한 복합 명령어 앞에서만 유효합니다.
check.1124.shellcheck.directives.are.only.valid.in.front.of.complete.commands.like.case.statements.not.individual.case.branches=ShellCheck 지시문은 개별 case 브랜치가 아닌 'case' 문과 같은 완전한 명령어 앞에만 유효합니다.
check.1126.place.shellcheck.directives.before.commands.not.after=ShellCheck 지시문을 명령어 뒤가 아닌 앞에 배치하세요.
check.1127.was.this.intended.as.a.comment.use.in.sh=주석인 경우, `#`을 사용하세요.
check.1128.the.shebang.must.be.on.the.first.line.delete.blanks.and.move.comments=shebang은 첫 번째 줄에 있어야 합니다. 공백을 삭제하고 주석을 이동하세요.
check.1129.you.need.a.space.before.the='!' 앞에 공백을 추가합니다.
check.1130.you.need.a.space.before.the=':' 앞에 공백을 추가합니다.
check.1131.use.elif.to.start.another.branch=다른 브랜치를 시작하려면 'elif'를 사용하세요.
check.exit.code.directly.with.e.g.if.mycmd.not.indirectly.with='$'?로 종료 코드를 간접적으로 검사하지 않고 'if mycmd;'으로 직접 검사하세요.
check1000.is.not.used.specially.and.should.therefore.be.escaped=$는 이스케이프되어야 합니다.
check1001.this.o.will.be.a.regular.o.in.this.context=이 \\o는 이 컨텍스트에서 일반적인 'o'입니다.
check1003.want.to.escape.a.single.quote.echo.this.is.how.it.s.done=작은따옴표를 이스케이프하시겠어요? 'This is how it'\'s done'이 echo로 출력됩니다.
check1004.this.backslash.linefeed.is.literal.break.outside.single.quotes.if.you.just.want.to.break.the.line=이 백슬래시+라인피드는 리터럴입니다. 줄을 바꾸려면 작은따옴표 바깥에서 바꾸세요.
check1007.remove.space.after.if.trying.to.assign.a.value.or.for.empty.string.use.var='=' 뒤의 공백을 제거하여 값을 대입하세요(또는 var='...을 사용하여 빈 문자열을 입력하세요).
consider.adding.a.default.case.even.if.it.just.exits.with.error=오류와 함께 종료되더라도 디폴트 '*)' case를 추가하는 것이 좋습니다.
consider.using.cmd1.cmd2.file.instead.of.individual.redirects=개별 리디렉션 대신 '{ cmd1; cmd2; } >> file'을 사용해 보세요.
consider.using.grep.c.instead.of.grep.wc='grep|wc' 대신 'grep -c'를 사용해 보세요.
d.only.applies.to.the.first.expansion.of.this.glob.use.a.loop.to.check.any.all='-d'는 이 glob의 첫 번째 확장에만 적용됩니다. 루프를 사용하여 모든 것을 확인하세요.
decimals.are.not.supported.either.use.integers.only.or.use.bc.or.awk.to.compare=소수는 지원되지 않습니다. 정수만 사용하거나 'bc' 또는 'awk'를 사용하여 비교하세요.
declare.and.assign.separately.to.avoid.masking.return.values=반환 값을 마스킹하지 않으려면 별도로 선언하고 대입하세요.
did.you.mean.ifs=IFS=$'\t'를의도하셨나요?
display.name.shell.check=ShellCheck
doesn.t.support.decimals.use.bc.or.awk='(( ))'는 소수를 지원하지 않습니다. 'bc' 또는 'awk'를 사용하세요.
don.t.quote.rhs.of.it.ll.match.literally.rather.than.as.a.regex==~의 rhs를 따옴표로 묶으면 안 됩니다. 정규식이 아닌 문자 그대로 대응합니다.
don.t.use.around.ranges.in.tr.it.replaces.literal.square.brackets='tr'의 범위 주위에 '[]'를 사용하면 안 됩니다. 해당 괄호가 리터럴 대괄호를 대체합니다.
don.t.use.ls.grep.use.a.glob.or.a.for.loop.with.a.condition.to.allow.non.alphanumeric.filenames='ls | grep'을 사용하면 안 됩니다. 비 영숫자 파일 이름을 허용하는 조건을 가진 glob 또는 for 루프를 사용하세요.
don.t.use.variables.in.the.printf.format.string.use.printf.s.foo=printf 형식 문자열에 변수를 사용하면 안 됩니다. 대신 다음 구문을 사용하세요. printf "..%s.." "$foo"
double.quote.array.expansions.to.avoid.re.splitting.elements=요소 재분할을 방지하려면 배열 확장을 큰따옴표로 묶으세요.
double.quote.to.prevent.globbing.and.word.splitting=글로빙 및 단어 분할을 방지하려면 큰따옴표를 사용하세요.
e.doesn.t.work.with.globs.use.a.for.loop='-e'는 glob와 작동하지 않습니다. for 루프를 사용하세요.
echo.doesn.t.read.from.stdin.are.you.sure.you.should.be.piping.to.it='echo'는 표준 입력에서 읽지 않습니다. 파이핑하는 것은 권장되지 않습니다.
echo.won.t.expand.escape.sequences.consider.printf='echo'는 이스케이프 시퀀스를 확장하지 않습니다. 'printf'를 고려해 보세요.
egrep.is.non.standard.and.deprecated.use.grep.e.instead=egrep은 비표준이며 더 이상 사용되지 않습니다. 대신 grep -E를 사용하세요.
elements.in.associative.arrays.need.index.e.g.array.index.value=연관 배열의 요소에는 색인이 필요합니다(예: array=( [index]=value ).
ensure.the.shebang.uses.the.absolute.path.to.the.interpreter=shebang이 인터프리터의 절대 경로를 지정하는지 확인하세요.
eq.is.for.integer.comparisons.use.instead='-eq'는 정수 비교에 사용됩니다. 대신 '='를 사용하세요.
error.message.can.t.find.info.in.your.path=$PATH 변수에서 정보를 찾을 수 없습니다.
error.message.cannot.determine.shell.script.parent.directory=셸 스크립트 상위 디렉터리를 확인할 수 없습니다
exec.does.not.automatically.invoke.a.shell.use.exec.sh.c.for.that='-exec'는 셸을 자동으로 호출하지 않습니다. 자동 호출하려면 '-exec sh -c'를 사용하세요.
expanding.an.array.without.an.index.only.gives.the.first.element=색인 없이 배열을 확장하면 첫 번째 요소만 제공됩니다.
expr.is.antiquated.consider.rewriting.this.using.or='expr'은 구식입니다. '$((..))', '${}' 또는 '\\[\\[\\]\\]'를 사용하여 다시 작성하세요.
expressions.don.t.expand.in.single.quotes.use.double.quotes.for.that=표현식은 작은따옴표로 확장되지 않습니다. 확장하려면 큰따옴표를 사용하세요.
false.is.true.remove.the.brackets='[ false ]'는 true입니다. 대괄호를 제거하세요.
fgrep.is.non.standard.and.deprecated.use.grep.f.instead=fgrep은 비표준이며 더 이상 사용되지 않습니다. 대신 grep -F를 사용하세요.
filetype.sh.shell.script.description=셸 스크립트
find.usages.type.function=함수
flip.leading.and.if.this.should.be.a.quoted.substitution=이것이 따옴표로 묶인 대체여야 하는 경우 선행하는 '$'와 ""를 반전시키세요.
foo.appears.unused.verify.it.or.export.it='foo'는 사용되지 않는 것으로 보입니다. 확인하거나 내보내세요.
foo.references.arguments.but.none.are.ever.passed='foo'는 인수를 참조하지만 아무것도 전달되지 않습니다.
for.loops.over.find.output.are.fragile.use.find.exec.or.a.while.read.loop=find 출력에 대한 for 루프는 불안정합니다. 'find -exec' 또는 while read 루프를 사용하세요.
function.keyword.is.non.standard.delete.it='function' 키워드는 표준이 아닙니다. 삭제하세요.
getopts.specified.n.but.it.s.not.handled.by.this.case='getopts'에 '-n'이 지정되어 있으나 이 'case'로 처리되지 않습니다.
globs.are.ignored.in.except.right.of.use.a.loop='=', '!='의 오른쪽을 제외하고 `[[ ]]` 안의 glob는 무시됩니다. 루프를 사용하세요.
globs.don.t.work.as.operands.in.use.a.loop=glob는 '[ ]' 안에서 피연산자로 작동하지 않습니다. 루프를 사용하세요.
grep.uses.regex.but.this.looks.like.a.glob=grep은 정규식을 사용하지만 이것은 glob처럼 보입니다.
i.do.mind.path.placeholder=신경 쓰임
if.you.wanted.to.assign.the.output.of.the.pipeline.use.a.b.c=파이프라인의 출력을 대입하려면 'a=$(b | c)'를 사용하세요.
in.dash.something.is.not.supported=이 기능은 dash에서 지원되지 않습니다
in.functions.use.return.instead.of.break=함수에서는 'break' 대신 'return'을 사용하세요.
in.posix.sh.something.is.undefined=POSIX sh에서 정의되지 않은 항목이 있습니다.
in.use.instead.of.a='[\\[..]]'에서 '-a' 대신 '\\&\\&'를 사용하세요.
in.use.instead.of.o='[\\[..]]'에서 '-o' 대신 '||'를 사용하세요.
increase.precision.by.replacing.a.b.c.with.a.c.b='a/b\\*c'를 'a\\*c/b'로 바꿔서 정밀도를 높이세요.
injecting.filenames.is.fragile.and.insecure.use.parameters=파일 이름을 삽입하는 것은 불안정하고 안전하지 않습니다. 매개변수를 사용하세요.
instead.of.1.use.true='[ 1 ]' 대신 'true'를 사용하세요.
instead.of.a.b.use.a.b='[ a || b ]' 대신 '[ a ] || [ b ]'를 사용하세요.
instead.of.a.b.use.a.b2='[ a \\&\\& b ]' 대신 '[ a ] \\&\\& [ b ]'를 사용하세요.
instead.of.let.expr.prefer.expr='let expr' 대신 '(( expr ))'를 사용하는 것이 좋습니다.
instead.of.true.just.use.true='[ true ]' 대신 'true'를 사용하세요.
intention.shell.script=셸 스크립트
invalid.flags.are.not.handled.add.a.case=잘못된 플래그는 처리되지 않습니다. '*)' case를 추가하세요.
is.a.subshell.did.you.mean.a.test.expression='(..)'는 하위 셸입니다. 테스트 표현식인 '[ .. ]'를 의도하셨나요?
is.for.regex.but.this.looks.like.a.glob.use.instead='=~'는 정규식에 사용되지만 glob처럼 보입니다. 대신 '='를 사용하세요.
is.for.string.comparisons.use.gt.instead='>'는 문자열 비교에 사용됩니다. 대신 '-gt'를 사용하세요.
is.not.a.valid.operator.use.a.b.instead='>='는 올바른 연산자가 아닙니다. 대신 '! a < b'를 사용하세요.
is.unnecessary.on.arithmetic.variables='$' 및 '${}'는 산술 변수에 불필요합니다.
iterating.over.ls.output.is.fragile.use.globs=ls 출력을 반복하는 것은 불안정합니다. glob을 사용하세요.
line.marker.run.0={0} 실행
literal.tilde.in.path.works.poorly.across.programs=PATH의 리터럴 물결표는 프로그램 전반에서 제대로 작동하지 않습니다.
local.is.only.valid.in.functions='local'은 함수에서만 유효합니다.
make.sure.all.escape.sequences.are.enclosed.in.to.prevent.line.wrapping.issues=래핑 문제를 방지하기 위해 모든 이스케이프 시퀀스가 '\\[..\\]'로 묶여 있는지 확인하세요
missing.or.terminating.exec.you.can.t.use.and.has.to.be.a.separate.quoted.argument='-exec'를 종료하는 ';' 또는 '+'가 누락되었습니다. |/||/\\&\\&를 사용하지 말고 ';'에는 따옴표를 사용하세요.
modification.of.var.is.local.to.subshell.caused.by.pipeline='var' 수정은 (파이프라인으로 생긴 하위 셸로) 국한됩니다.
n.doesn.t.work.with.unquoted.arguments.quote.or.use=''-n''은 따옴표로 묶이지 않은 인수와 함께 작동하지 않습니다. 따옴표로 묶거나 ''''[[ ]]''''를 사용하세요.
named.class.needs.outer.e.g.digit=명명된 클래스에는 바깥에 '[]'가 필요합니다(예: [[:digit:]\\])
note.that.a.b.c.is.not.if.then.else.c.may.run.when.a.is.true='A \\&\\& B || C'는 'if-then-else'가 아닙니다. C는 A가 true일 때 실행될 수 있습니다.
note.that.unescaped.this.expands.on.the.client.side=이것은 이스케이프되지 않으면 클라이언트 측에서 확장됩니다.
note.that.unlike.globs.o.here.matches.ooo.but.not.oscar=glob와 달리 'o*'는 여기에서 'ooo'와 일치하지만 'oscar'와는 일치하지 않습니다
notification.group.shell.script=셸 스크립트 도구 사용 가능
numbers.with.leading.0.are.considered.octal=앞에 0이 있는 숫자는 8진수로 간주됩니다.
numerical.eq.does.not.dereference.in.expand.or.use.string.operator=숫자 '-'eq는 [..]에서 역참조하지 않습니다. 문자열 연산자를 확장하거나 사용하세요.
on.most.os.shebangs.can.only.specify.a.single.parameter=대부분의 OS에서 shebang은 하나의 매개변수만 지정할 수 있습니다.
only.one.integer.0.255.can.be.returned.use.stdout.for.other.data=0~255의 정수 하나만 반환할 수 있습니다. 다른 데이터는 표준 출력을 사용하세요.
path.is.the.shell.search.path.use.another.name=PATH는 셸 검색 경로입니다. 다른 이름을 사용하세요.
piping.to.rm.a.command.that.doesn.t.read.stdin.wrong.command.or.missing.xargs=표준 입력을 읽지 않는 명령어인 'rm'으로 파이핑합니다. 명령어가 잘못되었거나 xargs가 누락되지 않았나요?
possible.misspelling.myvariable.may.not.be.assigned.but.my.variable.is=철자 오류 가능성: MYVARIABLE은 대입되지 않을 수 있지만 MY_VARIABLE은 대입됩니다.
prefer.explicit.n.to.check.for.output.or.run.command.without.to.check.for.success=출력을 확인하려면 명시적 '-n'을 사용하세요. 성공 여부를 검사하려면 '[' 및 '[[' 없이 명령어를 실행하세요.
prefer.explicit.n.to.check.non.empty.string.or.use.ne.to.check.boolean.integer=비어 있지 않은 문자열을 확인하려면 명시적 '-n'을 사용하세요. 부울 및 정수를 검사하려면 '=' 또는 '-ne'를 사용하세요.
prefer.mapfile.or.read.a.to.split.command.output.or.quote.to.avoid.splitting='mapfile' 또는 'read -a'를 사용하여 명령어 출력을 분할하세요(또는 따옴표를 사용하여 분할을 방지하세요).
prefer.p.q.as.p.a.q.is.not.well.defined='[ p -a q ]'는 명확하게 정의되어 있지 않으므로 '[ p ] \\&\\& [ q ]'를 사용하는 것이 좋습니다.
quote.arguments.to.unset.so.they.re.not.glob.expanded=glob 구문을 무시하려면 인수를 따옴표표 묶으세요.
quote.eof.to.make.here.document.expansions.happen.on.the.server.side.rather.than.on.the.client=here 문서가 클라이언트 측이 아닌 서버 측에서 확장되도록 하려면 'EOF' 주위에 따옴표를 추가하세요.
quote.expansions.in.this.for.loop.glob.to.prevent.wordsplitting.e.g.dir.txt=단어 분할을 방지하려면 for 루프 glob에서 확장을 따옴표로 묶으세요(예: "$dir"/*.txt).
quote.parameters.to.tr.to.prevent.glob.expansion=glob 확장을 방지하기 위해 'tr'에 대한 매개변수를 따옴표로 묶으세요.
quote.the.grep.pattern.so.the.shell.won.t.interpret.it=grep 패턴을 셸이 해석하지 않도록 따옴표로 묶으세요.
quote.the.parameter.to.name.so.the.shell.won.t.interpret.it='-name'에 대한 매개변수를 셸이 해석하지 않도록 따옴표로 묶으세요.
quote.the.rhs.of.in.to.prevent.glob.matching=glob 일치를 방지하려면 '[[ ]]'에서 'rhs of ='를 따옴표로 묶으세요.
quote.this.invalid.brace.expansion.since.it.should.be.passed.literally.to.eval=이 잘못된 괄호 확장은 그대로 eval에 전달되어야 하므로 따옴표로 묶으세요.
quote.this.to.prevent.word.splitting=단어 분할을 방지하려면 따옴표로 묶으세요.
quote.to.prevent.word.splitting.or.split.robustly.with.mapfile.or.read.a=단어 분할을 방지하기 위해 따옴표로 묶거나 'mapfile' 또는 'read -a'를 사용하여 확실히 분할하세요.
quotes.backslashes.in.this.variable.will.not.be.respected=이 변수의 따옴표 및 백슬래시는 고려되지 않습니다.
quotes.backslashes.will.be.treated.literally.use.an.array=따옴표 및 백슬래시는 문자 그대로 처리됩니다. 배열을 사용하세요.
ranges.can.only.match.single.chars.mentioned.due.to.duplicates=범위는 단일 문자(중복으로 인해 언급된)와만 대응합니다.
read.without.r.will.mangle.backslashes='-r' 없이 'read'를 사용하면 백슬래시가 불분명해집니다.
redirecting.to.echo.a.command.that.doesn.t.read.stdin.bad.quoting.or.missing.xargs=표준 입력을 읽지 않는 명령어인 'echo'로 리디렉션합니다. 따옴표 묶기가 잘못되었거나 xargs가 누락되지 않았나요?
redirecting.to.from.command.name.instead.of.file.did.you.want.pipes.xargs.or.quote.to.ignore=파일 대신 명령어 이름으로 또는 이름에서 리디렉션합니다. 파이프 또는 xargs를 대신 사용하세요(또는 따옴표로 묶어 무시하세요).
redirection.applies.to.the.find.command.itself.rewrite.to.work.per.action.or.move.to.end=리디렉션은 'find' 명령어 자체에 적용됩니다. 액션별로 작동하도록 다시 작성하세요(또는 끝으로 이동하세요).
remove.backticks.to.avoid.executing.output=출력을 실행하지 않으려면 백틱을 제거하세요.
remove.exec.if.script.should.continue.after.this.command=이 명령어 이후 스크립트가 계속되어야 하는 경우 'exec'를 제거하세요.
remove.for.numeric.index.or.escape.it.for.string=숫자 색인의 경우 '$' 및 '${}'를 제거하거나 문자열의 경우 이를 이스케이프하세요.
remove.or.use.expr.to.avoid.executing.output=출력을 실행하지 않으려면 '$'를 제거하거나 '_=$((expr))'를 사용하세요.
remove.superfluous.around.condition=조건 주위에 불필요한 '(..)'를 제거하세요.
remove.superfluous.around.test.command=테스트 명령어 주위에 불필요한 '(..)'를 제거하세요.
remove.surrounding.to.avoid.executing.output=출력을 실행하지 않으려면 둘러싸는 '$()'를 제거하세요.
sc2001.see.if.you.can.use.variable.search.replace.instead=SC2001: 대신 ${variable//search/replace}를 사용할 수 있는지 확인하세요.
sc2009.consider.using.pgrep.instead.of.grepping.ps.output=SC2009 ps 출력을 grep하는 대신 pgrep을 사용하는 것이 좋습니다.
sc2094.make.sure.not.to.read.and.write.the.same.file.in.the.same.pipeline=SC2094 동일한 파이프라인에서 동일한 파일을 읽고 쓰지 않도록 하세요.
sc2106.this.only.exits.the.subshell.caused.by.the.pipeline=SC2106: 파이프라인으로 발생한 하위 셸만 종료됩니다.
sh.code.style.binary.ops.like.and.may.start.a.line=이항 연산자 뒤 줄 바꿈 허용
sh.code.style.choose.path=Shfmt 경로 선택:
sh.code.style.download.link=Shfmt 서식 지정 도구 다운로드
sh.code.style.keep.column.alignment.padding=열 정렬 안쪽 여백 유지
sh.code.style.minify.program.to.reduce.its.size=크기를 줄이도록 프로그램 최소화
sh.code.style.redirect.operators.will.be.followed.by.a.space=리다이렉트 연산자 뒤 공백 추가
sh.code.style.switch.cases.will.be.indented=case 문 들여쓰기
sh.code.style.unix.line.separator=Unix 줄 구분 기호 사용(\\n)
sh.color.backquotes=역따옴표
sh.color.braces.curly.brackets=괄호//중괄호
sh.color.braces.parentheses=괄호//소괄호
sh.color.braces.square.brackets=괄호//대괄호
sh.color.commands.generic.command=명령어//제네릭 명령어
sh.color.commands.subshell.command=명령어//하위 셸 명령어
sh.color.conditional.operators=조건 연산자
sh.color.function.declaration=함수 선언
sh.color.here.documents=Here 문서
sh.color.here.documents.end=Here 문서 끝
sh.color.here.documents.start=Here 문서 시작
sh.color.keyword=키워드
sh.color.line.comment=줄 주석
sh.color.number=숫자
sh.color.raw.string=원시 문자열
sh.color.redirection=리디렉션
sh.color.shebang.comment=Shebang 주석
sh.color.string=문자열
sh.color.variables.composed.variable=변수//합성 변수
sh.color.variables.variable.declaration=변수//변수 선언
sh.color.variables.variable.usage=변수//변수 사용 위치
sh.disable.inspection.text=검사 {0} 비활성화
sh.download=다운로드
sh.explain.command.to.explain=설명할 명령어
sh.explain.inspection.text=셸 설명
sh.explain.message.nothing.to.explain=설명할 항목이 없음
sh.explain.title.nothing.to.explain=설명할 항목이 없음
sh.fmt.cannot.download=shfmt 서식 지정 도구를 다운로드할 수 없습니다. 수동으로 설치하세요.
sh.fmt.cannot.update=shfmt 서식 지정 도구를 업데이트할 수 없습니다. 이전 버전으로 롤백되었습니다.
sh.fmt.formatter=Shfmt 서식 지정 도구
sh.fmt.indent.label=들여쓰기
sh.fmt.install.question=셸 스크립트 서식 지정 도구를 설치하시겠어요?
sh.fmt.missing.formatter=누락된 서식 지정 도구
sh.fmt.success.install=셸 스크립트 서식 지정 도구가 성공적으로 설치되었습니다.
sh.fmt.success.update=셸 스크립트 서식 지정 도구가 성공적으로 업데이트되었습니다.
sh.fmt.update.question=셸 스크립트 서식 지정 도구를 업데이트하시겠어요?
sh.install=설치
sh.invalid.path=경로가 올바르지 않습니다.
sh.label.choose.interpreter=인터프리터 선택
sh.label.choose.script.working.directory=스크립트 작업 디렉터리 선택
sh.label.choose.shell.script=셸 스크립트 선택
sh.label.download.shfmt.formatter=shfmt 서식 지정 도구 다운로드
sh.livetemplate.description.array.add=배열 끝에 새 항목 추가
sh.livetemplate.description.array.all=모든 배열 요소
sh.livetemplate.description.array.at.index=색인의 요소
sh.livetemplate.description.array.create=배열 생성
sh.livetemplate.description.array.delete=배열 삭제
sh.livetemplate.description.array.delete.at=배열에서 삭제
sh.livetemplate.description.array.iteration=배열 반복 처리
sh.livetemplate.description.array.length=배열 길이
sh.livetemplate.description.array.set.element=색인의 배열 세트 요소
sh.livetemplate.description.case=Case 문
sh.livetemplate.description.cmd=명령어 대체
sh.livetemplate.description.cmd.success.check=Cmd 성공 확인
sh.livetemplate.description.command.exists=명령어가 있음
sh.livetemplate.description.curl=HTTP 요청
sh.livetemplate.description.directory.exists=디렉터리가 있습니다
sh.livetemplate.description.elif=Elif 식
sh.livetemplate.description.file.equals=다음과 동일한 파일
sh.livetemplate.description.file.executable=실행 가능한 파일
sh.livetemplate.description.file.exists=파일이 있습니다
sh.livetemplate.description.file.newer=다음보다 최신 파일
sh.livetemplate.description.file.not.empty=파일이 비어 있지 않음
sh.livetemplate.description.file.older=다음보다 오래된 파일
sh.livetemplate.description.file.readable=읽기 가능한 파일
sh.livetemplate.description.file.writable=쓰기 가능한 파일
sh.livetemplate.description.find=파일 또는 디렉터리 찾기
sh.livetemplate.description.for=색인에 의한 for 루프
sh.livetemplate.description.fori=목록 내 for 루프
sh.livetemplate.description.function=함수 정의
sh.livetemplate.description.git.branch.create=브랜치 생성
sh.livetemplate.description.git.commit=변경 내용 커밋
sh.livetemplate.description.git.push=브랜치를 원격으로 푸시
sh.livetemplate.description.heredoc=여러 줄 문자열
sh.livetemplate.description.if=If 문
sh.livetemplate.description.mkdir=디렉터리 생성
sh.livetemplate.description.number.equal=숫자가 동일합니다
sh.livetemplate.description.number.greater=다음보다 큰 숫자
sh.livetemplate.description.number.greater.or.equal=다음보다 크거나 같은 숫자
sh.livetemplate.description.number.less=다음보다 작은 숫자
sh.livetemplate.description.number.less.or.equal=다음보다 작거나 같은 숫자
sh.livetemplate.description.number.not.equal=숫자가 동일하지 않습니다
sh.livetemplate.description.path.exists=경로가 있음
sh.livetemplate.description.rm=파일 또는 디렉터리 제거
sh.livetemplate.description.select=표현식 선택
sh.livetemplate.description.string.equal=문자열이 동일합니다
sh.livetemplate.description.string.is.empty=문자열이 비어 있습니다
sh.livetemplate.description.string.not.empty=문자열이 비어 있지 않습니다
sh.livetemplate.description.string.not.equal=문자열이 동일하지 않습니다
sh.livetemplate.description.system.info.linux=Linux 시스템 정보
sh.livetemplate.description.system.info.mac=Mac OS 시스템 정보
sh.livetemplate.description.system.kernel.info=커널 정보
sh.livetemplate.description.tar.compress=tar 압축
sh.livetemplate.description.tar.decompress=tar 압축 해제
sh.livetemplate.description.until=조건에 의한 until 루프
sh.livetemplate.description.while=조건에 의한 while 루프
sh.livetemplate.description.xargs=표준 입력으로부터 명령어 실행
sh.markdown.runner.title=터미널에서 실행
sh.no.thanks=아니요
sh.parser.expected.similar.close.bracket=유사한 닫는 대괄호가 필요합니다.
sh.path.label=경로:
sh.rename.all.occurrences=모든 찾은 항목의 이름 변경
sh.rename.occurence={0} 이름 변경
sh.run.configuration.description.0.configuration={0} 구성
sh.run.environment.variables=환경 변수:
sh.run.execute=실행:
sh.run.execute.script.file=스크립트 파일
sh.run.execute.script.text=스크립트 텍스트
sh.run.execute.script.text.title=스크립트 텍스트:
sh.run.execute.terminal=터미널에서 실행
sh.run.interpreter=인터프리터
sh.run.interpreter.not.found=인터프리터를 찾을 수 없습니다
sh.run.interpreter.options=인터프리터 옵션:
sh.run.interpreter.path=인터프리터 경로:
sh.run.interpreter.should.be.executable=인터프리터가 실행 파일이어야 합니다
sh.run.script.not.found=셸 스크립트를 찾을 수 없습니다
sh.run.script.options=스크립트 옵션:
sh.run.script.path=스크립트 경로:
sh.run.working.dir=작업 디렉터리:
sh.run.working.dir.not.found=작업 디렉터리를 찾을 수 없습니다
sh.shell.script=셸 스크립트
sh.shellcheck.cannot.download=Shellcheck를 다운로드할 수 없습니다. 수동으로 설치하세요.
sh.shellcheck.cannot.update=Shellcheck를 업데이트할 수 없습니다. 이전 버전으로 롤백되었습니다.
sh.shellcheck.download.label.text=shellcheck 다운로드
sh.shellcheck.install.question=Shellcheck 설치하여 셸 스크립트의 유효성을 검증하시겠어요?
sh.shellcheck.missing=\ 누락된 Shellcheck
sh.shellcheck.path.label=Shellcheck 경로 선택:
sh.shellcheck.success.install=Shellcheck가 성공적으로 설치되었습니다.
sh.shellcheck.success.update=Shellcheck가 성공적으로 업데이트되었습니다.
sh.shellcheck.update.question=Shellcheck를 업데이트하시겠어요?
sh.skip.version=이 버전 건너뛰기
sh.suppress.inspection={0} 억제
sh.unnamed.element.presentable.name=<이름이 지정되지 않음>
sh.update=업데이트
shell.functions.can.t.be.passed.to.external.commands=셸 함수는 외부 명령어에 전달할 수 없습니다.
sigkill.sigstop.can.not.be.trapped=SIGKILL 및 SIGSTOP을 트랩할 수 없습니다.
since.you.double.quoted.this.it.will.not.word.split.and.the.loop.will.only.run.once=이것은 큰따옴표로 묶였으므로 단어로 분할되지 않으며 루프는 한 번만 실행됩니다.
some.finds.don.t.have.a.default.path.specify.explicitly=일부 find에 디폴트 경로가 없습니다. '.'를 명시적으로 지정하세요.
sudo.doesn.t.affect.redirects.use.sudo.tee.file='sudo'는 리디렉션에 영향을 주지 않습니다. '..| sudo tee file'을 사용하세요
tempfile.is.deprecated.use.mktemp.instead=tempfile은 더 이상 사용되지 않습니다. 대신 mktemp를 사용하세요.
the.arguments.to.this.comparison.can.never.be.equal.make.sure.your.syntax.is.correct=이 비교의 인수는 절대 동일하면 안 됩니다. 구문이 올바른지 확인하세요.
the.dot.command.does.not.support.arguments.in.sh.dash.set.them.as.variables=dot 명령어는 sh/dash의 인수를 지원하지 않습니다. 해당 인수를 변수로 설정하세요.
the.exit.status.can.only.be.one.integer.0.255.use.stdout.for.other.data=종료 상태는 정수 0~255여야 합니다. 다른 데이터에는 표준 출력을 사용하세요.
the.here.is.literal.to.assign.by.index.use.index.value.with.no.spaces.to.keep.as.literal.quote.it=여기에서 상등 문자 '='는 리터럴입니다. 색인으로 대입하려면 ([index]=value)을 사용하세요. 리터럴로 유지하려면 따옴표로 묶으세요.
the.surrounding.quotes.actually.unquote.this.remove.or.escape.them=주위 따옴표가 실제로 따옴표를 해제합니다. 따옴표를 제거하거나 이스케이프하세요.
this.action.ignores.everything.before.the.o.use.to.group=이 액션은 '-o' 앞의 모든 것을 무시합니다. 그룹화하려면 \\(\\)를 사용하세요.
this.array.element.has.no.value.remove.spaces.after.or.use.for.empty.string=이 배열 요소에는 값이 없습니다. '=' 뒤의 공백을 제거하거나 빈 문자열에 ""를 사용하세요.
this.assignment.is.only.seen.by.the.forked.process=이 대입은 포크된 프로세스에서만 볼 수 있습니다.
this.case.is.not.specified.by.getopts=이 case는 'getopts'로 지정되지 않았습니다.
this.cp.has.no.destination.check.the.arguments=이 'cp'에는 대상이 없습니다. 인수를 확인하세요.
this.default.assignment.may.cause.dos.due.to.globbing.quote.it=이 디폴트 대입은 글로빙으로 인해 DoS를 유발할 수 있습니다. 따옴표로 대입을 묶으세요.
this.does.not.export.foo.remove.for.that.or.use.var.to.quiet=이것은 'FOO'를 내보내지 않습니다. 내보내려면 '$'와 '${}'를 제거하거나 경고가 표시되지 않도록 '${var?}'를 사용하세요.
this.does.not.read.foo.remove.for.that.or.use.var.to.quiet=이것은 'foo'를 읽지 않습니다. '$'와 '${}'를 제거하거나 경고가 표시되지 않도록 '${var?}'를 사용하세요.
this.expands.when.defined.not.when.used.consider.escaping=이것은 사용될 때가 아니라 정의될 때 확장됩니다. 이스케이프하는 것이 좋습니다.
this.expansion.will.not.see.the.mentioned.assignment=이 확장에는 언급된 대입이 표시되지 않습니다.
this.expression.is.constant.did.you.forget.a.somewhere=이 표현식은 상수입니다. 어딘가에서 '$'를 잊지 않으셨나요?
this.expression.is.constant.did.you.forget.the.on.a.variable=이 표현식은 상수입니다. 변수에서 '$'를 잊으셨나요?
this.flag.is.used.as.a.command.name.bad.line.break.or.missing=이 플래그는 명령어 이름으로 사용됩니다. 줄 바꿈이 잘못되었거나 '[..]'가 누락되지 않았나요?
this.format.string.has.2.variables.but.is.passed.1.arguments=이 형식 문자열에는 2개의 변수가 있지만 1개의 인수가 전달됩니다.
this.function.is.only.defined.later.move.the.definition.up=이 함수는 나중에만 정의됩니다. 정의를 위로 이동하세요.
this.is.a.file.redirection.was.it.supposed.to.be.a.comparison.or.fd.operation=이것은 파일 리디렉션입니다. 비교 또는 fd 작업이어야 했나요?
this.is.a.glob.used.as.a.command.name.was.it.supposed.to.be.in.array.or.is.it.missing.quoting=이것은 명령어 이름으로 사용된 glob입니다. ''${..}'' 또는 배열에 있어야 했던 것일까요? 그렇지 않다면 따옴표를 사용하세요.
this.is.a.literal.string.to.run.as.a.command.use.instead.of=이것은 리터럴 문자열입니다. 명령어로 실행하려면 '..' 대신 '$(..)'를 사용하세요.
this.is.interpreted.as.a.shell.file.redirection.not.a.comparison=이것은 비교가 아니라 셸 파일 리디렉션으로 해석됩니다.
this.ln.has.no.destination.check.the.arguments.or.specify.explicitly=이 'ln'에는 대상이 없습니다. 인수를 확인하거나 '.'를 명시적으로 지정하세요.
this.loop.will.only.ever.run.once.for.a.constant.value.did.you.perhaps.mean.to.loop.over.dir.var.or.cmd=이 루프는 상수 값에 대해 한 번만 실행됩니다. 'dir/*', '$var' 또는 '$(cmd)'를 반복하려고 하셨나요'?
this.mv.has.no.destination.check.the.arguments=이 'mv'에는 대상이 없습니다. 인수를 확인하세요.
this.nested.loop.overrides.the.index.variable.of.its.parent=이 중첩 루프는 해당 상위 항목의 색인 변수를 재정의합니다.
this.parent.loop.has.its.index.variable.overridden=이 상위 루프에서 해당 색인 변수가 재정의되어 있습니다.
this.pattern.always.overrides.a.later.one=이 패턴은 항상 이후 패턴을 재정의합니다.
this.pattern.never.matches.because.of.a.previous.pattern=이 패턴은 이전 패턴으로 인해 전혀 대응하지 않습니다.
this.pattern.will.never.match.the.case.statement.s.word.double.check.them=이 패턴은 case 문의 단어와 일치하지 않습니다.
this.printf.format.string.has.no.variables.other.arguments.are.ignored=이 printf 형식 문자열에는 변수가 없습니다. 다른 인수는 무시됩니다.
this.redirection.doesn.t.have.a.command.move.to.its.command.or.use.true.as.no.op=이 리디렉션에는 명령어가 없습니다. 해당 명령어로 이동하세요(또는 'true'를 no-op로 사용).
this.shebang.specifies.a.directory.ensure.the.interpreter.is.a.file=이 shebang은 디렉터리를 지정합니다. 인터프리터가 파일인지 확인하세요.
this.terminates.the.command.escape.it.or.add.space.after.to.silence=이 `\\&`는 명령어를 종료합니다. 이스케이프하거나, 경고를 표시하지 않도록 `\\&` 뒤에 공백을 추가하세요.
this.will.expand.once.before.find.runs.not.per.file.found=이것은 찾은 파일마다가 아니라 find 실행 전에 한 번 확장됩니다.
this.word.is.constant.did.you.forget.the.on.a.variable=이 단어는 상수입니다. 변수에서 '$' 문자를 잊으셨나요?
this.word.is.outside.of.quotes.did.you.intend.to.nest.single.quotes.instead=이 단어는 따옴표 외부에 있습니다. '대신 ""작은따옴표""를 중첩'하려고 하셨나요?
tilde.does.not.expand.in.quotes.use.home=물결표는 따옴표에서 확장되지 않습니다. $HOME을 사용하세요.
time.is.undefined.for.compound.commands.time.sh.c.instead='time'이 복합 명령어에 대해 정의되지 않았습니다. 'time sh -c'를 사용하세요.
time.is.undefined.for.pipelines.time.single.stage.or.bash.c.instead='time'이 파이프라인에 대해 정의되지 않았습니다. 단일 단계에서 'time'을 사용하거나 대신 `time bash -c`를 사용하세요.
tips.depend.on.target.shell.and.yours.is.unknown.add.a.shebang=팁은 타깃 셸에 따라 다릅니다. shebang을 추가하세요.
to.assign.a.variable.use.just.var.value.no.set=변수를 대입하려면 'set ..'이 아닌 'var=value'를 사용하세요.
to.assign.the.output.of.a.command.use.var.cmd=명령어의 출력을 대입하려면 'var=$(cmd)'를 사용하세요.
to.expand.via.indirection.use.name.foo.n.echo.name=간접적으로 확장하려면 name="foo$n"; echo "${!name}"을 사용하세요.
to.read.lines.rather.than.words.pipe.redirect.to.a.while.read.loop=단어가 아닌 행을 읽으려면 출력을 'while read' 루프로 파이핑하거나 리디렉션하세요.
to.redirect.stdout.stderr.2.1.must.be.last.or.use.cmd.file.2.1.to.clarify=표준 출력+표준 오류를 리디렉션하려면 '2>\\&1'이 마지막에 와야 합니다(또는 명확히 하기 위해 '{cmd > file;} 2>\\&1'을 사용하세요).
to.run.commands.as.another.user.use.su.c.or.sudo=다른 사용자로서 명령어를 실행하려면 'su -c' 또는 'sudo'를 사용하세요'.
tr.replaces.sets.of.chars.not.words.mentioned.due.to.duplicates='tr'은 단어가 아닌 문자 집합을 바꿉니다(중복으로 인해 언급됨).
trapping.signals.by.number.is.not.well.defined.prefer.signal.names=시그널을 숫자로 트랩하는 것은 명확하게 정의되지 않습니다. 시그널 이름을 사용하는 것이 좋습니다.
unexpected.start.of.line.if.breaking.lines.should.be.at.the.end.of.the.previous.one=새 줄의 예기치 않은 시작입니다. 줄 바꿈을 하려는 경우 |/||/\\&\\&가 이전 줄의 끝에 있어야 합니다.
unknown.binary.operator=알 수 없는 이항 연산자입니다.
unknown.unaryoperator=알 수 없는 단항 연산자입니다.
use.a.subshell.to.avoid.having.to.cd.back=cd를 되돌리지 않으려면 ( 하위 셸 )을 사용하세요.
use.array.item.to.append.items.to.an.array='array+=("item")'을 사용하여 배열에 항목을 추가하세요.
use.cd.exit.in.case.cd.fails=cd가 실패할 경우 cd ... || exit을 사용하세요.
use.false.instead.of.empty.conditionals=빈 '[' 및 '[[' 조건 대신 'false'를 사용하세요.
use.find.instead.of.ls.to.better.handle.non.alphanumeric.filenames=영숫자가 아닌 파일 이름을 더 효과적으로 처리하려면 'ls' 대신 'find'를 사용하세요.
use.foo.if.function.s.1.should.mean.script.s.1=함수의 '$1' 인수가 스크립트의 '$1' 인수를 의미하는 경우 'foo "$@"'을 사용하세요.
use.for.arithmetics.e.g.i.i.2=산술에 `$((..))`를 사용하세요(예: 'i=$((i + 2))')
use.glob.or.glob.so.names.with.dashes.won.t.become.options=대시가 있는 이름이 옵션이 되지 않도록 './\\*glob*' 또는 '-- \\*glob*'를 사용하세요.
use.grep.q.instead.of.comparing.output.with.n='[ -n .. ]'으로 출력을 비교하는 대신 'grep -q'를 사용하세요.
use.instead.of.deprecated=사용이 중단된 '$[..]' 대신 '$((..))'를 사용하세요.
use.instead.of.to.avoid.subshell.overhead=하위 셸 오버헤드를 피하려면 '(..)' 대신 '{ ..; }'를 사용하세요.
use.lower.to.support.accents.and.foreign.alphabets=악센트 및 외국어 자모를 지원하려면 '[:lower:]'를 사용하세요.
use.n.instead.of.z='! [ -z .. ]' 대신 '[ -n .. ]'를 사용하세요.
use.n.instead.of.z2='! -z' 대신 '-n'을 사용하세요.
use.notation.instead.of.legacy.backticked=기존에 백틱을 추가한 `` `...` `` 대신 '$(...)' 표기를 사용하세요.
use.or.quote.arguments.to.v.to.avoid.glob.expansion=`[[ ]]`를 사용하거나 '-v' 옵션의 인수를 따옴표로 묶어서 glob 확장을 방지하세요.
use.own.script.or.sh.c.to.run.this.from.su=이것을 su에서 실행하려면 자체 스크립트 또는 sh -c '..'를 사용하세요.
use.print0.0.or.find.exec.to.allow.for.non.alphanumeric.filenames=영숫자가 아닌 파일 이름을 허용하려면 '-print0', '-0', 또는 'find -exec +'를 사용하세요.
use.single.quotes.otherwise.this.expands.now.rather.than.when.signalled=지금 즉시가 아니라 시그널을 받을 때만 확장하려면 작은따옴표를 사용하세요.
use.spaces.not.commas.to.separate.array.elements=쉼표가 아닌 공백을 사용하여 배열 요소를 구분하세요.
use.upper.to.support.accents.and.foreign.alphabets=악센트 및 외국어 자모를 지원하려면 '[:upper:]'를 사용하세요.
use.var.command.to.assign.output.or.quote.to.assign.string='var=$(command)'를 사용하여 출력을 대입하세요(또는 따옴표 사용하여 문자열을 대입하세요).
use.var.to.ensure.this.never.expands.to="${var:?}"를 사용하여 /*로 확장되지 않도록 하세요.
use.with.quotes.to.prevent.whitespace.problems=공백 문제를 방지하려면 "$@"(따옴표 포함)를 사용하세요.
useless.cat.consider.cmd.file.or.cmd.file.instead=불필요한 'cat'입니다. 대신 'cmd < file | ..' 또는 'cmd file | ..'을 사용하세요.
useless.echo.instead.of.cmd.echo.foo.just.use.cmd.foo=불필요한 echo인가요? 'cmd $(echo foo)' 대신 'cmd foo'를 사용하세요.
useless.echo.instead.of.echo.cmd.just.use.cmd=불필요한 `echo`인가요? `echo $(cmd)` 대신 `cmd`를 사용하세요.
var.is.referenced.but.not.assigned='var'가 참조되었으나 대입되지 않았습니다.
var.was.modified.in.a.subshell.that.change.might.be.lost='var가 하위 셸에서 수정되었습니다. 변경 내용이 손실될 수 있습니다.
variable.was.used.as.an.array.but.is.now.assigned.a.string=변수가 배열로 사용되었지만 지금 문자열이 대입되었습니다.
warning.deletes.a.system.directory=경고: 시스템 디렉터리를 삭제합니다.
when.used.with.p.m.only.applies.to.the.deepest.directory='-p', '-m'과 함께 사용될 경우 최하단 디렉터리에만 적용됩니다.
which.is.non.standard.use.builtin.command.v.instead='which'는 표준이 아닙니다. 대신 기본 제공되는 'command -v'를 사용하세요.
word.is.on.the.form.a.b.c.b.indicated.did.you.mean.abc.or.a.b.c=\ 단어가 "A"B"C"(B 표시) 형식으로 되어 있습니다. "ABC" 또는 "A\"B\"C"를의도하셨나요?
you.can.t.have.between.this.redirection.and.the.command.it.should.apply.to=이 리디렉션과 해당 리디렉션이 적용되는 명령어 사이에 '|'을 사용할 수 없습니다.
you.need.spaces.around.the.comparison.operator=비교 연산자 주위에 공백이 필요합니다.
you.probably.wanted.here='\\&\\&'를 사용하세요.