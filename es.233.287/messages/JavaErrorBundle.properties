abstract.cannot.be.instantiated=''{0}'' es abstracto; no se puede instanciar
abstract.method.0.cannot.be.accessed.directly.method.reference.context=No se puede acceder directamente al método abstracto ''{0}''
abstract.method.in.non.abstract.class=Método abstracto en clase no abstracta
abstract.methods.cannot.have.a.body=Los métodos abstractos no pueden tener cuerpo
actual.type.argument.contradict.inferred.type=El argumento de tipo real y el tipo inferido se contradicen entre sí
ambiguous.method.call=Llamada al método ambiguo: ambos ''{0}'' y ''{1}'' coinciden
ambiguous.method.call.no.match=No se puede resolver el método ''{0}'' en ''{1}''
ambiguous.method.html.tooltip=\
ambiguous.reference=La referencia a ''{0}'' es ambigua, tanto ''{1}'' como ''{2}'' coinciden
an.enclosing.instance.of.type.not.in.scope.method.reference.context=Una instancia adjunta de tipo {0} no está en el alcance
annotation.annotation.type.expected=Se esperaba Tipo de anotación
annotation.cannot.be.local=No se permiten anotaciones locales
annotation.container.abstract=La anotación de contenedor ''{0}'' no tiene un valor predeterminado para ''{1}''
annotation.container.bad.type=Anotación de contenedor no válida ''{0}'': el método '' valor '' debe tener el tipo ''{1}''
annotation.container.low.retention=La anotación de contenedor ''{0}'' tiene una retención más corta (''{1}'') que la anotación contenida
annotation.container.missed.annotation=컨테이너 어노테이션 ''{0}''에 필수 @{1} 어노테이션이 없습니다
annotation.container.no.value=Anotación de contenedor no válida ''{0}'': ningún método de '' valor '' declarado
annotation.container.not.applicable=La anotación de contenedor ''@{0}'' no se aplica a {1}
annotation.container.wide.target=El objetivo de la anotación del contenedor ''{0}'' no es un subconjunto del objetivo de esta anotación
annotation.container.wrong.place=La anotación de contenedor ''{0}'' no debe estar presente al mismo tiempo que el elemento que contiene
annotation.cyclic.element.type=Tipo de elemento de anotación cíclica
annotation.duplicate.annotation=Anotación duplicada
annotation.duplicate.attribute=Atributo duplicado ''{0}''
annotation.duplicate.explained=Anotación duplicada. {0}
annotation.illegal.array.initializer=Inicializador ilegal para ''{0}''
annotation.interface.members.may.not.have.parameters=@interface miembros pueden no tener parámetros
annotation.invalid.annotation.member.type=Tipo no válido ''{0}'' para miembro de anotación
annotation.may.not.have.extends.list=@interface puede no tener una lista de extensiones
annotation.may.not.have.type.parameters=@interface puede no tener parámetros de tipo
annotation.members.may.not.have.throws.list=@interface miembros pueden no tener lista de lanzamientos
annotation.missing.attribute={0} falta aunque es obligatorio
annotation.missing.method=No se puede encontrar el método ''{0}''
annotation.non.class.literal.attribute.value=El valor del atributo debe ser un literal de clase
annotation.non.constant.attribute.value=El valor del atributo debe ser constante
annotation.non.enum.constant.attribute.value=El valor del atributo debe ser una constante de enumeración
annotation.non.repeatable=La declaración de ''{0}'' no tiene una anotación java.lang.annotation.Repetible válida
annotation.not.allowed.class=El tipo de literal de clase no se puede anotar
annotation.not.allowed.here=Aquí no se permiten anotaciones
annotation.not.allowed.ref=Anotación no aplicable a este tipo de referencia
annotation.not.allowed.static=No se puede anotar el tipo de miembro estático que califica
annotation.not.allowed.var=No se puede anotar el tipo ''var''
annotation.not.allowed.void=el tipo 'void' no puede ser anotado
annotation.not.applicable=''@{0}'' no se aplica a {1}
annotation.on.static.member.qualifying.type.family.name=Mover tipo de anotación
annotation.type.permits=허가 절은 어노테이션 유형에 허용되지 않습니다
annotation.unknown.method=No se puede resolver el método ''{0}''
anonymous.class.implements.interface.cannot.have.qualifier=La clase anónima implementa la interfaz; no puede tener calificador para nuevo
anonymous.class.implements.interface.cannot.have.type.arguments=La clase anónima implementa la interfaz; no puede tener argumentos de tipo
anonymous.classes.must.not.extend.sealed.classes=Las clases anónimas no deben extender las clases selladas
array.creation.with.type.arguments=No se puede crear una matriz con argumentos de tipo
array.initializer.not.allowed=El inicializador de matriz no está permitido aquí
array.type.expected=Tipo de matriz esperado; encontrado: ''{0}''
assert.identifier.warn=El uso de 'assert' como identificador no se admite en las versiones desde Java 1.4
assignment.to.final.variable=No se puede asignar un valor a la variable final ''{0}''
auto.closeable.resource=자동 종료 가능한 리소스
bad.qualifier.in.super.method.reference.extended=디폴트 super 호출 내 잘못된 타입 한정자: 불필요한 인터페이스 {0}이(가) {1}에 의해 확장되었습니다
bad.qualifier.in.super.method.reference.overridden=디폴트 super 호출 내 잘못된 타입 한정자: 메서드 {0}이(가) {1}에서 재정의되었습니다
bad.type.in.switch.expression=Tipo incorrecto en la expresión de cambio: {0} no se puede convertir a {1}
binary.numbers.must.contain.at.least.one.hexadecimal.digit=Los números binarios deben contener al menos un dígito binario
binary.operator.not.applicable=El operador ''{0}'' no se puede aplicar a ''{1}'', ''{2}''
break.outside.switch.expr=Romper fuera de la expresión del interruptor adjunto
break.outside.switch.or.loop=Romper el interruptor o bucle exterior
call.to.super.is.not.allowed.in.enum.constructor=La llamada a super no está permitida en el constructor de enumeración
cannot.access.member.on.type=''{0}''이(가) 기본 타입 {1}이므로 멤버를 액세스할 수 없습니다
cannot.be.referenced.from.static.context=''{0}'' no puede ser referenciado desde un contexto estático
cannot.call.method.on.type=''{0}''이(가) 기본 타입 {1}이므로 메서드를 호출할 수 없습니다
cannot.create.array.with.empty.diamond='<>'로 배열을 생성할 수 없습니다
cannot.find.class=No se puede encontrar la clase {0}
cannot.infer.functional.interface.type=No se puede inferir el tipo de interfaz funcional
cannot.resolve.constructor=No se puede resolver el constructor ''{0}''
cannot.resolve.method=No se puede resolver el método ''{0}''
cannot.resolve.package=No se puede resolver el paquete {0}
cannot.resolve.symbol=No se puede resolver el símbolo ''{0}''
cannot.select.dot.class.from.type.variable=No se puede seleccionar de una variable de tipo
cannot.select.from.a.type.parameter=No se puede seleccionar de un parámetro de tipo
cannot.select.from.parameterized.type=No se puede seleccionar del tipo parametrizado
case.statement.outside.switch=Declaración de caso fuera del interruptor
catch.without.try=try' sin 'catch
clash.methods.message={0}'' choca con ''{1}
clash.methods.message.show.classes={0}'' en ''{2}'' choca con ''{1}'' en ''{3}
class.already.imported=''{0}'' ya está definido en esta unidad de compilación
class.cannot.be.inherited.with.different.arguments={0} no se puede heredar con diferentes argumentos: {1}
class.cannot.extend.multiple.classes=La clase no puede extender varias clases
class.cannot.inherit.from.its.type.parameter=La clase no puede heredar de su parámetro de tipo
class.clashes.with.package=La clase ''{0}'' choca con el paquete del mismo nombre
class.expected=Nombre de clase esperado aquí
class.in.default.package=Class ''{0}'' está en el paquete predeterminado
class.is.already.defined.in.single.static.import=La clase ''{0}'' ya está definida en una única importación estática
class.is.ambiguous.in.single.static.import=Class ''{0}'' es ambigua en una sola importación estática
class.is.not.used=La clase ''{0}'' nunca se usa
class.member.declared.outside=클래스 멤버가 클래스 외부에서 선언되었습니다
class.must.be.abstract=La clase ''{0}'' debe ser declarada abstracta o implementar el método abstracto ''{1}'' en ''{2}''
class.must.implement.method=La clase ''{0}'' debe implementar el método abstracto ''{1}'' en ''{2}''
class.name.expected=Nombre de clase esperado
class.not.allowed.to.extend.sealed.class.from.another.module=La clase no puede extender la clase sellada desde otro módulo
class.not.allowed.to.extend.sealed.class.from.another.package=La clase no puede extender la clase sellada de otro paquete
classes.extends.prohibited.super=Las clases no pueden extender directamente ''{0}''
compact.constructor.in.regular.class=Lista de parámetros esperada
constant.expression.required=Expresión constante requerida
constructor.call.must.be.first.statement=La llamada a ''{0}'' debe ser la primera declaración en el cuerpo del constructor
constructor.is.not.used=El constructor ''{0}'' nunca se usa
continue.outside.loop=Continuar fuera del bucle
continue.outside.switch.expr=Continuar fuera de la expresión del interruptor adjunto
create.class.action.this.not.valid.java.qualified.name=올바른 Java 정규화된 이름이 아닙니다
cyclic.inheritance=Herencia cíclica que involucra ''{0}''
declaration.not.allowed=Declaración no permitida aquí
declaration.or.variable.expected=Declaración, variable final o efectivamente final esperada
deconstruction.pattern.requires.record=구조 분해 패턴은 레코드에만 적용할 수 있습니다. ''{0}''은(는) 레코드가 아닙니다
deconstruction.pattern.type.contain.annotation=구조 분해 패턴 타입 내에서는 어노테이션이 허용되지 않습니다
default.label.must.not.contains.case.keyword=디폴트 case의 라벨은 'case' 없이 'default' 키워드만 사용해야 합니다
default.label.not.allowed.here=디폴트 라벨은 이곳에서 허용되지 않습니다. 'default'는 단일 case 라벨으로 사용되거나 'null'과만 쌍이 될 수 있습니다
default.method.overrides.object.member=El método predeterminado ''{0}'' anula un miembro de '' java.lang.Object ''
deprecated.default.constructor=El constructor predeterminado en ''{0}'' está obsoleto
deprecated.since.symbol=''{0}''은(는) 버전 {1} 이후부터 사용되지 않습니다
deprecated.symbol=''{0}'' está obsoleto
different.case.kinds.in.switch=Diferentes tipos de casos usados en el interruptor
direct.abstract.method.access=No se puede acceder al método abstracto ''{0}'' directamente
dot.expected.after.super.or.this=Se esperaba '.'
duplicate.class=Clase duplicada: ''{0}''
duplicate.class.in.other.file=Clase duplicada encontrada en el archivo ''{0}''
duplicate.default.switch.label=Etiqueta predeterminada duplicada
duplicate.label=Etiqueta ''{0}'' ya en uso
duplicate.method={0}'' ya está definido en ''{1}
duplicate.switch.label=Etiqueta duplicada ''{0}''
duplicate.unconditional.pattern.label=조건 없는 패턴 중복
else.without.if=else' sin 'if
empty.character.literal=Literal de carácter vacío
enum.constant.must.implement.method=Enum constante ''{0}'' debe implementar el método abstracto ''{1}'' en ''{2}''
enum.identifier.warn=El uso de 'enum' como identificador no se admite en las versiones desde Java 1.5
enum.is.not.used=Enum ''{0}'' nunca se usa
enum.types.cannot.be.instantiated=No se pueden crear instancias de tipos de enumeración
error.cannot.infer.pattern.type=패턴 타입을 추론할 수 없습니다. {0}
error.cannot.resolve.class=No se puede resolver la clase ''{0}''
error.cannot.resolve.class.or.package=No se puede resolver la clase o el paquete ''{0}''
error.extra.semicolons.between.import.statements.not.allowed=import 문 사이의 추가적인 세미콜론은 허용되지 않습니다
error.guard.allowed.after.patterns.only=Guard는 패턴 뒤에서만 허용됩니다
error.initializers.are.not.allowed.in.unnamed.classes=이니셜라이저는 이름이 없는 클래스에서 허용되지 않습니다
error.interface.member.clashes=@interface miembro choca con ''{0}'' en {1}
error.package.statement.not.allowed.for.unnamed.class=패키지 구문은 이름이 없는 클래스에서 허용되지 않습니다
error.raw.deconstruction=원본 구조 분해 패턴은 허용되지 않습니다
error.unnamed.class.contains.no.main.method=이름이 없는 클래스에서 'main' 메서드가 없습니다
error.unnamed.class.has.invalid.file.name=이름이 없는 클래스의 파일 이름은 유효한 식별자가 아닙니다
exception.already.caught=La excepción ''{0}'' ya ha sido detectada
exception.already.caught.warn=Sección inaccesible: {1, choice, 0#excepción|2#excepciones} ''{0}'' {1, choice, 0#| 2#han} ya sido detectadas
exception.is.never.thrown=La excepción ''{0}'' nunca se lanza en el método
exception.must.be.disjoint=Los tipos de captura múltiple deben estar separados: ''{0}'' es una subclase de ''{1}''
exception.never.thrown.try=La excepción ''{0}'' nunca se lanza en el bloque try correspondiente
expected.boolean.expression=Se esperaba una expresión booleana
expected.catch.or.finally=Se esperaba 'catch' o 'finally'
expected.class.or.package=Clase o paquete esperado
expected.comma=Se esperaba ','
expected.expression=Expresión esperada
expected.identifier=Identificador esperado
expected.identifier.or.type=Identificador o tipo esperado
expected.lbrace=Se esperaba '{'
expected.lparen=Se esperaba '('
expected.lparen.or.lbracket=Se esperaba '(' o '['
expected.parameter=Se esperaba Parámetro
expected.rbrace=Se esperaba '}'
expected.rbracket=Se esperaba ']'
expected.rparen=Se esperaba ')'
expected.semicolon=Se esperaba ';'
expected.statement=Declaración esperada
expected.switch.label=Se esperaba 'case', 'default' o '}'
expected.switch.rule=Se esperaba una expresión, bloque o declaración throw
expected.while=Se esperaba 'while'
expression.expected=Expresión esperada
expression.with.type.void.not.allowed.as.string.template.embedded.expression='void' 타입의 표현은 문자열 템플릿이 임베드된 식으로 사용할 수 없습니다
extends.after.enum=No se permite la cláusula de extensión para enum
extension.method.in.class=Los métodos de extensión solo se pueden usar dentro de una interfaz
extension.method.should.have.a.body=El método de extensión debe tener un cuerpo
field.is.already.defined.in.single.static.import=El campo ''{0}'' ya está definido en una única importación estática
field.is.ambiguous.in.single.static.import=El campo ''{0}'' es ambiguo en una sola importación estática
field.is.not.used=El campo ''{0}'' nunca se usa
field.is.not.used.for.reading=El campo {0} ''{1}'' está asignado pero nunca se accede
final.method.override=''{0}'' no se puede anular ''{1}'' en ''{2}''; el método anulado es final
finally.without.try=try' sin 'finally
floating.point.number.too.large=Número de coma flotante demasiado grande
floating.point.number.too.small=Número de coma flotante demasiado pequeño
foreach.not.applicable=foreach no aplicable al tipo ''{0}''
formal.varargs.element.type.inaccessible.here=El tipo de elemento formal de varargs {0} es inaccesible aquí
functional.interface.must.not.be.sealed.error.description=La interfaz funcional no se puede declarar como ''{0}''
generic.array.creation=Creación de matriz genérica
generic.extend.exception=La clase genérica no puede extender 'java.lang.Throwable'
generics.annotation.members.may.not.have.type.parameters=@interface miembros pueden no tener parámetros de tipo
generics.cannot.be.inherited.as.raw.and.generic=제네릭 타입 인수 ''{1}''을(를) 사용하여 ''{0}''을(를) 원시 타입으로서 상속할 수 없습니다
generics.cannot.be.inherited.with.different.type.arguments={0}'' no se puede heredar con argumentos de tipo diferente: ''{1}'' y ''{2}
generics.cannot.catch.type.parameters=No se pueden capturar los parámetros de tipo
generics.cannot.instanceof.type.parameters=Clase o matriz esperada
generics.diamond.not.applicable=El operador de diamante no es aplicable para tipos no parametrizados
generics.duplicate.type.parameter=Parámetro de tipo duplicado: ''{0}''
generics.enum.may.not.have.type.parameters=Enum puede no tener parámetros de tipo
generics.holder.method=Método
generics.holder.type=Tipo
generics.inferred.type.for.type.parameter.is.not.within.its.bound.extend=El tipo inferido ''{2}'' para el parámetro de tipo ''{0}'' no está dentro de su límite; debería extender ''{1}''
generics.inferred.type.for.type.parameter.is.not.within.its.bound.implement=El tipo inferido ''{2}'' para el parámetro de tipo ''{0}'' no está dentro de su límite; debería implementar ''{1}''
generics.methods.have.same.erasure={0}; ambos métodos tienen el mismo borrado
generics.methods.have.same.erasure.hide={0}; Ambos métodos tienen el mismo borrado, pero ninguno oculta el otro.
generics.methods.have.same.erasure.override={0}; Ambos métodos tienen el mismo borrado, pero ninguno anula al otro.
generics.reference.parameters.not.allowed=Los parámetros de referencia no están permitidos aquí
generics.select.static.class.from.parameterized.type=No se puede seleccionar la clase estática ''{0}'' del tipo parametrizado
generics.type.argument.cannot.be.of.primitive.type=El argumento de tipo no puede ser de tipo primitivo
generics.type.arguments.on.raw.method=Escriba los argumentos dados en un método sin procesar
generics.type.arguments.on.raw.type=Argumentos de tipo dados en un tipo sin formato
generics.type.or.method.does.not.have.type.parameters={0} ''{1}'' no tiene parámetros de tipo
generics.type.parameter.cannot.be.instantiated=El parámetro de tipo ''{0}'' no se puede instanciar directamente
generics.type.parameter.is.not.within.its.bound.extend=El parámetro de tipo ''{0}'' no está dentro de su límite; debería extender ''{1}''
generics.type.parameter.is.not.within.its.bound.implement=El parámetro de tipo ''{0}'' no está dentro de su límite; debería implementar ''{1}''
generics.unchecked.assignment=Asignación sin marcar: ''{0}'' a ''{1}''
generics.unchecked.call=Invocación del método no verificado ''{0}''
generics.unchecked.call.to.member.of.raw.type=Llamada sin marcar a ''{0}'' como miembro del tipo sin formato ''{1}''
generics.unchecked.cast=Reparto sin marcar: ''{0}'' a ''{1}''
generics.wildcard.not.expected=No se esperan comodines
generics.wildcards.may.be.used.only.as.reference.parameters=Los comodines solo pueden usarse como parámetros de referencia
generics.wrong.number.of.type.arguments=Número incorrecto de argumentos de tipo: {0}; requerido: {1}
guarded.pattern.variable.must.be.final=보호된 패턴에서 사용되는 변수는 final 또는 실질적으로 final이어야 합니다
guarded.patterns.unavailable=JEP 406의 보호된 패턴은 Java 19 테스트 버전부터 사용할 수 없습니다
hexadecimal.numbers.must.contain.at.least.one.hexadecimal.digit=Los números hexadecimales deben contener al menos un dígito hexadecimal
identifier.is.not.allowed.here=식별자는 허용되지 않습니다
illegal.escape.character.in.character.literal=Carácter de escape ilegal en carácter literal
illegal.escape.character.in.string.literal=Carácter de escape ilegal en literal de cadena
illegal.forward.reference=Referencia hacia adelante ilegal
illegal.generic.type.for.instanceof=Tipo genérico ilegal, por ejemplo
illegal.initializer=Inicializador ilegal para ''{0}''
illegal.line.end.in.string.literal=Final de línea ilegal en literal de cadena
illegal.self.reference=Autorreferencia ilegal
illegal.to.access.static.member.from.enum.constructor.or.instance.initializer=Es ilegal acceder al miembro estático ''{0}'' desde el constructor de enumeración o el inicializador de instancia
illegal.type.void=Tipo ilegal: 'void'
illegal.underscore=subrayado ilegal
illegal.unicode.escape=잘못된 유니코드 이스케이프 시퀀스
implements.after.interface=No se permite ninguna cláusula de implementos para la interfaz
impossible.assign.declared.outside.guard=변수 ''{0}''가 guard 외부에서 선언되어 해당 변수에 값을 할당할 수 없습니다
inaccessible.type=''{0}'' es inaccesible aquí
incompatible.modifiers=Combinación ilegal de modificadores: ''{0}'' y ''{1}''
incompatible.parameter.types.in.lambda=Tipos de parámetros incompatibles en la expresión lambda: esperado {0} pero encontrado {1}
incompatible.parameter.types.in.lambda.wrong.number.of.parameters=Tipos de parámetros incompatibles en la expresión lambda: número incorrecto de parámetros: esperado {0} pero encontrado {1}
incompatible.return.type=intentando utilizar un tipo de retorno incompatible
incompatible.switch.null.type=''{0}''을(를) ''{1}''(으)로 변환할 수 없습니다
incompatible.types=Tipos incompatibles. Encontrado: ''{1}'', obligatorio: ''{0}''
incompatible.types.html.tooltip=\
incompatible.types.reason.ambiguous.method.reference=<br/> motivo: la referencia del método es ambigua: tanto ''{0}'' como ''{1}'' coinciden
inconvertible.type.cast=Tipos inconvertibles; no se puede transmitir ''{0}'' a ''{1}''
incorrect.number.of.nested.patterns=중첩된 패턴 수가 올바르지 않습니다. {0}이(가) 필요하지만 {1}을(를) 찾았습니다.
inheritance.from.final.class=No se puede heredar de {1} ''{0}''
initializer.must.be.able.to.complete.normally=El inicializador debe poder completarse normalmente
instance.method.cannot.override.static.method=El método de instancia ''{0}'' en ''{1}'' no puede anular el método estático ''{2}'' en ''{3}''
instanceof.pattern.equals=패턴 타입 ''{0}''은(는) 표현식 타입과 같습니다
instanceof.pattern.supertype=패턴 타입 ''{0}''은(는) 표현식 타입 ''{1}''의 상위 타입입니다
insufficient.language.level={0} no se admiten en el nivel de lenguaje ''{1}''
integer.number.too.large=Número entero demasiado grande
interface.expected=Interfaz esperada aquí
interface.is.not.used=La interfaz ''{0}'' nunca se usa
interface.methods.cannot.have.body=Los métodos abstractos de la interfaz no pueden tener cuerpo
invalid.case.label.combination.constants.and.patterns=잘못된 case 라벨 조합입니다. case 라벨은 case 상수의 목록이거나 단일 case 패턴이어야 합니다
invalid.case.label.combination.constants.and.patterns.unnamed=잘못된 case 라벨 조합입니다. case 라벨은 case 상수의 목록이거나 case 패턴의 목록이어야 합니다
invalid.case.label.combination.several.patterns=유효하지 않은 case 라벨 조합입니다. case 라벨은 하나를 초과하는 case 패턴을 가질 수 없습니다
invalid.case.label.combination.several.patterns.unnamed=잘못된 case 라벨 조합입니다. 다수의 패턴은 패턴 변수가 선언되지 않는 경우에만 허용됩니다
invalid.default.and.null.order=잘못된 case 라벨 순서입니다. 'null'이 처음에 오고 'default'가 두 번째여야 합니다
invalid.package.annotation.containing.file=Las anotaciones del paquete deben estar en el archivo package-info.java
invalid.permits.clause=Cláusula de permisos inválidos: ''{0}'' debe estar sellado
invalid.permits.clause.direct.implementation=Cláusula de permisos no válidos: ''{0}'' debe {1, choice, 1#extend|2#implement} ''{2}'' directamente
invalid.qualified.new=Nuevo calificado no válido
invalid.statement=Declaración no válida
is.not.an.enclosing.class=''{0}'' no es una clase adjunta
label.without.statement=Etiqueta sin declaración
lambda.expression.not.expected=No se espera una expresión lambda aquí
lambda.parameters.consistency.message=No se pueden mezclar 'var' y parámetros escritos explícitamente en la expresión lambda
lambda.variable.must.be.final=La variable utilizada en la expresión lambda debe ser final o efectivamente final
local.class.is.not.used=La clase local ''{0}'' nunca se usa
local.classes.must.not.extend.sealed.classes=Las clases locales no deben extender las clases selladas
local.variable.is.never.used=La variable ''{0}'' nunca se usa
local.variable.is.not.assigned=La variable ''{0}'' nunca se asigna
local.variable.is.not.used.for.reading=La variable ''{0}'' está asignada pero nunca se accede
long.number.too.large=Número largo demasiado grande
lvti.array='var' no está permitido como tipo de elemento de una matriz
lvti.compound='var' no está permitido en una declaración compuesta
lvti.lambda=No se puede inferir el tipo: la expresión lambda requiere un tipo de destino explícito
lvti.method.ref=No se puede inferir el tipo: la referencia del método requiere un tipo de destino explícito
lvti.no.initializer=No se puede inferir el tipo: 'var' en la variable sin inicializador
lvti.null=No se puede inferir el tipo: el inicializador de la variable es 'nulo'
lvti.selfReferenced=No se puede inferir el tipo: el inicializador de variable es autoreferenciado
lvti.void=No se puede inferir el tipo: el inicializador de la variable es 'vacío'
malformed.floating.point.literal=Literal de punto flotante con formato incorrecto
marked.for.removal.default.constructor=El constructor predeterminado en ''{0}'' está obsoleto y marcado para su eliminación
marked.for.removal.symbol=''{0}'' está obsoleto y marcado para su eliminación
marked.for.removal.symbol.since=''{0}''은(는) 버전 {1} 이후 사용되지 않으며 제거될 예정입니다
member.referenced.before.constructor.called=No se puede hacer referencia a ''{0}'' antes de que se haya llamado al constructor de supertipo
method.call.expected=Se esperaba una llamada al método
method.does.not.override.super=El método no anula el método de su superclase
method.is.not.used=El método ''{0}'' nunca se usa
method.reference.expression.is.not.expected=Aquí no se espera la expresión de referencia del método
missing.method.body=Falta el cuerpo del método o declarar abstracto
missing.package.statement=Falta la declaración del paquete: ''{0}''
missing.package.statement.package.name.invalid=패키지 구문이 누락되었으나 파일 경로에 대응하는 패키지 이름 ''{0}''이(가) 유효하지 않습니다
missing.return.statement=Falta la declaración de devolución
missing.return.type=Declaración de método no válida; tipo de retorno requerido
missing.return.value=Falta el valor de retorno
modifier.not.allowed=Modificador ''{0}'' no permitido aquí
modifiers.for.enum.constants=No se permiten modificadores para las constantes de enumeración
module.access.bad.name=El paquete ''{0}'' se declara en el módulo con un nombre no válido (''{1}'')
module.access.does.not.read=El paquete ''{0}'' está declarado en el módulo ''{1}'', pero el módulo ''{2}'' no lo lee
module.access.from.named=El paquete ''{0}'' se declara en el módulo ''{1}'', que no lo exporta al módulo ''{2}''
module.access.from.unnamed=El paquete ''{0}'' se declara en el módulo ''{1}'', que no lo exporta al módulo sin nombre
module.access.not.in.graph=El paquete ''{0}'' se declara en el módulo ''{1}'', que no está en el gráfico del módulo
module.access.to.unnamed=El paquete ''{0}'' está declarado en el módulo sin nombre, pero el módulo ''{1}'' no lo lee
module.ambiguous=Referencia de módulo ambiguo: {0}
module.conflicting.packages=El paquete ''{0}'' existe en otro módulo: {1}
module.conflicting.reads=Módulo ''{0}'' lee el paquete ''{1}'' tanto de ''{2}'' como de ''{3}''
module.cyclic.dependence=Dependencia cíclica: {0}
module.duplicate.exports=Duplicar ''exports'': {0}
module.duplicate.exports.target=Destino de ''exports'' duplicado: {0}
module.duplicate.impl=Implementación duplicada: {0}
module.duplicate.opens=Duplicar ''opens'': {0}
module.duplicate.opens.target=Duplicar ''opens'' objetivo: {0}
module.duplicate.provides=Duplicar ''provides'': {0}
module.duplicate.requires=Duplicar ''requires'': {0}
module.duplicate.uses=Duplicar ''uses'': {0}
module.file.duplicate='module-info.java' ya existe en el módulo
module.file.wrong.location=La declaración del módulo debe estar ubicada en la raíz de origen de un módulo
module.file.wrong.name=La declaración del módulo debe estar en un archivo llamado 'module-info.java'
module.no.package=Un archivo de módulo no debe tener la declaración 'paquete'
module.not.found=Módulo no encontrado: {0}
module.not.on.path=El módulo no está en dependencias: {0}
module.open.duplicate.text=Ir a duplicar
module.opens.in.weak.module='opens' no está permitido en un módulo abierto
module.service.abstract=La implementación del servicio es una clase abstracta: {0}
module.service.alien=La implementación del servicio debe definirse en el mismo módulo que la directiva proporciona
module.service.enum=La definición del servicio es una enumeración: {0}
module.service.impl=El tipo de implementación del servicio debe ser un subtipo del tipo de interfaz de servicio, o tener un método de 'proveedor' público estático no-args
module.service.inner=La implementación del servicio es una clase interna: {0}
module.service.no.ctor=La implementación del servicio no tiene un constructor público predeterminado: {0}
module.service.provider.type=El tipo de retorno del método '' proveedor '' debe ser un subtipo del tipo de interfaz de servicio: {0}
module.service.unused=Interfaz de servicio proporcionada pero no exportada ni utilizada
module.unwanted.modifier.warn=Los modificadores en 'requires java.base' están prohibidos en las versiones desde Java 10
multiple.non.overriding.abstract.methods.found.in.0=Múltiples métodos abstractos no invalidantes encontrados en {0}
multiple.non.overriding.abstract.methods.found.in.interface.0=Se encontraron varios métodos abstractos no invalidantes en la interfaz {0}
multiple.switch.labels=switch 라벨이 패턴 변수를 선언하지 않을 때만 switch 라벨이 지정된 구문 그룹에서 다수의 switch 라벨이 허용됩니다
native.methods.cannot.have.a.body=Los métodos nativos no pueden tener cuerpo
no.default.constructor.available=No hay ningún constructor predeterminado disponible en ''{0}''
no.enclosing.instance.in.scope=Ninguna instancia adjunta del tipo ''{0}'' está en el alcance
no.interface.expected=No se espera ninguna interfaz aquí
no.target.method.found=No se encontró ningún método de destino
non.static.method.cannot.be.referenced.from.a.static.context.method.reference.context=No se puede hacer referencia al método no estático desde un contexto estático
non.static.symbol.referenced.from.static.context=No se puede hacer referencia a {0} ''{1}'' no estático desde un contexto estático
not.a.functional.interface={0} no es una interfaz funcional
not.a.statement=No es una declaración
not.allowed.in.interface=No permitido en la interfaz
not.allowed.in.sealed.hierarchy={0} no está permitido en la jerarquía sellada
not.inner.class=''{0}'' no es una clase interna
not.loop.label=No es una etiqueta de bucle: ''{0}''
null.label.not.allowed.here=잘못된 case 라벨 조합입니다. 'null'은 단일 case 라벨로 사용되거나 'default'와만 쌍이 될 수 있습니다
numeric.overflow.in.expression=Desbordamiento numérico en expresión
overridden.method.does.not.throw={0}; El método anulado no arroja ''{1}''
override.not.allowed.in.interfaces=@Override no está permitido al implementar el método de interfaz
overrides.deprecated.method=Anula el método obsoleto en ''{0}''
overrides.marked.for.removal.method=Anula el método que está obsoleto y marcado para su eliminación en ''{0}''
package.clashes.with.class=El paquete ''{0}'' choca con la clase del mismo nombre
package.is.empty=El paquete está vacío: {0}
package.local.symbol=''{0}'' no es público en ''{1}''. No se puede acceder desde el paquete externo
package.name.file.path.mismatch=El nombre del paquete ''{0}'' no corresponde a la ruta del archivo ''{1}''
package.not.found=Paquete no encontrado: {0}
parameter.excluding.hierarchy.disable.text=상속된 메서드의 매개변수를 강조 표시 안 함
parameter.is.not.used=El parámetro ''{0}'' nunca se usa
parameterized.qualifier.on.static.method.reference.context=Calificador parametrizado en referencia de método estático
pattern.is.not.exhaustive=패턴 ''{0}''은(는) ''{1}''에 대해 완전하지 않습니다
pattern.variable.is.not.used=La variable de patrón ''{0}'' nunca se usa
permit.list.must.contain.outside.inheritors=봉인된 클래스의 permits 절은 모든 하위 클래스를 포함해야 합니다
permits.after.enum=la cláusula de permiso no está permitida en enumeraciones
permits.list.generics.are.not.allowed=제네릭은 허가 목록에서 허용되지 않습니다
permitted.subclass.must.have.modifier=sealed 클래스의 하위 클래스는 final, sealed, non-sealed 중 하나여야 합니다
private.constructor.is.not.used=El constructor privado ''{0}'' nunca se usa
private.field.is.not.assigned=El campo privado ''{0}'' nunca se asigna
private.field.is.not.used=El campo privado ''{0}'' nunca se usa
private.inner.class.is.not.used=La clase interna privada ''{0}'' nunca se usa
private.inner.interface.is.not.used=La interfaz interna privada ''{0}'' nunca se usa
private.method.is.not.used=El método privado ''{0}'' nunca se usa
private.methods.in.interfaces.should.have.body=Los métodos privados en las interfaces deben tener un cuerpo
private.symbol={0}'' tiene acceso privado en ''{1}
processor.missing.from.string.template.expression=문자열 템플릿 식에서 프로세서가 누락되었습니다
protected.symbol={0}'' tiene acceso protegido en ''{1}
public.class.should.be.named.after.file=La clase ''{0}'' es pública, debe declararse en un archivo llamado '' {0} .java ''
qualified.class.reference.not.allowed.in.qualified.new=No se permite la referencia de clase calificada en calificados nuevos
qualified.enum.constant.in.switch=Una etiqueta de caso de cambio de enumeración debe ser el nombre no calificado de una constante de enumeración
qualified.enum.constant.in.switch.remove.fix=한정자 제거
qualified.new.of.static.class=Nuevo calificado de clase estática
qualifier.must.be.expression=El calificador debe ser una expresión
raw.processor.type.not.allowed=원시 프로세서 타입은 허용되지 않습니다. {0}
receiver.name.mismatch=El nombre del receptor no coincide con el tipo de clase adjunto
receiver.static.context=El receptor no se puede utilizar en un contexto estático
receiver.type.mismatch=El tipo de receptor no coincide con el tipo de clase adjunto
receiver.wrong.context=No se permiten receptores fuera de la lista de parámetros del método
receiver.wrong.position=El receptor debe ser el primer parámetro
record.accessor=Accesor de componente de registro
record.accessor.wrong.return.type=Tipo de retorno de acceso de componente incorrecto. Esperado: ''{0}'', encontrado: ''{1}''
record.canonical.constructor=Constructor canónico
record.canonical.constructor.wrong.parameter.name=Los nombres de los parámetros del constructor canónico deben coincidir con los nombres de los componentes del registro. Esperado: ''{0}'', encontrado: ''{1}''
record.canonical.constructor.wrong.parameter.type=Tipo de parámetro incorrecto para el componente de registro ''{0}''. Esperado: ''{1}'', encontrado: ''{2}''
record.compact.constructor=Constructor compacto
record.compact.constructor.return=la declaración 'return' no está permitida en el constructor compacto
record.component.cstyle.declaration=C 스타일의 레코드 구성 요소 선언은 허용되지 않습니다
record.component.not.initialized=Es posible que el componente de registro ''{0}'' no esté inicializado en el constructor canónico
record.component.restricted.name=Nombre de componente de registro ilegal ''{0}''
record.component.vararg.not.last=El componente de registro de Vararg debe ser el último en la lista
record.constructor.call.in.canonical=El constructor canónico no puede delegar en otro constructor
record.extends=No se permite la cláusula de extensiones para el registro
record.header.regular.class=Encabezado de registro declarado para no registro
record.instance.field=El campo de instancia no está permitido en el registro
record.instance.initializer=El inicializador de instancia no está permitido en el registro
record.no.constructor.call.in.non.canonical=El constructor de registros no canónicos debe delegar en otro constructor
record.no.header=El registro no tiene ningún encabezado declarado
record.permits=허가 절은 레코드에 허용되지 않습니다
record.special.method.non.public={0} debe ser ''public''
record.special.method.stronger.access={0} el nivel de acceso no puede ser más restrictivo que el nivel de acceso al registro (''{1}'')
record.special.method.throws={0} no puede declarar excepciones lanzadas
record.special.method.type.parameters={0} no puede tener parámetros de tipo
recursive.constructor.invocation=Invocación de constructor recursivo
redundant.semicolon.warn=import 구문 간의 불필요한 세미콜론은 Java 21부터 금지됩니다
remove.unused.import.quickfix.text=사용되지 않는 Import 제거
repeated.annotation.target=Objetivo de anotación repetida
repeated.interface=Interfaz repetida
resource.variable.must.be.final=La variable utilizada como recurso de prueba con recursos debe ser final o efectivamente final
restricted.identifier=''{0}'' es un identificador restringido y no se puede utilizar para declaraciones de tipo
restricted.identifier.reference=Referencia ilegal al tipo restringido ''{0}''
restricted.identifier.warn=Java {1} 이후 릴리스에서는 클래스 이름으로 ''{0}''을(를) 사용할 수 없습니다
return.from.void.method=No se puede devolver un valor de un método con tipo de resultado nulo
return.outside.method=Método de retorno externo
return.outside.switch.expr=Regresar fuera de la expresión del interruptor adjunto
safevararg.annotation.cannot.be.applied.for.record.component=@SafeVarargs는 기록 구성 요소에서는 허용되지 않습니다
safevarargs.not.allowed.non.final.instance.methods=@SafeVarargs no está permitido en métodos de instancia no final
safevarargs.not.allowed.on.methods.with.fixed.arity=@SafeVarargs no está permitido en métodos con arity fijo
safevarargs.not.applicable.for.reifiable.types=@SafeVarargs no es aplicable para tipos confiables
safevarargs.not.suppress.potentially.unsafe.operations=@SafeVarargs no suprime operaciones potencialmente inseguras
sealed.cannot.be.functional.interface=sealed 클래스는 함수 인터페이스로 사용할 수 없습니다
sealed.must.have.inheritors=La clase sellada debe tener subclases
sealed.type.inheritor.expected.modifiers={0}, {1} o {2} modificadores esperados
single.import.class.conflict=''{0}'' ya está definido en una importación de tipo único
statement.must.be.prepended.with.case.label=La declaración debe ir precedida de la etiqueta del caso
static.interface.method.call.qualifier=El método estático se puede invocar solo en la clase de interfaz que contiene
static.member.accessed.via.instance.reference=Miembro estático ''{0}.{1}'' al que se accede mediante referencia de instancia
static.method.cannot.be.annotated.with.override=정적 메서드에 @Override를 사용하여 어노테이션을 추가할 수 없습니다.
static.method.cannot.override.instance.method=El método estático ''{0}'' en ''{1}'' no puede anular el método de instancia ''{2}'' en ''{3}''
static.method.referenced.through.non.static.qualifier.method.reference.context=Método estático al que se hace referencia mediante un calificador no estático
static.method.referenced.through.receiver.method.reference.context=Método estático referenciado a través del receptor
static.methods.in.interfaces.should.have.body=Los métodos estáticos en las interfaces deben tener un cuerpo
suspicious.name.assignment={0}'' probablemente no debería asignarse a ''{1}
suspicious.name.parameter={0}'' probablemente no debería pasarse como parámetro ''{1}
suspicious.name.return={0}'' probablemente no debería devolverse del método ''{1}
switch.class.or.array.type.expected=클래스 또는 배열
switch.constant.expression.required=상수식, 패턴 또는 null이 필요합니다
switch.dominance.of.preceding.label=라벨은 선행 case 라벨 ''{0}''에 의해 지배됩니다
switch.expr.empty=la expresión 'switch' no tiene cláusulas de caso
switch.expr.incomplete=la expresión 'switch' no cubre todos los valores de entrada posibles
switch.expr.no.result=La expresión de cambio no tiene ninguna expresión de resultado
switch.expr.rule.should.produce.result=La regla de expresión de cambio debe producir un resultado en todas las rutas de ejecución
switch.expr.should.produce.result=La expresión de cambio debe producir un resultado en todas las rutas de ejecución
switch.expression.cannot.be.void=El tipo de destino para la expresión de cambio no puede ser nulo
switch.illegal.fall.through.from=패턴으로부터의 잘못된 fall-through
switch.illegal.fall.through.to=패턴으로의 잘못된 fall-through
switch.invalid.selector.types=''{0}''의 선택자 타입은 지원되지 않습니다
switch.pattern.expected=switch 선택자 타입 ''{0}''에 패턴이 필요합니다
switch.statement.empty='switch' 문에 case 절이 없습니다
switch.statement.incomplete='switch' 문이 모든 가능한 입력 값을 포함하지 않습니다
switch.unconditional.pattern.and.default.exist='switch'에 조건이 없는 패턴 및 기본 라벨이 모두 있습니다
target.method.is.generic=El método de destino es genérico
target.type.of.a.lambda.conversion.must.be.an.interface=El tipo de destino de una conversión lambda debe ser una interfaz
text.block.new.line=Inicio ilegal del bloque de texto: falta una nueva línea después de abrir las comillas
text.block.unclosed=Bloque de texto sin cerrar
text.class.cannot.access={0}에 액세스할 수 없습니다
text.class.inherits.abstract.and.default={0}이(가) 유형 {2} 및 {3}의 {1}에 대해 추상 및 디폴트를 상속합니다
text.class.inherits.unrelated.defaults={0}이(가) 유형 {2}의 {1}에 대해 관련 없는 디폴트를 상속합니다
text.class.is.not.accessible={0}은(는) 현재 컨텍스트에서 액세스할 수 없습니다
text.improper.formed.type=유형의 양식이 부적절합니다. 일부 유형 매개변수가 누락되었습니다
too.many.array.dimensions=배열 차원이 너무 많습니다
too.many.characters.in.character.literal=Demasiados caracteres en el carácter literal
two.methods.are.inherited.with.same.signature=Los métodos {0} de {1} y {2} de {3} se heredan con la misma firma
type.parameter.cannot.be.followed.by.other.bounds=El parámetro de tipo no puede ser seguido por otros límites
type.parameter.has.incompatible.upper.bounds=El parámetro de tipo {0} tiene límites superiores incompatibles: {1}
type.parameter.is.not.used=El parámetro de tipo ''{0}'' nunca se usa
type.pattern.expected=타입 패턴이 필요합니다
unary.operator.not.applicable=El operador ''{0}'' no se puede aplicar a ''{1}''
unchecked.overriding.incompatible.return.type=Anulación sin marcar: el tipo de retorno requiere una conversión sin marcar. Encontrado ''{0}'', obligatorio ''{1}''
unclosed.char.literal=Literal de carácter no cerrado
unclosed.comment=Comentario sin cerrar
underscore.identifier.error=A partir de Java 9, '_' es una palabra clave y no se puede utilizar como identificador
underscore.identifier.error.unnamed='_'를 참조로 사용하는 것은 허용되지 않습니다
underscore.identifier.warn=El uso de '_' como identificador no se admite en versiones desde Java 9
underscore.lambda.identifier=No se permite el uso de '_' como nombre de parámetro lambda
unexpected.token=Token inesperado
unexpected.type=예기치 않은 타입입니다. 발견: ''{1}'', 필요: ''{0}''
unexpected.type.class.expected=Tipo inesperado: se espera una clase
unhandled.close.exceptions=Excepci{1, choice, 0#ón no controlada|2#ones no controladas} de {2}: {0}
unhandled.exceptions=Excepci{1, choice, 0#ón no controlada|2#ones no controladas}: {0}
unknown.class=Clase desconocida: ''{0}''
unqualified.super.disallowed=No se permite la super referencia no calificada en el método de extensión
unreachable.statement=Declaración inalcanzable
unreachable.statement.false.condition=루프 조건이 항상 거짓이므로 루프 본문에 도달할 수 없습니다
unrelated.overriding.methods.return.types=los métodos tienen tipos de retorno no relacionados
unresolved.label=Etiqueta no definida: ''{0}''
unsafe.cast.in.instanceof={0}'' no se puede convertir de forma segura a ''{1}
valid.switch.1_7.selector.types=char, byte, short, int, Character, Byte, Short, Integer, String 또는 enum
valid.switch.selector.types=byte, char, short o int
vararg.cstyle.array.declaration=vararg 인수 내에서 C 스타일의 배열 선언은 허용되지 않습니다
vararg.not.last.parameter=El parámetro Vararg debe ser el último en la lista
variable.already.assigned=Es posible que la variable ''{0}'' ya se haya asignado a
variable.already.defined=La variable ''{0}'' ya está definida en el alcance
variable.assigned.in.loop=La variable ''{0}'' podría asignarse en bucle
variable.expected=Variable esperada
variable.must.be.final=Se accede a la variable ''{0}'' desde dentro de la clase interna, debe declararse final
variable.must.be.final.or.effectively.final=Se accede a la variable ''{0}'' desde dentro de la clase interna, debe ser final o efectivamente final
variable.not.initialized=Es posible que la variable ''{0}'' no se haya inicializado
visibility.access.problem=No se puede acceder a ''{0}'' en ''{1}''
visibility.module.access.problem={2} impide el acceso a ''{0}'' en ''{1}''
void.type.is.not.allowed=El tipo 'void' no está permitido aquí
weaker.privileges={0}; intentar asignar privilegios de acceso más débiles (''{1}''); era ''{2}''
when.expression.is.false=이 케이스 라벨은 'false' 값을 가진 상수 식인 guard를 갖고 있습니다
wildcard.type.cannot.be.instantiated=El tipo de comodín ''{0}'' no se puede instanciar directamente
wrong.constructor.arguments={0}'' no se puede aplicar a ''{1}
wrong.method.arguments={0}'' in ''{1}'' no se puede aplicar a ''{2}
yield.unexpected=Rendimiento fuera de la expresión de cambio
yield.unqualified.method.warn=Es posible que la llamada no calificada al método 'yield' no sea compatible con versiones desde Java 14
yield.void=El tipo de expresión no debe ser 'void'
