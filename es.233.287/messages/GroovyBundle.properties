0.expressions.on.trait.fields.properties.are.not.supported.in.traits={0} las expresiones en los campos/propiedades de rasgos no son compatibles con los rasgos
0.is.deprecated=''{0}'' está obsoleto
Cannot.perform.undo.operation=연산을 실행 취소할 수 없음
Constructor=Constructor
Equals=Iguales
Getter=Getter
Inner.methods.are.not.supported=Los métodos internos no son compatibles
Setter=Setter
Undo.disable=비활성화 실행 취소
abstract.methods.must.not.have.body=Los métodos abstractos no deben tener cuerpo
abstract.visibility.presentation=abstract
action.ConvertGroovyToJava.description=Convertir archivos Groovy a Java
action.ConvertGroovyToJava.text=Convertir a Java
action.ConvertToCompileStatic.description=Convertir archivos Groovy a @CompileStatic
action.ConvertToCompileStatic.text=Convertir a @CompileStatic
action.DumpGroovyControlFlowAction.text=Volcar Flujo de control Groovy
action.ExcludeFromStubGeneration.description=No genere stubs de Java para este archivo Groovy en la compilación
action.ExcludeFromStubGeneration.text=Excluir de la generación de stub
action.Gant.NewScript.description=새 Gant 스크립트 생성
action.Gant.NewScript.text=Gant 스크립트
action.Groovy.CheckResources.Make.description=Ejecute el compilador incremental para archivos Groovy en las raíces de recursos para comprobar si hay problemas de compilación
action.Groovy.CheckResources.Make.text=_Build Resources
action.Groovy.CheckResources.Rebuild.description=Ejecute el compilador para todos los archivos Groovy en las raíces de recursos para comprobar si hay problemas de compilación
action.Groovy.CheckResources.Rebuild.text=_Rebuild Resources
action.Groovy.Console.description=Inicia la consola Groovy
action.Groovy.Console.text=Consola Groovy
action.Groovy.NewClass.description=Crear nueva clase Groovy
action.Groovy.NewClass.text=Clase Groovy
action.Groovy.NewScript.description=Crear nuevo script Groovy
action.Groovy.NewScript.text=Script maravilloso
action.build.module.restart.description=모듈 ''{0}'' 빌드 후 다시 시작
action.build.restart.text=빌드 후 다시 시작
action.collapse.all.description=모두 접기
action.collapse.all.text=모두 접기
action.convert.lambda.to.closure=Convertir lambda en cierre
action.expand.all.description=모두 펼치기
action.expand.all.text=모두 펼치기
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.description=Genera getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.text=Getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.description=Genera getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.text=Getter y Setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.description=Genera setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.text=Setter
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.description=Genera constructor
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.text=Constructor
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.description=La acción genera equals y hashCode ahora
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.text=equals() y hashCode()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.description=La acción genera propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.text=methodMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.description=La acción genera propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.text=propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.description=Generar método toString()
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.text=to_String()
action.remove.dynamic.member.description=동적 멤버 제거
action.remove.dynamic.member.text=Eliminar
add.class.to.extends.family.name=구현
add.compilestatic=@CompileStatic 추가
add.dynamic.element=Agregar elemento dinámico
add.dynamic.method=Agregar método dinámico
add.dynamic.method.0=동적 메서드 ''{0}'' 추가
add.dynamic.property=Agregar propiedad dinámica ''{0}''
add.method=메서드 ''{0}()'' 을(를) ''{1}'' 에 추가
add.method.family=메서드 추가
add.modifier.sealed=제어자 'sealed' 추가
add.parenthesis.to.lambda.parameter.list=Agregar paréntesis a la lista de parámetros
add.return.type=반환 유형 추가
add.return.type.to.method.declaration=반환 유형을 메서드 선언에 추가
add.to.resources=리소스에 추가
add.type.customizer.to.resources=유형 커스터마이저 스크립트를 리소스에 추가
ambiguous.code.block=Bloque de código ambiguo
annotation.collector.cannot.have.attributes=El tipo de anotación anotado con @AnnotationCollector no puede tener atributos
annotation.field.can.only.be.used.within.a.script=Annotation @Field solo se puede usar dentro de un script
annotation.field.can.only.be.used.within.a.script.body=Annotation @Field solo se puede usar dentro de un cuerpo de script
annotation.field.should.have.type.declaration=El campo en la anotación debe tener una declaración de tipo
annotation.type.cannot.be.inner=El tipo de anotación no puede ser interno
annotation.types.may.not.have.extends.clause=Los tipos de anotaciones pueden no tener una cláusula 'extiende'
annotation.types.may.not.have.implements.clause=Los tipos de anotaciones pueden no tener una cláusula 'implements'
anonymous.class=익명 클래스
anonymous.class.cannot.have.abstract.method=La clase anónima no puede tener un método abstracto
anonymous.class.derived.from.0=clase anónima derivada de {0}
anonymous.classes.cannot.be.created.from.traits=No se pueden crear clases anónimas a partir de rasgos
are.you.sure.to.delete.dynamic.property=¿Está seguro de eliminar ''{0}''?
are.you.sure.to.delete.elements=¿Está seguro de eliminar los elementos ''{0}''?
at.interface.0.does.not.contain.attribute=@interface ''{0}'' no contiene el atributo ''{1}''
attribute.descriptor.abstract.class=추상 클래스
attribute.descriptor.annotation.attribute.name=어노테이션 속성 이름
attribute.descriptor.annotation.name=어노테이션 이름
attribute.descriptor.annotations=어노테이션
attribute.descriptor.anonymous.class=익명 클래스
attribute.descriptor.bad.character=잘못된 문자
attribute.descriptor.block.comment=Bloque de comentario
attribute.descriptor.braces=중괄호
attribute.descriptor.braces.and.operators=중괄호 및 연산자
attribute.descriptor.brackets=대괄호
attribute.descriptor.class=클래스
attribute.descriptor.classes.and.interfaces=클래스 및 인터페이스
attribute.descriptor.closure.expression.braces.and.arrow=클로저 표현식 중괄호 및 화살표
attribute.descriptor.comments=Comentario
attribute.descriptor.constructor.call=생성자 호출
attribute.descriptor.constructor.declaration=생성자 선언
attribute.descriptor.enum=열거형
attribute.descriptor.fields=필드
attribute.descriptor.groovydoc=GroovyDoc
attribute.descriptor.groovydoc.tag=태그
attribute.descriptor.groovydoc.text=Texto
attribute.descriptor.gstring=GString
attribute.descriptor.instance.field=인스턴스 필드
attribute.descriptor.instance.method.call=인스턴스 메서드 호출
attribute.descriptor.instance.property.reference=인스턴스 프로퍼티 참조
attribute.descriptor.interface=인터페이스
attribute.descriptor.invalid.string.escape=잘못된 문자열 이스케이프
attribute.descriptor.keyword=키워드
attribute.descriptor.label=라벨
attribute.descriptor.lambda.expression.braces.and.arrow=람다 표현식 중괄호 및 화살표
attribute.descriptor.line.comment=줄 주석
attribute.descriptor.list.map.to.object.conversion=List/Map에서 객체로 변환
attribute.descriptor.local.variable=지역 변수
attribute.descriptor.map.key.named.argument=Map 키/기명 매개변수
attribute.descriptor.method.declaration=메서드 선언
attribute.descriptor.methods=메서드
attribute.descriptor.number=숫자
attribute.descriptor.operator.sign=연산자 기호
attribute.descriptor.parameter=매개변수
attribute.descriptor.parentheses=소괄호
attribute.descriptor.reassigned.local.variable=재대입된 지역 변수
attribute.descriptor.reassigned.parameter=재대입된 매개변수
attribute.descriptor.references=참조
attribute.descriptor.static.field=static 필드
attribute.descriptor.static.method.call=정적 메서드 호출
attribute.descriptor.static.property.reference=정적 프로퍼티 참조
attribute.descriptor.string=String
attribute.descriptor.strings=문자열
attribute.descriptor.trait=특성
attribute.descriptor.type.parameter=타입 매개변수
attribute.descriptor.unresolved.reference=해결되지 않은 참조
attribute.descriptor.valid.string.escape=올바른 문자열 이스케이프
attribute.descriptor.variables.and.parameters=변수 및 매개변수
attribute.name.expected=Nombre de atributo esperado
base.script.annotation.is.allowed.only.inside.scripts=La anotación @BaseScript solo se puede usar dentro de un script
break.outside.loop=La declaración de ruptura con etiquetas con nombre solo se permite dentro de los bucles
break.outside.loop.or.switch=La declaración de interrupción solo se permite dentro de bucles o interruptores
builder.annotation.not.support.super.for.simple.strategy=El atributo de anotación 'includeSuperProperties' no es compatible con groovy.transform.builder.SimpleStrategy
call.can.throw.npe=호출 체인이 NullPointerException을 던질 수 있습니다
call.without.parentheses.are.supported.since.groovy.3=인수 목록에 소괄호가 없는 호출은 Groovy 3.0부터 지원됩니다
cannot.access=El acceso a ''{0}'' excede sus derechos de acceso
cannot.apply.constructor=El constructor ''{0}'' en ''{1}'' no se puede aplicar a ''{2}''
cannot.apply.default.constructor=No se puede aplicar el constructor predeterminado para la clase ''{0}''
cannot.apply.method.or.closure={0}'' no se puede aplicar a ''{1}
cannot.apply.method1={0}'' in ''{1}'' no se puede aplicar a ''{2}
cannot.assign=No se puede asignar ''{0}'' a ''{1}''
cannot.assign.a.value.to.final.field.0=No se puede asignar un valor al campo final ''{0}''
cannot.assign.a.value.to.final.parameter.0=No se puede asignar un valor al parámetro final ''{0}''
cannot.assign.string.to.enum.0=No se puede asignar una cadena a la enumeración ''{0}''
cannot.cast=No se puede transmitir ''{0}'' a ''{1}''
cannot.create.class=클래스를 생성할 수 없음
cannot.create.class.error.text=No se puede crear la clase ''{0}'': {1}
cannot.create.class.error.title=No se puede crear una clase
cannot.find.enum.constant.0.in.enum.1=No se puede encontrar la constante de enumeración ''{0}'' en la enumeración ''{1}''
cannot.infer.argument.types=No se pueden inferir tipos de argumentos
cannot.instantiate.abstract.class=No se puede crear una instancia de la clase abstracta ''{0}''
cannot.instantiate.interface=No se puede crear una instancia de la interfaz ''{0}''
cannot.reference.non.static=No se puede hacer referencia al símbolo no estático ''{0}'' desde el contexto estático
cannot.resolve=No se puede resolver el símbolo ''{0}''
cannot.return.from.constructor=No se puede devolver un objeto del constructor
cannot.return.from.void.method=No se puede devolver un objeto de un método que devuelve 'void'
cannot.return.type=No se puede devolver ''{0}'' del método que devuelve ''{1}''
catch.statement.parameter.type.should.be.a.subclass.of.throwable=El tipo de parámetro de declaración Catch debe ser una subclase de Throwable
change.base.method.label=기본 메서드 변경
change.implements.and.extends.classes=Normalizar extiende e implementa listas
change.lvalue.type=변수 ''{0}'' 유형을 ''{1}'' (으)로 변경
change.modifier=Hacer ''{0}'' {1}
change.modifier.family.name=Cambiar modificadores
change.modifier.not=Hacer ''{0}'' no {1}
change.signature.default.initializer.column=기본 이니셜라이저
change.signature.type.column=유형
change.usages.label=사용 위치 변경
checkbox.delegate.via.overloading.method=오버로드 메서드를 통한 위임
checkbox.ignore.conditional.operators=조건 연산자 무시
checkbox.ignore.double.checked.locking.on.volatile.fields=휘발성 필드에서 이중 검사된 잠금 무시
checkbox.ignore.obscure.operators=모호한 연산자 무시
checkbox.inspect.anonymous.closures=익명 클로저 검사
checkbox.inspect.gradle.files=Gradle 파일 검사
checkbox.only.warn.if.loop.empty=루프가 비어 있는 경우에만 경고
checkbox.report.unmatched.null=일치하지 않는 'null' 보고
class.definition.is.not.expected.here=No se espera una definición de clase aquí
class.is.not.annotation=''{0}'' no es una anotación
closure=클로저
closure.is.accessed.outside.of.groovy=필드 <b>{0}</b> 이(가) Groovy 외부에서 액세스됩니다
closure.is.too.complex.to.analyze=El cierre es complejo de analizar.\nLos tipos de variables locales no se infieren.
closure.used.as.variable=클로저가 인수로서 전달되었습니다. 리팩터링을 하면 의미가 변경될 수 있습니다.
code.style.groovydoc.enable=GroovyDoc 서식 지정 활성화
code.style.groovydoc.tab.name=GroovyDoc
code.style.group.list.map.literals=List 및 Map 리터럴
code.style.option.after.assert.separator=''assert'' 구분 기호 뒤
code.style.option.align.multiline.named.arguments=여러 줄의 이름 지정된 인수 정렬
code.style.option.align.when.multiple=여러 개일 경우 정렬
code.style.option.before.assert.separator=''assert'' 구분 기호 앞
code.style.option.before.record.parameter.list=레코드 매개변수 목록 앞
code.style.option.closure.left.brace.in.method.calls=메서드 호출 내 왼쪽 중괄호 클로저
code.style.option.gstring.injection.braces=GString 삽입 중괄호
code.style.option.import.annotations=어노테이션 가져오기
code.style.option.in.named.argument.after.colon=''\:'' 뒤 이름 지정된 인수 내
code.style.option.in.named.argument.before.colon=''\:'' 앞 이름 지정된 인수 내
code.style.option.list.maps.literals=List 및 Map 리터럴
code.style.option.regexp.expression=정규 표현식 (\=\=~, \=~)
code.style.option.relational.operators=관계 연산자(<, >, <\=, >\=, <\=>)
code.style.option.simple.lambdas.closures.in.one.line=한 줄의 간단한 람다/클로저
code.style.option.tuple.assignment.expression=튜플 할당 표현식
code.style.option.unary.operators=단항 연산자(\!, -, +, ++, --, *)
code.style.option.use.flying.geese.braces=닫는 중괄호를 한 줄에 입력
code.style.option.wrap.after.dot=마침표 이후 줄 바꿈
collection.literal.contains.named.argument.and.expression.items=El literal de colección contiene argumentos con nombre y expresión al mismo tiempo
command.name.add.dynamic.member=동적 멤버 추가
comments.count.as.content=주석을 내용으로 계산
configurable.GantConfigurable.display.name=Gant
configurable.GroovyCompilerConfigurable.display.name=Compilador Groovy
configurable.greclipse.border.title=Groovy-Eclipse 옵션
configurable.greclipse.command.line.params.label=추가 명령줄 매개변수\:
configurable.greclipse.debug.checkbox=디버깅 정보 생성
configurable.greclipse.path.chooser.description=Groovy 배포판과 일치하는 버전의 groovy-eclipse-batch-*.jar 경로 선택
configurable.greclipse.path.label=groovy-eclipse-batch jar 경로\:
configurable.hotswap.checkbox=Groovy 코드의 핫 스왚 에이전트 활성화
configurable.hotswap.checkbox.description=디버그된 애플리케이션에서 직렬화 문제를 유발할 수 있음
configure.groovy.library=Configurar Groovy SDK…
constructor.cannot.have.static.modifier=El constructor no puede ser estático
constructors.are.not.allowed.in.anonymous.class=Los constructores no están permitidos en la clase anónima
constructors.are.not.allowed.in.interface=Los constructores no están permitidos en la interfaz
constructors.cannot.have.return.type=El elemento de tipo de retorno no está permitido en el constructor
continue.outside.loop=La instrucción continue solo se permite dentro de los bucles
conversion.closure.not.allowed.in.non.groovy.files=Groovy가 아닌 파일에서 사용되는 클로저에는 리팩터링을 사용할 수 없습니다\:
conversion.method.not.allowed.in.non.groovy.files=Groovy가 아닌 파일에서 사용되는 메서드에는 리팩터링을 사용할 수 없습니다\:
convert.cannot.itself=리팩터링은 맵 매개변수 자체에 사용할 수 없습니다
convert.param.to.map.entry=매개변수를 맵 항목으로 변환
convert.parameter.to.map.entry.title=매개변수를 맵 항목으로 변환
create.annotation.text=Crear anotación {0}
create.class.family.name=Crear clase
create.class.text=Crear clase {0}
create.directory.command=디렉터리  생성
create.enum=Crear enumeración {0}
create.field.from.usage=Crear campo ''{0}''
create.field.from.usage.family.name=Crear campo a partir del uso
create.instance.of.built-in.type=Creación de instancias del tipo incorporado
create.interface.text=Crear interfaz {0}
create.method.from.usage=Crear método ''{0}''
create.method.from.usage.family.name=Crear método a partir del uso
create.parameter.from.usage=Crear parámetro ''{0}''
create.parameter.from.usage.family.name=Crear parámetro a partir del uso
create.record.text=기록 {0} 생성
create.trait=Crear rasgo {0}
create.variable.from.usage=Crear variable ''{0}''
create.variable.from.usage.family.name=Crear variable de uso
cyclic.inheritance.involving.0=Herencia cíclica que involucra ''{0}''
debug.option=Habilitar y &depurar el seguimiento de la pila
declare.explicit.implementations.of.trait=특성의 명시적 구현 선언
declared.type.0.extends.1.which.is.circular.inheritance=선언된 타입 ''{0}''은(는) ''{1}''을(를) 확장합니다. 이는 순환 상속입니다
declared.type.0.have.to.extend.script=El tipo declarado ''{0}'' no extiende la clase '' groovy.lang.Script ''
def.visibility.presentation=def
default.initializers.are.not.allowed.in.abstract.method=Los inicializadores predeterminados no están permitidos en métodos abstractos
default.modifier.in.old.versions=El modificador 'predeterminado' está disponible con Groovy 3.0 o posterior
delegate.annotation.is.only.for.methods.without.arguments=La anotación @Delegate no se pudo aplicar al método con argumentos
destination.package=대상 패키지\:
dialog.create.class.package.chooser.title=대상 패키지 선택
dialog.message.gant.not.configured=Gant가 구성되지 않았습니다.
dialog.title.no.jdk.specified.error=Groovy SDK 지정 안 됨
dialog.title.no.jdk.specified.prompt=SDK가 할당되지 않은 프로젝트를 생성하시겠어요?
dialog.title.no.jdk.specified.title=Groovy SDK 지정 안 됨
dialog.title.refactoring.unavailable.in.current.scope=현재 범위에서는 리팩터링을 사용할 수 없음
dialog.title.select.groovy.sdk=Groovy SDK 선택
dialog.title.specify.groovy.sdk=Groovy SDK 홈 지정
dialog.title.validation.directory.you.specified.does.not.contain.groovy.sdk.do.you.want.to.create.project.with.this.configuration=Groovy SDK가 없는 디렉터리를 지정했습니다. 이 구성으로 프로젝트를 생성하시겠어요?
dialog.title.validation.invalid.sdk.specified.error=잘못된 Groovy SDK 지정됨
dialog.title.validation.invalid.sdk.specified.title=잘못된 Groovy SDK 지정됨
dialog.title.validation.path.does.not.contain.groovy.sdk=경로에 Groovy SDK가 없습니다
dialog.title.validation.path.should.not.be.empty=경로는 공백일 수 없습니다
do.you.want.to.change.method.return.type=''{0}'' 메서드의 반환 유형을 변경하시겠어요?
do.you.want.to.change.type.of.parameter.in.method=메서드 ''{1}'' 에서 매개변수 ''{0}'' 의 유형을 변경하시겠어요?
do.you.want.to.change.variable.type=''{0}'' 의 유형을 변경하시겠어요?
doc.end.expected='*/' esperado
documentation.cannot.infer.type.label=타입을 추론할 수 없습니다
documentation.gdk.label=GDK
documentation.inferred.type.label=추론 타입
duplicate.attribute=Atributo duplicado
duplicate.class=Class ''{0}'' ya existe en ''{1}''
duplicate.element.in.the.map=Elemento duplicado ''{0}'' en el mapa
duplicate.inner.class=Clase duplicada: ''{0}''
duplicate.modifier=Modificador duplicado ''{0}''
duplicated.named.parameter=Parámetro con nombre duplicado ''{0}'' encontrado
duplicating.named.parameter=El parámetro con nombre duplicado ''{0}'' ocurre en los parámetros: {1}
dynamic.dialog.class.label=클래스(&C)\:
dynamic.dialog.static.checkbox=&정적
dynamic.dialog.type.label=유형(&T)\:
dynamic.element=동적 요소
dynamic.element.deletion=Eliminación de elementos dinámicos
dynamic.members.column.name.element=동적 요소
dynamic.members.column.name.type=Categoría
dynamic.method.property.type=Propiedad y tipo:
dynamic.method.return.type=Devolver &tipo:
dynamic.name=Nombre
dynamic.properties.table.name=Argumentos del método
dynamic.property.deletion=Propiedad dinámica de eliminación
dynamic.tool.window.id=Miembros dinámicos
dynamic.type=Tipo
ellipsis.type.is.not.allowed.here=El tipo de elipsis no está permitido aquí
enums.may.not.have.extends.clause=Las enumeraciones pueden no tener la cláusula 'extends'
equals.between.inconvertible.types.tooltip=<code>{0}</code>이(가) 변환할 수 없는 유형인 ''{1}'' 및 ''{2}'' 의 객체 사이에 있습니다
exception.0.has.already.been.caught=La excepción ''{0}'' ya ha sido detectada
expected.0.to.be.inline.constant=Se espera que ''{0}'' sea una constante en línea
expected.type.0=''{0}'' 이(가) 필요하나 ''{1}'' 발견
explicit.constructors.are.not.allowed.in.immutable.class=Los constructores explícitos no están permitidos para la clase @Immutable
explicit.includes.and.excludes=''includes'' 및 ''excludes'' 중 하나만 제공해야 합니다
expression.expected=Expresión esperada
expression.type.no.expression=표현식을 찾을 수 없음
expression.type.unknown=<unknown>
extract.closure.command.name=클로저 추출
field.already.defined=Campo ''{0}'' ya definido
field.already.exists=필드 <b>{0}</b>이(가) 이미 있습니다
field.is.used.in.argument.label=필드 <b>{0}</b> 이(가) 인수 라벨에서 사용됩니다
field.should.be.immutable=El campo ''{0}'' debe tener un tipo inmutable o declararse así con @ImmutableOptions
file.exists=파일 ''{0}'' 이(가) 디렉터리 ''{1}'' 에 이미 있습니다
file.template.group.title.groovy=Groovy
filetype.dgm.description=Groovy 확장 모듈 설명자 파일
filetype.dgm.display.name=DGM
filetype.gdsl.description=IntelliJ Groovy DSL 구성
filetype.gdsl.display.name=Groovy DSL
filetype.logback.description=Groovy Logback DSL 구성
filetype.logback.display.name=Groovy Logback DSL
final.class.cannot.be.extended=La clase final no se puede extender
final.visibility.presentation=final
find.method.ro.closure.usages=프로젝트 파일 내 둘러싸는 클로저 사용 위치 검색 중
find.method.ro.method.usages=프로젝트 파일 내 둘러싸는 메서드 사용 위치 검색 중
find.usages.method.0.of.class.1={0} de {1}
fix.class=클래스 {0} 수정
fix.package.name=Corregir el nombre del paquete
framework.0.home.label={0} 홈\:
framework.0.library={0} 라이브러리
framework.0.library.version.1={0} 라이브러리 버전 {1}
framework.0.sdk.chooser.description={0} 배포판을 포함하는 디렉터리 선택
framework.0.sdk.chooser.error.message=지정된 경로의 {0} 배포판이 망가진 것 같습니다. 버전을 파악할 수 없습니다.
framework.0.sdk.chooser.error.title=클래스 생성 실패
framework.0.sdk.chooser.title={0} SDK
framework.gant=Gant
gdsl.error.notification.title=DSL 스크립트 실행 오류
gdsl.investigate.link.label=조사하려면 클릭하세요
generate.equals.and.hashcode.already.defined.title=equals() 및 hashCode()가 이미 정의되어 있음
generate.equals.and.hashcode.already.defined.warning=equals() 및 hashCode()가 이미 정의되어 있음
generate.equals.and.hashcode.already.defined.warning.anonymous=equals() 및 hashCode()가 이미 정의되어 있음
generate.equals.compare.arrays.comment=// Object[] 배열을 Arrays.equals와 비교하면 올바르지 않을 수 있음
generate.equals.compare.nested.arrays.comment=// 여기 {0} 의 중첩된 배열 - 값 비교
generate.method.missing.already.defined.title=methodMissing()이 이미 정의되어 있음
generate.method.missing.already.defined.warning=methodMissing()이 이미 정의되어 있음
generate.property.missing.already.defined.title=propertyMissing()이 이미 정의되어 있음
generate.property.missing.already.defined.warning=propertyMissing()이 이미 정의되어 있음
generated.stub.exclude.link.label=스텁 생성에서 제외
generated.stub.message=이 스텁은 Groovy 클래스가 Groovy-Java 크로스 컴파일을 가능하게 하기 위해 생성됩니다
generated.stub.navigate.link.label=Groovy 클래스로 이동
getter.0.clashes.with.getter.1=충돌 발생\: ''{0}'' 와(과) ''{1}''
getter.kind.gdk.method.0=GDK 메서드 {0}
getter.kind.getter.0=getter {0}
getter.kind.method.0=메서드 {0}
ginq.code.style.group.ginq.clauses=GINQ 절
ginq.code.style.option.indent.having.clauses='having' 절 들여쓰기
ginq.code.style.option.indent.on.clauses='on' 절 들여쓰기
ginq.code.style.option.space.after.keyword=키워드 뒤에 공백 넣기
ginq.code.style.option.wrap.having.clauses='having' 절 줄 바꿈
ginq.code.style.option.wrap.on.clauses='on' 절 줄 바꿈
ginq.error.message.0.must.be.after.1=''{0}''은(는) ''{1}'' 이후여야 합니다
ginq.error.message.0.must.be.before.1=''{0}''은(는) ''{1}'' 이전이어야 합니다
ginq.error.message.boolean.condition.expected=부울 조건이 필요합니다
ginq.error.message.container.expected=GINQ, Iterable, Stream 혹은 배열이 필요합니다
ginq.error.message.expected.a.boolean.expression=bool 표현식이 필요합니다
ginq.error.message.expected.alias=별칭 이름이 필요합니다
ginq.error.message.expected.data.source=데이터 소스가 필요합니다
ginq.error.message.expected.in.operator='… 내 …'이 필요합니다
ginq.error.message.expected.one.or.two.arguments.for.limit='limit'에 하나 혹은 두 개의 인수가 필요합니다
ginq.error.message.from.must.be.in.the.start.of.a.query='from'은 쿼리의 첫부분에 있어야 합니다
ginq.error.message.groupby.expected.a.list.of.expressions=표현식의 목록이 필요합니다
ginq.error.message.on.is.expected.after.join='join'과 유사한 절 뒤에는 'on'이 필요합니다
ginq.error.message.on.should.not.be.provided.after.crossjoin='crossjoin' 뒤에 'on'이 오면 안 됩니다
ginq.error.message.orderby.expected.a.list.of.ordering.fields=정렬하는 필드의 목록이 필요합니다
ginq.error.message.query.should.end.with.select=쿼리는 'select'로 끝나야 합니다
ginq.error.message.query.should.start.from.from=쿼리는 'from'으로 시작해야 합니다
ginq.error.message.unrecognized.query=인식되지 않는 쿼리
gr.package.inspection.check.scripts=스크립트 검사
grab.error.0.title=@Grab을 실행할 수 없음\: {0}
grab.error.ivy.missing.message=죄송하지만 IDEA는 Apache Ivy 없이 종속성을 @Grab할 수 없습니다. Apache Ivy를 모듈 종속성에 추가하여 액션을 재실행하세요.
grab.error.ivy.missing.title=Ivy가 누락되었습니다
grab.family.name=Grab
grab.intention.name=아티팩트 Grab
grab.jar.count=<b>{0}</b>\: {1} {1, choice, 0\#jar|1\#jar|2\#jar}
grab.progress.title=@Grab 어노테이션 처리 중
grab.result.title={0} Grape 종속성 {0, choice, 0\#jar|1\#jar|2\#jar} 추가됨
groovy.consoles.type=Consola Groovy
groovy.debug.caption=Groovy
groovy.debug.disable.specific.methods=No entre en clases específ&icas de Groovy
groovy.does.not.support.constructor.type.arguments=Groovy no admite argumentos de tipo constructor
groovy.file.0=Archivo maravilloso ''{0}''
groovy.file.extension.is.not.mapped.to.groovy.file.type=*. Los archivos groovy se asignan a ''{0}''.\nPuedes asignarlos a Groovy en Configuración | Tipos de archivo
groovy.library.is.not.configured.for.module=Groovy SDK no está configurado para el módulo ''{0}''
groovy.library.label=Groovy 라이브러리
groovy.term.annotation=anotación
groovy.term.binding=variable de enlace de script
groovy.term.class=clase
groovy.term.closure=cierre
groovy.term.enum=enumeración
groovy.term.expression=Expresión
groovy.term.field=campo
groovy.term.interface=interfaz
groovy.term.label=etiqueta
groovy.term.method=método
groovy.term.parameter=parámetro
groovy.term.property=propiedad
groovy.term.record=레코드
groovy.term.trait=rasgo
groovy.term.type.parameter=타입 매개변수
groovy.term.variable=variable local
groovy.version.0=Groovy {0}
groovy.version.bundled.0=번들 Groovy {0}
group.Groovy.CheckResources.description=Ejecute el compilador de archivos Groovy en las raíces de recursos para comprobar si hay problemas de compilación
group.Groovy.CheckResources.text=Gr_oovy Recursos
header.extract.closure=클로저 추출
highlight.if.groovy.object.methods.overridden=invokeMethod(), getProperty() 또는 setProperty()를 재정의하는 클래스에서 참조 강조 표시
highlight.if.missing.methods.declared=missingMethod() 또는 missingProperty()를 선언하는 클래스에서 참조 강조 표시
identifier.expected=Identificador esperado
identifier.or.block.expected=Identificador o bloque de código esperado
ignore.boolean.expressions=부울 검사 시 대입되지 않은 변수 무시
ignore.when.catch.parameter.is.named.ignore.or.ignored=catch 매개변수의 이름이 ignore 또는 ignored로 지정된 경우 무시
illegal.combination.of.modifiers=Combinación ilegal de modificadores
illegal.combination.of.modifiers.abstract.and.final=Combinación ilegal de modificadores 'abstracto' y 'final'
illegal.combination.of.modifiers.volatile.and.final=Combinación ilegal de modificadores 'volátil' y 'final'
illegal.default.modifier=El modificador 'predeterminado' solo tiene sentido en los métodos de la interfaz
illegal.default.modifier.fix=Eliminar modificador 'predeterminado'
illegal.escape.character.in.string.literal=Carácter de escape ilegal en literal de cadena
illegal.method.name=El nombre del método contiene caracteres ilegales: {0}
illegal.nonsealed.modifier.fix='non-sealed' 제어자 제거
illegal.sealed.modifier.fix='sealed' 제어자 제거
illegal.single.argument.lambda=La forma de un solo argumento de lambda está disponible solo como parte derecha de la expresión de asignación o como argumento dentro de la llamada al método
illegal.type.void=Tipo ilegal: 'void'
immutable.options.property.not.exist=La propiedad ''{0}'' no existe
implement.class={0} 구현
import.statement.cannot.have.modifiers=La declaración de importación no puede tener modificadores
incorrect.number.of.values=Número incorrecto de valores. Esperado: {0} Era: {1}
incorrect.variable.name=Nombre de variable incorrecto
indexed.property.is.applicable.to.properties.only=@IndexedProperty를 프로퍼티에만 적용할 수 없습니다
infer.method.parameters.types=명시적 유형을 매개변수에 추가
infer.method.parameters.types.for.method.declaration=메서드 선언 내 모든 매개변수의 명시적 유형을 추가
initializer.cannot.be.0=El inicializador no puede ser {0}
initializer.cannot.have.annotations=Los inicializadores no pueden tener anotaciones
initializers.are.forbidden.with.defaults=@TupleConstructor에서 ''defaults''를 비활성화하면 기본값은 금지됩니다
initializers.are.not.allowed.in.interface=Los inicializadores no están permitidos en la interfaz
injection.should.not.contain.line.feeds=La inyección GString no debe contener avances de línea
inlay.groovy.implicit.null.argument.hint.description=하나의 인수를 사용하는 메서드에 인수를 전달하지 않는 호출입니다. 즉, 묵시적 null이 인수로 전달됩니다.
inlay.groovy.parameters.hints.inferred.parameter.types=메서드에서 추론된 매개변수 타입.
inlay.groovy.parameters.hints.type.parameter.list=하나 이상의 추론 타입 매개변수가 있는 메서드가 있습니다. <b>추론된 매개변수 타입<b/> 힌트가 필요합니다.
inlay.groovy.variable.type.hints.description=선언에서 명시적으로 지정되지 않은 지역 변수 타입입니다.
inspection.annotations=Verificación de anotaciones
inspection.assignments=Problemas de asignación
inspection.bugs=Errores probables
inspection.confusing=Construcciones de código potencialmente confusas
inspection.control.flow=Problemas de flujo de control
inspection.data.flow=Flujo de datos
inspection.display.name.access.to.inaccessible.element=Acceso a elemento inaccesible
inspection.display.name.access.to.static.field.locked.on.instance=Acceso al campo estático bloqueado en datos de instancia
inspection.display.name.annotation.references.unknown.identifier=''includes'' 및 ''excludes'' 속성 내 알 수 없는 식별자
inspection.display.name.assignability.check=Asignaciones de tipos incompatibles
inspection.display.name.assignment.can.be.operator.assignment=Asignación reemplazable por asignación de operador
inspection.display.name.assignment.to.for.loop.parameter=Asignación al parámetro de bucle for
inspection.display.name.assignment.to.method.parameter=Asignación al parámetro del método
inspection.display.name.break=Declaración de ruptura
inspection.display.name.busy.wait=Espera ocupada
inspection.display.name.change.to.method=Cambiar a método
inspection.display.name.change.to.operator=Cambiar a operador
inspection.display.name.check.labeled.statement=Inspección de declaración etiquetada
inspection.display.name.clashing.getters=Captadores en conflicto
inspection.display.name.clashing.trait.methods=Métodos de rasgos en conflicto
inspection.display.name.class.naming.convention=Convención de nomenclatura de clases
inspection.display.name.conditional=Expresión condicional
inspection.display.name.conditional.can.be.conditional.call=La expresión condicional puede ser una llamada condicional
inspection.display.name.conditional.can.be.elvis=La expresión condicional puede ser elvis
inspection.display.name.conditional.with.identical.branches=Expresión condicional con ramas idénticas
inspection.display.name.constant.conditional=Expresión condicional constante
inspection.display.name.constant.if.statement=Constante si declaración
inspection.display.name.constant.naming.convention=Convención de nomenclatura constante
inspection.display.name.constructor.named.arguments=Argumentos nombrados de la llamada al constructor
inspection.display.name.continue=Continuar declaración
inspection.display.name.continue.or.break.from.finally.block=continuar' o 'romper' dentro del bloque 'finalmente
inspection.display.name.delegates.to=@DelegatesTo inspección
inspection.display.name.deprecated.api.usage=Inspección de API obsoleta
inspection.display.name.divide.by.zero=Dividir por cero
inspection.display.name.double.checked.locking=Bloqueo verificado dos veces
inspection.display.name.double.negation=Doble negación
inspection.display.name.duplicate.switch.branch=Caso de interruptor duplicado
inspection.display.name.empty.catch.block=Bloque 'catch' vacío
inspection.display.name.empty.finally.block=Bloque 'finally' vacío
inspection.display.name.empty.statement.body=Declaración con cuerpo vacío
inspection.display.name.empty.sync.block=Bloque vacío 'sincronizado'
inspection.display.name.empty.try.block=Bloque 'try' vacío
inspection.display.name.equals.between.inconvertible.types='equals()' entre objetos de tipos inconvertibles
inspection.display.name.fallthrough=Fallthrough en la declaración de cambio
inspection.display.name.final.variable.access=Acceso a la variable final
inspection.display.name.groovydoc.check=Problemas con GroovyDoc
inspection.display.name.gstring.key=Clave del mapa GString
inspection.display.name.if.statement.with.identical.branches=Declaración If con ramas idénticas
inspection.display.name.if.statement.with.too.many.branches=Declaración If con demasiadas ramas
inspection.display.name.implicit.null.argument=묵시적 null 인수
inspection.display.name.in.argument.check=Tipos de argumentos 'in' incompatibles
inspection.display.name.incorrect.range.argument=Argumentos de rango incorrectos
inspection.display.name.infinite.loop.statement=Declaración de bucle infinito
inspection.display.name.infinite.recursion=Recursión infinita
inspection.display.name.instance.method.naming.convention=Convención de nomenclatura del método de instancia
inspection.display.name.instance.variable.naming.convention=Convención de nomenclatura de variables de instancia
inspection.display.name.java.style.properties.invocation=Acceso a la propiedad estilo Java
inspection.display.name.list.get.can.be.keyed.access=Llamar a List.get puede ser acceso por clave
inspection.display.name.list.set.can.be.keyed.access=Llamar a List.set puede ser acceso por clave
inspection.display.name.local.variable.naming.convention=Convención de nomenclatura de variables locales
inspection.display.name.loop.statement.that.doesnt.loop=Declaración de bucle que no se repite
inspection.display.name.map.get.can.be.keyed.access=La llamada a Map.get puede ser acceso por clave
inspection.display.name.map.put.can.be.keyed.access=La llamada a Map.put puede ser acceso por clave
inspection.display.name.method.may.be.static=El método puede ser estático
inspection.display.name.method.parameter.count=Método con demasiados parámetros
inspection.display.name.method.with.more.than.three.negations=3개 이상의 부정이 있는 메서드
inspection.display.name.multiple.return.points.per.method=Método con múltiples puntos de retorno
inspection.display.name.negated.conditional=Expresión condicional negada
inspection.display.name.negated.if=Expresión de condición si se niega
inspection.display.name.nested.assignment=Asignación anidada
inspection.display.name.nested.conditional=Expresión condicional anidada
inspection.display.name.nested.switch=Instrucción de cambio anidada
inspection.display.name.nested.synchronized.statement=Declaración 'sincronizada' anidada
inspection.display.name.new.instance.of.singleton=Nueva instancia de clase anotada con @groovy.lang.Singleton
inspection.display.name.no.return=Falta la declaración de retorno
inspection.display.name.non.extending.permitted.subclasses=확장이 허용되지 않은 하위 클래스
inspection.display.name.non.short.circuit.boolean=Booleano sin cortocircuito
inspection.display.name.notify.while.not.synchronized='notificar()' o 'notificar a todos()' mientras no esté sincronizado
inspection.display.name.octal.integer=Entero octal
inspection.display.name.overly.complex.arithmetic.expression=Expresión aritmética demasiado compleja
inspection.display.name.overly.complex.boolean.expression=Expresión booleana demasiado compleja
inspection.display.name.overly.complex.method=Método demasiado complejo
inspection.display.name.overly.long.method=Método demasiado largo
inspection.display.name.overly.nested.method=Método demasiado anidado
inspection.display.name.package.mismatch=No coincide el paquete
inspection.display.name.parameter.naming.convention=Convención de nomenclatura de parámetros de método
inspection.display.name.pointless.arithmetic=Expresión aritmética sin sentido
inspection.display.name.pointless.boolean=Expresión booleana sin sentido
inspection.display.name.pojo.without.compile.static=@CompileStatic 없는 @POJO
inspection.display.name.public.field.accessed.in.synchronized.context=Campo no privado al que se accede en contexto sincronizado
inspection.display.name.reassigned.in.closure.local.var=La variable local se reasigna en cierre o clase anónima
inspection.display.name.result.of.assignment.used=Resultado de la asignación utilizada
inspection.display.name.result.of.increment.or.decrement.used=Resultado del incremento o decremento utilizado
inspection.display.name.result.of.object.allocation.ignored=Resultado de la asignación del objeto ignorado
inspection.display.name.return.from.closure.can.be.implicit=la declaración 'return' puede ser implícita
inspection.display.name.return.from.finally.block=return' dentro del bloque 'finally
inspection.display.name.second.unsafe.call=Segunda llamada insegura
inspection.display.name.silly.assignment=Tarea tonta
inspection.display.name.singleton.constructor=Constructor @Singleton
inspection.display.name.static.method.naming.convention=Convención de nomenclatura de métodos estáticos
inspection.display.name.static.variable.naming.convention=Convención de nomenclatura de variables estáticas
inspection.display.name.string.style.violation=문자열 스타일 위반
inspection.display.name.switch.exhaustiveness.check=switch 식의 완전성 확인
inspection.display.name.switch.statement.with.no.default=Sentencia de cambio sin caso predeterminado
inspection.display.name.synchronization.on.non.final.field=Sincronización en campo no final
inspection.display.name.synchronization.on.this=Sincronización en 'esto'
inspection.display.name.synchronization.on.variable.initialized.with.literal=Sincronización en variable inicializada con literal
inspection.display.name.synchronized.method=Método sincronizado
inspection.display.name.system.run.finalizers.on.exit=Llamada a System.runFinalizersOnSalir()
inspection.display.name.thread.stop.suspend.resume=Llamada a Thread.stop(), Thread.suspend() o Thread.resume()
inspection.display.name.throw.from.finally.block=throw' dentro del bloque 'finally
inspection.display.name.trivial.conditional=Expresión condicional redundante
inspection.display.name.trivial.if=Declaración 'if' redundante
inspection.display.name.type.customizer=Tipo de inspección del personalizador
inspection.display.name.unassigned.access=Variable No asignada
inspection.display.name.unchecked.assignment.of.member.of.raw.type=Asignación no verificada de miembros de tipo crudo
inspection.display.name.unconditional.wait=Llamada de 'espera' incondicional
inspection.display.name.unnecessary.alias=Alias de importación innecesario
inspection.display.name.unnecessary.continue=Declaración 'continuar' innecesaria
inspection.display.name.unnecessary.def.modifier='def' innecesario
inspection.display.name.unnecessary.final.modifier=불필요한 'final'
inspection.display.name.unnecessary.non.sealed.modifier=불필요한 'non-sealed' 제어자
inspection.display.name.unnecessary.public.modifier='público' innecesario
inspection.display.name.unnecessary.qualified.reference=Referencia calificada innecesaria
inspection.display.name.unnecessary.return=Declaración de 'retorno' innecesaria
inspection.display.name.unnecessary.sealed.modifier=불필요한 'sealed' 제어자
inspection.display.name.unnecessary.semicolon=Punto y coma innecesario
inspection.display.name.unreachable.statement=Declaración inalcanzable
inspection.display.name.unresolved.access=Acceso a expresión no resuelta
inspection.display.name.unresolved.labels.in.named.variant=@NamedVariant/@NamedParam/@NamedDelegate 변환 뒤 해결되지 않은 라벨
inspection.display.name.unsynchronized.method.overrides.synchronized.method=El método no sincronizado anula el método sincronizado
inspection.display.name.untyped.access=Acceso a expresión sin tipo
inspection.display.name.unused.assignment=Asignación no utilizada
inspection.display.name.unused.catch.parameter=Parámetro de captura no utilizado
inspection.display.name.unused.declaration=Declaración no utilizada
inspection.display.name.unused.inc.dec=Incremento o decremento no utilizado
inspection.display.name.variable.can.be.final=La variable puede ser final
inspection.display.name.wait.call.not.in.loop='wait()' no está en bucle
inspection.display.name.wait.while.not.synchronized='esperar()' mientras no está sincronizado
inspection.display.name.while.loop.spins.on.field=Mientras el bucle gira en el campo
inspection.error.handling=Manejo de errores
inspection.gpath=GPath
inspection.message.0.not.allowed.for.record=''{0}''은(는) 레코드에서 허용되지 않습니다
inspection.message.access.to.static.field.locked.on.instance.data=static 필드 <code>\#ref</code> 로의 액세스가 인스턴스 데이터에서 잠김 \#loc
inspection.message.annotation.non.sealed.cannot.be.applied.to.enum.class=어노테이션 '@NonSealed'는 열거형 클래스에 적용할 수 없습니다
inspection.message.annotation.sealed.cannot.be.applied.to.enum.class=어노테이션 '@Sealed'는 열거형 클래스에 적용할 수 없습니다
inspection.message.arrows.in.case.expressions.are.available.with.groovy.4.or.later=Case 식의 화살표는 Groovy 4.0 이상에서 사용할 수 있습니다
inspection.message.assignment.replaceable.with.operator.assignment=<code>\#ref</code>을(를) ''{0}'' (으)로 단순활할 수 있습니다 \#loc
inspection.message.assignment.to.for.loop.parameter=for 루프 매개변수 ''\#ref''에 대입 \#loc
inspection.message.assignment.to.method.parameter=메서드 매개변수 ''\#ref''에 대입 \#loc
inspection.message.both.open.ranges.are.available.in.groovy.4.or.later=양쪽 열림 범위는 Groovy 4.0 이상에서 사용할 수 있습니다
inspection.message.call.to.ref.can.be.keyed.access=''\#ref'' 호출이 키 액세스일 수 있습니다 \#loc
inspection.message.call.to.ref.outside.of.loop=루프 밖에서 ''\#ref'' 호출 \#loc
inspection.message.call.to.ref.outside.of.synchronized.context=동기화된 컨텍스트 외부의 ''\#ref'' 호출 \#loc
inspection.message.call.to.ref.outside.synchronized.context=동기화된 컨텍스트 외부의 ''\#ref'' 호출 \#loc
inspection.message.call.to.system.ref=''System.\#ref'' 호출 \#loc
inspection.message.call.to.thread.ref=''스레드.\#ref'' 호출 \#loc
inspection.message.call.to.thread.ref.in.a.loop=루프 내 <code>Thread.\#ref()</code>에 대한 호출이 바쁜 대기 중일 수 있습니다 \#loc
inspection.message.cannot.determine.type.ref=''\#ref''의 유형을 파악할 수 없음
inspection.message.cannot.resolve.method.call=메서드 'call'을 해결할 수 없습니다
inspection.message.case.or.default.branches.are.expected='case' 또는 'default' 브랜치가 필요합니다
inspection.message.class.cannot.be.non.sealed.without.sealed.parent=클래스 ''{0}''은(는) sealed 상위 없이 non-sealed일 수 없습니다
inspection.message.class.has.no.explicit.or.implicit.subclasses=클래스 ''{0}''에 명시적 또는 묵시적으로 허용된 하위 클래스가 없습니다
inspection.message.code.ref.code.recurses.infinitely.can.only.complete.by.throwing.exception=<code>\#ref</code>이(가) 무한 반복되며 예외를 던져야 완료됩니다 \#loc
inspection.message.code.ref.code.statement.doesnt.loop=<code>\#ref</code> 문이 루프되지 않습니다 \#loc
inspection.message.compact.constructor.should.have.explicit.visibility.modifier=압축 생성자는 명시적 가시성 제어자가 있어야 합니다
inspection.message.conditional.expression=조건식 \#loc
inspection.message.conditional.expression.can.be.call=조건식이 호출일 수 있습니다 \#loc
inspection.message.conditional.expression.can.be.elvis=조건식이 elvis일 수 있습니다 \#loc
inspection.message.conditional.expression.with.identical.branches=동일한 브랜치가 있는 조건식 \#loc
inspection.message.constant.name.ref.doesnt.match.regex=상수 이름 ''\#ref''이(가) 정규식 ''{0}'' 와(과) 일치하지 않습니다 \#loc
inspection.message.constant.name.ref.too.long=상수 이름 ''\#ref''이(가) 너무 깁니다
inspection.message.constant.name.ref.too.short=상수 이름 ''\#ref''이(가) 너무 짧습니다
inspection.message.couldnt.find.property.field.with.this.name=이 이름을 가진 프로퍼티 또는 필드를 프레임을 찾을 수 없음 \#loc
inspection.message.divide.by.zero=0으로 나누기 \#loc
inspection.message.double.checked.locking=이중 검사된 잠금 \#loc
inspection.message.double.negation.ref=이중 부정 \#ref \#loc
inspection.message.dsl.descriptor.file.has.been.changed.and.isnt.currently.executed=DSL 기술자 파일이 변경되어 현재 실행되고 있지 않습니다.
inspection.message.dsl.descriptor.file.has.been.disabled.due.to.processing.error=처리 오류 때문에, DSL 기술자 파일이 비활성화 되었습니다.
inspection.message.duplicate.switch.case.ref=중복 switch case ''\#ref'' \#loc
inspection.message.empty.ref.block=빈 ''\#ref'' 블록 \#loc
inspection.message.fallthrough.in.switch.statement=switch 문의 폴스루 \#loc
inspection.message.fraction.literals.without.leading.zero.are.available.in.groovy.or.later=선행 0이 없는 프랙션 리터럴은 Groovy 4.0 이상에서 사용할 수 있습니다
inspection.message.gstring.used.as.maps.key=GString가 맵 키로 사용되었습니다 \#loc
inspection.message.instance.method.name.ref.doesnt.match.regex=인스턴스 메서드 이름 ''\#ref''이(가) 정규식 ''{0}'' 와(과) 일치하지 않습니다 \#loc
inspection.message.instance.method.name.ref.too.long=인스턴스 메서드 이름 ''\#ref''이(가) 너무 깁니다
inspection.message.instance.method.name.ref.too.short=인스턴스 메서드 이름 ''\#ref''이(가) 너무 짧습니다
inspection.message.instance.variable.name.ref.doesn.t.match.regex=인스턴스 변수 이름 ''\#ref''이(가) 정규식 ''{0}'' 와(과) 일치하지 않습니다 \#loc
inspection.message.instance.variable.name.ref.too.long=인스턴스 변수 이름 ''\#ref''이(가) 너무 깁니다
inspection.message.instance.variable.name.ref.too.short=인스턴스 변수 이름 ''\#ref''이(가) 너무 짧습니다
inspection.message.interface.cannot.be.non.sealed.without.sealed.parent=인터페이스 ''{0}''은(는) sealed 상위 없이 non-sealed일 수 없습니다
inspection.message.interface.has.no.explicit.or.implicit.implementors=인터페이스 ''{0}''에 명시적 또는 묵시적으로 허용된 구현자가 없습니다
inspection.message.interpolated.string.should.be.dollar.slashy.quoted=보간된 문자열은 달러 슬래시로 묶어야 합니다
inspection.message.interpolated.string.should.be.double.quoted=보간된 문자열은 큰따옴표로 묶어야 합니다
inspection.message.interpolated.string.should.be.quoted.with.triple.double.quotes=보간된 문자열은 '"""로 묶어야 합니다
inspection.message.interpolated.string.should.be.slashy.quoted=보간된 문자열은 슬래시로 묶어야 합니다
inspection.message.invalid.permits.clause.must.be.sealed=잘못된 ''permits'' 절: ''{0}''이(가) ''sealed''여야 합니다
inspection.message.invalid.permits.clause.must.directly.extend=잘못된 ''permits'' 절: ''{0}''이(가) ''{1}''을(를) 직접 확장해야 합니다
inspection.message.keyword.yield.available.with.groovy.4.or.later=키워드 'yield'는 Groovy 4.0 이상에서 사용할 수 있습니다
inspection.message.label.name.ref.not.supported.by.0={0} 은(는) 라벨 이름 ''\#ref''을(를) 지원하지 않습니다
inspection.message.left.open.ranges.are.available.in.groovy.4.or.later=왼쪽 열림 범위는 Groovy 4.0 이상에서 사용할 수 있습니다
inspection.message.local.variable.name.ref.doesnt.match.regex=지역 변수 이름 ''\#ref''이(가) 정규식 ''{0}'' 와(과) 일치하지 않습니다 \#loc
inspection.message.local.variable.name.ref.too.long=지역 변수 이름 ''\#ref''이(가) 너무 깁니다
inspection.message.local.variable.name.ref.too.short=지역 변수 이름 ''\#ref''이(가) 너무 짧습니다
inspection.message.method.called.with.implicit.null.argument=메서드는 묵시적 null 인수로 호출됩니다
inspection.message.method.parameter.name.ref.doesnt.match.regex=메서드 매개변수 이름 ''\#ref''이(가) 정규식 ''{0}'' 와(과) 일치하지 않습니다 \#loc
inspection.message.method.parameter.name.ref.too.long=메서드 매개변수 이름 ''\#ref''이(가) 너무 깁니다
inspection.message.method.parameter.name.ref.too.short=메서드 매개변수 이름 ''\#ref''이(가) 너무 짧습니다
inspection.message.method.ref.contains.too.many.parameters.0.1=모듈 ''\#ref''에 매개변수가 너무 많습니다({0}>{1})
inspection.message.method.ref.has.too.many.negations=메서드 ''\#ref''에 부정이 너무 많습니다({0}>3)
inspection.message.method.ref.overly.complex.cyclomatic.complexity=메서드 ''\#ref'' 이(가) 지나치게 복잡합니다(순환 복잡성 \={0}>{1})
inspection.message.method.ref.overly.nested.nesting.depth=메서드 ''\#ref''이(가) 과도하게 중첩되어 있습니다(중첩 깊이 \={0}>{1})
inspection.message.method.ref.too.long.statement.count=메서드 ''\#ref''이(가) 지나치게 깁니다(구문 수 \={0}>{1}})
inspection.message.mixing.arrows.colons.not.allowed=화살표와 콜론은 혼용할 수 없습니다
inspection.message.modifier.non.sealed.cannot.be.applied.to.enum.class=제어자 'non-sealed'는 열거형 클래스에 적용할 수 없습니다
inspection.message.modifier.nonsealed.available.with.groovy.or.later=제어자 'non-sealed'는 Groovy 4.0 이상에서 사용할 수 있습니다
inspection.message.modifier.sealed.available.with.groovy.or.later=제어자 'sealed'는 Groovy 4.0 이상에서 사용할 수 있습니다
inspection.message.modifier.sealed.cannot.be.applied.to.enum.class=제어자 'sealed'는 열거형 클래스에 적용할 수 없습니다
inspection.message.multiline.string.should.be.dollar.slashy.quoted=여러 줄 문자열은 달러 슬래시로 묶어야 합니다
inspection.message.multiline.string.should.be.quoted.with.triple.double.quotes=여러 줄 문자열은 """로 묶어야 합니다
inspection.message.multiline.string.should.be.quoted.with.triple.quotes=여러 줄 문자열은 ''''로 묶어야 합니다
inspection.message.multiline.string.should.be.slashy.quoted=여러 줄 문자열은 슬래시로 묶어야 합니다
inspection.message.multiple.expressions.in.case.section.are.available.with.groovy.4.or.later=Case 라벨의 다중 표현식은 Groovy 4.0 이상에서 사용할 수 있습니다
inspection.message.negated.conditional.expression=부정된 조건식 \#loc
inspection.message.negated.if.condition.expression=부정된 if 조건식 \#loc
inspection.message.nested.assignment=대입 표현식의 결과가 사용되었습니다 \#loc
inspection.message.nested.assignment.expression=중첩된 대입식 \#loc
inspection.message.nested.conditional.expression=중첩된 조건식 \#loc
inspection.message.nested.ref.statement=중첩된 ''\#ref'' 문 \#loc
inspection.message.non.private.field.accessed.in.synchronized.context=동기화된 컨텍스트에서 비 private 필드 <code>\#ref</code>이(가) 액세스됩니다 \#loc
inspection.message.non.short.circuit.boolean.expression=비단락 회로 부울 표현식 \#loc
inspection.message.not.allowed.in.sealed.hierarchy=''{0}''은(는) sealed 계층 구조에서 허용되지 않습니다
inspection.message.octal.integer.ref=8진 정수 \#ref \#loc
inspection.message.only.one.final.sealed.non.sealed.should.be.applied.to.class='final', 'sealed', 'non-sealed', @Sealed 또는 @NonSealed 중 하나만 클래스에 적용해야 합니다
inspection.message.overly.complex.arithmetic.expression=지나치게 복잡한 산술 표현식 \#loc
inspection.message.overly.complex.boolean.expression=지나치게 복잡한 부울 표현식 \#loc
inspection.message.package.name.mismatch=패키지 이름 불일치
inspection.message.package.name.mismatch.actual.0.expected.1=패키지 이름 불일치. 실제\: ''{0}'', 필요\: ''{1}''
inspection.message.permits.available.with.groovy.4.or.later='permits'는 Groovy 4.0 이상에서 사용할 수 있습니다
inspection.message.plain.string.should.be.dollar.slashy.quoted=일반 문자열은 달러 슬래시로 묶어야 합니다
inspection.message.plain.string.should.be.double.quoted=일반 문자열은 큰따옴표로 묶어야 합니다
inspection.message.plain.string.should.be.quoted.with.triple.double.quotes=일반 문자열은 '"""로 묶어야 합니다
inspection.message.plain.string.should.be.quoted.with.triple.quotes=일반 문자열은 ''''로 묶어야 합니다
inspection.message.plain.string.should.be.single.quoted=일반 문자열은 작은따옴표로 묶어야 합니다
inspection.message.plain.string.should.be.slashy.quoted=일반 문자열은 슬래시로 묶어야 합니다
inspection.message.pojo.has.effect.only.with.compilestatic=@POJO는 @CompileStatic이 있을 때만 효과가 있습니다
inspection.message.property.0.is.final=프로퍼티 ''{0}'' 이(가) final입니다 \#loc
inspection.message.property.0.is.ignored.by.map.constructor=프로퍼티 ''{0}'' 이(가) @MapConstructor에 의해 무시되었습니다 \#loc
inspection.message.property.not.indexable.type.must.be.array.or.list.but.found.0=속성은 색인화할 수 없습니다. 유형은 배열 또는 목록이어야 하나 {0} 를 찾았습니다
inspection.message.record.parameter.should.be.immutable=레코드 매개변수 ''{0}''은(는) 불변 타입을 포함하거나 @ImmutableOptions를 통해 불변 타입으로 선언되어야 합니다
inspection.message.records.are.available.in.groovy.4.or.later=레코드는 Groovy 4.0.0-beta-2 이상에서 사용할 수 있습니다
inspection.message.ref.can.be.simplified=''\#ref''을(를) 단순화할 수 있습니다 \#loc
inspection.message.ref.has.0.return.points=<code>\#ref</code>에 {0} 개의 반환점이 있습니다 \#loc
inspection.message.ref.inside.finally.block=''finally'' 블록 내 ''\#ref'' \#loc
inspection.message.ref.is.unnecessary.as.last.statement.in.loop=루프의 마지막 구문으로서 \#ref 은(는) 불필요합니다 \#loc
inspection.message.ref.is.unnecessary.as.last.statement.in.method.with.no.return.value=반환값이 없는 메서드의 마지막 구문으로서 \#ref 은(는) 불필요합니다 \#loc
inspection.message.ref.loop.spins.on.field=<code>\#ref</code> 루프가 필드에서 스핀합니다 \#loc
inspection.message.ref.statement=\#ref 문 \#loc
inspection.message.ref.statement.at.end.closure.can.be.made.implicit=클로저 끝의 \#ref 문을 묵시적으로 만들 수 있습니다 \#loc
inspection.message.ref.statement.can.be.simplified=\#ref 문을 단순화할 수 있습니다 \#loc
inspection.message.ref.statement.cannot.complete.without.throwing.exception=<code>\#ref</code> 문은 예외를 던지지 않으면 완료되지 않습니다 \#loc
inspection.message.ref.statement.has.empty.body=''\#ref'' 문의 본문이 비어 있습니다
inspection.message.ref.statement.has.empty.branch=''\#ref'' 문의 브랜치가 비어 있습니다
inspection.message.ref.statement.with.identical.branches=동일한 브랜치가 있는 ''\#ref'' 문 \#loc
inspection.message.ref.statement.with.no.default.branch=default 브랜치가 없는 \#ref 문 \#loc
inspection.message.ref.statement.with.too.many.branches=''\#ref'' 문에 브랜치가 너무 많음({0}) \#loc
inspection.message.result.increment.or.decrement.expression.used=사용된 증분 또는 감소 표현식의 결과 \#loc
inspection.message.result.of.new.ref.is.ignored=<code>새 \#ref{0}</code>의 결과가 무시되었습니다 \#loc
inspection.message.silly.assignment=잘못된 대입 \#loc
inspection.message.static.interface.methods.must.be.qualified.in.groovy.4=Groovy 4부터 '정적' 인터페이스 메서드를 사용할 수 있어야 합니다.
inspection.message.static.method.name.ref.doesnt.match.regex=정적 메서드 이름 ''\#ref''이(가) 정규식 ''{0}'' 와(과) 일치하지 않습니다 \#loc
inspection.message.static.method.name.ref.too.long=정적 메서드 이름 ''\#ref''이(가) 너무 깁니다
inspection.message.static.method.name.ref.too.short=정적 메서드 이름 ''\#ref''이(가) 너무 짧습니다
inspection.message.static.variable.name.ref.doesnt.match.regex=정적 변수 이름 ''\#ref''이(가) 정규식 ''{0}'' 와(과) 일치하지 않습니다 \#loc
inspection.message.static.variable.name.ref.too.long=정적 변수 이름 ''\#ref''이(가) 너무 깁니다
inspection.message.static.variable.name.ref.too.short=정적 변수 이름 ''\#ref''이(가) 너무 짧습니다
inspection.message.string.escaping.could.be.minimized=이스케이프를 최소화할 수 있습니다
inspection.message.switch.expression.does.not.cover.all.possible.outcomes=switch 식이 모든 가능한 결과를 포함하지 않습니다
inspection.message.switch.expressions.are.available.with.groovy.4.or.later=Switch 식은 Groovy 4.0 이상에서 사용할 수 있습니다
inspection.message.switch.expressions.do.not.support.return=switch 식은 'return'을 지원하지 않습니다
inspection.message.synchronization.on.non.final.field.ref=비 final 필드 ''\#ref'' 동기화 \#loc
inspection.message.synchronization.on.ref=\ ''\#ref'' 동기화 \#loc
inspection.message.synchronization.on.variable.ref.which.was.initialized.with.literal=리터럴로 초기화된 변수 ''\#ref'' 동기화 \#loc
inspection.message.synchronized.method.ref=동기화된 메서드 ''\#ref'' \#loc
inspection.message.traits.0.contain.clashing.methods.with.signature.1=특성 {0} 이(가) 시그니처 {1} 이 있는 충돌 메서드를 포함합니다
inspection.message.trivial.conditional.expression=자명한 조건 표현식 #loc
inspection.message.type.argument.0.can.not.be.1=인수 ''{0}'' 의 유형이 ''{1}'' 일 수 없습니다
inspection.message.unconditional.call.to.ref=<code>\#ref()</code>을(를) 조건 없이 호출합니다 \#loc
inspection.message.unreachable.statement=도달할 수 없는 명령문 \#loc
inspection.message.unsynchronized.method.ref.overrides.synchronized.method=비동기화된 메서드 ''\#ref'' 이(가) 동기화된 메서드를 재정의합니다 \#loc
inspection.message.unused.catch.parameter.ref=사용되지 않은 catch 매개변수 ''\#ref'' \#loc
inspection.message.yield.or.throw.expected.in.case.section='yield' 또는 'throw'가 case 섹션에 필요합니다
inspection.method.metrics=Métricas del método
inspection.naming=Convenciones de nomenclatura
inspection.other=Otro
inspection.redundancy=Declaración de redundancia
inspection.separator.disable.in.file.types=다음의 파일 형식에서 활성화:
inspection.style=Estilo
inspection.threading=Problemas de subprocesos
inspection.validity=Problemas de validez
intention.category.closures=Groovy/Closures
intention.category.comments=Groovy/Comentarios
intention.category.control.flow=Groovy/Control de flujo
intention.category.conversions=Conversiones Groovy/Expression
intention.category.groovy=Groovy
intention.category.groovy.declaration=Groovy/Declaración
intention.category.groovy.other=Groovy/Otro
intention.category.groovy.style=Groovy/Groovy-style
intention.family.name.activate.dsl.descriptor=DSL 설명자 활성화
intention.family.name.add.attributes.to.annotation=어노테이션에 속성 추가
intention.family.name.add.cast=형 변환 추가
intention.family.name.add.class.to.clause=절에 클래스 추가
intention.family.name.add.missing.case.branches=누락된 case 브랜치 추가
intention.family.name.add.parameter.cast=매개변수 형 변환 추가
intention.family.name.change.variable.type=변수 유형 변경
intention.family.name.collapse.conditional.expressions=조건식 접기
intention.family.name.collapse.if.statement=''if'' 문'' 접기
intention.family.name.convert.conditional.expression.to.elvis=조건식을 elvis로 변환
intention.family.name.create.field=필드 생성
intention.family.name.fix.quotation=따옴표 수정
intention.family.name.fix.range.class=범위 등급 수정
intention.family.name.make.return.implicit=반환을 묵시적으로 설정
intention.family.name.remove.double.negation=이중 부정 제거
intention.family.name.remove.unnecessary.continue=불필요한 continue 제거
intention.family.name.remove.unnecessary.return=불필요한 return 제거
intention.family.name.rename=이름 변경
intention.family.name.replace.for.each.operator=for-each 연산자 바꾸기
intention.family.name.replace.keywords=요소 대치
intention.family.name.replace.modifiers=제어자 바꾸기
intention.family.name.replace.something.with=''{0}'' 을(를) ''{1}'' (으)로 바꾸기
intention.family.name.replace.with.conditional.call=조건 호출로 바꾸기
intention.family.name.replace.with.keyed.access=키 액세스로 바꾸기
intention.family.name.replace.with.short.circuit.expression=단락 표현식으로 바꾸기
intention.family.name.simplify=단순화
intention.name.activate.back=다시 활성화
intention.name.add.required.attributes.to.map.constructor=@MapConstructor에 필수 속성 추가
intention.name.add.to.clause=''{0}''을(를) ''{2}''의 {1} 절에 추가
intention.name.cast.operand.to.0=피연산자를 {0} (으)로 형 변환
intention.name.cast.to.0={0} (으)로 형 변환
intention.name.change.quotes.to.triple.double.quotes=따옴표를 """로 변경
intention.name.change.quotes.to.triple.single.quotes=따옴표를 "로 변경
intention.name.convert.to.dollar.slashy.string=달러 슬래시 문자열로 변환
intention.name.convert.to.double.quoted.string=큰따옴표로 묶인 문자열로 변환
intention.name.convert.to.single.quoted.string=작은따옴표로 묶인 문자열로 변환
intention.name.convert.to.slashy.string=슬래시 문자열로 변환
intention.name.create.abstract.method.in.class=''{1}''에 추상 메서드 ''{0}'' 생성
intention.name.create.constant.field.in.class=''{1}''에 상수 필드 ''{0}'' 생성
intention.name.create.enum.constant.0=enum 상수 ''{0}'' 생성
intention.name.create.field.in.class=''{1}''에 필드 ''{0}'' 생성
intention.name.create.method.in.class=''{1}''에 메서드 ''{0}'' 생성
intention.name.insert.case.0=''case {0}'' 삽입
intention.name.insert.case.0.case.1=''case {0}'', ''case {1}'' 삽입
intention.name.insert.default.branch='default' 브랜치 삽입
intention.name.insert.missing.branches=누락된 브랜치 삽입
intention.name.make.compact.constructor.public=압축 생성자를 'public'으로 만들기
intention.name.remove.wrong.modifiers.for.record=잘못된 기록용 제어자 제거
intention.name.replace=''{0}''을(를) ''{1}''(으)로 바꾸기
intention.name.replace.eq.with.0.eq=''\=''를 ''{0}\=''로 바꾸기
intention.name.replace.with.in=''\:''을 ''in''으로 바꾸기
intention.name.replace.with.qualified.expression=정규화된 이름으로 바꾸기
interface.cannot.have.modifier.final=La interfaz no puede tener el modificador 'final'
interface.members.are.not.allowed.to.be=Los miembros de la interfaz no pueden ser {0}
interface.must.have.no.static.method=La interfaz no debe tener un método estático
introduce.constant.title=상수 삽입
introduce.parameter.delegate.via.overload=오버로드 메서드를 통한 위임(&L)
introduce.parameter.delegating.unavailable.tooltip=위임은 클로저 컨텍스트에서 허용되지 않습니다
introduce.parameter.do.not.replace.option.label=바꾸기 안 함(&O)
introduce.parameter.explicit.return.statement.option.label=명시적 return 문 사용(&X)
introduce.parameter.replace.all.fields.option.label=모든 필드 바꾸기(&R)
introduce.parameter.replace.fields.border.title=표현식에 사용된 필드를 getter로 바꾸기
introduce.parameter.replace.inaccessible.fields.option.label=사용 컨텍스트에서 접근할 수 없는 필드 바꾸기(&I)
introduce.variable.change.type.advertisement={0} 을(를) 눌러 유형 변경
introduce.variable.declare.final.label=final 선언(&F)
introduce.variable.name.label=&Nombre\:
introduce.variable.replace.all.0.occurrences=모든 사용 위치 바꾸기({0}개 위치)(&A)
introduce.variable.replace.all.occurrences=모든 사용 위치 바꾸기(&A)
introduce.variable.type.label=유형(&T)\:
invalid.lvalue=Valor no válido para asignar
invalid.qualified.name=유효한 Groovy 정규화된 이름이 아닙니다
investigate.gdsl.error.family.name=DSL 설명자 프로세스 오류 검사
investigate.gdsl.error.intention.name=세부 정보 보기
invoke.completion.second.time.to.show.skipped.methods=Invocar la finalización por segunda vez para mostrar los métodos omitidos
is.not.enclosing.class=''{0}'' no es una clase adjunta
java.style.for.each.statement.requires.a.type.declaration=Estilo Java para cada declaración requiere una declaración de tipo
java.style.properties.invocation.intention.family.name=Java 스타일 접근자 호출을 Groovy 스타일 프로퍼티 참조로 변경
java.style.properties.invocation.intention.name=Groovy 스타일 프로퍼티 참조로 변경
java.style.property.access=Java 스타일 접근자 호출
label.already.used=La etiqueta ''{0}'' ya está en uso
label.groovy.sdk=Groovy SDK:
language.groovy=Groovy
leave.only.modifier.or.annotation.0=''{0}''만 남기기
listener.list.field.must.have.a.generic.collection.type=@ListenerList 필드는 제네릭 Collection 유형이 필요합니다
listener.list.field.with.generic.wildcards.not.supported=@ListenerList 필드에 제네릭 와일드카드 사용은 지원되지 않음
live.template.context.declaration=선언
live.template.context.expression=표현식
live.template.context.statement=구문
local.var.0.is.reassigned=지역 변수 ''{0}'' 이(가) 대입되었습니다
local.variable.types=지역 변수 타입
lock.field.0.must.be.static=락 필드 ''{0}'' 은(는) static이어야 합니다
lock.field.0.must.not.be.static=락 필드 ''{0}'' 은(는) static일 수 없습니다
lock.field.0.not.found=락 필드 ''{0}'' 을(를) 찾을 수 없음
loss.of.precision=Posible pérdida de precisión de ''{0}'' a ''{1}''
map.param.name=맵 매개변수 이름(&N)\:
map.parameter.dialog.create.new.checkbox=이름 지정된 인수에 대한 매개변수 생성(&C)
map.parameter.dialog.explicit.type.checkbox=명시적으로 유형 지정
method.0.cannot.have.weaker.access.privileges.1.than.2.in.3.4=El método ''{0}'' no puede tener privilegios de acceso más débiles (''{1}'') que '' { 2} '' en ''{3}'' (''{4}'')
method.0.cannot.override.method.1.in.2.overridden.method.is.final=El método ''{0}'' no puede anular el método ''{1}'' en ''{2}'' ; el método anulado es final
method.0.is.too.complex.too.analyze=El método ''{0}'' es demasiado complejo para analizar.\nLos tipos de variables locales no se infieren.
method.call.is.ambiguous=La llamada al método es ambigua
method.does.not.override.super=El método no anula el método de su superclase
method.duplicate=El método con la firma {0} ya está definido en la clase ''{1}''
method.has.incorrect.modifier.volatile=El método tiene un modificador incorrecto 'volátil'
method.is.not.implemented=El método ''{0}'' no está implementado
method.is.used.outside.of.groovy=메서드가 Groovy 외부에서 사용됩니다
method.may.be.static=메서드가 static일 수 있습니다
method.may.be.static.ignore.empty.method.option=빈 메서드 무시
method.may.be.static.only.private.or.final.option=final 또는 private 메서드만 검사
method.may.be.static.option.ignore.trait.methods=특성 메서드 무시
method.parameters.count.max.parameters.option=최대 매개변수 개수\:
method.returns.max.returns.option=반환점 제한\:
method.with.signature.already.exists=시그니처 {0} 이(가) 포함된 메서드가 이미 있습니다
method.with.type.parameters.should.have.return.type=El método con parámetros de tipo debe tener un tipo de retorno
missed.attributes=Atributos perdidos\: {0}
missing.required.named.parameter=Falta el parámetro con nombre obligatorio ''{0}''
mixing.private.and.public.protected.methods.of.the.same.name=Mezclando métodos privados y públicos/protegidos del mismo nombre
modifier.0.not.allowed=Modificador ''{0}'' no permitido aquí
modifier.transient.not.allowed.here=Modificador 'transitorio' no permitido aquí
modifier.volatile.not.allowed.here=Modificador 'volátil' no permitido aquí
module.name.0.and.groovy.version.1={0} ({1})
module.with.groovy=Groovy 라이브러리가 연결된 간단한 모듈
move.class.0.from.method=Mover ''{0}'' al lugar correcto
move.class.from.method.family.name=Mover al lugar correcto solución rápida
move.to.correct.dir=''{0}'' (으)로 이동
move.to.correct.dir.family.name=올바른 패키지로 파일 이동
multiple.assignments.without.list.expr=Múltiples asignaciones sin expresiones de lista en el lado derecho no son compatibles en el modo de verificación de tipo estático
named.arguments.are.not.allowed.inside.index.operations=No se permiten argumentos con nombre dentro de operaciones de índice
native.methods.cannot.have.body=Los métodos nativos no pueden tener cuerpo
native.visibility.presentation=native
new.class.action.description=Crea una nueva clase Groovy
new.class.action.text=Clase Groovy
new.class.dialog.title=새 Groovy 클래스
new.class.list.item.annotation=어노테이션
new.class.list.item.class=클래스
new.class.list.item.enum=열거형
new.class.list.item.interface=인터페이스
new.class.list.item.record=레코드
new.class.list.item.trait=특성
new.gant.script.dialog.message=새 Gant 스크립트 이름 입력
new.gant.script.dialog.title=새 Gant 스크립트
new.instance.of.singleton=@groovy.lang.Singleton 어노테이션이 지정된 클래스의 새 인스턴스
new.project.wizard.groovy.creating.main.file=Groovy 메인 파일 생성 중…
new.project.wizard.groovy.retrieving.has.failed=Groovy 버전을 가져오지 못했습니다
new.script.action.description=새 Groovy 스크립트 생성
new.script.action.text=Groovy 스크립트
new.script.dialog.title=새 Groovy 스크립트 이름 입력
new.script.list.item.script=Groovy 스크립트
new.script.list.item.script.dsl=GroovyDSL 스크립트
newlines.here.are.available.since.groovy.3=인수 목록 내의 줄 바꿈 문자는 Groovy 3.0부터 사용할 수 있습니다
no.applicable.signature.found=적용 가능한 시그니처를 찾을 수 없음
no.class.expected.here=No se espera una clase aquí
no.class.in.file.template=No se encontró ninguna clase en la plantilla de archivo
no.implements.clause.allowed.for.interface=Es posible que las interfaces no tengan la cláusula 'implements'
no.interface.expected.here=No se espera ninguna interfaz aquí
no.return.message=일부 실행 경로가 값을 반환하지 않습니다
no.such.property=La propiedad ''{0}'' no existe
no.super.classes.found=No se encontraron superclases
no.super.method.found=No se encontraron supermétodos
no.type.specified=지정된 유형 없음
non.sealed.visibility.presentation=비 sealed
non.static.classes.not.allowed=Las clases internas no estáticas no están permitidas en los rasgos
not.abstract.method.should.have.body=El método no abstracto debe tener cuerpo
not.allowed.modifier.in.for.in=El modificador ''{0}'' no está permitido aquí
notification.group.grape=Groovy @Grab 어노테이션 처리됨
notification.group.groovy.dsl=Groovy DSL 오류
only.abstract.class.can.have.abstract.method=Solo la clase abstracta puede tener un método abstracto
only.traits.expected.here=Aquí solo se esperan rasgos
operator.call.is.ambiguous=La llamada del operador es ambigua
operator.is.not.supported.in=El operador ''{0}'' no es compatible con la versión actual
optimize.all.imports=사용되지 않는 import 문 최적화
optimize.imports=Optimización de declaración import
optimize.imports.progress.title=Groovy 파일에서 import 문 최적화 중...
other.scope=기타 범위
overly.complex.method.complexity.limit.option=메서드 복잡성 제한\:
overly.long.method.statements.limit.option=메서드당 최대 구문 수\:
overly.nested.method.nesting.limit.option=최대 중첩 깊이\:
overriding.methods.of.0=''{0}'' 메서드 재정의 중
package.definition.cannot.have.modifiers=La definición del paquete no puede tener modificadores
packageLocal.visibility.presentation=Visibilidad predeterminada
parameter.can.be.final.tooltip=매개변수 ''{0}'' 은(는) final이 될 수 있습니다
parameter.cast.fix=Transmitir el parámetro {0, número, ordinal} a {1}
parameter.hint.number.of.arguments={0, choice, 0\#|1\#{0} 인수|2\#{0} 인수}
parameter.list.owner.chooser.title=다음으로 매개변수 삽입
pointless.arithmetic.error.message=\#ref 을(를) ''{0}'' (으)로 바꿀수 있습니다 \#loc
pointless.boolean.problem.descriptor=\#ref 을(를) ''{0}'' (으)로 단순화할 수 있습니다 \#loc
pointless.boolean.quickfix=단순화
popup.content.navigation.to.overriding.classes.unavailable=색인 업데이트 중에는 클래스를 재정의하는 탐색이 불가능합니다
postfix.template.provider.name=Groovy
primitive.bound.types.are.not.allowed=Los tipos de enlace primitivo no están permitidos
primitive.type.parameters.are.not.allowed=Los parámetros de tipo primitivo no están permitidos en la lista de parámetros de tipo
private.visibility.presentation=privado
property.missing=propertyMissing
property.name.expected=Nombre de propiedad esperado
protected.visibility.presentation=protected
public.visibility.presentation=public
pull.up.abstract.wont.be.accessible.from={0} 은(는) 하위 클래스에서 접근할 수 없으므로 abstract으로 만들 수 없음
pull.up.wont.be.accessible.from={1} 에서 {0} 에 액세스할 수 없습니다
pull.up.wont.be.accessible.from.the.subclass={0} 이(가) 하위 클래스에서 액세스할 수 없는 {1} 을(를) 사용합니다.
qualified.0.is.allowed.only.in.nested.or.inner.classes=Qualified {0} solo se permite en clases anidadas/internas
recursive.constructor.invocation=Invocación de constructor recursivo
remove.0={0} 제거
remove.catch.block=catch 블록 제거
remove.exception=예외 제거
remove.modifier=Eliminar ''{0}''
remove.parameter.0=매개변수 ''{0}'' 제거
remove.unused.parameter=사용되지 않은 매개변수 제거
rename.file.to.0=파일 이름을 ''{0}'' (으)로 변경
repetitive.method.name.0=Nombre de método repetitivo ''{0}''
replace.0.with.1={0} 을(를) 2진 {1} (으)로 바꾸기
replace.all.occurrences.and.remove.variable.0=모든 사용 위치 바꾸기 및 변수 ''{0}'' 제거
replace.new.expression.with.instance.access=인스턴스 액세스로 바꾸기
replace.postfix.0.with.prefix.0=접미사 {0} 을(를) 접두사 {0} (으)로 바꾸기
replace.primitive.type.with.wrapper=기본 유형을 래퍼로 바꾸기
replace.qualified.name.with.import=정규화된 이름을 import 문으로 바꾸기
replace.with.get.at=Reemplazar con acceso de índice
replace.with.list.literal=Reemplazar con lista literal
replace.with.method.fix=''{0}'' 메서드로 바꾸기
replace.with.method.message=''{0}'' 메서드 호출로 바꿀 수 있음
replace.with.operator.compareTo.equality.option=''compareTo'' 등식을 equals(예\: \=\=)로 바꾸기
replace.with.operator.double.negation.option=이중 부정 사용(예\: \!\!)
replace.with.operator.fix=''{0}'' 을(를) 연산자로 바꾸기
replace.with.operator.message=''{0}'' 을(를) 연산자로 바꿀수 있습니다
replace.with.operator.parentheses=추가 소괄호가 필요한 경우 연산자로 바꾸도록 제안 안 함
replace.with.wrapper={0} (으)로 바꾸기
require.closure.as.attribute.value=속성 값으로 클로저가 필요합니다
return.type.is.incompatible=El tipo de retorno de {0} en {1} es incompatible con {2} en {3}
rtype.cannot.contain.ltype=''{1}'' 은(는) ''{0}'' 을(를) 포함할 수 없습니다
run.configuration.module.chooser.label=모듈(&M)\:
run.configuration.module.classpath.checkbox=러너에 모듈 클래스 경로 추가(&C)
run.configuration.script.path.label=스크립트 경로\:
script.cannot.have.modifier.native=El script no puede tener el modificador 'nativo'
script.generated.with.same.name=Hay una clase sintética ''{0}'' generada para el código del script
script.method.cannot.have.modifier.abstract=El método de script no puede tener el modificador 'abstracto'
script.runner.cant.find.script=스크립트 ''{0}'' 을(를) 찾을 수 없음
script.runner.chooser.description=스크립트 경로 지정\:
script.runner.chooser.title=스크립트 경로
script.runner.class.cannot.be.executed=클래스를 실행할 수 없습니다
script.runner.class.does.not.exist=클래스가 없습니다.
script.runner.description=Groovy 클래스 또는 스크립트
script.runner.display.name=Groovy
script.runner.file.is.not.groovy.file=스크립트 파일이 Groovy 파일이 아닙니다
script.runner.module.not.specified.message=Módulo no especificado
script.runner.no.groovy.for.module=Groovy가 모듈 ''{0}''에 대해 구성되지 않았습니다
script.runner.unknown.script.type=알 수 없는 스크립트 유형 ''{0}''
sealed.visibility.presentation=sealed
second.unsafe.call=두 번째 안전하지 않은 호출
select.framework.0.home.title={0} 홈 선택
select.module.action.description=클래스 경로를 사용할 모듈 선택
select.module.action.text=모듈 선택...
select.module.popup.title=모듈 클래스 경로 사용
selfType.class.does.not.inherit=@SelfType: La clase ''{0}'' no hereda ''{1}''
separator.domain.of.inspection.usage=사용 위치 도메인
separator.preferable.string.kind=선호 종류
settings.code.style.absolute=Absoluto
settings.code.style.indent.labels=Aplicar sangría a las etiquetas
settings.code.style.indent.statements.after.label=Declaraciones de sangría después de la etiqueta
settings.code.style.label.indent.size=tamaño de sangría de etiqueta
settings.code.style.label.indent.style=Estilo de sangría de etiqueta:
settings.compiler.alternative=Alternativamente, puede especificar el compilador Groovy-Eclipse en la <a href=\\"#\\"> página del compilador Java</a>
settings.compiler.exclude.from.stub.generation=Excluir de la generación de stub:
settings.compiler.invoke.dynamic.support=Invocar soporte &dinámico
settings.compiler.path.to.configscript=Ruta de &configscript:
settings.compiler.select.path.to.groovy.compiler.configscript=Seleccione la ruta al configscript del compilador Groovy
settings.inlay.implicit.null.argument=묵시적 null 인수
settings.inlay.inferred.parameter.types=Tipos de parámetros inferidos
settings.inlay.parameter.types=Tipos de parámetros
settings.inlay.put.type.hint.before.identifier=식별자 앞에 타입 힌트 넣기
settings.inlay.show.hints.for.implicit.null.argument=묵시적 null 인수에 관한 힌트 표시
settings.inlay.show.type.hints.for=Mostrar sugerencias de tipo para:
settings.inlay.show.variable.type.hints=지역 변수 타입 힌트 표시
settings.inlay.type.parameter.list=Tipo de lista de parámetros
shows.parameter.names.at.function.call.sites=함수 호출 사이트에서 매개변수 이름을 표시합니다.
singleton.constructor.found=@Singleton 클래스는 생성자를 포함할 수 없습니다
singleton.constructor.makeNonStrict=@Singleton을 비 strict로 설정
singleton.constructor.remove=생성자 제거
spread.operator.is.not.available=El operador de propagación no se puede usar como argumento con verificación de tipo estático
static.import.method.0.fix=static import 메서드 ''{0}''
static.import.method.fix=static import 메서드...
static.visibility.presentation=static
strictfp.visibility.presentation=strictfp
string.end.expected=Se espera el final de la cadena
string.option.do.not.handle.specifically=특별히 처리 안 함
string.option.dollar.slashy.string=달러 슬래시 문자열
string.option.double.quoted.string=큰따옴표로 묶인 문자열
string.option.single.quoted.string=작은따옴표로 묶인 문자열
string.option.slashy.string=슬래시 문자열
string.option.triple.double.quoted.string=삼중 큰따옴표로 묶인 문자열
string.option.triple.quoted.string=삼중 작은따옴표로 묶인 문자열
string.sort.default=디폴트
string.sort.multiline.string=여러 줄 문자열
string.sort.strings.with.escaping=문자 이스케이프를 포함하는 문자열
string.sort.strings.with.interpolation=보간 표현식을 포함하는 문자열
super.cannot.be.used.in.static.context='super' no se puede utilizar en contexto estático
super.is.not.allowed.in.pre.with.call.super=super 호출은 ''callSuper''가 활성화된 ''pre''에서 허용되지 않습니다
surround.with.cast=((Type) expr)
surround.with.closure={ ->... }.call()
surround.with.for=for
surround.with.if=if
surround.with.if.else=if/else
surround.with.if.else.expr=if (expr)/else
surround.with.if.expr=if (expr)
surround.with.parentheses=(expr)
surround.with.shouldFail=shouldFail () {...}
surround.with.try=try
surround.with.try.catch=try/catch
surround.with.try.catch.finally=try/catch/finally
surround.with.try.finally=try/finally
surround.with.while=while
surround.with.while.expr=while (expr)
surround.with.with=with () {...}
surround.with.with.expr=with (expr)
synchronized.not.allowed.on.abstract.method=@Synchronized는 추상 메서드에서 허용되지 않음
synchronized.visibility.presentation=sincronizado
target.0.does.not.exist=대상 ''{0}'' 이(가) 없습니다
target.annotation.is.unused=@Target은 사용되지 않습니다
text.class.0.is.unused=클래스 {0} 이(가) 사용되지 않습니다
text.constructor.0.is.unused=생성자 {0} 이(가) 사용되지 않습니다
text.method.0.is.unused=메서드 {0} 이(가) 사용되지 않습니다
text.parameter.0.is.unused=매개변수 ''{0}'' 이(가) 사용되지 않습니다
text.property.0.is.unused=프로퍼티 {0} 이(가) 사용되지 않습니다
the.usage.of.a.map.entry.expression.to.initialize.an.enum.is.currently.not.supported=Actualmente no se admite el uso de una expresión de entrada de mapa para inicializar un Enum
there.is.no.default.constructor.available.in.class.0=No hay un constructor predeterminado disponible en la clase ''{0}''
this.super.completion.advertisement=클래스 한정자 없이 {0} 을(를) 2회 누르면 액세스 가능한 모든 정적 메서드가 표시됩니다
throws.clause.is.not.allowed.in.at.interface=La cláusula 'throws' no está permitida en los miembros de @interface
top.level.class.may.not.have.private.modifier=Es posible que la clase de nivel superior no tenga el modificador 'privado'
top.level.class.may.not.have.protected.modifier=Es posible que la clase de nivel superior no tenga el modificador 'protegido'
trait.method.cannot.be.protected=Los métodos de rasgos no pueden protegerse
transient.visibility.presentation=transient
try.catch.fix=try-catch 수정
try.without.catch.finally=intentar' sin 'atrapar' o 'finalmente
tuple.cant.be.placed.in.class=No se permiten múltiples asignaciones para los campos
tuple.declaration.should.end.with.def.modifier=La declaración de tupla debe terminar con el modificador 'def'
type.argument.0.is.not.in.its.bound.should.extend.1=El parámetro de tipo ''{0}'' no está en su límite; debería extender ''{1}''
type.argument.list.is.not.allowed.here=La lista de argumentos de tipo no está permitida aquí
type.customizer.is.not.marked.as.a.resource.file=유형 커스터마이저 스크립트가 컴파일러 리소스로 표시되지 않았습니다.
type.doesnt.contain.method=유형 ''{0}'' 에 메서드 ''{1}'' 이(가) 없으므로 해당 유형을 범위 내에서 반복할 수 없습니다
type.doesnt.implement.comparable=유형 ''{0}'' 이(가) Comparable을 구현하지 않습니다
type.parameters.are.unexpected=Los parámetros de tipo son inesperados
unassigned.access.tooltip=변수 ''{0}'' 은(는) 대입되지 않을 수 있습니다
undefined.label=Etiqueta no definida ''{0}''
undefined.library.version=No definida
unexpected.attribute.type.0=Tipo de atributo inesperado\: ''{0}''
unnecessary.alias.description=별칭이 필요하지 않습니다
unnecessary.alias.fix=불필요한 별칭 제거
unnecessary.def.explicitly.typed.only=명시적으로 유형 지정된 선언에서만 보고
unnecessary.modifier.description=제어자 ''{0}'' 은(는) 필요하지 않습니다
unnecessary.modifier.remove=불필요한 ''{0}'' 제거
unnecessary.semicolon.description=세미콜론이 필요하지 않습니다
unnecessary.semicolon.fix=세미콜론 제거
unnecessary.type=Excepción innecesaria ''{0}''. ''{1}'' ya está declarado
unresolved.type.status=유형 ''{0}'' 이(가) 해결되지 않았습니다
unsupported.anonymous.class.0=Las clases anónimas no son compatibles con Groovy {0}
unsupported.array.initializers=Los inicializadores de matriz no son compatibles con la versión actual
unsupported.command.syntax.0=La sintaxis de la expresión de comando no es compatible con Groovy {0}
unsupported.diamonds.0=Los diamantes no son compatibles con Groovy {0}
unsupported.do.while.statement='hacer mientras' no es compatible con la versión actual
unsupported.dollar.slashy.string.0=Las cadenas de barras inclinadas en dólares no son compatibles con Groovy {0}
unsupported.elvis.assignment=La asignación de Elvis no es compatible con la versión actual
unsupported.expression.list.in.for.update=Varias expresiones en la actualización 'for' no son compatibles con la versión actual
unsupported.inner.class.0=Las clases internas no son compatibles con Groovy {0}
unsupported.lambda=Lambdas no son compatibles con la versión actual
unsupported.multiline.slashy.string.0=Las cadenas de barras inclinadas de varias líneas no son compatibles con Groovy {0}
unsupported.multiple.variables.in.for=Varias variables en la inicialización 'for' no son compatibles con la versión actual
unsupported.negated.in=Negated 'in' no es compatible con la versión actual
unsupported.negated.instanceof=La 'instancia de' negada no es compatible con la versión actual
unsupported.resource.list='probar' con recursos no es compatible con la versión actual
unsupported.safe.index.access=El acceso seguro al índice no es compatible con la versión actual
unsupported.traits.0=Los rasgos no son compatibles con Groovy {0}
unsupported.tuple.application.initializer=애플리케이션 이니셜라이저는 현재 버전에서 지원되지 않습니다
unsupported.tuple.declaration.in.for=La declaración de tupla en la inicialización 'for' no es compatible con la versión actual
unsupported.type.annotations=Las anotaciones de tipo no son compatibles con la versión actual
unused.0=사용되지 않은 {0}
unused.assignment.tooltip=La tarea no se utiliza
unused.default.parameter.fix=이니셜라이저 제거
unused.default.parameter.message=디폴트 매개변수가 사용되지 않습니다
unused.import=사용되지 않은 import 문
unused.variable=변수가 사용되지 않습니다
variable.0.might.not.have.been.initialized=Es posible que la variable ''{0}'' no se haya inicializado
variable.already.defined=Variable ''{0}'' ya definida
variable.can.be.final.tooltip=변수 ''{0}'' 은(는) final이 될 수 있습니다
variable.cannot.be=La variable no puede tener el modificador ''{0}''
volatile.visibility.presentation=volatile
wildcards.are.not.allowed.in.extends.list=Un supertipo no puede especificar un tipo de comodín
write.access.to.closure.variable=필드 <b>{0}</b>에 대한 쓰기 액세스
wrong.closure.first.parameter.type=클로저 ''{0}'' 은(는) 이름 지정된 인수와 함께 사용되지만 내부의 첫 번째 인수 ''{1}'' 이(가) Map 유형을 준수하지 않습니다.
wrong.method.first.parameter.type=메서드 ''{0}'' 은(는) 이름 지정된 인수와 함께 사용되지만 내부의 첫 번째 인수 ''{1}'' 이(가) Map 유형을 준수하지 않습니다.
wrong.number.of.type.arguments=Número incorrecto de argumentos de tipo\: {0}; requerido\: {1}
