0.expressions.on.trait.fields.properties.are.not.supported.in.traits=특성 필드/프로퍼티에 있는 {0} 표현식은 특성에서 지원되지 않습니다.
0.is.deprecated=''{0}''은(는) 곧 사용할 수 없게 됩니다
Cannot.perform.undo.operation=연산을 실행 취소할 수 없습니다
Constructor=생성자
Equals=상등
Getter=Getter
Inner.methods.are.not.supported=내부 메서드가 지원되지 않습니다
Setter=Setter
Undo.disable=비활성화 실행 취소
abstract.methods.must.not.have.body=추상 메서드에 본문이 있어서는 안 됩니다.
abstract.visibility.presentation=abstract
action.ConvertGroovyToJava.description=그루비 파일을 Java로 변환합니다
action.ConvertGroovyToJava.text=Java로 변환
action.ConvertToCompileStatic.description=Groovy 파일을 @CompileStatic으로 변환합니다
action.ConvertToCompileStatic.text=@CompileStatic으로 변환
action.DumpGroovyControlFlowAction.text=Groovy 제어 흐름 덤프
action.ExcludeFromStubGeneration.description=컴파일 시 이 Groovy 파일에 대한 Java 스텁을 생성하지 않습니다
action.ExcludeFromStubGeneration.text=스텁 생성에서 제외
action.Gant.NewScript.description=새 Gant 스크립트를 생성합니다
action.Gant.NewScript.text=Gant 스크립트
action.Groovy.CheckResources.Make.description=컴파일 문제 확인을 위해 리소스 루트의 Groovy 파일에 대해 증분 컴파일러를 실행합니다
action.Groovy.CheckResources.Make.text=리소스 빌드(_B)
action.Groovy.CheckResources.Rebuild.description=컴파일 문제 확인을 위해 리소스 루트의 모든 Groovy 파일에 대해 컴파일러를 실행합니다
action.Groovy.CheckResources.Rebuild.text=리소스 다시 빌드(_R)
action.Groovy.Console.description=Groovy 콘솔을 시작합니다
action.Groovy.Console.text=Groovy 콘솔
action.Groovy.NewClass.description=새 Groovy 클래스를 생성합니다
action.Groovy.NewClass.text=Groovy 클래스
action.Groovy.NewScript.description=새 Groovy 스크립트를 생성합니다
action.Groovy.NewScript.text=Groovy 스크립트
action.build.module.restart.description=모듈 ''{0}''을(를) 빌드한 후 다시 시작합니다
action.build.restart.text=빌드 후 다시 시작
action.collapse.all.description=모두 접기
action.collapse.all.text=모두 접기
action.convert.lambda.to.closure=람다를 클로저로 변환
action.expand.all.description=모두 펼치기
action.expand.all.text=모두 펼치기
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.description=getter 생성
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.text=Getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.description=getter 생성
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.text=Getter 및 Setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.description=setter 생성
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.text=Setter
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.description=생성자를 생성합니다
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.text=생성자
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.description=액션이 이제 equals와 hashCode를 생성합니다.
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.text=equals() 및 hashCode()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.description=액션이 propertyMissing()을 생성합니다
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.text=methodMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.description=액션이 propertyMissing()을 생성합니다
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.text=propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.description=toString() 메서드를 생성합니다
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.text=to_String()
action.remove.dynamic.member.description=동적 멤버를 제거합니다
action.remove.dynamic.member.text=제거
add.class.to.extends.family.name=구현
add.compilestatic=@CompileStatic 추가
add.dynamic.element=동적 요소 추가
add.dynamic.method=동적 메서드 추가
add.dynamic.method.0=동적 메서드 ''{0}'' 추가
add.dynamic.property=동적 프로퍼티 ''{0}'' 추가
add.method=메서드 ''{0}()''을(를) ''{1} 추가
add.method.family=메서드 추가
add.modifier.sealed=제어자 'sealed' 추가
add.parenthesis.to.lambda.parameter.list=소괄호를 매개변수 목록에 추가
add.return.type=반환 타입 추가
add.return.type.to.method.declaration=반환 타입을 메서드 선언에 추가
add.to.resources=리소스에 추가
add.type.customizer.to.resources=타입 커스터마이저 스크립트를 리소스에 추가
ambiguous.code.block=모호한 코드 블록
annotation.collector.cannot.have.attributes=@AnnotationCollector로 추가된 어노테이션 타입은 속성을 가질 수 없습니다
annotation.field.can.only.be.used.within.a.script=어노테이션 @Field는 스크립트 내에서만 사용할 수 있습니다.
annotation.field.can.only.be.used.within.a.script.body=어노테이션 @Field는 스크립트 본문 내에서만 사용할 수 있습니다.
annotation.field.should.have.type.declaration=어노테이션 내 필드에는 타입 선언이 있어야 합니다.
annotation.type.cannot.be.inner=어노테이션 타입은 내부형일 수 없습니다.
annotation.types.may.not.have.extends.clause=어노테이션 타입은 'extends' 절을 가질 수 없습니다.
annotation.types.may.not.have.implements.clause=어노테이션 타입은 'implements' 절을 가질 수 없습니다.
anonymous.class=익명 클래스
anonymous.class.cannot.have.abstract.method=익명 클래스는 추상 메서드를 가질 수 없습니다.
anonymous.class.derived.from.0={0}에서 파생된 익명 클래스
anonymous.classes.cannot.be.created.from.traits=특성의 익명 클래스는 Groovy 2.5.2부터 사용할 수 있습니다
are.you.sure.to.delete.dynamic.property=''{0}''을(를) 삭제하시겠어요?
are.you.sure.to.delete.elements=''{0}'' 요소를 삭제하시겠어요?
at.interface.0.does.not.contain.attribute=@interface ''{0}''에 속성 ''{1}''이(가) 없습니다.
attribute.descriptor.abstract.class=추상 클래스
attribute.descriptor.annotation.attribute.name=어노테이션 속성 이름
attribute.descriptor.annotation.name=어노테이션 이름
attribute.descriptor.annotations=어노테이션
attribute.descriptor.anonymous.class=익명 클래스
attribute.descriptor.bad.character=잘못된 문자
attribute.descriptor.block.comment=블록 주석
attribute.descriptor.braces=중괄호
attribute.descriptor.braces.and.operators=중괄호 및 연산자
attribute.descriptor.brackets=대괄호
attribute.descriptor.class=클래스
attribute.descriptor.classes.and.interfaces=클래스 및 인터페이스
attribute.descriptor.closure.expression.braces.and.arrow=클로저 표현식 중괄호 및 화살표
attribute.descriptor.comments=주석
attribute.descriptor.constructor.call=생성자 호출
attribute.descriptor.constructor.declaration=생성자 선언
attribute.descriptor.enum=열거형
attribute.descriptor.fields=필드
attribute.descriptor.groovydoc=GroovyDoc
attribute.descriptor.groovydoc.tag=태그
attribute.descriptor.groovydoc.text=텍스트
attribute.descriptor.gstring=GString
attribute.descriptor.instance.field=인스턴스 필드
attribute.descriptor.instance.method.call=인스턴스 메서드 호출
attribute.descriptor.instance.property.reference=인스턴스 프로퍼티 참조
attribute.descriptor.interface=인터페이스
attribute.descriptor.invalid.string.escape=잘못된 문자열 이스케이프
attribute.descriptor.keyword=키워드
attribute.descriptor.label=라벨
attribute.descriptor.lambda.expression.braces.and.arrow=람다 식 중괄호 및 화살표
attribute.descriptor.line.comment=줄 주석
attribute.descriptor.list.map.to.object.conversion=리스트/맵에서 객체로 변환
attribute.descriptor.local.variable=지역 변수
attribute.descriptor.map.key.named.argument=맵 키/이름 지정된 인수
attribute.descriptor.method.declaration=메서드 선언
attribute.descriptor.methods=메서드
attribute.descriptor.number=숫자
attribute.descriptor.operator.sign=연산자 기호
attribute.descriptor.parameter=매개변수
attribute.descriptor.parentheses=소괄호
attribute.descriptor.reassigned.local.variable=재대입된 지역 변수
attribute.descriptor.reassigned.parameter=재대입된 매개변수
attribute.descriptor.references=참조
attribute.descriptor.static.field=static 필드
attribute.descriptor.static.method.call=static 메서드 호출
attribute.descriptor.static.property.reference=static 프로퍼티 참조
attribute.descriptor.string=String
attribute.descriptor.strings=문자열
attribute.descriptor.trait=특성
attribute.descriptor.type.parameter=타입 매개변수
attribute.descriptor.unresolved.reference=해결되지 않은 참조
attribute.descriptor.valid.string.escape=올바른 문자열 이스케이프
attribute.descriptor.variables.and.parameters=변수 및 매개변수
attribute.name.expected=속성 이름이 필요합니다
base.script.annotation.is.allowed.only.inside.scripts=어노테이션 @BaseScript는 스크립트 내에서만 사용할 수 있습니다.
break.outside.loop=이름 지정된 라벨이 있는 break 문은 루프 내에서만 허용됩니다.
break.outside.loop.or.switch='break' 문은 루프 또는 콜론 스타일의 switch 문 내에서만 허용됩니다
builder.annotation.not.support.super.for.simple.strategy=어노테이션 속성 'includeSuperProperties'는 groovy.transform.builder.SimpleStrategy에서 지원되지 않습니다.
call.can.throw.npe=호출 체인이 NullPointerException을 던질 수 있습니다
call.without.parentheses.are.supported.since.groovy.3=인수 목록에 소괄호가 없는 호출은 Groovy 3.0부터 지원됩니다
cannot.access=''{0}''에 대한 액세스는 해당 액세스 권한을 초과합니다.
cannot.apply.constructor=''{1}''의 생성자 ''{0}''을(를) ''{2}''에 적용할 수 없습니다.
cannot.apply.default.constructor=클래스''{0}''에 대한 디폴트 생성자를 적용할 수 없습니다.
cannot.apply.method.or.closure=''{0}''을(를) ''{1}''에 적용할 수 없습니다
cannot.apply.method1=''{1}''의 ''{0}''을(를) ''{2}''에 적용할 수 없습니다
cannot.assign=''{0}''을(를) ''{1}''에 대입할 수 없습니다.
cannot.assign.a.value.to.final.field.0=final 필드 ''{0}''에 값을 대입할 수 없습니다.
cannot.assign.a.value.to.final.parameter.0=final 매개변수 ''{0}''에 값을 대입할 수 없습니다.
cannot.assign.string.to.enum.0=문자열을 열거형 ''{0}''에 대입할 수 없습니다.
cannot.cast=''{0}''을(를) ''{1}''(으)로 형 변환할 수 없습니다.
cannot.create.class=클래스를 생성할 수 없음
cannot.create.class.error.text=클래스 ''{0}''을(를) 생성할 수 없습니다. {1}
cannot.create.class.error.title=클래스를 생성할 수 없음
cannot.find.enum.constant.0.in.enum.1=열거형 ''{1}''에서 열거형 상수 ''{0}''을(를) 찾을 수 없습니다.
cannot.infer.argument.types=인수 타입을 추론할 수 없습니다.
cannot.instantiate.abstract.class=추상 클래스 ''{0}''을(를) 인스턴스화할 수 없습니다.
cannot.instantiate.interface=인터페이스 ''{0}''을(를) 인스턴스화할 수 없습니다.
cannot.reference.non.static=정적 컨텍스트에서 정적이 아닌 심볼 ''{0}''을(를) 참조할 수 없습니다.
cannot.resolve=심볼 ''{0}''을(를) 해결할 수 없습니다
cannot.return.from.constructor=생성자에서 객체를 반환할 수 없습니다.
cannot.return.from.void.method='void'를 반환하는 메서드에서 객체를 반환할 수 없습니다.
cannot.return.type=''{1}''을(를) 반환하는 메서드에서 ''{0}''을(를) 반환할 수 없습니다
catch.statement.parameter.type.should.be.a.subclass.of.throwable=catch 문 매개변수 타입은 Throwable의 하위 클래스여야 합니다.
change.base.method.label=기본 메서드 변경
change.implements.and.extends.classes=extends 및 implements 목록을 정규화
change.lvalue.type=변수 ''{0}'' 타입을 ''{1}''(으)로 변경
change.modifier=''{0}''을(를) {1}(으)로 만들기
change.modifier.family.name=제어자 변경
change.modifier.not=''{0}''을(를) 비 {1}(으)로 만들기
change.signature.default.initializer.column=디폴트 이니셜라이저
change.signature.type.column=타입
change.usages.label=사용 위치 변경
checkbox.delegate.via.overloading.method=오버로딩 메서드를 통한 위임
checkbox.ignore.conditional.operators=조건 연산자 무시
checkbox.ignore.double.checked.locking.on.volatile.fields=volatile 필드에 이중 검사된 락 무시
checkbox.ignore.obscure.operators=모호한 연산자 무시
checkbox.inspect.anonymous.closures=익명 클로저 검사
checkbox.inspect.gradle.files=Gradle 파일 검사
checkbox.only.warn.if.loop.empty=루프가 비어 있는 경우에만 경고
checkbox.report.unmatched.null=일치하지 않는 'null' 보고
class.definition.is.not.expected.here=여기에서는 클래스 정의가 필요하지 않습니다.
class.is.not.annotation=''{0}''이(가) 어노테이션이 아닙니다
closure=클로저
closure.is.accessed.outside.of.groovy=필드 <b>{0}</b>이(가) Groovy 외부에서 액세스됩니다
closure.is.too.complex.to.analyze=클로저가 너무 복잡하여 분석할 수 없습니다.\n지역 변수 타입이 추론되지 않았습니다.
closure.used.as.variable=클로저가 인수로서 전달되었습니다. 리팩터링을 하면 의미가 변경될 수 있습니다.
code.style.groovydoc.enable=GroovyDoc 서식 지정 활성화
code.style.groovydoc.tab.name=GroovyDoc
code.style.group.list.map.literals=List 및 Map 리터럴
code.style.option.after.assert.separator='assert' 구분 기호 뒤
code.style.option.align.multiline.named.arguments=여러 줄의 이름 지정된 인수 정렬
code.style.option.align.when.multiple=여러 개일 경우 정렬
code.style.option.before.assert.separator='assert' 구분 기호 앞
code.style.option.before.record.parameter.list=레코드 매개변수 목록 앞
code.style.option.closure.left.brace.in.method.calls=메서드 호출 내 왼쪽 중괄호 클로저
code.style.option.gstring.injection.braces=GString 삽입 중괄호
code.style.option.import.annotations=어노테이션 가져오기
code.style.option.in.named.argument.after.colon=':' 뒤 이름 지정된 인수 내
code.style.option.in.named.argument.before.colon=':' 앞 이름 지정된 인수 내
code.style.option.list.maps.literals=List 및 Map 리터럴
code.style.option.regexp.expression=정규 표현식 (==~, =~)
code.style.option.relational.operators=관계 연산자 (<, >, <=, >=, <=>)
code.style.option.simple.lambdas.closures.in.one.line=한 줄의 간단한 람다/클로저
code.style.option.tuple.assignment.expression=튜플 대입 표현식
code.style.option.unary.operators=단항 연산자(!, -, +, ++, --, *)
code.style.option.use.flying.geese.braces=닫는 중괄호를 한 줄에 입력
code.style.option.wrap.after.dot=마침표 이후 줄 바꿈
collection.literal.contains.named.argument.and.expression.items=컬렉션 리터럴에는 이름 지정된 인수 및 표현식 인수가 동시에 포함됩니다.
command.name.add.dynamic.member=동적 멤버 추가
comments.count.as.content=주석을 내용으로 간주
configurable.GantConfigurable.display.name=Gant
configurable.GroovyCompilerConfigurable.display.name=Groovy 컴파일러
configurable.greclipse.border.title=Groovy-Eclipse 옵션
configurable.greclipse.command.line.params.label=추가 명령줄 매개변수:
configurable.greclipse.debug.checkbox=디버그 정보 생성
configurable.greclipse.path.chooser.description=Groovy 배포판과 일치하는 버전의 groovy-eclipse-batch-*.jar 경로를 선택합니다
configurable.greclipse.path.label=groovy-eclipse-batch jar 경로:
configurable.hotswap.checkbox=Groovy 코드의 핫스왑 에이전트 활성화
configurable.hotswap.checkbox.description=디버그된 애플리케이션에서 직렬화 문제가 발생할 수 있습니다
configure.groovy.library=Groovy SDK 구성…
constructor.cannot.have.static.modifier=생성자는 정적일 수 없습니다.
constructors.are.not.allowed.in.anonymous.class=생성자는 익명 클래스에서 허용되지 않습니다.
constructors.are.not.allowed.in.interface=생성자가 인터페이스에서 허용되지 않습니다.
constructors.cannot.have.return.type='return' 타입 요소는 생성자에서 허용되지 않습니다.
continue.outside.loop=continue 문은 루프 내에서만 허용됩니다.
conversion.closure.not.allowed.in.non.groovy.files=Groovy가 아닌 파일에서 사용되는 클로저에는 리팩터링을 사용할 수 없습니다.
conversion.method.not.allowed.in.non.groovy.files=Groovy가 아닌 파일에서 사용되는 메서드에는 리팩터링을 사용할 수 없습니다.
convert.cannot.itself=리팩터링은 맵 매개변수 자체에 사용할 수 없습니다
convert.param.to.map.entry=매개변수를 맵 항목으로 변환
convert.parameter.to.map.entry.title=매개변수를 맵 항목으로 변환
create.annotation.text=어노테이션 ''{0}'' 생성
create.class.family.name=클래스 생성
create.class.text=클래스 ''{0}'' 생성
create.directory.command=디렉터리  생성
create.enum=열거형 ''{0}'' 생성
create.field.from.usage=필드 ''{0}'' 생성
create.field.from.usage.family.name=사용 위치에서 필드 생성
create.instance.of.built-in.type=기본 타입의 인스턴스화
create.interface.text=인터페이스 ''{0}'' 생성
create.method.from.usage=메서드 ''{0}'' 생성
create.method.from.usage.family.name=사용 위치에서 메서드 생성
create.parameter.from.usage=매개변수 ''{0}'' 생성
create.parameter.from.usage.family.name=사용 위치에서 매개변수 생성
create.record.text=레코드 ''{0}'' 생성
create.trait=특성 ''{0}'' 생성
create.variable.from.usage=변수 ''{0}'' 생성
create.variable.from.usage.family.name=사용 위치에서 변수 생성
cyclic.inheritance.involving.0=''{0}'' 관련 순환 상속
debug.option=디버그 스택 트레이스 활성화(&D)
declare.explicit.implementations.of.trait=특성의 명시적 구현 선언
declared.type.0.extends.1.which.is.circular.inheritance=선언된 타입 ''{0}''은(는) ''{1}''을(를) 확장합니다. 이는 순환 상속입니다
declared.type.0.have.to.extend.script=선언된 타입 ''{0}''이(가) ''groovy.lang.Script'' 클래스를 확장하지 않습니다.
def.visibility.presentation=def
default.initializers.are.not.allowed.in.abstract.method=기본 이니셜라이저는 추상 메서드에서 허용되지 않습니다
default.modifier.in.old.versions=제어자 'default'는 Groovy 3.0 이상에서 사용할 수 있습니다
delegate.annotation.is.only.for.methods.without.arguments=어노테이션 @Delegate는 인수를 가진 메서드에 적용할 수 있습니다.
destination.package=대상 패키지:
dialog.create.class.package.chooser.title=대상 패키지 선택
dialog.message.gant.not.configured=Gant가 구성되지 않았습니다
dialog.title.no.jdk.specified.error=Groovy SDK 지정 안 됨
dialog.title.no.jdk.specified.prompt=SDK가 할당되지 않은 프로젝트를 생성하시겠어요?
dialog.title.no.jdk.specified.title=Groovy SDK 지정 안 됨
dialog.title.refactoring.unavailable.in.current.scope=현재 범위에서는 리팩터링을 사용할 수 없음
dialog.title.select.groovy.sdk=Groovy SDK 선택
dialog.title.specify.groovy.sdk=Groovy SDK 홈 지정
dialog.title.validation.directory.you.specified.does.not.contain.groovy.sdk.do.you.want.to.create.project.with.this.configuration=Groovy SDK가 없는 디렉터리를 지정했습니다. 이 구성으로 프로젝트를 생성하시겠어요?
dialog.title.validation.invalid.sdk.specified.error=잘못된 Groovy SDK 지정됨
dialog.title.validation.invalid.sdk.specified.title=잘못된 Groovy SDK 지정됨
dialog.title.validation.path.does.not.contain.groovy.sdk=경로에 Groovy SDK가 없습니다
dialog.title.validation.path.should.not.be.empty=경로는 공백일 수 없습니다
do.you.want.to.change.method.return.type=''{0}'' 메서드의 반환 타입을 변경하시겠어요?
do.you.want.to.change.type.of.parameter.in.method=메서드 ''{1}''에서 매개변수 ''{0}''의 타입을 변경하시겠어요?
do.you.want.to.change.variable.type=''{0}''의 타입을 변경하시겠어요?
doc.end.expected='*/'이(가) 필요합니다
documentation.cannot.infer.type.label=타입을 추론할 수 없습니다
documentation.gdk.label=GDK
documentation.inferred.type.label=추론 타입
duplicate.attribute=중복 속성
duplicate.class=클래스 ''{0}''이(가) ''{1}''에 이미 있습니다.
duplicate.element.in.the.map=맵 내 중복 요소 ''{0}''
duplicate.inner.class=클래스 중복: ''{0}''
duplicate.modifier=중복 제어자 ''{0}''
duplicated.named.parameter=이름이 중복된 매개변수 ''{0}''이(가) 발견되었습니다.
duplicating.named.parameter=매개변수에 이름이 중복된 매개변수 ''{0}''이(가) 있습니다. {1}
dynamic.dialog.class.label=클래스(&C):
dynamic.dialog.static.checkbox=static(&S)
dynamic.dialog.type.label=타입(&T):
dynamic.element=동적 요소
dynamic.element.deletion=동적 요소 삭제
dynamic.members.column.name.element=동적 요소
dynamic.members.column.name.type=타입
dynamic.method.property.type=프로퍼티 타입(&T):
dynamic.method.return.type=반환 타입(&T):
dynamic.name=이름
dynamic.properties.table.name=메서드 인수
dynamic.property.deletion=동적 프로퍼티 삭제
dynamic.tool.window.id=동적 숫자
dynamic.type=타입
ellipsis.type.is.not.allowed.here=여기에서는 ellipsis 타입이 허용되지 않습니다.
enums.may.not.have.extends.clause=열거형은 'extends' 절을 가질 수 없습니다.
equals.between.inconvertible.types.tooltip=<code>{0}</code>이(가) 변환할 수 없는 타입인 ''{1}'' 및 ''{2}''의 객체 사이에 있습니다
exception.0.has.already.been.caught=예외 ''{0}''이(가) 이미 포착되었습니다
expected.0.to.be.inline.constant=''{0}''은(는) 인라인 상수여야 합니다.
expected.type.0=''{0}''이(가) 필요하나 ''{1}''이(가) 발견되었습니다
explicit.constructors.are.not.allowed.in.immutable.class=명시적 생성자는 @Immutable 클래스에서 허용되지 않습니다.
explicit.includes.and.excludes='includes' 및 'excludes' 중 하나만 제공해야 합니다
expression.expected=표현식 필요
expression.type.no.expression=표현식을 찾을 수 없습니다
expression.type.unknown=<알 수 없음>
extract.closure.command.name=클로저 추출
field.already.defined=필드 ''{0}''은(는) 이미 정의되어 있습니다.
field.already.exists=필드 <b>{0}</b>이(가) 이미 있습니다
field.is.used.in.argument.label=필드 <b>{0}</b>이(가) 인수 라벨에서 사용됩니다
field.should.be.immutable=필드 ''{0}''에 불변 타입이 있어야 하거나 @ImmutableOptions를 사용해 불변 타입으로 선언되어야 합니다.
file.exists=파일 ''{0}''이(가) 디렉터리 ''{1}''에 이미 있습니다
file.template.group.title.groovy=Groovy
filetype.dgm.description=Groovy 확장 모듈 설명자 파일
filetype.dgm.display.name=DGM
filetype.gdsl.description=IntelliJ Groovy DSL 구성
filetype.gdsl.display.name=Groovy DSL
filetype.logback.description=Groovy Logback DSL 구성
filetype.logback.display.name=Groovy Logback DSL
final.class.cannot.be.extended=final 클래스는 확장할 수 없습니다
final.visibility.presentation=final
find.method.ro.closure.usages=프로젝트 파일 내 둘러싸는 클로저의 사용 위치 검색 중
find.method.ro.method.usages=프로젝트 파일 내 둘러싸는 메서드의 사용 위치 검색 중
find.usages.method.0.of.class.1={1} 내 {0}
fix.class=클래스 {0} 수정
fix.package.name=패키지 이름 수정
framework.0.home.label={0} 홈:
framework.0.library={0} 라이브러리
framework.0.library.version.1={0} 라이브러리 버전 {1}
framework.0.sdk.chooser.description={0} 배포판을 포함하는 디렉터리를 선택합니다
framework.0.sdk.chooser.error.message=지정된 경로의 {0} 배포판이 손상된 것 같습니다. 버전을 파악할 수 없습니다.
framework.0.sdk.chooser.error.title=클래스 생성 실패
framework.0.sdk.chooser.title={0} SDK
framework.gant=Gant
gdsl.error.notification.title=DSL 스크립트 실행 오류
gdsl.investigate.link.label=여기를 클릭하여 조사
generate.equals.and.hashcode.already.defined.title=equals() 및 hashCode()가 이미 정의되어 있음
generate.equals.and.hashcode.already.defined.warning=equals() 및 hashCode()가 이미 정의되어 있음
generate.equals.and.hashcode.already.defined.warning.anonymous=equals() 및 hashCode()가 이미 정의되어 있음
generate.equals.compare.arrays.comment= // Object[] 배열을 Arrays.equals와 비교하면 올바르지 않을 수 있음
generate.equals.compare.nested.arrays.comment= // 여기 {0} 의 중첩된 배열 - 값 비교
generate.method.missing.already.defined.title=methodMissing()이 이미 정의되어 있음
generate.method.missing.already.defined.warning=methodMissing()이 이미 정의되어 있음
generate.property.missing.already.defined.title=propertyMissing()이 이미 정의되어 있음
generate.property.missing.already.defined.warning=propertyMissing()이 이미 정의되어 있음
generated.stub.exclude.link.label=스텁 생성에서 제외
generated.stub.message=이 스텁은 Groovy 클래스가 Groovy-Java 크로스 컴파일할 수 있도록 하기 위해 생성됩니다
generated.stub.navigate.link.label=Groovy 클래스로 이동
getter.0.clashes.with.getter.1=충돌 발생: ''{0}'' 및 ''{1}''
getter.kind.gdk.method.0=GDK 메서드 {0}
getter.kind.getter.0=getter {0}
getter.kind.method.0=메서드 {0}
ginq.code.style.group.ginq.clauses=GINQ 절
ginq.code.style.option.indent.having.clauses='having' 절 들여쓰기
ginq.code.style.option.indent.on.clauses='on' 절 들여쓰기
ginq.code.style.option.space.after.keyword=키워드 뒤에 공백 넣기
ginq.code.style.option.wrap.having.clauses='having' 절 줄 바꿈
ginq.code.style.option.wrap.on.clauses='on' 절 줄 바꿈
ginq.error.message.0.must.be.after.1=''{0}''은(는) ''{1}'' 이후여야 합니다
ginq.error.message.0.must.be.before.1=''{0}''은(는) ''{1}'' 이전이어야 합니다
ginq.error.message.boolean.condition.expected=부울 조건이 필요합니다
ginq.error.message.container.expected=GINQ, Iterable, Stream 혹은 배열이 필요합니다
ginq.error.message.expected.a.boolean.expression=bool 표현식이 필요합니다
ginq.error.message.expected.alias=별칭 이름이 필요합니다
ginq.error.message.expected.data.source=데이터 소스가 필요합니다
ginq.error.message.expected.in.operator='… 내 …'이 필요합니다
ginq.error.message.expected.one.or.two.arguments.for.limit='limit'에 하나 혹은 두 개의 인수가 필요합니다
ginq.error.message.from.must.be.in.the.start.of.a.query='from'은 쿼리의 첫부분에 있어야 합니다
ginq.error.message.groupby.expected.a.list.of.expressions=표현식의 목록이 필요합니다
ginq.error.message.on.is.expected.after.join='join'과 유사한 절 뒤에는 'on'이 필요합니다
ginq.error.message.on.should.not.be.provided.after.crossjoin='crossjoin' 뒤에 'on'이 오면 안 됩니다
ginq.error.message.orderby.expected.a.list.of.ordering.fields=정렬하는 필드의 목록이 필요합니다
ginq.error.message.query.should.end.with.select=쿼리는 'select'로 끝나야 합니다
ginq.error.message.query.should.start.from.from=쿼리는 'from'으로 시작해야 합니다
ginq.error.message.unrecognized.query=인식되지 않는 쿼리
gr.package.inspection.check.scripts=스크립트 검사
grab.error.0.title=@Grab을 실행할 수 없음: {0}
grab.error.ivy.missing.message=IDEA는 Apache Ivy 없이 종속성을 @Grab할 수 없습니다. Apache Ivy를 모듈 종속성에 추가한 후 액션을 재실행하세요.
grab.error.ivy.missing.title=Ivy 누락
grab.family.name=Grab
grab.intention.name=아티팩트 Grab
grab.jar.count=<b>{0}</b>: {1}개의 {1, choice, 0#jar|1#jar|2#jar}
grab.progress.title=@Grab 어노테이션 처리 중
grab.result.title={0}개의 Grape 종속성 {0, choice, 0#jar|1#jar|2#jar}이 추가됨
groovy.consoles.type=Groovy 콘솔
groovy.debug.caption=Groovy
groovy.debug.disable.specific.methods=특정 Groovy 클래스로 스텝인투 안 함(&I)
groovy.does.not.support.constructor.type.arguments=Groovy는 생성자 타입 인수를 지원하지 않습니다.
groovy.file.0=Groovy 파일 ''{0}''
groovy.file.extension.is.not.mapped.to.groovy.file.type=*.groovy 파일이 ''{0}''(으)로 매핑되었습니다.\n해당 파일은 설정 | 파일 타입에서 Groovy로 매핑할 수 있습니다.
groovy.library.is.not.configured.for.module=Groovy SDK가 모듈 ''{0}''에 대해 구성되지 않았습니다
groovy.library.label=Groovy 라이브러리
groovy.term.annotation=어노테이션
groovy.term.binding=스크립트 바인딩 변수
groovy.term.class=클래스
groovy.term.closure=클로저
groovy.term.enum=열거형
groovy.term.expression=표현식
groovy.term.field=필드
groovy.term.interface=인터페이스
groovy.term.label=라벨
groovy.term.method=메서드
groovy.term.parameter=매개변수
groovy.term.property=프로퍼티
groovy.term.record=레코드
groovy.term.trait=특성
groovy.term.type.parameter=타입 매개변수
groovy.term.variable=지역 변수
groovy.version.0=Groovy {0}
groovy.version.bundled.0=번들 Groovy {0}
group.Groovy.CheckResources.description=컴파일 문제 확인을 위해 리소스 루트의 모든 Groovy 파일에 대해 컴파일러를 실행합니다
group.Groovy.CheckResources.text=Groovy 리소스(_O)
header.extract.closure=클로저 추출
highlight.if.groovy.object.methods.overridden=invokeMethod(), getProperty() 또는 setProperty()를 재정의하는 클래스의 참조를 강조 표시
highlight.if.missing.methods.declared=missingMethod() 또는 missingProperty()를 선언하는 클래스의 참조를 강조 표시
identifier.expected=식별자가 필요합니다
identifier.or.block.expected=식별자 또는 코드 블록이 필요합니다.
ignore.boolean.expressions=부울 검사 시 대입되지 않은 변수 무시
ignore.when.catch.parameter.is.named.ignore.or.ignored=catch 매개변수의 이름이 ignore 또는 ignored로 지정된 경우 무시
illegal.combination.of.modifiers=제어자 조합이 올바르지 않습니다
illegal.combination.of.modifiers.abstract.and.final=제어자 'abstract' 및 'final'의 조합이 올바르지 않습니다
illegal.combination.of.modifiers.volatile.and.final=제어자 'abstract' 및 'final'의 조합이 올바르지 않습니다
illegal.default.modifier=제어자 'default'는 인터페이스 메서드 내에서만의미가 있습니다
illegal.default.modifier.fix='default' 제어자 제거
illegal.escape.character.in.string.literal=문자열 리터럴의 올바르지 않은 문자 이스케이프
illegal.method.name=메서드 이름에 잘못된 문자가 있습니다. {0}
illegal.nonsealed.modifier.fix='non-sealed' 제어자 제거
illegal.sealed.modifier.fix='sealed' 제어자 제거
illegal.single.argument.lambda=단일 인수는 대입 표현식의 오른쪽 부분에 또는 메서드 호출 내에 인수로서 사용할 수 있습니다.
illegal.type.void=올바르지 않은 타입: 'void'
immutable.options.property.not.exist=프로퍼티 ''{0}''이(가) 없습니다.
implement.class={0} 구현
import.statement.cannot.have.modifiers=import 문은 제어자를 가질 수 없습니다
incorrect.number.of.values=값의 수가 올바르지 않습니다. 기댓값: {0}, 현재 값: {1}
incorrect.variable.name=잘못된 변수 이름
indexed.property.is.applicable.to.properties.only=@IndexedProperty는 프로퍼티에만 적용할 수 없습니다
infer.method.parameters.types=명시적 타입을 매개변수에 추가
infer.method.parameters.types.for.method.declaration=메서드 선언 내 모든 매개변수의 명시적 타입을 추가
initializer.cannot.be.0=이니셜라이저는 {0}이(가) 될 수 없습니다.
initializer.cannot.have.annotations=이니셜라이저는 어노테이션을 가질 수 없습니다.
initializers.are.forbidden.with.defaults=@TupleConstructor에서 'defaults'를 비활성화하면 디폴트 값이 금지됩니다
initializers.are.not.allowed.in.interface=이니셜라이저가 인터페이스에서 허용되지 않습니다.
injection.should.not.contain.line.feeds=GString 삽입에 줄 피드가 포함되면 안 됩니다.
inlay.groovy.implicit.null.argument.hint.description=하나의 인수를 사용하는 메서드에 인수를 전달하지 않는 호출입니다. 즉, 묵시적 null이 인수로 전달됩니다.
inlay.groovy.parameters.hints.inferred.parameter.types=메서드에서 추론된 매개변수 타입.
inlay.groovy.parameters.hints.type.parameter.list=하나 이상의 추론 타입 매개변수가 있는 메서드가 있습니다. <b>추론된 매개변수 타입<b/> 힌트가 필요합니다.
inlay.groovy.variable.type.hints.description=선언에서 명시적으로 지정되지 않은 지역 변수 타입입니다.
inspection.annotations=어노테이션
inspection.assignments=대입 이슈
inspection.bugs=발생할 수 있는 버그
inspection.confusing=코드 구문이 혼동될 수 있습니다.
inspection.control.flow=제어 흐름 이슈
inspection.data.flow=데이터 흐름
inspection.display.name.access.to.inaccessible.element=액세스할 수 없는 요소
inspection.display.name.access.to.static.field.locked.on.instance=static 필드에 대한 액세스가 인스턴스 데이터에서 잠겨 있음
inspection.display.name.annotation.references.unknown.identifier=@TupleConstructor 및 @MapConstructor
inspection.display.name.assignability.check=호환되지 않는 타입 대입
inspection.display.name.assignment.can.be.operator.assignment=대입을 연산자 대입으로 바꿀 수 있습니다
inspection.display.name.assignment.to.for.loop.parameter='for' 루프 매개변수에 대입
inspection.display.name.assignment.to.method.parameter=메서드 매개변수에 대입
inspection.display.name.break='break' 문
inspection.display.name.busy.wait=바쁜 대기
inspection.display.name.change.to.method=연산자 호출을 메서드 호출로 바꿀 수 있음
inspection.display.name.change.to.operator=메서드 호출을 연산자 호출로 바꿀수 있음
inspection.display.name.check.labeled.statement=라벨 지정된 구문 검사
inspection.display.name.clashing.getters=getter 충돌
inspection.display.name.clashing.trait.methods=특성 메서드 충돌
inspection.display.name.class.naming.convention=클래스 이름 지정 규칙
inspection.display.name.conditional=삼항식
inspection.display.name.conditional.can.be.conditional.call=삼항식을 안전한 호출로 바꿀 수 있음
inspection.display.name.conditional.can.be.elvis=삼항식을 elvis 식으로 바꿀 수 있음
inspection.display.name.conditional.with.identical.branches=동일한 브랜치가 있는 삼항식
inspection.display.name.constant.conditional=상수 조건식
inspection.display.name.constant.if.statement=상수 if 문
inspection.display.name.constant.naming.convention=상수 이름 지정 규칙
inspection.display.name.constructor.named.arguments=생성자 호출의 이름 지정된 인수
inspection.display.name.continue='continue' 문
inspection.display.name.continue.or.break.from.finally.block='finally' 블록의 'continue' 또는 'break'
inspection.display.name.delegates.to=@DelegatesTo
inspection.display.name.deprecated.api.usage=곧 사용할 수 없게 될 API 사용
inspection.display.name.divide.by.zero=0으로 나누기
inspection.display.name.double.checked.locking=이중 검사된 락
inspection.display.name.double.negation=이중 부정
inspection.display.name.duplicate.switch.branch=switch case 중복
inspection.display.name.empty.catch.block=빈 'catch' 블록
inspection.display.name.empty.finally.block=빈 'finally' 블록
inspection.display.name.empty.statement.body=본문이 비어 있는 구문
inspection.display.name.empty.sync.block=빈 'synchronized' 블록
inspection.display.name.empty.try.block=빈 'try' 블록
inspection.display.name.equals.between.inconvertible.types=변환할 수 없는 타입의 객체 간의 'equals()'
inspection.display.name.fallthrough='switch' 문의 폴스루
inspection.display.name.final.variable.access=final 변수 액세스
inspection.display.name.groovydoc.check=해결되지 않은 GroovyDoc 참조
inspection.display.name.gstring.key=GString 맵 키
inspection.display.name.if.statement.with.identical.branches=브랜치가 동일한 if 문
inspection.display.name.if.statement.with.too.many.branches=브랜치가 너무 많은 if 문
inspection.display.name.implicit.null.argument=묵시적 null 인수
inspection.display.name.in.argument.check=호환되지 않는 'in'인수 타입
inspection.display.name.incorrect.range.argument=올바르지 않은 범위 인수
inspection.display.name.infinite.loop.statement=무한 루프 문
inspection.display.name.infinite.recursion=무한 재귀
inspection.display.name.instance.method.naming.convention=인스턴스 메서드 이름 지정 규칙
inspection.display.name.instance.variable.naming.convention=인스턴스 변수 이름 지정 규칙
inspection.display.name.java.style.properties.invocation=Java 스타일 프로퍼티 액세스
inspection.display.name.list.get.can.be.keyed.access=List.get 호출이 키 액세스일 수 있습니다
inspection.display.name.list.set.can.be.keyed.access=List.set 호출이 키 액세스일 수 있습니다
inspection.display.name.local.variable.naming.convention=지역 변수 이름 지정 규칙
inspection.display.name.loop.statement.that.doesnt.loop=루프를 실행하지 않는 루프 문
inspection.display.name.map.get.can.be.keyed.access=Map.get 호출이 키 액세스일 수 있습니다
inspection.display.name.map.put.can.be.keyed.access=Map.put 호출이 키 액세스일 수 있습니다
inspection.display.name.method.may.be.static=메서드를 'static'으로 만들 수 있음
inspection.display.name.method.parameter.count=매개변수가 너무 많은 메서드
inspection.display.name.method.with.more.than.three.negations=3개 이상의 부정이 있는 메서드
inspection.display.name.multiple.return.points.per.method=여러 반환점이 있는 메서드
inspection.display.name.negated.conditional=부정된 조건식
inspection.display.name.negated.if=부정된 if 조건식
inspection.display.name.nested.assignment=중첩된 대입
inspection.display.name.nested.conditional=중첩된 조건식
inspection.display.name.nested.switch=부정된 switch 문
inspection.display.name.nested.synchronized.statement=중첩된 'synchronized' 문
inspection.display.name.new.instance.of.singleton=@groovy.lang.Singleton 어노테이션이 추가된 클래스의 새 인스턴스
inspection.display.name.no.return=return 문 누락
inspection.display.name.non.extending.permitted.subclasses=확장이 허용되지 않은 하위 클래스
inspection.display.name.non.short.circuit.boolean=쇼트 서킷이 아닌 부울
inspection.display.name.notify.while.not.synchronized=동기화되지 않은 'wait()' 또는 'notify()'
inspection.display.name.octal.integer=8진 정수
inspection.display.name.overly.complex.arithmetic.expression=지나치게 복잡한 산술 표현식
inspection.display.name.overly.complex.boolean.expression=지나치게 복잡한 부울 표현식
inspection.display.name.overly.complex.method=지나치게 복잡한 메서드
inspection.display.name.overly.long.method=지나치게 긴 메서드
inspection.display.name.overly.nested.method=지나치게 중첩된 메서드
inspection.display.name.package.mismatch=패키지 불일치
inspection.display.name.parameter.naming.convention=메서드 매개변수 이름 지정 규칙
inspection.display.name.pointless.arithmetic=무의미한 산술 표현식
inspection.display.name.pointless.boolean=무의미한 부울 표현식
inspection.display.name.pojo.without.compile.static=@CompileStatic 없는 @POJO
inspection.display.name.public.field.accessed.in.synchronized.context=동기화된 컨텍스트에서 비 private 필드 액세스
inspection.display.name.reassigned.in.closure.local.var=지역 변수가 클로저 또는 익명 클래스에 다시 대입됨
inspection.display.name.result.of.assignment.used=대입 결과 사용
inspection.display.name.result.of.increment.or.decrement.used=사용된 증분 또는 감소의 결과
inspection.display.name.result.of.object.allocation.ignored=객체 대입의 결과가 무시됨
inspection.display.name.return.from.closure.can.be.implicit='return' 문이 묵시적일 수 있음
inspection.display.name.return.from.finally.block='finally' 블록 내 'return'
inspection.display.name.second.unsafe.call=두 번째 안전하지 않은 호출
inspection.display.name.silly.assignment=잘못된 대입
inspection.display.name.singleton.constructor=@Singleton 생성자
inspection.display.name.static.method.naming.convention=static 메서드 이름 지정 규칙
inspection.display.name.static.variable.naming.convention=static 변수 이름 지정 규칙
inspection.display.name.string.style.violation=문자열 스타일 위반
inspection.display.name.switch.exhaustiveness.check=switch 식의 완전성 확인
inspection.display.name.switch.statement.with.no.default=default case가 없는 switch 문
inspection.display.name.synchronization.on.non.final.field=final이 아닌 필드 동기화
inspection.display.name.synchronization.on.this='this' 동기화
inspection.display.name.synchronization.on.variable.initialized.with.literal=리터럴로 초기화된 변수 동기화
inspection.display.name.synchronized.method=동기화된 메서드
inspection.display.name.system.run.finalizers.on.exit=System.runFinalizersOnExit() 호출
inspection.display.name.thread.stop.suspend.resume=Thread.stop(), Thread.suspend() 또는 Thread.resume() 호출
inspection.display.name.throw.from.finally.block='finally' 블록 내 'throw'
inspection.display.name.trivial.conditional=중복 조건식
inspection.display.name.trivial.if=중복 'if' 문
inspection.display.name.type.customizer=타입 커스터마이저 검사
inspection.display.name.unassigned.access=변수가 대입되지 않음
inspection.display.name.unchecked.assignment.of.member.of.raw.type=원시 타입 멤버에서 검사되지 않은 대입
inspection.display.name.unconditional.wait=조건 없는 'wait' 호출
inspection.display.name.unnecessary.alias=불필요한 import 별칭
inspection.display.name.unnecessary.continue=불필요한 'continue' 문
inspection.display.name.unnecessary.def.modifier=불필요한 'def'
inspection.display.name.unnecessary.final.modifier=불필요한 'final'
inspection.display.name.unnecessary.non.sealed.modifier=불필요한 'non-sealed' 제어자
inspection.display.name.unnecessary.public.modifier=불필요한 'public'
inspection.display.name.unnecessary.qualified.reference=불필요한 정규화된 참조
inspection.display.name.unnecessary.return=불필요한 'return' 문
inspection.display.name.unnecessary.sealed.modifier=불필요한 'sealed' 제어자
inspection.display.name.unnecessary.semicolon=불필요한 세미콜론
inspection.display.name.unreachable.statement=도달할 수 없는 구문
inspection.display.name.unresolved.access=해결되지 않은 참조 표현식
inspection.display.name.unresolved.labels.in.named.variant=@NamedVariant/@NamedParam/@NamedDelegate 해결되지 않은 라벨
inspection.display.name.unsynchronized.method.overrides.synchronized.method=비동기화된 메서드가 동기화된 메서드를 재정의
inspection.display.name.untyped.access=타입이 없는 참조 표현식
inspection.display.name.unused.assignment=사용되지 않는 대입
inspection.display.name.unused.catch.parameter=사용되지 않는 'catch' 매개변수
inspection.display.name.unused.declaration=사용되지 않는 선언
inspection.display.name.unused.inc.dec=사용되지 않는 증분 또는 감소
inspection.display.name.variable.can.be.final=변수가 final일 수 있음
inspection.display.name.wait.call.not.in.loop='wait()'가 루프에 없음
inspection.display.name.wait.while.not.synchronized=동기화되지 않은 'wait()'
inspection.display.name.while.loop.spins.on.field=while 루프가 필드에서 스핀
inspection.error.handling=오류 처리
inspection.gpath=GPath
inspection.message.0.not.allowed.for.record=''{0}''은(는) 레코드에서 허용되지 않습니다
inspection.message.access.to.static.field.locked.on.instance.data=static 필드 <code>#ref</code>에 대한 액세스가 인스턴스 데이터에서 잠김 #loc
inspection.message.annotation.non.sealed.cannot.be.applied.to.enum.class=어노테이션 '@NonSealed'는 열거형 클래스에 적용할 수 없습니다
inspection.message.annotation.sealed.cannot.be.applied.to.enum.class=어노테이션 '@Sealed'는 열거형 클래스에 적용할 수 없습니다
inspection.message.arrows.in.case.expressions.are.available.with.groovy.4.or.later=Case 식의 화살표는 Groovy 4.0 이상에서 사용할 수 있습니다
inspection.message.assignment.replaceable.with.operator.assignment=<code>#ref</code>을(를) ''{0}''(으)로 단순화할 수 있습니다 #loc
inspection.message.assignment.to.for.loop.parameter=for 루프 매개변수 '#ref'에 대입 #loc
inspection.message.assignment.to.method.parameter=메서드 매개변수 '#ref'에 대입 #loc
inspection.message.both.open.ranges.are.available.in.groovy.4.or.later=양쪽 열림 범위는 Groovy 4.0 이상에서 사용할 수 있습니다
inspection.message.call.to.ref.can.be.keyed.access='#ref' 호출이 키 액세스일 수 있습니다 #loc
inspection.message.call.to.ref.outside.of.loop=루프 외부에서 '#ref' 호출 #loc
inspection.message.call.to.ref.outside.of.synchronized.context=동기화된 컨텍스트 외부에서 '#ref' 호출 #loc
inspection.message.call.to.ref.outside.synchronized.context=동기화된 컨텍스트 외부의 '#ref' 호출 #loc
inspection.message.call.to.system.ref='System.#ref' 호출 #loc
inspection.message.call.to.thread.ref='스레드.#ref' 호출 #loc
inspection.message.call.to.thread.ref.in.a.loop=루프 내 <code>Thread.#ref()</code> 호출이 바쁜 대기 중일 수 있습니다 #loc
inspection.message.cannot.determine.type.ref='#ref'의 타입을 파악할 수 없습니다
inspection.message.cannot.resolve.method.call=메서드 'call'을 해결할 수 없습니다
inspection.message.case.or.default.branches.are.expected='case' 또는 'default' 브랜치가 필요합니다
inspection.message.class.cannot.be.non.sealed.without.sealed.parent=클래스 ''{0}''은(는) sealed 상위 없이 non-sealed일 수 없습니다
inspection.message.class.has.no.explicit.or.implicit.subclasses=클래스 ''{0}''에 명시적 또는 묵시적으로 허용된 하위 클래스가 없습니다
inspection.message.code.ref.code.recurses.infinitely.can.only.complete.by.throwing.exception=<code>#ref</code>이(가) 무한 반복되며 예외를 던져야 완료됩니다 #loc
inspection.message.code.ref.code.statement.doesnt.loop=<code>#ref</code> 문이 루프되지 않습니다 #loc
inspection.message.compact.constructor.should.have.explicit.visibility.modifier=압축 생성자는 명시적 가시성 제어자가 있어야 합니다
inspection.message.conditional.expression=조건식 #loc
inspection.message.conditional.expression.can.be.call=조건식이 호출일 수 있습니다 #loc
inspection.message.conditional.expression.can.be.elvis=조건식이 elvis일 수 있습니다 #loc
inspection.message.conditional.expression.with.identical.branches=동일한 브랜치가 있는 조건식 #loc
inspection.message.constant.name.ref.doesnt.match.regex=상수 이름 ''#ref''이(가) 정규식 ''{0}''와(과) 일치하지 않습니다 #loc
inspection.message.constant.name.ref.too.long=상수 이름 '#ref'이(가) 너무 깁니다
inspection.message.constant.name.ref.too.short=상수 이름 '#ref'이(가) 너무 짧습니다
inspection.message.couldnt.find.property.field.with.this.name=이 이름을 가진 프로퍼티 또는 필드를 프레임을 찾을 수 없습니다 #loc
inspection.message.divide.by.zero=0으로 나누기 #loc
inspection.message.double.checked.locking=이중 검사된 락 #loc
inspection.message.double.negation.ref=이중 부정 #ref #loc
inspection.message.dsl.descriptor.file.has.been.changed.and.isnt.currently.executed=DSL 설명자 파일이 변경되어 현재 실행되지 않습니다
inspection.message.dsl.descriptor.file.has.been.disabled.due.to.processing.error=처리 오류로 인해 DSL 설명자 파일이 비활성화되었습니다
inspection.message.duplicate.switch.case.ref=중복 switch case '#ref' #loc
inspection.message.empty.ref.block=빈 '#ref' 블록 #loc
inspection.message.fallthrough.in.switch.statement='switch' 문의 폴스루 #loc
inspection.message.fraction.literals.without.leading.zero.are.available.in.groovy.or.later=선행 0이 없는 프랙션 리터럴은 Groovy 4.0 이상에서 사용할 수 있습니다
inspection.message.gstring.used.as.maps.key=GString이 맵 키로 사용되었습니다 #loc
inspection.message.instance.method.name.ref.doesnt.match.regex=인스턴스 메서드 이름 ''#ref''이(가) 정규식 ''{0}''와(과) 일치하지 않습니다 #loc
inspection.message.instance.method.name.ref.too.long=인스턴스 메서드 이름 '#ref'이(가) 너무 깁니다
inspection.message.instance.method.name.ref.too.short=인스턴스 메서드 이름 '#ref'이(가) 너무 짧습니다
inspection.message.instance.variable.name.ref.doesn.t.match.regex=인스턴스 변수 이름 ''#ref''이(가) 정규식 ''{0}''와(과) 일치하지 않습니다 #loc
inspection.message.instance.variable.name.ref.too.long=인스턴스 변수 이름 '#ref'이(가) 너무 깁니다
inspection.message.instance.variable.name.ref.too.short=인스턴스 변수 이름 '#ref'이(가) 너무 짧습니다
inspection.message.interface.cannot.be.non.sealed.without.sealed.parent=인터페이스 ''{0}''은(는) sealed 상위 없이 non-sealed일 수 없습니다
inspection.message.interface.has.no.explicit.or.implicit.implementors=인터페이스 ''{0}''에 명시적 또는 묵시적으로 허용된 구현자가 없습니다
inspection.message.interpolated.string.should.be.dollar.slashy.quoted=보간된 문자열은 달러 슬래시로 묶어야 합니다
inspection.message.interpolated.string.should.be.double.quoted=보간된 문자열은 큰따옴표로 묶어야 합니다
inspection.message.interpolated.string.should.be.quoted.with.triple.double.quotes=보간된 문자열은 '"""로 묶어야 합니다
inspection.message.interpolated.string.should.be.slashy.quoted=보간된 문자열은 슬래시로 묶어야 합니다
inspection.message.invalid.permits.clause.must.be.sealed=잘못된 ''permits'' 절: ''{0}''이(가) ''sealed''여야 합니다
inspection.message.invalid.permits.clause.must.directly.extend=잘못된 ''permits'' 절: ''{0}''이(가) ''{1}''을(를) 직접 확장해야 합니다
inspection.message.keyword.yield.available.with.groovy.4.or.later=키워드 'yield'는 Groovy 4.0 이상에서 사용할 수 있습니다
inspection.message.label.name.ref.not.supported.by.0={0}은(는) 라벨 이름 ''#ref''을(를) 지원하지 않습니다
inspection.message.left.open.ranges.are.available.in.groovy.4.or.later=왼쪽 열림 범위는 Groovy 4.0 이상에서 사용할 수 있습니다
inspection.message.local.variable.name.ref.doesnt.match.regex=지역 변수 이름 ''#ref''이(가) 정규식 ''{0}''와(과) 일치하지 않습니다 #loc
inspection.message.local.variable.name.ref.too.long=지역 변수 이름 '#ref'이(가) 너무 깁니다
inspection.message.local.variable.name.ref.too.short=지역 변수 이름 '#ref'이(가) 너무 짧습니다
inspection.message.method.called.with.implicit.null.argument=메서드는 묵시적 null 인수로 호출됩니다
inspection.message.method.parameter.name.ref.doesnt.match.regex=메서드 매개변수 이름 ''#ref''이(가) 정규식 ''{0}''와(과) 일치하지 않습니다 #loc
inspection.message.method.parameter.name.ref.too.long=메서드 매개변수 이름 '#ref'이(가) 너무 깁니다
inspection.message.method.parameter.name.ref.too.short=메서드 매개변수 이름 '#ref'이(가) 너무 짧습니다
inspection.message.method.ref.contains.too.many.parameters.0.1=모듈 ''#ref''에 매개변수가 너무 많습니다({0}>{1})
inspection.message.method.ref.has.too.many.negations=메서드 ''#ref''에 부정이 너무 많습니다({0}>3)
inspection.message.method.ref.overly.complex.cyclomatic.complexity=메서드 ''#ref''이(가) 지나치게 복잡합니다(순환 복잡도 = {0}>{1})
inspection.message.method.ref.overly.nested.nesting.depth=메서드 ''#ref''이(가) 지나치게 중첩되어 있습니다(중첩 깊이 = {0}>{1})
inspection.message.method.ref.too.long.statement.count=메서드 ''#ref''이(가) 지나치게 깁니다(구문 수 = {0}>{1}})
inspection.message.mixing.arrows.colons.not.allowed=화살표와 콜론은 혼용할 수 없습니다
inspection.message.modifier.non.sealed.cannot.be.applied.to.enum.class=제어자 'non-sealed'는 열거형 클래스에 적용할 수 없습니다
inspection.message.modifier.nonsealed.available.with.groovy.or.later=제어자 'non-sealed'는 Groovy 4.0 이상에서 사용할 수 있습니다
inspection.message.modifier.sealed.available.with.groovy.or.later=제어자 'sealed'는 Groovy 4.0 이상에서 사용할 수 있습니다
inspection.message.modifier.sealed.cannot.be.applied.to.enum.class=제어자 'sealed'는 열거형 클래스에 적용할 수 없습니다
inspection.message.multiline.string.should.be.dollar.slashy.quoted=여러 줄 문자열은 달러 슬래시로 묶어야 합니다
inspection.message.multiline.string.should.be.quoted.with.triple.double.quotes=여러 줄 문자열은 """로 묶어야 합니다
inspection.message.multiline.string.should.be.quoted.with.triple.quotes=여러 줄 문자열은 ''''로 묶어야 합니다
inspection.message.multiline.string.should.be.slashy.quoted=여러 줄 문자열은 슬래시로 묶어야 합니다
inspection.message.multiple.expressions.in.case.section.are.available.with.groovy.4.or.later=Case 라벨의 다중 표현식은 Groovy 4.0 이상에서 사용할 수 있습니다
inspection.message.negated.conditional.expression=부정된 조건식 #loc
inspection.message.negated.if.condition.expression=부정된 if 조건식 #loc
inspection.message.nested.assignment=대입 표현식 결과 사용 위치 #loc
inspection.message.nested.assignment.expression=중첩된 대입식 #loc
inspection.message.nested.conditional.expression=중첩된 조건식 #loc
inspection.message.nested.ref.statement=중첩된 '#ref' 문 #loc
inspection.message.non.private.field.accessed.in.synchronized.context=동기화된 컨텍스트에서 비 private 필드 ‘#ref'이(가) 액세스됩니다 #loc
inspection.message.non.short.circuit.boolean.expression=쇼트 서킷이 아닌 부울 표현식 #loc
inspection.message.not.allowed.in.sealed.hierarchy=''{0}''은(는) sealed 계층 구조에서 허용되지 않습니다
inspection.message.octal.integer.ref=8진 정수 #ref #loc
inspection.message.only.one.final.sealed.non.sealed.should.be.applied.to.class='final', 'sealed', 'non-sealed', @Sealed 또는 @NonSealed 중 하나만 클래스에 적용해야 합니다
inspection.message.overly.complex.arithmetic.expression=지나치게 복잡한 산술 표현식 #loc
inspection.message.overly.complex.boolean.expression=지나치게 복잡한 부울 표현식 #loc
inspection.message.package.name.mismatch=패키지 이름 불일치
inspection.message.package.name.mismatch.actual.0.expected.1=패키지 이름 불일치. 실제: ''{0}'', 필요: ''{1}''
inspection.message.permits.available.with.groovy.4.or.later='permits'는 Groovy 4.0 이상에서 사용할 수 있습니다
inspection.message.plain.string.should.be.dollar.slashy.quoted=일반 문자열은 달러 슬래시로 묶어야 합니다
inspection.message.plain.string.should.be.double.quoted=일반 문자열은 큰따옴표로 묶어야 합니다
inspection.message.plain.string.should.be.quoted.with.triple.double.quotes=일반 문자열은 '"""로 묶어야 합니다
inspection.message.plain.string.should.be.quoted.with.triple.quotes=일반 문자열은 ''''로 묶어야 합니다
inspection.message.plain.string.should.be.single.quoted=일반 문자열은 작은따옴표로 묶어야 합니다
inspection.message.plain.string.should.be.slashy.quoted=일반 문자열은 슬래시로 묶어야 합니다
inspection.message.pojo.has.effect.only.with.compilestatic=@POJO는 @CompileStatic이 있을 때만 효과가 있습니다
inspection.message.property.0.is.final=프로퍼티 ''{0}''이(가) final입니다 #loc
inspection.message.property.0.is.ignored.by.map.constructor=프로퍼티 ''{0}''이(가) @MapConstructor에 의해 무시되었습니다 #loc
inspection.message.property.not.indexable.type.must.be.array.or.list.but.found.0=프로퍼티는 색인 생성할 수 없습니다. 타입은 배열 또는 목록이어야 하나 {0}이(가) 발견됩니다
inspection.message.record.parameter.should.be.immutable=레코드 매개변수 ''{0}''은(는) 불변 타입을 포함하거나 @ImmutableOptions를 통해 불변 타입으로 선언되어야 합니다
inspection.message.records.are.available.in.groovy.4.or.later=레코드는 Groovy 4.0.0-beta-2 이상에서 사용할 수 있습니다
inspection.message.ref.can.be.simplified='#ref'을(를) 단순화할 수 있습니다 #loc
inspection.message.ref.has.0.return.points=<code>#ref</code>에 {0}개의 반환점이 있습니다 #loc
inspection.message.ref.inside.finally.block='finally' 블록 내 '#ref' #loc
inspection.message.ref.is.unnecessary.as.last.statement.in.loop=루프의 마지막 구문으로서 #ref 은(는) 불필요합니다 #loc
inspection.message.ref.is.unnecessary.as.last.statement.in.method.with.no.return.value=반환값이 없는 메서드의 마지막 구문으로서 #ref 은(는) 불필요합니다 #loc
inspection.message.ref.loop.spins.on.field=<code>#ref</code> 루프가 필드에서 스핀합니다 #loc
inspection.message.ref.statement=#ref 문 #loc
inspection.message.ref.statement.at.end.closure.can.be.made.implicit=클로저 끝에서 명시적 반환 #loc
inspection.message.ref.statement.can.be.simplified=#ref 문을 단순화할 수 있습니다 #loc
inspection.message.ref.statement.cannot.complete.without.throwing.exception=<code>#ref</code> 문은 예외를 던지지 않으면 완료되지 않습니다 #loc
inspection.message.ref.statement.has.empty.body='#ref' 문의 본문이 비어 있습니다
inspection.message.ref.statement.has.empty.branch='#ref' 문의 브랜치가 비어 있습니다
inspection.message.ref.statement.with.identical.branches=동일한 브랜치가 있는 '#ref' 문 #loc
inspection.message.ref.statement.with.no.default.branch='default' 브랜치가 없는 #ref 문 #loc
inspection.message.ref.statement.with.too.many.branches=''#ref'' 문에 브랜치가 너무 많습니다({0}) #loc
inspection.message.result.increment.or.decrement.expression.used=증감 결과 사용 위치 #loc
inspection.message.result.of.new.ref.is.ignored=''new #ref{0}''의 결과가 무시되었습니다 #loc
inspection.message.silly.assignment=잘못된 대입 #loc
inspection.message.static.interface.methods.must.be.qualified.in.groovy.4=Groovy 4부터 '정적' 인터페이스 메서드를 사용할 수 있어야 합니다.
inspection.message.static.method.name.ref.doesnt.match.regex=정적 메서드 이름 ''#ref''이(가) 정규식 ''{0}''와(과) 일치하지 않습니다 #loc
inspection.message.static.method.name.ref.too.long=정적 메서드 이름 '#ref'이(가) 너무 깁니다
inspection.message.static.method.name.ref.too.short=정적 메서드 이름 '#ref'이(가) 너무 짧습니다
inspection.message.static.variable.name.ref.doesnt.match.regex=정적 변수 이름 ''#ref''이(가) 정규식 ''{0}''와(과) 일치하지 않습니다 #loc
inspection.message.static.variable.name.ref.too.long=정적 변수 이름 '#ref'이(가) 너무 깁니다
inspection.message.static.variable.name.ref.too.short=정적 변수 이름 '#ref'이(가) 너무 짧습니다
inspection.message.string.escaping.could.be.minimized=이스케이프를 최소화할 수 있습니다
inspection.message.switch.expression.does.not.cover.all.possible.outcomes=switch 식이 모든 가능한 결과를 포함하지 않습니다
inspection.message.switch.expressions.are.available.with.groovy.4.or.later=Switch 식은 Groovy 4.0 이상에서 사용할 수 있습니다
inspection.message.switch.expressions.do.not.support.return=switch 식은 'return'을 지원하지 않습니다
inspection.message.synchronization.on.non.final.field.ref=final이 아닌 필드 '#ref' 동기화 #loc
inspection.message.synchronization.on.ref=\ '#ref' 동기화 #loc
inspection.message.synchronization.on.variable.ref.which.was.initialized.with.literal=리터럴로 초기화된 변수 '#ref' 동기화 #loc
inspection.message.synchronized.method.ref=동기화된 메서드 '#ref' #loc
inspection.message.traits.0.contain.clashing.methods.with.signature.1=시그니처 {1}이(가) 포함된 충돌 메서드가 특성 {0}에 있습니다
inspection.message.trivial.conditional.expression=자명한 조건 표현식 #loc
inspection.message.type.argument.0.can.not.be.1=인수 ''{0}''의 타입은 ''{1}''일 수 없습니다
inspection.message.unconditional.call.to.ref=<code>#ref()</code>을(를) 조건 없이 호출합니다 #loc
inspection.message.unreachable.statement=도달할 수 없는 명령문 #loc
inspection.message.unsynchronized.method.ref.overrides.synchronized.method=비동기화된 메서드 '#ref'이(가) 동기화된 메서드를 재정의합니다 #loc
inspection.message.unused.catch.parameter.ref=사용되지 않는 catch 매개변수 '#ref' #loc
inspection.message.yield.or.throw.expected.in.case.section='yield' 또는 'throw'가 case 섹션에 필요합니다
inspection.method.metrics=메서드 메트릭
inspection.naming=이름 지정 규칙
inspection.other=기타
inspection.redundancy=선언 중복성
inspection.separator.disable.in.file.types=다음의 파일 형식에서 활성화:
inspection.style=스타일
inspection.threading=스레딩 문제
inspection.validity=유효성 이슈
intention.category.closures=Groovy/클로저
intention.category.comments=Groovy/주석
intention.category.control.flow=Groovy/제어 흐름
intention.category.conversions=Groovy/표현식 변환
intention.category.groovy=Groovy
intention.category.groovy.declaration=Groovy/선언
intention.category.groovy.other=Groovy/기타
intention.category.groovy.style=Groovy/Groovy 스타일
intention.family.name.activate.dsl.descriptor=DSL 설명자 활성화
intention.family.name.add.attributes.to.annotation=어노테이션에 속성 추가
intention.family.name.add.cast=형 변환 추가
intention.family.name.add.class.to.clause=절에 클래스 추가
intention.family.name.add.missing.case.branches=누락된 case 브랜치 추가
intention.family.name.add.parameter.cast=매개변수 형 변환 추가
intention.family.name.change.variable.type=변수 타입 변경
intention.family.name.collapse.conditional.expressions=조건식 접기
intention.family.name.collapse.if.statement='if' 문 접기
intention.family.name.convert.conditional.expression.to.elvis=조건식을 Elvis로 변환
intention.family.name.create.field=필드 생성
intention.family.name.fix.quotation=따옴표 수정
intention.family.name.fix.range.class=range 클래스 수정
intention.family.name.make.return.implicit=반환을 묵시적으로 만들기
intention.family.name.remove.double.negation=이중 부정 제거
intention.family.name.remove.unnecessary.continue=불필요한 continue 제거
intention.family.name.remove.unnecessary.return=불필요한 return 제거
intention.family.name.rename=이름 변경
intention.family.name.replace.for.each.operator='for-each' 연산자 바꾸기
intention.family.name.replace.keywords=요소 바꾸기
intention.family.name.replace.modifiers=제어자 바꾸기
intention.family.name.replace.something.with=''{0}''을(를) ''{1}''(으)로 바꾸기
intention.family.name.replace.with.conditional.call=조건 호출로 바꾸기
intention.family.name.replace.with.keyed.access=키 액세스로 바꾸기
intention.family.name.replace.with.short.circuit.expression=단락 표현식으로 바꾸기
intention.family.name.simplify=단순화
intention.name.activate.back=다시 활성화
intention.name.add.required.attributes.to.map.constructor='@MapConstructor'에 필수 속성 추가
intention.name.add.to.clause=''{0}''을(를) ''{2}''의 {1} 절에 추가
intention.name.cast.operand.to.0=피연산자를 {0}(으)로 형 변환
intention.name.cast.to.0={0}(으)로 형 변환
intention.name.change.quotes.to.triple.double.quotes=따옴표를 """로 변경
intention.name.change.quotes.to.triple.single.quotes=따옴표를 "로 변경
intention.name.convert.to.dollar.slashy.string=달러 슬래시 문자열로 변환
intention.name.convert.to.double.quoted.string=큰따옴표로 묶인 문자열로 변환
intention.name.convert.to.single.quoted.string=작은따옴표로 묶인 문자열로 변환
intention.name.convert.to.slashy.string=슬래시 문자열로 변환
intention.name.create.abstract.method.in.class=''{1}''에 abstract 메서드 ''{0}'' 생성
intention.name.create.constant.field.in.class=''{1}''에 상수 필드 ''{0}'' 생성
intention.name.create.enum.constant.0=열거형 상수 ''{0}'' 생성
intention.name.create.field.in.class=''{1}''에 필드 ''{0}'' 생성
intention.name.create.method.in.class=''{1}''에 메서드 ''{0}'' 생성
intention.name.insert.case.0=''case {0}'' 삽입
intention.name.insert.case.0.case.1=''case {0}'', ''case {1}'' 삽입
intention.name.insert.default.branch='default' 브랜치 삽입
intention.name.insert.missing.branches=누락된 브랜치 삽입
intention.name.make.compact.constructor.public=압축 생성자를 'public'으로 만들기
intention.name.remove.wrong.modifiers.for.record=잘못된 기록용 제어자 제거
intention.name.replace=''{0}''을(를) ''{1}''(으)로 바꾸기
intention.name.replace.eq.with.0.eq=''=''를 ''{0}=''로 바꾸기
intention.name.replace.with.in=':'을 'in'으로 바꾸기
intention.name.replace.with.qualified.expression=정규화된 이름으로 바꾸기
interface.cannot.have.modifier.final=인터페이스는 제어자 'final'을 가질 수 없습니다
interface.members.are.not.allowed.to.be=인터페이스 멤버는 {0}이(가) 될 수 없습니다.
interface.must.have.no.static.method=인터페이스는 정적 메서드를 가질 수 없습니다.
introduce.constant.title=상수 삽입
introduce.parameter.delegate.via.overload=오버로딩 메서드를 통한 위임(&L)
introduce.parameter.delegating.unavailable.tooltip=위임은 클로저 컨텍스트에서 허용되지 않습니다
introduce.parameter.do.not.replace.option.label=바꾸기 안 함(&O)
introduce.parameter.explicit.return.statement.option.label=명시적 return 문 사용(&X)
introduce.parameter.replace.all.fields.option.label=모든 필드 바꾸기(&R)
introduce.parameter.replace.fields.border.title=표현식에 사용된 필드를 getter로 바꾸기
introduce.parameter.replace.inaccessible.fields.option.label=사용 컨텍스트에서 액세스할 수 없는 필드 바꾸기(&I)
introduce.variable.change.type.advertisement={0}을(를) 눌러 타입 변경
introduce.variable.declare.final.label=final 선언(&F)
introduce.variable.name.label=이름(&N):
introduce.variable.replace.all.0.occurrences=모든 찾은 항목 바꾸기({0}개의 찾은 항목)(&A)
introduce.variable.replace.all.occurrences=모든 찾은 항목 바꾸기(&A)
introduce.variable.type.label=타입(&T):
invalid.lvalue=대입할 값이 올바르지 않습니다.
invalid.qualified.name=올바른 Groovy 정규화된 이름이 아닙니다
investigate.gdsl.error.family.name=DSL 설명자 프로세스 오류 조사
investigate.gdsl.error.intention.name=세부 정보 표시
invoke.completion.second.time.to.show.skipped.methods=코드 완성을 2번째 호출하여 건너뛴 메서드 표시
is.not.enclosing.class=''{0}''이(가) 둘러싸는 클래스가 아닙니다
java.style.for.each.statement.requires.a.type.declaration=Java 스타일의 for-each 문에는 타입 선언이 필요합니다.
java.style.properties.invocation.intention.family.name=Java 스타일 접근자 호출을 Groovy 스타일 프로퍼티 참조로 변경
java.style.properties.invocation.intention.name=Groovy 스타일 프로퍼티 참조로 변경
java.style.property.access=Java 스타일 접근자 호출
label.already.used=라벨 ''{0}''은(는) 이미 사용 중입니다.
label.groovy.sdk=Groovy SDK:
language.groovy=Groovy
leave.only.modifier.or.annotation.0=''{0}''만 남기기
listener.list.field.must.have.a.generic.collection.type=@ListenerList 필드는 제네릭 Collection 타입이 필요합니다
listener.list.field.with.generic.wildcards.not.supported=제네릭 와일드카드가 있는 @ListenerList 필드는 지원되지 않습니다
live.template.context.declaration=선언
live.template.context.expression=표현식
live.template.context.statement=구문
local.var.0.is.reassigned=지역 변수 ''{0}''이(가) 다시 대입되었습니다
local.variable.types=지역 변수 타입
lock.field.0.must.be.static=잠금 필드 ''{0}''은(는) static이어야 합니다
lock.field.0.must.not.be.static=잠금 필드 ''{0}''은(는) static일 수 없습니다
lock.field.0.not.found=잠금 필드 ''{0}''을(를) 찾을 수 없습니다
loss.of.precision=정확도가 ''{0}''에서 ''{1}''(으)로 손실될 수 있습니다.
map.param.name=맵 매개변수 이름(&N):
map.parameter.dialog.create.new.checkbox=이름 지정된 인수의 새 매개변수 생성(&C)
map.parameter.dialog.explicit.type.checkbox=명시적으로 타입 지정
method.0.cannot.have.weaker.access.privileges.1.than.2.in.3.4=메서드 ''{0}''은(는) ''{3}''(''{4}'')에서 ''{2}''보다 약한 액세스 권한(''{1}'')을 가질 수 없습니다.
method.0.cannot.override.method.1.in.2.overridden.method.is.final=메서드 ''{0}''은(는) ''{2}''에서 메서드 ''{1}''을(를) 재정의할 수 없으며, 재정의된 메서드는 final입니다.
method.0.is.too.complex.too.analyze=메서드 ''{0}''이(가) 너무 복잡하여 분석할 수 없습니다.\n지역 변수 타입이 추론되지 않았습니다.
method.call.is.ambiguous=메서드 호출이 모호합니다.
method.does.not.override.super=메서드가 상위 클래스의 메서드를 재정의하지 않습니다.
method.duplicate=시그니처 {0}이(가) 포함된 메서드는 클래스 ''{1}''에 이미 정의되어 있습니다
method.has.incorrect.modifier.volatile=메서드에 있는 제어자 'volatile'이 올바르지 않습니다
method.is.not.implemented=메서드 ''{0}''이(가) 구현되어 있지 않습니다.
method.is.used.outside.of.groovy=메서드가 Groovy 외부에서 사용됩니다
method.may.be.static=메서드가 static 일 수 있습니다
method.may.be.static.ignore.empty.method.option=빈 메서드 무시
method.may.be.static.only.private.or.final.option=final 또는 private 메서드만 검사
method.may.be.static.option.ignore.trait.methods=특성 메서드 무시
method.parameters.count.max.parameters.option=최대 매개변수 개수:
method.returns.max.returns.option=반환점 제한:
method.with.signature.already.exists=시그니처 {0}이(가) 포함된 메서드가 이미 있습니다
method.with.type.parameters.should.have.return.type=타입 매개변수가 있는 메서드에는 반환 타입이 있어야 합니다
missed.attributes=누락된 속성: {0}
missing.required.named.parameter=이름 지정된 필수 매개변수 ''{0}''이(가) 없습니다.
mixing.private.and.public.protected.methods.of.the.same.name=이름이 같은 private 및 public/protected 메서드가 혼재되어 있습니다.
modifier.0.not.allowed=제어자 ''{0}''은(는) 여기에서 허용되지 않습니다
modifier.transient.not.allowed.here=제어자 'transient'는 여기에서 허용되지 않습니다
modifier.volatile.not.allowed.here=제어자 'volatile'은 여기에서 허용되지 않습니다.
module.name.0.and.groovy.version.1={0}({1})
module.with.groovy=Groovy 라이브러리가 연결된 간단한 모듈
move.class.0.from.method=올바른 위치로 ''{0}'' 이동
move.class.from.method.family.name=올바른 위치로 이동하는 빠른 수정
move.to.correct.dir=패키지 ''{0}''(으)로 이동
move.to.correct.dir.family.name=올바른 패키지로 파일 이동
multiple.assignments.without.list.expr=정적 타입 검사 모드에서는 오른쪽에 list 표현식이 없는 여러 개의 대입이 지원되지 않습니다.
named.arguments.are.not.allowed.inside.index.operations=이름 지정된 인수는 색인 연산 내에서 허용되지 않습니다.
native.methods.cannot.have.body=네이티브 메서드는 본문을 가질 수 없습니다.
native.visibility.presentation=native
new.class.action.description=새 Groovy 클래스를 생성합니다
new.class.action.text=Groovy 클래스
new.class.dialog.title=새 Groovy 클래스
new.class.list.item.annotation=어노테이션
new.class.list.item.class=클래스
new.class.list.item.enum=열거형
new.class.list.item.interface=인터페이스
new.class.list.item.record=레코드
new.class.list.item.trait=특성
new.gant.script.dialog.message=새 Gant 스크립트 이름을 입력하세요
new.gant.script.dialog.title=새 Gant 스크립트
new.instance.of.singleton=@groovy.lang.Singleton 어노테이션이 지정된 클래스의 새 인스턴스
new.project.wizard.groovy.creating.main.file=Groovy 메인 파일 생성 중…
new.project.wizard.groovy.retrieving.has.failed=Groovy 버전을 가져오지 못했습니다
new.script.action.description=새 Groovy 스크립트를 생성합니다
new.script.action.text=Groovy 스크립트
new.script.dialog.title=새 Groovy 스크립트 이름 입력
new.script.list.item.script=Groovy 스크립트
new.script.list.item.script.dsl=GroovyDSL 스크립트
newlines.here.are.available.since.groovy.3=인수 목록 내의 줄 바꿈 문자는 Groovy 3.0부터 사용할 수 있습니다
no.applicable.signature.found=적용 가능한 시그니처를 찾을 수 없음
no.class.expected.here=여기에서는 클래스가 필요하지 않습니다
no.class.in.file.template=파일 템플릿에서 클래스를 찾을 수 없습니다
no.implements.clause.allowed.for.interface=인터페이스는 'implements' 절을 가질 수 없습니다.
no.interface.expected.here=여기에서는 인터페이스가 필요하지 않습니다
no.return.message=일부 실행 경로가 값을 반환하지 않습니다
no.such.property=프로퍼티 ''{0}''이(가) 없습니다.
no.super.classes.found=상위 클래스를 찾을 수 없습니다.
no.super.method.found=상위 메서드를 찾을 수 없습니다.
no.type.specified=지정된 타입이 없습니다
non.sealed.visibility.presentation=비 sealed
non.static.classes.not.allowed=비정적 내부 클래스는 특성에서 허용되지 않습니다.
not.abstract.method.should.have.body=추상 메서드에 본문이 있어서는 안 됩니다.
not.allowed.modifier.in.for.in=제어자 ''{0}''은(는) 여기에서 허용되지 않습니다
notification.group.grape=Groovy @Grab 어노테이션 처리됨
notification.group.groovy.dsl=Groovy DSL 오류
only.abstract.class.can.have.abstract.method=추상 클래스만이 추상 메서드를 가질 수 있습니다.
only.traits.expected.here=여기에는 특성만이 필요합니다.
operator.call.is.ambiguous=연산자 호출이 모호합니다.
operator.is.not.supported.in=연산자 ''{0}''은(는) 현재 버전에서 지원되지 않습니다.
optimize.all.imports=사용되지 않는 import 문 최적화
optimize.imports=import 문 최적화
optimize.imports.progress.title=Groovy 파일에서 import 문 최적화 중...
other.scope=기타 범위
overly.complex.method.complexity.limit.option=메서드 복잡도 제한:
overly.long.method.statements.limit.option=메서드당 최대 구문 수:
overly.nested.method.nesting.limit.option=최대 중첩 깊이:
overriding.methods.of.0=''{0}''의 재정의하는 메서드
package.definition.cannot.have.modifiers=패키지 정의는 제어자를 가질 수 없습니다
packageLocal.visibility.presentation=디폴트 가시성
parameter.can.be.final.tooltip=매개변수 ''{0}''은(는) final이 될 수 있습니다
parameter.cast.fix={0,number,ordinal}번째 매개변수를 {1}(으)로 형 변환합니다.
parameter.hint.number.of.arguments={0, choice, 0#|1#{0}개의 인수|2#{0}개의 인수}
parameter.list.owner.chooser.title=다음으로 매개변수 삽입
pointless.arithmetic.error.message=불필요한 산술 연산 #loc
pointless.boolean.problem.descriptor=불필요한 부울 연산 #loc
pointless.boolean.quickfix=단순화
popup.content.navigation.to.overriding.classes.unavailable=색인 업데이트 중에는 재정의하는 클래스로 이동할 수 없습니다
postfix.template.provider.name=Groovy
primitive.bound.types.are.not.allowed=기본 바운드 타입은 허용되지 않습니다.
primitive.type.parameters.are.not.allowed=기본 타입 매개변수는 타입 매개변수 목록에서 허용되지 않습니다.
private.visibility.presentation=private
property.missing=propertyMissing
property.name.expected=프로퍼티 이름이 필요합니다
protected.visibility.presentation=protected
public.visibility.presentation=public
pull.up.abstract.wont.be.accessible.from={0}은(는) 하위 클래스에서 액세스할 수 없으므로 추상으로 만들 수 없습니다.
pull.up.wont.be.accessible.from={1}에서 {0}에 액세스할 수 없습니다
pull.up.wont.be.accessible.from.the.subclass={0}이(가) 하위 클래스에서 액세스할 수 없는 {1}을(를) 사용합니다.
qualified.0.is.allowed.only.in.nested.or.inner.classes=한정된 {0}은(는) 중첩/내부 클래스에서만 허용됩니다.
recursive.constructor.invocation=재귀 생성자 호출
remove.0=''{0}'' 제거
remove.catch.block=catch 블록 제거
remove.exception=예외 제거
remove.modifier=''{0}'' 제거
remove.parameter.0=매개변수 ''{0}'' 제거
remove.unused.parameter=사용되지 않은 매개변수 제거
rename.file.to.0=파일 이름을 ''{0}'' (으)로 변경
repetitive.method.name.0=메서드 이름 ''{0}''이 반복됩니다.
replace.0.with.1=''{0}''을(를) 이항 ''{1}''(으)로 바꾸기
replace.all.occurrences.and.remove.variable.0=모든 찾은 항목 바꾸기 및 변수 ''{0}'' 제거
replace.new.expression.with.instance.access=인스턴스 액세스로 바꾸기
replace.postfix.0.with.prefix.0=접미사 ''{0}''을(를) 접두사 ''{0}''(으)로 바꾸기
replace.primitive.type.with.wrapper=기본 타입을 래퍼로 바꾸기
replace.qualified.name.with.import=정규화된 이름을 import 문으로 바꾸기
replace.with.get.at=색인 액세스로 바꿉니다.
replace.with.list.literal=list 리터럴로 바꿉니다.
replace.with.method.fix=''{0}'' 메서드로 바꿉니다.
replace.with.method.message=''{0}'' 메서드 호출로 바꿀 수 있습니다
replace.with.operator.compareTo.equality.option='compareTo' 등식을 equals(예: ==)로 바꾸기
replace.with.operator.double.negation.option=이중 부정 사용(예: !!)
replace.with.operator.fix=''{0}''을(를) 연산자로 바꾸기
replace.with.operator.message=''{0}''을(를) 연산자로 바꿀 수 있습니다
replace.with.operator.parentheses=추가 소괄호가 필요한 경우 연산자로 바꾸도록 제안 안 함
replace.with.wrapper=''{0}''(으)로 바꾸기
require.closure.as.attribute.value=속성 값으로 클로저가 필요합니다
return.type.is.incompatible={1} 내 {0}의 반환 타입이 {3} 내 {2}와(과) 호환되지 않습니다
rtype.cannot.contain.ltype=''{1}''은(는) ''{0}''을(를) 포함할 수 없습니다
run.configuration.module.chooser.label=모듈(&M):
run.configuration.module.classpath.checkbox=러너에 모듈 클래스 경로 추가(&C)
run.configuration.script.path.label=스크립트 경로:
script.cannot.have.modifier.native=스크립트 메서드는 제어자 'native'를 가질 수 없습니다
script.generated.with.same.name=스크립트 코드에 대해 생성된 통합 클래스 ''{0}''이(가) 있습니다.
script.method.cannot.have.modifier.abstract=스크립트 메서드는 제어자 'abstract'를 가질 수 없습니다
script.runner.cant.find.script=스크립트 ''{0}''을(를) 찾을 수 없습니다
script.runner.chooser.description=스크립트 경로 지정:
script.runner.chooser.title=스크립트 경로
script.runner.class.cannot.be.executed=클래스를 실행할 수 없습니다
script.runner.class.does.not.exist=클래스가 없습니다
script.runner.description=Groovy 클래스 또는 스크립트
script.runner.display.name=Groovy
script.runner.file.is.not.groovy.file=스크립트 파일이 Groovy 파일이 아닙니다
script.runner.module.not.specified.message=모듈이 지정되지 않았습니다
script.runner.no.groovy.for.module=Groovy가 모듈 ''{0}''에 대해 구성되지 않았습니다
script.runner.unknown.script.type=알 수 없는 스크립트 타입 ''{0}''
sealed.visibility.presentation=sealed
second.unsafe.call=두 번째 안전하지 않은 호출
select.framework.0.home.title={0} 홈 선택
select.module.action.description=클래스 경로를 사용할 모듈을 선택합니다
select.module.action.text=모듈 선택…
select.module.popup.title=모듈 클래스 경로 사용
selfType.class.does.not.inherit=@SelfType: 클래스 ''{0}''은(는) ''{1}''을(를) 상속해 있지 않습니다.
separator.domain.of.inspection.usage=사용 위치 도메인
separator.preferable.string.kind=선호 종류
settings.code.style.absolute=절대
settings.code.style.indent.labels=라벨 들여쓰기
settings.code.style.indent.statements.after.label=라벨 다음 구문 들여쓰기
settings.code.style.label.indent.size=라벨 들여쓰기 크기:
settings.code.style.label.indent.style=라벨 들여쓰기 스타일:
settings.compiler.alternative=다른 방법으로, <a>Java 컴파일러 페이지</a>에서 Groovy-Eclipse 컴파일러를 지정할 수 있습니다.
settings.compiler.exclude.from.stub.generation=스텁 생성에서 제외:
settings.compiler.invoke.dynamic.support=동적 지원 실행(&D)
settings.compiler.path.to.configscript=구성 스크립트 경로(&C):
settings.compiler.select.path.to.groovy.compiler.configscript=Groovy 컴파일러의 구성 스크립트 경로 선택
settings.inlay.implicit.null.argument=묵시적 null 인수
settings.inlay.inferred.parameter.types=추론된 매개변수 타입
settings.inlay.parameter.types=매개변수 타입
settings.inlay.put.type.hint.before.identifier=식별자 앞에 타입 힌트 넣기
settings.inlay.show.hints.for.implicit.null.argument=묵시적 null 인수에 관한 힌트 표시
settings.inlay.show.type.hints.for=다음에 대한 타입 힌트 표시:
settings.inlay.show.variable.type.hints=지역 변수 타입 힌트 표시
settings.inlay.type.parameter.list=타입 매개변수 목록
shows.parameter.names.at.function.call.sites=함수 호출 사이트에서 매개변수 이름을 표시합니다.
singleton.constructor.found=@Singleton 클래스는 생성자를 포함할 수 없습니다
singleton.constructor.makeNonStrict=@Singleton을 비 strict로 만들기
singleton.constructor.remove=생성자 제거
spread.operator.is.not.available=정적 타입 검사에서는 스프레드 연산자를 인수로서 사용할 수 없습니다.
static.import.method.0.fix=static import 메서드 ''{0}''
static.import.method.fix=static import 메서드…
static.visibility.presentation=static
strictfp.visibility.presentation=strictfp
string.end.expected=문자열 끝부분이 필요합니다.
string.option.do.not.handle.specifically=특별히 처리 안 함
string.option.dollar.slashy.string=달러 슬래시 문자열
string.option.double.quoted.string=큰따옴표로 묶인 문자열
string.option.single.quoted.string=작은따옴표로 묶인 문자열
string.option.slashy.string=슬래시 문자열
string.option.triple.double.quoted.string=삼중 큰따옴표로 묶인 문자열
string.option.triple.quoted.string=삼중 작은따옴표로 묶인 문자열
string.sort.default=디폴트
string.sort.multiline.string=여러 줄 문자열
string.sort.strings.with.escaping=문자 이스케이프를 포함하는 문자열
string.sort.strings.with.interpolation=보간 표현식을 포함하는 문자열
super.cannot.be.used.in.static.context='super'는 정적 컨텍스트에서 사용할 수 없습니다.
super.is.not.allowed.in.pre.with.call.super=super 호출은 'callSuper'가 활성화된 'pre'에서 허용되지 않습니다
surround.with.cast=((Type) expr)
surround.with.closure={ -> ... }.call()
surround.with.for=for
surround.with.if=if
surround.with.if.else=if / else
surround.with.if.else.expr=if (expr) / else
surround.with.if.expr=if (expr)
surround.with.parentheses=(expr)
surround.with.shouldFail=shouldFail () {...}
surround.with.try=try
surround.with.try.catch=try / catch
surround.with.try.catch.finally=try / catch / finally
surround.with.try.finally=try / finally
surround.with.while=while
surround.with.while.expr=while (expr)
surround.with.with=with () {...}
surround.with.with.expr=with (expr)
synchronized.not.allowed.on.abstract.method=@Synchronized는 추상 메서드에서 허용되지 않습니다
synchronized.visibility.presentation=synchronized
target.0.does.not.exist=타깃 ''{0}''이(가) 없습니다
target.annotation.is.unused=@Target은 사용되지 않습니다
text.class.0.is.unused=클래스 {0}이(가) 사용되지 않습니다
text.constructor.0.is.unused=생성자 {0}이(가) 사용되지 않습니다
text.method.0.is.unused=메서드 {0}이(가) 사용되지 않습니다
text.parameter.0.is.unused=매개변수 {0}이(가) 사용되지 않습니다
text.property.0.is.unused=프로퍼티 {0}이(가) 사용되지 않습니다
the.usage.of.a.map.entry.expression.to.initialize.an.enum.is.currently.not.supported=열거형을 초기화하는 맵 항목 표현식의 사용은 현재 지원되지 않습니다.
there.is.no.default.constructor.available.in.class.0=''{0}''에서 사용할 수 있는 디폴트 생성자가 없습니다.
this.super.completion.advertisement=클래스 한정자 없이 {0}을(를) 두 번 누르면 액세스 가능한 모든 정적 메서드가 표시됩니다
throws.clause.is.not.allowed.in.at.interface='throws' 절은 @interface 멤버에서 허용되지 않습니다.
top.level.class.may.not.have.private.modifier=최상위 클래스는 'private' 제어자를 가질 수 없습니다
top.level.class.may.not.have.protected.modifier=최상위 클래스는 'protected' 제어자를 가질 수 없습니다
trait.method.cannot.be.protected=특성 메서드는 protected가 될 수 없습니다.
transient.visibility.presentation=transient
try.catch.fix=try-catch 수정
try.without.catch.finally='try'에 'catch' 또는 'finally'가 없습니다.
tuple.cant.be.placed.in.class=필드에 대한 여러 대입이 허용되지 않습니다
tuple.declaration.should.end.with.def.modifier=튜플 선언은 'def' 제어자로 끝나야 합니다
type.argument.0.is.not.in.its.bound.should.extend.1=타입 매개변수 ''{0}''이(가) 해당 바운드 내에 없으며, ''{1}''을(를) 확장해야 합니다.
type.argument.list.is.not.allowed.here=타입 인수 목록은 여기에서 허용되지 않습니다.
type.customizer.is.not.marked.as.a.resource.file=타입 커스터마이저 스크립트가 컴파일러 리소스로 표시되지 않았습니다
type.doesnt.contain.method=타입 ''{0}''에 메서드 ''{1}''이(가) 없으므로 해당 타입을 범위 내에서 반복할 수 없습니다
type.doesnt.implement.comparable=타입 ''{0}''이(가) Comparable을 구현하지 않습니다
type.parameters.are.unexpected=예기치 않은 타입 매개변수 입니다
unassigned.access.tooltip=변수 ''{0}''은(는) 대입되지 않을 수 있습니다
undefined.label=정의되지 않은 라벨 ''{0}''
undefined.library.version=정의되지 않음
unexpected.attribute.type.0=예기치 않은 속성 타입: ''{0}''
unnecessary.alias.description=별칭이 필요하지 않습니다
unnecessary.alias.fix=불필요한 별칭 제거
unnecessary.def.explicitly.typed.only=명시적으로 타입 지정된 선언에서만 보고
unnecessary.modifier.description=제어자 ''{0}''은(는) 필요하지 않습니다
unnecessary.modifier.remove=불필요한 ''{0}''을(를) 제거합니다.
unnecessary.semicolon.description=세미콜론이 필요하지 않습니다
unnecessary.semicolon.fix=세미콜론 제거
unnecessary.type=예외 ''{0}''은(는) 필요하지 않습니다. ''{1}''은(는) 이미 선언되었습니다.
unresolved.type.status=타입 ''{0}''이(가) 해결되지 않았습니다
unsupported.anonymous.class.0=익명 클래스는 Groovy {0}에서 지원되지 않습니다.
unsupported.array.initializers=배열 이니셜라이저는 현재 버전에서 지원되지 않습니다.
unsupported.command.syntax.0=명령어 표현식 구문은 Groovy {0}에서 지원되지 않습니다.
unsupported.diamonds.0=다이아몬드는 Groovy {0}에서 지원되지 않습니다.
unsupported.do.while.statement='do while'은 현재 버전에서 지원되지 않습니다.
unsupported.dollar.slashy.string.0=달러 슬래시 문자열은 Groovy {0}에서 지원되지 않습니다.
unsupported.elvis.assignment=elvis 대입은 현재 버전에서 지원되지 않습니다.
unsupported.expression.list.in.for.update='for' 업데이트 내 여러 표현식은 현재 버전에서 지원되지 않습니다.
unsupported.inner.class.0=내부 클래스는 Groovy {0}에서 지원되지 않습니다
unsupported.lambda=람다는 현재 버전에서 지원되지 않습니다.
unsupported.multiline.slashy.string.0=여러 줄 슬래시 문자열은 Groovy {0}에서 지원되지 않습니다.
unsupported.multiple.variables.in.for='for' 초기화 내 여러 변수는 현재 버전에서 지원되지 않습니다.
unsupported.negated.in=부정된 'in'은 현재 버전에서 지원되지 않습니다.
unsupported.negated.instanceof=부정된 'instanceof'는 현재 버전에서 지원되지 않습니다.
unsupported.resource.list='try'는 현재 버전에서 지원되지 않습니다.
unsupported.safe.index.access=안전한 색인 액세스는 현재 버전에서 지원되지 않습니다.
unsupported.traits.0=특성은 Groovy {0}에서 지원되지 않습니다
unsupported.tuple.application.initializer=애플리케이션 이니셜라이저는 현재 버전에서 지원되지 않습니다
unsupported.tuple.declaration.in.for='for' 초기화 내 튜플 선언은 현재 버전에서 지원되지 않습니다
unsupported.type.annotations=타입 어노테이션은 현재 버전에서 지원되지 않습니다.
unused.0=사용되지 않는 ''{0}''
unused.assignment.tooltip=대입이 사용되지 않습니다
unused.default.parameter.fix=이니셜라이저 제거
unused.default.parameter.message=디폴트 매개변수가 사용되지 않습니다
unused.import=사용되지 않는 import 문
unused.variable=변수가 사용되지 않습니다
variable.0.might.not.have.been.initialized=변수 ''{0}''이(가) 초기화되지 않았을 수 있습니다
variable.already.defined=변수 ''{0}''은(는) 이미 정의되어 있습니다.
variable.can.be.final.tooltip=변수 ''{0}''은(는) final이 될 수 있습니다
variable.cannot.be=변수는 제어자 ''{0}''을(를) 가질 수 없습니다
volatile.visibility.presentation=volatile
wildcards.are.not.allowed.in.extends.list=super 타입은 wildcard 타입을 지정할 수 없습니다.
write.access.to.closure.variable=필드 <b>{0}</b>에 대한 쓰기 액세스
wrong.closure.first.parameter.type=클로저 ''{0}''은(는) 이름 지정된 인수와 함께 사용되지만 내부의 첫 번째 인수 ''{1}''이(가) Map 타입을 준수하지 않습니다.
wrong.method.first.parameter.type=메서드 ''{0}''은(는) 이름 지정된 인수와 함께 사용되지만 내부의 첫 번째 인수 ''{1}''이(가) Map 타입을 준수하지 않습니다.
wrong.number.of.type.arguments=타입 인수의 개수가 잘못되었습니다({0}). 필요: {1}개