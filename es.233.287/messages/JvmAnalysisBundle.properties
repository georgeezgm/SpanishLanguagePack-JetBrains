assertequals.between.inconvertible.types.display.name='assertequals()' entre objetos de tipos no convertibles
can.t.build.uast.tree.for.file=No se pudo construir el árbol UAST para el archivo.
current.version=Versión actual
dialog.title.choose.annotation=Seleccione {0}
inspection.message.illegal.dependency.module.doesn.t.export=Dependencia no válida: el módulo ''{0}'' no exporta el paquete ''{1}''
jvm.inspection.logging.condition.disagrees.with.log.statement.display.name=La condición de registro no coincide con la llamada de registro
jvm.inspection.logging.condition.disagrees.with.log.statement.problem.descriptor=El nivel de condición ''{0}'' no coincide con el nivel de llamada de registro ''{1}''
jvm.inspection.logging.placeholder.count.matches.argument.count.display.name=El número de marcadores de posición no coincide con el número de argumentos en la llamada de registro
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.descriptor=Hay menos argumentos ({0}) que el número de marcadores de posición especificados ({1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.partial.descriptor=La cantidad de argumentos proporcionados ({0}) es menor que la cantidad de marcadores de posición especificados (al menos {1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.incorrect.problem.descriptor=Especificador de cadena de formato no válido #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.more.problem.descriptor=#loc Hay más argumentos ({0}) que el número de marcadores de posición especificados ({1})
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option=SLF4J utiliza Log4j 2 como implementación
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.auto=Confirmación automática
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.no=No
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.yes=Sí
jvm.inspection.logging.string.template.as.argument.all.levels.option=Todos los niveles de registro
jvm.inspection.logging.string.template.as.argument.debug.level.and.lower.option=Por debajo del nivel de depuración
jvm.inspection.logging.string.template.as.argument.display.name=Pasar una plantilla de cadena como argumento a una llamada de registro
jvm.inspection.logging.string.template.as.argument.info.level.and.lower.option=Por debajo del nivel de información
jvm.inspection.logging.string.template.as.argument.problem.descriptor=<code>#ref()</code> Pase la plantilla de cadena como argumento para la llamada de registro #loc
jvm.inspection.logging.string.template.as.argument.quickfix.name=Reemplazar con marcador de posición
jvm.inspection.logging.string.template.as.argument.skip.on.primitives=No avisar cuando solo se incluyen expresiones con tipos primitivos, envoltorios o cadenas
jvm.inspection.logging.string.template.as.argument.trace.level.option=Nivel de seguimiento
jvm.inspection.logging.string.template.as.argument.warn.level.and.lower.option=Por debajo del nivel de advertencia
jvm.inspection.logging.string.template.as.argument.warn.on.label=Advertir sobre:
jvm.inspection.test.failed.line.display.name=Failed line in test
jvm.inspections.1.5.problem.descriptor=Uso de API registrado como @since {0}+
jvm.inspections.1.7.problem.descriptor=Uso de API generalizada posterior a 1.6 que puede causar problemas de compilación en JDK {0}
jvm.inspections.1.8.problem.descriptor=El valor predeterminado {0,choice, 0#|1#method|2#method} no se ha anulado. Esto puede causar problemas de compilación en JDK {1).
jvm.inspections.1.8.problem.single.descriptor=El método predeterminado ''{0}'' no ha sido anulado. Esto puede causar problemas de compilación con JDK {1}
jvm.inspections.api.display.name=Usar una API que no está disponible en el nivel de idioma configurado
jvm.inspections.api.no.extension.class.description=La clase ''{0}'' no debe extenderse.
jvm.inspections.api.no.extension.display.name=La clase, la interfaz o el método no deben extenderse
jvm.inspections.api.no.extension.interface.extend.description=La interfaz ''{0}'' no debe extenderse.
jvm.inspections.api.no.extension.interface.implement.description=La interfaz ''{0}'' no debe implementarse.
jvm.inspections.api.no.extension.method.overriding.description=El método ''{0}'' no debe anularse.
jvm.inspections.api.override.only.description=El método ''{0}'' solo se puede anular.
jvm.inspections.api.override.only.display.name=Los métodos solo se pueden anular
jvm.inspections.assertequals.between.inconvertible.types.problem.descriptor=<code>#ref()</code> está entre objetos de tipo ''{0}'' y ''{1}'', que no se pueden convertir. #loc
jvm.inspections.assertnotequals.between.inconvertible.types.problem.descriptor=Puede haber afirmaciones duplicadas. Se comparan los tipos incompatibles, ''{0}'' y ''{1}''.
jvm.inspections.assertnotsame.between.inconvertible.types.problem.descriptor=Afirmación duplicada. Se comparan los tipos incompatibles, ''{0}'' y ''{1}''.
jvm.inspections.blocking.method.annotation.blocking=Bloqueo de anotaciones
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=Agregar anotación de bloqueo
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=Add non-blocking annotation
jvm.inspections.blocking.method.annotation.non-blocking=Non-Blocking Annotations
jvm.inspections.blocking.method.consider.suspend.context.non.blocking=Kotlin suspende el contexto como sin bloqueo
jvm.inspections.blocking.method.consider.unknown.context.blocking=Considere bloquear contextos desconocidos
jvm.inspections.blocking.method.consider.unknown.context.nonblocking=Trate el contexto desconocido como sin bloqueo
jvm.inspections.blocking.method.display.name=Llamada al método de bloqueo de subprocesos no válida
jvm.inspections.blocking.method.in.implicit.ctr.problem.descriptor=El bloqueo de llamadas de constructores implícitos en contextos sin bloqueo puede provocar potencialmente la inanición de los subprocesos.
jvm.inspections.blocking.method.in.implicit.ctr.problem.wildcard.descriptor=Bloquear la llamada del constructor implícito en {0} podría provocar la inanición del subproceso
jvm.inspections.blocking.method.intention.text=Habilite la opción de escaneo ''{0}''.
jvm.inspections.blocking.method.problem.descriptor=Llamada al método de bloqueo no válida.
jvm.inspections.blocking.method.problem.wildcard.descriptor=Bloquear llamadas en {0} puede causar falta de hilo en el hilo
jvm.inspections.collection.contains.url.problem.descriptor=''{0}'' tiene el objeto URL #loc
jvm.inspections.dependency.display.name=Illegal package dependencies
jvm.inspections.dependency.edit.rules.family=Edit dependency rules
jvm.inspections.dependency.edit.rules.text=Edit dependency rule \"{0} \"
jvm.inspections.dependency.intention.description=Abre un cuadro de diálogo para configurar reglas de dependencia entre ámbitos.
jvm.inspections.dependency.on.internal.display.name=Dependencia no válida para el paquete interno
jvm.inspections.dependency.violator.problem.descriptor=Dependency rule ''{0}.'' is violated
jvm.inspections.equals.hashcode.called.on.url.display.name=Llamar a 'equals()' o 'hashCode()' en un objeto 'URL'
jvm.inspections.equals.hashcode.called.on.url.problem.descriptor=''{0}'' llamado en objeto URL
jvm.inspections.group.name=Lenguaje JVM
jvm.inspections.junit.assertequals.may.be.assertsame.display.name=AssertEquals()' puede convertirse en 'assertSame()
jvm.inspections.junit.assertequals.may.be.assertsame.problem.descriptor=<code>#ref</code>puede ser 'assertSame()' #loc
jvm.inspections.junit.assertequals.on.array.display.name=Llamar a 'assertEquals()' en una matriz
jvm.inspections.junit.assertequals.on.array.problem.descriptor=<code>#ref()</code> se llama en la matriz #loc
jvm.inspections.junit.ignored.test.class.problem.descriptor=La clase de prueba ''{0}'' ha sido ignorada/deshabilitada. Motivo: {1,choice, 1#|2#ninguno} #loc
jvm.inspections.junit.ignored.test.display.name=Agregue anotaciones '@Ignore'/'@Disabled' a las pruebas JUnit
jvm.inspections.junit.ignored.test.ignore.reason.option=Informar únicamente de las anotaciones utilizadas sin motivo
jvm.inspections.junit.ignored.test.method.problem.descriptor=El método de prueba ''{0}'' se ignora/deshabilita. Motivo: {1,choice, 1#|2#ninguno} #loc
jvm.inspections.junit.malformed.annotated.double.descriptor=''@{1}'' anotado {0,choice, 0#campo|1#método} <code>#ref</code> debe ser {2} y {3}
jvm.inspections.junit.malformed.annotated.double.typed.descriptor=@{1}'' anotado {0,choice, 0#field|1#method} <code>#ref</code> es {2} y {3} y ''{4 Debe ser de tipo }
jvm.inspections.junit.malformed.annotated.method.double.param.double.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1} y {2} con el parámetro ''{3}'' ''{4}'' no debe declararse
jvm.inspections.junit.malformed.annotated.method.double.param.single.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1} y {2} y toma el parámetro ''{3}''. No debes declararlo.
jvm.inspections.junit.malformed.annotated.method.double.typed.param.double.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1} y {2} y escribir ''{3}'', con parámetro {4 } y ''{5 }'' no debe ser declarado
jvm.inspections.junit.malformed.annotated.method.double.typed.param.single.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1} y {2} y escriba ''{3}'', con el parámetro '' {4}'' debe no ser declarado
jvm.inspections.junit.malformed.annotated.method.param.double.descriptor=Un método <code>#ref</code> anotado con ''@{0}'' declara los parámetros {1} y ''{2}''.
jvm.inspections.junit.malformed.annotated.method.param.single.descriptor=El método <code>#ref</code> anotado con ''@{0}'' no debe declarar el parámetro ''{1}''
jvm.inspections.junit.malformed.annotated.method.single.param.double.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1} y tiene los parámetros ''{2}'' y ''{3 }'' no debe declararse
jvm.inspections.junit.malformed.annotated.method.single.param.single.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1} y no debe declarar el parámetro ''{2}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.double.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1} y escriba ''{2}'' con los parámetros {3} y ) ''{4}'' debe no ser declarado
jvm.inspections.junit.malformed.annotated.method.single.typed.param.single.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1} y escriba ''{2}'', con el parámetro ''{3}'' no debe declararse
jvm.inspections.junit.malformed.annotated.method.typed.param.double.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser del tipo ''{1}'' y tiene los parámetros {2} y ''{ 3}'' no debe declararse.
jvm.inspections.junit.malformed.annotated.method.typed.param.single.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser del tipo ''{1}'' y toma el parámetro ''{2}''. No debe declararse.
jvm.inspections.junit.malformed.annotated.single.descriptor={0,choice, 0#field|1#method} <code>#ref</code> anotado con ''@{1}'' debe ser {2}
jvm.inspections.junit.malformed.annotated.single.typed.descriptor={0,choice, 0#field|1#method} <code>#ref</code> anotado con ''@{1}'' es {2} y el tipo ''{3}'' debe ser
jvm.inspections.junit.malformed.annotated.suspend.function.descriptor=El método <code>#ref</code> anotado con ''@{0}'' no debe ser una función de pausa
jvm.inspections.junit.malformed.annotated.typed.descriptor={0,choice, 0#field|1#method} <code>#ref</code> anotado con ''@{1}'' debe ser del tipo ''{2}''
jvm.inspections.junit.malformed.declaration.name=Declaración incorrecta de JUnit
jvm.inspections.junit.malformed.extension.class.level.descriptor={0} debe estar registrado a nivel de clase
jvm.inspections.junit.malformed.fix.class.signature=Editar firma de campo
jvm.inspections.junit.malformed.fix.class.signature.descriptor=Modificar firma de clase ''{0}''
jvm.inspections.junit.malformed.fix.class.signature.multi=Modificar firma de clase
jvm.inspections.junit.malformed.fix.field.signature=Editar firma de campo
jvm.inspections.junit.malformed.fix.field.signature.descriptor=Modificar la firma del campo ''{0}''
jvm.inspections.junit.malformed.fix.method.signature=Editar firma del método
jvm.inspections.junit.malformed.fix.method.signature.descriptor=Modificar la firma del método ''{0}''
jvm.inspections.junit.malformed.missing.nested.annotation.descriptor=Las pruebas dentro de clases anidadas no se ejecutarán
jvm.inspections.junit.malformed.no.arg.descriptor=El método <code>#ref</code> debe ser {0}, {1} y {2,choice, 0#sin parámetros|1#, sin parámetros y de tipo void}
jvm.inspections.junit.malformed.option.ignore.test.parameter.if.annotated.by=Ignore los parámetros de prueba si están anotados con:
jvm.inspections.junit.malformed.param.duplicated.enum.descriptor=Nombre constante 'enum' duplicado
jvm.inspections.junit.malformed.param.empty.source.unsupported.descriptor=''@{0}'' no puede proporcionar argumentos al método porque el método tiene un parámetro de tipo ''{1}'', que no es compatible
jvm.inspections.junit.malformed.param.exactly.one.type.of.input.must.be.provided.descriptor=Se debe proporcionar exactamente un tipo de entrada
jvm.inspections.junit.malformed.param.file.source.descriptor=No se pudo resolver el origen del archivo. ''{0}''
jvm.inspections.junit.malformed.param.method.source.assignable.descriptor=No se encontró ninguna conversión implícita para convertir ''{0}'' a ''{1}''
jvm.inspections.junit.malformed.param.method.source.no.params.descriptor=La fuente del método ''{0}'' no puede contener parámetros
jvm.inspections.junit.malformed.param.method.source.return.type.descriptor=La fuente del método ''{0}'' debe contener uno de los siguientes tipos de devolución: ''Flujo<?>'', ''Iterador<?>'', ''Iterable<?>'' u ''Objeto[]''
jvm.inspections.junit.malformed.param.method.source.static.descriptor=Para el método fuente ''{0}'' siempre debe ser estático
jvm.inspections.junit.malformed.param.method.source.unresolved.descriptor=El origen del método de destino no se puede resolver. ''{0}''
jvm.inspections.junit.malformed.param.multiple.parameters.descriptor=Esta fuente no admite múltiples parámetros.
jvm.inspections.junit.malformed.param.no.sources.are.provided.descriptor=La suite se deja en blanco debido a que no se proporcionaron fuentes
jvm.inspections.junit.malformed.param.no.value.source.is.defined.descriptor=No hay fuente de valor definida
jvm.inspections.junit.malformed.param.unresolved.enum.descriptor=No se puede resolver la referencia constante 'enum'.
jvm.inspections.junit.malformed.param.wrapped.in.arguments.descriptor=Se deben incluir varios parámetros en 'Argumentos'
jvm.inspections.junit.malformed.repetition.number.descriptor=El número de iteraciones debe ser mayor que 0.
jvm.inspections.junit.malformed.source.without.params.descriptor=\n''@{0}'' no puede proporcionar argumentos al método porque el método no tiene parámetros.
jvm.inspections.junit.malformed.suspend.function.descriptor=El método <code>#ref</code> no debe ser una función de pausa
jvm.inspections.junit.malformed.test.combination.descriptor=Combinación sospechosa de {0} y ''@{1}''
jvm.inspections.junit.mixed.annotations.junit.descriptor=El método anotado ''@{0}'' <code>#ref()</code> dentro de la clase extiende JUnit {1} TestCase #loc
jvm.inspections.junit.mixed.annotations.name=Usando múltiples versiones de JUnit API dentro de un TestCase
jvm.inspections.junit3.super.teardown.display.name=JUnit 3 'super.tearDown()' no llamado en el bloque 'finalmente'
jvm.inspections.junit3.super.teardown.problem.descriptor=<code>#ref()</code> no se llama en el bloque 'finalmente' #loc
jvm.inspections.junit4.converter.display.name=Las pruebas JUnit 3 pueden convertirse en JUnit 4
jvm.inspections.junit4.converter.problem.descriptor=Puede convertir <code>#ref</code> a casos de prueba JUnit4.
jvm.inspections.junit4.converter.quickfix.conflict.call.compile=La llamada al método {0} no se compila cuando {1} se convierte a JUnit 4
jvm.inspections.junit4.converter.quickfix.conflict.name=El método {0} tiene un conflicto de nombre con su método principal
jvm.inspections.junit4.converter.quickfix.conflict.semantics=La llamada al método {0} puede cambiar su significado si {1} se convierte a JUnit 4
jvm.inspections.junit4.converter.quickfix.conflict.suite=La migración del método de suite de {0} tiene efectos secundarios y se eliminará
jvm.inspections.junit4.converter.quickfix.name=Convertir a casos de prueba JUnit4
jvm.inspections.junit5.assertions.converter.display.name=Afirmaciones en versiones anteriores a JUnit 5
jvm.inspections.junit5.assertions.converter.familyName=Reemplazar con llamadas compatibles con JUnit 5
jvm.inspections.junit5.assertions.converter.problem.descriptor=Debe reemplazar la llamada <code>#ref()</code> en ''{0}'' con una llamada al método en ''{1}'' #loc
jvm.inspections.junit5.assertions.converter.quickfix=Reemplace ''{0}'' con una llamada a un método
jvm.inspections.junit5.converter.display.name=Las pruebas JUnit 4 pueden convertirse en JUnit 5
jvm.inspections.junit5.converter.problem.descriptor=#ref puede ser una prueba JUnit 5
jvm.inspections.junit5.converter.quickfix=Migrar a JUnit 5
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=La clase {0} no se puede convertir a JUnit 5 porque tiene herederos incompatibles. {Uno}
jvm.inspections.junit5.converter.quickfix.presentation.text=Conversión de afirmaciones
jvm.inspections.logging.frameworks.group.name=Inicio sesión
jvm.inspections.migrate.assert.to.matcher.description=La expresión de aserción <code>#ref</code> se puede reemplazar con una llamada a ''{0}'' #loc
jvm.inspections.migrate.assert.to.matcher.option=Importar el método de comparación estáticamente
jvm.inspections.migrate.assertion.name=Las afirmaciones de JUnit pueden ser llamadas a 'assertThat()'
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=Las API que se eliminarán también deben estar marcadas con la anotación '' @Deprecated ''.
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=Falta la anotación '' @Deprecated '' en la API que se eliminará
jvm.inspections.must.already.be.removed.api.current.version.description=La API se ha eliminado de la versión actual {0}.
jvm.inspections.must.already.be.removed.api.display.name=La API ya ha sido eliminada.
jvm.inspections.must.already.be.removed.api.earlier.version.description=La API se ha eliminado de {0} pero la versión actual es {1}.
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' está programado para ser eliminado de {3} ''{2}'' ha sido declarado en
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' está a punto de eliminarse de {1}.
jvm.inspections.scheduled.for.removal.future.version=Versiones futuras
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=El método reemplazado ''{0}'' programado para ser eliminado de {3} {1} ''{2}'' fue declarado.
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=El método anulado ''{0}'' está a punto de ser eliminado de {1}.
jvm.inspections.scheduled.for.removal.predefined.version=Versión {0}
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' se eliminará de {3} {1 } ''{2}'' se hace referencia en su firma y se eliminará
jvm.inspections.serializable.class.without.serialversionuid.display.name=Clase serializable sin 'serialVersionUID'
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code>no define el campo 'serialVersionUID' #loc
jvm.inspections.source.to.sink.flow.assigned.unknown=Cadena desconocida asignada a variable segura
jvm.inspections.source.to.sink.flow.assigned.unsafe=Cadena insegura asignada a variable segura
jvm.inspections.source.to.sink.flow.common.unknown=Cadena desconocida utilizada en contexto seguro
jvm.inspections.source.to.sink.flow.common.unsafe=Cadena insegura utilizada en un contexto seguro
jvm.inspections.source.to.sink.flow.display.name=Cadena insegura pasada a un método seguro
jvm.inspections.source.to.sink.flow.passed.unknown=Cadena insegura pasada a un método seguro
jvm.inspections.source.to.sink.flow.passed.unsafe=Cadena insegura pasada a un método seguro
jvm.inspections.source.to.sink.flow.returned.unknown=Cadena desconocida devuelta por un método seguro
jvm.inspections.source.to.sink.flow.returned.unsafe=Cadena insegura devuelta por un método seguro
jvm.inspections.source.to.sink.flow.too.complex=Demasiado complicado comprobar si una cadena es segura en un contexto seguro
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods=Los parámetros de los métodos privados se consideran seguros.
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods.comment=Cuando están habilitados, los parámetros de un método privado se consideran seguros; de lo contrario, se consideran desconocidos.
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex=Informar cuando el caso sea demasiado complejo para verificarlo
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex.comment=Habilítelo si necesita informar cadenas no verificables debido a la complejidad
jvm.inspections.source.unsafe.to.sink.flow.checked.types=Tipos confirmados:
jvm.inspections.source.unsafe.to.sink.flow.config=La anotación Sin contaminación se agrega a la configuración de inspección para el elemento ''{0}''
jvm.inspections.source.unsafe.to.sink.flow.depth.inside=Análisis profundo dentro de un método:
jvm.inspections.source.unsafe.to.sink.flow.impossible=No se admiten anotaciones no contaminadas para el elemento ''{0}''. Ese elemento será ignorado.
jvm.inspections.source.unsafe.to.sink.flow.index.parameter=Índice de parámetros
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=Marcar como que requiere verificación
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=Marcar como que requiere verificación
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=Marcar ''{0}'' como que requiere verificación
jvm.inspections.source.unsafe.to.sink.flow.not.number=No un número
jvm.inspections.source.unsafe.to.sink.flow.place.class.column.title=nombre de clase en contexto
jvm.inspections.source.unsafe.to.sink.flow.place.method.column.title=Nombre del método expresión regular en contexto
jvm.inspections.source.unsafe.to.sink.flow.preview=Agregar la anotación '@Untainted'
jvm.inspections.source.unsafe.to.sink.flow.preview.propagate=Visualización de árbol hacia adelante
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=Entrega segura de anotaciones
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.preview=Abre una ventana de herramientas para configurar la entrega de anotaciones seguras.
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=Entrega segura de anotaciones desde ''{0}''
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=Agregue anotaciones a todo excepto a los excluidos.
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=Seleccione miembros para anotar como seguros
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=Flujo inseguro
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.arguments=tomar el control
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.classes=clase
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.comment=Estos métodos muestran el calificador "no contaminado" (los argumentos deben estar separados por comas)
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.methods=método
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.table=Métodos para limpiar las eliminatorias:
jvm.inspections.source.unsafe.to.sink.flow.safe.class=Clases seguras:
jvm.inspections.source.unsafe.to.sink.flow.safe.class.comment=No hay datos inseguros en la clase.
jvm.inspections.source.unsafe.to.sink.flow.show.unknown.object=Informe de objeto desconocido
jvm.inspections.source.unsafe.to.sink.flow.show.unsafe.object=Reportar objetos inseguros
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations=Anotación contaminada:
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations.comment=Estas anotaciones se utilizan como anotaciones '@Tainted' durante el análisis.
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods=Método contaminado:
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods.comment=Se considera que estos métodos devuelven sólo objetos inseguros.
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters=Parámetros contaminados:
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters.comment=Se considera que estos parámetros están anotados con '@Tainted'
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations=Anotación no contaminada:
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations.comment=Estas anotaciones se utilizan como anotaciones '@Tainted' durante el análisis. Si está presente en la ruta, la primera anotación de la lista se utiliza para el reenvío.
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields=Campos no contaminados:
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.comment=Se considera que estos campos contienen solo objetos seguros.
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.name=Nombre del campo
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods=Método no contaminado:
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods.comment=Se considera que estos métodos devuelven sólo objetos seguros.
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters=Parámetros no contaminados:
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters.comment=Se considera que estos parámetros están anotados con '@Untainted'
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments=Si el receptor y los argumentos no están contaminados, el método externo se considera no contaminado.
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments.comment=Cuando está habilitado, las clases externas fuera de la clase actual se consideran seguras si sus receptores y argumentos lo son. Aunque puede que no se aplique en algunos casos, puede resultar útil para clases sin estado. De lo contrario, todos los métodos externos se considerarán inseguros.
jvm.inspections.string.touppercase.tolowercase.without.locale.description=<code> String. Se llama a {0} ()</code> sin especificar una configuración regional que utilice una cadena internacionalizada.\#loc
jvm.inspections.system.get.property.display.name=Podemos simplificar la llamada a 'System.getProperty(str)'
jvm.inspections.system.get.property.problem.descriptor=La llamada <code>#ref</code> se puede simplificar a ''{0}''
jvm.inspections.test.case.in.product.source.display.name=Pruebas del producto en origen
jvm.inspections.test.case.in.product.source.problem.descriptor=Es posible que sea necesario colocar los casos de prueba <code>#ref</code> en el árbol de fuentes de prueba con #loc
jvm.inspections.test.case.with.constructor.display.name=TestCase con constructor no trivial
jvm.inspections.test.case.with.constructor.problem.descriptor=Lógica de inicialización #loc en el constructor <code>#ref()</code> distinta del método de ciclo de vida 'setup()'
jvm.inspections.test.case.with.constructor.problem.descriptor.initializer=Lógica de inicialización en inicializadores distintos del método de ciclo de vida 'setup()'
jvm.inspections.test.case.without.test.methods.display.name=Clase de prueba sin pruebas.
jvm.inspections.test.case.without.test.methods.option=Ignorar casos de prueba que tienen clases principales que usan métodos de prueba
jvm.inspections.test.case.without.test.methods.problem.descriptor=La clase de prueba <code>#ref</code> no tiene pruebas #loc
jvm.inspections.test.frameworks.group.name=Marco de prueba
jvm.inspections.test.method.in.product.source.problem.descriptor=Es posible que sea necesario colocar el método de prueba <code>#ref()</code> en el árbol de fuentes de prueba con #loc
jvm.inspections.test.method.without.assertion.display.name=Método de prueba sin afirmaciones.
jvm.inspections.test.method.without.assertion.problem.descriptor=Sin aserción en el método de prueba <code>#ref()</code> #loc
jvm.inspections.testonly.class.reference=Test-only class is referenced in production code
jvm.inspections.testonly.display.name=Test-only usage in production code
jvm.inspections.testonly.field.reference=Test-only field is referenced in production code
jvm.inspections.testonly.method.call=Test-only method is called in production code
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting makes little sense on @TestOnly code
jvm.inspections.thread.run.display.name=Llamar a 'Thread.run()'
jvm.inspections.unconstructable.test.case.junit3.descriptor=La clase de prueba <code>#ref</code> no se puede construir porque no tiene argumentos que no sean 'públicos' o un único constructor de parámetros 'Cadena' #loc
jvm.inspections.unconstructable.test.case.junit4.descriptor=La clase de prueba <code>#ref</code> no se puede construir porque debe tener solo un constructor 'público' sin argumentos #loc
jvm.inspections.unconstructable.test.case.not.public.descriptor=La clase de prueba <code>#ref</code> no es 'pública' y no se puede construir #loc
jvm.inspections.unstable.api.usage.annotations.list=Anotaciones API inestables
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}'' is declared in unstable {1} ''{2}'' marked with @{3}
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' está marcado como inestable en @ {1}.
jvm.inspections.unstable.api.usage.display.name=Usando API inestable
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=Ignore API declared in this project
jvm.inspections.unstable.api.usage.ignore.inside.imports=Ignorar dentro de la declaración de importación
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=Método anulado ''{0}'' marcado como inestable {1 como @ {3}} Declarado en '' {2 } ''.
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=El método anulado ''{0}'' está marcado como inestable en @ {1}.
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' marcado como @ {3} inestable {1} ''{2}'' se hace referencia por su firma y, por lo tanto, es inestable
jvm.inspections.unstable.type.used.in.class.signature.description=Anotado ''@{0} '' porque la clase hace referencia al tipo inestable ''{1}'' en su declaración, debería ser
jvm.inspections.unstable.type.used.in.field.signature.description=El campo está anotado con ''@{0} '' porque hace referencia al tipo inestable ''{1}'' debería ser
jvm.inspections.unstable.type.used.in.method.signature.description=Anotado ''@{0} '' porque el método hace referencia al tipo inestable ''{1}'' en su firma debe ser
jvm.inspections.unstable.type.used.in.signature.display.name=Tipo inestable utilizado en la firma
jvm.inspections.usages.of.obsolete.api.description=Se utiliza una API obsoleta
jvm.inspections.usages.of.obsolete.api.display.name=Dónde utilizar ApiStatus.@Obsolete
propagated.from=Razones para marcar como seguro:
propagated.to=Marcar como seguro:
title.uast=UAST
