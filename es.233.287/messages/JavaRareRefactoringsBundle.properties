action.Generify.description=Convierta su código para usar tipos genéricos
action.Generify.text=Convirtiendo tipos primitivos a genéricos...
action.RemoveMiddleman.description=Incluye al delegado para el método de campo seleccionado.
action.RemoveMiddleman.text=Eliminar intermediario(_M)...
action.ReplaceTempWithQuery.description=Convertir variables seleccionadas en métodos
action.ReplaceTempWithQuery.text=Convirtiendo una variable temporal en una consulta (_Q)...
action.WrapReturnValue.description=Envuelve el valor de retorno de un método específico con un objeto
action.WrapReturnValue.text=Método de valor de retorno de avance de línea (_P)...
cannot.replace.temp.with.query.in.interface=No se puede reemplazar ad hoc con consulta en la interfaz
constructor.returns.can.not.be.wrapped=Las devoluciones del constructor no se pueden empaquetar.
could.not.find.selected.wrapping.class=Clase de embalaje seleccionada no encontrada
declaration.s.to.be.generified=Declaración a generalizar {0}
delegating.field=Campo delegado
dialog.message.inner.class.with.name.already.exist=Ya existe una clase interna con el nombre ''{0}''
dialog.message.invalid.inner.class.name=''{0}'' es un nombre de clase interna no válido
dialog.message.invalid.qualified.wrapper.class.name=''{0}'' es un nombre de clase contenedor completamente calificado no válido
dialog.message.invalid.wrapper.class.name=''{0}'' es un nombre de clase contenedor no válido
dialog.message.invalid.wrapper.class.package.name=''{0}'' es un nombre de paquete de clase contenedora no válido
dialog.message.wrapper.field.not.found=Campo contenedor no encontrado
error.wrong.caret.position.local.name=El símbolo de intercalación debe estar en el nombre de la variable local que se va a refactorizar
exposed.delegation.command.name=Delegación expuesta en {0}
field.selected.is.not.used.as.a.delegate=El campo seleccionado no se utilizará como delegado.
generify.title=Convertir tipos primitivos a genéricos
method.selected.returns.void=El método seleccionado devuelve 'nulo'.
method.to.wrap.returns.from.label=Ubicación en el método donde desea envolver la devolución:
method.whose.return.are.to.wrapped=Método para ajustar el valor de retorno
references.to.be.modified.usage.view=Referencias para modificar {1,choice, 0#|1#de {1} archivos|2#de {1} archivos} {0,choice, 0# (no encontrado)|1#{0} referencias|2 #{0 } referencias}
references.to.expose.usage.view=Referencias para exponer {1,choice, 0#|1#de {1} archivos|2#de {1} archivos} {0,choice, 0# (no encontrado)|1#{0} referencias 2#{0 } referencias}
remove.middleman=Eliminar intermediario
remove.middleman.column.header=Borrar
remove.middleman.deleted.hierarchy.conflict={0} será eliminado. La jerarquía está rota
remove.middleman.field.header=Eliminar campo intermediario:
remove.middleman.methods.to.inline.title=Método para en línea
remove.middleman.title=Eliminar intermediario
remove.middleman.tooltip.warning=Eliminarlo romperá la jerarquía de tipos.
replace.temp.with.query.title=Convertir ad hoc en consulta
the.caret.should.be.positioned.at.the.name.of.the.field.to.be.refactored=El cursor debe estar en el nombre del campo que se va a refactorizar.
there.already.exists.a.class.with.the.selected.name=Ya existe una clase con el nombre seleccionado
type.cook.command=Generalización
type.cook.drop.obsolete.casts=Eliminar reparto obsoleto
type.cook.elements.header=Alcance para generalizar
type.cook.generify.objects=Generalización de objetos
type.cook.leave.object.parameterized.types.raw=Dejar tipos de objetos parametrizados sin formato
type.cook.perform.exhaustive.search=&Realizar una búsqueda precisa
type.cook.preserve.raw.arrays=Preservación de materias primas y matrices
type.cook.produce.wildcard.types=Crear tipo comodín (&W)
type.cook.ratio.generified={0,choice,-1#No calculado|0#{0,número}/{1}}
type.cook.report=Items generified: {0},casts removed: {1}
wrap.return.value=Salto de línea del valor de retorno
wrap.return.value.title=Salto de línea del valor de retorno
wrapped.return.command.name=\ return envuelto en {0} para {1}()
