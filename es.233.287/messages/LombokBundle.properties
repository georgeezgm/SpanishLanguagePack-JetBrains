action.defaultLombokData.description=getter/setter/equals/hashcode/toString 메서드를 Lombok @Data 어노테이션으로 바꾸는 액션
action.defaultLombokData.text=디폴트 @Data
action.defaultLombokEqualsAndHashcode.description=equals 및 hashcode 메서드를 Lombok @EqualsAndHashcode 어노테이션으로 바꾸는 액션
action.defaultLombokEqualsAndHashcode.text=디폴트 @EqualsAndHashCode
action.defaultLombokGetter.description=모든 getter 메서드를 Lombok @Getter 어노테이션으로 바꾸는 액션
action.defaultLombokGetter.text=디폴트 @Getter
action.defaultLombokLogger.description=로거를 Lombok @Log 어노테이션으로 바꾸는 액션
action.defaultLombokLogger.text=@Log (및 친구들)
action.defaultLombokSetter.description=모든 setter 메서드를 Lombok @Setter 어노테이션으로 바꾸는 액션
action.defaultLombokSetter.text=디폴트 @Setter
action.defaultLombokToString.description=toString 메서드를 Lombok의 @ToString 어노테이션으로 바꾸는 액션
action.defaultLombokToString.text=디폴트 @ToString
action.delombokAny.description=모든 Lombok 어노테이션을 Vanila Java 메서드로 바꾸는 액션
action.delombokAny.text=모든 Lombok 어노테이션
action.delombokBuilder.description=Lombok @Builder 어노테이션을 Vanila Java 메서드로 바꾸는 액션
action.delombokBuilder.text=@Builder
action.delombokConstructor.description=Lombok @NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor 어노테이션을 Vanila Java 메서드로 바꾸는 액션
action.delombokConstructor.text=@Constructors
action.delombokData.description=Lombok @Data 어노테이션을 Vanila Java 메서드로 바꾸는 액션
action.delombokData.text=@Data
action.delombokDelegate.description=Lombok @Delegate 어노테이션을 Vanila Java 메서드로 바꾸는 액션
action.delombokDelegate.text=@Delegate
action.delombokEqualsAndHashCode.description=Lombok @EqualsAndHashCode 어노테이션을 Vanila Java 메서드로 바꾸는 액션
action.delombokEqualsAndHashCode.text=@EqualsAndHashCode
action.delombokFieldNameCostants.description=Lombok @FieldNameConstants 어노테이션을 Vanila Java 필드로 바꾸는 액션
action.delombokFieldNameCostants.text=@FieldNameConstants
action.delombokGetter.description=Lombok @Getter 어노테이션을 Vanila getter 메서드로 바꾸는 액션
action.delombokGetter.text=@Getter
action.delombokLogger.description=Lombok @Log (및 기타) 어노테이션을 Vanila 로그 필드로 바꾸는 액션
action.delombokLogger.text=@Log (및 친구들)\n
action.delombokSetter.description=Lombok @Setter 어노테이션을 Vanila setter 메서드로 바꾸는 액션
action.delombokSetter.text=@Setter
action.delombokStandardException.description=Lombok @StandardException 어노테이션을 Vanila Java 메서드로 바꾸는 액션
action.delombokStandardException.text=@StandardException
action.delombokSuperBuilder.description=Lombok @SuperBuilder 어노테이션을 Vanila Java 메서드로 바꾸는 액션
action.delombokSuperBuilder.text=@SuperBuilder
action.delombokToString.description=Lombok @ToString 어노테이션을 Vanila Java 메서드로 바꾸는 액션
action.delombokToString.text=@ToString
action.delombokUtilityClass.description=Lombok @UtilityClass 어노테이션을 Vanila Java 필드로 바꾸는 액션
action.delombokUtilityClass.text=@UtilityClass
action.delombokValue.description=Lombok @Value 어노테이션을 Vanila Java 메서드로 바꾸는 액션
action.delombokValue.text=@Value
action.delombokWither.description=Lombok @Wither 어노테이션을 Vanila Java 메서드로 바꾸는 액션
action.delombokWither.text=@Wither
checkbox.settings.jps.fix=1.18.16 이전의 Lombok 버전에 대해 자동으로 '-Djps.track.ap.dependencies=false' 컴파일 옵션 추가
checkbox.settings.version.warning=이전의 Lombok 버전에 대해 Lombok 버전 경고 활성화
color.settings.clear=지우기
color.settings.comment=주석
color.settings.key=키
color.settings.separator=구분 기호
color.settings.value=값
config.warn.annotation-processing.disabled.title=Lombok을 사용하려면 활성화된 어노테이션 처리 필요
config.warn.dependency.outdated.message=<br>프로젝트 "{0}"에 오래된 lombok 종속성이 추가된 것 같습니다.<br>구성된 버전은 "{1}"이지만 "{2}" 이후 버전이 이미 출시되어 있습니다<br><a href="https://projectlombok.org/download">업데이트하시겠어요?</a><br>
config.warn.dependency.outdated.title=Lombok 종속 요소가 오래되었을 수 있음
configurable.name.lombok.config=Lombok 구성
dialog.message.logger.field.s.not.private.sfinal.field.named.s.refactor.anyway=로거 필드: "{0}"은(는) 이름이 "{2}"인 private {1,choice,0#|1 #static} final 필드가 아닙니다. 그래도 리팩터링하시겠어요?
dialog.message.this.element.cannot.be.renamed=이 요소의 이름을 변경할 수 없습니다.
dialog.title.attention=주의!
filetype.lombok.config.description=Lombok 구성 파일
group.DelombokActionGroup.description=Lombok 어노테이션을 제거하여 코드 리팩터링
group.DelombokActionGroup.text=Delombok
group.LombokActionGroup.description=Lombok 어노테이션으로 코드 리팩터링
group.LombokActionGroup.text=Lombok
inspection.deprecated.lombok.display.name=곧 사용할 수 없게 될 Lombok 어노테이션
inspection.lombok.display.name=Lombok 어노테이션
inspection.lombok.getter.may.be.used.display.class.message=클래스 ''{0}''은(는) Lombok @Getter를 사용할 수 있습니다
inspection.lombok.getter.may.be.used.display.field.message=필드 ''{0}''은(는) Lombok @Getter를 가질 수 있습니다
inspection.lombok.getter.may.be.used.display.fix.family.name=명시적 getter 메서드를 Lombok @Getter로 대체
inspection.lombok.getter.may.be.used.display.fix.name=''{0}''에 lombok @Getter 사용
inspection.lombok.getter.may.be.used.display.name=Lombok @Getter를 사용할 수 있습니다
inspection.lombok.group.name.lombok=Lombok
inspection.lombok.group.name.redundant.definitions=불필요한 정의
inspection.lombok.group.name.redundant.modifiers=불필요한 제어자
inspection.message.annotation.copy.duplicate=어노테이션 ''{0}''은(는) 필드에 이미 있으므로 onX 구성과 중복됩니다
inspection.message.annotation.not.lombok.copyable=Lombok은 어노테이션 ''{0}''을(를) 생성자에 복사하지 않습니다
inspection.message.annotation.only.supported.on.class.or.enum.type=어노테이션은 클래스 또는 열거형에서만 지원됩니다
inspection.message.builder.default.requires.initializing.expression=@Builder.Default에는 초기화 표현식(' = something;')이 필요합니다.
inspection.message.builder.default.singular.cannot.be.mixed=@Builder.Default와 @Singular는 함께 사용할 수 없습니다.
inspection.message.can.t.singularize.this.name=이 이름을 특이화할 수 없습니다. ''{0}''. Singular를 명시적으로 지정하세요(예: @Singular("sheep"))
inspection.message.cleanup.legal.only.on.local.variable.declaration.inside.block=@Cleanup: 블록 내부의 지역 변수 선언에서만 사용할 수 있습니다
inspection.message.cleanup.legal.only.on.local.variable.declarations=@Cleanup은 지역 변수 선언에서만 사용할 수 있습니다
inspection.message.cleanup.method.s.not.found.on.target.class=@Cleanup: 타깃 클래스에서 메서드 ''{0}()''을(를) 찾을 수 없습니다
inspection.message.cleanup.value.cannot.be.empty.string=@Cleanup: 값은 빈 문자열일 수 없습니다
inspection.message.cleanup.variable.declarations.need.to.be.initialized=@Cleanup 변수 선언을 초기화해야 합니다.
inspection.message.constructor.noargs.needs.to.be.forced=클래스에 필수 필드가 포함되어 있습니다. NoArgsConstructor를 강제 적용해야 합니다.
inspection.message.constructor.with.d.parameters.already.defined=''{0}'' 매개변수가 있는 생성자가 이미 정의되어 있습니다
inspection.message.constructor.without.parameters.already.defined=매개변수가 없는 생성자가 이미 정의되어 있습니다
inspection.message.custom.log.does.not.allow.topic=@CustomLog가 주제를 허용하지 않습니다.
inspection.message.custom.log.not.configured.correctly=@CustomLog가 올바르게 구성되지 않았습니다. lombok.config에 log.custom.declaration를 설정하세요.
inspection.message.custom.log.requires.topic=@CustomLog에 주제가 필요합니다.
inspection.message.data.only.supported.on.class.type='@Data'는 클래스 타입에서만 지원됩니다
inspection.message.default.constructor.doesn.t.exist=디폴트 생성자가 없습니다
inspection.message.delegate.can.only.use.concrete.class.types=@Delegate는 와일드카드, 배열, 타입 변수 또는 원시형이 아닌 구체 클래스 타입만 사용할 수 있습니다. ''{0}''은(는) 잘못된 클래스 타입입니다
inspection.message.delegate.does.not.support.recursion.delegating=@Delegate는 재귀(그 자체가 @Delegate 멤버를 가진 타입에 위임)를 지원하지 않습니다. 멤버 ''{0}''은(는) 타입 ''{1}''의 @Delegate입니다
inspection.message.delegate.legal.only.on.instance.fields=@Delegate는 인스턴스 필드 또는 인수가 없는 인스턴스 메서드에서만 사용할 수 있습니다.
inspection.message.delegate.legal.only.on.no.argument.methods=@Delegate는 인수가 없는 인스턴스 메서드에서만 사용할 수 있습니다.
inspection.message.equals.and.hashcode.only.supported.on.class.type=@EqualsAndHashCode는 클래스 타입에서만 지원됩니다
inspection.message.exclude.are.mutually.exclusive.exclude.parameter.will.be.ignored=매개변수 'exclude'와 'of'는 서로 배타적입니다. 'exclude' 매개변수는 무시됩니다
inspection.message.existing.builder.must.be.abstract.static.inner.class=기존 빌더는 추상 static 내부 클래스여야 합니다.
inspection.message.field.name.constants.inner.type=@FieldNameConstants 내부 타입이 이미 있으나 asEnum={0}이(가) 기존 타입과 일치하지 않습니다
inspection.message.field.name.constants.only.supported.on.class.enum.or.field.type=@FieldNameConstants는 클래스, 열거형, 레코드 또는 필드 타입에서만 지원됩니다
inspection.message.field.name.constants.only.supported.on.class.or.enum=@FieldNameConstants는 클래스, 열거형 또는 레코드에서만 지원됩니다.
inspection.message.field.s.does.not.exist=필드 ''{0}''이(가) 없습니다.
inspection.message.field.s.does.not.exist.exclude=필드 ''{0}''이(가) 없습니다
inspection.message.field.s.does.not.exist.field=필드 ''{0}''이(가) 없습니다
inspection.message.field.s.would.have.been.excluded.anyway=필드 ''{0}''은(는) 어쨌든 제외되었을 것입니다
inspection.message.generating.equals.hashcode.implementation=이 클래스가 java.lang.Object를 확장하지 않은 경우에도 상위 클래스를 호출하지 않고 equals/hashCode 구현을 생성합니다. 의도적인 경우에는 타입에 '(call Super=false)'를 추가하세요.
inspection.message.generating.equals.hashcode.with.super.call=java.lang.Object 상위 호출을 사용한 equals/hashCode 생성은 무의미합니다.
inspection.message.getter.only.supported.on.class.enum.or.field.type=@Getter는 클래스, 열거형 또는 필드 타입에서만 지원됩니다
inspection.message.jacksonized.builder.on.abstract.classes=추상 클래스의 빌더는 @Jacksonized될 수 없습니다(이러면 빌더가 사용되지 않습니다).
inspection.message.jacksonized.cannot.process.both.builder.superbuilder=@Jacksonized는 같은 클래스에서 @Builder 및 @SuperBuilder 모두를 처리할 수 없습니다.
inspection.message.jacksonized.jsondeserialize.already.exists=클래스에 @JsonDeserialize가 이미 있습니다. @JsonDeserialize를 삭제하거나 @Jacksonized를 제거하고 수동으로 Jackson을 구성하세요.
inspection.message.jacksonized.requires.builder.superbuilder=@Jacksonized는 @Builder 또는 @SuperBuilder가 있어야 의미가 있습니다.
inspection.message.lazy.does.not.work.with.access.level.none='lazy'는 Access Level.NONE에서 작동하지 않습니다.
inspection.message.lazy.not.supported.for.getter.on.type='lazy'는 타입에 지정된 @Getter에서 지원되지 않습니다
inspection.message.lazy.requires.field.initialization='lazy'에는 필드 초기화가 필요합니다.
inspection.message.lazy.requires.field.to.be.private.final='lazy'에서는 필드가 private 및 final이어야 합니다
inspection.message.lombok.annotation.deprecated.not.supported=Lombok 어노테이션 ''{0}''은(는) lombok-plugin에서 사용 중지되어 지원되지 않습니다. 대신 ''{1}''을(를) 사용하세요.
inspection.message.lombok.annotations.are.not.allowed.on.builder.class=Lombok 어노테이션은 빌더 클래스에서 허용되지 않습니다.
inspection.message.lombok.builder.needs.proper.constructor.for.this.class=Lombok @Builder에는 이 클래스에 대한 적절한 생성자가 필요합니다
inspection.message.lombok.does.not.know=Lombok은 타입 ''{0}''의 단수형 빌더 메서드를 만들 수 없습니다. 빌더 메서드가 생성되지 않습니다.
inspection.message.lombok.needs.default.constructor.in.base.class=Lombok은 기본 클래스에 디폴트 생성자가 필요합니다
inspection.message.method.s.matched.static.constructor.name.already.defined=staticConstructorName과 일치하는 메서드 ''{0}''이(가) 이미 정의되어 있습니다
inspection.message.method.s.with.d.parameters.matched.static.constructor.name.already.defined=staticConstructorName과 일치하는 ''{1}'' 매개변수를 가진 메서드 ''{0}''이(가) 이미 정의되어 있습니다
inspection.message.not.allowed.in.old.style.for.loops=''{0}''은(는) 예전 for 루프에서 허용되지 않습니다
inspection.message.not.allowed.with.lambda.expressions=''{0}''은(는) 람다 식에서 허용되지 않습니다.
inspection.message.not.compatible.with.array.initializer.expressions=''{0}''은(는) 배열 이니셜라이저 표현식과 호환되지 않습니다. 완전한 형식('{' ... '}'이(가) 아닌 새로운 int[ ] '{' ... '}')을 사용하세요
inspection.message.not.generated.s.method.with.same.name.already.exists=''{0}()''이(가) 생성되지 않습니다. 이름이 같은 메서드가 이미 있습니다
inspection.message.not.generated.s.method.with.similar.name.s.already.exists=''{0}()''이(가) 생성되지 않습니다. ''{0}''(이)라는 유사한 이름의 메서드가 이미 있습니다
inspection.message.not.generating.constant=이 필드에 상수가 생성되지 않습니다. 상수 이름이 필드 이름과 같습니다.
inspection.message.not.generating.equals.hashcode=equals와 hashCode가 생성되지 않습니다. 이러한 이름 중 하나를 가진 메서드가 이미 있습니다. (이 메서드가 모두 생성되거나 생성되지 않습니다.)
inspection.message.not.generating.field.s.field.with.same.name.already.exists=필드 ''{0}''이(가) 생성되지 않습니다. 이름이 같은 필드가 이미 있습니다
inspection.message.not.generating.getter.for.this.field=이 필드에 getter가 생성되지 않습니다. @Accessors 접두사 목록에 적합하지 않습니다.
inspection.message.not.generating.s.method.with.that.name.already.exists=''{0}()''이(가) 생성되지 않습니다. 이름이 같은 메서드가 이미 있습니다
inspection.message.not.generating.setter.for.this.field.it=이 필드에 setter가 생성되지 않습니다. @Accessors 접두사 목록에 적합하지 않습니다.
inspection.message.not.generating.setter.for.this.field.setters=이 필드에 setter가 생성되지 않습니다. final 필드에는 setter를 생성할 수 없습니다.
inspection.message.not.generating.wither=이 필드에 wither가 생성되지 않습니다. static 필드에는 wither를 생성할 수 없습니다.
inspection.message.not.generating.wither.for.this.field.withers=이 필드에 wither가 생성되지 않습니다. $로 시작하는 필드에는 wither를 생성할 수 없습니다.
inspection.message.not.generating.wither.for.this.field.withers.cannot.be.generated=이 필드에 wither가 생성되지 않습니다. 초기화된 final 필드에는 wither를 생성할 수 없습니다.
inspection.message.obtain.via.is.static.true.not.valid.unless.method.has.been.set='method'가 설정되지 않으면 @ObtainVia(isStatic = true)는 유효하지 않습니다.
inspection.message.on.local.variable.requires.initializer.expression=지역 변수의 ''{0}''에는 초기화 표현식이 필요합니다
inspection.message.s.can.be.used.on.classes.only=''@{0}''은(는) 클래스에서만 사용할 수 있습니다
inspection.message.s.legal.only.on.classes.enums=''@{0}''은(는) 클래스 및 열거형에서만 사용할 수 있습니다
inspection.message.s.not.valid.identifier=''{0}''은(는) 올바른 식별자가 아닙니다
inspection.message.s.only.supported.on.class.or.field.type=''@{0}''은(는) 클래스 또는 필드 타입에서만 지원됩니다
inspection.message.slf4j.logger.defined.explicitly=Slf4j 로거가 명시적으로 정의되어 있습니다. 대신 Lombok @Slf4j 어노테이션을 사용하세요.
inspection.message.standardexception.accesslevel.none.not.valid=AccessLevel.NONE은 여기서 유효하지 않습니다
inspection.message.standardexception.class.only.supported.on.class=@StandardException은 클래스에서만 지원됩니다
inspection.message.standardexception.should.extend.throwable=@StandardException을 사용하려면 Throwable 타입을 확장해야 합니다
inspection.message.synchronized.field.is.not.static=필드 ''{0}''은(는) 비 static이며 이 static 메서드에서는 사용할 수 없습니다
inspection.message.synchronized.legal.only.on.concrete.methods=@Synchronized는 구체 메서드에서만 사용할 수 있습니다.
inspection.message.synchronized.legal.only.on.methods.in.classes.enums=@Synchronized는 클래스 및 열거형의 메서드에서만 사용할 수 있습니다.
inspection.message.syntax.either.obtain.via.field=구문은 @ObtainVia(fieldv= "fieldName") 또는 @ObtainVia(method = "methodName") 중 하나입니다.
inspection.message.to.string.only.supported.on.class.or.enum.type=@ToString은 클래스 또는 열거형 타입에서만 지원됩니다
inspection.message.utility.class.already.marks.class.final=@UtilityClasss가 이미 클래스를 final로 표시하고 있습니다.
inspection.message.utility.class.already.marks.fields.static=@UtilityClasss가 이미 필드를 static으로 표시하고 있습니다.
inspection.message.utility.class.already.marks.inner.classes.static=@UtilityClasss가 이미 내부 클래스를 static으로 표시하고 있습니다.
inspection.message.utility.class.already.marks.methods.static=@UtilityClasss가 이미 메서드를 static으로 표시하고 있습니다.
inspection.message.utility.class.automatically.makes.class.static=@UtilityClass는 자동으로 클래스를 static으로 설정하지만 이 클래스는 static으로 만들 수 없습니다.
inspection.message.utility.class.cannot.be.placed=@UtilityClass는 지역 메서드 또는 익명 내부 클래스 또는 그러한 클래스에 중첩된 클래스에는 배치할 수 없습니다.
inspection.message.utility.class.only.supported.on.class=@UtilityClass는 클래스(인터페이스, 열거형 또는 어노테이션 제외)에서만 지원됩니다.
inspection.message.utility.classes.cannot.have.declared.constructors=@UtilityClasses는 생성자를 선언할 수 없습니다.
inspection.message.val.already.marks.variables.final='val'이 이미 변수를 final로 표시하고 있습니다.
inspection.message.val.works.only.on.local.variables='val'은 지역 변수와 foreach 루프에서만 작동합니다\n
inspection.message.value.already.marks.class.final=@Value가 이미 클래스를 final로 표시하고 있습니다.
inspection.message.value.already.marks.non.static.fields.final=@Value가 이미 static이 아닌 필드를 final로 표시하고 있습니다.
inspection.message.value.already.marks.non.static.package.local.fields.private=@Value가 이미 static이 아닌 필드와 package-local 필드를 private으로 표시하고 있습니다.
inspection.message.value.only.supported.on.class.type='@Value'는 클래스 타입에서만 지원됩니다
inspection.message.var.works.only.on.local.variables.on.for.foreach.loops='var'은 지역 변수와 for/foreach 루프에서만 작동합니다
inspection.message.wither.needs.constructor.for.all.fields.d.parameters=@Wither에서는 모든 필드(''{0}'' 매개변수)에 생성자가 필요합니다
inspection.message.wither.only.supported.on.class.or.field=@Wither는 클래스 또는 필드에서만 지원됩니다.
inspection.redundant.modifiers.utility.class.lombok.display.name=@UtilityClass 제어자
inspection.redundant.modifiers.val.lombok.display.name='val' 앞의 불필요한 final
inspection.redundant.modifiers.value.lombok.display.name=@Value 제어자
inspection.redundant.slf.4.j.definition.display.name=@Slf4j
inspection.springqualifiercopyable.lombok.display.name=@Qualifier를 Lombok으로 복사할 수 없음
intention.category.lombok=Java/Lombok
intention.name.create.new.field.s=새 필드 ''{0}'' 생성
intention.name.replace.with.lombok=Lombok으로 바꾸기
notification.enable.annotation.processing=어노테이션 처리 활성화
notification.group.lombok=Lombok 통합 문제
plugin.settings.title=Lombok
popup.content.java.annotation.processing.has.been.enabled=Java 어노테이션 처리가 활성화되었습니다
replace.0.with.explicit.type.lombok=''{0}''을(를) 명시적 타입으로 바꾸기(Lombok)
replace.explicit.type.with.0.lombok=명시적 타입을 ''{0}''(으)로 바꾸기(Lombok)
replace.with.annotations.lombok=어노테이션으로 바꾸기(Lombok)