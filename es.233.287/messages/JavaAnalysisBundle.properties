0.field.is.always.initialized.not.null=El campo @ {0} siempre se inicializa a un estado no nulo.
access.can.be.0=El acceso puede ser {0}
access.can.be.package.private=액세스는 package-private일 수 있습니다
access.to.field.code.ref.code.outside.of.declared.guards.loc=Acceso al campo <code>\#ref</code> fuera de la guardia declarada\#loc
add.explicit.type.arguments=Agregar argumentos de tipo explícito
annotate.as.safevarargs=Anotar con @SafeVarargs
annotate.overridden.methods.parameters=Anotar los parámetros del método anulado con ''@{0} ''
annotate.overridden.methods.parameters.family.name=Agregar al parámetro de método anulado
annotation.target.ANNOTATION_TYPE=Tipo de anotación
annotation.target.CONSTRUCTOR=Constructor
annotation.target.FIELD=campo
annotation.target.LOCAL_VARIABLE=Variables locales
annotation.target.METHOD=método
annotation.target.MODULE=Módulo
annotation.target.PACKAGE=paquete
annotation.target.PARAMETER=parámetro
annotation.target.RECORD_COMPONENT=Componente de registro
annotation.target.TYPE=Tipo
annotation.target.TYPE_PARAMETER=Tipo de parámetro
annotation.target.TYPE_USE=Tipo de uso
anonymous.ref.loc.can.be.replaced.with.0=Anonymous\#ref\#loc se puede reemplazar con {0}.
anonymous.ref.loc.can.be.replaced.with.lambda=Puede reemplazar una\#ref\#loc lambda anónima.
arguments.count.mismatch=Se esperaban {0} argumentos, pero se encontraron {1}
assigning.a.collection.of.nullable.elements=Asignar una colección de elementos que aceptan valores NULL a una colección de elementos que no aceptan valores NULL
call.to.method.code.ref.code.outside.of.declared.guards.loc=Llamar al método <code>\#ref ()</code> fuera de la guardia declarada\#loc
change.type.arguments=Cambiar tipo de argumentos
change.type.arguments.to.0=Cambiar tipo de argumento a <{0}>
change.visibility.level=establecer {0} en {1}
chooser.popup.title.select.class.to.move.members.to=대상 클래스 선택
comparision.between.object.and.primitive=Las comparaciones entre objetos y primitivos son ilegales y solo se permiten en Java 7.
contract.return.validator.incompatible.return.parameter.type=El tipo de retorno ''{0}'' debe ser convertible del tipo de parámetro ''{1}''
contract.return.validator.method.return.incompatible.with.method.containing.class=El tipo de retorno del método debe ser compatible con el método contenedor
contract.return.validator.not.applicable.for.constructor=No se puede aplicar al constructor
contract.return.validator.not.applicable.primitive=No se puede aplicar al tipo de retorno predeterminado ''{0}''
contract.return.validator.not.applicable.static=static no se puede aplicar al método
contract.return.validator.return.type.must.be.boolean=El tipo de retorno del método debe ser '' booleano ''
contract.return.validator.too.few.parameters={0, choice, 0\#parameterless |1\#one parameter|2\#parameter {0} private} No hay
contract.return.value.validation.prefix=Valor de devolución del contrato ''{0}''\:
custom.exception.class.should.have.a.constructor=Una clase de excepción personalizada debe tener un constructor con un único parámetro de mensaje de tipo String.
dataflow.message.array.index.out.of.bounds=Índice de matriz fuera de límites.
dataflow.message.arraystore=Almacenar elementos de tipo <code> {0}</code> en una matriz de elementos <code> {1}</code> arroja <code> ArrayStoreException</code>
dataflow.message.assigning.null=<code> null</code> se asigna a una variable anotada con @NotNull
dataflow.message.assigning.null.notannotated=Asignar valores <code> nulos</code> a campos no anotados
dataflow.message.assigning.nullable=La expresión <code>\#ref</code> se puede evaluar como <code> null</code> pero se asigna a una variable anotada con @NotNull.
dataflow.message.assigning.nullable.notannotated=La expresión <code>\#ref</code> puede ser\#loc nula pero se asignará a un campo no anotado
dataflow.message.cce=La conversión de <code> {0}</code> a <code>\#ref</code>\#loc puede producir <code> java.lang.ClassCastException</code>
dataflow.message.cce.always=la conversión de <code> {0}</code> a <code>\#ref</code> da\#loc cualquier <código> ClassCastException</code> no nulo que se genere.
dataflow.message.constant.condition=La condición <code>\#ref</code> es\#loc siempre <code> {0, choice, 0\#false |1\#true}</code>.
dataflow.message.constant.condition.when.reached=condition <code>\#ref</code> es siempre <code> {0, choice, 0\#false |1\#true cuando se alcanza\#loc}</código>.
dataflow.message.constant.expression=<code>\#ref</code> \#loc siempre da como resultado ''{0}''
dataflow.message.constant.method.reference=El resultado de la referencia del método es siempre ''{0}''.
dataflow.message.constant.no.ref=La condición es siempre {0, choice, 0\#false |1\#true}.
dataflow.message.constant.value=El valor <code>\#ref</code>\#loc es siempre ''{0}''
dataflow.message.contract.fail=The call to ''\#ref'' always fails,according to its method contracts
dataflow.message.contract.fail.index=La llamada ''\#ref '' siempre falla cuando el índice está fuera de rango.
dataflow.message.fail="#ref" 호출이 항상 예외와 함께 실패합니다
dataflow.message.immutable.modified=Los objetos inmutables se modifican.
dataflow.message.immutable.passed=Se pasan objetos inmutables donde se espera mutable.
dataflow.message.negative.array.size=음수 배열 크기
dataflow.message.npe.array.access=Array access <code>\#ref</code> \#loc may produce <code>java.lang.NullPointerException</code>
dataflow.message.npe.array.access.sure=El acceso a la matriz <code>\#ref</code> generará\#loc <code> NullPointerException</code>.
dataflow.message.npe.field.access=Dereference of <code>\#ref</code> \#loc may produce <code>java.lang.NullPointerException</code>
dataflow.message.npe.field.access.sure=Dereference of <code>\#ref</code> \#loc will produce <code>java.lang.NullPointerException</code>
dataflow.message.npe.inner.class.construction=La construcción de la clase interna puede producir <code> java.lang.NullPointerException</code>
dataflow.message.npe.inner.class.construction.sure=La estructura de clases interna generará <code> NullPointerException</code>.
dataflow.message.npe.method.invocation=La invocación del método <code>\#ref</code> generará\#loc <code> NullPointerException</code>
dataflow.message.npe.method.invocation.sure=La invocación del método <code>\#ref</code> generará\#loc <code> NullPointerException</code>.
dataflow.message.npe.methodref.invocation=Method reference invocation <code>\#ref</code> \#loc may produce <code>java.lang.NullPointerException</code>
dataflow.message.npe.template.invocation=템플릿 프로세서 호출은 <code>NullPointerException</code>을 일으킬 수 있습니다
dataflow.message.npe.template.invocation.sure=템플릿 프로세서 호출은 <code>NullPointerException</code>을 일으킬 수 있습니다
dataflow.message.only.switch.label=La etiqueta del conmutador <code>\#ref</code>\#loc se alcanza de forma única en todo el conmutador.
dataflow.message.passing.non.null.argument.to.optional=Pasando un argumento no nulo a <code> Opcional</code>
dataflow.message.passing.null.argument=<code> null</code> Pasa argumentos a parámetros anotados con @NotNull
dataflow.message.passing.null.argument.nonannotated=pasando argumentos <code> nulos</code> a campos no anotados
dataflow.message.passing.null.argument.to.optional=Pasando el argumento <code> null</code> a <code> Opcional</code>
dataflow.message.passing.nullable.argument=El argumento <code>\#ref</code> puede ser\#loc nulo.
dataflow.message.passing.nullable.argument.methodref=El argumento de referencia del método puede ser nulo.
dataflow.message.passing.nullable.argument.methodref.nonannotated=El argumento de referencia del método es nulo pero se puede pasar como un parámetro no anotado
dataflow.message.passing.nullable.argument.nonannotated=El argumento <code>\#ref</code> puede ser\#loc nulo pero puede pasarse a parámetros no anotados
dataflow.message.pointless.assignment.expression=La condición <code>\#ref</code> en el lado izquierdo de la expresión de asignación\#loc es siempre <code> {0}</code>. Puedes simplificar esto.
dataflow.message.pointless.same.argument.and.result=''\# ref '' tiene el mismo resultado que el argumento {0, choice, 1\#first | 2\#second}, por lo que la llamada no tiene sentido.
dataflow.message.pointless.same.arguments=Los argumentos de ''\# ref '' son los mismos. Por lo tanto, no tiene sentido llamar a este método con los mismos argumentos.
dataflow.message.redundant.assignment=La variable ya ha sido asignada a este valor.
dataflow.message.redundant.instanceof=La condición <code>\#ref</code> es un duplicado de\#loc y se puede reemplazar con comprobaciones nulas.
dataflow.message.redundant.update=No se ha realizado ninguna acción con la actualización de la variable.
dataflow.message.return.notnull.from.nullable=@{0} El método ''{1}'' devuelve un valor no nulo
dataflow.message.return.null.from.notnull=<code> null</code> se devuelve desde un método declarado como @ {0}.
dataflow.message.return.null.from.notnullable=<code> null</code> se devuelve desde un método no declarado como @ {0}.
dataflow.message.return.nullable.from.notnull=La expresión <code>\#ref</code> se puede evaluar como <code> null</code> pero se declaró como @ {0} devuelta por el método.
dataflow.message.return.nullable.from.notnull.function=La función puede devolver un valor nulo, pero no está permitido aquí
dataflow.message.return.nullable.from.notnullable=La expresión <code>\#ref</code> se puede evaluar como <code> null</code> pero no se declara como @ {0} devuelta desde un no método.
dataflow.message.storing.array.null=<code> null</code> se almacena en una matriz de elementos @NotNull.
dataflow.message.storing.array.nullable=La expresión <code>\#ref</code> se puede evaluar como nula pero se almacena en una matriz de elementos @NotNull.
dataflow.message.stream.consumed=스트림이 이미 연결되거나 사용되었을 수 있습니다
dataflow.message.stream.consumed.always=스트림이 이미 연결되거나 사용되었습니다
dataflow.message.unboxing=Unboxing de <code>\#ref</code> \#loc puede producir <code> java.lang.NullPointerException</code>
dataflow.message.unboxing.method.reference=El uso de <code>\#ref</code> \#loc necesitaría unboxing que puede producir <code> java.lang.NullPointerException</code>
dataflow.message.unboxing.nullable.argument.methodref=Pasar argumentos a la referencia del método requiere unboxing que puede generar <code> NullPointerException</code>
dataflow.message.unknown.nullability=\ (알 수 없는 null 값 가능성)
dataflow.message.unreachable.switch.label=no se alcanza la etiqueta de cambio <code>\#ref</code>.
dataflow.method.fails.with.null.argument=El método genera una excepción cuando el parámetro es nulo.
dataflow.not.precise={0} es complejo y puede dar como resultado resultados de flujo de datos inexactos.
dataflow.too.complex=El método <code>\#ref</code> es demasiado complejo para analizarlo mediante el algoritmo de flujo de datos
delete.repeated.0=Eliminar repetidos ''{0}''
delete.repeated.interface=Eliminar interfaz repetida
delimiters.argument.contains.duplicated.characters=El argumento delimiters contiene caracteres duplicados.
deprecated.class.usage.group.xml=XML
deprecated.member.0.is.still.used=El miembro obsoleto ''{0}'' todavía está en uso.
detach.library.quickfix.name=Desconectar biblioteca
detach.library.roots.quickfix.name=Desconectar las raíces de la biblioteca no utilizadas
dfa.find.cause.an.execution.might.exist.where=La ejecución puede estar en:
dfa.find.cause.array.length.is.always.non.negative=La longitud de la matriz siempre es no negativa
dfa.find.cause.call.always.fails=Las llamadas siempre fallan
dfa.find.cause.cast.may.fail=el lanzamiento puede fallar
dfa.find.cause.collection.size.is.always.non.negative=El tamaño de la colección siempre es no negativo
dfa.find.cause.comparison.arguments.are.different.constants=Los argumentos de comparación son constantes diferentes
dfa.find.cause.comparison.arguments.are.the.same=Los argumentos de comparación son iguales
dfa.find.cause.compile.time.constant=Una constante en tiempo de compilación que se evalúa como ''{0}''
dfa.find.cause.condition.is.known.from.place=Conocido por ser ''{0}'' de ___ PLACE___
dfa.find.cause.condition.was.checked.before=La condición ''{0}'' fue verificada previamente
dfa.find.cause.condition.was.deduced=Se supuso la condición ''{0}''
dfa.find.cause.contract.kind.explicit=Contrato
dfa.find.cause.contract.kind.hard.coded=contrato codificado
dfa.find.cause.contract.kind.inferred=Contrato inferido
dfa.find.cause.contract.returns.on.condition=El método ''{1}'' devuelve el valor ''{2}'' para {3} según {0}
dfa.find.cause.contract.throws.on.condition=El método ''{1}'' arroja una excepción para {2} según {0}
dfa.find.cause.contract.trivial=El método ''{1}'' siempre devuelve el valor ''{2}'' según {0}
dfa.find.cause.equality.established.from.condition=''{0}'' se estableció en una condición
dfa.find.cause.field.assigned.nullability=Siempre se sabe que el campo ''{0}'' se inicializa con el valor ''{1}''
dfa.find.cause.field.initializer.nullability=El campo ''{0}'' se inicializa con el valor ''{1}''
dfa.find.cause.instanceof.implies.non.nullity=comprobar '' instanceof '' significa no nulo
dfa.find.cause.left.operand.range.template=El operando izquierdo es%s
dfa.find.cause.may.be.null=puede ser null
dfa.find.cause.nonnull.expression.kind.concatenation=Concatenación
dfa.find.cause.nonnull.expression.kind.literal=literal
dfa.find.cause.nonnull.expression.kind.newly.created.object=Objeto recién creado
dfa.find.cause.nonnull.expression.kind.primitive.type=Valor del tipo primitivo ''{0}''
dfa.find.cause.nonnull.expression.kind.this.object='' este '' objeto
dfa.find.cause.nullability.explicitly.annotated={0} ''{1}'' fue anotado como ''{2}''
dfa.find.cause.nullability.externally.annotated={0} ''{1}'' anotado externamente como ''{2}''
dfa.find.cause.nullability.inferred={0} ''{1}'' se infirió que era ''{2}''
dfa.find.cause.nullability.inherited.from.class={0} ''{1}'' es ''{3}'' porque hereda las anotaciones de la clase {2}
dfa.find.cause.nullability.inherited.from.container={0} es ''{2}'' porque ''{1}'' hereda la anotación de la anotación del contenedor
dfa.find.cause.nullability.inherited.from.named.element={0} es ''{3}'' porque ''{1}'' hereda de {2}
dfa.find.cause.nullability.inherited.from.package={0} ''{1}'' es ''{3}'' porque hereda las anotaciones del paquete {2}
dfa.find.cause.numeric.cast.operand.template=el operando de conversión es%s
dfa.find.cause.numeric.range.generic.template=El valor es%s
dfa.find.cause.object.kind.expression=expresión
dfa.find.cause.object.kind.generic=Objeto
dfa.find.cause.object.kind.method.return=método de retorno
dfa.find.cause.obviously.non.null.expression=No puede ser nulo porque la expresión es {0}
dfa.find.cause.one.of.the.following.happens=Ocurre uno de los siguientes.
dfa.find.cause.operand.of.boolean.expression.is.the.same={1, choice, 0#and|1#or} 체인의 연산자 #{0}이(가) {2}입니다
dfa.find.cause.place.here=here
dfa.find.cause.place.line.number=línea\# {0}
dfa.find.cause.primitive.boxed=기본값이 박싱되었습니다
dfa.find.cause.range.is.known.from.place=Se sabe que el rango proviene de ___PLACE___
dfa.find.cause.range.is.specified.by.annotation=''{0}'' está anotado con el rango {1}
dfa.find.cause.result.of.numeric.operation.template=El resultado de ''{0}'' es%s
dfa.find.cause.result.of.primitive.cast.template='' ({0}) '' el resultado del lanzamiento es%s
dfa.find.cause.right.operand.range.template=El operando derecho es%s
dfa.find.cause.size.is.always.zero=크기가 항상 0입니다
dfa.find.cause.special.field.of.something={1} 중 {0}
dfa.find.cause.string.length.is.always.non.negative=La longitud de la cadena siempre es no negativa
dfa.find.cause.type.is.known.from.place=Se sabe que el tipo de ''{0}'' proviene de ___PLACE___
dfa.find.cause.type.known={0} es de tipo {1}
dfa.find.cause.unable=No se puede encontrar la causa
dfa.find.cause.value.is.always.the.same=El valor siempre es {0}
dfa.find.cause.value.is.known.from.place=Se sabe que ''{0}'' es ''{1}'' de ___PLACE___
dfa.find.cause.value.x.is.always.the.same=Value ''{0}'' es siempre ''{1}''
dfa.find.cause.values.cannot.be.equal.because=Por qué los valores no pueden ser iguales\: {0}
dfa.find.cause.variable.is.initialized={0} ''{1}'' se inicializó en {2}
dfa.find.cause.was.assigned=''{0}'' ha sido asignado
dfa.find.cause.was.assigned.to={0}'' fue asignado a ''{1}
dfa.find.cause.was.dereferenced=''{0}'' ha sido desreferenciado
dfa.find.cause.was.passed.as.non.null.parameter=''{0}'' se pasó como argumento a un método que acepta un parámetro no nulo
dftype.presentation.empty.optional=Vacío Opcional
dftype.presentation.present.optional=Actual Opcional
don.t.report.unused.jars.inside.used.library=No informe los frascos no utilizados dentro de las bibliotecas usadas
duplication.policy.ask=Comprobar
duplication.policy.generate.duplicate=Crear método duplicado
duplication.policy.replace=Reemplazar artículo existente
element.kind.keys=Claves
element.kind.objects=Objetos
element.kind.values=Valores
error.class.not.found=No se pudo encontrar la clase {0}
error.message.invalid.java.type=Tipo de Java no válido
error.unnamed.field.not.allowed=이름 없는 필드는 허용되지 않습니다
error.unnamed.method.parameter.not.allowed=이름 없는 메서드 매개변수는 허용되지 않습니다
error.unnamed.variable.brackets=이름이 없는 변수의 선언 뒤에 대괄호를 사용할 수 없습니다
error.unnamed.variable.not.allowed.in.this.context=이 컨텍스트에서 이름 없는 변수 선언은 허용되지 않습니다
error.unnamed.variable.without.initializer=이름 없는 변수 선언은 이니셜라이저가 필요합니다
exception.handler.will.become.unreachable=catch 섹션에 도달할 수 없게 됩니다
explicit.type.argument.ref.loc.can.be.replaced.with=Puede reemplazar el argumento de tipo explícito\#ref\#loc con <>.
exports.to.itself.delete.module.ref.fix=Eliminar referencia al módulo ''{0}''.
exports.to.itself.delete.statement.fix=Eliminar directiva.
feature.annotations=Anotaciones
feature.binary.literals=literal binario
feature.diamond.types=Tipos de diamantes
feature.enhanced.switch=Bloque '' switch '' mejorado
feature.enum.qualified.name.in.switch=switch 내에서 정규화된 enum을 상수로 사용
feature.extension.methods=Métodos de extensión
feature.for.each=Para cada bucle
feature.generics=genéricos
feature.hex.fp.literals=literales de punto flotante hexadecimal
feature.inner.statics=내부 클래스 내 static 선언
feature.intersections.in.casts=Tipos de intersección en moldes
feature.lambda.expressions=Expresiones Lambda
feature.local.enums=Enumeraciones locales
feature.local.interfaces=Interfaces locales
feature.lvti=Inferir tipos de variables locales
feature.method.references=Referencias de métodos
feature.modules=Módulos
feature.multi.catch=Varias capturas
feature.parenthesised.patterns=괄호처리된 패턴
feature.pattern.guard.and.record.patterns=패턴 가드 및 레코드 패턴
feature.patterns.in.switch=switch 내 패턴
feature.patterns.instanceof='' instancia de '' mi patrón
feature.record.patterns.in.for.each=for-each 루프에서 패턴 기록
feature.records=Registros
feature.sealed.classes=Clases selladas
feature.static.imports=declaración de importación estática
feature.static.interface.calls=Llamadas a métodos de interfaz estática
feature.string.templates=문자열 템플릿
feature.switch.expressions=expresión '' cambiar ''
feature.text.block.escape.sequences=secuencias de escape ''\\s'' y ''\''
feature.text.blocks=Literales de bloque de texto
feature.try.with.resources=Try-with-resources
feature.try.with.resources.refs=Referencias de recursos
feature.type.annotations=Tipo de anotaciones
feature.type.receivers=Parámetros del receptor
feature.underscores.in.literals=Guiones bajos en literales
feature.unnamed.classes=이름이 없는 클래스
feature.unnamed.vars=이름이 없는 패턴과 변수
feature.var.lambda.parameter='' var '' en el parámetro lambda
feature.varargs=Métodos de aridad variable
find.searching.for.references.to.class.progress=Buscando referencias para la clase {0}...
find.usages.panel.title.base.methods=기본 메서드 사용 위치
find.usages.panel.title.base.methods.cap=기본 메서드 사용 위치
find.usages.panel.title.derived.classes=Clases derivadas
find.usages.panel.title.derived.classes.cap=파생 클래스
find.usages.panel.title.derived.interfaces=Interfaces derivadas
find.usages.panel.title.derived.interfaces.cap=파생 인터페이스
find.usages.panel.title.implementing.classes=Implementación de clase
find.usages.panel.title.implementing.classes.cap=구현 클래스
find.usages.panel.title.implementing.methods=implementación del método
find.usages.panel.title.implementing.methods.cap=구현 메서드
find.usages.panel.title.overloaded.methods.usages=Dónde usar métodos sobrecargados
find.usages.panel.title.overloaded.methods.usages.cap=오버로드된 메서드
find.usages.panel.title.overriding.methods=Métodos de reemplazo
find.usages.panel.title.overriding.methods.cap=재정의 메서드
generate.members.position.after.equals.and.hashcode=Después de equals () y hashCode ()
generate.members.position.at.caret=en la posición de intercalación
generate.members.position.at.the.end.of.class=Fin de la clase
highlighting.try.blocks=try 블록 강조 표시 중...
html.classes.exposed.with.code.module.info.code.html=Clases expuestas como <html><code> module-info</code></html>
html.ignore.overrides.of.deprecated.abstract.methods=<html>Ignorar anulaciones de métodos abstractos obsoletos en ancestros obsoletos</html>
ignore.casts.in.suspicious.collections.method.calls=Ignorar las conversiones en llamadas a métodos de recolección sospechosos
ignore.exceptions.thrown.by.entry.points.methods=Ignorar excepciones lanzadas por métodos de punto de entrada
ignore.in.the.same.outermost.class=Ignorar en la misma clase más externa
ignore.in.the.same.project=이 프로젝트에서 선언된 API 무시
ignore.inside.deprecated.members=Ignorar dentro de miembros obsoletos
ignore.inside.non.static.imports=Ignorar las declaraciones de importación no estáticas
ignore.members.of.deprecated.classes=Ignorar miembros de clases obsoletas
ignore.operation.which.results.in.negative.value=Ignorar la operación '' << '' que da como resultado valores negativos
inspection.annotate.method.quickfix.family.name=Método anotado
inspection.annotate.method.quickfix.name=Anotar método con ''@{0} ''
inspection.annotate.overridden.method.and.self.quickfix.family.name=Método reemplazado y agregar una anotación a sí mismo
inspection.annotate.overridden.method.and.self.quickfix.name=Método anulado y anotarse a sí mismo como ''@{0} ''
inspection.annotate.overridden.method.nullable.quickfix.name=Anotar el método anulado con ''@{0} ''
inspection.annotate.overridden.method.quickfix.family.name=Agregar una anotación al método reemplazado
inspection.annotate.overridden.method.quickfix.name=Anotar el método anulado con ''@{0} ''
inspection.anonymous.has.lambda.alternative.display.name=El tipo anónimo tiene un reemplazo lambda más corto
inspection.block.marker.comments.display.name=Comentarios de marcadores de bloque
inspection.c.style.array.declarations.option=Ignorar declaraciones de estilo C en variables
inspection.can.be.final.accept.quickfix=Haga que la inspección pueda ser final.
inspection.can.be.final.display.name=La declaración puede tener un controlador final
inspection.can.be.final.option=Informe de clase
inspection.can.be.final.option1=Método de informe
inspection.can.be.final.option2=Campo de informe
inspection.can.be.local.parameter.problem.descriptor=Los parámetros <code>\#ref</code> pueden tener modificadores <code> finales</code>.
inspection.can.be.local.variable.problem.descriptor=La variable <code>\#ref</code> puede tener modificadores <code> final</code>.
inspection.can.be.replaced.with.message={0}
inspection.class.getclass.display.name=llamada Class.getClass ()
inspection.class.getclass.fix.remove.name=llamada '' getClass()'' eliminada
inspection.class.getclass.fix.replace.name=Reemplace '' Class.class ''.
inspection.class.getclass.message='' getClass()'' se llama en una instancia de clase.
inspection.class.has.no.to.string.method.description=La clase ''{0}'' no anula el método '' toString() ''.
inspection.class.has.no.to.string.method.display.name=La clase no anula el método '' toString() ''
inspection.class.has.no.to.string.method.exclude.classes.reg.exp.option=Excluir clase (regex)\:
inspection.class.has.no.to.string.method.ignore.abstract.classes.option=Ignorar clases abstractas
inspection.class.has.no.to.string.method.ignore.deprecated.classes.option=Ignorar clases obsoletas
inspection.class.has.no.to.string.method.ignore.enum.classes.option=Ignorar clases de enumeración
inspection.class.has.no.to.string.method.ignore.exception.classes.option=Ignorar clases de excepción
inspection.class.has.no.to.string.method.ignore.inner.classes.option=Ignorar clases internas
inspection.class.has.no.to.string.method.ignore.records.option=레코드 무시
inspection.class.has.no.to.string.method.ignore.test.classes.option=Ignorar clases de prueba
inspection.common.if.parts.disable.highlight.tail.call=No resalte partes comunes cuando se invoca la sintaxis de cola.
inspection.common.if.parts.family=Extrae partes comunes de la declaración '' if ''
inspection.common.if.parts.family.else.if=combinación de sentencias '' else if ''
inspection.common.if.parts.family.else.if.description='' else if '' puede fusionarse.
inspection.common.if.parts.family.else.if.invert=두 번째 조건을 반전하여 'else if' 구문 병합
inspection.common.if.parts.settings.highlight.else.if=간소화할 수 있는 else-if 체인 강조 표시
inspection.common.if.parts.settings.highlight.when.tail.call=Resaltar cuando se llama a la última sintaxis común.
inspection.compiler.javac.quirks.anno.array.comma.fix=Elimine las comas finales.
inspection.compiler.javac.quirks.anno.array.comma.problem=La coma final en el inicializador de la matriz de anotaciones puede causar errores de compilación en algunas versiones de Javac (por ejemplo, JDK 5 y JDK 6).
inspection.compiler.javac.quirks.name=Problema de Javac
inspection.compiler.javac.quirks.qualifier.type.args.fix=Eliminar parámetros genéricos.
inspection.compiler.javac.quirks.qualifier.type.args.problem=Los genéricos en las referencias de los calificadores pueden causar errores de compilación en algunas versiones de Javac (por ejemplo, JDK 5 y JDK 6)
inspection.constant.on.wrong.side.of.a.comparison.side.option=Donde debe estar la constante en la comparación\:
inspection.contract.checker.boolean.condition.for.nonboolean.parameter=El parámetro ''{0}'' es de tipo ''{1}'' (requiere booleano)
inspection.contract.checker.clause.syntax=La cláusula del contrato debe tener el formato arg1,..., argN -> valor de retorno
inspection.contract.checker.contract.clause.never.satisfied=La cláusula del contrato ''{0}'' no se cumple porque la condición está incluida en el contrato anterior
inspection.contract.checker.contract.violated=Se violó la cláusula del contrato ''{0}''
inspection.contract.checker.empty.constraint=La restricción no debe estar vacía
inspection.contract.checker.inferred.notnull.parameter.notnull=Se infiere que el parámetro ''{0}'' no es nulo, por lo que '' \! null '' siempre se cumple
inspection.contract.checker.inferred.notnull.parameter.null='' null '' no es aplicable porque se infiere que el parámetro ''{0}'' es un valor no nulo
inspection.contract.checker.method.always.fails.nontrivial=El método siempre falla en este caso, por lo que puede reemplazar el valor de retorno de la cláusula ''{0}'' con '' fail ''
inspection.contract.checker.method.always.fails.trivial=El método siempre falla, por lo que puede reemplazar el valor de retorno de la cláusula ''{0}'' con '' fail ''
inspection.contract.checker.no.exception.thrown=Se violó la cláusula del contrato ''{0}''\: no se lanzó ninguna excepción
inspection.contract.checker.notnull.parameter.notnull=El parámetro ''{0}'' está anotado con un valor no nulo, por lo que '' \! null '' siempre se cumple
inspection.contract.checker.notnull.parameter.null=No se puede aplicar '' nulo '' porque el parámetro ''{0}'' está anotado con un valor no nulo
inspection.contract.checker.parameter.count.mismatch=La cláusula del contrato ''{1}'' requiere {2}, pero el método toma el parámetro {0}
inspection.contract.checker.primitive.parameter.nullability=No se puede aplicar ''{2}'' porque el tipo primitivo de parámetro ''{0}'' es ''{1}''
inspection.contract.checker.pure.method.mutation.contract=Los métodos puros no pueden tener contratos de mutación
inspection.contract.checker.unknown.constraint=La restricción debe ser una de\: {0}. encontrado\: {1}
inspection.contract.checker.unknown.return.value=El valor devuelto debe ser uno de: {0}. encontrado\: {1}
inspection.contract.checker.unreachable.contract.clause=No se puede alcanzar la cláusula del contrato ''{0}''\: el contrato anterior contiene todas las cláusulas posibles
inspection.contract.display.name=problema del contrato
inspection.convert.2.diamond.display.name=Puede convertir el tipo explícito a <>
inspection.convert.2.lambda.display.name=Puede convertir el tipo anónimo a lambda
inspection.data.flow.redundant.instanceof.quickfix=Reemplazo de inspección nula.
inspection.data.flow.simplify.boolean.expression.quickfix=Simplificar expresiones booleanas
inspection.data.flow.simplify.to.assignment.quickfix.name=Simplificar con asignación genérica
inspection.data.flow.turn.off.constant.references.quickfix=No informa los valores garantizados como constantes.
inspection.data.flow.turn.off.nullable.returning.notnull.quickfix=No informe de métodos que aceptan valores NULL que siempre devuelven un valor no nulo.
inspection.data.flow.turn.off.true.asserts.quickfix=No informe siempre afirmaciones verdaderas.
inspection.deprecated.class.usage.inspection.display.name=Usar API obsoleta en XML
inspection.deprecated.is.still.used.display.name=El miembro obsoleto todavía se usa
inspection.duplicate.throws.display.name=Lanza duplicado
inspection.duplicate.throws.ignore.subclassing.option=Ignorar excepciones que subclasifican otras clases
inspection.duplicate.throws.more.general.problem=Ya hay una excepción más general, ''{0}'', en la lista de lanzamientos.
inspection.duplicate.throws.problem=Lanza como duplicados.
inspection.equals.hashcode.only.one.defined.problem.descriptor=La clase {0} está definida, pero la clase no define {1}.
inspection.export.results.can.be.final.description=La declaración puede tener el controlador final
inspection.expression.can.be.replaced.with.message=표현식을 ''{0}''(으)로 바꿀수 있습니다
inspection.extract.method.dont.suggest.length=이렇게 짧은 메서드의 추출을 제안하지 않음
inspection.extract.method.dont.suggest.parameters=매개변수가 {0}개 이상 있는 메서드의 추출을 제안하지 않음
inspection.extract.method.inspection.name=메서드를 추출할 수 있음
inspection.extract.method.message=길게 감싸는 메서드로부터 ''{0}''을(를) 반환하는 메서드를 추출할 수 있습니다
inspection.extract.method.nothing=없음
inspection.extract.method.option.max.parameters=최대 매개변수 수:
inspection.extract.method.option.min.length=추출할 코드의 최소 길이: 심볼
inspection.extract.method.preview.html={1}을(를) 취하고 <b>{2}</b>을(를) 반환하는 {0} 문을 메서드로 추출
inspection.field.access.not.guarded.display.name=Acceder a un campo desprotegido o llamar a un método
inspection.field.not.used.in.to.string.description=El método ''{0}'' no se usa en el método '' toString() ''.
inspection.field.not.used.in.to.string.description2=El campo ''{0}'' no se usa en el método '' toString() ''.
inspection.field.not.used.in.to.string.display.name=campo no utilizado en el método de '' toString() ''
inspection.fix.name.remove.scheduled.for.removal.annotation.by.attribute=@ScheduledForRemoval을 @Deprecated 어노테이션의 'forRemoval' 속성으로 바꾸기
inspection.i18n.quickfix.annotate=Anotar...
inspection.i18n.quickfix.annotate.as=Anotado con @{0}
inspection.i18n.quickfix.annotate.element={0} Agregar anotación a ''{1}''...
inspection.i18n.quickfix.annotate.element.as={0} anotado ''{1}'' como @ {2}
inspection.implicit.subclass.display.forClass=La clase ''{0}'' puede ser subclasificada implícitamente y no debe ser final.
inspection.implicit.subclass.display.name=No se puede anular la declaración final en tiempo de ejecución.
inspection.implicit.subclass.extendable=Haga que la ''{0}'' sea reemplazable.
inspection.implicit.subclass.make.class.extendable=Class ''{0}'' {1, choice, 0\# |1\# y método {2} con | 1 <y el método requerido {1 Make}} extensible .
inspection.inconsistent.language.level.display.name=Configuración de nivel de lenguaje inconsistente
inspection.infinite.loop.option=Ignorar si se coloca en Thread.run
inspection.instance.guarded.by.static.display.name=Miembro de instancia protegido por campo estático
inspection.invalid.comparator.method.reference.display.name=Se utilizó una referencia de método no válida en la Comparator
inspection.java.8.list.sort.display.name=Collections.sort () se puede reemplazar con List.sort ()
inspection.java.9.redundant.requires.statement.display.name=Declaración innecesaria '' requiere '' en la module-info
inspection.java.module.naming=Convención de nomenclatura de módulos Java
inspection.java.module.naming.terminal.digits=El componente del nombre del módulo ''{0}'' debe evitar dígitos terminales.
inspection.local.can.be.final.display.name=La variable o parámetro local puede ser final
inspection.local.can.be.final.option=Informar variable local
inspection.local.can.be.final.option1=Parámetros del método de informe
inspection.local.can.be.final.option2=informe de parámetro de captura
inspection.local.can.be.final.option3=Informe para cada parámetro
inspection.local.can.be.final.option4=Informe de la variable final implícita
inspection.local.can.be.final.option5=패턴 변수 보고
inspection.message.code.generation.different.nullability.annotation.will.be.used=El código generado usa ''{1}'' en lugar de ''{0}''.
inspection.message.javac.quick.intersection.type.problem=La asignación es formalmente correcta, pero puede generar una ClassCastException en tiempo de ejecución. Requerido\: ''{0}'', Real\: ''{1}''
inspection.message.non.annotated.method.implements.non.null.method=El método no anotado ''{0}'' de ''{1}'' es nulo para ''{2}'' implementar este método no
inspection.message.non.annotated.parameter.should.not.override.non.null.parameter=El parámetro no anotado '' {0} 'en el método' '{1}' 'de' '{2}' '' no debe anular los parámetros no nulos de ''{3}''
inspection.message.non.null.parameter.should.not.override.non.annotated.parameter=El parámetro no nulo ''{0}'' en el método ''{1}'' de ''{2}'' no debe anular el parámetro no anotado de ''{3}'' Es posible
inspection.message.non.null.parameter.should.not.override.nullable.parameter=parámetro no nulo ''{0}'' en el método ''{1}'' de la ''{2}'' no debe anular los parámetros que aceptan valores NULL de ''{3}''
inspection.message.nullable.method.implements.non.null.method=El método anulable ''{0}'' de ''{1}'' no es el método anulable del implemento ''{2}''
inspection.message.scheduled.for.removal.annotation.can.be.removed=@ScheduledForRemoval 어노테이션은 제거될 수 있습니다
inspection.message.scheduled.for.removal.annotation.can.be.replaced.by.attribute=@ScheduledForRemoval 어노테이션은 @Deprecated 어노테이션의 'forRemoval' 속성으로 바꿀 수 있습니다
inspection.module.exports.package.to.itself=Exporta un paquete a sí mismo desde un módulo o lo abre en sí mismo.
inspection.name.redundant.scheduled.for.removal.annotation=불필요한 @ScheduledForRemoval 어노테이션
inspection.non.final.field.in.immutable.display.name=campo no final en la clase @Immutable
inspection.non.final.guard.display.name=Campo @GuardedBy no final
inspection.nullable.problems.NotNull.parameter.overrides.Nullable=El parámetro anotado con @{0} NO DEBE anular el parámetro @ {1}
inspection.nullable.problems.NotNull.parameter.overrides.not.annotated=Los parámetros anotados con @{0} NO DEBEN anular los parámetros no anotados
inspection.nullable.problems.NotNull.parameter.receives.null.literal=El parámetro anotado con @{0} NO DEBE aceptar '' nulo '' como argumento
inspection.nullable.problems.Nullable.NotNull.conflict=No se pueden anotar tanto @ {0} como @ {1}.
inspection.nullable.problems.Nullable.method.overrides.NotNull=El método anotado con @{0} NO DEBE anular el método @ {1}
inspection.nullable.problems.annotated.field.constructor.parameter.not.annotated=El parámetro de constructor para el campo @ {0} se puede anotar como @ {0}.
inspection.nullable.problems.annotated.field.getter.conflict=Getter para el campo @ {0} anotado con @ {1}
inspection.nullable.problems.annotated.field.getter.not.annotated=El captador para el campo @ {0} se puede anotar como @ {0}.
inspection.nullable.problems.annotated.field.setter.parameter.conflict=Parámetro de establecimiento para el campo @ {0} anotado con @ {1}
inspection.nullable.problems.annotated.field.setter.parameter.not.annotated=El parámetro Setter para el campo @ {0} se puede anotar con @ {0}.
inspection.nullable.problems.applied.to.package=완전히 정규화된 이름에 관한 어노테이션은 마지막 구성 요소 다음에 위치해야 합니다
inspection.nullable.problems.at.constructor=null 값 가능성을 표시하는 어노테이션을 생성자에 적용할 수 없습니다
inspection.nullable.problems.at.enum.constant=null 값 가능성을 표시하는 어노테이션을 열거형 상수에 적용할 수 없습니다
inspection.nullable.problems.at.local.variable=null 값 가능성을 표시하는 어노테이션을 지역 변수에 적용할 수 없습니다
inspection.nullable.problems.at.reference.list=null 값 가능성을 표시하는 어노테이션을 extends/implements 절에 적용할 수 없습니다
inspection.nullable.problems.at.type.parameter=null 값 가능성을 표시하는 어노테이션을 타입 매개변수에 적용할 수 없습니다
inspection.nullable.problems.at.wildcard=null 값 가능성을 표시하는 어노테이션을 와일드카드 타입에 적용할 수 없습니다
inspection.nullable.problems.method.overrides.NotNull=Los métodos no anotados anulan los métodos anotados con @ {0}
inspection.nullable.problems.outer.type=외부 타입은 본질적으로 null이 아닙니다
inspection.nullable.problems.parameter.overrides.NotNull=Los parámetros no anotados anulan los parámetros @ {0}
inspection.nullable.problems.primitive.type.annotation=No se pueden anotar miembros de tipo primitivo
inspection.nullable.problems.receiver.annotation=리시버 매개변수는 본질적으로 null이 아닙니다
inspection.numeric.overflow.display.name=Desbordamiento numérico
inspection.objects.equals.can.be.simplified.display.name=Puede reemplazar objects.equals() con equals().
inspection.quirk.method.reference.return.type.message=타깃 메서드 반환 타입에 액세스할 수 없는 클래스 {0}이(가) 있습니다. 이로 인해 런타임에 IllegalAccessError가 발생합니다.
inspection.redundant.cast.display.name=Conversión de tipo innecesaria
inspection.redundant.cast.problem.descriptor=Conversión duplicada de {0} a {1}.
inspection.redundant.cast.remove.quickfix=Eliminar moldes duplicados
inspection.redundant.field.initialization.option=Advertir solo cuando se inicializa en null
inspection.redundant.requires.statement.description=La directiva duplicada '' requiere {0} ''
inspection.redundant.requires.statement.fix.family=Eliminar la directiva '' require '' duplicada
inspection.redundant.requires.statement.fix.name=La directiva de eliminación '' requiere {0} ''
inspection.redundant.requires.statement.message.java.base.implicitly.required='java.base'가 묵시적으로 필요합니다.
inspection.redundant.requires.statement.message.module.unused=모듈 패키지의 사용 위치가 발견되지 않았습니다.
inspection.redundant.requires.statement.message.transitive.dependencies.on.can.be.used.directly=''{0}''의 이행적 종속 요소는 직접 사용될 수 있습니다.
inspection.redundant.throws.display.name=Cláusula de lanzamientos redundantes
inspection.redundant.throws.problem.descriptor=La implementación del método nunca lanza la excepción declarada {0}.
inspection.redundant.throws.problem.descriptor1=La excepción declarada {0} nunca se lanza en este método, ni en sus derivables.
inspection.redundant.throws.problem.descriptor2=La excepción declarada {0} no se lanza en absoluto.
inspection.redundant.throws.remove.quickfix=Eliminar declaraciones de lanzamientos innecesarios
inspection.redundant.tostring.option.notnull.qualifier=한정자가 null이 아닐 경우에만 보고
inspection.redundant.type.display.name=Argumentos de tipo duplicado
inspection.redundant.type.no.generics.method.reference.problem.descriptor=Los argumentos de tipo son redundantes para referencias de métodos no genéricos.
inspection.redundant.type.no.generics.problem.descriptor=Los argumentos de tipo son redundantes para llamadas a métodos no genéricos.
inspection.redundant.type.problem.descriptor=Puede inferir argumentos de tipo explícito.
inspection.redundant.type.remove.quickfix=Eliminar argumento de tipo
inspection.reference.anonymous.name=Anónimo ({0})
inspection.reference.default.lambda.name=람다
inspection.reference.default.method.reference.name=메서드 참조
inspection.reference.default.package=<predeterminado>
inspection.reference.implicit.constructor.name=Constructor implícito para la {0}
inspection.reference.jsp.holder.method.anonymous.name=<% contenido de la página%>
inspection.reference.lambda.name=람다({0})
inspection.reference.method.reference.name=메서드 참조({0})
inspection.requires.auto.module=Dependencias del módulo automatizado
inspection.requires.auto.module.message=directiva '' requiere '' para módulos automáticos
inspection.requires.auto.module.option=Resaltar dependencias transitivas solamente
inspection.requires.auto.module.transitive=directiva '' requiere transitiva '' para módulos automáticos
inspection.safe.varargs.detector.display.name=Contaminación potencial del montón con tipos de vararg parametrizados
inspection.same.return.value.display.name=El método devuelve el mismo valor
inspection.same.return.value.problem.descriptor=El método siempre devuelve {0}.
inspection.same.return.value.problem.descriptor1=El método y todos sus derivados siempre devuelven {0}.
inspection.same.return.value.problem.descriptor2=Todas las implementaciones de este método siempre devuelven {0}.
inspection.static.guarded.by.instance.display.name=campo de instancia o miembro estático protegido por este
inspection.string.tokenizer.delimiter.display.name=Delimitador duplicado en java.util.StringTokenizer
inspection.surround.requirenonnull.quickfix=Reemplazar con '' Objects.requireNonNull ({0}) ''.
inspection.suspicious.array.method.call.display.name=Llamada sospechosa al método de matriz
inspection.suspicious.array.method.call.problem.arrays=Los tipos de matriz son incompatibles. El arreglo siempre es diferente.
inspection.suspicious.array.method.call.problem.element=El tipo de elemento no es compatible con el tipo de matriz.
inspection.suspicious.collections.method.calls.display.name=Llamada sospechosa al método de recolección
inspection.suspicious.collections.method.calls.problem.descriptor=''{0}'' no puede contener {2} del tipo ''{1}''.
inspection.suspicious.collections.method.calls.problem.descriptor1=Llamada sospechosa ''{0}''.
inspection.suspicious.getter.setter.field.option=Advertir solo si el campo tiene un nombre de captador/definidor coincidente
inspection.suspicious.integer.div.assignment.option=Informe de rotura sospechoso pero preciso
inspection.unary.plus.unary.binary.option=Informe solo en un contexto unario o binario confuso
inspection.unknown.guard.display.name=Campo @GuardedBy desconocido
inspection.unnecessary.super.qualifier.option=Ignore el calificador '' super '' para mayor claridad
inspection.unsatisfied.range.display.name=반환 값이 선언된 범위를 벗어남
inspection.unsatisfied.range.message=반환 값 범위 ''{0}''이(가) 선언된 범위 ''{1}''을(를) 벗어났습니다
inspection.unsatisfied.range.message.value=반환 값 ''{0}''이(가) 선언된 범위 ''{1}''을(를) 벗어났습니다
inspection.use.compare.method.display.name=El método '' compare()'' se puede utilizar para comparar números
inspection.use.compare.method.fix.family.name=Reemplazar con método de comparación simple
inspection.use.compare.method.option.double=Double.compare() 및 Float.compare() 제안
inspection.use.compare.method.turn.off.double=Double.compare() 및 Float.compare() 메서드를 제안하지 않음
inspection.visibility.accept.quickfix=Acepte el nivel de acceso sugerido.
inspection.visibility.compose.suggestion=podría ser {0}.
inspection.visibility.option.constants=Sugerir visibilidad débil para constantes
inspection.visibility.option.package.private.members=Proponer el nivel de visibilidad del paquete privado para los miembros de la clase
inspection.visibility.package.private.top.level.classes=Proponer nivel de visibilidad de paquete privado para clases de nivel superior
inspection.visibility.private.inner.members=<html>Proponer privado para miembros de la clase interna solo cuando se hace referencia a ella desde la clase externa</html>
inspection.weaker.access.display.name=El acceso a la declaración puede ser más débil
instance.member.guarded.by.static.0.loc=miembro de instancia estático\#loc protegido por "{0}"
instance.member.guarded.by.static.ref.loc=miembro de instancia protegido por static\#ref\#loc
intention.add.annotation.family=Agregar anotaciones
intention.add.type.annotation.family=타입 어노테이션 추가
intention.family.name.move.annotation.to.array=어노테이션을 배열로 이동
intention.family.name.move.members.into.class=클래스로 멤버 이동
intention.family.name.move.members.to={0}(으)로 멤버 이동
intention.family.name.remove.new.family.name='new' 제거
intention.family.name.remove.repeating.call=반복되는 호출 제거
intention.family.name.replace.with.expression=표현식으로 바꾸기
intention.family.name.replace.with.unnamed.pattern=이름이 없는 패턴으로 바꾸기
intention.name.ignore.exception=예외 ''{0}'' 무시
intention.name.make.variable.effectively.final=변수를 사실상 final로 만들기
intention.name.qualify.expression=calificar expresión {0} a ''{1}''
intention.name.remove.repeating.call=반복되는 호출 ''{0}()'' 제거
intention.text.remove.annotation=Eliminar
make.0.default.annotation=Hacer que "{0}" sea la anotación predeterminada
make.0.default.annotation.preview=코드 생성 시 기본값으로 사용되는 null 가능성 표시법을 변경합니다.
make.default.the.last.case.family.name=Haga que '' default '' sea el último caso
make.final.and.annotate.as.safevarargs=final y anotar con @SafeVarargs
message.class.inaccessible=\ ''{0}'' no es accesible
message.class.inaccessible.from.module=No se pudo acceder a la clase ''{0}'' desde el módulo ''{1}''
method.reference.mapped.to.comparator=Una referencia de método asignada a una interfaz de comparador no cumple con el contrato del comparador.
module.0.with.language.level.1.depends.on.module.2.with.language.level.3=El módulo {0} con nivel de idioma {1} tiene nivel de idioma {3} Depende del módulo { 2}.
move.0.to.the.beginning=Mover ''{0}'' al principio
move.annotations.to.package.info.file.family.name='package-info.java'로 어노테이션 이동
move.to.front=Avanzar
mutability.modifiable=Modificable
mutability.must.not.modify=수정할 수 없는 입력 매개변수
mutability.unknown=Desconocido
mutability.unmodifiable=No modificable
mutability.unmodifiable.view=Vista no modificable
mutation.signature.problem.invalid.token=Token no válido\: {0}. Se admiten "esto", "param1", "param2", etc.
mutation.signature.problem.parameter.has.immutable.type=El parámetro\# {0} tiene un tipo inmutable ''{1}''
mutation.signature.problem.reference.to.parameter.invalid=Referencia no válida al parámetro\# {0}
mutation.signature.problem.static.method.cannot.mutate.this=el método estático no puede mutar '' esto ''
navigate.to.overridden.methods.title=Método anulado en {0}
non.final.field.code.ref.code.in.immutable.class.loc=@Immutable Campo no final de la clase <code>\#ref</code>\#loc
non.final.guarded.by.field.0.loc=Campo @GuardedBy no final "{0}"\#loc
non.final.guarded.by.field.ref.loc=Campo @GuardedBy no final\#ref\#loc
non.null.type.argument.is.expected=Se requiere un argumento de tipo no nulo.
notification.content.cannot.move.file=''{0}''을(를) ''{1}''(으)로 이동할 수 없습니다. {2}
notification.file.system.issue=파일 작업 문제
nullability.non.null=no nulo
nullability.null=nulo
nullability.nullable=nullable
nullable.stuff.error.overriding.notnull.with.nullable=anulando una colección de elementos no nulos con una colección de elementos que pueden ser nulos
nullable.stuff.error.overriding.nullable.with.notnull=Anular una colección de elementos que pueden ser null a una colección de elementos no nulos
nullable.stuff.problems.overridden.method.parameters.are.not.annotated=No se agregaron anotaciones al parámetro del método anulado
nullable.stuff.problems.overridden.methods.are.not.annotated=Método anulado no anotado
parameter.can.be.null=El parámetro puede ser nulo.
parameter.is.always.not.null=El parámetro siempre es no nulo.
possible.heap.pollution.from.parameterized.vararg.type.loc=Contaminación potencial del montón de tipos de vararg parametrizados\#loc
processing.method.usages=Usos del método de procesamiento...
progress.title.searching.for.overridden.methods=Buscando métodos anulados
provided.type=tipo proporcionado
qualify.0={0} normalizar
qualify.with.0.this=Normalizar con {0} .this
reassign.variable.display.name=재할당된 변수
redundant.block.marker=Marcador de bloque duplicado
remove.annotation=Eliminar anotación
remove.block.marker.comments=Eliminar comentarios de marcadores de bloque
remove.dependency=Eliminar dependencia
remove.left.side.of.assignment=Eliminar asignación izquierda
remove.switch.branch.0=Eliminar la rama del interruptor ''{0}''
remove.switch.label=cambiar eliminar etiqueta
remove.switch.label.0=Eliminar etiqueta del interruptor ''{0}''
replace.0.with=''{0}'''' con ''''\=''
replace.anonymous.class.with.lambda.alternative=Reemplazar clase anónima con reemplazar lambda
replace.get.class.with.class.literal=reemplaza getClass () con .class literal
replace.operator.assignment.with.assignment=Reemplazar asignación de operador con asignación
replace.stringtokenizer.delimiters.parameter.with.unique.symbols=Reemplazar el parámetro delimitador StringTokenizer con símbolos únicos
replace.var.with.explicit.type=Reemplazar '' var '' con un tipo explícito
replace.with.0=Reemplazar con {0}
replace.with.boolean.equals=Boolean.equals로 바꾸기
replace.with.comparator=Reemplazar con comparador
replace.with.constant.value=Reemplazar con valor constante
replace.with.constant.value.title=상수값으로 바꾸기
replace.with.expression.lambda=Reemplazar con expresión lambda
replace.with.lambda=Reemplazar con lambda
replace.with.stream.api.fix=스트림 ''{0}()''이(가) 있는 루프 접기
report.suspicious.but.possibly.correct.method.calls=& Informar llamadas a métodos sospechosos pero posiblemente correctos
report.when.interface.is.not.annotated.with.functional.interface=Informar si la interfaz no está anotada con @FunctionalInterface
required.type=Tipo requerido
scope.package=paquete {0}
searching.for.overriding.methods=Buscar métodos de reemplazo
service.click.to.navigate=탐색하려면 클릭합니다
service.provides=Proporcionar servicio <a href\="\#javaClass/{0}"> {0}</a><br><div style \='' margin-top\: 5px ''><tamaño de fuente \='' 2 ''> Haga clic para explorar</font></div>
service.uses=Servicio utilizado <a href\="\#javaClass/{0}"> {0}</a><br><div style \='' margin-top\: 5px ''><tamaño de fuente \='' 2 ''> Haga clic para explorar</font></div>
special.field.array.length=Longitud de la matriz
special.field.collection.size=Tamaño
special.field.consumed.stream=연결되거나 사용된 스트림
special.field.enum.ordinal=열거형 서수
special.field.instantiable.class=인스턴스화 가능한 클래스
special.field.optional.value=Valor opcional
special.field.string.length=Longitud de la cadena
special.field.unboxed.value=Valor sin caja
statement.lambda.can.be.replaced.with.expression.lambda=Una declaración lambda se puede reemplazar con una expresión lambda
static.inheritrance.fix.replace.progress=Reemplazo del uso de {0}
static.member.guarded.by.instance.0.loc=miembro estático\#loc protegido por la instancia "{0}"
static.member.guarded.by.instance.ref.loc=Miembro estático protegido por instancia\#ref\#loc
subclasses.search.progress.title=Buscando métodos anulados
suggest.package.private.visibility.level.for.classes.in.exported.packages.java.9=Sugerir nivel de visibilidad de paquete privado para miembros de clase dentro de paquetes exportados (Java 9+)
suppress.all.for.class=Suprimir todas las comprobaciones de clase
suppress.for.parameter=Suprimir parámetro
suppress.for.statement.with.comment=Suprimir por declaración con comentario
suppress.inspection.class=Suprimir clase
suppress.inspection.field=Suprimir campo
suppress.inspection.member=Suprimir miembro
suppress.inspection.method=Suprimir método
suppress.inspection.module=Suprimir la declaración del módulo
suspected.module.dependency.problem.descriptor=El módulo ''{0}'' no depende del módulo ''{1}''. Sin embargo, no se verificó ''{1}'' para una dependencia exportada requerida en el alcance ''{2}''.
suspicious.invocation.handler.implementation.display.name=Implementación sospechosa de InvocationHandler
suspicious.invocation.handler.implementation.method.unused.message='' invoke '' no tiene ningún método utilizado. Es posible que '' hashCode '', '' equals '' y '' toString '' no se implementen correctamente.
suspicious.invocation.handler.implementation.null.returned.for.toString.message=Puede devolver un valor nulo cuando se utiliza el método proxy '' toString() ''. No se recomienda.
suspicious.invocation.handler.implementation.null.returned.message=El método de proxy '' {0}()'' puede devolver nulo. Hacerlo puede resultar en una NullPointerException.
suspicious.invocation.handler.implementation.type.mismatch.message=El método de proxy ''{0}()'' puede devolver tipos incompatibles. Elementos necesarios: {1}, elementos obtenidos: {2}
text.raw.ctor.reference.with.type.parameters=Referencia de constructor primitivo con parámetros de tipo explícitos para el constructor
text.shebang.mechanism.in.java.files.not.permitted=No se permite el mecanismo Shebang para archivos .java
text.unused.import.in.template=Declaración import obsoleta (Especificado en la plantilla)
type.constraint.assignability.explanation.definitely.inconvertible={0} es conocido por ser {1} que es definitivamente incompatible con {2}
type.constraint.assignability.explanation.exact={0} ya se sabe que es {1}
type.constraint.assignability.explanation.exact.not.subtype=type {0} es {1} no es exactamente un subtipo de {2}
type.constraint.assignability.explanation.exact.subtype={0} type es exactamente {1} que es un subtipo de {2}
type.constraint.assignability.explanation.not.instance.of=Se sabe que {0} no es {1}
type.constraint.assignability.explanation.not.instance.of.supertype=Se sabe que {0} no es un subtipo {1} de {2}
type.constraint.assignability.explanation.subtype.of.subtype={0} ya se sabe que es un subtipo {1} de {2}
type.mismatch.reason=motivo\: {0}
uast.language.display.name=JVM 언어
unknown.guardedby.reference.0.loc=Desconocido @GuardedBy referencia "{0}"\#loc
unknown.guardedby.reference.ref.loc=Desconocido @GuardedBy reference\#ref\#loc
unnecessary.module.dependency.display.name=Dependencias de módulo innecesarias
unnecessary.module.dependency.problem.descriptor=El módulo fuente ''{0}'' no depende del módulo fuente ''{1}''.
unused.import.display.name=Importación no utilizada
unused.import.statement=Declaración import obsoleta
unused.library.display.name=biblioteca obsoleta
unused.library.problem.descriptor=Biblioteca no utilizada ''{0}''
unused.library.roots.problem.descriptor=Raíz no utilizada {0} en la biblioteca ''{1}''
var.can.be.replaced.with.explicit.type=Puede reemplazar '' var '' con un tipo explícito.
vararg.method.call.with.50.poly.arguments=Llamar a un método vararg con más de 50 argumentos puede ralentizar la compilación y el análisis.
