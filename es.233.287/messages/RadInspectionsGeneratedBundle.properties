Strings.ConstructorOfSmartPointerIsUsedInsteadOfItsMakeFunction=Se utiliza el constructor de puntero inteligente en lugar de la función make
Strings.ConstructorOfASmartPointerBoostStdSharedPtrUniquePtrIsUsedInsteadOfTheCorrespondingMakeSharedMakeUniqueMakeFunctionsAreExceptionSafeAndMoreEfficient=Se utilizaron los constructores de punteros inteligentes (boost/std\:\:shared_ptr/unique_ptr) en lugar de sus homólogos make_shared/make_unique. La función Make es segura para excepciones y es más eficiente.
Strings.CStyleCastIsUsedInsteadOfACCast=Casting estilo C en lugar de casting C++
Strings.CStyleCastIsUsedInsteadOfACCast1=Casting estilo C en lugar de casting C++
Strings.FunctionalStyleCastIsUsedInsteadOfACCast=Se utiliza la conversión de estilo de función en lugar de la conversión de C++
Strings.FunctionalStyleCastIsUsedInsteadOfACCast2=Se utiliza la conversión de estilo de función en lugar de la conversión de C++
Strings.ReinterpretCastIsUsedInsteadOfAStaticCast=se utiliza reinterpret_cast en lugar de static_cast
Strings.ReinterpretCastIsUsedInsteadOfAStaticCast3=se utiliza reinterpret_cast en lugar de static_cast
Strings.NonExplicitConvertingConstructor=Constructor de conversión no explícito
Strings.NonExplicitConvertingConstructor4=Constructor de conversión no explícito
Strings.NonExplicitConversionOperator=Operadores de conversión no explícitos
Strings.NonExplicitConversionOperator5=Operadores de conversión no explícitos
Strings.ResultOfAPostfixOperatorIsDiscarded=Se ignoran los resultados de los operadores postfix.
Strings.ResultOfAPostfixOperatorIsDiscardedItMightBeMoreEfficientToUseAPrefixFormOfTheOperator=El resultado del operador postfix se descarta. Puede que sea más eficaz utilizar un operador con sufijo.
Strings.FunctionReturnsByConstValue=Retorno de función basado en valor constante
Strings.ReturningFromAFunctionByConstValueIsUsuallyNotBeneficialConsiderReturningValuesAsNonConstToTakeAdvantageOfMoveSemantics=Por lo general, no resulta útil regresar de una función con un valor constante. Considere devolver un valor no constante y aproveche la sintaxis de movimiento.
Strings.MemberFunctionCanBeMadeConst=Puedes hacer que las funciones miembro sean constantes.
Strings.MemberFunctionCanBeMadeConst6=Puedes hacer que las funciones miembro sean constantes.
Strings.MemberFunctionCanBeMadeStatic=Puedes hacer que las funciones miembro sean estáticas
Strings.MemberFunctionCanBeMadeStatic7=Puedes hacer que las funciones miembro sean estáticas
Strings.LocalVariableCanBeMadeConst=Puedes hacer que las variables locales sean constantes.
Strings.LocalVariableCanBeMadeConst8=Puedes hacer que las variables locales sean constantes.
Strings.ParameterCanBeMadeConst=Los parámetros se pueden hacer constantes.
Strings.ParameterCanBeMadeConst9=Los parámetros se pueden hacer constantes.
Strings.VariableCanBeMadeConstexpr=Puedes hacer una variable constexpr.
Strings.VariableCanBeMadeConstexpr10=Puedes hacer una variable constexpr.
Strings.ParameterCanBeMadePointerReferenceToConst=Puede hacer que los parámetros sean punteros/referencias a constantes.
Strings.ParameterCanBeMadePointerReferenceToConst11=Los parámetros se pueden convertir en punteros/referencias a constantes.
Strings.PassValueParameterByConstReferenceTitle=Pasar parámetros de valor por referencia constante
Strings.PassValueParameterByConstReferenceDescription=Se pasa por valor un parámetro de un tipo con una alta carga de copia. Puede pasar constantes por referencia en lugar de valor
Strings.ThrowExpressionCanBeReplacedWithARethrowExpression=La expresión de lanzamiento se puede reemplazar con la expresión de volver a lanzar
Strings.ThrowExpressionCanBeReplacedWithARethrowExpression12=La expresión de lanzamiento se puede reemplazar con la expresión de volver a lanzar
Strings.ZeroConstantCanBeReplacedWithNullptr=0 Las constantes se pueden reemplazar por nullptr
Strings.ZeroConstantCanBeReplacedWithNullptr13=0 constantes se pueden reemplazar con nullptr
Strings.CompileTimeConstantExpressionCanBeReplacedByEithertrueOrfalse=Las expresiones constantes en tiempo de compilación se pueden reemplazar por "verdadero" o "falso"
Strings.CompileTimeIntegralConstantExpressionOrNullptrIsConvertedToBoolAndCanBeReplacedBytrueOrfalse=En el momento de la compilación, las expresiones constantes que son números enteros o nullptr se convierten a booleanas y se pueden reemplazar por "verdadero" o "falso".
Strings.IfStatementWithConstantConditionCanBeReplacedByifConstexpr=Cuando las declaraciones que contienen condiciones constantes se pueden reemplazar con 'if constexpr'
Strings.IfStatementWithConstantConditionCanBeReplacedByifConstexpr14=Cuando las declaraciones que contienen condiciones constantes se pueden reemplazar con 'if constexpr'
Strings.IfStdIsConstantEvaluatedCanBeReplacedTitle=Puedes sustituir 'si' por 'si consteval'
Strings.IfStdIsConstantEvaluatedCanBeReplacedDescription=Puedes sustituir 'si' por 'si consteval'
Strings.StdIsConstantEvaluatedWillAlwaysEvaluateToConstantTitle='std\:\:is_constant_evaluated' siempre se evalúa como una constante
Strings.StdIsConstantEvaluatedWillAlwaysEvaluateToConstantDescription='std\:\:is_constant_evaluated' siempre se evalúa como una constante
Strings.ConstevalIfIsAlwaysConstantTitle=consteval si es siempre una constante
Strings.ConstevalIfIsAlwaysConstantDescription=consteval si es siempre una constante
Strings.ClassCanBeMadeFinal=Las clases se pueden hacer definitivas.
Strings.AClassDefinitionCanBeMarkedAsFinalSoItCannotBeInheritedFrom=Puede marcar una definición de clase como final para que no se pueda heredar de la clase.
Strings.StructuredBindingCanBeUsed=Puedes usar enlace estructurado.
Strings.StructuredBindingCanBeUsed15=Puedes usar enlace estructurado.
Strings.TypeTraitCanBeSimplifiedUsingATemplateAliasOrAVariableTemplate=Puede simplificar los atributos de tipo utilizando alias de plantilla o plantillas de variables.
Strings.ATypeTraitCanBeSimplifiedUsingATemplateAliasOrAVariableTemplate=Puede simplificar los atributos de tipo utilizando alias de plantilla o plantillas de variables.
Strings.AlgorithmAcceptingAnIteratorAndACountCanBeUsed=Puedes escribir un algoritmo que requiera un iterador y un conteo.
Strings.AStandardAlgorithmAcceptingRangeIteratorsIsUsedInsteadOfTheVariantAcceptingAnIteratorAndACount=Se utilizó el algoritmo estándar que toma un iterador de rango en lugar de la variante que toma varios iteradores.
Strings.AlgorithmOperatingOnRangesCanBeUsed=Puedes utilizar algoritmos que operan en rangos.
Strings.AlgorithmAcceptingIteratorsIsUsedInsteadOfTheCorrespondingAlgorithmFromStdRanges=Se utilizó un algoritmo que toma un iterador distinto del algoritmo correspondiente en std\:\:ranges.
Strings.StdViewsKeysValuesCanBeUsed=Puede utilizar std\:\:views\:\:keys/values
Strings.ForExampleWhenIteratingOnKeyValuePairsStdViewsKeysAllowsToIgnoreTheValues=Por ejemplo, al iterar sobre pares clave-valor, puede usar std\:\:views\:\:keys para ignorar los valores.
Strings.StdSizeCanBeUsed=Puedes usar std\:\:tamaño
Strings.StdSizeIsTypeSafeAlternativeToCIdiomForArraySizeCalculation=Al calcular el tamaño de una matriz, std\:\:size es una alternativa segura al lenguaje C.
Strings.ForLoopCanBeReplacedWithWhileLoop=Puede cambiar el bucle for a un bucle while.
Strings.ForLoopWithoutInitStatementAndUpdateExpressionIsEquivalentToWhileLoop=Un bucle for sin una declaración init y una expresión de actualización es lo mismo que un bucle while.
Strings.DeclarationAndAssignmentCanBeJoined=La declaración y la cesión se pueden combinar
Strings.DeclarationOfAVariableAndAssignmentToItCanBeJoined=La declaración de variables y sus asignaciones se puede realizar por separado.
Strings.StructuredBindingCanBeUsedInsteadOfTie=En lugar de atar(..) puedes usar encuadernación estructurada
Strings.ZeroInitializationCanBeUsedInsteadOfMemset=Puedes usar inicialización cero en lugar de memset
Strings.ZeroInitializationCanBeUsedInsteadOfMemset16=Puedes usar inicialización cero en lugar de memset
Strings.containsMemberFunctionCanBeUsed=La función miembro 'contiene' se puede utilizar
Strings.containsMemberFunctionCanBeUsed17=La función miembro 'contiene' se puede utilizar
Strings.stdErasestdEraseIfCanBeUsedInsteadOfTheRemoveEraseIdiom='std\:\:erase'/'std\:\:erase_if' se puede utilizar en lugar del modismo remove-erase
Strings.stdErasestdEraseIfCanBeUsedInsteadOfTheRemoveEraseIdiom18='std\:\:erase'/'std\:\:erase_if' se puede utilizar en lugar del modismo remove-erase
Strings.LambdaCanBeRewrittenToUseExplicitTemplateParameters=Puede reescribir su lambda para usar parámetros de plantilla explícitos:
Strings.LambdaCanBeRewrittenToUseExplicitTemplateParameters19=Puede reescribir su lambda para usar parámetros de plantilla explícitos:
Strings.VariableCanBeMovedToInnerScope=Puede mover variables al alcance interno
Strings.DontIntroduceAVariableBeforeYouNeedToUseIt=No insertes variables que no necesitas
Strings.VariableCanBeMovedToInitStatement=Puede mover la variable a la declaración de inicio
Strings.NamespaceDefinitionContainingSingleClassSpecialization=Definición de espacio de nombres con especialización de clase única
Strings.DontIntroduceANamespaceDefinitionOnlyForClassSpecializationSpecializationCanBeDefinedUsingQualifiedClassName=No inserte definiciones de espacios de nombres únicamente por motivos de especialización de clases. Las especializaciones se pueden definir utilizando nombres de clase completos.
Strings.NonInlineFunctionDefinitionInAHeaderFile=Definiciones de funciones no integradas en archivos de encabezado
Strings.AFunctionDefinitionInAHeaderFileThatWillCauseMultipleDefinitionLinkageError=Hay múltiples definiciones de funciones dentro del archivo de encabezado que causarán un error de enlace de definición
Strings.NonInlineVariableDefinitionInAHeaderFile=Definiciones de variables no integradas en archivos de encabezado
Strings.AVariableDefinitionInAHeaderFileThatWillCauseMultipleDefinitionLinkageError=Hay definiciones de variables dentro del archivo de encabezado que causarán múltiples errores de enlace de definición.
Strings.FunctionIsNotImplemented=Función no implementada
Strings.AFunctionIsNotImplemented=La función no está implementada
Strings.PrivateSpecialMemberFunctionIsNotImplemented=Las funciones especiales de miembros privados no están implementadas.
Strings.APrivateSpecialMemberFunctionShouldBeDefinedOrDeleted=Las funciones de miembros especiales privados deben definirse o eliminarse.
Strings.NonVirtualClassMemberFunctionHiddenInADerivedClass=Funciones ocultas de miembros de clases no virtuales en clases derivadas
Strings.NonVirtualClassMemberFunctionIsHiddenInADerivedClass=Las funciones de miembros de clases no virtuales están ocultas en clases derivadas
Strings.ClassMemberFunctionHidingANonVirtualFunctionFromABaseClass=Funciones miembro de clase que ocultan funciones no virtuales de la clase base
Strings.ClassMemberFunctionHidesANonVirtualFunctionFromABaseClass=Las funciones de los miembros de la clase ocultan funciones no virtuales de la clase base
Strings.PolymorphicClassWithNonVirtualPublicDestructor=Clases polimórficas con destructores virtuales y no públicos.
Strings.APolymorphicClassWithANonVirtualPublicDestructor=Clases polimórficas con destructores públicos no virtuales.
Strings.ClassIsAbstractButNotExplicitlyDeclaredAsSuch=Esta clase es abstracta, pero no se declara explícitamente como tal.
Strings.TheClassIsAbstractButNotExplicitlyDeclaredAsSuch=La clase es abstracta, pero no declarada explícitamente.
Strings.PossiblyErroneousIncompleteSwitchStatement=Declaración de cambio incompleta con posibles errores
Strings.TheSwitchStatementDoesntCoverTheWholeRangeOfTheEnumerationUsed=La declaración de cambio no cubre todos los rangos de la enumeración utilizada.
Strings.DefaultCaseIsNotHandledInASwitchStatement=Caso predeterminado no manejado en la declaración de cambio
Strings.DefaultCaseIsNotHandledInASwitchStatement20=Caso predeterminado no manejado en la declaración de cambio
Strings.PossiblyErroneousEmptyStatement=Sintaxis vacía que puede contener errores
Strings.PossiblyErroneousEmptyStatementUsedInAControlStatement=Sintaxis vacía y potencialmente propensa a errores utilizada en declaraciones de control
Strings.PossiblyErroneousExpressionWithoutSideEffects=Posibles expresiones de error (sin efectos secundarios)
Strings.PossiblyErroneousExpressionWithoutSideEffects21=Posibles expresiones de error (sin efectos secundarios)
Strings.ResultOfNodiscardFunctionIsNotUsed=El resultado de la función nodiscard no se utiliza
Strings.ResultOfNodiscardFunctionIsNotUsed22=El resultado de la función nodiscard no se utiliza
Strings.FunctionResultShouldBeUsedTitle=Se debe utilizar el resultado de la función.
Strings.FunctionResultShouldBeUsedDescription=La función devuelve un valor del tipo que debe procesarse en la ubicación de la llamada.
Strings.MayBeMissingKeywordthrow=Es posible que le falte la palabra clave "lanzar"
Strings.ObjectOfExceptionTypeIsCreatedButIsNotThrown=Se crea un objeto de tipo de excepción pero no se lanza.
Strings.DependentTypeWithouttypenameKeyword=Tipo dependiente sin palabra clave 'typename'
Strings.DependentTypeWithouttypenameKeyword23=Tipo dependiente sin palabra clave 'typename'
Strings.DependentTemplateWithouttemplateKeyword=Plantilla dependiente sin palabra clave 'plantilla'
Strings.DependentTemplateWithouttemplateKeyword24=Plantilla dependiente sin palabra clave 'plantilla'
Strings.ImplicitDefaultConstructorIsNotAvailable=No se puede utilizar el constructor predeterminado implícito
Strings.ImplicitDefaultConstructorIsNotAvailableBecauseABaseClassOrAClassMemberDoesNotHaveAnAccessibleDefaultConstructor=No hay ningún constructor predeterminado accesible para la clase base o los miembros de la clase, por lo que no hay disponible un constructor predeterminado implícito.
Strings.ClassShouldHaveAUserDefinedConstructorBecauseOfAnUninitializedDataMember=Los miembros de datos no inicializados requieren un constructor personalizado en la clase.
Strings.ClassShouldHaveAUserDefinedConstructorBecauseOfAnUninitializedDataMember25=Los miembros de datos no inicializados requieren un constructor personalizado en la clase.
Strings.NonStaticDataMemberIsUninitialized=Miembro de datos no estáticos no inicializado
Strings.NonStaticDataMemberIsUninitialized26=Miembro de datos no estáticos no inicializado
Strings.PossiblyUnintendedIncompatibleReferenceTypeInRangeDeclaration=Tipos de referencia incompatibles potencialmente no deseados en la declaración de alcance
Strings.UsingAnIncompatibleReferenceTypeInTheRangeDeclarationIsLikelyToCauseUnwantedObjectCopying=El uso de tipos inferidos incompatibles en declaraciones de alcance puede provocar copias no deseadas de objetos.
Strings.ExpressionWhichEvaluatesToZeroIsUsedAsANullPointerConstant=Las expresiones que se evalúan como cero se utilizan como constantes de puntero nulo.
Strings.ExpressionWhichEvaluatesToZeroIsUsedAsANullPointerConstant27=Las expresiones que se evalúan como cero se utilizan como constantes de puntero nulo.
Strings.PossiblyUnintendedObjectSlicing=Posible corte de objetos no deseado
Strings.PossiblyUnintendedObjectSlicing28=Posible corte de objetos no deseado
Strings.PossiblyUninitializedClassMember=Posibles miembros de la clase no inicializados
Strings.ClassConstructorDoesntInitializeAFieldExplicitlyOrImplicitly=El constructor de clases no inicializa campos explícita o implícitamente
Strings.DeclaratorDisambiguatedAsAFunctionDeclaration=Como declaración de función, el declarador está separado.
Strings.DeclaratorIsDisambiguatedAsAFunctionDeclarationMakeSureAVariableDefinitionIsNotIntendedInstead=El declarador se separa en una declaración de función. Asegúrese de que la definición de su variable no sea la que pretendía.
Strings.DeclarationOfANonOverridingVirtualFunctionInAFinalOrSealedClass=Declaración de una función virtual que no se anula en una clase final o sellada
Strings.ANonOverridingVirtualFunctionInAFinalOrSealedClassCannotBeOverriddenSoThevirtualSpecifierIsRedundant=El especificador 'virtual' es innecesario porque las funciones virtuales no anuladas dentro de una clase final o sellada no se pueden redefinir.
Strings.MethodMustBePublicAndVirtualToImplementACCLIInterfaceMember=La implementación de un miembro de interfaz C++/CLI requiere que el método sea público y virtual.
Strings.MethodMustBePublicAndVirtualToImplementACCLIInterfaceMember29=Para implementar un miembro de la interfaz C++/CLI, el método debe ser público y virtual.
Strings.DeclarationSpecifierWithNoDeclarators=Especificador de declaración sin declarador
Strings.ADeclarationSpecifierIsIgnoredWhenThereAreNoDeclarators=Los especificadores de declaración se ignoran si no hay un declarador.
Strings.DeclarationDoesNotDeclareAnything=declaración no declara nada
Strings.ADeclarationDoesNotDeclareAnything=declaración no declara nada
Strings.HidingLocalDeclaration=Ocultar declaraciones locales
Strings.ALocalDeclarationHidesAnotherLocalDeclaration=Las declaraciones locales eclipsan otras declaraciones locales
Strings.HidingAnUncapturedLocalDeclaration=Ocultar variables locales que no se capturan
Strings.ALocalDeclarationInsideALambdaHidesAnUncapturedLocalDeclaration=Las declaraciones locales dentro de lambda oscurecen las declaraciones locales no capturadas
Strings.MismatchedClassTags=Etiquetas de clase no coincidentes
Strings.TagsOfTheDeclaredClassDoNotMatchPreviousDeclarations=Las etiquetas de la clase declarada no coinciden con la declaración anterior
Strings.ResultOfAssignmentIsUsedAsCondition=El resultado de la asignación se utiliza como condición.
Strings.ImplicitIntegerToPointerConversion=Conversión implícita de número entero a puntero
Strings.ImplicitIntegerToPointerConversion30=Conversión implícita de número entero a puntero
Strings.ImplicitPointerToIntegerConversion=Conversión implícita de puntero a entero
Strings.ImplicitPointerToIntegerConversion31=Conversión implícita de puntero a entero
Strings.ImplicitConversionToIncompatiblePointerType=Conversión implícita a tipo de puntero incompatible
Strings.ImplicitConversionToIncompatiblePointerType32=Conversión implícita a tipo de puntero incompatible
Strings.ImplicitConversionToLessQualifiedPointerType=Conversión implícita al tipo de puntero con pérdida de controlador
Strings.ImplicitConversionToLessQualifiedPointerType33=Conversión implícita al tipo de puntero con pérdida de controlador
Strings.StringLiteralToCharPointerConversion=Conversión de literal de cadena a puntero de carácter
Strings.StringLiteralToCharPointerConversion34=Conversión de literal de cadena a puntero de carácter
Strings.NonSafeResourceAcquisition=Adquisición insegura de recursos
Strings.DetectsLeakProneResourceAcquisitionFreeingConstructs=Detectar construcciones de adquisición/liberación de recursos propensas a fugas
Strings.CallToAVirtualFunctionInsideAConstructorDestructorIsResolvedAtCompileTime=Las llamadas a funciones virtuales dentro de constructores/destructores se resuelven en tiempo de compilación
Strings.CallToAVirtualFunctionInsideAConstructorDestructorWillResultInAPureVirtualFunctionCall=Llamar a una función virtual dentro de un constructor/destructor da como resultado una llamada de función virtual pura.
Strings.CallsToPureVirtualFunctionsInsideConstructorsAndDestructorsAreARuntimeError=Llamar a funciones virtuales puras dentro de constructores y destructores genera un error de tiempo de ejecución
Strings.BackslashAndNewlineAreSeparatedBySpace=Las barras invertidas y las nuevas líneas están separadas por espacios.
Strings.BackslashIsNotALineContinuatorBecauseThereIsASpaceBetweenItAndTheEndOfTheLine=Hay un espacio entre la barra invertida y el final de la línea, por lo que la barra invertida no continúa la línea.
Strings.InvalidPrintfFormatSpecifier=Especificador de formato printf no válido
Strings.FormatStringContainsAnInvalidPrintfFormatSpecifier=La cadena de formato contiene un especificador de formato printf no válido
Strings.PossiblyInvalidPrintfFormatSpecifier=Especificador de formato printf potencialmente no válido
Strings.FormatStringContainsAPotentialError=La cadena de formato contiene un posible error
Strings.NotEnoughArgumentsInACallToPrintf=La llamada printf carece de argumentos.
Strings.NotEnoughArgumentsInACallToPrintfSomeFormatCodesDoNotHaveAMatchingArgument=La llamada printf no tiene suficientes argumentos. Falta un argumento coincidente para algunas directivas de formato.
Strings.TooManyArgumentsInACallToPrintf=Demasiados argumentos en la llamada printf
Strings.TooManyArgumentsInACallToPrintfSomeOfTheArgumentsAreNotUsed=Hay demasiados argumentos en la llamada printf. Algunos argumentos no se utilizan.
Strings.BadFormatCodeForBoostFormat=Directiva de formato no válida en formato boost\:\:
Strings.AFormatStringOfBoostFormatContainsAnErroneousFormatCode=La cadena de formato en boost\:\:format contiene una directiva de formato no válida
Strings.LegacyFormatCodeForBoostFormat=boost\:\:formatear mi antigua directiva de formato
Strings.AFormatStringOfBoostFormatContainsALegacyPrintfLikeCodeTypeSpecifierIsNotTakenIntoAccount=La cadena de formato boost\:\:format contiene código existente similar a printf. Los especificadores de tipo no se consideran
Strings.MixedSerialAndPositionalArgumentsForBoostFormat=Argumentos posicionales y no posicionales en la misma llamada de formato boost\:\:
Strings.AnArgumentOfBoostFormatShouldContainEitherPositionalNNOrSerialsArgumentsNotBoth=Los argumentos para impulsar\:\:formato deben contener solo uno de los siguientes argumentos: argumentos posicionales (%N%, %|N$...|) o seriales (%|...|, %s).
Strings.NotEnoughArgumentsInACallToBoostFormat=La llamada al formato boost\:\:carece de argumentos
Strings.NotEnoughArgumentsInACallToBoostFormat36=La llamada al formato boost\:\:carece de argumentos
Strings.TooManyArgumentsInACallToBoostFormat=La llamada al formato boost\:\:tiene demasiados argumentos
Strings.TooManyArgumentsInACallToBoostFormatSomeOfTheArgumentsAreNotUsed=Demasiados argumentos en la llamada para impulsar\:\:formato. Algunos argumentos no se utilizan.
Strings.EntityIsDeprecated=La entidad no se utiliza
Strings.EntityIsDeprecated37=La entidad no se utiliza
Strings.MissingIncludeGuard=falta incluir guardia
Strings.IncludeGuardIsNotFoundAtTheBeginningOfAHeaderFile=Falta incluir guardia al principio del archivo de encabezado
Strings.SyntaxErrorInDoxygenComment=Error de sintaxis en el comentario de doxygen
Strings.SyntaxErrorInADoxygenComment=Error de sintaxis en el comentario de doxygen
Strings.UnresolvedReferenceInDoxygenComment=Referencia no resuelta en el comentario de doxygen
Strings.UnresolvedReferenceInADoxygenComment=Referencia no resuelta en el comentario de doxygen
Strings.MissingFunctionParameterDescriptionInADocumentationComment=Falta la descripción del parámetro de función en los comentarios de la documentación
Strings.MissingFunctionParameterDescriptionInADocumentationComment38=Falta la descripción del parámetro de función en los comentarios de la documentación
Strings.DeletingAVoidPointer=Eliminar un puntero vacío
Strings.DeletingAVoidPointerIsUndefinedBehavior=Eliminar un puntero vacío es un comportamiento indefinido
Strings.IncrementingExpressionOfTypeBool=Expresión incremental de tipo bool
Strings.IncrementingExpressionOfTypeBoolIsDeprecatedInCAndRemovedInC=Las expresiones incrementales de tipo bool están en desuso desde C++ 11 y se eliminaron en C++ 17.
Strings.DeprecatedregisterStorageClassSpecifier=Especificador de clase de almacenamiento 'registro' obsoleto
Strings.TheregisterStorageClassSpecifierIsDeprecatedInCAndRemovedInC=El especificador de clase de almacenamiento 'regitor' está en desuso desde C++11 y se eliminó en C++17.
Strings.BinaryOperatorActsOnIdenticalOperands=Los operadores binarios operan con operandos coincidentes.
Strings.BinaryOperatorActsOnIdenticalOperands39=Los operadores binarios operan con operandos coincidentes.
Strings.BinaryOperatorActsOnEqualOperands=Los operadores binarios operan con operandos iguales
Strings.BinaryOperatorActsOnEqualOperands40=Los operadores binarios operan con operandos iguales
Strings.OverrideFunctionRedefinesADefaultParameterArgument=La función de anulación anula los argumentos de los parámetros predeterminados
Strings.AnOverrideFunctionRedefinesADefaultParameterArgumentPreviouslyDefinedInABaseFunction=Una función de anulación anula los argumentos de parámetros predeterminados definidos en la función base.
Strings.UnnamedNamespaceInAHeaderFile=Espacio de nombres sin nombre en el archivo de encabezado
Strings.UnnamedNamespacesShouldNotBeUsedInHeaderFiles=Los espacios de nombres sin nombre no deben usarse en archivos de encabezado
Strings.ParameterNamesDoNotMatch=Los nombres de los parámetros no coinciden
Strings.ParameterNamesDifferInDifferentDeclarationsOfTheSameFunction=Los nombres de los parámetros se usan de manera diferente en diferentes declaraciones de la misma función.
Strings.DefaultedSpecialMemberFunctionIsImplicitlyDeleted=Las funciones de miembros especiales establecidas como predeterminadas se eliminan implícitamente
Strings.ExplicitlyDefaultedSpecialMemberFunctionIsImplicitlyDeleted=Las funciones miembro especiales que se establecen explícitamente en valores predeterminados se eliminan implícitamente.
Strings.NodiscardCannotBeAppliedToFunctionsWithoutAReturnValue=[[nodiscard]] no se puede aplicar a una función sin valor de retorno
Strings.TheNodiscardAttributeCannotBeAppliedToFunctionsWithoutAReturnValue=La propiedad [[nodiscard]] no se puede aplicar a una función que no tiene valor de retorno
Strings.CppRedundantComplexityInComparison=Las expresiones se pueden simplificar.
Strings.AbstractFinalClass=clase final abstracta
Strings.AnAbstractFinalClassIsMarkedAsfinalOrsealed=La clase final del resumen está marcada como 'final' o 'sellada'
Strings.SpecialFunctionWithoutNoexceptSpecification=Características especiales (sin excepciones a las especificaciones)
Strings.SpecialFunctionDoesntHaveAnyNoexceptSpecification=La función especial no tiene ninguna especificación excepto
Strings.ComparisonOfUnsignedExpressionWith=Comparación de expresiones sin signo con ceros.
Strings.ComparisonOfUnsignedExpressionWith41=Comparación de expresiones sin signo con ceros.
Strings.MultiCharacterLiteralTitle=El literal de carácter contiene varios caracteres.
Strings.MultiCharacterLiteralDescription=El literal de carácter contiene varios caracteres.
Strings.MultiCharacterWideLiteralTitle=El literal de caracteres anchos contiene varios caracteres.
Strings.MultiCharacterWideLiteralDescription=El literal de caracteres anchos contiene varios caracteres.
Strings.RedundantQualifier=Calificador\n innecesario
Strings.QualifierIsRedundantAndCanBeDeleted=Los calificadores son innecesarios y pueden eliminarse.
Strings.AccessSpecifierDoesNotChangeAccessibilityLevel=El especificador de acceso no cambia el nivel de accesibilidad
Strings.AnAccessSpecifierDoesNotChangeAccessibilityLevelAndIsRedundant=Los especificadores de acceso no cambian los niveles de accesibilidad y son innecesarios.
Strings.AccessSpecifierDoesNotAffectAnyDeclaration=Los especificadores de acceso no tienen efecto en las declaraciones.
Strings.AnAccessSpecifierDoesNotAffectAnyDeclarationAndIsRedundant=Los especificadores de acceso no tienen efecto en las declaraciones y son innecesarios.
Strings.RedundanttypenameKeyword=Palabra clave duplicada 'nombre de tipo'
Strings.RedundanttypenameKeyword42=Palabra clave duplicada 'nombre de tipo'
Strings.RedundanttemplateKeyword=Palabra clave 'plantilla' duplicada
Strings.RedundanttemplateKeyword43=Palabra clave 'plantilla' duplicada
Strings.RedundantelseKeyword=Duplicar la palabra clave 'otra'
Strings.RedundantelseKeyword45=Duplicar palabra clave 'otra'
Strings.RedundantelseKeywordInsideCompoundStatement=Duplicar la palabra clave 'else' dentro de una frase compuesta
Strings.RedundantelseKeywordInsideCompoundStatement46=Duplicar la palabra clave 'else' dentro de una frase compuesta
Strings.RedundantControlFlowJumpStatement=Sintaxis de movimiento de flujo de control duplicado
Strings.RedundantControlFlowJumpStatement47=Sintaxis de movimiento de flujo de control duplicado
Strings.RedundantEmptyStatement=declaración duplicada vacía
Strings.RedundantEmptyStatement48=declaración duplicada vacía
Strings.RedundantEmptyDeclaration=declaración duplicada vacía
Strings.RedundantEmptyDeclaration49=declaración duplicada vacía
Strings.RedundantParentheses=paréntesis innecesarios
Strings.ParenthesesDontChangeOrderOfOperationsAndCanBeDeleted=Los paréntesis no cambian el orden de las operaciones y se pueden eliminar.
Strings.RedundantParameterListInLambdaDeclarator=Lista de parámetros innecesarios en el declarador lambda
Strings.EmptyParameterListInLambdaDeclaratorCanBeDeleted=Se pueden eliminar las listas de parámetros vacías en los declaradores lambda
Strings.RedundantCastExpression=Expresión de reparto innecesaria
Strings.CastIsRedundantAndCanBeDeleted=El casting es innecesario y se puede eliminar.
Strings.GuardedHeaderHasAlreadyBeenIncluded=Protector de cabecera ya incluido.
Strings.GuardedHeaderHasAlreadyBeenIncluded50=Protector de cabecera ya incluido.
Strings.TemplateArgumentsCanBeDeduced=Se pueden inferir argumentos de plantilla
Strings.RedundantTemplateArguments=Argumentos de plantilla duplicados
Strings.RedundantstaticSpecifierOnAnAnonymousNamespaceMember=Especificador 'estático' redundante para miembros anónimos del espacio de nombres
Strings.RedundantstaticSpecifierOnAnAnonymousNamespaceMember52=Especificador 'estático' redundante para miembros anónimos del espacio de nombres
Strings.RedundantstaticSpecifierOnAMemberAllocationDeallocationFunction=Especificador 'estático' redundante para funciones de asignación/desasignación de miembros
Strings.ThestaticSpecifierIsOptionalForMemberAllocationDeallocationFunctions=El especificador 'estático' es opcional en las funciones de asignación/desasignación de miembros.
Strings.RedundantStaticSpecifierOnThreadLocalLocalVariableTitle=Especificador 'estático' innecesario utilizado en la variable local 'thread_local'
Strings.RedundantStaticSpecifierOnThreadLocalLocalVariableDescription=Especificador 'estático' innecesario utilizado en la variable local 'thread_local'
Strings.RedundantBaseClassAccessSpecifier=Especificador de acceso de clase base duplicado
Strings.RedundantBaseClassAccessSpecifier53=Especificador de acceso de clase base duplicado
Strings.RedundantinlineSpecifier=Especificador 'en línea' duplicado
Strings.TheinlineSpecifierOnAFunctionDefinitionIsRedundant=El especificador 'en línea' es innecesario en las definiciones de funciones
Strings.RedundantconstSpecifier=Especificador 'const' duplicado
Strings.TheconstSpecifierOnAVariableDefinitionIsRedundant=El especificador 'const' no es necesario en declaraciones de variables.
Strings.RedundantArgumentInConditionalExpression=Argumentos duplicados en expresiones condicionales.
Strings.RedundantArgumentInConditionalExpression54=Argumentos duplicados en expresiones condicionales.
Strings.RedundantVoidArgumentList=Lista duplicada de argumentos no válidos
Strings.RedundantVoidArgumentList55=Lista duplicada de argumentos no válidos
Strings.RedundantMemberInitializerInConstructorInitializationList=Inicializadores de miembros duplicados en la lista de inicialización del constructor
Strings.RedundantMemberInitializerInConstructorInitializationList56=Inicializadores de miembros duplicados en la lista de inicialización del constructor
Strings.RedundantBaseClassInitializerTitle=Inicializador de clase base innecesario
Strings.RedundantBaseClassInitializerDescription=Hay un inicializador de clase base innecesario en la lista de inicializadores de miembros.
Strings.ConstQualifiedParameterInAFunctionDeclaration=parámetros normalizados constantes en declaraciones de funciones
Strings.ConstQualificationOfParametersHasAnEffectOnlyInFunctionDefinitions=La calificación constante de los parámetros sólo tiene efecto en las definiciones de funciones.
Strings.VolatileQualifiedParameterInAFunctionDeclaration=parámetro de normalización volátil en la declaración de función
Strings.VolatileQualificationOfParametersHasAnEffectOnlyInFunctionDefinitions=La calificación volátil de un parámetro tiene efecto sólo en las definiciones de funciones.
Strings.FinalFunctionInAFinalClass=función final en la clase final
Strings.RedundantfinalSpecifierOnAFunctionInAFinalClass=Especificador 'final' innecesario en funciones dentro de clases finales
Strings.FinalNonOverridingVirtualFunction=función virtual final sin anular
Strings.AVirtualFunctionIsMarkedfinalAndDoesNotOverrideABaseFunction=La función virtual está marcada como "final" y no anula la función base.
Strings.RedundantElaboratedTypeSpecifier=Especificador de tipo detallado innecesario
Strings.ElaboratedTypeSpecifierIsRedundantAndCanBeDeleted=El especificador de tipo detallado no es necesario y puede eliminarse
Strings.CppRedundantDereferencingAndTakingAddressTitle=Eliminación de referencias y adquisición de direcciones innecesarias
Strings.CppRedundantDereferencingAndTakingAddressDescription=Eliminación de referencias y adquisición de direcciones innecesarias
Strings.CppRedundantConditionalExpressionTitle=Expresión condicional duplicada
Strings.CppRedundantConditionalExpressionDescription=Expresión condicional duplicada
Strings.CppConditionalExpressionCanBeSimplifiedTitle=Las expresiones condicionales se pueden simplificar.
Strings.CppConditionalExpressionCanBeSimplifiedDescription=Las expresiones condicionales se pueden simplificar.
Strings.RedundantExportKeywordMessage=La palabra clave 'exportar' es innecesaria ya que se adjunta una declaración de exportación.
Strings.UserDefinedLiteralSuffixesMustStartWithAnUnderscore=Los sufijos literales personalizados deben comenzar con un guión bajo.
Strings.UserDefinedLiteralSuffixesMustStartWithAnUnderscoreTheSuffixesThatDoNotBeginWithAnUnderscoreAreReservedForTheLiteralOperatorsProvidedByTheStandardLibrary=Los sufijos literales personalizados deben comenzar con un guión bajo. Los sufijos que no comienzan con un guión bajo solo se pueden usar con operadores literales proporcionados por la biblioteca estándar.
Strings.UseOfAnIncompleteTypeInsideATemplate=Usar el tipo Incompleto dentro de una plantilla
Strings.AnIncompleteTypeIsUsedInsideATemplateDeclarationOrDefinition=Tipo incompleto utilizado en la declaración o definición de plantilla
Strings.RedeclarationOfATemplateParameterFromAnOuterScope=Redeclarar parámetros de plantilla en el ámbito externo
Strings.ATemplateParameterFromAnOuterScopeIsShadowedByADeclarationWithTheSameName=Los parámetros de plantilla en el ámbito externo están ocultos por declaraciones del mismo nombre
Strings.ReferenceClassMemberWithmutableSpecifier=Miembro de clase de referencia con especificador 'mutable'
Strings.ReferenceClassMembersCannotHavemutableSpecifier=Los miembros de la clase de referencia no pueden tener el especificador 'mutable'
Strings.DefaultInitializationOfAConstQualifiedObjectOfATypeWithoutAUserProvidedDefaultConstructor=Por defecto inicializa un objeto calificado de forma constante de un tipo sin un constructor predeterminado proporcionado por el usuario.
Strings.DefaultInitializationOfAConstQualifiedObjectOfATypeWithoutAUserProvidedDefaultConstructor3=Por defecto inicializa un objeto calificado de forma constante de un tipo sin un constructor predeterminado proporcionado por el usuario.
Strings.ExplicitSpecializationInNonNamespaceScope=Especialización explícita en un ámbito que no es de espacio de nombres
Strings.ExplicitSpecializationsOfATemplateInNonNamespaceScope=Especialización explícita de plantillas en ámbitos que no son espacios de nombres
Strings.UnionMemberOfReferenceType=Miembros sindicales de tipos de referencia.
Strings.UnionsCannotContainNonStaticDataMembersOfReferenceTypes=Una unión no puede contener miembros de datos que no sean estáticos y sean de tipo inferido.
Strings.UninitializedDependentBaseClass=clase base dependiente no inicializada
Strings.PossiblyUninitializedDependentBaseClass=Clase base dependiente potencialmente no inicializada
Strings.PrecompiledHeaderIsNotIncluded=No se incluyen encabezados precompilados
Strings.PrecompiledHeaderMustBeIncludedAtTheTopOfSourceFile=Los encabezados precompilados deben incluirse en la parte superior del archivo fuente.
Strings.PrecompiledHeaderIsNotFound=Encabezado precompilado no encontrado
Strings.NoCorrespondingFileWithThePrecompiledHeaderPropertySetToCreateYcIsFound=No se encontró ningún archivo correspondiente con la propiedad 'Encabezados precompilados' establecida en 'Generar' (/Yc)
Strings.CannotResolveARequiredCoroutineFunction=No se puede resolver la función de rutina requerida
Strings.ACoroutineRelatedFunctionWhichIsRequiredByTheCStandardCannotBeResolved=Las funciones relacionadas con rutinas requeridas en C++ 20 no se pueden resolver
Strings.AwaiterTypeIsNotAClass=El tipo de camarero no es una clase.
Strings.TheAwaiterTypeMustBeAAClassAccordingToTheCStandard=Según el estándar C ++ 20, el tipo de camarero debe ser una clase
Strings.TheoutParameterMustBeAssigned=Se debe asignar el parámetro 'out'.
Strings.InHLSLoutParametersMustBeAssignedBeforeExitingTheFunction=En HLSL, el parámetro 'out' debe asignarse antes de salir de la función.
Strings.WarningDirectiveTitle=\#directiva de advertencia
Strings.WarningDirectiveDescription=\#advertencia directiva de preprocesador
Strings.StaticAssertFailedTitle=static_assert falló
Strings.StaticAssertFailedDescription=static_assert falló
Strings.DeclaratorIsNeverUsed=Declarador no utilizado en absoluto
Strings.ADeclaratorIsNeverUsed=El declarante no se utiliza en absoluto.
Strings.TypeAliasIsNeverUsed=Los alias de tipo no se utilizan en absoluto
Strings.ATypeAliasIsNeverUsed=Los alias de tipo no se utilizan en absoluto
Strings.ConceptIsNeverUsed=El concepto no se utiliza en absoluto.
Strings.ClassIsNeverUsed=La clase no se utiliza en absoluto.
Strings.AClassIsNeverUsed=La clase no se utiliza en absoluto.
Strings.EnumeratorIsNeverUsed=Emulador no usado en absoluto
Strings.AEnumeratorIsNeverUsed=El enumerador no se utiliza en absoluto
Strings.LambdaCaptureIsNeverUsed=La captura lambda no se utiliza en absoluto
Strings.ALambdaCaptureIsNeverUsed=La captura lambda no se utiliza en absoluto
Strings.LocalVariableIsNeverUsedButMayHaveSideEffectsInItsDestructor=Las variables locales nunca se utilizan, pero pueden afectar a sus destructores.
Strings.LocalVariableIsNeverUsedButMayHaveSideEffectsInItsDestructor4=Las variables locales nunca se utilizan, pero pueden afectar a sus destructores.
Strings.ParameterIsNeverUsed=No se utilizan parámetros en absoluto.
Strings.FunctionParameterIsNeverUsed=No se utilizan parámetros de función en absoluto.
Strings.TemplateParameterIsNeverUsedTitle=Los parámetros de la plantilla nunca se utilizan
Strings.TemplateParameterIsNeverUsedDescription=Los parámetros de la plantilla nunca se utilizan
Strings.DeclaratorIsOnlyAssignedButNeverAccessed=El declarante solo se asigna y no se accede a él en absoluto
Strings.ADeclaratorIsOnlyAssignedButNeverAccessed=El declarante solo se asigna y no se accede a él en absoluto
Strings.DeclaratorIsUsedOnlyInUnevaluatedContext=El declarante solo se usa en un contexto no evaluado
Strings.ADeclaratorIsUsedOnlyInUnevaluatedContext=Solo se usa en contextos donde el declarador no se evalúa.
Strings.LocalVariableMightNotBeInitialized=Es posible que la variable local no se inicialice
Strings.ALocalVariableMightNotBeInitialized=Es posible que la variable local no se inicialice
Strings.ObjectMemberMightNotBeInitialized=Es posible que los miembros del objeto no se inicialicen
Strings.AnObjectMemberMightNotBeInitialized=Es posible que los miembros del objeto no se inicialicen
Strings.SomeObjectMembersMightNotBeInitialized=Es posible que algunos miembros del objeto no se inicialicen
Strings.LocalVariableUsedWithoutBeingInitialized=Variable local utilizada sin inicialización
Strings.LocalVariableUsedWithoutBeingInitialized5=Variable local utilizada sin inicialización
Strings.PossiblyUnusedIncludeDirective=Directiva \#include potencialmente obsoleta
Strings.PossiblyUnusedIncludeDirective7=Directiva \#include potencialmente obsoleta
Strings.NotAllControlPathsReturnAValue=Algunas rutas de control no devuelven valores
Strings.NotAllControlPathsInsideAFunctionOrALambdaReturnAValue=Cualquier ruta de control dentro de la función o lambda no devuelve un valor
Strings.TypeSpecifierMissingDefaultsToInt=Falta el calificador de tipo, int es el valor predeterminado
Strings.NoTypeSpecifierFoundInADeclarationDefaultsToint=No hay ningún especificador de tipo en la declaración. Acepte el valor predeterminado de 'int'.
Strings.NoReturnStatementInAFunctionOrALambdaReturningNonVoid=No hay declaración de retorno en una función o lambda que devuelva no nulo
Strings.NoReturnStatementInAFunctionOrALambdaWithNonVoidReturnType=No hay declaración de devolución en función o lambda con un tipo de devolución distinto de nulo
Strings.AFunctionOrALambdaWithNonVoidReturnTypeShouldReturnAValue=Las funciones o lambdas con tipos de retorno distintos de void deben devolver un valor.
Strings.AFunctionOrALambdaWithNonVoidReturnTypeShouldReturnAValue8=Las funciones o lambdas con tipos de retorno distintos de void deben devolver un valor.
Strings.AddingCvQualifiersToReferencesHasNoEffect=Agregar cv-qualifier a la referencia no tiene ningún efecto
Strings.AddingCvQualifiersToReferencesHasNoEffect9=Agregar cv-qualifier a la referencia no tiene ningún efecto
Strings.DereferenceOperatorLimitIsExceeded=Se superó el límite del operador de desreferencia
Strings.DereferenceOperatorLimitIsExceeded10=Se superó el límite del operador de desreferencia
Strings.ForwardEnumDeclarationWithoutUnderlyingTypeTitle=Declaración de enumeración directa sin tipo base
Strings.ForwardEnumDeclarationWithoutUnderlyingTypeDescription=ISO C++ prohíbe la declaración directa de enumeraciones sin tipos primitivos
Strings.PragmaRegionIsMissingAMatchingEndRegionTitle=Falta la directiva '\#pragma endregion' coincidente
Strings.PragmaRegionIsMissingAMatchingEndRegionDescription=Ninguna directiva '\#pragma endregion' coincide con la directiva '\#pragma region'
Strings.PragmaEndRegionIsMissingAMatchingEndRegionTitle=Falta la directiva coincidente '\#pragma region'
Strings.PragmaEndRegionIsMissingAMatchingEndRegionDescription=Ninguna directiva '\#pragma region' coincide con la directiva '\#pragma endregion'
Strings.StaticDataMemberInAnAnonymousClassIsNotAllowedByTheCStandard=Los miembros de datos estáticos en clases anónimas no están permitidos en el estándar C++
Strings.StaticDataMembersAreNotAllowedInAnonymousClasses=Los miembros de datos estáticos no están permitidos en clases asincrónicas.
Strings.KeyworddefaultIsUsedAsIdentifier=La palabra clave 'predeterminada' se utiliza como identificador
Strings.defaultIsAKeywordInTheCStandardAndCannotBeUsedAsAnIdentifier='predeterminado' es una palabra clave en el estándar C++ y no se puede utilizar como identificador.
Strings.longFloatsAreNotAllowedByTheCStandard=El valor flotante "largo" no está permitido en el estándar C++
Strings.DeclarationSpecifierlongCanNotBeCombinedWithfloat=El especificador de declaración 'largo' no se puede combinar con 'flotante'
Strings.CastingFromNullptrToPointerTypeWithReinterpretCastIsNonStandardMicrosoftCExtension=La conversión de nullptr al tipo de puntero usando reinterpret_cast es una extensión no estándar de Microsoft C++
Strings.CastingFromNullptrToPointerTypeWithReinterpretCastIsNonStandardMicrosoftCExtension1=La conversión de nullptr al tipo de puntero usando reinterpret_cast es una extensión no estándar de Microsoft C++
Strings.BindingRValueToLValueReferenceIsNonStandardMicrosoftCExtension=Vincular un valor r mediante una referencia de valor l es una extensión no estándar de Microsoft C++
Strings.BindingRValueToLValueReferenceIsNonStandardMicrosoftCExtension2=Vincular un valor r mediante una referencia de valor l es una extensión no estándar de Microsoft C++
Strings.TakingAnAddressOfClassRValueIsNonStandardMicrosoftCExtension=El uso de direcciones del valor de clase r es una extensión no estándar de Microsoft C++
Strings.TakingAnAddressOfClassRValueIsNonStandardMicrosoftCExtension3=El uso de direcciones de valores de clase r es una extensión no estándar de Microsoft C++
Strings.MoreThanOneImplicitConversionAppliedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension=Se aplicó una conversión implícita que excede una de las inicializaciones de copia. Esta es una extensión no estándar de Microsoft C++.
Strings.MoreThanOneImplicitConversionAppliedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension4=Se aplicó una conversión implícita que excede una de las inicializaciones de copia. Esta es una extensión no estándar de Microsoft C++.
Strings.CallOfDeletedCopyConstructorElidedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension=La llamada al constructor de la copia eliminada se ocultó durante la inicialización de la copia. Esta es una extensión no estándar de Microsoft C++.
Strings.CallOfDeletedCopyConstructorElidedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension5=La llamada al constructor de la copia eliminada se ocultó durante la inicialización de la copia. Esta es una extensión no estándar de Microsoft C++.
Strings.NotInitializedStaticConstLocalVariableOfScalarTypeThisIsNonStandardMicrosoftCExtension=Una variable local constante estática de tipo escalar no se inicializa. Esta es una extensión no estándar de Microsoft C++
DFAStrings.CppDFAConstantConditionsTitle=Condiciones que siempre son verdaderas o falsas
DFAStrings.CppDFAConstantConditionsDescription=Informa una expresión cuya condición es siempre verdadera o falsa y cuyo valor se ha demostrado estáticamente que es una constante.
DFAStrings.CppDFANullDereferenceTitle=Desreferencia de un puntero que puede contener nullptr
DFAStrings.CppDFANullDereferenceDescription=Informa desreferencias de punteros que pueden contener nullptr
DFAStrings.CppDFANotInitializedFieldTitle=Campos que pueden no haberse inicializado antes de su uso
DFAStrings.CppDFANotInitializedFieldDescription=Campos de informes que pueden no haberse inicializado antes de usarse. La inicialización y el uso pueden ocurrir en diferentes funciones.
DFAStrings.CppDFALoopConditionNotUpdatedTitle=La condición del bucle no se actualiza dentro del bucle
DFAStrings.CppDFALoopConditionNotUpdatedDescription=Informa una condición de bucle que no se actualiza dentro del bucle
DFAStrings.CppDFADeletedPointerTitle=Dónde utilizar punteros que hacen referencia a la memoria eliminada
DFAStrings.CppDFADeletedPointerDescription=Informa el uso de un puntero que hace referencia a la memoria que ya ha sido eliminada por el operador de eliminación o la función free(void* ptr)
DFAStrings.CppDFAMemoryLeakTitle=Asignación de memoria inédita
DFAStrings.CppDFAMemoryLeakDescription=Informa las asignaciones de memoria que no se liberaron (usando 'new' o 'malloc()') antes de que se volvieran inaccesibles.
DFAStrings.CppDFAInvalidatedMemoryTitle=Una referencia al contenido de un contenedor invalidado.
DFAStrings.CppDFAInvalidatedMemoryDescription=Informa una referencia al contenido de un contenedor invalidado.
DFAStrings.CppDFALocalValueEscapesScopeTitle=Una referencia a una variable local que escapa de su alcance.
DFAStrings.CppDFALocalValueEscapesScopeDescription=Informa variables que tienen una referencia a una variable local que escapa de su alcance.
DFAStrings.CppDFALocalValueEscapesFunctionTitle=Referencia a la función de escape de variable local
DFAStrings.CppDFALocalValueEscapesFunctionDescription=Informa referencias a valores locales que escapan de una función mediante retorno o asignación a una variable o campo global.
DFAStrings.CppDFAConstantParameterTitle=Parámetros de función que siempre tienen el mismo valor.
DFAStrings.CppDFAConstantParameterDescription=Siempre informa los parámetros de función con el mismo valor
DFAStrings.CppDFAConstantFunctionResultTitle=Una función cuyo valor de retorno es siempre la misma constante
DFAStrings.CppDFAConstantFunctionResultDescription=Informa una función cuyo valor de retorno es siempre la misma constante.
DFAStrings.CppDFAArrayIndexOutOfBoundsTitle=Expresión de acceso a matriz donde el índice puede estar fuera de rango
DFAStrings.CppDFAArrayIndexOutOfBoundsDescription=Informa una expresión de acceso a variable de puntero o matriz donde el índice puede estar fuera de los límites de la matriz o del búfer asignado.
DFAStrings.CppDFAUnreachableCodeTitle=código no disponible
DFAStrings.CppDFAUnreachableCodeDescription=Informa fragmentos de código que no se ejecutan en ningún flujo de control y que se pueden eliminar de forma segura
DFAStrings.CppDFAUnreachableFunctionCallTitle=Función cuya llamada nunca se utiliza
DFAStrings.CppDFAUnreachableFunctionCallDescription=Las llamadas informan sobre funciones que nunca se utilizan. Esa función tampoco se ejecuta en absoluto.
DFAStrings.CppDFAEndlessLoopTitle=declaración de bucle infinito
DFAStrings.CppDFAEndlessLoopDescription=Informa declaraciones 'para', 'mientras', 'hacer-mientras' y 'goto' que deben finalizar lanzando una excepción.
DFAStrings.CppDFAInfiniteRecursionTitle=Una función que se llama a sí misma infinitamente.
DFAStrings.CppDFAInfiniteRecursionDescription=Informa una función que se llama a sí misma infinitamente a menos que se produzca una excepción.
DFAStrings.CppDFAUnusedValueTitle=Valor de variable que nunca se utiliza después de ser sustituido
DFAStrings.CppDFAUnusedValueDescription=Informa valores de variables que nunca se han utilizado después de ser sustituidos.
DFAStrings.CppDFAUnreadVariableTitle=Variable local declarada pero nunca accedida para lectura
DFAStrings.CppDFAUnreadVariableDescription=Informa variables locales que se declaran pero a las que nunca se accede para su lectura.
DFAStrings.CppDFATimeOverTitle=Tiempo de espera de verificación del flujo de datos
DFAStrings.CppDFATimeOverDescription=La verificación del flujo de datos ha alcanzado un límite de tiempo o de memoria y no se puede evaluar en modo consciente o no consciente del contexto.
