Strings.ConstructorOfSmartPointerIsUsedInsteadOfItsMakeFunction=make 함수 대신 스마트 포인터 생성자가 사용되었습니다
Strings.ConstructorOfASmartPointerBoostStdSharedPtrUniquePtrIsUsedInsteadOfTheCorrespondingMakeSharedMakeUniqueMakeFunctionsAreExceptionSafeAndMoreEfficient=Constructor of a smart pointer (boost/std\:\:shared_ptr/unique_ptr) is used instead of the corresponding make_shared/make_unique. Make functions are exception-safe and more efficient.
Strings.CStyleCastIsUsedInsteadOfACCast=C++ 형 변환 대신 C-스타일 형 변환이 되었습니다
Strings.CStyleCastIsUsedInsteadOfACCast1=C++ 형 변환 대신 C-스타일 형 변환이 되었습니다
Strings.FunctionalStyleCastIsUsedInsteadOfACCast=C++ 형 변환 대신 함수 스타일 형 변환이 사용되었습니다
Strings.FunctionalStyleCastIsUsedInsteadOfACCast2=C++ 형 변환 대신 함수 스타일 형 변환이 사용되었습니다
Strings.ReinterpretCastIsUsedInsteadOfAStaticCast=static_cast 대신 reinterpret_cast가 사용되었습니다
Strings.ReinterpretCastIsUsedInsteadOfAStaticCast3=static_cast 대신 reinterpret_cast가 사용되었습니다
Strings.NonExplicitConvertingConstructor=비명시적 변환 생성자
Strings.NonExplicitConvertingConstructor4=비명시적 변환 생성자
Strings.NonExplicitConversionOperator=비명시적 변환 연산자
Strings.NonExplicitConversionOperator5=비명시적 변환 연산자
Strings.ResultOfAPostfixOperatorIsDiscarded=접미어 연산자의 결과가 무시됨
Strings.ResultOfAPostfixOperatorIsDiscardedItMightBeMoreEfficientToUseAPrefixFormOfTheOperator=접미사 연산자의 결과가 버려집니다. 접미사 형태의 연산자를 쓰는 것이 더 효율적일 수 있습니다.
Strings.FunctionReturnsByConstValue=const 값에 따른 함수 반환
Strings.ReturningFromAFunctionByConstValueIsUsuallyNotBeneficialConsiderReturningValuesAsNonConstToTakeAdvantageOfMoveSemantics=Returning from a function by const value is usually not beneficial. Consider returning values as non-const to  take advantage of move semantics.
Strings.MemberFunctionCanBeMadeConst=멤버 함수를 const로 만들 수 있습니다
Strings.MemberFunctionCanBeMadeConst6=멤버 함수를 const로 만들 수 있습니다
Strings.MemberFunctionCanBeMadeStatic=멤버 함수를 static으로 만들 수 있습니다
Strings.MemberFunctionCanBeMadeStatic7=멤버 함수를 static으로 만들 수 있습니다
Strings.LocalVariableCanBeMadeConst=로컬 변수를 const로 만들 수 있습니다
Strings.LocalVariableCanBeMadeConst8=로컬 변수를 const로 만들 수 있습니다
Strings.ParameterCanBeMadeConst=매개변수를 const로 만들 수 있습니다
Strings.ParameterCanBeMadeConst9=매개변수를 const로 만들 수 있습니다
Strings.VariableCanBeMadeConstexpr=변수를 constexpr로 만들 수 있습니다
Strings.VariableCanBeMadeConstexpr10=변수를 constexpr로 만들 수 있습니다
Strings.ParameterCanBeMadePointerReferenceToConst=매개변수를 const에 대한 포인터/참조로 만들 수 있습니다
Strings.ParameterCanBeMadePointerReferenceToConst11=매개변수를 const에 대한 포인터/참조로 만들 수 있습니다
Strings.PassValueParameterByConstReferenceTitle=const 참조에 의해 값 매개변수 전달
Strings.PassValueParameterByConstReferenceDescription=복사 부하가 큰 타입의 매개변수가 값에 의해 전달되고 있습니다. 값 대신 상수 참조로 전달할 수 있습니다
Strings.ThrowExpressionCanBeReplacedWithARethrowExpression=throw 식을 rethrow 식으로 대체 가능
Strings.ThrowExpressionCanBeReplacedWithARethrowExpression12=throw 식을 rethrow 식으로 대체 가능
Strings.ZeroConstantCanBeReplacedWithNullptr=0 상수를 nullptr로 대체 가능
Strings.ZeroConstantCanBeReplacedWithNullptr13=0 상수를 nullptr로 대체 가능
Strings.CompileTimeConstantExpressionCanBeReplacedByEithertrueOrfalse=컴파일-시간 상수 표현식응ㄹ 'true' 또는 'false'로 대체 가능
Strings.CompileTimeIntegralConstantExpressionOrNullptrIsConvertedToBoolAndCanBeReplacedBytrueOrfalse=컴파일 시 정수인 상수 표현식 혹은 nullptr이 부울로 변환되며 'true' 혹은 'false'로 대체될 수 있습니다
Strings.IfStatementWithConstantConditionCanBeReplacedByifConstexpr=상수 조건을 포함한 문이 'if constexpr'로 대체될 수 있는 경우
Strings.IfStatementWithConstantConditionCanBeReplacedByifConstexpr14=상수 조건을 포함한 문이 'if constexpr'로 대체될 수 있는 경우
Strings.IfStdIsConstantEvaluatedCanBeReplacedTitle='if'를 'if consteval'로 바꿀 수 있습니다
Strings.IfStdIsConstantEvaluatedCanBeReplacedDescription='if'를 'if consteval'로 바꿀 수 있습니다
Strings.StdIsConstantEvaluatedWillAlwaysEvaluateToConstantTitle='std\:\:is_constant_evaluated'는 항상 상수로 평가됩니다
Strings.StdIsConstantEvaluatedWillAlwaysEvaluateToConstantDescription='std\:\:is_constant_evaluated'는 항상 상수로 평가됩니다
Strings.ConstevalIfIsAlwaysConstantTitle=consteval if는 항상 상수입니다
Strings.ConstevalIfIsAlwaysConstantDescription=consteval if는 항상 상수입니다
Strings.ClassCanBeMadeFinal=클래스를 final로 만들 수 있음
Strings.AClassDefinitionCanBeMarkedAsFinalSoItCannotBeInheritedFrom=클래스로부터 상속할 수 없도록 클래스 정의를 final로 표시할 수 있습니다
Strings.StructuredBindingCanBeUsed=구조화 바인딩을 쓸 수 있습니다
Strings.StructuredBindingCanBeUsed15=구조화 바인딩을 쓸 수 있습니다
Strings.TypeTraitCanBeSimplifiedUsingATemplateAliasOrAVariableTemplate=템플릿 별칭이나 변수 템플릿을 사용하여 타입 특성을 간소화할 수 있습니다
Strings.ATypeTraitCanBeSimplifiedUsingATemplateAliasOrAVariableTemplate=템플릿 별칭이나 변수 템플릿을 사용하여 타입 특성을 간소화할 수 있습니다
Strings.AlgorithmAcceptingAnIteratorAndACountCanBeUsed=반복기와 개수를 받는 알고리즘을 쓸 수 있습니다
Strings.AStandardAlgorithmAcceptingRangeIteratorsIsUsedInsteadOfTheVariantAcceptingAnIteratorAndACount=반복기 개수를 받는 변종이 아닌 범위 반복기를 받는 표준 알고리즘이 사용되었습니다
Strings.AlgorithmOperatingOnRangesCanBeUsed=범위에서 작동하는 알고리즘을 사용할 수 있습니다
Strings.AlgorithmAcceptingIteratorsIsUsedInsteadOfTheCorrespondingAlgorithmFromStdRanges=std\:\:ranges에서 대응되는 알고리즘이 아닌 반복기를 받는 알고리즘이 사용되었습니다
Strings.StdViewsKeysValuesCanBeUsed=std\:\:views\:\:keys/values를 사용할 수 있습니다
Strings.ForExampleWhenIteratingOnKeyValuePairsStdViewsKeysAllowsToIgnoreTheValues=For example, when iterating on key-value pairs, std\:\:views\:\:keys allows ignoring the values.
Strings.StdSizeCanBeUsed=std\:\:size를 사용할 수 있습니다
Strings.StdSizeIsTypeSafeAlternativeToCIdiomForArraySizeCalculation=배열 크기를 계산할 때 std\:zie는 C 관용구 대신 쓸 수 있는 안전한 대안입니다
Strings.ForLoopCanBeReplacedWithWhileLoop=For 반복문을 while 반복문으로 바꿀 수 있습니다
Strings.ForLoopWithoutInitStatementAndUpdateExpressionIsEquivalentToWhileLoop=init 문과 업데이트 표현식이 없는 for 반복문은 while 반복문과 같습니다
Strings.DeclarationAndAssignmentCanBeJoined=선언 및 할당이 결합될 수 있음
Strings.DeclarationOfAVariableAndAssignmentToItCanBeJoined=변수의 선언과 이에 대한 할당은 하벼질 수 있습니다
Strings.StructuredBindingCanBeUsedInsteadOfTie=tie(..) 대신 구조화 바인딩을 쓸 수 있습니다
Strings.ZeroInitializationCanBeUsedInsteadOfMemset=memset 대신 0 초기화를 사용할 수 있습니다
Strings.ZeroInitializationCanBeUsedInsteadOfMemset16=memset 대신 0 초기화를 사용할 수 있습니다
Strings.containsMemberFunctionCanBeUsed='contains' 멤버 함수가 사용될 수 있습니다
Strings.containsMemberFunctionCanBeUsed17='contains' 멤버 함수가 사용될 수 있습니다
Strings.stdErasestdEraseIfCanBeUsedInsteadOfTheRemoveEraseIdiom='std\:\:erase'/'std\:\:erase_if'를 remove-erase 관용구 대신 사용할 수 있습니다
Strings.stdErasestdEraseIfCanBeUsedInsteadOfTheRemoveEraseIdiom18='std\:\:erase'/'std\:\:erase_if'를 remove-erase 관용구 대신 사용할 수 있습니다
Strings.LambdaCanBeRewrittenToUseExplicitTemplateParameters=Lambda can be rewritten to use explicit template parameters
Strings.LambdaCanBeRewrittenToUseExplicitTemplateParameters19=Lambda can be rewritten to use explicit template parameters
Strings.VariableCanBeMovedToInnerScope=변수를 내부 범위로 이동할 수 있습니다
Strings.DontIntroduceAVariableBeforeYouNeedToUseIt=필요하지 않은 변수를 삽입하지 마십시오
Strings.VariableCanBeMovedToInitStatement=변수를 init 문으로 이동할 수 있습니다
Strings.NamespaceDefinitionContainingSingleClassSpecialization=단일 클래스 전문화를 포함한 네임스페이스 정의
Strings.DontIntroduceANamespaceDefinitionOnlyForClassSpecializationSpecializationCanBeDefinedUsingQualifiedClassName=클래스 전문화만을 위해 네임스페이스 정의를 삽입하지 마십시오. 전문화는 정규화된 클래스 이름을 사용하여 정의될 수 있습니다
Strings.NonInlineFunctionDefinitionInAHeaderFile=헤더 파일의 인라인화되지 않은 함수 정의
Strings.AFunctionDefinitionInAHeaderFileThatWillCauseMultipleDefinitionLinkageError=헤더 파일 내에 다수의 정의 링크 에러를 일으킬 함수 정의가 있습니다
Strings.NonInlineVariableDefinitionInAHeaderFile=헤더 파일의 인라인화되지 않은 변수 정의
Strings.AVariableDefinitionInAHeaderFileThatWillCauseMultipleDefinitionLinkageError=헤더 파일 내에 다수의 정의 링크 에러를 일으킬 변수 정의가 있습니다
Strings.FunctionIsNotImplemented=함수가 구현되지 않음
Strings.AFunctionIsNotImplemented=함수가 구현되지 않았습니다
Strings.PrivateSpecialMemberFunctionIsNotImplemented=특수 private 멤버 함수가 구현되지 않음
Strings.APrivateSpecialMemberFunctionShouldBeDefinedOrDeleted=private 특수 멤버 함수를 정의하거나 삭제해야 합니다
Strings.NonVirtualClassMemberFunctionHiddenInADerivedClass=파생 클래스에서 숨겨진 virtual 외 클래스 멤버 함수
Strings.NonVirtualClassMemberFunctionIsHiddenInADerivedClass=파생 클래스에서 가상이 아닌 클래스 멤버 함수가 숨겨졌습니다
Strings.ClassMemberFunctionHidingANonVirtualFunctionFromABaseClass=기본 클래스로부터 virtual 외 함수를 숨기는 클래스 멤버 함수
Strings.ClassMemberFunctionHidesANonVirtualFunctionFromABaseClass=클래스 멤버 함수가 기본 클래스로부터 가상이 아닌 함수를 숨깁니다
Strings.PolymorphicClassWithNonVirtualPublicDestructor=virtual 및 public 외 소멸자를 포함한 다형 클래스
Strings.APolymorphicClassWithANonVirtualPublicDestructor=가상이 아닌 public 소멸자를 포함한 다형 클래스
Strings.ClassIsAbstractButNotExplicitlyDeclaredAsSuch=이 클래스는 추상적이나, 명시적으로 그렇게 선언되지 않습니다.
Strings.TheClassIsAbstractButNotExplicitlyDeclaredAsSuch=클래스가 추상적이지만, 명시적으로 선언되지 않음
Strings.PossiblyErroneousIncompleteSwitchStatement=오류가 있을 수 있는 미완료 switch 문
Strings.TheSwitchStatementDoesntCoverTheWholeRangeOfTheEnumerationUsed=switch 문이 사용된 열거형의 모든 범위를 다루지 않습니다
Strings.DefaultCaseIsNotHandledInASwitchStatement=switch 문에서 기본 case가 처리되지 않음
Strings.DefaultCaseIsNotHandledInASwitchStatement20=switch 문에서 기본 case가 처리되지 않음
Strings.PossiblyErroneousEmptyStatement=오류가 있을 수 있는 비어 있는 구문
Strings.PossiblyErroneousEmptyStatementUsedInAControlStatement=오류가 있을 수 있는 빈 구문이 제어문에서 사용됨
Strings.PossiblyErroneousExpressionWithoutSideEffects=가능한 오류 식(부작용 없음)
Strings.PossiblyErroneousExpressionWithoutSideEffects21=가능한 오류 식(부작용 없음)
Strings.ResultOfNodiscardFunctionIsNotUsed=nodiscard 함수의 결과가 사용되지 않습니다
Strings.ResultOfNodiscardFunctionIsNotUsed22=nodiscard 함수의 결과가 사용되지 않습니다
Strings.FunctionResultShouldBeUsedTitle=함수 결과가 사용되어야 합니다
Strings.FunctionResultShouldBeUsedDescription=함수가 호출 위치에서 처리되어야 하는 타입의 값을 반환합니다
Strings.MayBeMissingKeywordthrow='throw' 키워드가 누락되었을 수 있습니다
Strings.ObjectOfExceptionTypeIsCreatedButIsNotThrown=예외 타입의 객체가 생성되었으나 던져지지 않습니다
Strings.DependentTypeWithouttypenameKeyword='typename' 키워드가 없는 종속 유형
Strings.DependentTypeWithouttypenameKeyword23='typename' 키워드가 없는 종속 유형
Strings.DependentTemplateWithouttemplateKeyword='template' 키워드가 없는 종속 템플릿
Strings.DependentTemplateWithouttemplateKeyword24='template' 키워드가 없는 종속 템플릿
Strings.ImplicitDefaultConstructorIsNotAvailable=묵시적 기본 생성자를 사용할 수 없음
Strings.ImplicitDefaultConstructorIsNotAvailableBecauseABaseClassOrAClassMemberDoesNotHaveAnAccessibleDefaultConstructor=기본 클래스나 클래스 멤버가 접근할 수 있는 기본 생성자가 없으므로 묵시적 기본 생성자를 이용할 수 없습니다
Strings.ClassShouldHaveAUserDefinedConstructorBecauseOfAnUninitializedDataMember=초기화되지 않은 데이터 멤버로 인해 클래스에 사용자 정의 생성자가 필요합니다.
Strings.ClassShouldHaveAUserDefinedConstructorBecauseOfAnUninitializedDataMember25=초기화되지 않은 데이터 멤버로 인해 클래스에 사용자 정의 생성자가 필요합니다.
Strings.NonStaticDataMemberIsUninitialized=비정적 데이터 멤버가 초기화되지 않음
Strings.NonStaticDataMemberIsUninitialized26=비정적 데이터 멤버가 초기화되지 않음
Strings.PossiblyUnintendedIncompatibleReferenceTypeInRangeDeclaration=범위 선언에서 잠재적으로 의도되지 않은 비호환 참조 타입
Strings.UsingAnIncompatibleReferenceTypeInTheRangeDeclarationIsLikelyToCauseUnwantedObjectCopying=호환되지 않는 추론 타입을 범위 선언에서 사용하면 원하지 않게 객체가 복사될 수 있습니다
Strings.ExpressionWhichEvaluatesToZeroIsUsedAsANullPointerConstant=제로에 대해 평가하는 식이 null 포인터 상수로 사용됩니다
Strings.ExpressionWhichEvaluatesToZeroIsUsedAsANullPointerConstant27=제로에 대해 평가하는 식이 null 포인터 상수로 사용됩니다
Strings.PossiblyUnintendedObjectSlicing=잠재적인 의도되지 않은 객체 슬라이싱
Strings.PossiblyUnintendedObjectSlicing28=잠재적인 의도되지 않은 객체 슬라이싱
Strings.PossiblyUninitializedClassMember=잠재적인 초기화되지 않은 클래스 멤버
Strings.ClassConstructorDoesntInitializeAFieldExplicitlyOrImplicitly=클래스 생성자가 필드를 명시적으로든 묵시적으로든 초기화하지 않습니다
Strings.DeclaratorDisambiguatedAsAFunctionDeclaration=함수 선언으로서 선언자가 구분됨
Strings.DeclaratorIsDisambiguatedAsAFunctionDeclarationMakeSureAVariableDefinitionIsNotIntendedInstead=선언자가 함수 선언으로 구분되었습니다. 변수 정의가 의도된 것이 아닌지 확인하세요.
Strings.DeclarationOfANonOverridingVirtualFunctionInAFinalOrSealedClass=final 또는 sealed 클래스에서 재정의되지 않은 가상 함수의 선언
Strings.ANonOverridingVirtualFunctionInAFinalOrSealedClassCannotBeOverriddenSoThevirtualSpecifierIsRedundant=final 혹은 sealed 클래스 내에 있는 재정의하지 않는 가상 함수는 재정의될 수 없으므로 'virtual' 지정자는 불필요합니다
Strings.MethodMustBePublicAndVirtualToImplementACCLIInterfaceMember=C++/CLI 인터페이스 멤버를 구현하려면 메소드가 public이면서 virtual이어야 합니다.
Strings.MethodMustBePublicAndVirtualToImplementACCLIInterfaceMember29=C++/CLI 인터페이스 멤버를 구현하려면 메소드가 public이면서 virtual이어야 합니다.
Strings.DeclarationSpecifierWithNoDeclarators=선언자 없는 선언 지정자
Strings.ADeclarationSpecifierIsIgnoredWhenThereAreNoDeclarators=선언 지정자는 선언자가 없으면 무시됩니다
Strings.DeclarationDoesNotDeclareAnything=선언이 아무 것도 선언하지 않음
Strings.ADeclarationDoesNotDeclareAnything=선언이 아무 것도 선언하지 않습니다
Strings.HidingLocalDeclaration=지역 선언을 숨김
Strings.ALocalDeclarationHidesAnotherLocalDeclaration=로컬 선언이 다른 로컬 선언을 가립니다
Strings.HidingAnUncapturedLocalDeclaration=캡쳐되지 않은 로컬 변수를 숨기는 중
Strings.ALocalDeclarationInsideALambdaHidesAnUncapturedLocalDeclaration=람다 내의 로컬 선언이 캡쳐되지 않은 로컬 선언을 가립니다
Strings.MismatchedClassTags=일치하지 않는 클래스 태그
Strings.TagsOfTheDeclaredClassDoNotMatchPreviousDeclarations=선언된 클래스의 태그가 이전 선언과 일치하지 않습니다
Strings.ResultOfAssignmentIsUsedAsCondition=할당 결과가 조건으로 사용됩니다
Strings.ImplicitIntegerToPointerConversion=정수를 포인터로 묵시적 변환
Strings.ImplicitIntegerToPointerConversion30=정수를 포인터로 묵시적 변환
Strings.ImplicitPointerToIntegerConversion=포인터에서 정수로 묵시적 변환
Strings.ImplicitPointerToIntegerConversion31=포인터에서 정수로 묵시적 변환
Strings.ImplicitConversionToIncompatiblePointerType=호환되지 않는 포인터 유형으로 묵시적 변환
Strings.ImplicitConversionToIncompatiblePointerType32=호환되지 않는 포인터 유형으로 묵시적 변환
Strings.ImplicitConversionToLessQualifiedPointerType=제어자가 손실된 포인터 타입으로의 묵시적 변환
Strings.ImplicitConversionToLessQualifiedPointerType33=제어자가 손실된 포인터 타입으로의 묵시적 변환
Strings.StringLiteralToCharPointerConversion=string 리터럴에서 char 포인터로의 변환
Strings.StringLiteralToCharPointerConversion34=string 리터럴에서 char 포인터로의 변환
Strings.NonSafeResourceAcquisition=안전하지 않은 리소스 획득
Strings.DetectsLeakProneResourceAcquisitionFreeingConstructs=누출에 취약한 리소스 획득/해제된 구문을 감지합니다
Strings.CallToAVirtualFunctionInsideAConstructorDestructorIsResolvedAtCompileTime=생성자/소멸자 내의 가상 함수에 대한 호출이 컴파일 때 해결됩니다
Strings.CallToAVirtualFunctionInsideAConstructorDestructorWillResultInAPureVirtualFunctionCall=생성자/소멸자 내의 가상 함수를 호출하면 순수 가상 함수 호출이 발생함
Strings.CallsToPureVirtualFunctionsInsideConstructorsAndDestructorsAreARuntimeError=생성자 및 소멸자 내에서 순수 가상 함수를 호출하면 런타임 오류가 발생합니다
Strings.BackslashAndNewlineAreSeparatedBySpace=백슬래시 및 새로운 줄은 공백으로 구분됩니다
Strings.BackslashIsNotALineContinuatorBecauseThereIsASpaceBetweenItAndTheEndOfTheLine=백슬래시와 줄의 끝 사이에 공백이 있으므로 백슬래시는 줄을 지속시키지 않습니다
Strings.InvalidPrintfFormatSpecifier=유효하지 않은 printf 서식 지정자
Strings.FormatStringContainsAnInvalidPrintfFormatSpecifier=서식 지정 문자열에 유효하지 않은 printf 서식 지정자가 포함됩니다
Strings.PossiblyInvalidPrintfFormatSpecifier=잠재적으로 유효하지 않은 printf 형식 지정자
Strings.FormatStringContainsAPotentialError=서식 지정 문자열에 잠재적인 오류가 포함되어 있습니다
Strings.NotEnoughArgumentsInACallToPrintf=printf 호출에 인수가 부족함
Strings.NotEnoughArgumentsInACallToPrintfSomeFormatCodesDoNotHaveAMatchingArgument=printf 호출에 인수가 충분하지 않습니다. 일치하는 인수가 일부 서식 지시문에 없습니다.
Strings.TooManyArgumentsInACallToPrintf=printf 호출에 인수가 너무 많음
Strings.TooManyArgumentsInACallToPrintfSomeOfTheArgumentsAreNotUsed=printf 호출에 인수가 너무 많습니다. 일부 인수는 사용되지 않습니다.
Strings.BadFormatCodeForBoostFormat=boost\:\:format 내 잘못된 서식 지시문
Strings.AFormatStringOfBoostFormatContainsAnErroneousFormatCode=boost\:\:format의 서식 문자열에 잘못된 서식 지시문이 포함되어 있습니다
Strings.LegacyFormatCodeForBoostFormat=boost\:\:format 내 오래된 서식 지시문
Strings.AFormatStringOfBoostFormatContainsALegacyPrintfLikeCodeTypeSpecifierIsNotTakenIntoAccount=서식 지정 문자열 boost\:\:format은 printf와 유사한 기존 코드를 포함합니다. 타입 지정자는 고려되지 않습니다
Strings.MixedSerialAndPositionalArgumentsForBoostFormat=동일한 boost\:\:format 호출에 있는 위치 및 비위치 인수
Strings.AnArgumentOfBoostFormatShouldContainEitherPositionalNNOrSerialsArgumentsNotBoth=An argument of boost\:\:format should contain either positional (%N%, %|N$...|) or serial (%|...|, %s) arguments, not both
Strings.NotEnoughArgumentsInACallToBoostFormat=boost\:\:format에 대한 호출에 인수 부족
Strings.NotEnoughArgumentsInACallToBoostFormat36=boost\:\:format에 대한 호출에 인수 부족
Strings.TooManyArgumentsInACallToBoostFormat=boost\:\:format에 대한 호출에 인수가 너무 많음
Strings.TooManyArgumentsInACallToBoostFormatSomeOfTheArgumentsAreNotUsed=boost\:\:format 호출에 인수가 너무 많습니다. 일부 인수는 사용되지 않습니다.
Strings.EntityIsDeprecated=엔티티가 사용되지 않음
Strings.EntityIsDeprecated37=엔티티가 사용되지 않음
Strings.MissingIncludeGuard=누락 include 가드
Strings.IncludeGuardIsNotFoundAtTheBeginningOfAHeaderFile=Include guard가 헤더 파일의 첫 부분에 없습니다
Strings.SyntaxErrorInDoxygenComment=doxygen 코멘트의 구문 오류
Strings.SyntaxErrorInADoxygenComment=doxygen 코멘트의 구문 오류
Strings.UnresolvedReferenceInDoxygenComment=doxygen 코멘트에서 미해결 참조
Strings.UnresolvedReferenceInADoxygenComment=doxygen 코멘트에서 미해결 참조
Strings.MissingFunctionParameterDescriptionInADocumentationComment=설명서 코멘트에서 기능 매개변수 설명 누락
Strings.MissingFunctionParameterDescriptionInADocumentationComment38=설명서 코멘트에서 기능 매개변수 설명 누락
Strings.DeletingAVoidPointer=void 포인터 삭제
Strings.DeletingAVoidPointerIsUndefinedBehavior=void 포인터를 삭제하는 것은 정의되지 않은 동작입니다
Strings.IncrementingExpressionOfTypeBool=bool 유형의 증분식
Strings.IncrementingExpressionOfTypeBoolIsDeprecatedInCAndRemovedInC=bool 타입의 증분식은 C++11부터 사용되지 않으며 C++17에서 제거되었습니다
Strings.DeprecatedregisterStorageClassSpecifier=더는 사용되지 않는 'register' 저장소 클래스 지정자
Strings.TheregisterStorageClassSpecifierIsDeprecatedInCAndRemovedInC='registor' 스토리지 클래스 지정자는 C++11부터 더는 사용되지 않으며 C++17에서 제거되었습니다
Strings.BinaryOperatorActsOnIdenticalOperands=이진 연산자가 일치 피연사자에 대해 작동
Strings.BinaryOperatorActsOnIdenticalOperands39=이진 연산자가 일치 피연사자에 대해 작동
Strings.BinaryOperatorActsOnEqualOperands=이진 연산자가 동등 피연산자에 대해 작동
Strings.BinaryOperatorActsOnEqualOperands40=이진 연산자가 동등 피연산자에 대해 작동
Strings.OverrideFunctionRedefinesADefaultParameterArgument=재정의 함수가 기본 매개변수 인수를 재정의
Strings.AnOverrideFunctionRedefinesADefaultParameterArgumentPreviouslyDefinedInABaseFunction=재정의 함수는 기본 함수에서 정의된 기본 매개변수 인수를 재정의합니다
Strings.UnnamedNamespaceInAHeaderFile=헤더 파일의 명명되지 않은 네임스페이스
Strings.UnnamedNamespacesShouldNotBeUsedInHeaderFiles=이름이 지정되지 않은 네임스페이스는 헤더 파일에서 사용되면 안 됩니다
Strings.ParameterNamesDoNotMatch=매개변수 이름이 일치하지 않음
Strings.ParameterNamesDifferInDifferentDeclarationsOfTheSameFunction=매개변수 이름이 같은 함수의 다른 선언에서 다르게 사용됩니다
Strings.DefaultedSpecialMemberFunctionIsImplicitlyDeleted=기본값으로 설정된 특수 멤버 함수는 묵시적으로 삭제됩니다
Strings.ExplicitlyDefaultedSpecialMemberFunctionIsImplicitlyDeleted=Explicitly defaulted special member function is implicitly deleted
Strings.NodiscardCannotBeAppliedToFunctionsWithoutAReturnValue=[[nodiscard]]은(는) 반환 값이 없는 함수에 적용될 수 없습니다
Strings.TheNodiscardAttributeCannotBeAppliedToFunctionsWithoutAReturnValue=[[nodiscard]] 속성은 반환 값이 없는 함수에 적용될 수 없습니다
Strings.CppRedundantComplexityInComparison=표현식을 단순화할 수 있습니다
Strings.AbstractFinalClass=추상적 final 클래스
Strings.AnAbstractFinalClassIsMarkedAsfinalOrsealed=추상적 final 클래스가 'final' 혹은 'sealed'로 표기되었습니다
Strings.SpecialFunctionWithoutNoexceptSpecification=특수 기능(사양 예외 없음)
Strings.SpecialFunctionDoesntHaveAnyNoexceptSpecification=특별 함수에 noexcept 사양이 없습니다
Strings.ComparisonOfUnsignedExpressionWith=0이 있는 unsigned 표현식의 비교
Strings.ComparisonOfUnsignedExpressionWith41=0이 있는 unsigned 표현식의 비교
Strings.RedundantQualifier=불필요한\n 한정자
Strings.QualifierIsRedundantAndCanBeDeleted=한정자는 불필요하며 삭제될 수 있습니다
Strings.AccessSpecifierDoesNotChangeAccessibilityLevel=액세스 지정자가 접근성 수준을 변경하지 않음
Strings.AnAccessSpecifierDoesNotChangeAccessibilityLevelAndIsRedundant=액세스 지정자는 접근성 수준을 변경하지 않으며 불필요합니다
Strings.AccessSpecifierDoesNotAffectAnyDeclaration=액세스 지정자가 선언에 전혀 영향을 주지 않음
Strings.AnAccessSpecifierDoesNotAffectAnyDeclarationAndIsRedundant=액세스 지정자는 선언에 영향을 주지 않으며 불필요합니다
Strings.RedundanttypenameKeyword=중복 'typename' 키워드
Strings.RedundanttypenameKeyword42=중복 'typename' 키워드
Strings.RedundanttemplateKeyword=중복 'template' 키워드
Strings.RedundanttemplateKeyword43=중복 'template' 키워드
Strings.RedundantelseKeyword=중복 'else' 키워드
Strings.RedundantelseKeyword45=중복 'else' 키워드
Strings.RedundantelseKeywordInsideCompoundStatement=복합 구문 내의 중복 'else' 키워드
Strings.RedundantelseKeywordInsideCompoundStatement46=복합 구문 내의 중복 'else' 키워드
Strings.RedundantControlFlowJumpStatement=중복 컨트롤 흐름 이동 구문
Strings.RedundantControlFlowJumpStatement47=중복 컨트롤 흐름 이동 구문
Strings.RedundantEmptyStatement=비어 있는 중복 구문
Strings.RedundantEmptyStatement48=비어 있는 중복 구문
Strings.RedundantEmptyDeclaration=비어 있는 중복 선언
Strings.RedundantEmptyDeclaration49=비어 있는 중복 선언
Strings.RedundantParentheses=불필요한 소괄호
Strings.ParenthesesDontChangeOrderOfOperationsAndCanBeDeleted=소괄호는 작업의 순서를 바꾸지 않으며 삭제될 수 있습니다
Strings.RedundantParameterListInLambdaDeclarator=람다 선언자 내의 불필요한 매개변수 목록
Strings.EmptyParameterListInLambdaDeclaratorCanBeDeleted=람다 선언자에서 빈 매개변수 목록은 삭제될 수 있습니다
Strings.RedundantCastExpression=불필요한 형 변환 표현식
Strings.CastIsRedundantAndCanBeDeleted=형 변환은 불필요하며 삭제될 수 있습니다
Strings.GuardedHeaderHasAlreadyBeenIncluded=헤더 가드가 이미 포함됨
Strings.GuardedHeaderHasAlreadyBeenIncluded50=헤더 가드가 이미 포함됨
Strings.TemplateArgumentsCanBeDeduced=템플릿 인수를 추론할 수 있습니다
Strings.RedundantTemplateArguments=중복 템플릿 인수
Strings.RedundantstaticSpecifierOnAnAnonymousNamespaceMember=익명 네임스페이스 멤버에 대한 중복 'static' 지정자
Strings.RedundantstaticSpecifierOnAnAnonymousNamespaceMember52=익명 네임스페이스 멤버에 대한 중복 'static' 지정자
Strings.RedundantstaticSpecifierOnAMemberAllocationDeallocationFunction=멤버 할당/할당 취소 함수에 대한 중복 'static' 지정자
Strings.ThestaticSpecifierIsOptionalForMemberAllocationDeallocationFunctions='static' 지정자는 멤버 할당/할당 취소 함수에서 선택사항입니다
Strings.RedundantStaticSpecifierOnThreadLocalLocalVariableTitle='thread_local' 지역 변수에 사용된 불필요한 'static' 지정자
Strings.RedundantStaticSpecifierOnThreadLocalLocalVariableDescription='thread_local' 지역 변수에 사용된 불필요한 'static' 지정자
Strings.RedundantBaseClassAccessSpecifier=중복 기본 클래스 액세스 지정자
Strings.RedundantBaseClassAccessSpecifier53=중복 기본 클래스 액세스 지정자
Strings.RedundantinlineSpecifier=중복 'inline' 지정자
Strings.TheinlineSpecifierOnAFunctionDefinitionIsRedundant=함수 정의에서 'inline' 지정자는 불필요합니다
Strings.RedundantconstSpecifier=중복 'const' 지정자
Strings.TheconstSpecifierOnAVariableDefinitionIsRedundant=변수 선언에서 'const' 지정자는 불필요합니다
Strings.RedundantArgumentInConditionalExpression=조건부 식의 중복 인수
Strings.RedundantArgumentInConditionalExpression54=조건부 식의 중복 인수
Strings.RedundantVoidArgumentList=중복 무효 인수 목록
Strings.RedundantVoidArgumentList55=중복 무효 인수 목록
Strings.RedundantMemberInitializerInConstructorInitializationList=생성자 초기화 목록의 중복 멤버 이니셜라이저
Strings.RedundantMemberInitializerInConstructorInitializationList56=생성자 초기화 목록의 중복 멤버 이니셜라이저
Strings.RedundantBaseClassInitializerTitle=불필요한 기본 클래스 이니셜라이저
Strings.RedundantBaseClassInitializerDescription=멤버 이니셜라이저 목록에 불필요한 기본 클래스 이니셜라이저가 있습니다
Strings.ConstQualifiedParameterInAFunctionDeclaration=함수 선언의 const 정규화 매개변수
Strings.ConstQualificationOfParametersHasAnEffectOnlyInFunctionDefinitions=매개 변수의 상수 한정은 함수 정의에서만 효과가 있습니다
Strings.VolatileQualifiedParameterInAFunctionDeclaration=함수 선언의 volatile 정규화 매개변수
Strings.VolatileQualificationOfParametersHasAnEffectOnlyInFunctionDefinitions=매개 변수의 volatile 한정은 함수 정의에서만 효과가 있습니다
Strings.FinalFunctionInAFinalClass=final 클래스 내의 final 함수
Strings.RedundantfinalSpecifierOnAFunctionInAFinalClass=final 클래스 내의 함수에서 불필요한 'final' 지정자
Strings.FinalNonOverridingVirtualFunction=재정의하지 않는 final 가상 함수
Strings.AVirtualFunctionIsMarkedfinalAndDoesNotOverrideABaseFunction=가상 함수가 'final'로 표시되어 있으며 기본 함수를 재정의하지 않습니다
Strings.RedundantElaboratedTypeSpecifier=불필요한 상세 유형 지정자
Strings.ElaboratedTypeSpecifierIsRedundantAndCanBeDeleted=상세 타입 지정자가 불필요하여 삭제될 수 있습니다
Strings.CppRedundantDereferencingAndTakingAddressTitle=불필요한 역참조 및 주소 취득
Strings.CppRedundantDereferencingAndTakingAddressDescription=불필요한 역참조 및 주소 취득
Strings.CppRedundantConditionalExpressionTitle=중복 조건식
Strings.CppRedundantConditionalExpressionDescription=중복 조건식
Strings.CppConditionalExpressionCanBeSimplifiedTitle=Conditional expression can be simplified
Strings.CppConditionalExpressionCanBeSimplifiedDescription=Conditional expression can be simplified
Strings.RedundantExportKeywordMessage=Keyword 'export' is redundant, because there is enclosing export declaration
Strings.UserDefinedLiteralSuffixesMustStartWithAnUnderscore=사용자 정의 리터럴 접미어는 밑줄로 시작해야 함
Strings.UserDefinedLiteralSuffixesMustStartWithAnUnderscoreTheSuffixesThatDoNotBeginWithAnUnderscoreAreReservedForTheLiteralOperatorsProvidedByTheStandardLibrary=사용자 지정 리터럴 접미사는 반드시 밑줄로 시작해야 합니다. 밑줄로 시작하지 않는 접미사는 표준 라이브러리에서 제공되는 리터럴 연산자에만 사용될 수 있습니다.
Strings.UseOfAnIncompleteTypeInsideATemplate=템플릿 내에서 미완료 유형 사용
Strings.AnIncompleteTypeIsUsedInsideATemplateDeclarationOrDefinition=템플릿 선언이나 정의에서 불완전한 타입이 사용되었습니다
Strings.RedeclarationOfATemplateParameterFromAnOuterScope=외부 범위의 템플릿 매개변수 재선언
Strings.ATemplateParameterFromAnOuterScopeIsShadowedByADeclarationWithTheSameName=외부 범위의 템플릿 매개변수가 같은 이름의 선언에 의해 가려집니다
Strings.ReferenceClassMemberWithmutableSpecifier='mutable' 지정자를 포함한 참조 클래스 멤버
Strings.ReferenceClassMembersCannotHavemutableSpecifier=참조 클래스 멤버는 'mutable' 지정자를 가질 수 없습니다
Strings.DefaultInitializationOfAConstQualifiedObjectOfATypeWithoutAUserProvidedDefaultConstructor=사용자가 제공한 기본 생성자 없이 유형의 const 정규화 객체를 기본 초기화
Strings.DefaultInitializationOfAConstQualifiedObjectOfATypeWithoutAUserProvidedDefaultConstructor3=사용자가 제공한 기본 생성자 없이 유형의 const 정규화 객체를 기본 초기화
Strings.ExplicitSpecializationInNonNamespaceScope=비 네임스페이스 범위에서 명시적 전문화
Strings.ExplicitSpecializationsOfATemplateInNonNamespaceScope=네임스페이스가 아닌 범위에서 템플릿의 명시적 전문화
Strings.UnionMemberOfReferenceType=참조 유형의 공용체 멤버
Strings.UnionsCannotContainNonStaticDataMembersOfReferenceTypes=공용체는 static이 아니며 추론 타입인 데이터 멤버를 포함할 수 없습니다
Strings.UninitializedDependentBaseClass=초기화되지 않은 종속 기본 클래스
Strings.PossiblyUninitializedDependentBaseClass=잠재적으로 초기화되지 않은 종속 기본 클래스
Strings.PrecompiledHeaderIsNotIncluded=사전 컴파일된 헤더가 포함되지 않음
Strings.PrecompiledHeaderMustBeIncludedAtTheTopOfSourceFile=사전 컴파일된 헤더는 반드시 소스 파일의 상단에 포함되어야 합니다
Strings.PrecompiledHeaderIsNotFound=사전 컴파일된 헤더를 찾을 수 없음
Strings.NoCorrespondingFileWithThePrecompiledHeaderPropertySetToCreateYcIsFound='사전컴파일된 헤더' 프로퍼티가 '생성'(/Yc)로 설정된 상응하는 파일이 발견되지 않았습니다
Strings.CannotResolveARequiredCoroutineFunction=필수 코루틴 함수를 해결할 수 없습니다
Strings.ACoroutineRelatedFunctionWhichIsRequiredByTheCStandardCannotBeResolved=C++20에서 필수인 코루틴 관련 함수가 해결될 수 없습니다
Strings.AwaiterTypeIsNotAClass=대기자 타입은 클래스가 아닙니다
Strings.TheAwaiterTypeMustBeAAClassAccordingToTheCStandard=C++20 표준에 따라 대기자 타입은 반드시 클래스여야 합니다
Strings.TheoutParameterMustBeAssigned='out' 매개변수는 반드시 할당되어야 합니다
Strings.InHLSLoutParametersMustBeAssignedBeforeExitingTheFunction=HLSL에서 'out' 매개변수는 반드시 함수를 종료하기 전에 할당되어야 합니다
Strings.WarningDirectiveTitle=\#warning 지시문
Strings.WarningDirectiveDescription=\#warning 전처리기 지시문
Strings.DeclaratorIsNeverUsed=선언자가 전혀 사용되지 않음
Strings.ADeclaratorIsNeverUsed=선언자가 전혀 사용되지 않습니다
Strings.TypeAliasIsNeverUsed=타입 별칭이 전혀 사용되지 않습니다
Strings.ATypeAliasIsNeverUsed=타입 별칭이 전혀 사용되지 않습니다
Strings.ConceptIsNeverUsed=콘셉트가 전혀 사용되지 않습니다
Strings.ClassIsNeverUsed=클래스가 전혀 사용되지 않습니다
Strings.AClassIsNeverUsed=클래스가 전혀 사용되지 않습니다
Strings.EnumeratorIsNeverUsed=에뮬레이터가 전혀 사용되지 않음
Strings.AEnumeratorIsNeverUsed=열거자가 전혀 사용되지 않습니다
Strings.LambdaCaptureIsNeverUsed=람다 캡쳐가 전혀 사용되지 않습니다
Strings.ALambdaCaptureIsNeverUsed=람다 캡쳐가 전혀 사용되지 않습니다
Strings.LocalVariableIsNeverUsedButMayHaveSideEffectsInItsDestructor=지역 변수가 전혀 사용되지 않지만, 해당 소멸자에 영향을 미칠 수 있음
Strings.LocalVariableIsNeverUsedButMayHaveSideEffectsInItsDestructor4=지역 변수가 전혀 사용되지 않지만, 해당 소멸자에 영향을 미칠 수 있음
Strings.ParameterIsNeverUsed=매개변수가 전혀 사용되지 않음
Strings.FunctionParameterIsNeverUsed=함수 매개변수가 전혀 사용되지 않습니다
Strings.TemplateParameterIsNeverUsedTitle=템플릿 매개변수가 한 번도 사용되지 않습니다
Strings.TemplateParameterIsNeverUsedDescription=템플릿 매개변수가 한 번도 사용되지 않습니다
Strings.DeclaratorIsOnlyAssignedButNeverAccessed=선언자가 할당만 되고 전혀 액세스되지 않음
Strings.ADeclaratorIsOnlyAssignedButNeverAccessed=선언자가 할당만 되고 전혀 액세스되지 않습니다
Strings.DeclaratorIsUsedOnlyInUnevaluatedContext=선언자는 평가되지 않은 컨텍스트에서만 사용됨
Strings.ADeclaratorIsUsedOnlyInUnevaluatedContext=선언자가 평가되지 않은 컨텍스트에서만 사용됩니다
Strings.LocalVariableMightNotBeInitialized=지역 변수가 초기화되지 않았을 수 있음
Strings.ALocalVariableMightNotBeInitialized=로컬 변수가 초기화되지 않았을 수 있습니다
Strings.ObjectMemberMightNotBeInitialized=객체 멤버가 초기화되지 않았을 수 있음
Strings.AnObjectMemberMightNotBeInitialized=객체 멤버가 초기화되지 않았을 수 있습니다
Strings.SomeObjectMembersMightNotBeInitialized=일부 객체 멤버가 초기화되지 않았을 수 있음
Strings.LocalVariableUsedWithoutBeingInitialized=로컬 변수가 초기화 없이 사용되었습니다
Strings.LocalVariableUsedWithoutBeingInitialized5=로컬 변수가 초기화 없이 사용되었습니다
Strings.PossiblyUnusedIncludeDirective=잠재적으로 사용되지 않는 \#include 지시문
Strings.PossiblyUnusedIncludeDirective7=잠재적으로 사용되지 않는 \#include 지시문
Strings.NotAllControlPathsReturnAValue=일부 제어 경로가 값을 반환하지 않음
Strings.NotAllControlPathsInsideAFunctionOrALambdaReturnAValue=함수나 람다 내의 모든 제어 경로가 값을 반환하지 않습니다
Strings.TypeSpecifierMissingDefaultsToInt=유형 한정자 누락, int가 기본값
Strings.NoTypeSpecifierFoundInADeclarationDefaultsToint=선언에 타입 지정자가 없습니다. 기본값 'int'를 적용합니다.
Strings.NoReturnStatementInAFunctionOrALambdaReturningNonVoid=비 void를 반환하는 함수 또는 람다에 반환문 없음
Strings.NoReturnStatementInAFunctionOrALambdaWithNonVoidReturnType=void가 아닌 반환 타입의 혹은 함수 혹은 람다에 반환 문 없음
Strings.AFunctionOrALambdaWithNonVoidReturnTypeShouldReturnAValue=void가 아닌 반환 타입을 가진 함수나 람다는 값을 반환해야 합니다
Strings.AFunctionOrALambdaWithNonVoidReturnTypeShouldReturnAValue8=void가 아닌 반환 타입을 가진 함수나 람다는 값을 반환해야 합니다
Strings.AddingCvQualifiersToReferencesHasNoEffect=참조에 cv-한정자를 추가해도 영향이 없음
Strings.AddingCvQualifiersToReferencesHasNoEffect9=참조에 cv-한정자를 추가해도 영향이 없음
Strings.DereferenceOperatorLimitIsExceeded=역참조 연산자의 한계가 초과됨
Strings.DereferenceOperatorLimitIsExceeded10=역참조 연산자의 한계가 초과됨
Strings.ForwardEnumDeclarationWithoutUnderlyingTypeTitle=기본 타입이 없는 전방 열거형 선언
Strings.ForwardEnumDeclarationWithoutUnderlyingTypeDescription=ISO C++는 기본 타입이 없는 열거형의 전방 선언을 금지합니다
Strings.StaticDataMemberInAnAnonymousClassIsNotAllowedByTheCStandard=익명 클래스의 정적 데이터 멤버가 C++ 표준에서 허용되지 않음
Strings.StaticDataMembersAreNotAllowedInAnonymousClasses=비동기식 클래스에서 static 데이터 멤버는 허용되지 않습니다
Strings.KeyworddefaultIsUsedAsIdentifier='default' 키워드가 식별자로 사용됨
Strings.defaultIsAKeywordInTheCStandardAndCannotBeUsedAsAnIdentifier='default'는 C++ 표준에서 키워드이며 식별자로 사용될 수 없습니다
Strings.longFloatsAreNotAllowedByTheCStandard='long' float은 C++ 표준에서 허용되지 않습니다
Strings.DeclarationSpecifierlongCanNotBeCombinedWithfloat=선언 지정자 'long'은 'float'과 결합될 수 없습니다
Strings.CastingFromNullptrToPointerTypeWithReinterpretCastIsNonStandardMicrosoftCExtension=reinterpret_cast를 사용해 nullptr에서 포인터 유형으로 형 변환하는 것이 비표준 Microsoft C++ 확장임
Strings.CastingFromNullptrToPointerTypeWithReinterpretCastIsNonStandardMicrosoftCExtension1=reinterpret_cast를 사용해 nullptr에서 포인터 유형으로 형 변환하는 것이 비표준 Microsoft C++ 확장임
Strings.BindingRValueToLValueReferenceIsNonStandardMicrosoftCExtension=l 값 참조로 r 값을 바인딩하는 것이 비표준 Microsoft C++ 확장임
Strings.BindingRValueToLValueReferenceIsNonStandardMicrosoftCExtension2=l 값 참조로 r 값을 바인딩하는 것이 비표준 Microsoft C++ 확장임
Strings.TakingAnAddressOfClassRValueIsNonStandardMicrosoftCExtension=클래스 r 값의 주소 사용이 비표준 Microsoft C++ 확장임
Strings.TakingAnAddressOfClassRValueIsNonStandardMicrosoftCExtension3=클래스 r 값의 주소 사용이 비표준 Microsoft C++ 확장임
Strings.MoreThanOneImplicitConversionAppliedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension=복사 초기화 중 하나를 초과하는 묵시적 변환이 적용되었습니다. 이는 비표준 Microsoft C++ 확장입니다.
Strings.MoreThanOneImplicitConversionAppliedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension4=복사 초기화 중 하나를 초과하는 묵시적 변환이 적용되었습니다. 이는 비표준 Microsoft C++ 확장입니다.
Strings.CallOfDeletedCopyConstructorElidedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension=삭제된 복사 생성자에 대한 호출이 복사 초기화 중에 숨겨졌습니다. 이는 비표준 Microsoft C++ 확장입니다.
Strings.CallOfDeletedCopyConstructorElidedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension5=삭제된 복사 생성자에 대한 호출이 복사 초기화 중에 숨겨졌습니다. 이는 비표준 Microsoft C++ 확장입니다.
Strings.NotInitializedStaticConstLocalVariableOfScalarTypeThisIsNonStandardMicrosoftCExtension=스칼라 타입의 static 상수 로컬 변수가 초기화되지 않았습니다. 이는 비표준 Microsoft C++ 확장입니다
DFAStrings.CppDFAConstantConditionsTitle=항상 true 또는 false인 조건
DFAStrings.CppDFAConstantConditionsDescription=항상 true 또는 false인 조건과 값이 정적으로 상수로 입증된 표현식을 보고합니다
DFAStrings.CppDFANullDereferenceTitle=nullptr을 포함할 수 있는 포인터의 역참조
DFAStrings.CppDFANullDereferenceDescription=nullptr을 포함할 수 있는 포인터의 역참조를 보고합니다
DFAStrings.CppDFANotInitializedFieldTitle=Fields that may have not been initialized before their usage
DFAStrings.CppDFANotInitializedFieldDescription=Reports the fields that may have not been initialized before their usage. Initialization and usage may be in different functions
DFAStrings.CppDFALoopConditionNotUpdatedTitle=루프 내에서 업데이트되지 않는 루프 조건
DFAStrings.CppDFALoopConditionNotUpdatedDescription=루프 내에서 업데이트되지 않는 루프 조건을 보고합니다
DFAStrings.CppDFADeletedPointerTitle=삭제된 메모리를 참조하는 포인터의 사용 위치
DFAStrings.CppDFADeletedPointerDescription=delete 연산자 또는 free(void* ptr) 함수에 의해 이미 삭제된 메모리를 참조하는 포인터의 사용 위치를 보고합니다
DFAStrings.CppDFAInvalidatedMemoryTitle=무효화된 컨테이너의 내용에 대한 참조
DFAStrings.CppDFAInvalidatedMemoryDescription=무효화된 컨테이너의 내용에 대한 참조를 보고합니다
DFAStrings.CppDFALocalValueEscapesScopeTitle=해당 범위를 이스케이프하는 지역 변수에 대한 참조
DFAStrings.CppDFALocalValueEscapesScopeDescription=해당 범위를 이스케이프하는 지역 변수에 대한 참조가 있는 변수를 보고합니다
DFAStrings.CppDFALocalValueEscapesFunctionTitle=함수를 이스케이프하는 지역 변수에 대한 참조
DFAStrings.CppDFALocalValueEscapesFunctionDescription=함수를 이스케이프하는 지역 변수에 대한 참조가 있는 변수를 보고합니다
DFAStrings.CppDFAConstantParameterTitle=항상 값이 동일한 함수 매개변수
DFAStrings.CppDFAConstantParameterDescription=항상 값이 동일한 함수 매개변수를 보고합니다
DFAStrings.CppDFAConstantFunctionResultTitle=반환값이 항상 동일한 상수인 함수
DFAStrings.CppDFAConstantFunctionResultDescription=반환값이 항상 동일한 상수인 함수를 보고합니다
DFAStrings.CppDFAArrayIndexOutOfBoundsTitle=색인이 범위를 벗어날 수 있는 배열 액세스 표현식
DFAStrings.CppDFAArrayIndexOutOfBoundsDescription=색인이 배열 또는 할당된 버퍼의 범위를 벗어날 수 있는 배열 또는 포인터 변수 액세스 표현식을 보고합니다
DFAStrings.CppDFAUnreachableCodeTitle=사용할 수 없는 코드
DFAStrings.CppDFAUnreachableCodeDescription=어떤 제어 흐름에서도 실행되지 않고 안전하게 제거할 수 있는 코드 조각을 보고합니다
DFAStrings.CppDFAUnreachableFunctionCallTitle=호출이 한 번도 사용되지 않는 함수
DFAStrings.CppDFAUnreachableFunctionCallDescription=호출이 한 번도 사용되지 않는 함수를 보고합니다. 해당 함수 역시 전혀 실행되지 않습니다.
DFAStrings.CppDFAEndlessLoopTitle=무한 루프 문
DFAStrings.CppDFAEndlessLoopDescription=예외를 던져야만 종료되는 for, while, do-while 및 goto 문을 보고합니다
DFAStrings.CppDFAInfiniteRecursionTitle=자신을 무한 호출하는 함수
DFAStrings.CppDFAInfiniteRecursionDescription=예외가 던져지지 않는 한 자신을 무한 호출하는 함수를 보고합니다
DFAStrings.CppDFAUnusedValueTitle=대입된 후 한 번도 사용되지 않는 변숫값
DFAStrings.CppDFAUnusedValueDescription=대입된 후 한 번도 사용되지 않는 변숫값을 보고합니다
DFAStrings.CppDFAUnreadVariableTitle=선언되었지만 읽기를 위해 한 번도 액세스되지 않는 지역 변수
DFAStrings.CppDFAUnreadVariableDescription=선언되었지만 읽기를 위해 한 번도 액세스되지 않는 지역 변수를 보고합니다
DFAStrings.CppDFATimeOverTitle=데이터 흐름 검사 시간 초과
DFAStrings.CppDFATimeOverDescription=데이터 흐름 검사가 시간 또는 메모리 제한에 도달하여 컨텍스트 인식 모드나 비인식 모드 모두에서 평가할 수 없습니다
