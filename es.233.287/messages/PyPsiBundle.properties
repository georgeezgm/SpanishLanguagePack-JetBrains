### Inspections: INSP ###
ACT.CMD.use.import=가져온 모듈 사용
ACT.from.some.module.import=다음에서 가져오기…
ACT.qualify.with.module=가져온 모듈 검증
ANN.assign.to.none=None에 대입
ANN.assignment.expression.as.a.target=여기에서 대입 표현식을 타깃으로 사용할 수 없습니다
ANN.assignment.expression.in.an.iterable=컴프리헨션 iterable에서는 대입 표현식을 사용할 수 없습니다
ANN.assignment.expressions.within.a.comprehension.cannot.be.used.in.a.class.body=컴프리헨션 내 대입 표현식을 클래스 본문에서 사용할 수 없습니다
ANN.assignment.to.keyword=키워드에 대입
ANN.await.outside.async.function=비동기 함수 외부의 'await'
ANN.break.outside.loop=루프 외부의 'break'
ANN.can.t.use.starred.expression.here=여기에서 별표 표현식을 사용할 수 없습니다
ANN.cannot.assign.to.debug=__debug__에 대입할 수 없습니다
ANN.cant.assign.to.call=함수 호출에 대입할 수 없습니다
ANN.cant.assign.to.comprh=리스트 컴프리헨션에 대입할 수 없습니다
ANN.cant.assign.to.dict.comprh=딕셔너리 컴프리헨션에 대입할 수 없습니다
ANN.cant.assign.to.generator=제너레이터 표현식에 대입할 수 없습니다
ANN.cant.assign.to.lambda=람다에 대입할 수 없습니다
ANN.cant.assign.to.literal=리터럴에 대입할 수 없습니다
ANN.cant.assign.to.operator=연산자에 대입할 수 없습니다
ANN.cant.assign.to.parens=()에 대입할 수 없습니다
ANN.cant.assign.to.set.comprh=세트 컴프리헨션에 대입할 수 없습니다
ANN.cant.aug.assign.starred.assignment.target.must.be.in.list.or.tuple=별표가 있는 대입 타깃은 리스트 또는 튜플 안에 있어야 합니다
ANN.cant.aug.assign.to.comprh=리스트 컴프리헨션에 증분 대입할 수 없습니다
ANN.cant.aug.assign.to.dict.comprh=딕셔너리 컴프리헨션에 증분 대입할 수 없습니다
ANN.cant.aug.assign.to.generator=제너레이터 표현식에 증분 대입할 수 없습니다
ANN.cant.aug.assign.to.list.or.comprh=리스트 리터럴 또는 컴프리헨션에 증분 대입할 수 없습니다
ANN.cant.aug.assign.to.set.comprh=세트 컴프리헨션에 증분 대입할 수 없습니다
ANN.cant.aug.assign.to.tuple.or.generator=튜플 리터럴 또는 제너레이터 표현식에 증분 대입할 수 없습니다
ANN.cant.delete.call=함수 호출을 삭제할 수 없습니다
ANN.cant.delete.literal=리터럴을 삭제할 수 없습니다
ANN.continue.break.or.return.in.star.except='break', 'continue' 및 'return'은 except* 블록에 사용할 수 없습니다.
ANN.continue.outside.loop=루프 외부의 'continue'
ANN.default.except.must.be.last=디폴트 'except:'이 마지막에 와야 합니다
ANN.deleting.none=None 삭제
ANN.duplicate.param.name=매개변수 이름 중복
ANN.exception.group.in.star.except=except*에서는 ExceptionGroup을 사용할 수 없습니다.
ANN.fstrings.illegal.conversion.character=''{0}''은(는) 잘못된 변환 문자입니다. ''s'', ''r'', ''a'' 중 하나여야 합니다
ANN.fstrings.missing.conversion.character=변환 문자가 필요합니다. 's', 'r', 'a' 중 하나여야 합니다
ANN.fstrings.single.right.brace.not.allowed.inside.fstrings=단일 '}'은(는) f-string 내에서 허용되지 않습니다
ANN.function.cannot.be.async=함수 ''{0}''은(는) 비동기일 수 없습니다
ANN.generator.expression.must.be.parenthesized.if.not.sole.argument=인수가 하나가 아닐 경우에는 제너레이터 표현식을 괄호로 감싸야 합니다
ANN.ignore.errors.like.this=이와 같은 오류 무시
ANN.illegal.target.for.variable.annotation=변수 어노테이션의 잘못된 타깃
ANN.missing.closing.quote=닫는 따옴표 [{0}] 누락
ANN.missing.closing.triple.quotes=닫는 삼중 따옴표 누락
ANN.multiple.args=여러 개의 * 매개변수는 허용되지 않습니다
ANN.multiple.kwargs=여러 개의 ** 매개변수는 허용되지 않습니다
ANN.multiple.slash=여러 개의 / 매개변수는 허용되지 않습니다
ANN.name.used.both.as.global.and.param=이름 ''{0}''이(가) 매개변수 및 전역 모두로 사용되었습니다
ANN.named.parameters.after.star=이름이 지정된 매개변수가 bare * 뒤에 와야 합니다
ANN.named.parameters.before.slash=이름이 지정된 매개변수가 bare / 앞에 와야 합니다
ANN.no.exception.to.reraise=다시 발생시킬 예외가 없습니다
ANN.non.default.param.after.default=디폴트가 아닌 매개변수가 디폴트 매개변수 뒤에 옵니다
ANN.non.empty.return.inside.asynchronous.generator=비동기 제너레이터 내 비어 있지 않은 'return'
ANN.patterns.attribute.name.is.repeated=속성 이름 ''{0}''이(가) 반복됩니다
ANN.patterns.double.star.pattern.cannot.be.used.outside.mapping.patterns=별 2개 패턴은 매핑 패턴 밖에서 사용할 수 없습니다
ANN.patterns.invalid.complex.number.literal=잘못된 복합 번호 리터럴
ANN.patterns.key.pattern.can.only.be.value.or.literal.pattern=키 패턴은 값 패턴 또는 리터럴 패턴만 될 수 있습니다
ANN.patterns.name.already.bound=이름 ''{0}''이(가) 이미 바인드되어 있습니다
ANN.patterns.pattern.does.not.bind.names=패턴이 {0,choice,1#이름|2#이름} {1}을(를) 바인드하지 않습니다
ANN.patterns.pattern.makes.remaining.alternatives.unreachable=패턴으로 인해 나머지 대체 항목에 도달할 수 없습니다
ANN.patterns.pattern.makes.remaining.case.clauses.unreachable=패턴으로 인해 나머지 case 절에 도달할 수 없습니다
ANN.patterns.repeated.star.pattern=반복된 별 패턴
ANN.patterns.single.star.pattern.cannot.be.used.outside.sequence.patterns=별 1개 패턴은 시퀀스 패턴 밖에서 사용할 수 없습니다
ANN.python.does.not.support.yield.from.inside.async.functions=Python은 비동기 함수 내 'yield from'을 지원하지 않습니다
ANN.regular.param.after.keyword=** 매개변수 뒤의 일반 매개변수
ANN.regular.param.after.vararg=* 매개변수 뒤의 일반 매개변수
ANN.return.outside.of.function=함수 외부의 'return'
ANN.slash.param.after.keyword=/ 매개변수가 ** 매개변수 앞에 와야 합니다
ANN.slash.param.after.vararg=/ 매개변수가 * 매개변수 앞에 와야 합니다
ANN.star.import.at.top.only='import *'는 모듈 수준에서만 허용됩니다
ANN.starred.param.after.kwparam=** 매개변수 뒤의 * 매개변수
ANN.try.except.can.not.have.except.and.star.except=Try 구문은 except와 except*를 모두 포함할 수 없습니다.
ANN.tuple.py3=Python 3에서는 튜플 매개변수의 패킹 해제가 지원되지 않습니다
ANN.unparenthesized.assignment.expression.statement=표현 구문의 최상위 수준에서는 소괄호로 묶이지 않은 대입 표현식이 금지됩니다
ANN.unparenthesized.assignment.expression.value=대입 구문 오른쪽의 최상위 수준에서는 소괄호로 묶이지 않은 대입 표현식이 금지됩니다
ANN.variable.annotation.cannot.be.combined.with.tuple.unpacking=변수 어노테이션은 튜플 패킹 해제와 결합할 수 없습니다
ANN.variable.annotation.cannot.be.used.in.assignment.with.multiple.targets=변수 어노테이션은 다중 타깃 대입에 사용할 수 없습니다
ANN.yield.outside.of.function=함수 외부의 'yield'
INSP.GROUP.python=Python
INSP.NAME.abstract.class=클래스는 모든 abstract 메서드를 구현해야 합니다
INSP.NAME.argument.equal.default=함수 인수가 디폴트 매개변수의 값과 동일
INSP.NAME.assignment.to.loop.or.with.parameter='for' 루프 또는 'with' 문 매개변수에 대입
INSP.NAME.attribute.outside.init=인스턴스 속성이 '__init__' 외부에 정의됨
INSP.NAME.augment.assignment=대입을 증분 대입으로 바꿀 수 있습니다
INSP.NAME.bad.except.clauses.order='except' 절의 잘못된 순서
INSP.NAME.byte.literal=바이트 리터럴이 ASCII가 아닌 문자를 포함
INSP.NAME.calling.non.callable=호출할 수 없는 객체 호출 시도
INSP.NAME.chained.comparisons=너무 복잡하게 연결된 비교
INSP.NAME.check.can.be.simplified=불필요한 bool 변수 검사
INSP.NAME.class.has.no.init=클래스에 '__init__' 메서드 누락
INSP.NAME.class.var.variables=ClassVar 변수의 유효하지 않은 사용 위치
INSP.NAME.classic.class.usage=클래식 스타일 클래스 사용 위치
INSP.NAME.comparison.with.none=None과 비교를 위해 상등 연산자 사용
INSP.NAME.compatibility=코드가 특정 Python 버전과 호환되지 않음
INSP.NAME.coroutine.is.not.awaited=코루틴 ''{0}''은(는) 대기하고 있지 않습니다 
INSP.NAME.dataclass.definition.and.usages=데이터 클래스의 잘못된 정의 및 사용
INSP.NAME.decorator.outside.class=클래스 외부에서 사용된 클래스 고유의 데코레이터
INSP.NAME.default.argument=디폴트 인수가 변경 가능
INSP.NAME.deprecated.function.class.or.module=곧 사용할 수 없게 될 함수, 클래스 또는 모듈
INSP.NAME.dict.creation=딕셔너리 생성을 딕셔너리 리터럴로 다시 작성 가능
INSP.NAME.docstring.types=docstring의 타입이 추론된 타입과 일치하지 않음
INSP.NAME.dunder.slots='__slots__' 정의가 포함된 클래스의 잘못된 사용
INSP.NAME.duplicate.keys=사전이 중복 키를 포함합니다
INSP.NAME.exception.not.inherit=예외가 표준 'Exception' 클래스를 상속 안 함
INSP.NAME.final.classes.methods.and.variables=final 클래스, 메서드 및 변수의 잘못된 사용
INSP.NAME.first.arg.assign=메서드의 첫 번째 인수가 재대입됨
INSP.NAME.from.future.import=잘못된 위치의 from __future__ import
INSP.NAME.global.undefined=전역 변수가 모듈 수준에서 정의되지 않음
INSP.NAME.inconsistent.indentation=일관되지 않은 들여쓰기
INSP.NAME.incorrect.call.arguments=잘못된 호출 인수
INSP.NAME.incorrect.docstring=잘못된 docstring
INSP.NAME.init.return=값을 반환하는 __init__ 메소드
INSP.NAME.invalid.interpreter=잘못된 인터프리터
INSP.NAME.invalid.usages.of.override.decorator=@override 데코레이터의 잘못된 사용 위치
INSP.NAME.list.creation=최적화되지 않은 리스트 선언
INSP.NAME.mandatory.encoding=파일에 대해 지정된 인코딩이 없습니다
INSP.NAME.method.may.be.static=메서드가 static으로 선언되지 않음
INSP.NAME.method.over=메서드 시그니처가 재정의된 메서드의 시그니처와 일치하지 않습니다
INSP.NAME.missing.or.empty.docstring=누락되었거나 빈 docstring
INSP.NAME.missing.super.constructor=상위 클래스의 '__init__' 호출 누락
INSP.NAME.missing.type.hints=함수 정의에 대한 타입 힌트가 누락되었습니다
INSP.NAME.nested.decorators=데코레이터의 문제 있는 중첩
INSP.NAME.new.init.signature=호환되지 않는 __new__ 및 __init__ 시그니처
INSP.NAME.new.style.generics.type.param.syntax=신규 형식의 타입 매개변수와 타입 별칭이 유효하지 않게 사용됨
INSP.NAME.non.ascii=파일이 ASCII가 아닌 문자를 포함합니다
INSP.NAME.none.function.assignment=아무것도 반환하지 않는 함수 호출 대입
INSP.NAME.oldstyle.class=이전 스타일 클래스가 새로운 스타일의 클래스 기능을 포함합니다
INSP.NAME.overloads.in.regular.python.files=일반 Python 파일의 오버로드
INSP.NAME.pep8.naming=PEP 8 이름 지정 규칙 위반
INSP.NAME.problematic.first.parameter=부적절한 첫 번째 매개변수
INSP.NAME.property.access=프로퍼티에 대한 올바르지 않은 접근
INSP.NAME.property.definition=잘못된 프로퍼티 정의
INSP.NAME.protected.member=클래스 또는 모듈의 protected 멤버에 대한 접근
INSP.NAME.protocol.definition.and.usages=잘못된 프로토콜 정의 및 사용
INSP.NAME.pytest-parametrized=@pytest.mark.parametrize 내 잘못된 인수
INSP.NAME.pytest.unpassed.fixture=테스트 함수가 픽스처를 요청하지 않습니다
INSP.NAME.redeclaration=사용되지 않고 다시 선언된 이름
INSP.NAME.redundant.parentheses=불필요한 소괄호
INSP.NAME.relative.import=의심스러운 상대적 import 문
INSP.NAME.requirements=충족되지 않은 패키지 요구 사항
INSP.NAME.set.function.to.literal=함수 호출을 집합 리터럴로 바꿀수 있습니다
INSP.NAME.shadowing.builtins=기본 제공 이름을 가림
INSP.NAME.single.quoted.docstring=작은 따옴표 docstring
INSP.NAME.statement.effect=명령문이 영향을 주지 않습니다
INSP.NAME.str.format=문자열 서식 지정 작업 오류
INSP.NAME.too.broad.exception.clauses=명확하지 않은 예외 절
INSP.NAME.trailing.semicolon=구문 내 금지된 후행 세미콜론
INSP.NAME.tuple.assignment.balance=튜플 할당 밸런스가 올바르지 않습니다
INSP.NAME.tuple.item.assignment=튜플 항목 대입 금지
INSP.NAME.type.checker=잘못된 타입
INSP.NAME.type.hints=잘못된 타입 힌트 정의 및 사용
INSP.NAME.typed.dict=잘못된 TypedDict 정의 및 사용
INSP.NAME.unbound=바운드되지 않은 지역 변수
INSP.NAME.unnecessary.backslash=불필요한 백슬래시
INSP.NAME.unreachable.code=도달할 수 없는 코드
INSP.NAME.unresolved.refs=해결되지 않는 참조
INSP.NAME.unused=사용하지 않는 지역 심볼
INSP.NAME.wrong.super.arguments=잘못된 super 호출 인수
INSP.abstract.class.add.to.superclasses=상위 클래스에 ''{0}'' 추가
INSP.abstract.class.class.must.implement.all.abstract.methods=클래스 {0}이(가) 모든 추상 메서드를 구현해야 합니다
INSP.abstract.class.set.as.metaclass=''{0}''을(를) 메타 클래스로 설정
INSP.argument.equals.to.default=인수가 디폴트 매개변수 값과 같습니다
INSP.arguments.not.declared.but.provided.by.decorator=다음 인수가 선언되지 않지만 데코레이터에 의해 제공됩니다. {0}
INSP.assignment.can.be.replaced.with.augmented.assignment=대입을 증분 대입으로 바꿀 수 있습니다
INSP.assignment.to.loop.or.with.parameter=변수 ''{0}''이(가) 위의 ''for'' 루프 또는 ''with'' 문에서 이미 선언되었습니다
INSP.async.call=코루틴 호출에 'await' 구문 누락
INSP.attribute.outside.init=__init__ 외부에 정의된 인스턴스 속성 {0}  
INSP.auto.to.manual.field.numbering=자동 필드 번호 표기에서 수동 필드 사양으로 전환할 수 없습니다
INSP.bad.except.exception.class.already.caught=예외 클래스 ''{0}''이(가) 이미 포착되었습니다
INSP.bad.except.superclass.of.exception.class.already.caught=예외 클래스 ''{1}''의 상위 클래스인 ''{0}''이(가) 이미 포착되었습니다
INSP.byte.literal.contains.illegal.characters=바이트 리터럴 내 문자가 255개를 초과합니다
INSP.cant.return.value.from.init=__init__에서 값을 반환할 수 없습니다
INSP.chained.comparisons.ignore.statements.with.constant.in.the.middle=중간에 상수가 있는 구문 무시
INSP.class.has.no.init=클래스에 __init__ 메서드가 없습니다
INSP.class.is.not.subtype.of.class=''{0}''이(가) ''{1}''의 인스턴스 또는 하위 클래스가 아닙니다
INSP.class.object.is.not.callable=''{0}'' 객체를 호출할 수 없습니다
INSP.class.var.can.be.used.only.in.class.body='ClassVar'는 클래스 본문의 대입에만 사용할 수 있습니다.
INSP.class.var.can.not.be.assigned.to.instance=인스턴스를 통해 클래스 변수 ''{0}''에 대입할 수 없습니다.
INSP.class.var.can.not.be.used.in.annotation.for.function.return.value='ClassVar'은 함수 반환 값에 대한 어노테이션에 사용할 수 없습니다.
INSP.class.var.can.not.be.used.in.annotations.for.function.parameters=함수 매개변수에 대한 어노테이션에서 'ClassVar' 를 사용할 수 없습니다.
INSP.class.var.can.not.be.used.in.function.body='ClassVar'는 로컬 변수에 대한 어노테이션에서 사용할 수 없습니다.
INSP.class.var.can.not.include.type.variables='ClassVar' 매개변수는 타입 변수를 포함할 수 없습니다
INSP.class.var.can.not.override.class.variable=클래스 변수 ''{0}''(이전에 기본 클래스 ''{1}''에 선언됨)을(를) 인스턴스 변수로 재정의할 수 없습니다.
INSP.class.var.can.not.override.instance.variable=인스턴스 변수 ''{0}''(이전에 기본 클래스 ''{1}''에 선언됨)을(를) 클래스 변수로 재정의할 수 없습니다.
INSP.classic.class.usage.old.style.class=이전 스타일 클래스
INSP.classic.class.usage.old.style.class.ancestors=상속받은 모든 클래스가 예전 스타일이기 때문에, 예전 스타일 클래스
INSP.comparison.with.none.performed.with.equality.operators=상등 연산자로 수행된 None과의 비교
INSP.compatibility.basestring.type.not.available.in.py3=basestring 타입은 Python3에서 사용할 수 없습니다
INSP.compatibility.check.for.compatibility.with.python.versions=Python 버전과의 호환성을 확인하세요:
INSP.compatibility.feature.allow.async.and.await.as.names='async' 및 'await'를 이름으로 허용하지 않습니다
INSP.compatibility.feature.allow.backslashes.in.f-strings=f 문자열의 식 내부에 백슬래시 허용
INSP.compatibility.feature.allow.deep.expression.nesting.in.f-strings=이 깊이의 서식 지정자 내에서 중첩 식 허용
INSP.compatibility.feature.allow.duplicate.kwargs=중복 **표현식을 허용하지 않습니다
INSP.compatibility.feature.allow.duplicate.positional.varargs=중복 **표현식을 허용하지 않습니다
INSP.compatibility.feature.allow.keyword.arguments.after.kwargs=**표현식 뒤 키워드 인수를 허용하지 않습니다
INSP.compatibility.feature.allow.new.lines.in.f-strings=세 번 따옴표로 둘러싸인 f 문자열의 식 부분에서 새로운 행 허용
INSP.compatibility.feature.allow.positional.arguments.after.expression=*표현식 뒤 위치 인수를 허용하지 않습니다
INSP.compatibility.feature.allow.quote.reuse.in.f-strings=f 문자열 내의 같은 따옴표 타입을 사용하는 문자열 리터럴을 중첩하도록 허용
INSP.compatibility.feature.allow.to.mix.bytes.and.non.bytes.literals=바이트 리터럴과 비 바이트 리터럴의 혼용을 허용하지 않습니다
INSP.compatibility.feature.allow.trailing.comma.after.kwargs=**표현식 뒤 키워드 후행 쉼표를 허용하지 않습니다
INSP.compatibility.feature.allow.trailing.comma.after.positional.vararg=*표현식 뒤 위치 후행 쉼표를 허용하지 않습니다
INSP.compatibility.feature.have.method=메서드 {0}을(를) 포함하지 않습니다
INSP.compatibility.feature.have.module=모듈 {0}을(를) 포함하지 않습니다
INSP.compatibility.feature.have.module.builtin=모듈 __builtin__을 포함하지 않습니다
INSP.compatibility.feature.have.module.builtins=내장 모듈을 포함하지 않습니다
INSP.compatibility.feature.have.nonlocal.keyword=로컬이 아닌 키워드를 포함하지 않습니다
INSP.compatibility.feature.have.type.long=타입 long을 포함하지 않습니다. 대신 int를 사용하세요.
INSP.compatibility.feature.line.comments.in.f-strings=f 문자열의 식 내부에서 주석 허용
INSP.compatibility.feature.support.arbitrary.expressions.as.decorator=임의 표현식을 데코레이터로서 지원하지 않습니다
INSP.compatibility.feature.support.assignment.expressions=대입 표현식을 지원하지 않습니다
INSP.compatibility.feature.support.backquotes=역따옴표를 지원하지 않습니다. 대신 repr()을 사용하세요
INSP.compatibility.feature.support.continue.inside.finally.clause='finally' 절 내부에 'continue'를 지원하지 않습니다
INSP.compatibility.feature.support.diamond.operator=<>를 지원하지 않습니다. 대신 !=를 사용하세요
INSP.compatibility.feature.support.ellipsis.outside.slices=시퀀스 슬라이싱 외부의 '...'를 지원하지 않습니다
INSP.compatibility.feature.support.long.integer.literal.suffix=후행 ''{0}''을(를) 지원하지 않습니다
INSP.compatibility.feature.support.match.statements=일치 구문 지원
INSP.compatibility.feature.support.matrix.multiplication.operators=행렬 곱셈 연산자를 지원하지 않습니다
INSP.compatibility.feature.support.old.style.octal.literals=이 구문을 지원하지 않습니다. 8진 리터럴의 경우 '0o' 접두사가 필요합니다
INSP.compatibility.feature.support.parenthesized.context.expressions=괄호로 둘러싼 컨텍스트 표현 지원
INSP.compatibility.feature.support.positional.only.parameters=위치 전용 매개변수를 지원하지 않습니다
INSP.compatibility.feature.support.print.statement=이 구문을 지원하지 않습니다. print 문은 print() 함수로 교체되었습니다
INSP.compatibility.feature.support.raise.with.no.arguments.outside.except.block=이 구문을 지원하지 않습니다. 인수 없는 발생은 except 블록에서만 사용할 수 있습니다
INSP.compatibility.feature.support.starred.except.part=except* 부분 지원
INSP.compatibility.feature.support.starred.expressions.as.assignment.targets=별표가 있는 표현식을 대입 타깃으로 지원하지 않습니다
INSP.compatibility.feature.support.starred.expressions.in.dicts=딕셔너리에서 별표가 있는 표현식을 지원하지 않습니다
INSP.compatibility.feature.support.starred.expressions.in.subscriptions=구독에서 별표 표시된 표현을 지원합니다.
INSP.compatibility.feature.support.starred.expressions.in.tuples.lists.and.sets=튜플, 리스트, 세트에서 별표가 있는 표현식을 지원하지 않습니다
INSP.compatibility.feature.support.starred.expressions.in.type.annotations=타입 어노테이션에서 별표 표시된 표현식을 지원합니다.
INSP.compatibility.feature.support.string.literal.prefix=''{0}'' 접두사를 지원하지 않습니다
INSP.compatibility.feature.support.super.without.arguments=이 구문을 지원하지 않습니다. Python 2에서 super()에는 인수가 있어야 합니다
INSP.compatibility.feature.support.this.syntax=이 구문을 지원하지 않습니다
INSP.compatibility.feature.support.this.syntax.in.list.comprehensions=리스트 컴프리헨션에서 이 구문을 지원하지 않습니다
INSP.compatibility.feature.support.type.alias.statements=타입 별칭 구문 지원
INSP.compatibility.feature.support.underscores.in.numeric.literals=숫자 리터럴에서 밑줄을 지원하지 않습니다
INSP.compatibility.feature.support.unpacking.without.parentheses.in.return.statements=return 문에서 소괄호 없이 패킹 해제를 지원하지 않습니다
INSP.compatibility.feature.support.unpacking.without.parentheses.in.yield.statements=yield 문에서 소괄호 없이 패킹 해제를 지원하지 않습니다
INSP.compatibility.feature.support.variable.annotations=변수 어노테이션을 지원하지 않습니다
INSP.compatibility.feature.support.yield.from=이 구문을 지원하지 않습니다. 서브 제너레이터로의 위임은 Python 3.3 이후 버전에서 사용할 수 있습니다. 대신 서브 제너레이터에 대해 명시적 반복을 사용하세요.
INSP.compatibility.inspection.unsupported.feature.prefix=Python {0,choice,1#버전|2#버전} {1}은(는) {2}{0,choice,1#|2#}
INSP.compatibility.keyword.argument.repeated=키워드 인수가 반복됩니다
INSP.compatibility.new.union.syntax.not.available.in.earlier.version=공용체 타입을 X | Y로 작성하도록 허용
INSP.compatibility.old.dict.methods.not.available.in.py3=dict.iterkeys(), dict.iteritems(), dict.itervalues() 메서드는 Python 3에서 사용할 수 없습니다
INSP.compatibility.positional.argument.after.keyword.argument=키워드 인수 뒤 위치 인수
INSP.compatibility.positional.argument.after.kwargs=**표현식 뒤 키워드 위치 인수
INSP.compatibility.pre35.versions.do.not.allow.return.with.argument.inside.generator=Python 3.3보다 낮은 버전에서는 제너레이터 내에 인수를 가진 'return'을 허용하지 않습니다
INSP.compatibility.py35.does.not.support.async.inside.comprehensions.and.generator.expressions=Python 버전 3.5는 내포 및 제너레이터 표현식 내부에서 'async'를 지원하지 않습니다
INSP.compatibility.py35.does.not.support.await.inside.comprehensions=Python 버전 3.5는 내포 내부에서 'await'를 지원하지 않습니다
INSP.compatibility.py35.does.not.support.yield.inside.async.functions=Python 버전 3.5는 비동기 함수 내부에서 'yield'를 지원하지 않습니다
INSP.compatibility.support.equality.signs.in.fstrings=f-string에 상등 기호를 지원하지 않습니다
INSP.compatibility.this.syntax.available.only.since.py3=이 구문은 Python 3 이후 버전에서만 사용할 수 있습니다
INSP.dataclasses.argument.ignored.if.class.already.defines.method=클래스가 이미 ''{1}'' 메서드를 정의하는 경우 ''{0}''이(가) 무시됩니다
INSP.dataclasses.attribute.default.set.using.method=디폴트 값은 ''{0}''을(를) 사용하여 설정됩니다
INSP.dataclasses.attribute.lacks.type.annotation=속성 ''{0}''에 타입 어노테이션이 없습니다
INSP.dataclasses.attribute.useless.until.post.init.declared=속성 ''{0}''은(는) ''__post_init__''이 선언되기 전까지 의미가 없습니다
INSP.dataclasses.attrs.post.init.should.not.take.any.parameters.except.self='__attrs_post_init__은 'self'를 제외한 매개변수를 가질 수 없습니다
INSP.dataclasses.attrs.post.init.would.not.be.called.until.init.parameter.set.to.true='__attrs_post_init__'은 'init' 매개변수가 True로 설정되기 전까지 호출되지 않습니다
INSP.dataclasses.cannot.specify.both.default.and.default.factory='default' 및 'default_factory' 둘 다 지정할 수 없습니다
INSP.dataclasses.cannot.specify.both.default.and.factory='default' 및 'factory' 둘 다 지정할 수 없습니다
INSP.dataclasses.eq.must.be.true.if.order.true='order'가 true인 경우 'eq'는 true여야 합니다
INSP.dataclasses.field.cannot.have.default.factory=필드는 디폴트 팩토리를 가질 수 없습니다
INSP.dataclasses.frozen.attribute.should.be.false.if.class.defines.setattr.or.delattr=클래스가 '__setattr__' 또는 '__delattr__'를 정의하는 경우, 'frozen'이 False여야 합니다
INSP.dataclasses.frozen.dataclasses.can.not.inherit.non.frozen.one=데이터 클래스와 동결되지 않은 클래스는 서로를 상속할 수 없습니다
INSP.dataclasses.hash.ignored.if.class.already.defines.cmp.or.order.or.frozen.parameters=클래스가 이미 'cmp/order' 및 'frozen' 매개변수를 정의하는 경우 '__hash__'가 무시됩니다
INSP.dataclasses.method.is.ignored.if.class.already.defines.parameter=클래스가 이미 ''{1}'' 매개변수를 정의하는 경우 ''{0}''이(가) 무시됩니다
INSP.dataclasses.method.should.be.called.on.attrs.instances=''{0}'' 메서드는 속성 인스턴스에서 호출되어야 합니다
INSP.dataclasses.method.should.be.called.on.attrs.types=''{0}'' 메서드는 속성 타입에서 호출되어야 합니다
INSP.dataclasses.method.should.be.called.on.dataclass.instances=''{0}'' 메서드는 데이터 클래스 인스턴스에서 호출되어야 합니다
INSP.dataclasses.method.should.be.called.on.dataclass.instances.or.types=''{0}'' 메서드는 데이터 클래스 인스턴스 또는 타입에서 호출되어야 합니다
INSP.dataclasses.method.should.take.only.n.parameter=''{0}''에는 {1}개의 {1, choice, 1#매개변수| 2#매개변수}만 있어야 합니다
INSP.dataclasses.mutable.attribute.default.not.allowed.use.default.factory=변경 가능한 디폴트 값 ''{0}''은(는) 허용되지 않습니다. ''default_factory''를 사용하세요
INSP.dataclasses.object.attribute.read.only=''{0}'' 객체 속성 ''{1}''이(가) 읽기 전용입니다
INSP.dataclasses.object.could.have.no.attribute.because.it.declared.as.init.only=''{0}'' 객체가 init 전용으로 선언되어 속성 ''{1}''을(를) 가질 수 없습니다
INSP.dataclasses.operator.not.supported.between.instances.of.class=''{1}''의 인스턴스 사이의 ''{0}''은(는) 지원되지 않습니다
INSP.dataclasses.operator.not.supported.between.instances.of.classes=''{1}'' 및 ''{2}''의 인스턴스 사이의 ''{0}''은(는) 지원되지 않습니다
INSP.dataclasses.order.argument.should.be.false.if.class.defines.one.of.order.methods=클래스가 order 메서드 중 하나를 정의하는 경우, 'order'가 False여야 합니다
INSP.dataclasses.post.init.should.take.all.init.only.variables.in.same.order.they.defined='__post_init__'은 모든 init 전용 변수를 정의된 순서대로 취해야 합니다
INSP.dataclasses.post.init.should.take.all.init.only.variables.including.inherited.in.same.order.they.defined='__post_init__'은 모든 init 전용 변수(상속된 변수 포함)를 정의된 순서대로 취해야 합니다
INSP.dataclasses.post.init.would.not.be.called.until.init.parameter.set.to.true='__post_init__'은 'init' 매개변수가 True로 설정되기 전까지 호출되지 않습니다
INSP.dataclasses.unsafe.hash.attribute.should.be.false.if.class.defines.hash=클래스가 '__hash__'를 정의하는 경우, 'unsafe_hash'가 False여야 합니다
INSP.decorator.receives.unexpected.builtin=이 데코레이터는 기대하는 호출 가능한 객체를 받지 않으며, 기본 제공 데코레이터가 특수 객체를 반환합니다
INSP.decorators.method.only.decorator.on.method.outside.class=클래스 외부 메서드의 데코레이터 {0}
INSP.default.arguments.default.argument.value.mutable=디폴트 인수 값은 변경 가능합니다
INSP.deleter.should.not.return=삭제자는 값을 반환하지 않아야 합니다
INSP.deleter.signature.advice=삭제자 시그니처는 (self)이어야 합니다
INSP.deprecation.abc.decorator.deprecated.use.alternative=''{0}''은(는) Python 3.3 이후 버전에서 더 이상 사용되지 않습니다. 대신 ''{2}''와(과) 함께 ''{1}''을(를) 사용하세요
INSP.dict.creation.this.dictionary.creation.could.be.rewritten.as.dictionary.literal=딕셔너리 생성을 딕셔너리 리터럴로 다시 작성할 수 있습니다
INSP.doc.param.should.be.str=doc 매개변수는 문자열이어야 합니다
INSP.docstring.types.change.type={0} 타입을 {1}에서 {2}(으)로 변경
INSP.docstring.types.dynamically.inferred.type.does.not.match.specified.type=동적 추론 타입 ''{0}''이(가) 지정된 타입 ''{1}''와(과) 일치하지 않습니다
INSP.docstring.types.fix.docstring=docstring 수정
INSP.dunder.slots.class.object.attribute.read.only=''{0}'' 객체 속성 ''{1}''은(는) 읽기 전용입니다
INSP.dunder.slots.name.in.slots.conflicts.with.class.variable=__slots__의 ''{0}''은(는) 클래스 변수와 충돌합니다
INSP.duplicate.keys.dictionary.contains.duplicate.keys=딕셔너리에 중복 키 ''{0}''이(가) 있습니다
INSP.empty.docstring=빈 docstring
INSP.exception.inheritance.exception.does.not.inherit.from.base.exception.class=예외는 기본 'Exception' 클래스를 상속하지 않습니다
INSP.expected.dict.got.type=딕셔너리가 필요하나 {0}을(를) 얻었습니다
INSP.expected.iterable.got.type=iterable이 필요하나 {0}을(를) 얻었습니다 
INSP.expression.can.be.simplified=표현식을 단순화할 수 있습니다
INSP.expression.is.not.callable=표현식을 호출할 수 없습니다
INSP.final.already.declared.name.could.not.be.redefined.as.final=이미 선언된 이름은 'Final'로 재정의할 수 없습니다
INSP.final.either.instance.attribute.or.class.attribute.could.be.type.hinted.as.final=인스턴스 속성 또는 클래스 속성 중 하나의 타입 힌트를 'Final'로 지정할 수 있습니다
INSP.final.final.attribute.could.not.be.overridden=''{0}''은(는) ''Final''이므로 재정의할 수 없습니다
INSP.final.final.attribute.should.be.declared.in.class.body.or.init='Final' 속성은 클래스 본문 또는 '__init__' 안에 선언되어야 합니다
INSP.final.final.class.could.not.contain.abstract.methods='Final' 클래스는 abstract 메서드를 포함할 수 없습니다
INSP.final.final.could.not.be.mixed.with.abstract.decorators='Final'은 abstract 데코레이터와 함께 혼용할 수 없습니다
INSP.final.final.could.not.be.used.in.annotation.for.function.return.value='Final'은 함수 반환 값의 어노테이션에서 사용할 수 없습니다
INSP.final.final.could.not.be.used.in.annotations.for.function.parameters='Final'은 함수 매개변수의 어노테이션에서 사용할 수 없습니다
INSP.final.final.could.not.be.used.inside.loop='Final'은 루프 내부에서 사용할 수 없습니다
INSP.final.final.could.only.be.used.as.outermost.type='Final'은 가장 바깥쪽 타입으로만 사용할 수 있습니다
INSP.final.final.name.should.be.initialized.with.value='Final' 이름은 값으로 초기화되어야 합니다
INSP.final.final.should.be.placed.on.first.overload='@final'은 첫 번째 오버로드에 있어야 합니다
INSP.final.final.should.be.placed.on.implementation='@final'은 구현에 있어야 합니다
INSP.final.final.target.could.not.be.reassigned=''{0}''은(는) ''Final''이므로 다시 대입할 수 없습니다
INSP.final.if.assigned.value.omitted.there.should.be.explicit.type.argument.to.final=대입된 값이 생략된 경우 'Final'에 명시적 타입 인수가 있어야 합니다
INSP.final.method.marked.as.final.should.not.be.overridden=''{0}''은(는) ''@final''로 표시되었으므로 재정의될 수 없습니다
INSP.final.no.need.to.mark.method.in.final.class.as.final='Final' 클래스의 메서드를 '@final'로 표시할 필요가 없습니다
INSP.final.non.method.function.could.not.be.marked.as.final=비 메서드 함수는 '@final'로 표시할 수 없습니다
INSP.final.super.classes.are.marked.as.final.and.should.not.be.subclassed={0}{1,choice,1#은(는)|2#은(는)} ''@final''로 표시되었으므로 하위 클래스가 될 수 없습니다
INSP.first.arg.assign.method.parameter.reassigned=메서드 매개변수 ''{0}''이(가) 다시 할당되었습니다
INSP.first.param.must.not.be.tuple=비 static 메서드의 첫 번째 매개변수는 튜플이 아니어야 합니다
INSP.format.requires.mapping=형식에는 매핑이 필요합니다
INSP.format.requires.no.mapping=형식에는 매핑이 필요하지 않습니다
INSP.from.future.import.from.future.imports.must.occur.at.beginning.file=from __future__ import는 파일 시작 부분에 있어야 합니다
INSP.func.property.name.mismatch=함수 및 데코레이터 이름이 일치하지 않습니다. 프로퍼티 접근자가 생성되지 않았습니다.
INSP.function.lacks.positional.argument=함수 ''{0}''에 위치 인수가 부족합니다
INSP.getter.return.smth=getter가 무언가 반환하거나 산출해야합니다
INSP.getter.signature.advice=getter 시그니처는 (self)이어야 합니다
INSP.global.variable.undefined=전역 변수 ''{0}''이(가) 모듈 수준에서 undefined입니다
INSP.incompatible.options=청크 "{0}"의 형식 옵션이 호환되지 않습니다
INSP.inconsistent.indentation.mix.tabs.spaces=일관되지 않은 들여쓰기: 탭과 공백 혼용
INSP.inconsistent.indentation.previous.line.used.spaces.this.line.uses.tabs=일관되지 않은 들여쓰기: 이전 줄에서는 공백이 사용되고, 이 줄에서는 탭이 사용되었습니다
INSP.inconsistent.indentation.previous.line.used.tabs.this.line.uses.spaces=일관되지 않은 들여쓰기: 이전 줄에서는 탭이 사용되고, 이 줄에서는 공백이 사용되었습니다
INSP.init.incompatible.to.new=시그니처가 __new__로 호환되지 않습니다 
INSP.interpreter.configure.python.interpreter=Python 인터프리터 구성
INSP.interpreter.interpreter.settings=인터프리터 설정
INSP.interpreter.invalid.python.interpreter.selected.for.module=모듈에 잘못된 Python 인터프리터가 선택되었습니다
INSP.interpreter.invalid.python.interpreter.selected.for.project=프로젝트에 잘못된 Python 인터프리터가 선택되었습니다
INSP.interpreter.no.python.interpreter.configured.for.module=모듈에 대해 구성된 Python 인터프리터가 없습니다
INSP.interpreter.no.python.interpreter.configured.for.project=프로젝트에 대해 구성된 Python 인터프리터가 없습니다
INSP.interpreter.pipenv.interpreter.associated.with.another.module=Pipenv 인터프리터가 다른 모듈과 연결되어 있습니다. ''{0}''
INSP.interpreter.pipenv.interpreter.associated.with.another.project=Pipenv 인터프리터가 다른 프로젝트와 연결되어 있습니다. ''{0}''
INSP.interpreter.pipenv.interpreter.not.associated.with.any.module=Pipenv 인터프리터가 어느 모듈과도 연결되어 있지 않습니다
INSP.interpreter.pipenv.interpreter.not.associated.with.any.project=Pipenv 인터프리터가 어느 프로젝트와도 연결되어 있지 않습니다
INSP.interpreter.python.has.reached.its.end.life.and.is.no.longer.supported.in.python.plugin=Python {0}이(가) 지원 종료일에 도달하여 Python 플러그인에서 더 이상 지원되지 않습니다
INSP.interpreter.python.has.reached.its.end.of.life.and.is.no.longer.supported.in.pycharm=Python {0}이(가) 지원 종료일에 도달하여 PyCharm에서 더 이상 지원되지 않습니다
INSP.interpreter.use.interpreter={0} 사용
INSP.interpreter.use.suggested.interpreter=제안된 인터프리터 사용
INSP.list.creation.this.list.creation.could.be.rewritten.as.list.literal=다중 스텝 목록 초기화를 목록 리터럴로 바꿀 수 있습니다
INSP.mandatory.encoding.checkbox.enable.in.python.3=Python 3에서 활성화
INSP.mandatory.encoding.label.encoding.comment.format=주석 인코딩 형식:
INSP.mandatory.encoding.label.select.default.encoding=기본 인코딩 선택:
INSP.mandatory.encoding.no.encoding.specified.for.file=파일에 지정된 인코딩이 없습니다
INSP.manual.to.auto.field.numbering=수동 필드 사양에서 자동 필드 번호 표기로 전환할 수 없습니다
INSP.message.single.quoted.docstring=삼중 작은 따옴표 문자열이 docstrings에 사용되어야 합니다.
INSP.method.may.be.static=메서드 <code>#ref</code>가 'static'일 수 있습니다
INSP.method.parameters.metaclass.method.first.argument.name=메타 클래스 메서드 첫 번째 인수 이름
INSP.missing.parameter.in.docstring=docstring 내 누락된 매개변수 {0}
INSP.missing.super.constructor.message=상위 클래스 __init__ 호출이 누락되었습니다
INSP.missing.type.hints.add.type.hints=타입 힌트 추가
INSP.missing.type.hints.add.type.hints.for=''{0}''에 대한 타입 힌트 추가
INSP.missing.type.hints.checkbox.only.when.types.are.known=타입이 알려진 경우에만(런타임에서 수집 또는 추론)
INSP.missing.type.hints.type.hinting.missing.for.function.definition=함수 정의에 대한 타입 힌트가 누락되었습니다
INSP.must.have.first.parameter=메서드는 일반적으로 ''{0}'' 인 첫 번째 매개변수를 갖고 있어야 합니다
INSP.named.tuple='typing.NamedTuple'의 잘못된 정의
INSP.new.incompatible.to.init=시그니처가 __init__로 호환되지 않습니다 
INSP.new.style.generics.are.not.allowed.inside.type.param.bounds=제네릭 타입은 타입 매개변수의 제한 및 제약 내에서 사용할 수 없습니다
INSP.new.style.generics.assignment.expressions.not.allowed=타입 매개변수 목록이 있는 클래스, 함수 및 타입 별칭의 선언 내에서는 식을 대입할 수 없습니다
INSP.new.style.generics.classes.with.type.param.list.should.not.extend.generic=타입 매개변수 목록이 있는 클래스는 'Generic'을 확장할 수 없습니다
INSP.new.style.generics.extending.protocol.does.not.need.parameterization='Protocol'을 확장하기 위해 클래스 내에서 타입 매개 변수 목록으로 매개변수화를 하지 않아도 됩니다
INSP.new.style.generics.mixing.old.style.and.new.style.type.vars.not.allowed=기존 형식과 새로운 형식의 타입 매개변수를 혼합할 수 없습니다
INSP.new.style.generics.old.style.type.vars.not.allowed.in.new.style.type.aliases=기존의 TypeVars는 새로운 형식의 타입 별칭 구문 내에서는 사용할 수 없습니다
INSP.no.docstring=누락된 docstring
INSP.no.format.specifier.char=형식 지정자 문자가 누락되었습니다
INSP.non.ascii.char.non.ascii.character.in.file.but.no.encoding.declared=파일에 ASCII가 아닌 문자 ''{0}''이(가) 있으나 선언된 인코딩이 없습니다
INSP.none.function.assignment=함수 ''{0}''이(가) 아무것도 반환하지 않습니다
INSP.oldstyle.class.getattribute=이전 스타일 클래스가 __getattribute__ 정의를 포함합니다
INSP.oldstyle.class.slots=이전 스타일 클래스가 __slots__ 정의를 포함합니다
INSP.oldstyle.class.super=이전 스타일 클래스가 상위 메서드 호출을 포함합니다
INSP.overloads.series.overload.decorated.functions.should.always.be.followed.by.implementation=일련의 @overload-decorated 함수 다음에는 @overload-ed가 아닌 구현이 와야 합니다
INSP.overloads.series.overload.decorated.methods.should.always.be.followed.by.implementation=일련의 @overload-decorated 메서드 다음에는 @overload-ed가 아닌 구현이 와야 합니다
INSP.overloads.this.function.overload.signature.not.compatible.with.implementation=이 @overload-decorated 함수의 시그니처는 구현과 호환되지 않습니다
INSP.overloads.this.method.overload.signature.not.compatible.with.implementation=이 @overload-decorated 메서드의 시그니처는 구현과 호환되지 않습니다
INSP.override.missing.super.method=재정의에 super 메서드가 누락되었습니다
INSP.package.requirements.add.import=가져오기 추가
INSP.package.requirements.administrator.privileges.required=관리자 권한 필요
INSP.package.requirements.administrator.privileges.required.button.configure=구성
INSP.package.requirements.administrator.privileges.required.button.install.anyway=그래도 설치
INSP.package.requirements.administrator.privileges.required.description=''{0}''로 패키지를 설치하려면 관리자 권한이 필요합니다.\n\
\n\
파일 시스템의 보호된 영역에 프로젝트를 설치하지 않도록 프로젝트별 가상 환경을 프로젝트 인터프리터로 구성하세요.
INSP.package.requirements.requirement.has.been.ignored=''{0}''이(가) 무시되었습니다
INSP.package.requirements.requirements.file.empty=Requirements 파일이 비어 있습니다
INSP.package.requirements.requirements.have.been.ignored=Requirements가 무시되었습니다
INSP.pandas.series.values.replace.with.tolist=메서드 Series.to_list()가 추천됩니다
INSP.parameter(s).unfilled=매개변수가 채워지지 않았습니다
INSP.parameter.unfilled=매개변수 ''{0}''이(가) 채워지지 않았습니다
INSP.pep8.coding.style.violation=PEP 8 코딩 스타일 위반
INSP.pep8.ignore.base.class=기본 클래스 무시
INSP.pep8.ignore.method.names.for.descendants.of.class=하위 클래스에 대한 메서드 이름 무시
INSP.pep8.naming.argument.name.should.be.lowercase=인수 이름은 소문자여야 합니다
INSP.pep8.naming.camelcase.variable.imported.as.constant=상수로 가져온 낙타 표기 변수
INSP.pep8.naming.camelcase.variable.imported.as.lowercase=소문자 변수로 가져온 낙타 표기 변수
INSP.pep8.naming.class.names.should.use.capwords.convention=클래스 이름은 CapWords 규칙을 사용해야 합니다
INSP.pep8.naming.column.name.excluded.base.classes=제외된 기본 클래스:
INSP.pep8.naming.column.name.ignored.errors=무시된 오류:
INSP.pep8.naming.constant.variable.imported.as.non.constant=상수가 아닌 변수로 가져온 상수 변수
INSP.pep8.naming.function.name.should.be.lowercase=함수 이름은 소문자여야 합니다
INSP.pep8.naming.lowercase.variable.imported.as.non.lowercase=소문자가 아닌 변수로 가져온 소문자 변수
INSP.pep8.naming.variable.in.function.should.be.lowercase=함수 내 변수는 소문자여야 합니다
INSP.possible.callees=가능한 피호출자
INSP.probably.mistyped.self='self'가 아닙니까?
INSP.property.cannot.be.deleted=프로퍼티 ''{0}''을(를) 삭제할 수 없습니다
INSP.property.cannot.be.read=프로퍼티 ''{0}''을(를) 읽을 수 없습니다
INSP.property.cannot.be.set=프로퍼티 ''{0}''을(를) 설정할 수 없습니다
INSP.protected.member.access.to.protected.member.of.class=\ 클래스의 protected 멤버 {0}에 대한 액세스
INSP.protected.member.access.to.protected.member.of.module=\ 모듈의 protected 멤버 {0}에 대한 액세스
INSP.protected.member.ignore.annotations=어노테이션 무시
INSP.protected.member.ignore.test.functions=테스트 함수 무시
INSP.protected.member.name.not.declared.in.all=''{0}''이(가) __all__에 선언되어 있지 않습니다
INSP.protocol.all.bases.protocol.must.be.protocols=프로토콜의 모든 기본은 프로토콜이어야 합니다
INSP.protocol.element.type.incompatible.with.protocol=''{0}''의 타입은 ''{1}''와(과) 호환되지 않습니다
INSP.protocol.newtype.cannot.be.used.with.protocol.classes=NewType은 프로토콜 클래스에 사용할 수 없습니다
INSP.protocol.only.runtime.checkable.protocols.can.be.used.with.instance.class.checks=인스턴스 및 클래스 검사에는 @runtime_checkable 프로토콜만 사용할 수 있습니다
INSP.python.suppressor.suppress.for.class=클래스에 대해 억제
INSP.python.suppressor.suppress.for.function=함수에 대해 억제
INSP.python.suppressor.suppress.for.statement=구문에 대해 억제
INSP.python.trailing.suffix.not.support=Python은 후행 ''{0}''을(를) 지원하지 않습니다
INSP.redeclared.name=위에서 정의된 ''{0}''이(가) 사용되지 않고 다시 선언되었습니다
INSP.redundant.parens.ignore.argument.of.operator=% 연산자의 인수 무시
INSP.redundant.parens.ignore.empty.lists.of.base.classes=기본 클래스의 빈 리스트 무시
INSP.redundant.parens.ignore.tuples=튜플 무시
INSP.relative.import.relative.import.outside.package=패키지 외부의 상대적 가져오기
INSP.requirements.ignore.packages.label=무시된 패키지:
INSP.requirements.package.containing.module.not.listed.in.project.requirements=모듈 ''{0}''을(를) 포함하는 패키지는 프로젝트 requirements 목록에 없습니다
INSP.requirements.package.requirements.not.satisfied=패키지 {1,choice,1#requirement|2#requirement} {0}{1,choice,1#이(가)|2#이(가)} 충족되지 않았습니다
INSP.setter.should.not.return=세터는 값을 반환해지 않아야 합니다
INSP.setter.signature.advice=Setter 시그니처는 (self,value) 이어야 합니다
INSP.shadowing.builtins.ignore.built.ins.label=무시된 내장 항목:
INSP.shadowing.builtins.shadows.built.in.name=기본 제공 이름 "{0}" 가리기
INSP.shadowing.names=외부 범위로부터 이름 가림
INSP.shadows.name.from.outer.scope=외부 범위의 이름 ''{0}'' 가리기
INSP.signature.mismatch=메서드 ''{0}''의 시그니처가 클래스 ''{1}'' 내 기본 메서드의 시그니처와 일치하지 않습니다
INSP.simplify.boolean.check.ignore.comparison.to.zero=0에 대한 비교 무시
INSP.simplify.chained.comparison=체인 비교 단순화
INSP.statement.effect.statement.having.no.effect.can.be.replaced.with.function.call=구문이 아무 효과가 없는 듯 보입니다. 함수 호출로 바꾸면 효과가 생깁니다
INSP.statement.effect.statement.seems.to.have.no.effect=명령문이 아무 영향을 미치지 않는 것으로 보입니다
INSP.str.format.can.not.use.star.in.formats.when.using.mapping=매핑을 사용할 경우, 형식에 '*'를 사용할 수 없습니다
INSP.str.format.key.has.no.argument=키 ''{0}''에 해당 인수가 없습니다
INSP.str.format.unexpected.argument.type=예기치 않은 타입 {0}
INSP.str.format.unsupported.format.character.b=지원되지 않는 형식 문자 'b'
INSP.strange.arg.want.callable=이상한 인수; 호출 가능한 인수가 필요합니다
INSP.stub.packages=스텁 패키지 애드버타이저
INSP.stub.packages.compatibility=호환되지 않는 스텁 패키지
INSP.stub.packages.compatibility.ignore=''{0}'' 호환성 무시
INSP.stub.packages.compatibility.ignored.packages.label=무시한 스텁 패키지:
INSP.stub.packages.compatibility.incompatible.packages.message=''{0}{1}{2}''은(는) ''{3}{4}{5}''와(과) 호환되지 않습니다. ''{6}'' 버전이 필요합니다. [{7}]
INSP.symbol.is.not.callable=''{0}''을(를) 호출할 수 없습니다
INSP.too.broad.exception.clause=너무 광범위한 예외 절
INSP.too.few.args.for.fmt.string=형식 문자열에 대한 인수가 너무 적습니다
INSP.too.few.keys=매핑 키가 너무 적습니다
INSP.too.many.args.for.fmt.string=형식 문자열에 대한 인수가 너무 많습니다
INSP.trailing.semicolon=명령문 내 후행 세미콜론
INSP.try.except.import.error=''except ImportError''가 있는 try 블록의 ''{0}''이(가) except 블록에서도 정의되어야 합니다
INSP.tuple.assignment.balance.need.more.values.to.unpack=패킹 해제할 값이 더 필요합니다
INSP.tuple.assignment.balance.only.one.starred.expression.allowed.in.assignment=별표가 있는 표현식은 대입에서 하나만 허용됩니다
INSP.tuple.assignment.balance.too.many.values.to.unpack=패킹 해제할 값이 너무 많습니다
INSP.tuples.never.assign.items=Tuple이 항목 대입을 지원하지 않습니다
INSP.type.checker.expected.matched.type.got.type.instead=타입 ''{0}''(일치하는 제네릭 타입 ''{1}'')이(가) 필요하나 대신 ''{2}''을(를) 받았습니다
INSP.type.checker.expected.to.return.type.got.no.return=''{0}'' 반환이 필요하나 반환된 것이 없습니다
INSP.type.checker.expected.type.got.type.instead=타입 ''{0}''이(가) 필요하나 대신 ''{1}''을(를) 얻었습니다
INSP.type.checker.expected.types.prefix=가능한 타입:
INSP.type.checker.init.should.return.none=__init__은 None을 반환해야 합니다
INSP.type.checker.only.concrete.class.can.be.used.where.matched.protocol.expected=''{0}''(일치하는 제네릭 타입 ''{1}'') 프로토콜이 필요한 곳에는 구체 클래스만 사용할 수 있습니다
INSP.type.checker.only.concrete.class.can.be.used.where.protocol.expected=''{0}'' 프로토콜이 필요한 곳에는 구체 클래스만 사용할 수 있습니다
INSP.type.checker.type.does.not.have.expected.attribute=타입 ''{0}''에 필요한 {1,choice,1#속성|2#속성} {2}이(가) 없습니다
INSP.type.checker.typed.dict.extra.key=TypedDict ''{1}''에 대한 추가적인 키 ''{0}''
INSP.type.checker.typed.dict.missing.keys=TypedDict ''{0}''에 다음의 {1,choice,1#키|2#키}가 없습니다. {2}
INSP.type.checker.unexpected.argument.from.paramspec=(ParamSpec ''{0}''에서) 예기치 않은 인수
INSP.type.checker.unexpected.types.prefix=예기치 않은 타입:
INSP.type.checker.unfilled.parameter.for.paramspec=(ParamSpec ''{1}''에서) 매개변수 ''{0}''이(가) 채워지지 않았습니다.
INSP.type.checker.unfilled.vararg=매개변수 ''{0}''이(가) 입력되지 않았습니다. ''{1}''이(가) 필요합니다
INSP.type.hints.annotated.must.be.called.with.at.least.two.arguments='Annotated'는 최소 두 개의 인수와 함께 호출되어야 합니다
INSP.type.hints.argument.to.paramspec.must.be.string.equal.to.variable.name='ParamSpec()'인수는 대입된 변수 이름과 동일한 문자열이어야 합니다
INSP.type.hints.argument.to.typevar.must.be.string.equal.to.variable.name='TypeVar()'인수는 대입된 변수 이름과 동일한 문자열이어야 합니다
INSP.type.hints.argument.to.typevar.tuple.must.be.string.equal.to.variable.name='TypeVarTuple()' 인수는 대입된 변수 이름과 동일한 문자열이어야 합니다
INSP.type.hints.bivariant.type.variables.are.not.supported=이변적 타입 변수는 지원되지 않습니다
INSP.type.hints.builtin.cannot.be.parameterized.directly=내장 ''{0}''은(는) 직접 매개변수화할 수 없습니다
INSP.type.hints.cannot.inherit.from.generic.multiple.times='Generic[...]'을 여러 번 상속할 수 없습니다
INSP.type.hints.cannot.inherit.from.plain.generic=일반 'Generic'을 상속할 수 없음
INSP.type.hints.generics.should.be.specified.through.square.brackets=제네릭은 대괄호를 사용해 지정해야 합니다
INSP.type.hints.illegal.callable.format='Callable'을 'Callable[[arg, ...], result]'로 사용해야 합니다
INSP.type.hints.illegal.first.parameter=첫 번째 'Callable' 매개변수는 매개변수 식이어야 합니다
INSP.type.hints.illegal.literal.parameter='Literal'은 리터럴 int, 바이트 및 유니코드 문자열, bool, 열거형 값, None, 기타 리터럴 타입이나 기타 리터럴 타입의 타입 별칭으로 매개변수화할 수 있습니다
INSP.type.hints.invalid.type.self=잘못된 타입 'self'
INSP.type.hints.literal.must.have.at.least.one.parameter='Literal'에는 최소 하나의 매개변수가 있어야 합니다
INSP.type.hints.non.self.attribute.could.not.be.type.hinted=self가 아닌 속성은 타입 힌트로 지정할 수 없습니다
INSP.type.hints.parameterized.generics.cannot.be.used.with.instance.class.checks=인스턴스 및 클래스 검사에는 매개변수화된 제네릭을 사용할 수 없습니다
INSP.type.hints.parameters.to.generic.must.all.be.type.variables='Generic[...]'의 매개변수는 모두 타입 변수여야 합니다
INSP.type.hints.parameters.to.generic.must.all.be.unique='Generic[...]'의 매개변수는 모두 고유해야 합니다
INSP.type.hints.parameters.to.generic.types.cannot.contain.more.than.one.unpacking=제네릭의 매개변수는 하나 이상의 언패킹을 포함할 수 없습니다
INSP.type.hints.parameters.to.generic.types.must.be.types=제네릭 타입의 매개변수는 타입이어야 합니다
INSP.type.hints.paramspec.expects.string.literal.as.first.argument='ParamSpec()'에는 첫 번째 인수로 문자열 리터럴이 필요합니다
INSP.type.hints.self.use.for.cls.parameter.with.self.annotation='cls' 매개변수에 'Self' 어노테이션이 추가되지 않은 경우 'Self'를 사용할 수 없습니다
INSP.type.hints.self.use.for.self.parameter.with.self.annotation='self' 매개변수에 'Self' 어노테이션이 추가되지 않은 경우 'Self'를 사용할 수 없습니다
INSP.type.hints.self.use.in.staticmethod='Self'를 staticmethod 내에서 사용할 수 없습니다
INSP.type.hints.self.use.outside.class='Self'를 클래스 밖에서 사용할 수 없습니다
INSP.type.hints.single.typevar.constraint.not.allowed=단일 상수는 허용되지 않습니다
INSP.type.hints.some.type.variables.are.not.listed.in.generic=일부 타입 변수({0})가 ''Generic[{1}]'' 목록에 없습니다
INSP.type.hints.type.alias.cannot.be.parameterized='TypeAlias'는 매개변수화될 수 없습니다
INSP.type.hints.type.alias.must.be.immediately.initialized=타입 별칭을 즉시 초기화해야 합니다
INSP.type.hints.type.alias.must.be.top.level.declaration=타입 별칭은 최상위 선언이어야 합니다
INSP.type.hints.type.alias.must.be.used.as.standalone.type.hint='TypeAlias'는 독립실행형 타입 힌트로 사용되어야 합니다
INSP.type.hints.type.cannot.be.used.with.instance.class.checks=''{0}''은(는) 인스턴스 및 클래스 검사에 사용할 수 없습니다
INSP.type.hints.type.comment.cannot.be.matched.with.unpacked.variables=타입 주석이 패킹 해제된 변수와 일치할 수 없습니다
INSP.type.hints.type.self.not.supertype.its.class=self ''{0}''의 타입은 해당 클래스 ''{1}''의 상위 타입이 아닙니다
INSP.type.hints.type.signature.has.too.few.arguments=타입 시그니처의 인수가 너무 적습니다
INSP.type.hints.type.signature.has.too.many.arguments=타입 시그니처의 인수가 너무 많습니다
INSP.type.hints.type.specified.both.in.type.comment.and.annotation=타입 주석과 어노테이션 모두에 지정된 타입
INSP.type.hints.type.var.tuple.must.always.be.unpacked=TypeVarTuple은 항상 언패킹되어야 합니다
INSP.type.hints.type.variables.cannot.be.used.with.instance.class.checks=인스턴스 및 클래스 검사에는 타입 변수를 사용할 수 없습니다
INSP.type.hints.type.variables.must.not.be.redefined=타입 변수는 재정의하면 안 됩니다
INSP.type.hints.typevar.constraints.cannot.be.combined.with.bound=제약은 bound=…와 결합할 수 없습니다
INSP.type.hints.typevar.constraints.cannot.be.parametrized.by.type.variables=제약은 타입 변수로 매개변수화될 수 없습니다
INSP.type.hints.typevar.expects.string.literal.as.first.argument='TypeVar()'에는 첫 번째 인수로 문자열 리터럴이 필요합니다
INSP.type.hints.typevar.expression.must.be.always.directly.assigned.to.variable='TypeVar()' 표현식은 항상 변수에 직접 대입해야 합니다
INSP.type.hints.typevar.tuple.expects.string.literal.as.first.argument='TypeVarTuple()'에는 첫 번째 인수로 문자열 리터럴이 필요합니다
INSP.type.hints.typing.self.cannot.be.parameterized='Self'는 매개변수화될 수 없습니다
INSP.typeddict.cannot.add.non.string.key.to.typeddict=TypedDict "{0}"에 문자열이 아닌 키를 추가할 수 없습니다
INSP.typeddict.cannot.be.required.and.not.required.at.the.same.time=키를 요구하면서 동시에 요구하지 않을 수 없습니다
INSP.typeddict.cannot.overwrite.typeddict.field=TypedDict 필드를 덮어쓸 수 없습니다
INSP.typeddict.cannot.overwrite.typeddict.field.while.merging=병합 도중 TypedDict 필드 ''{0}''을(를) 덮어쓸 수 없습니다
INSP.typeddict.first.argument.has.to.match.variable.name=첫 번째 인수는 변수 이름과 일치해야 합니다
INSP.typeddict.invalid.statement.in.typeddict.definition.expected.field.name.field.type=TypedDict 정의에 잘못된 구문이 있습니다. 'field_name: field_type'이 필요합니다
INSP.typeddict.key.cannot.be.deleted=TypedDict ''{1}''의 키 ''{0}''을(를) 삭제할 수 없습니다
INSP.typeddict.key.should.be.string=키는 문자열이어야 합니다
INSP.typeddict.required.notrequired.cannot.be.used.outside.typeddict.definition=''{0}''은(는) TypedDict 정의에서만 사용될 수 있습니다
INSP.typeddict.required.notrequired.must.have.exactly.one.type.argument=''{0}''은(는) 정확히 하나의 인수만 가질 수 있습니다
INSP.typeddict.right.hand.side.values.are.not.supported.in.typeddict=TypedDict에서는 오른쪽 값이 지원되지 않습니다
INSP.typeddict.specifying.metaclass.not.allowed.in.typeddict=TypedDict에서는 메타 클래스 지정이 허용되지 않습니다
INSP.typeddict.this.operation.might.break.typeddict.consistency=이 작업은 TypedDict 일관성을 해칠 수 있습니다
INSP.typeddict.total.value.must.be.true.or.false='total'의 값은 True 또는 False여야 합니다
INSP.typeddict.typeddict.cannot.have.key=TypedDict "{0}"은(는) 키 ''{1}''을(를) 가질 수 없습니다
INSP.typeddict.typeddict.cannot.inherit.from.non.typeddict.base.class=TypedDict는 TypedDict가 아닌 기본 클래스를 상속할 수 없습니다
INSP.typeddict.typeddict.has.no.key=TypedDict "{0}"에 키 ''{1}''이(가) 없습니다
INSP.typeddict.typeddict.has.no.keys=TypedDict "{0}"에 키({1})가 없습니다
INSP.typeddict.typeddict.key.must.be.string.literal.expected.one=TypedDict 키는 문자열 리터럴이어야 합니다. ({0}) 중 하나가 필요합니다
INSP.typeddict.value.must.be.type=값은 타입이어야 합니다
INSP.unbound.function.too.large=함수 ''{0}''이(가) 너무 커서 분석할 수 없습니다
INSP.unbound.local.variable=지역 변수 ''{0}''이(가) 할당 전에 참조될 수 있습니다
INSP.unbound.name.undefined=이름 ''{0}''이(가) undefined일 수 있습니다
INSP.unbound.nonlocal.variable=비지역 변수 ''{0}''을(를) 외부 함수 범위에 바인딩해야 합니다
INSP.unexpected.arg=예기치 않은 인수
INSP.unexpected.arg(s)=예기치 않은 인수
INSP.unexpected.parameter.in.docstring=docstring 내 예기치 않은 매개변수 {0}
INSP.unnecessary.backslash.unnecessary.backslash.in.expression=표현식 내 불필요한 백슬래시
INSP.unreachable.code=이 코드에 도달할 수 없습니다
INSP.unresolved.refs.cannot.find.reference.in.type=''{1}''에서 참조 ''{0}''을(를) 찾을 수 없습니다
INSP.unresolved.refs.class.does.not.define.operator=클래스 ''{0}''이(가) ''{1}''을(를) 정의하지 않기 때문에 ''{2}'' 연산자를 인스턴스에서 사용할 수 없습니다
INSP.unresolved.refs.class.object.has.no.attribute=''{0}'' 객체에 속성 ''{1}''이(가) 없습니다
INSP.unresolved.refs.ignore.references.label=무시된 참조:
INSP.unresolved.refs.import.resolves.to.its.containing.file=import는 import의 포함 파일로 해결됩니다
INSP.unresolved.refs.module.not.found=모듈 ''{0}''을(를) 찾을 수 없습니다
INSP.unresolved.refs.unresolved.attribute.for.class=''{1}'' 클래스의 해결되지 않은 속성 참조 ''{0}''
INSP.unresolved.refs.unresolved.reference=확인되지 않은 참조 ''{0}''
INSP.unsupported.format.character=지원되지 않는 형식 문자 ''{0}''
INSP.unused.import.statement=사용되지 않는 import 문 <code>#ref</code>
INSP.unused.locals.ignore.lambda.parameters=람다 매개변수 무시
INSP.unused.locals.ignore.range.iteration.variables=범위 반복 변수 무시
INSP.unused.locals.ignore.variables.starting.with='_'로 시작하는 변수 무시
INSP.unused.locals.ignore.variables.used.in.tuple.unpacking=튜플 패킹 해제에 사용되는 변수 무시
INSP.unused.locals.local.class.isnot.used=지역 클래스 ''{0}''이(가) 사용되지 않습니다
INSP.unused.locals.local.function.isnot.used=지역 함수 ''{0}''이(가) 사용되지 않습니다
INSP.unused.locals.local.variable.isnot.used=지역 변수 ''{0}'' 값이 사용되지 않습니다
INSP.unused.locals.parameter.isnot.used=매개변수 ''{0}'' 값이 사용되지 않습니다
INSP.unused.locals.replace.with.wildcard=_로 바꾸기 
INSP.use.fixture.without.declaration.in.test.function=테스트 함수나 ''@pytest.mark.usefixtures'' 마커가 픽스처 ''{0}''을(를) 요청하지 않습니다
INSP.usually.named=일반적으로 이러한 메서드의 첫 번째 매개변수는 ''{0}''로 이름이 지정됩니다
INSP.usually.named.self=일반적으로 메서드의 첫 번째 매개변수는 'self'로 이름이 지정됩니다
INTN.NAME.add.type.hint.for.variable=변수에 대한 타입 힌트 추가
INTN.NAME.add.type.hints.for.function=함수에 대한 타입 힌트 추가
INTN.NAME.convert.collection.literal=컬렉션을 {0}(으)로 변환 
INTN.NAME.convert.import.qualify='from module import'에서 'import module'으로 바꿉니다
INTN.NAME.convert.import.unqualify='import module'에서 'from module import'로 변환
INTN.NAME.convert.type.comment.to.variable.annotation=타입 주석을 변수 어노테이션으로 변환
INTN.NAME.demorgan.law=드모르간의 법칙
INTN.NAME.flip.comparison=비교 반전
INTN.NAME.hide.type.annotations=타입 어노테이션 숨기기
INTN.NAME.insert.docstring.stub=docstring 스텁 삽입
INTN.NAME.join.if='if' 문 결합
INTN.NAME.negate.comparison=비교 부정
INTN.NAME.specify.type.in.annotation=어노테이션를 사용하여 참조 타입 지정
INTN.NAME.specify.type.in.docstring=docstring 내 참조 타입 지정
INTN.NAME.split.if='if' 문 분할
INTN.NAME.toggle.import.alias=import 문 별칭을 사용하여 전환
INTN.add.import.alias=별칭 추가
INTN.add.import.alias.dialog.message=''{0}''의 별칭:
INTN.add.import.alias.title=별칭 추가
INTN.add.import.alias.to.name=''{0}''에 별칭 추가
INTN.add.parameters.to.docstring=docstring에 매개변수 추가
INTN.add.type.hint.for.variable=변수 ''{0}''에 대한 형식 힌트 추가
INTN.add.type.hint.for.variable.PEP484.incompatible.type=타입 ''{0}''을(를) PEP 484 형식으로 인라인으로 표현할 수 없습니다
INTN.add.type.hints.for.function=함수 ''{0}''에 대한 타입 힌트 추가
INTN.category.python=Python
INTN.convert.absolute.to.relative=절대 가져오기를 상대 가져오기로 변환
INTN.convert.builtin.import=내장 모듈 import를 지원되는 형식으로 변환
INTN.convert.collection.literal={0}을(를) {1}(으)로 변환
INTN.convert.dict.constructor.to.dict.literal=dict 생성자를 dict 리터럴로 변환
INTN.convert.dict.literal.to.dict.constructor=dict 리터럴을 dict 생성자로 변환
INTN.convert.except.to='except exceptClass,Target'을 'except exceptClass as Target'으로 변환
INTN.convert.lambda.to.function=람다를 함수로 변환
INTN.convert.method.to.property=메서드를 프로퍼티로 변환
INTN.convert.relative.to.absolute=상대 가져오기를 절대 가져오기로 변환
INTN.convert.static.method.to.function=정적 메서드를 함수로 변환
INTN.convert.to.from.import=''from {0} import {1}''(으)로 변환
INTN.convert.to.fstring.literal=f 문자열 리터럴로 변환
INTN.convert.to.plain.import=''import {0}''(으)로 변환
INTN.convert.type.comment.to.variable.annotation=변수 어노테이션으로 변환
INTN.convert.variadic.param=가변 매개변수를 일반 매개변수로 변환
INTN.flip.comparison=''{0}'' 반전
INTN.flip.comparison.to.operator=''{0}''을(를) ''{1}''(으)로 반전
INTN.format.operator.to.method=형식 연산자를 'str.format' 메서드 호출로 변환
INTN.hide.type.annotations=타입 어노테이션 숨김
INTN.insert.assertion=타입 어설션 삽입
INTN.insert.docstring.stub=문서 문자열 스텁 삽입
INTN.invert.if.condition='if' 조건 반전
INTN.join.if=두 개의 'if' 문 결합
INTN.negate.comparison=''{0}''을(를) ''{1}''(으)로 부정
INTN.quoted.string=작은따옴표로 묶인 문자열을 큰따옴표로 묶인 문자열로 변환 및 그 반대
INTN.quoted.string.double.to.single=큰따옴표 문자열을 작은 따옴표 문자열로 변환
INTN.quoted.string.single.to.double=작은 따옴표 문자열을 큰따옴표 문자열로 변환
INTN.remove.import.alias=별칭 ''{0}'' 제거
INTN.replace.backquote.expression=역인용 부호(')를 바꾸세요
INTN.replace.list.comprehensions=리스트 내포를 지원 양식으로 변환
INTN.replace.list.comprehensions.with.for=리스트 컴프리헨션을 'for' 루프로 변환
INTN.replace.noteq.operator=등호가 아닌 연산자 바꾸기
INTN.replace.octal.numeric.literal=8진 숫자 리터럴을 지원되는 형식으로 변환
INTN.replace.plus.with.format.operator=문자열 서식 지정 연산자로 바꾸기
INTN.replace.plus.with.str.format=str.format 메서드 호출로 바꾸기
INTN.replace.raise.statement=raise 문을 지원되는 형식으로 변환
INTN.replace.with.method=str.format 메서드 호출로 바꾸기
INTN.specify.return.type.in.annotation=어노테이션를 사용하여 반환 타입 지정
INTN.specify.return.type.in.docstring=docstring 내 반환 타입 지정
INTN.specify.type.in.annotation=어노테이션을 사용하여 참조 타입 지정
INTN.specify.type.in.docstring=docstring 내 참조 타입 지정
INTN.split.if='if' 문 2개로 분할
INTN.string.concatenation.to.format=문자열 연결을 'str.format'으로 바꾸기
INTN.transform.into.if.else.statement=조건식을 'if'/'else' 문으로 변환
INTN.triple.quoted.string=삼중 따옴표 문자열을 작은 따옴표 문자열로 변환
INTN.yield.from='yield'를 사용한 명시적 반복을 'yield from' 식으로 변환
QDOC.accessor.kind=접근자 종류:
QDOC.assigned.to=다음에 대입됨:
QDOC.attributes=속성:
QDOC.built.in.description=기본 제공 설명
QDOC.class=클래스
QDOC.class.attribute={1}의 클래스 속성 {0}
QDOC.copied.from=다음에서 복사됨:
QDOC.epydoc.python2.sdk.not.found=<a href='http://epydoc.sourceforge.net/'>Epydoc</a> docstrings를 \n\
렌더링하려면 Python 2 SDK를 구성해야 합니다
QDOC.inferred.type.name=추론된 타입: {0}
QDOC.instance.attribute={1}의 인스턴스 속성 {0}
QDOC.keyword.args=키워드 인수:
QDOC.local.sdk.not.found=docstrings를 렌더링하려면 구성된 로컬 Python SDK가 필요합니다.
QDOC.module.name=모듈 {0}
QDOC.module.path.unknown=(모듈 경로를 알 수 없습니다)
QDOC.not.defined.in.parentheses=(정의되지 않음)
QDOC.package.name=패키지 {0}
QDOC.parameter.name=매개변수 ''{0}''
QDOC.parameter.name.of.link={1}의 매개변수 {0}
QDOC.parameter.of.function.name=함수 ''{1}''의 매개변수 ''{0}''
QDOC.parameter.of.method.name=메서드 ''{1}''의 매개변수 ''{0}''
QDOC.params=매개변수:
QDOC.property.getter=프로퍼티 getter
QDOC.property.name.of.link={1}의 프로퍼티 {0}
QDOC.raises=발생:
QDOC.returns=반환 값:
QDOC.type.alias.statement.name.of.link=Type alias statement {0} of {1}
QDOC.type.parameter.kind=종류:
QDOC.type.parameter.name=Type parameter {0}
QDOC.type.parameter.name.of.link=Type parameter {0} of {1}
QDOC.variable.name=변수 ''{0}''
QFIX.NAME.add.exception.base=예외 기본 클래스 추가
QFIX.NAME.add.field.to.class=클래스에 필드 추가
QFIX.NAME.add.method.to.class=클래스에 메서드 추가
QFIX.NAME.add.specifier=형식 지정자 문자 추가
QFIX.NAME.auto.import=가져오기
QFIX.NAME.convert.builtin=기본 제공 모듈 가져오기 변환
QFIX.NAME.create.function.in.module=모듈에 함수 생성
QFIX.NAME.docstring=docstring 수정
QFIX.NAME.ignore.errors.like.this=이와 같은 오류 무시
QFIX.NAME.ignore.requirements={0,choice,1#requirement|2#requirement} 무시
QFIX.NAME.ignore.shadowed.built.in.name=가려진 기본 제공 이름 무시
QFIX.NAME.install.and.import.package=‘{0}’ 패키지를 설치 및 가져오기
QFIX.NAME.install.requirements={0,choice,1#requirement|2#requirement} 설치
QFIX.NAME.local.auto.import=로컬로 가져오기
QFIX.NAME.make.function=메서드로부터 함수 생성
QFIX.NAME.make.function.return.type=함수가 추론 타입을 반환하도록 설정
QFIX.NAME.make.list=튜플을 리스트로 바꾸기
QFIX.NAME.make.static=메서드를 정적으로 만들기
QFIX.NAME.move.except.up=except 절을 위로 이동
QFIX.NAME.remove.argument=인수 제거
QFIX.NAME.remove.assignment=대입 제거
QFIX.NAME.remove.assignment.target=대입 타깃 제거
QFIX.NAME.remove.call=호출 제거
QFIX.NAME.remove.dict.key=이 키 제거
QFIX.NAME.remove.exception.target=예외 타깃 제거
QFIX.NAME.remove.parameter=매개변수 제거
QFIX.NAME.remove.statement=구문 제거
QFIX.NAME.remove.string.prefix=접두사 제거
QFIX.NAME.remove.underscores.in.numeric=숫자 리터럴에서 밑줄 제거
QFIX.NAME.remove.with.target='with' 타깃 제거
QFIX.NAME.rename.argument=인수 이름 변경
QFIX.NAME.rename.parameter=매개변수 이름 변경
QFIX.NAME.replace.with.true.or.false=True 또는 False로 바꾸기
QFIX.NAME.simplify.boolean.expression=bool 표현식 단순화
QFIX.NAME.unpack.type.var.tuple=TypeVarTuple 언패킹
QFIX.NAME.unresolved.reference.add.param=참조의 매개변수 생성
QFIX.NAME.unresolved.reference.create.function=함수 ''{0}'' 생성
QFIX.NAME.update.parameters=매개변수 업데이트 
QFIX.action.failed=액션이 실패했습니다
QFIX.add.encoding=인코딩 선언 추가
QFIX.add.field.to.class={1} 클래스에 ''{0}'' 필드 추가
QFIX.add.field.to.class.popup.content.added.init=새 필드 <code>{1}</code>을(를) 수용하기 위해<br/>__init__을 클래스 <code>{0}</code>에 추가했습니다
QFIX.add.fixture.to.test.function.parameters.list=테스트 함수 매개변수에 픽스처 추가
QFIX.add.from.future.import.annotations='from __future__ import annotations' 추가
QFIX.add.global=전역 구문 추가
QFIX.add.imported.packages.to.requirements=requirements에 가져온 패키지 추가…
QFIX.add.method.to.class={1} 클래스에 ''{0}'' 메서드 추가
QFIX.add.parameter.self=매개변수 ''{0}'' 추가
QFIX.add.property=필드 프로퍼티 추가
QFIX.add.qualifier=한정자 추가
QFIX.add.super=상위 클래스 호출 추가
QFIX.augment.assignment=대입을 증분 대입으로 바꾸기
QFIX.auto.import.import.name=가져오기 ''{0}''
QFIX.auto.import.import.this.name=이 이름 가져오기
QFIX.chained.comparison=체인 비교 단순화
QFIX.change.base.class=기본 클래스 변경
QFIX.classic.class.transform=객체로부터 상속
QFIX.convert.indents=들여쓰기 변환
QFIX.convert.indents.to.spaces=들여쓰기를 공백으로 변환
QFIX.convert.indents.to.tabs=들여쓰기를 탭으로 변환
QFIX.convert.single.quoted.docstring=docstring을 삼중 큰따옴표 문자열 양식으로 변환
QFIX.convert.to.new.style=새로운 스타일의 클래스로 변환
QFIX.coroutine.is.not.awaited=코루틴이 대기하고 있지 않습니다
QFIX.create.class=클래스 생성
QFIX.create.class.0=클래스 ''{0}'' 생성
QFIX.create.class.in.module=모듈 {1}에 클래스 ''{0}'' 생성
QFIX.create.function.in.module={1} 모듈에 {0}() 함수 생성
QFIX.create.property=프로퍼티 생성
QFIX.default.argument=가변 디폴트 인수 바꾸기
QFIX.dict.creation=딕셔너리 생성 바꾸기
QFIX.docstring.add.parameter=docstring 매개변수 ''{0}'' 추가
QFIX.docstring.insert.stub=docstring 삽입
QFIX.docstring.remove.parameter=docstring 매개변수 ''{0}'' 제거
QFIX.failed.to.add.field=<br/>필드 추가 실패하였습니다!<br/><br/>
QFIX.failed.to.add.function=<br/>함수 추가 실패하였습니다!<br/><br/>
QFIX.failed.to.add.method=<br/>메서드 추가 실패!<br/><br/>
QFIX.ignore.shadowed.built.in.name=가려진 기본 제공 이름 "{0}" 무시
QFIX.install.and.import.package=패키지를 설치하고 가져옵니다
QFIX.introduce.variable=구문의 변수 삽입
QFIX.list.creation=list 리터럴로 바꿉니다.
QFIX.local.auto.import.import.locally=로컬로 {0}
QFIX.make.function.return.type=''{0}''이(가) ''{1}''을(를) 반환하도록 만들기
QFIX.make.public=public으로 설정
QFIX.move.attribute=속성을 __init__ 메서드로 이동
QFIX.move.from.future.import=올바른 위치로 'from __future__ import' 이동
QFIX.optimize.imports=import 문 최적화
QFIX.pandas.series.values.replace.with.tolist=list(Series.values)를 Series.to_list()로 대체
QFIX.redundant.parentheses=중복 된 소괄호 제거
QFIX.remove.annotation=어노테이션 제거
QFIX.remove.argument.equal.default=디폴트 값과 동일한 인수 제거
QFIX.remove.decorator=데코레이터 제거
QFIX.remove.function.annotations=함수 어노테이션 제거
QFIX.remove.generic.parameters=제네릭 매개변수 제거
QFIX.remove.square.brackets=대괄호 제거
QFIX.remove.string.prefix=선행 {0} 제거
QFIX.remove.trailing.semicolon=후행 세미콜른 제거
QFIX.remove.trailing.suffix=후행 접미사 제거
QFIX.remove.type.comment=타입 주석 제거
QFIX.remove.unnecessary.backslash=표현식에서 불필요한 백슬래시 제거
QFIX.rename.parameter=''{0}''(으)로 이름 변경
QFIX.rename.unresolved.reference=참조 이름 변경
QFIX.replace.equality=상등 바꾸기
QFIX.replace.function.set.with.literal=함수 호출을 집합 리터럴로 바꾸기
QFIX.replace.star.by.unpack=typing_extensions.Unpack으로 바꾸기
QFIX.replace.with.old.union.style=이전 스타일 공용체로 바꾸기
QFIX.replace.with.square.brackets=대괄호로 바꾸기
QFIX.replace.with.target.name=타깃 이름으로 바꾸기
QFIX.replace.with.true.or.false={0}(으)로 바꾸기
QFIX.replace.with.type.name=타입 이름으로 바꾸기
QFIX.replace.with.typing.alias=타입 별칭으로 바꾸기
QFIX.simplify.boolean.expression=bool 표현식을 ''{0}''(으)로 바꾸기
QFIX.statement.effect=함수 호출로 바꾸기
QFIX.surround.with.square.brackets=대괄호로 둘러싸기
QFIX.unresolved.reference=''{0}''을(를) ''{1}.{0}''(으)로 바꾸기
QFIX.unresolved.reference.add.param=매개변수 ''{0}'' 생성
QFIX.unresolved.reference.create.function=함수 생성
QFIX.use.property=필드 프로퍼티 사용
custom.type.mimic.name={0}을(를) 기반으로 한 동적 클래스
debugger.cleaning.signature.cache=동적으로 수집된 타입의 캐시 정리
element.presentation.location.string.in.class=({1}의 {0})
element.presentation.location.string.in.class.stub=({0}/{1} 스텁)
element.presentation.location.string.module=({0})
element.presentation.location.string.module.stub=({0} 스텁)
filetype.python.docstring.description=Python docstring
filetype.python.function.type.annotation.description=Python PEP-484 함수 타입 주석
filetype.python.stub.description=Python 스텁
filetype.python.type.hint.description=Python PEP-484 타입 힌트
find.usages.class=클래스
find.usages.function=함수
find.usages.imported.module.alias=가져온 모듈 별칭
find.usages.keyword.argument=키워드 인수
find.usages.method=메서드
find.usages.parameter=매개 변수
find.usages.unnamed=<이름이 지정되지 않음>
find.usages.variable=변수
formatter.panel.dict.alignment.align.on.colon=콜론에 정렬
formatter.panel.dict.alignment.align.on.value=값에 정렬
formatter.panel.dict.alignment.do.not.align=정렬 안 함
ignore.overridden.functions=재정의된 함수 무시
python.docstring.format=Docstring 형식:
python.docstring.select.type=Docstring 타입 선택
python.find.usages=사용 위치 찾기
python.find.usages.base.method.question=메서드 {0}이(가) 클래스 {1}의 메서드를 재정의합니다.\n\
기본 메서드의 사용 위치를 찾으시겠어요?
python.find.usages.untyped.probable.usage=타입이 지정되지 않은(그럴 가능성 있는) 사용 위치
python.find.usages.usage.in.import.statement=import 문 내 사용 위치
python.find.usages.usage.in.isinstance=isinstance() 내 사용 위치
python.find.usages.usage.in.superclass.list=상위 클래스 목록 내 사용 위치
python.find.usages.usage.in.type.hint=타입 힌트의 사용 위치
refactoring.extract.method=메서드 추출
refactoring.extract.method.error.bad.selection=선택한 요소를 사용하여 추출 메서드 리팩터링을 할 수 없습니다
refactoring.extract.method.error.class.level=클래스 수준에서 리팩터링을 수행할 수 없습니다
refactoring.extract.method.error.empty.fragment=빈 코드 조각에서 리팩터링을 수행할 수 없습니다
refactoring.extract.method.error.interrupted.execution.flow=실행 흐름이 중단될 시 리팩터링을 수행할 수 없습니다
refactoring.extract.method.error.local.variable.modifications=코드 조각 내부의 지역 변수 수정이 있는 표현식에서 리팩터링을 수행할 수 없습니다.
refactoring.extract.method.error.local.variable.modifications.and.returns=코드 조각 내부의 지역 변수 수정과 반환 명령이 있는 표현식에서 리팩터링을 수행할 수 없습니다
refactoring.extract.method.error.name.clash=메서드 이름이 기존 이름과 충돌합니다
refactoring.extract.method.error.returns=코드 조각 내부에 반환 명령이 있는 메서드를 추출할 수 없습니다
refactoring.extract.method.error.star.import=코드 블록 내부의 별표 import 문으로 리팩터링을 수행할 수 없습니다
refactoring.extract.method.error.yield=코드 블록 내부의 'yield' 문으로 리팩터링을 수행할 수 없습니다
refactoring.inline.all.border.title=인라인화
refactoring.inline.all.keep.declaration=모든 호출 인라인화 및 선언 유지
refactoring.inline.all.remove.declaration=모든 호출 인라인화 및 선언 제거
refactoring.inline.can.not.multiline.string.to.f.string=f-string에 여러 줄 문자열을 인라인화할 수 없습니다
refactoring.inline.can.not.string.to.nested.f.string=중첩된 f-string에 문자열을 인라인화할 수 없습니다
refactoring.inline.can.not.string.with.backslashes.or.quotes.to.f.string=f-string에 백슬래시와 따옴표가 있는 문자열을 인라인화할 수 없습니다
refactoring.inline.function=함수 {0} 인라인화
refactoring.inline.function.async=비동기 함수를 인라인화할 수 없습니다
refactoring.inline.function.builtin=내장 함수는 인라인화할 수 없습니다
refactoring.inline.function.command.name={0} 인라인화 중
refactoring.inline.function.constructor=생성자 호출을 인라인화할 수 없습니다.
refactoring.inline.function.decorator=데코레이터가 있는 함수를 인라인화할 수 없습니다
refactoring.inline.function.function.to.inline=인라인화할 함수
refactoring.inline.function.generator=제너레이터를 인라인화할 수 없습니다
refactoring.inline.function.global=전역 변수가 있는 함수를 인라인화할 수 없습니다
refactoring.inline.function.interrupts.flow=제어 흐름을 방해하는 인라인 함수를 인라인화할 수 없습니다
refactoring.inline.function.invocations.to.be.inlined={0} 파일에 인라인화되는 호출
refactoring.inline.function.is.decorator=함수 {0}이(가) 데코레이터로 사용되어 인라인화될 수 없습니다. 함수 정의가 제거되지 않습니다
refactoring.inline.function.is.overridden=재정의된 메서드를 인라인화할 수 없습니다
refactoring.inline.function.is.reference=함수 {0}이(가) 참조로 사용되어 인라인될 수 없습니다. 함수 정의가 제거되지 않습니다
refactoring.inline.function.nested=다른 함수 선언이 있는 함수를 인라인화할 수 없습니다
refactoring.inline.function.nonlocal=비지역 함수를 인라인화할 없습니다
refactoring.inline.function.overrides.method=다른 메서드를 재정의하는 메서드를 인라인화할 수 없습니다
refactoring.inline.function.self.referrent=자신을 참조하는 함수를 인라인화할 수 없습니다
refactoring.inline.function.skeleton.only=바이너리 모듈에서 함수를 인라인화할 수 없습니다
refactoring.inline.function.special.method=특수 메서드를 인라인화할 수 없습니다
refactoring.inline.function.star=* 인수가 있는 함수를 인라인화할 수 없습니다
refactoring.inline.function.title=함수 인라인화
refactoring.inline.function.uses.unpacking=함수 {0}이(가) 인수 패킹 헤재를 사용하여 인라인화될 수 없습니다. 함수 정의가 제거되지 않습니다
refactoring.inline.label.function=함수 {0}
refactoring.inline.label.method=메서드 {0}
refactoring.inline.local.multiassignment=정의가 다중 대입에 있습니다
refactoring.inline.method=메서드 {0} 인라인화
refactoring.inline.this.only=이 호출만 인라인화 및 선언 유지
refactoring.introduce.constant.cannot.extract.selected.expression=선택한 표현식은 상수로 추출할 수 없습니다
refactoring.introduce.constant.dialog.title=상수 추출
refactoring.introduce.constant.scope.error=이름이 이미 범위에 선언되었습니다
refactoring.introduce.name.error=Incorrect name
refactoring.introduce.selection.error=선택한 요소를 사용하여 리팩터링을 수행할 수 없습니다
refactoring.introduce.variable.dialog.title=변수 추출
refactoring.introduce.variable.scope.error=이름이 기존 변수 또는 매개변수와 충돌합니다
refactoring.move.module.members.error.cannot.place.elements.into.nonpython.file=Python이 아닌 파일에 요소를 배치할 수 없습니다
refactoring.name.label.text={0}에는 {1} 개의 찾은 항목{2, choice, 0#|1#}이 있습니다
refactoring.progress.title.updating.existing.usages=기존 사용 위치를 업데이트하는 중...
type.param.list.annotator.two.or.more.types.required=두 개 이상의 타입이 필요합니다
type.param.list.annotator.type.parameter.already.defined=이름이 ''{0}''인 타입 매개변수는 이미 이 타입 매개변수 목록에 정의되어 있습니다
type.param.list.annotator.type.var.tuple.and.param.spec.can.not.have.bounds=ParamSpec과 TypeVarTuple은 제약과 상위 바운드를 가질 수 없습니다
unresolved.docstring.param.reference=함수 ''{0}''에 매개변수 ''{1}''이(가) 없습니다
unresolved.import.reference=이름이 ''{0}''인 모듈이 없습니다