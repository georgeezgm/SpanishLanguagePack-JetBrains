action.AnalyzeEPUsage.text=확장점 사용 위치 분석
action.AnalyzeEPUsageIgnoreSafeClasses.text=확장점 사용 위치 분석(안전 타입을 따르지 않음)
action.AnalyzeUnloadablePlugins.progress.title=플러그인 분석 중({0})
action.AnalyzeUnloadablePlugins.text=로드할 수 없는 플러그인 분석
action.DevKit.NewMessageBundle.action.name.create.new.message.bundle=새 메시지 번들 ''{0}'' 생성
action.DevKit.NewMessageBundle.description=새 메시지 번들 클래스 및 해당 프로퍼티 파일 생성
action.DevKit.NewMessageBundle.error.message.do.not.put.bundle.to.impl.module=현재 .impl 모듈의 번들을 별도로 생성하는 것은 권장되지 않으므로, 대신 해당 API 모듈의 번들을 사용하세요
action.DevKit.NewMessageBundle.error.message.folder.already.exists=''{0}'' 폴더가 {1}에 이미 있습니다
action.DevKit.NewMessageBundle.error.message.multiple.content.roots.for.module={0}의 콘텐츠 루트가 여러 개 있습니다
action.DevKit.NewMessageBundle.error.message.under.sources.root={0}이(가) 소스 루트에 있습니다
action.DevKit.NewMessageBundle.error.title.cannot.create.new.message.bundle=새 메시지 번들을 생성할 수 없음
action.DevKit.NewMessageBundle.label.bundle.name=번들 이름:
action.DevKit.NewMessageBundle.notification.content.cannot.create.resources.root.for.properties.file=프로퍼티 파일의 리소스 루트를 생성할 수 없습니다. {0}
action.DevKit.NewMessageBundle.notification.title.cannot.create.resources.root.for.properties.file=새 메시지 번들을 생성할 수 없음
action.DevKit.NewMessageBundle.text=메시지 번들
action.DevKit.NewMessageBundle.title.create.new.message.bundle=새 메시지 번들 생성
action.DumpCleanTestData.error.source.destination.must.differ=소스 루트와 대상 루트는 달라야 합니다
action.DumpCleanTestData.file.chooser.destination.description=강조 표시 없는 복사본을 넣을 디렉터리
action.DumpCleanTestData.file.chooser.source.description=강조 표시 테스트 데이터가 포함된 디렉터리
action.DumpCleanTestData.file.chooser.title=디렉터리 선택
action.DumpCleanTestData.text=강조 표시, 마크업이 없는 데이터 버리기
action.GenerateExternalization.text=외부화 생성
action.MakeAllJarsAction.text=배포할 모든 플러그인 준비
action.MakeJarAction.text=배포 준비
action.NewAction.description=새 함수 생성
action.NewAction.text=액션
action.ShowHelpPageById.dialog.enter.help.id=도움말 ID 입력:
action.ShowHelpPageById.dialog.title=도움말 페이지 표시
action.ShowHelpPageById.text=ID로 도움말 페이지 표시
action.ShowSerializedXml.dialog.title=''{0}''의 직렬화된 XML
action.ShowSerializedXml.message.cannot.find.class=클래스 ''{0}''을(를) 찾을 수 없습니다
action.ShowSerializedXml.message.cannot.generate.class=클래스 ''{0}''을(를) 생성할 수 없습니다. {1}
action.ShowSerializedXml.message.caret.must.be.at.class.identifier=캐럿을 클래스의 이름에 놓아야 합니다
action.ShowSerializedXml.text=클래스에 대한 직렬화된 XML을 표시
action.ShuffleNamesAction.text=이름 Shuffle/Scramble/Anonymize/Permute
action.TestData.Navigate.text=테스트 데이터로 이동
action.ToggleHighlightingMarkup.text=예상되는 강조 표시 마크업 전환
action.UpdateIdeFromSourcesAction.backup.progress.text=파일 백업 중
action.UpdateIdeFromSourcesAction.copy.copy.new.files.text=새 파일 복사 중
action.UpdateIdeFromSourcesAction.copy.delete.old.files.text=이전 파일 삭제 중
action.UpdateIdeFromSourcesAction.copy.progress.text=파일을 IDE 배포판으로 복사 중…
action.UpdateIdeFromSourcesAction.dialog.message.directory.not.writable=디렉터리 {0}은(는) 쓰기가 불가능합니다
action.UpdateIdeFromSourcesAction.error.config.or.system.directory.under.home=''{1}'' 프로퍼티가 그 아래에 있는 디렉터리를 가리키고\n\
{0} 설치를 업데이트하는 동안 해당 디렉터리가 삭제되므로 업데이트를 완료할 수 없습니다.
action.UpdateIdeFromSourcesAction.error.ide.cannot.restart=이 IDE는 스스로 재시작할 수 없으므로 소스에서 업데이트가 지원되지 않습니다
action.UpdateIdeFromSourcesAction.error.work.home.not.valid.ide.home={0}은(는) 올바른 IDE 홈이 아닙니다. {1}
action.UpdateIdeFromSourcesAction.error.work.home.not.valid.ide.home.not.directory=디렉터리가 아닙니다
action.UpdateIdeFromSourcesAction.error.work.home.not.valid.ide.home.not.exists=''{0}''이(가) 없습니다
action.UpdateIdeFromSourcesAction.notification.action.view.debug.log=디버그 로그 보기
action.UpdateIdeFromSourcesAction.notification.action.view.output=출력 보기
action.UpdateIdeFromSourcesAction.notification.content={0}에서 새 설치가 준비되었습니다.
action.UpdateIdeFromSourcesAction.notification.title=소스에서 업데이트
action.UpdateIdeFromSourcesAction.settings.do.not.show.description='소스 설정에서 IDE 업데이트' 액션을 호출하여 설정을 변경할 수 있습니다
action.UpdateIdeFromSourcesAction.settings.enabled.plugins.only=활성화된 플러그인만 빌드
action.UpdateIdeFromSourcesAction.settings.installation.choose.ide.directory.title=IDE 설치 디렉터리 선택
action.UpdateIdeFromSourcesAction.settings.ok.button=업데이트
action.UpdateIdeFromSourcesAction.settings.restart.automatically=자동으로 다시 시작
action.UpdateIdeFromSourcesAction.settings.row.ide.installation=IDE 설치:
action.UpdateIdeFromSourcesAction.settings.title=소스에서 IDE 업데이트
action.UpdateIdeFromSourcesAction.task.failed.content=스크립트 빌드가 오류 코드 {0}와(과) 함께 완료됨
action.UpdateIdeFromSourcesAction.task.failed.title=소스에서 업데이트 실패
action.UpdateIdeFromSourcesAction.task.title=소스에서 업데이트 중
action.UpdateIdeFromSourcesAction.update.description=현재 열려 있는 소스로부터 IntelliJIDEA의 설치를 빌드하여 현재 설치를 교체합니다.
action.UpdateIdeFromSourcesAction.update.progress.delete={0} 삭제 중
action.UpdateIdeFromSourcesAction.update.progress.start.script={0} 스크립트 시작 중
action.UpdateIdeFromSourcesAction.update.progress.text=소스에서 IDE 업데이트 중…
action.UpdateIdeFromSourcesAction.update.show.settings.text=소스 설정에서 IDE 업데이트…
action.UpdateIdeFromSourcesAction.update.text=소스에서 IDE 업데이트…
code.convert.experimental.feature.id.cannot.resolve=기능 ''{0}''을(를) 해결할 수 없습니다
code.convert.experimental.feature.no.description=설명 없음
code.convert.extension.point.declaration=확장 지점 ''{0}''을(를) 해결할 수 없습니다
code.convert.notification.group.cannot.resolve=알림 그룹 ID ''{0}''을(를) 해결할 수 없습니다
code.convert.registry.key.cannot.resolve=레지스트리 키 ''{0}''을(를) 해결할 수 없습니다
code.convert.registry.key.no.default.value=디폴트 없음
code.convert.registry.key.no.description=설명 없음
command.implement.externalizable=Externalizable 구현
create.description.file=설명 파일 {0} 생성
create.description.file.family.name=설명 파일 생성
deployment.cleanup={0} 디렉터리 정리
deployment.directory.location={0} 디렉터리 위치 선택
deployment.title=플러그인 배포
deployment.view.delete={0}을(를) 삭제하시겠어요?
deployment.view.meta-inf.label={0} 경로
deployment.view.select={0} 선택
error.cannot.resolve.extension.point=종속성 내 확장점 ''{0}''을(를) 해결할 수 없습니다
error.cannot.resolve.extension.point.missing.dependency=확장점 ''{0}''을(를) 사용하기 위한 종속성 선언 누락
error.cannot.resolve.extension.point.missing.dependency.fix.family.name=누락된 <depends> 추가
error.cannot.resolve.plugin=종속성 내 플러그인 ''{0}''을(를) 해결할 수 없습니다
error.cannot.resolve.plugin.reference.link.title=(참조: 플러그인 종속성)
error.file.not.found=파일을 찾을 수 없음
error.file.not.found.message=파일 ''{0}''을(를) 찾을 수 없습니다
error.no.plugin.xml=plugin.xml 파일을 찾을 수 없습니다
error.occurred=오류 발생
error.plugin.xml.readonly=읽기 전용 plugin.xml 파일을 처리할 수 없습니다. {0}
error.plugin.xml.tag.invalid=<올바르지 않음>
extension.point.analyzer.analyze.no.usages=사용 위치를 찾을 수 없음
extension.point.analyzer.analyze.status.bar.info=''{0}'' 분석 중(총: {1})
extension.point.analyzer.analyze.title=확장점 사용 위치 분석 중
extension.point.analyzer.analyze.usage.all.safe=모든 사용 위치가 동적 작동에 영향을 받지 않습니다
extension.point.analyzer.analyze.xml.batch.not.extension.points=<extensionPoints>가 아닙니다
extension.point.analyzer.analyze.xml.batch.title=확장점 분석 중
extension.point.analyzer.analyze.xml.cannot.resolve.ep.class=확장점의 클래스를 해결할 수 없습니다
extension.point.analyzer.analyze.xml.no.extension.point.name.field=ExtensionPointName 필드를 찾을 수 없습니다
extension.point.analyzer.analyze.xml.no.implementation.language.extension.point=LanguageExtensionPoint의 구현 클래스를 찾을 수 없습니다
extension.point.analyzer.analyze.xml.not.extension.point=<extensionPoint>가 아닙니다
extension.point.analyzer.not.extension.point.name=ExtensionPointName 참조가 아님
extension.point.analyzer.reason.call.not.loop.value=호출은 루프의 반복 값이 아닙니다
extension.point.analyzer.reason.element.of={0}의 요소
extension.point.analyzer.reason.extension.instance=확장 인스턴스
extension.point.analyzer.reason.extension.list=확장 목록
extension.point.analyzer.reason.get.instance.method.skipped='getInstance' 메서드에서 반환됨(호출 사이트를 검색하려면 비용이 너무 많이 듬)
extension.point.analyzer.reason.impure.method={0}이(가) 불순한 메서드에 전달되어 부수 효과가 발생할 수 있습니다(이를 방지하려면 ''@Contract(pure=true)'' 어노테이션을 추가하세요)
extension.point.analyzer.reason.leak.returned.from.method={0}: 메서드 ''{1}''에서 반환되고 이후 누수됨
extension.point.analyzer.reason.no.ep.field=확장점 필드가 없습니다
extension.point.analyzer.reason.return.value={0}: ''{1}''의 반환 값(타입: {2})
extension.point.analyzer.reason.returned.from.method={0}: 메서드 ''{1}''에서 반환됨
extension.point.analyzer.reason.too.many.visited.objects=방문한 객체가 너무 많아 검색이 중지됨
extension.point.analyzer.reason.uast.no.source.psi={0}: UVariable에 소스 PSI가 없습니다
extension.point.analyzer.reason.unknown.usage=알 수 없는 ExtensionPoint 사용 위치
extension.point.analyzer.reason.unknown.usage.text={0}: 알 수 없는 사용 위치
extension.point.analyzer.reason.unresolved.method.call=해결되지 않은 메서드 호출
extension.point.analyzer.usage.safe.eps=안전한 EP
extension.point.analyzer.usage.unsafe.eps=안전하지 않은 확장점 사용 위치
extension.point.documentation.field.required.can.be.empty.suffix=(필수, 빈 값 허용)
extension.point.documentation.field.required.suffix=(필수)
extension.point.documentation.implementation.section=확장점 구현
extension.point.documentation.link.platform.explorer=IntelliJ Platform Explorer에 사용 위치 표시
file.templates=템플릿
file.templates.new.plugin=새 플러그인
group.DevkitNewActions.text=플러그인 DevKit
group.Internal.DevKit.text=DevKit
group.PluginDeployActions.text=플러그인 배포 액션
gutter.name.test.data.line.marker=테스트 데이터
gutter.related.extension.declaration=선언
gutter.related.navigation.choose.action=액션 선택
gutter.related.navigation.choose.action.group=액션 그룹 선택
gutter.related.navigation.choose.component=구성 요소 선택
gutter.related.navigation.choose.extension=확장 선택
gutter.related.navigation.choose.extension.point=확장점 선택
gutter.related.navigation.choose.listener=리스너 선택
gutter.related.navigation.popup.description.tooltip=설명
gutter.related.navigation.popup.template.title=템플릿 선택
gutter.related.navigation.popup.template.tooltip=템플릿 전/후
gutter.related.option.before.after.templates=템플릿 전/후
gutter.related.option.description=설명
gutter.related.option.name=설명 / 템플릿 전|후
implemented.at.runtime.dom=런타임 시 구현된 DOM 요소
info.message=정보
inspection.action.is.not.preview.friendly.display.name=필드가 인텐션 미리보기를 막고 있습니다
inspection.action.presentation.instantiated.in.ctor.display.name=액션 프리젠테이션 즉시 생성
inspection.action.presentation.instantiated.in.ctor.message=액션 프리젠테이션이 생성자에서 인스턴스화됨
inspection.cancellation.check.in.loops.display.name=루프 내 취소 확인
inspection.cancellation.check.in.loops.message=루프 본문의 첫 번째 구문은 취소 검사 ''{0}''이어야 합니다
inspection.extension.class.should.be.final.and.non.public.display.name=확장 클래스는 final이면서 비 public이어야 합니다
inspection.extension.class.should.be.final.text=확장 클래스는 final이어야 합니다
inspection.extension.class.should.not.be.public.text=확장 클래스는 public이 아니어야 합니다
inspection.extension.registered.as.component.message=클래스를 확장인 동시에 구성 요소로 등록하면 안 됩니다
inspection.extension.registered.as.service.message=클래스를 확장인 동시에 서비스로 등록하면 안 됩니다
inspection.extension.registered.as.service.or.component.display.name=서비스/구성 요소로 등록된 확장
inspection.file.equals.usage.display.name=File.equals() 사용 위치
inspection.highlight.visitor.internal.display.name=올바른 코드는 빨간색으로 표시
inspection.incorrect.parent.disposable.display.name=잘못된 parentDisposable 매개변수
inspection.insert.cancellation.check.fix.message=취소 검사 삽입
inspection.inspection.description.not.found.inspection.display.name=검사 설명 검사기
inspection.inspection.unspecified.actions.place.display.name=지정되지 않은 액션 위치
inspection.inspection.using.gray.colors.display.name=new Color(a,a,a) 사용
inspection.intention.description.not.found.inspection.display.name=인텐션 설명 검사기
inspection.light.service.migration.already.annotated.message='@Service'로 어노테이션된 서비스 클래스는 plugin.xml에 등록될 필요가 없습니다
inspection.light.service.migration.app.level.message=서비스를 가벼운 서비스로 변환할 수 있습니다.\n\
서비스 클래스에 '@Service' 어노테이션을 추가하고 'plugin.xml' 파일에서 등록을 제거하세요.
inspection.light.service.migration.display.name=서비스를 라이트 서비스로 변환할 수 있음
inspection.light.service.migration.project.level.message=서비스를 가벼운 서비스로 변환할 수 있습니다.\n\
서비스 클래스에 '@Service(Service.Level.PROJECT)' 어노테이션을 추가하고 'plugin.xml' 파일에서 등록을 제거하세요.
inspection.light.service.must.be.concrete.class.message=라이트 서비스는 구체 클래스여야 하며 추상적이거나 인터페이스일 수 없습니다.\n\
IntelliJ 플랫폼은 구체 구현 클래스를 사용하여 서비스 인스턴스를 생성하고 관리합니다. 구체 구현이 없으면 플랫폼이 서비스의 인스턴스를 생성할 수 없으며, 플러그인이 서비스를 사용할 수 없습니다.\n\
이 문제를 해결하려면 서비스의 구체 구현 클래스를 정의하고 '@Service'로 어노테이션을 추가해야 합니다.
inspection.light.service.must.be.final.display.name=라이트 서비스는 final이어야 합니다
inspection.light.service.must.be.final.message=라이트 서비스는 final이어야 합니다
inspection.message.accessible.context.not.defined.for.jpanel=액세스 가능한 컨텍스트가 JPanel에 대해 정의되지 않았습니다
inspection.message.field.may.prevent.intention.preview.to.work.properly=필드 때문에 인텐션 미리보기가 제대로 작동하지 않을 수 있습니다
inspection.message.unnecessary.safe.field.annotation=불필요하녀 @SafeFieldForPreview 어노테이션: 필드 타입은 이미 안전한 것으로 간주됩니다
inspection.migrate.to.opt.control.display.name=getOptionPane()으로 마이그레이션
inspection.migrate.to.opt.control.fix=OptPane으로 변환
inspection.migrate.to.opt.control.message=OptPane으로 자동 변환할 수 있습니다
inspection.mismatched.light.service.level.and.ctor.app.level.ctor.required=애플리케이션 수준의 서비스에는 인수가 없거나 매개변수가 하나이며 타입이 'kotlinx.coroutines.CoroutineScope'인 생성자가 필요합니다
inspection.mismatched.light.service.level.and.ctor.display.name=라이트 서비스 수준과 생성자 간의 불일치
inspection.mismatched.light.service.level.and.ctor.project.level.required='Project' 타입의 매개변수를 1개 취하는 생성자가 있는 경우 라이트 서비스는 '@Service(Service.Level.PROJECT)'를 지정해야 합니다
inspection.mismatched.light.service.level.and.ctor.specify.project.level.fix='@Service' 어노테이션에서 'Service.Level.PROJECT' 매개변수 지정
inspection.missing.accessible.context.display.name=액세스 가능한 컨텍스트 누락
inspection.missing.recent.api.display.name=IntelliJ API는 이전 IDE에서 사용할 수 없습니다
inspection.non.default.constructor.display.name=서비스 및 확장 클래스의 디폴트가 아닌 생성자
inspection.plugin.xml.dynamic.plugin.display.name=Plugin.xml 동적 플러그인 검증
inspection.plugin.xml.extension.registration.configurable.should.define.displayName.or.key.attribute=Define 'displayName' or 'key' attribute matching 'Configurable.getDisplayName()' implementation
inspection.plugin.xml.extension.registration.display.name=Plugin.xml 확장 등록
inspection.plugin.xml.extension.registration.should.define.externalidprefix.attribute=<html>externalIdPrefix 속성을 정의하세요. <a href='https://plugins.jetbrains.com/docs/intellij/stub-indexes.html?from=PluginXmlExtensionRegistrationInspection'>스텁 색인</a>을 참조하세요</html>
inspection.plugin.xml.extension.registration.should.define.id.attribute=Define 'id' attribute matching 'StatusBarWidgetFactory.getId()' implementation
inspection.plugin.xml.extension.registration.should.define.language.attribute=확장 ''{0}''은(는) ''language'' 속성을 정의해야 합니다
inspection.plugin.xml.extension.registration.should.define.language.tag=확장 ''{0}''은(는) ''language'' 태그를 정의해야 합니다
inspection.plugin.xml.extension.registration.should.define.language.tag.family.name=언어 태그 추가
inspection.plugin.xml.validity.display.name=Plugin.xml 유효성
inspection.presentation.annotation.display.name=@Presentation 내 잘못된 아이콘 경로
inspection.psi.element.concatenation.display.name=새 표현식 생성을 위한 PsiElement 문자열 표현의 사용이 올바르지 않습니다
inspection.quick.fix.get.family.name.violation.display.name=QuickFix의 getFamilyName() 구현은 특정 컨텍스트에 종속되어서는 안 됩니다
inspection.renamer.dialog.description=<html>검사 설명 파일 이름 및 짧은 이름을 변경하시겠어요?<br/><b>경고: 기존 검사 프로파일 및 억제 주석이 손상될 수 있습니다.</b></html>
inspection.renamer.dialog.title=검사 설명 파일 이름 및 짧은 이름 변경
inspection.renamer.entity.name=요소
inspection.renamer.option.name=검사 설명 파일 이름 및 짧은 이름 변경
inspection.retrieving.service.can.be.replaced.with=''{0}.{1}()'' 호출로 바꿀 수 있습니다
inspection.retrieving.service.display.name=불러오는 서비스가 올바르지 않거나 간소화 가능
inspection.retrieving.service.mismatch.for.app.level=애플리케이션 수준의 서비스를 프로젝트 수준의 서비스로서 불러옵니다
inspection.retrieving.service.mismatch.for.project.level=프로젝트 수준의 서비스를 애플리케이션 수준의 서비스로서 불러옵니다
inspection.retrieving.service.not.registered=''{0}'' 클래스는 서비스로 등록되지 않았습니다
inspection.retrieving.service.replace.with=''{0}.{1}()'' 호출로 바꾸기
inspection.serializable.constructor.message=디폴트가 아닌 생성자에는 @PropertyMapping 어노테이션이 추가되어야 합니다
inspection.serializable.ctor.display.name=직렬화 가능한 클래스 내 디폴트가 아닌 생성자
inspection.stateful.ep.display.name=스테이트풀 확장
inspection.threading.concurrency.display.name=스레딩 및 동시성 문제
inspection.threading.concurrency.option.check.missing.annotations.methods=public 메서드에 누락된 어노테이션이 있는지 확인
inspection.threading.concurrency.option.group.inside.requires.edt=@RequiresEdt 내부 확인:
inspection.threading.concurrency.option.group.inside.requires.edt.check.requires.read.lock=@RequiresReadLock
inspection.threading.concurrency.option.group.inside.requires.edt.check.requires.write.lock=@RequiresWriteLock
inspection.threading.concurrency.violation.call.inside.method=''@{0}'' 어노테이션이 추가된 메서드는 ''@{1}'' 어노테이션이 추가된 메서드에서 호출될 수 없습니다
inspection.threading.concurrency.violation.unannotated.method.contains.call=어노테이션이 없는 메서드가 ''@{0}'' 어노테이션이 추가된 메서드를 호출합니다
inspection.threading.concurrency.violation.unannotated.method.contains.call.multiple.annotations=어노테이션이 없는 메서드가 여러 스레딩 어노테이션이 추가된 메서드를 호출합니다
inspection.token.set.in.parser.definition=ParserDefinition 내의 TokenSet이 비 플랫폼 클래스를 참조합니다
inspection.token.set.in.parser.definition.display.name=비 플랫폼 TokenSet이 ParserDefinition 내에 선언됨
inspection.u.element.as.psi.display.name=UElement를 PsiElement로 사용
inspection.undesirable.class.usage.display.name=올바르지 않은 클래스 사용 위치
inspection.unsafe.return.statement.visitor.display.name=안전하지 않은 return 문 방문자
inspection.unsafe.vfs.recursion.display.name=안전하지 못한 VFS 반복
inspection.use.DPI.aware.borders.display.name=DPI 지원 경계선 사용
inspection.use.DPI.aware.insets.display.name=DPI 지원 인셋 사용
inspection.use.JB.color.display.name=Darcula 지원 JBColor 사용
inspection.use.couple.display.name=Pair 대신 Couple 사용
inspection.use.plugin.id.equals.display.name='PluginId#equals(Object)' 사용
inspection.use.primitive.types.equals.display.name=기본 타입 'PsiType#equals(Object)' 사용
inspection.use.virtual.file.equals.display.name='VirtualFile#equals(Object)' 사용
inspections.IncorrectParentDisposableInspection.do.not.use.as.disposable=플러그인 코드에서 폐기 가능한 항목으로 {0} 사용 안 함
inspections.IncorrectParentDisposableInspection.documentation.link.title=폐기 가능한 상위 항목 선택
inspections.action.update.thread.display.name=ActionUpdateThread가 없습니다
inspections.action.update.thread.message='getActionUpdateThread'를 재정의하고 'EDT' 또는 'BGT'를 선택하세요
inspections.application.service.as.static.final.field.message=애플리케이션 서비스는 static final 필드에 대입할 수 없습니다
inspections.application.service.as.static.final.field.or.property.display.name=Application service assigned to a static final field or immutable property
inspections.awt.color.used='JBColor' 대신 'java.awt.Color'가 사용되었습니다
inspections.awt.color.used.fix.use.jb.color.constant.family.name='JBColor' 상수로 변환
inspections.awt.color.used.fix.use.jb.color.fix.family.name='JBColor'로 변환'
inspections.calling.method.should.be.rbc.annotated=호출하는 메서드에 @RequiresBlockingContext로 어노테이션을 추가해야 합니다
inspections.calling.method.should.be.rbc.annotated.annotate.fix=호출하는 메서드에 '@RequiresBlockingContext'로 어노테이션 추가
inspections.calling.method.should.be.rbc.annotated.message=호출하는 메서드에 '@RequiresBlockingContext'로 어노테이션을 추가해야 합니다
inspections.component.not.registered.message={0}이(가) plugin.xml에 등록되지 않았습니다
inspections.component.not.registered.name=구성 요소/액션이 등록되지 않음
inspections.component.not.registered.option.check.actions=액션 검사
inspections.component.not.registered.option.ignore.non.public=비 public 클래스 무시
inspections.component.not.registered.quickfix.error={0}을(를) 등록할 수 없습니다
inspections.component.not.registered.quickfix.family={0} 등록
inspections.component.not.registered.quickfix.name={0} 등록
inspections.component.postfix.template.not.found.description.name=접미사 템플릿 설명 검사기
inspections.file.equals.method=Do not use File.equals/hashCode/compareTo as they don't honor case-sensitivity on macOS. Use FileUtil.filesEquals/fileHashCode/compareFiles instead.
inspections.group.code=코드
inspections.group.description.file=설명 파일
inspections.group.descriptor=플러그인 설명자
inspections.group.name=플러그인 DevKit
inspections.group.path=플러그인 DevKit
inspections.incorrect.implicit.process.canceled.exception.handling.name.logged=''ProcessCanceledException''을 로그하면 안 됩니다. ''{0}()''이(가) ''ProcessCanceledException''을 던집니다.
inspections.incorrect.implicit.process.canceled.exception.handling.name.not.rethrown=''ProcessCanceledException''을 다시 던지면 안 됩니다. ''{0}()''이(가) ''ProcessCanceledException''을 던집니다.
inspections.incorrect.implicit.process.canceled.exception.inheritor.handling.name.logged=''ProcessCanceledException'' 상속자를 로그하면 안 됩니다. ''{0}()''이(가) ''ProcessCanceledException''을 던집니다.
inspections.incorrect.implicit.process.canceled.exception.inheritor.handling.name.not.rethrown=''ProcessCanceledException'' 상속자를 다시 던지면 안 됩니다. ''{0}()''이(가) ''ProcessCanceledException''을 던집니다.
inspections.incorrect.process.canceled.exception.handling.display.name='ProcessCanceledException'이 잘못 처리되었습니다
inspections.incorrect.process.canceled.exception.handling.name.logged='ProcessCanceledException'을 로그하면 안 됩니다
inspections.incorrect.process.canceled.exception.handling.name.not.rethrown='ProcessCanceledException'을 다시 던지면 안 됩니다
inspections.incorrect.process.canceled.exception.inheritor.handling.name.logged='ProcessCanceledException' 상속자를 로그하면 안 됩니다
inspections.incorrect.process.canceled.exception.inheritor.handling.name.not.rethrown='ProcessCanceledException' 상속자를 다시 던지면 안 됩니다
inspections.inspection.description.optional.short.name=검사에 설명이 없습니다{0}
inspections.inspection.mapping.consistency.specify.bundle=번들을 지정해야 합니다
inspections.inspection.mapping.consistency.specify.displayName.or.key=displayName 또는 key를 지정해야 합니다
inspections.inspection.mapping.consistency.specify.groupName.or.groupKey=displayName 또는 groupKey를 지정해야 합니다
inspections.intention.description.no.before.after.template=인텐션에는 'description.html' 이외에 'before.*.template' 및 'after.*.template'이 있어야 합니다
inspections.intention.description.not.found=인텐션에 설명이 없습니다
inspections.leakable.map.key.name=맵 키의 누수 가능성이 있음
inspections.leakable.map.key.quick.fix.name=''{0}''(으)로 매개변수화
inspections.leakable.map.key.text=맵 키로 ''{0}'' 대신 ''String''을 사용해 보세요.
inspections.listener.implementation.must.not.be.disposable.name=Listener implementation implements 'Disposable'
inspections.listener.implementation.must.not.implement.disposable=Listener implementation must not implement 'Disposable'
inspections.missing.recent.api.class.message=''{0}''은(는) {1}부터만 사용 가능하나 모듈이 {2}을(를) 타깃으로 합니다. 이로 인해 {1} 이전의 IDE와 호환성 문제가 발생할 수 있습니다. 이 타입은 이전 IDE에서 다른 정규화된 이름을 가졌을 수도 있습니다.
inspections.missing.recent.api.common.message=''{0}''은(는) {1}부터만 사용 가능하나 모듈이 {2}을(를) 타깃으로 합니다. 이로 인해 {1} 이전의 IDE와 호환성 문제가 발생할 수 있습니다.
inspections.missing.recent.api.default.constructor.message=''{0}'' 디폴트 생성자는 {1}부터만 사용 가능하나 모듈이 {2}을(를) 타깃으로 합니다. 이로 인해 {1} 이전의 IDE와 호환성 문제가 발생할 수 있습니다.
inspections.missing.recent.api.field.message=''{0}''은(는) {1}부터만 사용 가능하나 모듈이 {2}을(를) 타깃으로 합니다. 이로 인해 {1} 이전의 IDE와 호환성 문제가 발생할 수 있습니다. 이 필드는 이전 IDE에서 다른 전체 시그니처를 가졌을 수도 있습니다.
inspections.missing.recent.api.method.message=''{0}''은(는) {1}부터만 사용 가능하나 모듈이 {2}을(를) 타깃으로 합니다. 이로 인해 {1} 이전의 IDE와 호환성 문제가 발생할 수 있습니다. 이 메서드는 이전 IDE에서 다른 전체 시그니처를 가졌을 수도 있습니다.
inspections.missing.recent.api.overriding=''{0}'' 내 메서드 재정의는 {1}부터만 사용 가능하나 모듈이 {2}을(를) 타깃으로 합니다. 이로 인해 {1} 이전의 IDE와 호환성 문제가 발생할 수 있습니다. 재정의된 메서드는 이전 IDE에서 다른 시그니처를 가졌을 수도 있습니다.
inspections.missing.recent.api.settings.invalid.build.number=잘못된 빌드 번호: {0}
inspections.missing.recent.api.settings.range=플러그인 호환 범위
inspections.missing.recent.api.settings.since=시작
inspections.missing.recent.api.settings.until=종료
inspections.missing.recent.api.since.until.range.all.builds=모든 빌드
inspections.non.default.warning.and.suffix.message={0}은(는) 매개변수 {1}을(를) 가진 생성자를 가질 수 없습니다
inspections.non.default.warning.suffix.module=(모듈 제외)
inspections.non.default.warning.suffix.project=(프로젝트 제외)
inspections.non.default.warning.suffix.project.or.module=(해당 수준에서 요청된 경우 프로젝트 또는 모듈 제외)
inspections.non.default.warning.type.extension=확장
inspections.non.default.warning.type.service=서비스
inspections.plugin.xml.ComponentModuleRegistrationChecker.element.registered.wrong.module=요소의 클래스 ''{1}''이(가) 정의된 ''{0}'' 모듈에 요소를 등록해야 합니다
inspections.plugin.xml.ComponentModuleRegistrationChecker.fix.move.registration.family.name=등록을 올바른 모듈로 이동
inspections.plugin.xml.ComponentModuleRegistrationChecker.fix.move.registration.name=등록을 {0}(으)로 이동
inspections.plugin.xml.action.class.required.with.use.shortcut.of='class'는 'use-shortcut-of'로 지정해야 합니다
inspections.plugin.xml.action.group.id.required='id'를 지정해야 합니다
inspections.plugin.xml.action.must.override.method.with.use.shortcut.of={0}은(는) ''use-shortcut-of''로 재정의해야 합니다
inspections.plugin.xml.add.ignored.class.title=무시할 클래스 지정
inspections.plugin.xml.add.vendor.tag=<vendor> 추가
inspections.plugin.xml.add.version.tag=<version> 추가
inspections.plugin.xml.anchor.must.have.relative-to-action='anchor'는 'relative-to-action'으로 지정해야 합니다
inspections.plugin.xml.attribute.not.used.anymore=속성 ''{0}''은(는) 더 이상 사용되지 않습니다
inspections.plugin.xml.change.until.build.family.name='until-build' 속성 수정
inspections.plugin.xml.change.until.build.name=''until-build''를 ''{0}''(으)로 변경
inspections.plugin.xml.component.interface.class.redundant=불필요한 태그 'interface-class'
inspections.plugin.xml.dependency.class.located.in.wrong.package=클래스 ''{0}''은(는) 패키지 ''{1}''에 있어야 합니다
inspections.plugin.xml.dependency.descriptor.at.least.one.dependency=하나 이상의 <module> 또는 <plugin> 종속성을 정의해야 합니다
inspections.plugin.xml.dependency.descriptor.cannot.use.depends=<dependencies>와 더불어 <depends>를 사용할 수 없습니다
inspections.plugin.xml.dependency.specify.config.file='config-file'을 지정해야 함
inspections.plugin.xml.dependency.superfluous.optional=불필요한 선언
inspections.plugin.xml.deprecated=곧 사용 불가
inspections.plugin.xml.deprecated.attribute=곧 사용할 수 없게 될 속성 ''{0}''
inspections.plugin.xml.deprecated.ep=곧 사용할 수 없게 될 확장점 ''{0}''
inspections.plugin.xml.deprecated.ep.marked.for.removal=제거 확장점 ''{0}''을(를) 위해 표시됨
inspections.plugin.xml.deprecated.ep.marked.for.removal.in.version=버전 ''{1}''의 제거 확장점 ''{0}''을(를) 위해 표시됨
inspections.plugin.xml.deprecated.ep.use.replacement=확장점 ''{0}''은(는) 더 이상 사용되지 않습니다. 대신 ''{1}''을(를) 사용하세요
inspections.plugin.xml.deprecated.helpset=Helpset은 곧 사용할 수 없게 되므로 'com.intellij.openapi.help.WebHelpProvider'를 사용하세요
inspections.plugin.xml.do.not.use.template.text=템플릿 텍스트 ''{0}'' 사용 안 함
inspections.plugin.xml.duplicated.dependency=종속성 구성 파일 ''{0}'' 중복
inspections.plugin.xml.dynamic.plugin.analyze.extension.point=''{1}''에 대해 {0}
inspections.plugin.xml.dynamic.plugin.component.usage=구성 요소가 사용되므로 플러그인은 동적이지 않습니다.
inspections.plugin.xml.dynamic.plugin.component.usage.docs.link.title=마이그레이션 가이드
inspections.plugin.xml.dynamic.plugin.explicit.non.dynamic.extension.point=명시적 비 동적 확장점 ''{0}''
inspections.plugin.xml.dynamic.plugin.extension.point=비 동적 확장점 ''{0}''
inspections.plugin.xml.dynamic.plugin.id.required.for.group=<group>의 'id'가 지정되어야 합니다
inspections.plugin.xml.dynamic.plugin.option.highlight.usages.ep=비 동적 확장점의 사용 위치 강조 표시
inspections.plugin.xml.dynamic.plugin.usage.of.non.dynamic.extension.point=비 동적 확장점 ''{0}''의 사용 위치
inspections.plugin.xml.ep.both.beanClass.and.interface=''''<extensionPoint>''는 ''interface'' 및 ''beanClass'' 속성을 둘 다 지정할 수 없습니다
inspections.plugin.xml.ep.both.name.and.qualifiedName='<extensionPoint>'는 'name' 및 'qualifiedName' 속성을 둘 다 지정할 수 없습니다
inspections.plugin.xml.ep.doesnt.have.with='<extensionPoint>'에 클래스 필드 타입을 지정하는 '<with>' 태그가 없습니다
inspections.plugin.xml.ep.missing.beanClass.and.interface='<extensionPoint>'는 'interface' 및 'beanClass' 속성 중 하나를 지정해야 합니다
inspections.plugin.xml.ep.missing.name.and.qualifiedName='<extensionPoint>'는 'name' 또는 'qualifiedName' 속성 중 하나를 지정해야 합니다
inspections.plugin.xml.ep.qualifiedName.superfluous='qualifiedName'을 통한 불필요한 선언
inspections.plugin.xml.ep.qualifiedName.superfluous.fix='name'을 통해 선언
inspections.plugin.xml.fix.extension.point.add.with.tag=<with> 태그 추가
inspections.plugin.xml.ignore.classes.title=등록 검사에서 무시할 클래스 목록:
inspections.plugin.xml.inner.class.must.be.separated.with.dollar=내부 클래스가 '$'로 구분되어야 합니다
inspections.plugin.xml.invalid.build.number=<html>잘못된 빌드 번호 ''{0}'' (<a href="https://plugins.jetbrains.com/docs/intellij/build-number-ranges.html?from=DevkitPluginXmlInspection">문서</a>)</html>
inspections.plugin.xml.invalid.ep.name=이름
inspections.plugin.xml.invalid.ep.name.description=잘못된 확장점 {0} ''{1}''입니다. 라틴 문자, 숫자, 마침표만 포함해야 하며, 마침표로 시작하거나 끝나면 안 됩니다. 각 조각은 소문자로 시작해야 하며 마지막 조각 단어가 이전 조각을 반복해서는 안 됩니다.
inspections.plugin.xml.invalid.ep.qualifiedName=정규화된 이름
inspections.plugin.xml.invalid.order.attribute=잘못된 'order' 속성 값
inspections.plugin.xml.jetbrains.only.api=JetBrains 내부 사용을 위해 예약된 API의 사용 위치
inspections.plugin.xml.listener.does.not.inherit=''{0}''이(가) ''{1}''을(를) 상속하지 않습니다
inspections.plugin.xml.marked.for.removal.attribute=속성 ''{0}''을(를) 제거하도록 표시
inspections.plugin.xml.module.descriptor.at.least.one.dependency=하나 이상의 <module> 항목을 정의해야 합니다
inspections.plugin.xml.must.not.contain.template.text=템플릿 텍스트 ''{0}''을(를) 포함할 수 없습니다
inspections.plugin.xml.must.use.after.before.with.relative-to-action=''relative-to-action''과 함께 ''{0}''|''{1}''을(를) 사용해야 합니다
inspections.plugin.xml.no.need.to.specify.itnReporter=JetBrains에서 개발한 플러그인의 예외는 ITNReporter 통해 자동으로 보고되므로 명시적으로 지정할 필요가 없습니다
inspections.plugin.xml.no.plugin.icon.svg.file=<html>플러그인이 ''{0}''을(를) 제공해야 합니다(<a href="https://plugins.jetbrains.com/docs/intellij/plugin-icon-file.html?from=DevkitPluginXmlInspection">문서</a>)</html>
inspections.plugin.xml.plugin.jetbrains.no.change.notes=IntelliJ IDEA 프로젝트의 일부로 개발된 플러그인은 change-notes를 지정해야 합니다
inspections.plugin.xml.plugin.jetbrains.no.generic.plugin.url=IntelliJ IDEA 프로젝트의 일부로 개발된 플러그인은 제네릭 플러그인 url을 지정해야 합니다
inspections.plugin.xml.plugin.jetbrains.no.idea.version=IntelliJ IDEA 프로젝트의 일부로 개발된 플러그인은 빌드 스크립트에 의해 자동으로 생성되기 때문에 idea-version을 지정해야 합니다
inspections.plugin.xml.plugin.jetbrains.no.version=IntelliJ IDEA 프로젝트의 일부로 개발된 플러그인은 버전을 지정할 수 없습니다
inspections.plugin.xml.plugin.jetbrains.vendor.no.email=IntelliJ IDEA 프로젝트의 일부로 개발된 플러그인은 이메일을 지정할 수 없습니다
inspections.plugin.xml.plugin.jetbrains.vendor.no.url=IntelliJ IDEA 프로젝트의 일부로 개발된 플러그인은 ''{0}''을(를) url로 지정해야 합니다
inspections.plugin.xml.plugin.modules.description=각 줄은 단일 플러그인에 포함되고 쉼표로 구분된 모듈 이름 목록입니다.
inspections.plugin.xml.plugin.modules.label=멀티 모듈 플러그인의 모듈:
inspections.plugin.xml.plugin.should.have.jetbrains.vendor=IntelliJ IDEA 프로젝트의 일부로 개발된 플러그인은 'JetBrains'을 벤더로 지정해야 합니다
inspections.plugin.xml.product.descriptor.invalid.date=날짜는 YYYYMMDD 숫자이거나 자리표시자(예: __DATE__)여야 합니다
inspections.plugin.xml.product.descriptor.invalid.version=버전은 숫자이거나 자리표시자(예: __VERSION__)여야 합니다
inspections.plugin.xml.service.interface.class.redundant=불필요한 속성 'serviceInterface'
inspections.plugin.xml.since.build.could.not.determine.platform.version=타깃 플랫폼 버전을 파악할 수 없습니다. 프로젝트 설정을 확인하세요
inspections.plugin.xml.since.build.could.not.locate.main.descriptor=필수 <idea-version> 'since-build'를 파악하기 위한 메인 plugin.xml 파일을 찾을 수 없습니다
inspections.plugin.xml.since.build.listeners.not.available=기능은 플랫폼 버전 {0}부터만 사용 가능하나 지정된 ''since-build'' 플랫폼은 ''{1}''입니다
inspections.plugin.xml.since.build.listeners.os.attribute=속성 ''os''는 플랫폼 {0} 버전 이후에서만 사용 가능하나 ''since-build'' 플랫폼이 ''{1}'' 입니다
inspections.plugin.xml.since.build.must.be.specified=<idea-version> 'since-build'를 지정해야 합니다
inspections.plugin.xml.skipForDefaultProject.deprecated='skipForDefaultProject'는 곧 사용할 수 없게 됩니다. 기본적으로 프로젝트 구성 요소가 디폴트 프로젝트에서 로드되지 않습니다
inspections.plugin.xml.specify.defaultExtensionNs.explicitly=명시적으로 defaultExtensionNs="{0}" 지정
inspections.plugin.xml.synonym.both.key.and.text='<synonym>'은 'key' 또는 'text' 속성을 둘 다 지정할 수 없습니다
inspections.plugin.xml.synonym.missing.key.and.text='<synonym>'은 'key' 또는 'text' 속성 중 하나를 지정해야 합니다
inspections.plugin.xml.third.party.plugins.must.not.use.itnReporter='com.intellij.diagnostic.ITNReporter'는 JetBrains의 내부 처리 오류를 보고하므로 제3자 플러그인에서 사용될 수 없습니다
inspections.plugin.xml.until.build.misleading.plain.number=''until-build'' 속성의 일반 숫자는 오해의 소지가 있습니다. ''{0}''은(는) ''{0}.0''과 동일하기 때문에 플러그인이 {0}.* builds와 호환되지 않습니다. 대신 ''{1}''을(를) 지정하는 것이 낫습니다.
inspections.plugin.xml.until.build.must.be.greater.than.since.build="until-build"이 "since-build"보다 커야 합니다
inspections.plugin.xml.until.build.use.asterisk.instead.of.big.number=''until-build''에서 ''{0}'' 사용 안 함,  대신 ''*'' 사용
inspections.plugin.xml.usage.of.experimental.api=@{0}(으)로 표시된 API가 사용되고 있습니다.이러한 API는 향후 IDE 버전에서 변경되거나 삭제되어 호환성 문제가 발생할 수 있습니다.
inspections.plugin.xml.usage.of.internal.api=@{0}(으)로 표시된 API가 사용되고 있습니다. 이러한 API는 IntelliJ IDEA 프로젝트 밖에서는 사용할 수 없습니다.
inspections.plugin.xml.usage.of.obsolete.api=@{0}(으)로 표시된 API가 사용되고 있습니다. 이러한 API는 새 코드에서 사용할 수 없습니다.
inspections.plugin.xml.use.defaultExtensionNs=대신 defaultExtensionNs 사용
inspections.plugin.xml.value.exceeds.max.length=값의 길이가 최대값 {0}을(를) 초과합니다
inspections.plugin.xml.value.must.have.minimum.length=값은 최소 {0}자리여야 합니다
inspections.plugin.xml.vendor.must.be.specified='<vendor>'가 지정되어야 합니다
inspections.plugin.xml.vendor.specify.jetbrains=JetBrains을 벤더로 지정
inspections.plugin.xml.version.must.be.specified='<version>'이 지정되어야 합니다
inspections.postfix.description.no.before.after.template=접미사 템플릿에는 'description.html' 이외에 'before.*.template' 및 'after.*.template'이 있어야 합니다
inspections.postfix.description.not.found=접미사 템플릿에 설명이 없습니다
inspections.presentation.cannot.resolve.icon=아이콘 ''{0}''을(를) 해결할 수 없습니다
inspections.psi.element.concat.add.get.text.family.name=텍스트 표현 검색 메서드 호출
inspections.psi.element.concat.add.get.text.name=''{0}'' 호출 사용
inspections.psi.element.concat.psi.element=PsiElement에서 문자열로의 의심스러운 변환
inspections.psi.element.concat.psi.type=PsiType에서 문자열로의 의심스러운 변환
inspections.quick.fix.family.name=QuickFix의 getFamilyName() 구현은 특정 컨텍스트에 종속되어서는 안 됩니다
inspections.registration.problems.abstract=플러그인 구성 요소 클래스가 abstract여야 합니다
inspections.registration.problems.component.duplicate.interface=동일한 'interface-class'를 가진 여러 구성 요소는 허용되지 않습니다
inspections.registration.problems.component.incompatible.interface=구성 요소 클래스를 인터페이스 클래스 ''{0}''에 대입할 수 없습니다
inspections.registration.problems.incompatible.message=plugin.xml의 클래스 등록에 따르면 클래스는 ''{0}''을(를) 확장해야 합니다
inspections.registration.problems.missing.noarg.ctor=액션 클래스에는 인수 없는 생성자가 있어야 합니다
inspections.registration.problems.name=구성 요소 타입 불일치
inspections.registration.problems.quickfix.create.constructor=인수 없는 생성자 생성
inspections.registration.problems.quickfix.read-only=클래스 ''{0}''이(가) 읽기 전용입니다
inspections.stateful.extension.point.do.not.use.in.extension=확장에서 {0}을(를) 필드로 사용하면 안 됩니다
inspections.stateful.extension.point.do.not.use.in.quick.fix=빠른 수정에서 {0}을(를) 필드로 사용하면 안 됩니다
inspections.stateful.extension.point.leak.psi.element=잠재적 메모리 누수: PsiElement를 유지하지 말고 대신 SmartPsiElementPointer를 사용하세요
inspections.stateful.extension.point.leak.psi.element.quick.fix=LocalQuickFixOnPsiElement 또한 참조하세요.
inspections.static.initialization.in.extensions.message=Extension point implementations must not use static initialization
inspections.static.initialization.in.extensions.name=Static initialization in extension point implementations
inspections.statistics.collector.not.registered.message=plugin.xml에 통계 컬렉터가 등록되지 않았습니다
inspections.statistics.collector.not.registered.name=통계 컬렉터가 등록되지 않음
inspections.undesirable.class.use.instead=대신 ''{0}''을(를) 사용하세요
inspections.unresolved.plugin.config.reference=해결되지 않은 플러그인 구성 참조
inspections.unsafe.return.insert.family.name=익명/로컬 클래스 건너뛰기
inspections.unsafe.return.insert.visit.class.method=visitClass 메서드 삽입
inspections.unsafe.return.insert.visit.lambda.expression=visitLambdaExpression 메서드 삽입
inspections.unsafe.return.insert.visit.lambda.expression.and.class.methods=visitLambdaExpression/visitClass 메서드 삽입
inspections.unsafe.return.message='visitReturnStatement'를 사용하는 재귀 방문자는 익명/로컬 클래스('visitClass') 및 람다 식('visitLambdaExpression')을 구체적으로 처리해야 할 가능성이 높습니다
inspections.unsafe.vfs.recursion=재귀 메서드에서 호출된 'VirtualFile.getChildren()'
inspections.unspecified.actions.place.popup.menu=지정되지 않은 액션 팝업 메뉴 위치
inspections.unspecified.actions.place.toolbar=지정되지 않은 액션 툴바 위치
inspections.usage.uelement.as.psi=UElement을 PsiElement로 사용하지 않는 것이 좋습니다
inspections.use.couple.family.name='Pair'를 'Couple'로 바꾸기
inspections.use.couple.of='Couple.of()'로 바꾸기
inspections.use.couple.type=''Couple<{0}>''로 바꾸기
inspections.use.dpi.aware.empty.border.can.be.simplified=빈 테두리 생성을 단순화 가능
inspections.use.dpi.aware.empty.border.convert.fix.name='JBUI.Borders.empty(...)'로 변환
inspections.use.dpi.aware.empty.border.not.dpi.aware='EmptyBorder'는 DPI를 인식하지 않습니다
inspections.use.dpi.aware.empty.border.simplify.fix.name=단순화
inspections.use.dpi.aware.insets.can.be.simplified=Insets 생성을 단순화할 수 있습니다
inspections.use.dpi.aware.insets.convert.fix.name='JBUI.insets(...)'로 변환
inspections.use.dpi.aware.insets.not.dpi.aware='Insets'는 DPI를 인식하지 않습니다
inspections.use.dpi.aware.insets.simplify.fix.name=단순화
inspections.use.equals.description=''{0}'' 인스턴스는 동일성이 아닌 상등으로 비교해야 합니다
inspections.use.equals.fix.replace.equality.with.equals.family.name=상등 연산자를 'equals()'로 바꾸기
inspections.use.equals.fix.replace.equality.with.equals.name=''{0}''을(를) ''equals()''로 바꾸기
inspections.use.equals.fix.replace.equality.with.not.equals.name=''{0}''을(를) ''!equals()''로 바꾸기
inspections.use.gray.awt.color.used.name=회색에 'java.awt.Color'가 사용되었습니다
inspections.use.gray.fix.convert.family.name='Gray'로 변환
inspections.use.gray.fix.convert.name=''Gray._{0}''(으)로 변환
inspections.wrap.application.service.in.supplier.quick.fix.message=애플리케이션 서비스를 'java.util.function.Supplier'에서 래핑
intellij.api.annotations.update.task.title=IntelliJ API 어노테이션 {0} 업데이트 중
invalid.order.attribute.part=잘못된 ''order'' 속성 값 부분: ''{0}''. ''first'', ''last'', ''before <id>'' 또는 ''after <id>''여야 합니다
line.marker.related.property.description=관련 프로퍼티
line.marker.related.property.popup.title=관련 프로퍼티
line.marker.related.property.tooltip=관련 프로퍼티
manifest.selection=선택한 {0}이(가) 결과 배포에 포함됩니다
manifest.settings=매니페스트 설정
manifest.use.user.defined=사용자 매니페스트 사용:
message.bundle.convert.advanced.setting.id.cannot.resolve=고급 설정 ID ''{0}''을(를) 해결할 수 없습니다
message.bundle.convert.toolwindow.id.cannot.resolve=도구 창 ID ''{0}''을(를) 해결할 수 없습니다
module.builder.github.template.link=모든 기능을 갖춘 GitHub 템플릿
module.builder.how.to.link=IntelliJ 기반의 IDE용 플러그인 빌드 방법
module.builder.scala.github.template.link=Scala와 SBT로 플러그인을 개발하는 방법
module.builder.title=IDE 플러그인
module.builder.type=타입:
module.builder.type.plugin=플러그인
module.builder.type.theme=테마
module.description=플러그인 모듈은 <b>IntelliJ 플랫폼</b> 기반 IDE 플러그인 개발에 사용됩니다.<br>이 모듈은 <b>IntelliJ 플랫폼 플러그인 SDK</b> 제공 및 IDE 내 플러그인의 실행 및 디버그를 위한 <b>실행 구성</b>을 설정해 줍니다.
module.title=IntelliJ 플랫폼 플러그인
module.wizard.devkit.simple.plugin.label=<html>이 프로젝트 타입은 사용자 지정 UI 테마 등 단순한 플러그인에서 사용하는 것이 좋습니다.<br> 더 복잡한 플러그인의 경우, Gradle 기반의 프로젝트가 <a href="https://plugins.jetbrains.com/docs/intellij/developing-plugins.html?from=DevkitPluginModuleWizard">권장</a>됩니다.
module.wizard.gradle.plugin.xml.template.display.name=Gradle 기반 프로젝트 내 plugin.xml
new.action.action.name=새 액션 생성 중: {0}.{1}
new.action.add.to.group=그룹에 추가
new.action.cannot.create.class=액션 클래스를 생성할 수 없습니다
new.action.class.name=클래스 이름(&C):
new.action.description=설명(&D):
new.action.dialog.title=새 액션
new.action.error=액션을 생성할 수 없음
new.action.group.actions=액션(&I):
new.action.group.anchor=앵커:
new.action.group.anchor.=마지막(&L)
new.action.group.anchor.after=이후(&T)
new.action.group.anchor.before=이전(&B)
new.action.group.anchor.first=첫 번째(&F)
new.action.group.groups=그룹(&G):
new.action.id=액션 ID(&A):
new.action.invalid.class.name=액션 클래스 이름이 올바른 Java 정규화된 이름이 아닙니다
new.action.invalid.id=액션 ID가 공백일 수 없습니다
new.action.invalid.name=액션 이름이 공백일 수 없습니다
new.action.keyboard.clear=X
new.action.keyboard.clear.tooltip=단축키 지우기
new.action.keyboard.first=첫 번째:
new.action.keyboard.second=두 번째:
new.action.keyboard.shortcuts=키보드 단축키
new.action.text=이름(&N):
new.menu.action.text=액션
new.menu.application.component.text=애플리케이션 구성 요소
new.menu.module.component.text=모듈 구성 요소
new.menu.project.component.text=프로젝트 구성 요소
notification.group.devkit.deployment=플러그인 배포 완료됨
notification.group.testdata=테스트 데이터 파일을 찾을 수 없습니다
plugin.descriptor=IntelliJ 플랫폼 플러그인 설명자
plugin.descriptor.chooser.cannot.find=플러그인 서명자를 찾을 수 없습니다
plugin.descriptor.chooser.popup.title=플러그인 설명자 선택
plugin.xml.convert.action.or.group.cannot.resolve={0} ''{1}''을(를) 해결할 수 없습니다
plugin.xml.convert.action.or.group.invalid.name=<잘못된 이름>
plugin.xml.convert.action.or.group.type.action=액션
plugin.xml.convert.action.or.group.type.action.or.group=액션 또는 그룹
plugin.xml.convert.action.or.group.type.group=그룹
plugin.xml.convert.enum.cannot.resolve={1}의 ''{0}''을(를) 해결할 수 없습니다
plugin.xml.convert.extension.order.cannot.resolve='''''{'0'}''''' {0}확장을 해결할 수 없습니다
plugin.xml.convert.extension.property.cannot.resolve=확장점 프로퍼티 ''{0}''을(를) 해결할 수 없습니다
plugin.xml.convert.keymap.cannot.resolve=키맵 ''{0}''을(를) 해결할 수 없습니다
plugin.xml.convert.language.id.any.language.display.name=<모든 언어>
plugin.xml.convert.language.id.cannot.resolve=ID가 "{0}"인 언어를 해결할 수 없습니다
plugin.xml.convert.module.descriptor.name=모듈 ''{1}''의 소스 루트 내 모듈 설명자 ''{0}''을(를) 해결할 수 없습니다
plugin.xml.convert.property.bundle.cannot.resolve=프로퍼티 번들을 해결할 수 없습니다
plugin.xml.scopes.display.name=플러그인 설명자 파일
plugin.xml.scopes.production.display.name=모든 프로덕션 플러그인 설명자 파일
prepare.for.deployment=배포할 플러그인 모듈 ''{0}'' 준비
prepare.for.deployment.all=배포할 모든 플러그인 모듈 준비
prepare.for.deployment.task=배포할 플러그인 모듈 ''{0}'' 준비
prepare.for.deployment.task.progress=배포 준비 중
program.parameters=프로그램 인수(&P)
progress.title.calculate.target.properties.file=타깃 프로퍼티 파일 계산
register.extension.fix.name=레지스터 확장
register.extension.fix.popup.title=확장점 선택
register.inspection.fix.family.name=레지스터 검사
register.inspection.fix.name=레지스터 검사 ''{0}''
registry.properties.annotator.add.description.family.name=선언 키 추가
registry.properties.annotator.add.description.text=''{0}'' 선언 키 추가
registry.properties.annotator.key.no.description.key=Key ''{0}''에 설명 키가 없습니다
registry.properties.annotator.plugin.keys.use.ep='com.intellij.registryKey' 확장점을 통해 플러그인 전용 키를 등록해야 합니다
registry.properties.annotator.show.ep.family.name=확장점 선언 표시
registry.properties.annotator.show.ep.message=플러그인 설명자 XML로 이 선언 복사
registry.properties.annotator.show.ep.name=''{0}''의 확장점 선언 표시
registry.properties.annotator.show.ep.title=확장점 선언
run.configuration.no.module.specified=구성에서 플러그인 모듈이 지정되어 있지 않습니다
run.configuration.title=플러그인
run.configuration.type.description=플러그인 샌드박스 환경
sandbox.home=샌드박스 홈
sandbox.home.label=샌드박스 홈:
sandbox.no.configured=IntelliJ 플랫폼 플러그인 SDK에 지정된 샌드박스 없음
sandbox.no.sdk=SDK를 구성하세요
sandbox.purpose=타깃 IDE의 구성, 시스템, 플러그인을 저장할 폴더 찾아보기
sandbox.specification=샌드박스를 구성해주세요
saved.message= 모듈 ''{1}'' 의 {0, choice, 1#Zip|2#JAR} 파일이 {2}에 저장되었습니다
saved.message.common=선택한 디렉터리에서 {0}이(가) 저장됩니다
sdk.from.sources.scanning.roots=루트 검사 중
sdk.no.idea.sdk.version.found=IntelliJ 플랫폼 플러그인 SDK에 필요한 JDK 버전을 탐지하지 못했습니다.
sdk.no.java.sdk.for.idea.sdk.found=적절한 버전의 Java SDK를 찾을 수 없습니다. IntelliJ 플랫폼 플러그인 SDK와 더불어 동일한 Java 버전({0})의 JDK를 정의해야 합니다.
sdk.no.java.sdk.for.idea.sdk.found.title=Java JDK를 찾을 수 없음
sdk.no.specified=플러그인 모듈 ''{0}''에 지정된 SDK가 없습니다
sdk.select.java.sdk=IntelliJ 플랫폼 플러그인 SDK에 사용될 Java SDK 선택
sdk.select.java.sdk.label=내부 Java 플랫폼:
sdk.select.java.sdk.title=내부 Java 플랫폼 선택
sdk.title=IntelliJ 플랫폼 플러그인 SDK
sdk.type.incorrect=플러그인 모듈 ''{0}''의 SDK 타입이 잘못되었습니다.
sdk.type.incorrect.common=플러그인 모듈의 잘못된 SDK 타입
select.plugin.module.to.patch=패치할 플러그인 모듈 선택
select.plugin.modules.description=배포 준비할 모듈 선택
select.plugin.modules.title=모듈 선택
select.target.location.of.description={0}의 타깃 위치 선택
structure.sort.alphabetically.in.groups=그룹 내 알파벳순 정렬
structure.sort.alphabetically.in.groups.description=그룹 내 알파벳순 정렬
success.deployment.message=플러그인 모듈 ''{0}''의 배포 준비가 성공적으로 완료되었습니다
success.deployment.message.all=모든 플러그인의 배포 준비가 완료되었습니다
suggest.to.delete=''{0}''을(를) 삭제하시겠어요?
testdata.confirm.create.missing.files.dialog.message=다음 testdata 파일을 생성합니다.\n\
{0}
testdata.create.dialog.title=테스트 데이터 파일 생성
testdata.create.missing.files=누락된 파일 생성
testdata.file.doesn.not.exist=<html>참조된 테스트 데이터 파일 {0}이(가) 없습니다. 해당 파일을 생성하시겠어요?</html>
testdata.goto.test.data.action.text={0}(으)로 이동
testdata.notification.no.test.datafiles.content=클래스의 테스트 데이터 파일을 찾을 수 없습니다
testdata.notification.no.test.datafiles.title=테스트 데이터 파일을 찾을 수 없음
testdata.popup.navigation.title=테스트 데이터
testdata.progress.text.searching.for.test.data.files=''{0}'' 테스트 데이터 파일 검색 중…
testdata.related.navigation.group=테스트 데이터
testdata.related.navigation.title=테스트 데이터
testdata.searching=테스트 데이터 파일 검색 중
update.ide.from.sources=Update &IDE from sources
update.ide.from.sources.option=from sources
vm.parameters=VM 옵션(&V)