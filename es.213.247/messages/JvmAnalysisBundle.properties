jvm.inspections.group.name=JVM 언어

jvm.inspections.unstable.api.usage.display.name=불안정한 API 사용
jvm.inspections.unstable.api.usage.annotations.list=불안정한 API 어노테이션:
jvm.inspections.unstable.api.usage.ignore.inside.imports=import 문 내에서 무시
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=이 프로젝트에서 선언된 API 무시
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}''이(가) @{1}에서 불안정한 것으로 표시됩니다.
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}''이(가) @{3}(으)로 표시된 불안정한 {1} ''{2}''에서 선언되었습니다.
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=재정의된 메서드 ''{0}''이(가) @{1}에서 불안정한 것으로 표시됩니다.
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=재정의된 메서드 ''{0}''이(가) @{3}(으)로 표시된 불안정한 {1} ''{2}''에서 선언되었습니다.
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}''이(가) @{3}(으)로 표시된 불안정한 {1} ''{2}''을(를) 해당 시그니처에서 참조하고 있으므로 불안정합니다

jvm.inspections.scheduled.for.removal.future.version=향후 버전
jvm.inspections.scheduled.for.removal.predefined.version=버전 {0}
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}''은(는) {1}에서 제거될 예정입니다.
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}''이(가) {3}에서 제거될 예정인 {1} ''{2}''에서 선언되었습니다.
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=재정의된 메서드 ''{0}''은(는) {1}에서 제거될 예정입니다.
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=재정의된 메서드 ''{0}''이(가) {3}에서 제거될 예정인 {1} ''{2}''에서 선언되었습니다.
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}''이(가) {3}에서 제거될 예정인 {1} ''{2}''을(를) 해당 시그니처에서 참조하고 있으므로 제거될 예정입니다

jvm.inspections.unstable.type.used.in.signature.display.name=불안정한 타입이 시그니처에서 사용됨
jvm.inspections.unstable.type.used.in.class.signature.description=클래스가 해당 선언에서 불안정한 타입 ''{1}''을(를) 참조하고 있으므로 ''@{0}'' 어노테이션으로 표시되어야 합니다.
jvm.inspections.unstable.type.used.in.method.signature.description=메서드가 불안정한 타입 ''{1}''을(를) 해당 시그니처에서 참조하고 있으므로 ''@{0}'' 어노테이션으로 표시되어야 합니다
jvm.inspections.unstable.type.used.in.field.signature.description=필드가 불안정한 타입 ''{1}''을(를) 해당 타입에서 참조하고 있으므로 ''@{0}'' 어노테이션으로 표시되어야 합니다.

jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=제거 예정인 API에서 누락된 '@Deprecated' 어노테이션
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=제거 예정인 API도 '@Deprecated' 어노테이션으로 표시되어야 합니다.
jvm.inspections.must.already.be.removed.api.display.name=API가 이미 제거되었습니다.
jvm.inspections.must.already.be.removed.api.earlier.version.description=API가 {0}에서 제거되었으나 현재 버전은 {1}입니다.
jvm.inspections.must.already.be.removed.api.current.version.description=API가 현재 버전 {0}에서 제거되었습니다.
jvm.inspections.blocking.method.problem.descriptor=블록 컨텍스트가 아닌 상황에서 호출을 막는 것은 스레드에서 기아 상태를 일으킬 수 있습니다
jvm.inspections.blocking.method.display.name=논블로킹 컨텍스트의 잠재적 블로킹 호출
jvm.inspections.blocking.method.annotation.blocking=Blocking 어노테이션
jvm.inspections.blocking.method.annotation.non-blocking=Non-Blocking 어노테이션
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=Blocking 어노테이션 추가
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=Non-Blocking 어노테이션 추가
jvm.inspections.blocking.method.annotation.configure.empty.text=추가된 어노테이션이 없습니다.

jvm.inspections.api.no.extension.display.name=클래스, 인터페이스 또는 메서드가 확장되면 안 됨
jvm.inspections.api.no.extension.class.description=클래스 ''{0}''은(는) 확장되면 안 됩니다.
jvm.inspections.api.no.extension.interface.implement.description=인터페이스 ''{0}''은(는) 구현되면 안 됩니다.
jvm.inspections.api.no.extension.interface.extend.description=인터페이스 ''{0}''은(는) 확장되면 안 됩니다.
jvm.inspections.api.no.extension.method.overriding.description=메서드 ''{0}''은(는) 재정의되면 안 됩니다.
jvm.inspections.api.override.only.display.name=메서드는 재정의만 가능
jvm.inspections.api.override.only.description=메서드 ''{0}''은(는) 재정의만 가능합니다.

jvm.inspections.dependency.display.name=잘못된 패키지 종속 요소
jvm.inspections.dependency.edit.rules.text=종속 요소 규칙 "{0}" 편집
jvm.inspections.dependency.edit.rules.family=종속 요소 규칙 편집
jvm.inspections.dependency.configure.button.text=종속 요소 규칙 구성
jvm.inspections.dependency.violator.problem.descriptor=종속 요소 규칙 ''{0}.''이(가) 위반되었습니다

jvm.inspections.junit.rule.display.name=형식이 잘못된 @Rule/@ClassRule 필드
jvm.inspections.junit.rule.problem.descriptor=''@{0}''(으)로 어노테이션이 추가된 필드는 {1}이어야(여야) 합니다
jvm.inspections.junit.rule.type.problem.descriptor=필드 타입은 'org.junit.rules.TestRule'의 하위 타입이어야 합니다

jvm.inspections.testonly.display.name=프로덕션 코드 내 테스트 전용 사용 위치
jvm.inspections.testonly.class.reference=테스트 전용 클래스가 프로덕션 코드에서 참조됩니다
jvm.inspections.testonly.field.reference=테스트 전용 필드가 프로덕션 코드에서 참조됩니다
jvm.inspections.testonly.method.call=테스트 전용 메서드가 프로덕션 코드에서 호출됩니다
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting은 @TestOnly 코드에서 의미가 없습니다

jvm.inspections.string.touppercase.tolowercase.without.locale.description=국제화된 문자열을 사용하는 로케일을 지정하지 않은 상태에서 <code>String.{0}()</code>이(가) 호출됩니다 #loc
can.t.build.uast.tree.for.file=파일에 대한 UAST 트리를 빌드할 수 없습니다.
title.uast=UAST
current.version=현재 버전
dialog.title.choose.annotation={0} 선택 
jvm.inspection.test.failed.line.display.name=테스트에서 실패한 줄
jvm.inspections.source.to.sink.flow.display.name=안전하지 않은 문자열이 안전한 메서드로 전달됨
jvm.inspections.junit5.assertions.converter.display.name=JUnit 5 테스트에서 곧 사용할 수 없게 될 어설션
jvm.inspections.junit5.assertions.converter.problem.descriptor=''{0}''의 <code>#ref()</code> 호출을 ''{1}''의 메서드 호출로 바꿔야 합니다 #loc
jvm.inspections.junit5.assertions.converter.quickfix=''{0}'' 메서드 호출로 바꿉니다.
jvm.inspections.junit5.assertions.converter.familyName=JUnit 5 호환 호출로 바꾸기
jvm.inspections.junit5.converter.display.name=JUnit 4 테스트가 JUnit 5가 될 수 있음
jvm.inspections.junit5.converter.problem.descriptor=#ref이(가) JUnit 5 테스트일 수 있습니다
jvm.inspections.junit5.converter.quickfix=JUnit 5로 마이그레이션
jvm.inspections.junit5.converter.quickfix.presentation.text=어설션 변환
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=호환되지 않는 상속자가 있으므로 클래스 {0}을(를) JUnit 5로 변환할 수 없습니다. {1}
jvm.inspections.thread.run.display.name='Thread.run()' 호출
jvm.inspections.serializable.class.without.serialversionuid.display.name='serialVersionUID'가 없는 serializable 클래스
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code>이(가) 'serialVersionUID' 필드를 정의하지 않습니다 #loc
jvm.inspections.source.to.sink.flow.passed.unsafe=안전하지 않은 문자열이 안전한 메서드로 전달됨
jvm.inspections.source.to.sink.flow.passed.unknown=안전하지 않은 문자열이 안전한 메서드로 전달됨
jvm.inspections.source.to.sink.flow.returned.unsafe=안전하지 않은 문자열이 안전한 메서드에서 반환됨
jvm.inspections.source.to.sink.flow.returned.unknown=알 수 없는 문자열이 안전한 메서드에서 반환됨
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=검증 필요로 표시
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=''{0}''을(를) 검증 필요로 표시
jvm.inspections.blocking.method.consider.unknown.context.blocking=알 수 없는 컨텍스트 막기를 고려하세요
jvm.inspections.blocking.method.problem.wildcard.descriptor={0}에서 호출을 막는 것은 스레드에서 기아 상태를 일으킬 수 있습니다