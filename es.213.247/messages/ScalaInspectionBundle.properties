fileName.does.not.match=í?´ëž˜ìŠ¤ê°€ íŒŒì?¼ ì?´ë¦„ê³¼ ì?¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤
method.signature.accessor.empty.parenthesis=ì ‘ê·¼ìž?ì‹? ì?´ë¦„ì?´ ì§€ì •ë?œ ë©”ì„œë“œê°€ ë¹ˆ ì†Œê´„í˜¸ìž…ë‹ˆë‹¤
method.signature.accessor.unit.return.type=ì ‘ê·¼ìž?ì‹? ì?´ë¦„ì?´ ì§€ì •ë?œ ë©”ì„œë“œì?˜ ê²°ê³¼ ìœ í˜•ì?´ Unitìž…ë‹ˆë‹¤
method.signature.unit.parameterless=ê²°ê³¼ ìœ í˜•ì?´ Unitì?¸ ë©”ì„œë“œëŠ” ë§¤ê°œë³€ìˆ˜ë¥¼ í?¬í•¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤
method.signature.procedure.declaration=ë©”ì„œë“œ ì„ ì–¸ ë‚´ í”„ë¡œì‹œì € êµ¬ë¬¸
method.signature.procedure.definition=ë©”ì„œë“œ ì •ì?˜ ë‚´ í”„ë¡œì‹œì € êµ¬ë¬¸
method.signature.result.type.refinement=ëª…í™•í•œ ê²°ê³¼ ìœ í˜• ê°œì„ ; ëŒ€ìž…ì?´ ëˆ„ë?½ë?˜ì—ˆìŠµë‹ˆê¹Œ?
method.signature.parameterless.override.empty.paren=ë§¤ê°œë³€ìˆ˜ ì—†ì?´ ìž¬ì •ì?˜ë?œ ë¹ˆ ì†Œê´„í˜¸ Scala ë©”ì„œë“œ
method.signature.parameterless.override.java.mutator=ë§¤ê°œë³€ìˆ˜ ì—†ì?´ ìž¬ì •ì?˜ë?œ Java ì„¤ì •ìž? ë©”ì„œë“œ
method.signature.parameterless.override.mutator.like=ì„¤ì •ìž?ì‹? ì?´ë¦„ì?´ ì§€ì •ë?œ ë©”ì„œë“œ withì?˜ ë§¤ê°œë³€ìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤
method.signature.override.abstract.member=ìž¬ì •ì?˜ í‚¤ì›Œë“œë¡œ ì¶”ìƒ? ë©¤ë²„ë¥¼ ìž¬ì •ì?˜í•˜ëŠ” ë©”ì„œë“œ í‘œì‹œ
method.signature.empty.paren.override.java.accessor=ë¹ˆ ì†Œê´„í˜¸ë¡œ ìž¬ì •ì?˜ë?œ Java ì ‘ê·¼ìž? ë©”ì„œë“œ
method.signature.empty.paren.override.parameterless=ë¹ˆ ì†Œê´„í˜¸ë¡œ ìž¬ì •ì?˜ë?œ ë§¤ê°œë³€ìˆ˜ê°€ ì—†ëŠ” Scala ë©¤ë²„
method.signature.parameterless.access.java.mutator=ë§¤ê°œë³€ìˆ˜ ì—†ì?´ ì ‘ê·¼ ê°€ëŠ¥í•œ Java ì„¤ì •ìž? ë©”ì„œë“œ
method.signature.parameterless.access.empty.paren=ë§¤ê°œë³€ìˆ˜ ì—†ì?´ ì ‘ê·¼ë?œ ë¹ˆ ì†Œê´„í˜¸ ë©”ì„œë“œ
method.signature.java.accessor.empty.paren=ë¹ˆ ì†Œê´„í˜¸ë¡œ í˜¸ì¶œë?œ Java ì ‘ê·¼ìž? ë©”ì„œë“œ
typed.parameter.without.parenthesis.in.function.literal=í•¨ìˆ˜ ë¦¬í„°ëŸ´ ë‚´ ì†Œê´„í˜¸ ì—†ì?´ ìœ í˜• ì§€ì •ë?œ ë§¤ê°œë³€ìˆ˜
unused.expression.name=ì‚¬ìš©ë?˜ì§€ ì•Šì?€ í‘œí˜„ì‹?
unreachable.code.name=ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ì½”ë“œ
internal.getText.contains.shouldBe.textContains=.getText.containsëŠ” .textContainsì—¬ì•¼ í•©ë‹ˆë‹¤
internal.getText.equals.shouldBe.textMatches=.getText.equalsëŠ” . textMatchesì—¬ì•¼ í•©ë‹ˆë‹¤
internal.api.status.of.symbols=ì‹¬ë³¼ì?˜ Api ìƒ?íƒœ
internal.instanceOf.shouldBe.is=instanceOfëŠ” ë‹¤ì?Œì?´ì–´ì•¼ í•©ë‹ˆë‹¤
displayname.scala=Scala
displayname.scala.compile.server=Scala ì»´íŒŒì?¼ ì„œë²„
displayname.scala.compiler=Scala ì»´íŒŒì?¼ëŸ¬
displayname.loop.variable.not.updated.inside.loop=ë£¨í”„ ë³€ìˆ˜ê°€ ë£¨í”„ ë‚´ì—?ì„œ ì—…ë?°ì?´íŠ¸ë?˜ì§€ ì•Šì?Œ
displayname.package.name.inspection=ìž˜ëª»ë?œ package ë¬¸
displayname.scala.deprecation=Scala ì‚¬ìš© ì¤‘ë‹¨
displayname.deprecated.identifier=ë?” ì?´ìƒ? ì‚¬ìš©ë?˜ì§€ ì•ŠëŠ” ì‹?ë³„ìž?
displayname.deprecated.kind.projector.syntax=ë?” ì?´ìƒ? ì‚¬ìš©ë?˜ì§€ ì•ŠëŠ” kind-projector êµ¬ë¬¸
displayname.case.class.parameter=ì¼€ì?´ìŠ¤ í?´ëž˜ìŠ¤ ë§¤ê°œë³€ìˆ˜
displayname.var.could.be.a.val=''var''ì?´ ''val''ì?¼ ìˆ˜ ìžˆìŠµë‹ˆë‹¤
displayname.unused.symbol=SÃ­mbolo obsoleto
displayname.in.kind.projector.use.correct.lambda.keyword=Kind Projector\: ì˜¬ë°”ë¥¸ ëžŒë‹¤ í‚¤ì›Œë“œ ì‚¬ìš©
displayname.in.kind.projector.simplify.type=Kind Projector\: ìœ í˜• ë‹¨ìˆœí™”
displayname.use.of.postfix.method.call=ì ‘ë‘?ì‚¬ ë©”ì„œë“œ í˜¸ì¶œ ì‚¬ìš©
displayname.advanced.language.features=ê³ ê¸‰ ì–¸ì–´ ê¸°ëŠ¥
displayname.reference.must.be.prefixed=ì°¸ì¡°ì—? ì ‘ë‘?ì‚¬ê°€ í•„ìš”í•©ë‹ˆë‹¤
displayname.floating.point.literal.ending.with.dot=''.''ë¡œ ë??ë‚˜ëŠ” ë¶€ë?™ ì†Œìˆ˜ì ? ë¦¬í„°ëŸ´
displayname.chained.package.clause.inspection=ê¸°ë³¸ íŒ¨í‚¤ì§€ ì„ ì–¸
displayname.relative.import=ìƒ?ëŒ€ ê°€ì ¸ì˜¤ê¸°
displayname.suspicious.shadowing.by.a.variable.pattern=ë³€ìˆ˜ íŒ¨í„´ì—? ì?˜í•œ ì?˜ì‹¬ìŠ¤ëŸ¬ìš´ ê°€ë¦¬ê¸°
displayname.suspicious.shadowing.by.a.type.parameter=ìœ í˜• ë§¤ê°œë³€ìˆ˜ì—? ì?˜í•œ ì?˜ì‹¬ìŠ¤ëŸ¬ìš´ ê°€ë¦¬ê¸°
displayname.abstract.value.in.trait=íŠ¹ì„± ë‚´ ì¶”ìƒ? ê°’
displayname.unmatched.tag=ì?¼ì¹˜í•˜ì§€ ì•ŠëŠ” íƒœê·¸
displayname.unnecessary.braces.in.import.inspection=ê°€ì ¸ì˜¤ê¸° ê²€ì‚¬ ë‚´ ë¶ˆí•„ìš”í•œ ì¤‘ê´„í˜¸
displayname.name.boolean.parameters=ë¶€ìš¸ ë§¤ê°œë³€ìˆ˜ ì?´ë¦„ ì§€ì •
displayname.redundant.cast.inspection=ë¶ˆí•„ìš”í•œ í˜• ë³€í™˜ ê²€ì‚¬
displayname.redundant.conversion.inspection=ë¶ˆí•„ìš”í•œ ë³€í™˜ ê²€ì‚¬
displayname.missing.type.annotation=ìœ í˜• ì–´ë…¸í…Œì?´ì…˜ ëˆ„ë?½
displayname.malformed.format.string=í˜•ì‹?ì?´ ìž˜ëª»ë?œ ì„œì‹? ë¬¸ìž?ì—´
displayname.legacy.string.formatting=ê¸°ì¡´ ë¬¸ìž?ì—´ ì„œì‹? ì§€ì •
displayname.not.implemented.code=ì½”ë“œë¥¼ êµ¬í˜„í•˜ì§€ ì•Šì?Œ
displayname.redundant.block=ë¶ˆí•„ìš”í•œ ë¸”ë¡?
displayname.suspicious.forward.reference=ì?˜ì‹¬ìŠ¤ëŸ¬ìš´ ì „ë°© ì°¸ì¡°
displayname.type.annotation.required=ìœ í˜• ì–´ë…¸í…Œì?´ì…˜ í•„ìš”
displayname.double.negation=ì?´ì¤‘ ë¶€ì •
displayname.simplify.boolean.expression=ë¶€ìš¸ í‘œí˜„ì‹? ë‹¨ìˆœí™”
displayname.trivial.match.can.be.simplified=ìž?ëª…í•œ ì?¼ì¹˜ë¥¼ ë‹¨ìˆœí™”í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤
displayname.unnecessary.parentheses=ë¶ˆí•„ìš”í•œ ì†Œê´„í˜¸
displayname.type.check.can.be.pattern.matching=ìœ í˜• ê²€ì‚¬ê°€ íŒ¨í„´ ë§¤ì¹­ì?´ ë?  ìˆ˜ ìžˆìŠµë‹ˆë‹¤
displayname.comparing.unrelated.types=ê´€ë ¨ ì—†ëŠ” ìœ í˜• ë¹„êµ? ì¤‘
displayname.pattern.may.never.match=íŒ¨í„´ì?´ í•œ ë²ˆë?„ ì?¼ì¹˜í•˜ì§€ ì•Šì?„ ìˆ˜ ìžˆìŠµë‹ˆë‹¤
displayname.match.statement.convertible.to.pattern.matching.anonymous.function=íŒ¨í„´ ë§¤ì¹­ ì?µëª… í•¨ìˆ˜ë¡œ ë³€í™˜ ê°€ëŠ¥í•œ match êµ¬ë¬¸
displayname.view.bounds.are.deprecated=ë·° ë°”ìš´ë“œê°€ ë?” ì?´ìƒ? ì‚¬ìš©ë?˜ì§€ ì•ŠìŠµë‹ˆë‹¤
displayname.convert.expression.to.single.abstract.method=í‘œí˜„ì‹?ì?„ ë‹¨ì?¼ ì¶”ìƒ? ë©”ì„œë“œ(SAM)ë¡œ ë³€í™˜
displayname.nested.stateful.monads=ì¤‘ì²© ìƒ?íƒœ ëª¨ë‚˜ë“œ
displayname.field.from.delayedinit=DelayedInitì?˜ í•„ë“œ
displayname.non.value.field.is.accessed.in.hashcode=ê°’ì?´ ì•„ë‹Œ í•„ë“œê°€ ''hashCode()''ì—?ì„œ ì•¡ì„¸ìŠ¤ë?˜ì—ˆìŠµë‹ˆë‹¤
displayname.unnecessary.partial.function=ë¶ˆí•„ìš”í•œ ë¶€ë¶„ í•¨ìˆ˜
displayname.annotator.based.error.inspection=ì–´ë…¸í…Œì?´í„° ê¸°ë°˜ ì˜¤ë¥˜ ê²€ì‚¬
displayname.wrong.platform.method.usage=ìž˜ëª»ë?œ í”Œëž«í?¼ ë©”ì„œë“œ ì‚¬ìš© ìœ„ì¹˜
displayname.syntactic.sugar=ë¬¸ë²•ì ? ì„¤íƒ•
displayname.scala.unnecessary.semicolon.inspection=Comprobación de punto y coma innecesaria de Scala
displayname.redundant.return=ë¶ˆí•„ìš”í•œ ë°˜í™˜
displayname.postfix.unary.operation=Postfix unary operation
displayname.anonymous.function.convertible.to.a.method.value=ë©”ì„œë“œ ê°’ìœ¼ë¡œ ë³€í™˜ ê°€ëŠ¥í•œ ì?µëª… í•¨ìˆ˜
displayname.applied.type.lambda.can.be.simplified=ì ?ìš©ë?œ ëžŒë‹¤ ìœ í˜•ì?„ ë‹¨ìˆœí™”í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤
displayname.redundant.new.on.case.class=ì¼€ì?´ìŠ¤ í?´ëž˜ìŠ¤ì?˜ ë¶ˆí•„ìš”í•œ new
displayname.argument.duplicates.corresponding.parameter.default.value=ì?¸ìˆ˜ê°€ í•´ë‹¹ ë§¤ê°œë³€ìˆ˜ ë””í?´íŠ¸ ê°’ì?„ ë³µì œí•©ë‹ˆë‹¤
displayname.auto.tupling=ìž?ë?™ íŠœí”Œí™”
displayname.null.initializer.can.be.replaced.by.underscore=Null ì?´ë‹ˆì…œë?¼ì?´ì €ë¥¼ _ë¡œ ë°”ê¿€ ìˆ˜ ìžˆìŠµë‹ˆë‹¤
displayname.scala.style.inspection=Scala ìŠ¤íƒ€ì?¼ ê²€ì‚¬
displayname.simplifiable.empty.check=ë‹¨ìˆœí™” ê°€ëŠ¥í•œ ê³µë°± ê²€ì‚¬
displayname.size.to.length.on.arrays.and.strings=ë°°ì—´ ë°? ë¬¸ìž?ì—´ì?˜ sizeë¥¼ lengthë¡œ
displayname.equals.on.arrays.and.iterators=ë°°ì—´ ë°? ë°˜ë³µìž?ì?˜ ë“±í˜¸
displayname.sameelements.oncollections.of.a.same.kind=ë?™ì?¼í•œ ì¢…ë¥˜ì?˜ SameElements onCollections
displayname.corresponds.sameelements.on.unsorted.collection=ì •ë ¬ë?˜ì§€ ì•Šì?€ ì»¬ë ‰ì…˜ì?˜ Corresponds/sameElements
displayname.equals.oncollections.of.different.kinds=ë‹¤ë¥¸ ì¢…ë¥˜ì?˜ Equals onCollections
displayname.comparing.length.to.lengthcompare=length ë¹„êµ?ë¥¼ lengthCompareë¡œ
displayname.manually.zipping.with.indices=ìƒ‰ì?¸ìœ¼ë¡œ ìˆ˜ë?™ ì••ì¶• ì¤‘
displayname.access.to.first.element.by.index=ìƒ‰ì?¸ìœ¼ë¡œ ì²« ìš”ì†Œì—? ì•¡ì„¸ìŠ¤
displayname.access.to.last.element.by.index=ìƒ‰ì?¸ìœ¼ë¡œ ë§ˆì§€ë§‰ ìš”ì†Œì—? ì•¡ì„¸ìŠ¤
displayname.constructing.range.for.seq.indices=ì‹œí€€ìŠ¤ ìƒ‰ì?¸ ë²”ìœ„ ìƒ?ì„± ì¤‘
displayname.filter.and.headoption.to.find=filter ë°? headOptionë¥¼ findë¡œ
displayname.find.and.emptiness.check.to.exists=ì°¾ê¸° ë°? ê³µë°± ê²€ì‚¬ë¥¼ existsë¡œ
displayname.filter.and.emptiness.check.to.exists.forall=filter ë°? ê³µë°± ê²€ì‚¬ë¥¼ exists/forallë¡œ
displayname.filter.and.size.to.count=filter ë°? sizeë¥¼ countë¡œ
displayname.find.and.map.to.get=find ë°? mapì?„ getìœ¼ë¡œ
displayname.exists.simplifiable.to.contains=containsë¡œ ë‹¨ìˆœí™” ê°€ëŠ¥í•œ exists
displayname.map.and.contains.true.false.to.exists.or.forall=Map ë°? contains(true/false)ë¥¼ exists ë˜?ëŠ” \!forallë¡œ
displayname.filter.and.contains.to.intersect.or.diff=filter ë°? containsë¥¼ intersect ë˜?ëŠ” diffë¡œ
displayname.redundant.contains.in.filter=filter ë‚´ ë¶ˆí•„ìš”í•œ contains
displayname.double.negation.in.forall.and.exists=forall ë°? exists ë‚´ ì?´ì¤‘ ë¶€ì •
displayname.simplifiable.fold.or.reduce.method=ë‹¨ìˆœí™” ê°€ëŠ¥í•œ fold ë˜?ëŠ” reduce ë©”ì„œë“œ
displayname.fold.simplifiable.to.forall=forallë¡œ ë‹¨ìˆœí™” ê°€ëŠ¥í•œ fold
displayname.reverse.and.iterator.to.reverseiterator=reverse ë°? iteratorë¥¼ reverseIteratorë¡œ
displayname.reverse.find.to.findLast=reverse ë°? findë¥¼ findLastë¡œ
displayname.conversion.to.set.and.back.to.distinct=Setë¡œ ë³€í™˜í•˜ê³  distinctë¡œ ë³µì›?
displayname.drop.and.take.to.slice=drop ë°? takeë¥¼ sliceë¡œ ë°”ê¾¸ê¸°
displayname.reverse.take.and.reverse.to.takeright=reverse, take ë°? reverseë¥¼ takeRightìœ¼ë¡œ
displayname.map.and.flatten.to.flatmap=Map ë°? flattenì?„ flatMapìœ¼ë¡¤
displayname.emulated.headoption.or.lastoption=ëª¨ë°©ë?œ headOption ë˜?ëŠ” lastOption
displayname.replace.to.with.until=toë¥¼ untilë¡œ ë°”ê¾¸ê¸°
displayname.replace.with.flatten=flattenìœ¼ë¡œ ë°”ê¾¸ê¸°
displayname.sorted.and.head.last.to.max.min=sorted ë°? head/lastë¥¼ max/minë¡œ
displayname.collect.and.headoption.to.collectfirst=collect ë°? headOptionì?„ collectFirstë¡œ
displayname.index.bounds.check=ìƒ‰ì?¸ ë°”ìš´ë“œ ê²€ì‚¬
displayname.make.array.to.string=ë°°ì—´ì?„ ë¬¸ìž?ì—´ë¡œ ë§Œë“¤ê¸°
displayname.get.and.getorelse.to.getorelse=get ë°? getOrElseë¥¼ getOrElseë¡œ
displayname.extracting.keys.manually=ìˆ˜ë?™ìœ¼ë¡œ í‚¤ ì¶”ì¶œ ì¤‘
displayname.extracting.values.manually=ìˆ˜ë?™ìœ¼ë¡œ ê°’ ì¶”ì¶œ ì¤‘
displayname.redundant.get.when.getting.a.value.from.map=Mapì—?ì„œ ê°’ì?„ ê°€ì ¸ì˜¬ ê²½ìš° ë¶ˆí•„ìš”í•œ get
displayname.lift.to.get=Liftë¥¼ Getìœ¼ë¡œ
displayname.emptiness.check.on.get.to.contains=Get ê³µë°± ê²€ì‚¬ë¥¼ Containsë¡œ
displayname.redundant.headoption.or.lastoption=ë¶ˆí•„ìš”í•œ headOption ë˜?ëŠ” lastOption
displayname.equals.some.x.to.contains.x=ë“±í˜¸ Some(x)ì?„ contains(x)ë¡œ
displayname.map.and.getorelse.to.fold=map ë°? getOrElseë¥¼ foldë¡œ
displayname.map.and.getorelse.false.to.exists=Map ë°? getOrElse(false)ë¥¼ existsë¡œ
displayname.getorelse.null.to.ornull=GetOrElse(null)ë¥¼ orNullë¡œ
displayname.emulated.option.x=ëª¨ë°©ë?œ Option(x)
displayname.change.to.filter=filterë¡œ ë³€ê²½
displayname.some.to.option=Someì?„ Optionìœ¼ë¡œ
displayname.filter.after.sort=ì •ë ¬ í›„ í•„í„°ë§?
displayname.redundant.collection.conversion=ë¶ˆí•„ìš”í•œ ì»¬ë ‰ì…˜ ë³€í™˜
displayname.side.effects.in.a.monadic.transformation=ëª¨ë‚˜ë”• ë³€í™˜ ì‹œ ë¶€ìž‘ìš©
displayname.unit.return.type.in.the.argument.of.map=map ì?¸ìˆ˜ ë‚´ Unit ë°˜í™˜ ìœ í˜•
displayname.multiple.arg.lists.in.annotation.constructor=ì–´ë…¸í…Œì?´ì…˜ ìƒ?ì„±ìž? ë‚´ ë³µìˆ˜ ì?¸ìˆ˜ ëª©ë¡?
displayname.unzip.for.extracting.a.single.element=ë‹¨ì?¼ ìš”ì†Œ ì¶”ì¶œì?„ ìœ„í•œ ì••ì¶• í•´ì œ
displayname.tag.unclosed=íƒœê·¸ê°€ ë‹«ížˆì§€ ì•Šì?Œ
displayname.inlined.tag=ì?¸ë?¼ì?¸í™”ë?œ íƒœê·¸
displayname.header.tags.unbalanced=ì§?ì?´ ë§žì?´ ì•ŠëŠ” í—¤ë?” íƒœê·¸
displayname.unknown.tag=ì•Œ ìˆ˜ ì—†ëŠ” íƒœê·¸
displayname.unknown.parameter=ì•Œ ìˆ˜ ì—†ëŠ” ë§¤ê°œë³€ìˆ˜
displayname.missing.tag.parameter.description=íƒœê·¸ ë§¤ê°œë³€ìˆ˜ ì„¤ëª… ëˆ„ë?½
displayname.wrong.scaladoc.element=ìž˜ëª»ë?œ scaladoc ìš”ì†Œ
displayname.specs2.matchers=Specs2 ë§¤ì²˜
displayname.source3.scala2.syntax=-X source:3ì?„ ì‚¬ìš©í•œ Scala 2 êµ¬ë¬¸
displayname.dataflow.analysis.constant.conditions=ìƒ?ìˆ˜ ì¡°ê±´
final.modifier.is.redundant.for.toplevel.objects=''final'' ì œì–´ìž?ëŠ” ìµœìƒ?ìœ„ ê°?ì²´ì™€ ì¤‘ë³µë?©ë‹ˆë‹¤
mark.inner.case.objects.as.final=ë‚´ë¶€ case ê°?ì²´ë¥¼ finalë¡œ í‘œì‹œí•˜ì—¬ ì»´íŒŒì?¼ë?œ í?´ëž˜ìŠ¤ë?„ finalë¡œ ë§Œë“­ë‹ˆë‹¤
group.general=ì?¼ë°˜
group.internal=Internal
group.syntactic.simplification=êµ¬ë¬¸ ë‹¨ìˆœí™”
group.syntactic.clarification=êµ¬ë¬¸ ëª…í™•í™”
group.method.signature=ë©”ì„œë“œ ì‹œê·¸ë‹ˆì²˜
group.code.style=ì½”ë“œ ìŠ¤íƒ€ì?¼
group.dataflow.analysis=ë?°ì?´í„° í??ë¦„ ë¶„ì„?
group.size=í?¬ê¸°
group.comparing=ë¹„êµ?
group.indices=ìƒ‰ì?¸
group.simplifications.filter.and.exists=ë‹¨ìˆœí™”\: filter ë°? exists
group.simplifications.find.and.map.to.apply=ë‹¨ìˆœí™”\: find ë°? ì ?ìš©í•  map
group.simplifications.forall.and.exists=ë‹¨ìˆœí™”\: forall ë°? exists
group.simplifications.other=ë‹¨ìˆœí™”\: ê¸°íƒ€
group.maps=ë§µ
group.options=ì˜µì…˜
group.other=Otros
group.collections=ì»¬ë ‰ì…˜
group.scaladoc=Scaladoc
group.resource.leaks=ë¦¬ì†ŒìŠ¤ ëˆ„ìˆ˜
group.specs2=Specs2
displayname.deprecated.package.object=ë?” ì?´ìƒ? ì‚¬ìš©ë?˜ì§€ ì•ŠëŠ” íŒ¨í‚¤ì§€ ê°?ì²´
introduce.implicit.incorrect.order=ìž˜ëª»ë?œ ë§¤ê°œë³€ìˆ˜ ìˆœì„œ ë•Œë¬¸ì—? ë¬µì‹œì ? ë§¤ê°œë³€ìˆ˜ ì‚½ìž…ì?´ í—ˆìš©ë?˜ì§€ ì•ŠìŠµë‹ˆë‹¤
introduce.implicit.incorrect.count=ìž˜ëª»ë?œ ë§¤ê°œë³€ìˆ˜ ì‚¬ìš© ìœ„ì¹˜ ê°œìˆ˜ ë•Œë¬¸ì—? ë¬µì‹œì ? ë§¤ê°œë³€ìˆ˜ ì‚½ìž…ì?´ í—ˆìš©ë?˜ì§€ ì•ŠìŠµë‹ˆë‹¤
introduce.implicit.not.allowed.here=ì?´ í‘œí˜„ì‹?ì—?ëŠ” ë¬µì‹œì ? ë§¤ê°œë³€ìˆ˜ ì‚½ìž…ì?´ í—ˆìš©ë?˜ì§€ ì•ŠìŠµë‹ˆë‹¤
replace.with.some=Someìœ¼ë¡œ ë°”ê¾¸ê¸°
replace.option.with.some=Optionì?„ Someìœ¼ë¡œ ë°”ê¾¸ê¸°
convert.expression.to.sam=í‘œí˜„ì‹?ì?„ ë‹¨ì?¼ ì¶”ìƒ? ë©”ì„œë“œë¡œ ë³€í™˜
fileName.rename.text={0} {1} ì?„(ë¥¼) {2} (ìœ¼)ë¡œ
fileName.rename.class=ìœ í˜• ì •ì?˜ ì?´ë¦„ ë³€ê²½
fileName.rename.file=íŒŒì?¼ ì?´ë¦„ ë³€ê²½
implementation.limitation.multiple.argument.lists=êµ¬í˜„ ì œí•œ\: ì–´ë…¸í…Œì?´ì…˜ì?˜ ë‹¤ì¤‘ ì?¸ìˆ˜ ëª©ë¡?ì?´ í˜„ìž¬ ì§€ì›?ë?˜ì§€ ì•ŠìŠµë‹ˆë‹¤
display.name.double.negation=ì?´ì¤‘ ë¶€ì •
remove.double.negation=ì?´ì¤‘ ë¶€ì •ì?„ ì œê±°í•©ë‹ˆë‹¤.
simplify.boolean.expression=ë¶€ìš¸ í‘œí˜„ì‹? ë‹¨ìˆœí™”
simplify.with.text={0} ë‹¨ìˆœí™”
simplify.match.to.if.statement=matchë¥¼ if ë¬¸ìœ¼ë¡œ ë‹¨ìˆœí™”
display.name.case.class.parameter=ì¼€ì?´ìŠ¤ í?´ëž˜ìŠ¤ ë§¤ê°œë³€ìˆ˜
remove.unnecessary.val=ë¶ˆí•„ìš”í•œ ''val'' ì œê±°
remove.val.from.definition=ì •ì?˜ì—?ì„œ ''val'' ì œê±°
display.name.redundant.cast=ë¶ˆí•„ìš”í•œ ì¼€ìŠ¤íŠ¸
remove.redundant.cast=ë¶ˆí•„ìš”í•œ ì¼€ìŠ¤íŠ¸ ì œê±°
casting.left.to.right.is.redundant=''{0}''ì—?ì„œ ''{1}''(ìœ¼)ë¡œì?˜ í˜• ë³€í™˜ì?€ ì¤‘ë³µë?©ë‹ˆë‹¤
display.name.redundant.conversion=ë¶ˆí•„ìš”í•œ ë³€í™”
remove.redundant.conversion=ë¶ˆí•„ìš”í•œ ë³€í™˜ ì œê±°
casting.a.to.b.is.redundant=''{0}''ì—?ì„œ ''{1}''(ìœ¼)ë¡œì?˜ í˜• ë³€í™˜ì?€ ì¤‘ë³µë?©ë‹ˆë‹¤
catch.all=ì˜ˆì™¸ ìœ í˜• ì§€ì •
replace.collect.headOption.with.collectFirst=.collect ë°? .headOptionì?„ .collectFirst ë°”ê¾¸ê¸°
hint.comparing.different.collection.kinds=ë‹¤ë¥¸ ì»¬ë ‰ì…˜ ì¢…ë¥˜ ë¹„êµ? ì¤‘
hint.convert.left.hand.side.to.collection=ì™¼ìª½ì?„ {0} (ìœ¼)ë¡œ ë³€í™˜
hint.convert.right.hand.side.to.collection=ì˜¤ë¥¸ìª½ì?„ {0} (ìœ¼)ë¡œ ë³€í™˜
replace.with.lengthCompare=.lengthCompareë¡œ ë°”ê¾¸ê¸°
replace.with.sizeIs=.sizeIsë¡œ ë°”ê¾¸ê¸°
sameElements.unsorted=ì •ë ¬ë?˜ì§€ ì•Šì?€ ì»¬ë ‰ì…˜ì?˜ `sameElements`, ê²°ê³¼ë¥¼ ì˜ˆì¸¡í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤
corresponds.unsorted=ì •ë ¬ë?˜ì§€ ì•Šì?€ ì»¬ë ‰ì…˜ê³¼ì?˜ ''corresponds'', ê²°ê³¼ë¥¼ ì˜ˆì¸¡í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤
replace.drop.take.with.slice=.drop ë°? .takeë¥¼ .sliceë¡œ ë°”ê¾¸ê¸°
replace.take.drop.with.slice=.take ë°? .dropì?„ .sliceë¡œ ë°”ê¾¸ê¸°
replace.with.isEmpty=.isEmptyë¡œ ë°”ê¾¸ê¸°
replace.with.isDefined=.isDefinedë¡œ ë°”ê¾¸ê¸°
replace.with.nonEmpty=.nonEmptyë¡œ ë°”ê¾¸ê¸°
replace.with.flatten=.flattenë¡œ ë°”ê¾¸ê¸°
replace.equals.with.sameElements=ë“±í˜¸ë¥¼ sameElementsë¡œ ë°”ê¾¸ê¸°
config.description.for.arrays=ë°°ì—´
config.description.for.iterators=ë°˜ë³µìž?
exists.equals.hint=existsë¥¼ containsë¡œ ë°”ê¾¸ê¸°
forall.notEquals.hint=forallë¥¼ not containsë¡œ ë°”ê¾¸ê¸°
replace.with.forall=.forallë¡œ ë°”ê¾¸ê¸°
replace.with.exists=.existsë¡œ ë°”ê¾¸ê¸°
filter.nonempty.check.hint=ffilter ë°?  ë¹„ê³µë°± ê²€ì‚¬ë¥¼ existsë¡œ ë°”ê¾¸ê¸°
filter.empty.check.hint=filter ë°? ê³µë°± ê²€ì‚¬ë¥¼ \!(...).existsë¡œ ë°”ê¾¸ê¸°
filterNot.empty.check.hint=filterNot ë°? ê³µë°± ê²€ì‚¬ë¥¼ forallë¡œ ë°”ê¾¸ê¸°
filterNot.nonempty.check.hint=filterNot ë°? ë¹„ê³µë°± ê²€ì‚¬ë¥¼ \!(...).forallë¡œ ë°”ê¾¸ê¸°
filter.headOption.hint=filter ë°? headOptionì?„ findë¡œ ë°”ê¾¸ê¸°
replace.filter.with.intersect=filter ë°? containsì?„ intersectë¡œ ë°”ê¾¸ê¸°
replace.filter.with.diff=filter ë°? not containsì?„ diffë¡œ ë°”ê¾¸ê¸°
remove.redundant.contains=ë¶ˆí•„ìš”í•œ .contains ì œê±°
filter.size.hint=filter ë°? sizeë¥¼ countë¡œ ë°”ê¾¸ê¸°
replace.find.and.map.with.apply=find ë°? mapì?„ applyë¡œ ë°”ê¾¸ê¸°
find.isDefined.hint=find ë°? ë¹„ê³µë°± ê²€ì‚¬ë¥¼ existsë¡œ ë°”ê¾¸ê¸°
find.isEmpty.hint=find ë°? ê³µë°± ê²€ì‚¬ë¥¼ \!(...).existsë¡œ ë°”ê¾¸ê¸°
fold.true.and.hint=foldë¥¼ forallë¡œ ë°”ê¾¸ê¸°
get.getOrElse.hint=getOrElse(key, defaultValue)ë¡œ ë°”ê¾¸ê¸°
getOrElse.null.hint=getOrElse(null)ë¥¼ orNullë¡œ ë°”ê¾¸ê¸°
replace.with.headOption=.headOptionìœ¼ë¡œ ë°”ê¾¸ê¸°
replace.with.lastOption=.lastOptionìœ¼ë¡œ ë°”ê¾¸ê¸°
ifstmt.to.headOption=If-elseë¥¼ headOptionìœ¼ë¡œ
ifstmt.to.lastOption=If-elseë¥¼ lastOptionìœ¼ë¡œ
lift.to.headOption=.liftë¥¼ headOptionìœ¼ë¡œ
lift.to.lastOption=.liftë¥¼ lastOptionìœ¼ë¡œ
ifstmt.to.filteredOption=ifë¥¼ í•„í„° ì˜µì…˜ë¡œ ë°”ê¾¸ê¸°
hint.replace.with.option.expr=Option(x)ë¡œ ë°”ê¾¸ê¸°
hint.replace.with.option.expr.with.preview=Option({0})ìœ¼ë¡œ ë°”ê¾¸ê¸°
ifstmt.to.lift=If-elseë¥¼ liftë¡œ
replace.with.last=.lastë¡œ ë°”ê¾¸ê¸°
format.with.mkstring=.mkString("Array(", ", ", ")")ìœ¼ë¡œ ì„œì‹? ì§€ì •
replace.map.flatten.with.flatMap=.map ë°? .flattenì?„ .flatMapìœ¼ë¡œ ë°”ê¾¸ê¸°
replace.get.nonEmpty.with.contains=.contains(key)ë¡œ ë°”ê¾¸ê¸°
replace.get.isEmpty.with.not.contains=\!.contains(key)ë¡œ ë°”ê¾¸ê¸°
get.get.hint=.(key)ë¡œ ë°”ê¾¸ê¸°
map.getOrElse.false.hint=map ë°? getOrElse(false)ë¥¼ existsë¡œ ë°”ê¾¸ê¸°
map.getOrElse.true.hint=map ë°? getOrElse(true)ë¥¼ forallë¡œ ë°”ê¾¸ê¸°
map.getOrElse.hint=map ë°? getOrElseë¥¼ foldë¡œ ë°”ê¾¸ê¸°
replace.with.keys=.keysë¡œ ë°”ê¾¸ê¸°
replace.with.keySet=.keySetìœ¼ë¡œ ë°”ê¾¸ê¸°
replace.with.keysIterator=.keysIteratorë¡œ ë°”ê¾¸ê¸°
replace.with.get=.getìœ¼ë¡œ ë°”ê¾¸ê¸°
replace.map.contains.true.with.exists=.map(...).contains(true)ë¥¼ .exists(...)ë¡œ ë°”ê¾¸ê¸°
replace.map.contains.false.with.not.forall=.map(...).contains(false)ë¥¼ \! .forall(...)ë¡œ ë°”ê¾¸ê¸°
replace.with.values=.valuesë¡œ ë°”ê¾¸ê¸°
replace.with.valuesIterator=.valuesIteratorë¡œ ë°”ê¾¸ê¸°
operation.on.collection.id=OperationsOnCollection
operation.on.collection.name=ì½œë ‰ì…˜ì?˜ ë‹¨ìˆœí™” ê°€ëŠ¥í•œ ì—°ì‚°
operation.on.collection.like.option.input.message=ê²€ì‚¬ì—?ì„œ ì?´ëŸ¬í•œ í?´ëž˜ìŠ¤ëŠ” scala.Optionê³¼ ê°™ì?´ ì²˜ë¦¬ë?©ë‹ˆë‹¤
operation.on.collection.like.option.input.title=like-option í?´ëž˜ìŠ¤ ì¶”ê°€
operation.on.collection.like.option.panel.title=Like-option í?´ëž˜ìŠ¤
operation.on.collection.like.collection.input.message=ê²€ì‚¬ì—?ì„œ ì?´ëŸ¬í•œ í?´ëž˜ìŠ¤ëŠ” ì»¬ë ‰ì…˜ê³¼ ê°™ì?´ ì²˜ë¦¬ë?©ë‹ˆë‹¤
operation.on.collection.like.collection.input.title=like-collection í?´ëž˜ìŠ¤ ì¶”ê°€
operation.on.collection.like.collection.panel.title=like-collection í?´ëž˜ìŠ¤
replace.with.contains=.containsë¡œ ë°”ê¾¸ê¸°
replace.with.not.contains=\!.containsë¡œ ë°”ê¾¸ê¸°
hint.replace.with.indices=.indicesë¡œ ë°”ê¾¸ê¸°
hint.replace.with.indices.with.preview={0}.indicesë¡œ ë°”ê¾¸ê¸°
redundant.collection.conversion=ë¶ˆí•„ìš”í•œ ì»¬ë ‰ì…˜ ë³€í™˜ ì œê±°
remove.redundant.headOption=ë¶ˆí•„ìš”í•œ .headOption ì œê±°
remove.redundant.lastOption=ë¶ˆí•„ìš”í•œ . lastOption ì œê±°
replace.to.with.until=`to`ë¥¼ `until`ë¡œ ë°”ê¾¸ê¸°
replace.with.findlast='findLast'ë¡œ ë°”ê¾¸ê¸°
replace.reverse.iterator=.reverse.iteratorë¥¼ .reverseIteratorë¡œ ë°”ê¾¸ê¸°
replace.reverse.take.reverse.with.takeRight=.reverse.take(...).reverseë¥¼ .takeRight(...)ë¡œ ë°”ê¾¸ê¸°
replace.sameElements.with.equals=sameElementsë¥¼ equalsë¡œ ë°”ê¾¸ê¸°
replace.corresponds.with.equals=correspondsë¥¼ ë“±í˜¸ë¡œ ë°”ê¾¸ê¸°
side.effects.in.monadic=ëª¨ë‚˜ë”• ë³€í™˜ ì‹œ ë¶€ìž‘ìš©
fold.sum.hint=foldë¥¼ sumìœ¼ë¡œ ë°”ê¾¸ê¸°
fold.product.hint=foldë¥¼ productë¡œ ë°”ê¾¸ê¸°
fold.sum.short=foldë¥¼ sumìœ¼ë¡œ
fold.product.short=foldë¥¼ productë¡œ
reduce.sum.hint=reduceë¥¼ sumìœ¼ë¡œ ë°”ê¾¸ê¸°
reduce.product.hint=reduceë¥¼ productë¡œ ë°”ê¾¸ê¸°
reduce.min.hint=reduceë¥¼ minìœ¼ë¡œ ë°”ê¾¸ê¸°
reduce.max.hint=reduceë¥¼ maxë¡œ ë°”ê¾¸ê¸°
reduce.sum.short=reduceë¥¼ sumìœ¼ë¡œ
reduce.product.short=reduceë¥¼ productë¡œ
reduce.min.short=reduceë¥¼ minìœ¼ë¡œ
reduce.max.short=reduceë¥¼ maxë¡œ
size.to.length=ë°°ì—´ ë°? ë¬¸ìž?ì—´ì?˜ .sizeë¥¼ .lengthë¡œ ë°”ê¾¸ê¸°
replace.with.option=Optionìœ¼ë¡œ ë°”ê¾¸ê¸°
sort.filter.hint=sort ë°? filterì?˜ ìˆœì„œ ë³€ê²½
replace.sorted.head.with.min=.minìœ¼ë¡œ ë°”ê¾¸ê¸°
replace.sorted.last.with.max=.maxë¡œ ë°”ê¾¸ê¸°
replace.sortBy.head.with.minBy=.minByë¡œ ë°”ê¾¸ê¸°
replace.sortBy.last.with.maxBy=.maxByë¡œ ë°”ê¾¸ê¸°
replace.toSet.and.back.with.distinct=Setìœ¼ë¡œ ë³€í™˜ ë°? ë³µì›?ì?„ .distinctë¡œ ë°”ê¾¸ê¸°
expression.unit.return.in.map=map ì?¸ìˆ˜ ë‚´ Unit ë°˜í™˜ ìœ í˜•ì?„ ê°€ì§„ í‘œí˜„ì‹?
use.foreach.instead.of.map=map ëŒ€ì‹  foreach ì‚¬ìš©
replace.with.map=.mapìœ¼ë¡œ ë°”ê¾¸ê¸°
replace.with.head=.headë¡œ ë°”ê¾¸ê¸°
replace.with.zipWithIndex=zipWithIndexë¡œ ë°”ê¾¸ê¸°
remove.unreachable.code=ë?„ë‹¬í•  ìˆ˜ ì—†ëŠ” ì½”ë“œ ì œê±°
unwrap.do.statement=do-êµ¬ë¬¸ ì¤„ ë°”ê¿ˆ í•´ì œ
unused.expression.throws=ì‚¬ìš©ë?˜ì§€ ì•Šì?€ í‘œí˜„ì‹?, ë°œìƒ? ê°€ëŠ¥í•œ ìœ ì?¼í•œ ë¶€ìž‘ìš©ì?€ ì˜ˆì™¸ìž…ë‹ˆë‹¤
unused.expression.no.side.effects=ì‚¬ìš©ë?˜ì§€ ì•Šì?€ ë¶€ìž‘ìš© ì—†ëŠ” í‘œí˜„ì‹?
add.return.keyword=ë°˜í™˜ í‚¤ì›Œë“œ ì¶”ê°€
remove.expression=í‘œí˜„ì‹? ì œê±°
display.name.field.from.delayedinit=DelayedInitì?˜ í•„ë“œ
field.defined.in.delayedinit.is.likely.to.be.null=DelayedInitì—? ì •ì?˜ë?œ í•„ë“œê°€ nullì?¼ ìˆ˜ ìžˆìŠµë‹ˆë‹¤
package.objects.are.deprecated=íŒ¨í‚¤ì§€ ê°?ì²´ëŠ” Scala 3ì—?ì„œ ë?” ì?´ìƒ? ì‚¬ìš©ë?˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ëŒ€ì‹  ìµœìƒ?ìœ„ ìˆ˜ì¤€ì?˜ ì •ì?˜ë¥¼ ì‚¬ìš©í•´ë³´ì„¸ìš”
unwrap.package.object.fix=ë©¤ë²„ë¥¼ ìµœìƒ?ìœ„ ìˆ˜ì¤€ìœ¼ë¡œ ì?´ë?™
usage.of.deprecatedname.as.identifier.is.deprecated={0} ì?€(ëŠ”) ì‹?ë³„ìž˜ë¡œ ë?” ì?´ìƒ? ì‚¬ìš©ë?˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Scala í–¥í›„ ë²„ì „ì—?ì„œ í‚¤ì›Œë“œë¡œ ì‚¬ìš©ë?  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
parameter.name.is.deprecated=ë§¤ê°œë³€ìˆ˜ ì?´ë¦„\: {0} ì?€(ëŠ”) ë?” ì?´ìƒ? ì‚¬ìš©ë?˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
symbol.name.is.deprecated.with.message=ì‹¬ë³¼ {0} ì?€(ëŠ”) ë?” ì?´ìƒ? ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. {1}
super.method.name.is.deprecated.with.message=ìƒ?ìœ„ ë©”ì„œë“œ {0} ì?€(ëŠ”) ë?” ì?´ìƒ? ì‚¬ìš©ë?˜ì§€ ì•ŠìŠµë‹ˆë‹¤. {1}
overriding.is.deprecated={0} ìž¬ì •ì?˜ëŠ” ì§€ì›? ì¤‘ë‹¨ë?©ë‹ˆë‹¤. {1}
inheriting.form.name.is.deprecated.message={0} ìƒ?ì†?ì?€ ì§€ì›? ì¤‘ë‹¨ë?©ë‹ˆë‹¤. {1}
advanced.language.feature=ê³ ê¸‰ ì–¸ì–´ ê¸°ëŠ¥\: {0}
display.name.advanced.language.features=ê³ ê¸‰ ì–¸ì–´ ê¸°ëŠ¥
import.feature.flag.for.language.feature=\ %s ì?˜ ê¸°ëŠ¥ í”Œëž˜ê·¸ ê°€ì ¸ì˜¤ê¸°
enable.language.feature.plural={0} í™œì„±í™”
language.feature.postfix.operator.notation=ì ‘ë¯¸ì‚¬ ì—°ì‚°ìž? í‘œê¸°ë²•
language.feature.reflective.call=ë¦¬í”Œë ‰í‹°ë¸Œ í˜¸ì¶œ
language.feature.dynamic.member.selection=ë?™ì ? ë©¤ë²„ ì„ íƒ?
language.feature.implicit.conversion=ë¬µì‹œì ? ë³€í™˜
language.feature.higher.kinded.type=ìƒ?ìœ„ ìœ í˜•
language.feature.existential.type=ì¡´ìž¬ ìœ í˜•
language.feature.macro.definition=ë§¤í?¬ë¡œ ì •ì?˜
legacy.string.formatting.use.interpolated.string=ê¸°ì¡´ ë¬¸ìž?ì—´ ì„œì‹? ì§€ì • ì‹œ ë³´ê°„ë?œ ë¬¸ìž?ì—´ë¡œ ëŒ€ì²´ë?  ìˆ˜ ìžˆìŠµë‹ˆë‹¤
convert.to.interpolated.string=ë³´ê°„ë?œ ë¬¸ìž?ì—´ë¡œ ë³€í™˜
format.specifier.cannot.be.used.for.an.argument=ì„œì‹? ì§€ì •ìž? {0} ì—? ì?¸ìˆ˜ {1}({2}) ì?„(ë¥¼) ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤
argument.cannot.be.used.for.a.format.specifier=í˜•ì‹? ì§€ì •ìž? {2} ì—? ì?¸ìˆ˜ {0}({1}) ì?„(ë¥¼) ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤
malformed.format.specifier=í˜•ì‹?ì?´ ìž˜ëª»ë?œ ì„œì‹? ì§€ì •ìž?
no.argument.for.a.format.specifier=ì„œì‹? ì§€ì •ìž? {0} ì—? ì?¸ìˆ˜ ì—†ì?Œ
no.argument.at.position=ìœ„ì¹˜ {0} ì—? ì?¸ìˆ˜ ì—†ì?Œ
no.format.specifer.for.an.argument=ì?¸ìˆ˜ {0} ì—? ì„œì‹? ì§€ì •ìž? ì—†ì?Œ
convert.match.statement.to.pattern.matching.function=match êµ¬ë¬¸ì?„ íŒ¨í„´ ë§¤ì¹­ ì?µëª… í•¨ìˆ˜ë¡œ ë³€í™˜
unnecessary.partial.function=ë¶ˆí•„ìš”í•œ ë¶€ë¶„ í•¨ìˆ˜
convert.to.anonymous.function=ì?µëª… í•¨ìˆ˜ë¡œ ë³€í™˜
non.value.field.is.accessed.in.hashcode=ê°’ì?´ ì•„ë‹Œ í•„ë“œê°€ ''hashCode()''ì—?ì„œ ì•¡ì„¸ìŠ¤ë?˜ì—ˆìŠµë‹ˆë‹¤
view.bounds.are.deprecated=ë·° ë°”ìš´ë“œê°€ ë?” ì?´ìƒ? ì‚¬ìš©ë?˜ì§€ ì•ŠìŠµë‹ˆë‹¤
replace.with.implicit.parameters=ë¬µì‹œì ? ë§¤ê°œë³€ìˆ˜ë¡œ ë°”ê¾¸ê¸°
single.import=í•˜ë‚˜ì?˜ ê°€ì ¸ì˜¤ê¸°ë§Œ í?¬í•¨í•˜ëŠ” import ë¬¸ì—?ì„œ ì¤‘ê´„í˜¸ ì œê±°
display.name.loop.variable.not.updated.inside.loop=ë£¨í”„ ë³€ìˆ˜ê°€ ë£¨í”„ ë‚´ì—?ì„œ ì—…ë?°ì?´íŠ¸ë?˜ì§€ ì•Šì?Œ
error.detected=ì˜¤ë¥˜ íƒ?ì§€ë?¨
super.method.name.is.marked.as.status=ìƒ?ìœ„ ë©”ì„œë“œ {0}ì?´(ê°€) {1}(ìœ¼)ë¡œ í‘œì‹œë?˜ì–´ ìžˆìŠµë‹ˆë‹¤
symbol.name.is.marked.as.status=ì‹¬ë³¼ {0}ì?´(ê°€) {1}(ìœ¼)ë¡œ í‘œì‹œë?˜ì–´ ìžˆìŠµë‹ˆë‹¤
replace.with.is=.isë¡œ ë°”ê¾¸ê¸°
internal.replace.with.textContains=.textContainsë¡œ ë°”ê¾¸ê¸°
internal.replace.with.textMatches=.textMatchesë¡œ ë°”ê¾¸ê¸°
display.name.floating.point.literal.ending.with.dot=''.''ë¡œ ë??ë‚˜ëŠ” ë¶€ë?™ ì†Œìˆ˜ì ? ë¦¬í„°ëŸ´
convert.to.floating.point={0}(ìœ¼)ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
insert.missing.assignment=ëˆ„ë?½ë?œ ëŒ€ìž… ì‚½ìž…
remove.call.parentheses=í˜¸ì¶œ ì†Œê´„í˜¸ ì œê±°
add.override.modifier.quickfix=ìž¬ì •ì?˜ ì œì–´ìž? ì¶”ê°€
add.call.parentheses=í˜¸ì¶œ ì†Œê´„í˜¸ ì¶”ê°€
convert.to.function.syntax=í•¨ìˆ˜ êµ¬ë¬¸ ë³€í™˜
empty.parentheses=ë¹ˆ ì†Œê´„í˜¸ ì¶”ê°€
redundant.parentheses=ì¤‘ë³µ ë?œ ì†Œê´„í˜¸ ì œê±°
add.modifier=''{0}'' ì œì–´ìž? ì¶”ê°€
remove.modifier=''{0}'' ì œì–´ìž? ì œê±°
nested.stateful.monads=ì¤‘ì²© ìƒ?íƒœ ëª¨ë‚˜ë“œ
not.implemented=êµ¬í˜„ë?˜ì§€ ì•Šì?Œ
implement.quickfix.name=êµ¬í˜„
package.declaration.could.use.chained.package.clauses=ê¸°ë³¸ íŒ¨í‚¤ì§€ ''{0}''ì?€(ëŠ”) ë³„ë?„ì?˜ íŒ¨í‚¤ì§€ ì ˆì?´ì–´ì•¼ í•©ë‹ˆë‹¤
use.chained.package.clauses.like=íŒ¨í‚¤ì§€ ì ˆ ì¶”ì¶œ
use.chained.package.clauses=ë³„ë?„ì?˜ ê¸°ë³¸ íŒ¨í‚¤ì§€ ì ˆ ì‚¬ìš©
fimaly.name.move.file.to.package=íŒ¨í‚¤ì§€ë¡œ ì?´ë?™
move.file.to.default.package=ë””í?´íŠ¸ íŒ¨í‚¤ì§€ë¡œ ì?´ë?™
move.file.to.package.with.packagename=íŒ¨í‚¤ì§€ {0}(ìœ¼)ë¡œ ì?´ë?™
move.file.to.package.package.prefix.error=ì†ŒìŠ¤ í?´ë?” ''{1}''ì—?ì„œ íŒ¨í‚¤ì§€ ì ‘ë‘?ì‚¬ê°€ ''{2}''ì?¸ íŒ¨í‚¤ì§€ ''{0}''ì?„(ë¥¼) ìƒ?ì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤
package.names.does.not.correspond.to.directory.structure=íŒ¨í‚¤ì§€ ì?´ë¦„ ''{0}'' ì?´(ê°€) íŒŒì?¼ ê²½ë¡œ ''{1}''ì—? í•´ë‹¹ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤
package.names.does.not.correspond.to.directory.structure.package.prefix=ì†ŒìŠ¤ í?´ë?” ''{0}''ì—?ëŠ” íŒ¨í‚¤ì§€ ì ‘ë‘?ì‚¬ ''{1}''ì?´(ê°€) ìžˆìŠµë‹ˆë‹¤
rename.package.quickfix.command.name=íŒ¨í‚¤ì§€ ì?´ë¦„ ë³€ê²½
family.name.rename.package=íŒ¨í‚¤ì§€ ì?´ë¦„ ë³€ê²½
remove.package.statement=íŒ¨í‚¤ì§€ êµ¬ë¬¸ ì œê±°
rename.package.to=íŒ¨í‚¤ì§€ ì?´ë¦„ì?„ ''{0}''(ìœ¼)ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.
name.boolean.ignore.single.parameter.methods=ë§¤ê°œë³€ìˆ˜ê°€ í•˜ë‚˜ì?¸ ë©”ì„œë“œ ë¬´ì‹œ
name.boolean.params=ë¶€ìš¸ ë§¤ê°œë³€ìˆ˜ ì?´ë¦„ ì§€ì •
argument.duplicates.corresponding.parameter.default.value=ì?¸ìˆ˜ê°€ í•´ë‹¹ ë§¤ê°œë³€ìˆ˜ ë””í?´íŠ¸ ê°’ì?„ ë³µì œí•©ë‹ˆë‹¤
delete.redundant.default.argument=ë¶ˆí•„ìš”í•œ ë””í?´íŠ¸ ì?¸ìˆ˜ ì‚­ì œ
surround.with.parenthesis=ì†Œê´„í˜¸ë¡œ ë‘˜ëŸ¬ì‹¸ê¸°
clarifying.parentheses=ëª…í™•ížˆ êµ¬ë¶„ ì§“ëŠ” ì†Œê´„í˜¸
around.function.type=í•¨ìˆ˜ ìœ í˜• ì£¼ìœ„
around.function.type.parameter=í•¨ìˆ˜ ìœ í˜•ì?˜ ë§¤ê°œë³€ìˆ˜ ì£¼ìœ„
around.function.expr.parameter=í•¨ìˆ˜ í‘œí˜„ì‹?ì?˜ ë§¤ê°œë³€ìˆ˜ ì£¼ìœ„
unnecessary.parentheses.ignore=ë¬´ì‹œ
remove.unnecessary.parentheses.with.text=ë¶ˆí•„ìš”í•œ ì†Œê´„í˜¸ {0} ì œê±°
unnecessary.parentheses=ë¶ˆí•„ìš”í•œ ì†Œê´„í˜¸
remove.unnecessary.parentheses=ë¶ˆí•„ìš”í•œ ì†Œê´„í˜¸ë¥¼ ì œê±°í•©ë‹ˆë‹¤.
use.of.postfix.method.call=ì ‘ë‘?ì‚¬ ë©”ì„œë“œ í˜¸ì¶œ ì‚¬ìš©
add.dot.to.method.call=ë©”ì„œë“œ í˜¸ì¶œì—? ë§ˆì¹¨í‘œ ì¶”ê°€
reference.must.be.prefixed=ì°¸ì¡°ì—? ì ‘ë‘?ì‚¬ê°€ í•„ìš”í•©ë‹ˆë‹¤
add.prefix.to.reference=ì°¸ì¡°ì—? ì ‘ë‘?ì‚¬ ì¶”ê°€
remove.redundant.braces=ë¶ˆí•„ìš”í•œ ì¤‘ê´„í˜¸ ì œê±°
unwrap.the.expression=í‘œí˜„ì‹? ì¤„ ë°”ê¿ˆ í•´ì œ
the.enclosing.block.is.redundant=í•´ë‹¹ ë¸”ë¡?ì?´ ë¶ˆí•„ìš”í•©ë‹ˆë‹¤
redundant.braces.in.case.clause=case ì ˆì?˜ ë¶ˆí•„ìš”í•œ ì¤‘ê´„í˜¸
absolute.import.detected=importë¬¸ì?€ ë² ì?´ìŠ¤ íŒ¨í‚¤ì§€ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤
display.name.absolute.import=ì ˆëŒ€ ê°€ì ¸ì˜¤ê¸°
relative.import.detected=ìƒ?ëŒ€ ê°€ì ¸ì˜¤ê¸° íƒ?ì§€ë?¨
display.name.relative.import=ìƒ?ëŒ€ ê°€ì ¸ì˜¤ê¸°
family.name.enable.full.qualified.imports=ì •ê·œí™”ë?œ import ë¬¸ í™œì„±í™”
source.not.closed=ì†ŒìŠ¤ê°€ ë‹«ížˆì§€ ì•ŠìŠµë‹ˆë‹¤
display.name.inlined.tag=ì?¸ë?¼ì?¸í™”ë?œ íƒœê·¸
display.name.missing.parameter.description=ë§¤ê°œë³€ìˆ˜ ì„¤ëª… ëˆ„ë?½
all.text.from.header.closing.tag.to.end.of.line.will.be.lost=í—¤ë?” ë‹«ê¸° íƒœê·¸ì—?ì„œë¶€í„° ì¤„ ë??ê¹Œì§€ì?˜ ëª¨ë“  í…?ìŠ¤íŠ¸ê°€ ì†?ì‹¤ë?©ë‹ˆë‹¤
display.name.unclosed.tag=ë‹«ížˆì§€ ì•Šì?€ íƒœê·¸
unknown.tag.parameter=ì•Œ ìˆ˜ ì—†ëŠ” íƒœê·¸ ë§¤ê°œë³€ìˆ˜
unknown.tag.type.parameter=ì•Œ ìˆ˜ ì—†ëŠ” íƒœê·¸ ìœ í˜• ë§¤ê°œë³€ìˆ˜
one.param.or.tparam.tag.for.one.param.or.type.param.allowed=í•˜ë‚˜ì?˜ param/type ë§¤ê°œë³€ìˆ˜ ë‹¹ í•˜ë‚˜ì?˜ param/tparam íƒœê·¸ê°€ í—ˆìš©ë?¨
scaladoc.cant.process.tparams.for.type.alias.now=Scaladocì?´ ì?´ì œ ìœ í˜• ë³„ì¹­ì?˜ tparamsë¥¼ ì²˜ë¦¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤
param.and.tparams.tags.arnt.allowed.there=@param ë°? @tparams íƒœê·¸ëŠ” í—ˆìš©ë?˜ì§€ ì•ŠìŠµë‹ˆë‹¤
missing.tag.parameter=íƒœê·¸ ë§¤ê°œë³€ìˆ˜ ëˆ„ë?½
unknown.scaladoc.tag=ì•Œ ìˆ˜ ì—†ëŠ” scaladoc íƒœê·¸
family.name.scala.scaladoc=Scala\: Scaladoc
display.name.suspicious.shadowing.by.a.type.parameter=ìœ í˜• ë§¤ê°œë³€ìˆ˜ì—? ì?˜í•œ ì?˜ì‹¬ìŠ¤ëŸ¬ìš´ ê°€ë¦¬ê¸°
suspicious.shadowing.by.a.variable.pattern=ë³€ìˆ˜ íŒ¨í„´ì—? ì?˜í•œ ì?˜ì‹¬ìŠ¤ëŸ¬ìš´ ê°€ë¦¬ê¸°
rename.variable.pattern=ë³€ìˆ˜ íŒ¨í„´ ì?´ë¦„ ë³€ê²½
convert.to.stable.identifier.pattern=ì‹?ë³„ìž? íŒ¨í„´ `{0}` (ìœ¼)ë¡œ ë³€í™˜
replace.with.questionmark=?ë¡œ ë°”ê¾¸ê¸°
add.case='case' ì¶”ê°€
replace.with.star=*ë¡œ ë°”ê¾¸ê¸°
replace.with.as='as'ë¡œ ë°”ê¾¸ê¸°
replace.with.name.followed.by.star=''{0}*''ë¡œ ë°”ê¾¸ê¸°
replace.with.and.char=\\&ë¡œ ë°”ê¾¸ê¸°
suggest.converting.wildcards=<html>ì™€ì?¼ë“œì¹´ë“œ ë³€í™˜ ì œì•ˆ(<code>Seq[_]</code> \\&rarr; <code>Seq[?]</code>)</html>
suggest.adding.case.in.for.comprehensions=<html><code>for</code> ì»´í”„ë¦¬í—¨ì…˜ì—? <code>case</code>ë¥¼ ì¶”ê°€í•  ê²ƒì?„ ì œì•ˆí•©ë‹ˆë‹¤</html>
suggest.using.star.instead.of.underscore=<html>import ë¬¸ ë‚´ <code>_</code> ëŒ€ì‹  <code>*</code>ë¥¼ ì‚¬ìš©í•  ê²ƒì?„ ì œì•ˆí•©ë‹ˆë‹¤</html>
suggest.using.as.instead.of.arrow=<html>import ë¬¸ ë‚´ <code>=\\&gt;</code> ëŒ€ì‹  <code>as</code>ë¥¼ ì‚¬ìš©í•  ê²ƒì?„ ì œì•ˆí•©ë‹ˆë‹¤</html>
suggest.converting.vararg.splices=<html>vararg ìŠ¤í”Œë?¼ì?´ìŠ¤ë¥¼ ë³€í™˜í•  ê²ƒì?„ ì œì•ˆí•©ë‹ˆë‹¤(<code>seq: _*</code> \\&rarr; <code>seq*</code>)</html>
suggest.converting.named.wildcard.patterns=<html>ëª…ëª…ë?œ ì™€ì?¼ë“œì¹´ë“œ íŒ¨í„´ì?„ ë³€í™˜í•  ê²ƒì?„ ì œì•ˆí•©ë‹ˆë‹¤(<code>seq@_*</code> \\&rarr; <code>seq*</code>)</html>
suggest.using.and.instead.of.with=<html>ë³µí•© íƒ€ìž… ë‚´ <code>with</code> ëŒ€ì‹  <code>\\&</code>ë¥¼ ì‚¬ìš©í•  ê²ƒì?„ ì œì•ˆí•©ë‹ˆë‹¤</html>
specs2.builtin.matcher.alternative.exists=ì‚¬ìš© ê°€ëŠ¥í•œ ë§¤ì²˜ê°€ ì¡´ìž¬í•©ë‹ˆë‹¤
specs2.use.builtin.matcher=ê¸°ë³¸ ì œê³µ ë§¤ì²˜ë¡œ ë°”ê¾¸ê¸°
suppress.inspection.function=í•¨ìˆ˜ ì–µì œ
suppress.inspection.typeAlias=ìœ í˜• ë³„ì¹­ ì–µì œ
suppress.inspection.variable=ë³€ìˆ˜ ì •ì?˜ ì–µì œ
scala.compiler.will.replace.this.argument.list.with.tuple=Scala ì»´íŒŒì?¼ëŸ¬ê°€ ì?´ ì?¸ìˆ˜ ëª©ë¡?ì?„ íŠœí”Œë¡œ ë°”ê¿‰ë‹ˆë‹¤
display.name.auto.tupling=ìž?ë?™ íŠœí”Œí™”
make.tuple.explicit=íŠœí”Œì?„ ëª…ì‹œì ?ìœ¼ë¡œ ë§Œë“¤ê¸°
use.option.type=Option ìœ í˜• ì‚¬ìš©
use.underscore.initializer=_ ì?´ë‹ˆì…œë?¼ì?´ì € ì‚¬ìš©
variable.with.null.initializer=null ì?´ë‹ˆì…œë?¼ì?´ì €ê°€ ìžˆëŠ” ë³€ìˆ˜
convertible.to.method.value.name=ë©”ì„œë“œ ê°’ìœ¼ë¡œ ë³€í™˜ ê°€ëŠ¥í•œ ì?µëª… í•¨ìˆ˜
convertible.to.method.value.anonymous.hint=ë©”ì„œë“œ ê°’ìœ¼ë¡œ ë³€í™˜
convertible.to.method.value.eta.hint=ë¶ˆí•„ìš”í•œ ìž?ë¦¬í‘œì‹œìž? ì œê±°
syntactic.sugar.could.be.used=ë¬¸ë²•ì ? ì„¤íƒ•ì?„ ì‚¬ìš©í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤
unary.operation.can.use.prefix.notation=Use prefix notation for unary operators
display.name.redundant.new.on.case.class=ì¼€ì?´ìŠ¤ í?´ëž˜ìŠ¤ì?˜ ë¶ˆí•„ìš”í•œ new
return.keyword.is.redundant=í‚¤ì›Œë“œ ë°˜í™˜ì?´ ë¶ˆí•„ìš”í•©ë‹ˆë‹¤
display.name.redundant.return=ë¶ˆí•„ìš”í•œ ë°˜í™˜
remove.unnecessary.semicolon=Eliminar puntos y comas innecesarios
unnecessary.semicolon=Punto y coma innecesario
add.type.annotation=ìœ í˜• ì–´ë…¸í…Œì?´ì…˜ ì¶”ê°€
learn.why=ì?´ìœ  ì•Œì•„ë³´ê¸°...
quickfix.modify.code.style=ì½”ë“œ ìŠ¤íƒ€ì?¼ ìˆ˜ì •...
quickfix.make.private=privateìœ¼ë¡œ ì„¤ì •
type.annotation.required.for={0} ì—? ìœ í˜• ì–´ë…¸í…Œì?´ì…˜ í•„ìš”
comparing.unrelated.types.name=ê´€ë ¨ ì—†ëŠ” ìœ í˜• ë¹„êµ? ì¤‘
comparing.unrelated.types.hint=ê´€ë ¨ ì—†ëŠ” ìœ í˜• ë¹„êµ? ì¤‘\: {0} ë°? {1}
pattern.may.never.match=íŒ¨í„´ì?´ í•œ ë²ˆë?„ ì?¼ì¹˜í•˜ì§€ ì•Šì?„ ìˆ˜ ìžˆìŠµë‹ˆë‹¤
type.check.can.be.replaced.by.pattern.matching=ìœ í˜• ê²€ì‚¬ë¥¼ íŒ¨í„´ ì?¼ì¹˜ë¡œ ë°”ê¿€ ìˆ˜ ìžˆìŠµë‹ˆë‹¤
remove.unused.element=ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ìš”ì†Œ ì œê±°
remove.whole.definition=ì „ì²´ ì •ì?˜ ì œê±°
remove.only.name.binding={0} ë°”ì?¸ë”©ë§Œ ì œê±°
mark.import.as.always.used.in.this.project=importë¥¼ ì?´ í”„ë¡œì ?íŠ¸ì—?ì„œ í•­ìƒ? ì‚¬ìš©ìœ¼ë¡œ í‘œì‹œ
unused.import.statement=DeclaraciÃ³n import obsoleta
display.name.unused.symbol=ì‚¬ìš©ë?˜ì§€ ì•Šì?€ ì‹¬ë³¼
declaration.is.never.used=ì„ ì–¸ì?´ í•œ ë²ˆë?„ ì‚¬ìš©ë?˜ì§€ ì•ŠìŠµë‹ˆë‹¤
display.name.abstract.value.in.trait=íŠ¹ì„± ë‚´ ì¶”ìƒ? ê°’
abstract.value.used.in.trait=íŠ¹ì„±ì—? ì‚¬ìš©ë?œ ì¶”ìƒ? ê°’
abstract.variable.used.in.trait=íŠ¹ì„±ì—? ì‚¬ìš©ë?œ ì¶”ìƒ? ë³€ìˆ˜
convert.val.to.var=''val''ì?„ ''var''ë¡œ ë³€í™˜
var.could.be.a.val=varì?´ valì?¼ ìˆ˜ ìžˆìŠµë‹ˆë‹¤
convert.var.to.val=''var''ì?„ ''val''ë¡œ ë³€í™˜
family.name.scala.general=Scala\: ì?¼ë°˜
applied.type.lambda.can.be.simplified=ì ?ìš©ë?œ ëžŒë‹¤ ìœ í˜•ì?„ ë‹¨ìˆœí™”í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤
simplify.type=ìœ í˜• ë‹¨ìˆœí™”
replace.with.star.syntax=`*`-êµ¬ë¬¸ìœ¼ë¡œ ë°”ê¾¸ê¸°
kind.projector.deprecated.tip=''?'' ìž?ë¦¬í‘œì‹œìž?ëŠ” ë?” ì?´ìƒ? ì‚¬ìš©ë?˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ëŒ€ì‹  ''*''ë¥¼ ì‚¬ìš©í•´ ì£¼ì„¸ìš”.
kind.projector.deprecated.tip.with.update=''?'' ìž?ë¦¬í‘œì‹œìž?ëŠ” ë?” ì?´ìƒ? ì‚¬ìš©ë?˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ëŒ€ì‹  kind-projector í”ŒëŸ¬ê·¸ì?¸ì?„ ì—…ë?°ì?´íŠ¸í•œ í›„ ''*''ë¥¼ ì‚¬ìš©í•´ ì£¼ì„¸ìš”.
kind.projector.simplify.type=Kind Projector\: ìœ í˜• ë‹¨ìˆœí™”
kind.projector.replace.lambda.with.lamda.char=Kind Projector\: ëžŒë‹¤ë¥¼ Î»ë¡œ ë°”ê¾¸ê¸°
kind.projector.replace.lambda.char.with.lambda=Kind Projector\: Î»ë¥¼ ëžŒë‹¤ë¡œ ë°”ê¾¸ê¸°
kind.projector.use.correct.lambda.keyword=Kind Projector\: ì˜¬ë°”ë¥¸ ëžŒë‹¤ í‚¤ì›Œë“œ ì‚¬ìš©
kind.projector.code.style.setting.use.lamda.char=Kind Projector\: ì½”ë“œ ìŠ¤íƒ€ì?¼ ì„¤ì • ë³€ê²½\: ëžŒë‹¤ ëŒ€ì‹  Î» ì‚¬ìš©
kind.projector.code.style.setting.use.lamda.word=Kind Projector\: ì½”ë“œ ìŠ¤íƒ€ì?¼ ì„¤ì • ë³€ê²½\: Î» ëŒ€ì‹  ëžŒë‹¤ ì‚¬ìš©
invocation.index.out.of.bounds=í˜¸ì¶œì?´ IndexOutOfBoundsExceptionì?„ ìƒ?ì„±í•©ë‹ˆë‹¤. ìƒ‰ì?¸ì?´ í•­ìƒ? ë²”ìœ„ë¥¼ ë²—ì–´ë‚©ë‹ˆë‹¤.
invocation.no.such.element=í˜¸ì¶œì?´ NoSuchElementExceptionì?„ ìƒ?ì„±í•©ë‹ˆë‹¤. ì»¬ë ‰ì…˜ì?´ í•­ìƒ? ë¹„ì–´ ìžˆìŠµë‹ˆë‹¤.
condition.always.true=ì¡°ê±´ì?´ í•­ìƒ? trueìž…ë‹ˆë‹¤
condition.always.false=ì¡°ê±´ì?´ í•­ìƒ? falseìž…ë‹ˆë‹¤
expression.always.zero=í‘œí˜„ì‹?ì?´ í•­ìƒ? 0ìœ¼ë¡œ í?‰ê°€ë?¨
expression.always.null=í‘œí˜„ì‹?ì?´ í•­ìƒ? nullë¡œ í?‰ê°€ë?¨
warning.with.message=ê²½ê³ \: {0}
error.detected.with.message=ì˜¤ë¥˜ íƒ?ì§€ë?¨\: {0}
grouppath.scala.collections=Scala,ì»¬ë ‰ì…˜
method.signature.unit.explicit.type=ë¶ˆí•„ìš”í•œ Unit ê²°ê³¼ ìœ í˜• ì–´ë…¸í…Œì?´ì…˜
method.signature.unit.functional.definition=Unit ê²°ê³¼ ìœ í˜•ì?´ Unitì?¸ ë©”ì„œë“œëŠ” í•¨ìˆ˜ ì •ì?˜ë¥¼ í?¬í•¨í•©ë‹ˆë‹¤
method.signature.unit.explicit.assignment=ë¶ˆí•„ìš”í•œ ëŒ€ìž…
displayname.default.file.template.inspection=ë””í?´íŠ¸ íŒŒì?¼ í…œí”Œë¦¿ ê²€ì‚¬
remove.redundant.type.annotation=ë¶ˆí•„ìš”í•œ ìœ í˜• ì–´ë…¸í…Œì?´ì…˜ ì œê±°
remove.redundant.type.annotation.and.equals.sign=ë¶ˆí•„ìš”í•œ ìœ í˜• ì–´ë…¸í…Œì?´ì…˜ ë°? ë“±í˜¸ ê¸°í˜¸ ì œê±°
remove.redundant.equals.sign=ë¶ˆí•„ìš”í•œ ë“±í˜¸ ê¸°í˜¸ ì œê±°
make.apply.call.explicit="apply" í˜¸ì¶œì?„ ëª…ì‹œì ?ìœ¼ë¡œ ë§Œë“¤ê¸°
drop.one.hint=drop(1)ì?„ tailë¡œ ë°”ê¾¸ê¸°
replace.equals.with.arrays.equals=ë°°ì—´ ìƒ?ë“± ëŒ€ì‹  java.util.Arrays.equals ì‚¬ìš©
suppress.inspection.argument=ì?¸ìˆ˜ ì–µì œ
internal.string.should.be.in.bundle=ë¬¸ìž?ì—´ì?´ ë²ˆë“¤ë¡œ ì¶”ì¶œë?˜ì–´ì•¼ í•©ë‹ˆë‹¤
internal.only.pass.hardcoded.strings.as.property.keys=í”„ë¡œí?¼í‹° í‚¤ë¡œ í•˜ë“œì½”ë”©ë?œ ë¬¸ìž?ì—´ë§Œ ì „ë‹¬
internal.expression.without.nls.passed.to.nls=@Nlsë¡œ ì „ë‹¬ë?œ @Nlsê°€ ì—†ëŠ” í‘œí˜„ì‹?
intention.category.scala.internal=Scala/ë‚´ë¶€
