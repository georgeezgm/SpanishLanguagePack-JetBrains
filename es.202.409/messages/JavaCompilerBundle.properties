message.category.error=Error
message.category.warning=경고
message.category.information=정보
message.category.statistics=통계
error.copying={1}에 {0} 복사\n오류\:\n{2}
file.copying.compiler.description=파일 복사 컴파일러
error.javac.out.of.memory=메모리 부족. 프로젝트 프로퍼티 | 컴파일러 설정에서 최대 힙 크기를 늘리세요.
progress.loading.classes=클래스 로딩 중...
progress.compiling.class={0} 컴파일 중...
progress.parsing.file={0} 구문 분석 중...
action.compile.description.module=módulo ''{0}''
action.compile.description.selected.files=선택한 파일
rebuild.lvcs.label.no.errors=오류 없는 ''{0}''
rebuild.lvcs.label.with.errors=오류 있는 ''{0}''
action.make.selected.modules.text=선택한 모듈 빌드(_M)
message.resource.patterns.format.changed=리소스 패턴의 유형이 변경되었습니다.\n{0}에서 기존 정규식 패턴을 변환하지 못했습니다.\n{1}\n패턴 문자열을 새 유형으로 입력하십시오.\n각 리소스 패턴에는 다음 와일드 카드가 포함될 수 있습니다.\n? - 문자 1개\n* - 문자 0개 이상\n\! - 패턴을 부정(패턴의 시작 부분에만 허용)\n리소스 패턴 분리에는 ;(세미콜론)을 사용합니다. \n백슬래시("\")로 "\!" 문자를 이스케이프합니다.\n템플릿 프로젝트 설정의 수정이 필요할 수도 있습니다.\n입력된 패턴을 허용하려면 ''{2}''(을)를 누르고, 디폴트 패턴을 새 형식으로 로드하려면 ''{3}''(을)를 누릅니다.
pattern.conversion.dialog.title=패턴 변환
error.bad.resource.patterns=다음 리소스 패턴은 형식이 올바르지 않습니다\: {0}
bad.resource.patterns.dialog.title=잘못된 리소스 패턴 형식
compiler.results.export.text.prefix=줄({0})
compiler.error.exception=Error\: {0}
status.compilation.aborted=중단된 컴파일
status.all.up.to.date=모든 파일이 최신 상태입니다.
compiler.error.failed.to.delete={0} 삭제 실패
compiler.build.messages.classes.check.uptodate=빌드 결과가 요청한 컴파일 범위에 대해 최신입니다.\n후속 증분 빌드는 아무런 영향을 미치지 않습니다.
compiler.build.messages.classes.check.outdated=빌드 결과가 요청한 컴파일 범위에 대해 최신이 아닙니다.\n후속 증분 빌드 시 변경된 소스 파일을 컴파일하고 이전 빌드의 오래된 결과를 제거합니다.
progress.updating.caches=캐시 업데이트 중...
compiler.content.name.rebuild=다시 빌드
compiler.content.name.recompile=다시 컴파일
compiler.content.name.make=빌드
modules.classpath.title=종속성
status.compilation.completed.successfully.with.warnings=빌드가 완료되었습니다. {0}개 {0, choice, 0\#경고|1\#경고|2\#경고}
status.compilation.completed.successfully=\ 빌드가 성공적으로 완료되었습니다.
status.compilation.completed.successfully.with.warnings.and.errors=빌드가 완료되었습니다. {0}개 {0,choice, 0\#오류|1\#오류|2\#오류} 및 {1}개 {1,choice, 0\#경고|1\#경고|2\#경고}
progress.executing.precompile.tasks=컴파일 사전 작업 실행 중...
progress.executing.postcompile.tasks=컴파일 후 작업 실행 중...
error.failed.to.create.directory=디렉토리 "{0}" 생성 실패
error.chunk.modules.must.have.same.jdk=모듈 간 순환 종속 요소로 인해 다음 모듈에는 동일한 JDK가 할당되어야 합니다.\n{0}\n모듈 구성을 업데이트하십시오.
error.chunk.modules.must.have.same.language.level=모듈 간 순환 종속 요소로 인해 다음 모듈에는 동일한 언어 수준이 할당되어야 합니다.\n{0}\n모듈 구성을 업데이트하십시오.
warning.sources.under.output.paths=현재 컴파일러 옵션으로 "다시 빌드 시 출력 디렉토리 삭제"가 사용되고 있습니다.\n그러나 소스 파일은 다음 출력 경로에 존재할 수 있습니다.\n{0}\n컴파일은 출력 디렉토리를 삭제하지 않고 진행됩니다.
action.compiler.properties.text=컴파일러 프로퍼티
actions.exclude.from.compile.text=컴파일에서 제외
progress.checking.dependencies=종속 요소 확인 중...
progress.found.dependent.files={0} 종속 파일 발견
error.compiler.internal.error=컴파일러 내부 오류. 종료 코드 {0}(으) 로 프로세스가 종료되었습니다.
error.bad.class.file.format=잘못된 클래스 파일 형식\:\n{0}
java.compiler.description=Compilador de Java
resource.compiler.description=리소스 컴파일러
rmi.compiler.description=RMI 컴파일러
error.jdk.not.specified=컴파일러를 시작할 수 없음\: {0, choice, 1\#모듈|2\#모듈} {1}에 SDK가 지정되지 않았습니다.\n프로젝트 구조 대화상자에서 SDK를 지정하십시오.
error.output.not.specified=컴파일을 시작할 수 없음\: {0, choice, 1\#모듈|2\#모듈} {1}에 출력 경로가 지정되지 않았습니다.\n프로젝트 구조 대화상자에서 출력 경로를 지정하십시오.
statistics.files.classes=파일\: {0} - 클래스\: {1}
compiler.javac.name=Javac
javac.error.jdk.home.missing=JDK ''{0}''에 대한 홈 디렉토리 ''{1}''(을)를 찾을 수 없습니다.\nJDK 구성을 업데이트하십시오.
javac.error.unknown.jdk.version=JDK {0} 버전을 지정할 수 없습니다.\nJDK 설정을 업데이트하십시오.
compiler.configurable.display.name=Compilador
label.option.compile.in.background=백그라운드에서 컴파일(&O)
label.option.clear.output.directory.on.rebuild=다시 빌드 시 출력 디렉토리 삭제(&L)
label.option.resource.patterns.text=리소스 패턴\:
error.compiler.configurable.malformed.patterns=다음 리소스 패턴은 형식이 올바르지 않습니다\:\n{0}
exclude.from.compile.table.path.column.name=경로
exclude.from.compile.table.recursively.column.name=재귀적
no.excludes=제외 없음
option.use.compiler.text=컴파일러 사용\:
java.compiler.option.additional.command.line.parameters=추가 명령줄 매개변수\:
java.compiler.option.generate.no.warnings=경고 생성 없음
java.compiler.option.generate.debugging.info=디버깅 정보 생성
java.compiler.option.report.deprecated=중단된 기능의 사용 보고
javac.option.max.heap.size=최대 힙 사이즈(Mb)\:
javac.options.group.title=Javac 옵션
rmic.option.generate.iiop.stubs=IIOP 스텁 생성
rmic.option.enable.rmi.stubs=RMI 스텁 생성 활성화
compile.progress.title=컴파일 진행률
statistics.error.count={0} {0,choice, 0\#에러|1\#에러|2\#에러}
statistics.warnings.count={0} {0,choice, 0\#경|1\#경고|1\#|2\#경고}
compiler.running.dialog.title=실행 중인 컴파일러
warning.compiler.running.on.project.close=컴파일러가 실행 중입니다. 프로젝트 종료를 진행하시겠습니까?
warning.compiler.running.on.toolwindow.close=컴파일가 실행 중입니다. 종료하시겠습니까?
add.notnull.assertions=notnull 어노테이션이 추가된 메소드 및 매개변수에 대한 런타임 어설션 추가(&A) 

compiler.eclipse.name=Eclipse
eclipse.options.group.title=Eclipse 옵션

#artifacts
packaging.element.text.output.root=<output root>
label.text.main.class=메인 클래스(&M)\:
label.text.class.path=클래스 경로(&P)\:
element.type.name.artifact=아티팩트
dialog.title.choose.artifacts=아티팩트 선택
node.text.0.directory.content=''{0}'' 디렉토리 컨텐츠
element.type.name.library.files=라이브러리 파일
node.text.0.compile.output=''{0}'' 컴파일 출력
node.text.0.test.compile.output=''{0}'' 테스트 컴파일 출력
node.text.0.with.dependencies=종속 요소가 있는 ''{0}''
node.text.0.module.sources=''{0}'' 소스
element.type.name.module.source=모듈 소스
element.type.name.module.output=모듈 출력
element.type.name.module.test.output=모듈 테스트 출력
element.type.name.directory=디렉토리
element.type.name.archive=아카이브
artifact.type.plain=기타
build.artifacts.before.run.description.empty=아티팩트 빌드
build.artifacts.before.run.description.single=''{0}'' 아티팩트 빌드
build.artifacts.before.run.description.multiple={0} 아티팩트 빌드
build.artifacts.before.run.selector.title=아티팩트 선택

message.text.destination.is.directory={0} 대상은 디렉토리입니다.
message.text.error.copying.file.to.file=''{1}''에 ''{0}'' 복사 오류.
message.text.compiling.item.deployment.descriptor.could.not.be.found={0} 컴파일\: 배포 항목 ''{1}''(을)를 찾을 수 없습니다.
message.text.compiling.module.message={0} 컴파일\: {1}
message.text.xml.file.invalid=XML 파일 ''{0}''(이)가 올바르지 않습니다.
mesage.text.deployment.descriptor.file.not.exist=배포 설명자 파일 ''{0}''(이)가 존재하지 않습니다.
message.text.deployment.description.invalid.file=잘못된 파일
warning.text.file.has.been.changed=컴파일 중 파일이 변경되며 유효성 검사를 건너뛰었습니다.

dialog.message.compilation.of.unloaded.modules.failed=변경된 파일에 의존하는 언로드된 모듈이 프로젝트에 있습니다.<br>이러한 모듈의 컴파일은 오류로 종료되었습니다.
dialog.title.compilation.failed=컴파일 실패
button.text.checkin.handler.commit=커밋(&C)
button.text.checkin.handler.show.errors=오류 표시(&S)
checkbox.text.compile.affected.unloaded.modules=언로드된 모듈에 영향을 받는 컴파일(&U)

#artifacts
dialog.title.output.directory.for.artifact=아티팩트에 출력 디렉토리
chooser.description.select.output.directory.for.0.artifact=''{0}'' 아티팩트 출력 디렉토리 선택

#package file action
action.name.package.file=파일 패키징
action.description.package.file=해당 아티팩트의 파일 업데이트
message.tect.package.file.io.error=IO 오류\:\n{0}
command.name.package.file=파일 패키징
status.text.file.has.been.packaged={0, choice, 1\#파일|2\#파일} {1} {0, choice, 1\#에 포함|2\#에 포함}은 {2}에서 패키징되었습니다.
action.name.package.files=파일 패키징

# validation
validation.display.name=유효성 검사
action.name.exclude.from.validation=유효성 검사에서 제외
no.validators=사용 가능한 유효성 검사기가 없습니다.
label.option.autoshow.first.error=에디터에서 첫 번째 오류 자동으로 표시(&E)
label.option.display.notification.popup=빌드 완료 시 알림 표시

compiler.ref.service.validation.task.name=역방향 참조 색인 유효성 검사
compiler.ref.service.validation.progress.text=역방향 참조 색인 유효성 검사 중
java.compiler.option.prefer.target.jdk.compiler=가능할 경우 모듈 대상 JDK에서 컴파일러 사용
configurable.CompilerUIConfigurable.display.name=일반
configurable.AnnotationProcessorsConfigurable.display.name=어노테이션 프로세서
settings.configure.annotations=어노테이션 구성(&C)...
settings.build.project.automatically=프로젝트 자동 빌드
settings.compile.independent.modules.in.parallel=독립적 모듈 병렬 컴파일
settings.rebuild.module.on.dependency.change=종속 요소 변경 시 모듈 다시 빌드
settings.build.process.heap.size=프로세스 힙 크기(Mbytes) 빌드\:
settings.shared.build.process.vm.options=공유된 빌드 프로세스 VM 옵션\:
settings.user.local.build.process.vm.options=사용자-로컬 빌드 프로세스 VM 옵션(공유 옵션 재정의)\:
settings.auto.build.only.works.while.not.running=(실행/디버그 중이 아닌 경우에만 작동)
settings.parallel.module.compile.may.require.larger.heap.size=(더 큰 힙 사이즈가 필요할 수 있습니다)
settings.warning=<html>경고\!<br>'다시 빌드 시 출력 디렉토리 삭제' 옵션을 사용하도록 설정하면 생성된 소스가 저장된 디렉토리의 전체 콘텐츠가 다시 빌드 시 삭제됩니다.</html>
settings.use.release.option.for.cross.compilation=크로스 컴파일에 '--release' 옵션을 사용하십시오(Java 9 이상)
settings.project.bytecode.version=프로젝트 바이트코드 버전\: 
settings.per.module.bytecode.version=모듈당 바이코드 버전\:
settings.same.as.language.level=언어 수준과 동일
settings.all.modules.will.be.compiled.with.project.bytecode.version=모든 모듈은 프로젝트 바이트코드 버전으로 컴파일됩니다.
settings.module.column=모듈
settings.target.bytecode.version=대상 바이트코드 버전
settings.recommended.in.paths=(크로스 플랫폼 구성 경로에서 '/'이 권장됩니다)
settings.override.compiler.parameters.per.module=모듈당 컴파일러 매개변수 재정의\:
settings.override.module.column=모듈
settings.override.compilation.options.column=컴파일 옵션
settings.additional.compilation.options=추가 컴파일 옵션은 모든 모듈에서 동일합니다.
settings.enable.annotation.processing=어노테이션 처리 활성화
settings.obtain.processors.from.project.classpath=프로젝트 클래스 경로에서 프로세서 취득
settings.processor.path=프로세서 경로\:
settings.use.processor.module.path.compiler.option.for.java.9.and.later=--processor-module-path 컴파일러 옵션을 사용하십시오(Java 9 이상)
settings.module.content.root=모듈 콘텐츠 루트\:
settings.module.output.directory=모듈 출력 디렉토리
settings.annotation.processors=어노테이션 프로세서\:
settings.compiler.will.run.all.automatically.discovered.processors=컴파일러는 자동으로 검색된 모든 프로세서를 실행합니다.
settings.annotation.processor.options=어노테이션 프로세서 옵션\:
settings.no.processor.specific.options.configured=프로세서별 옵션이 구성되지 않았습니다.
settings.module.path.warning=지정된 경로가 '모듈 경로'라고 가정합니다(패키지된 java 모듈을 포함하는 JAR 또는 디렉토리의 경로). \n모듈 경로에서 검색하고 실행하려면 어노테이션 프로세서를 java 모듈로 패키징하고 모듈 선언의 ServiceLoader에 등록해야 합니다.
settings.store.generated.sources.relative.to=다음을 기준으로 생성된 소스 저장\: 
settings.production.sources.directory=프로덕션 소스 디렉토리\:
settings.column.option.name=옵션 이름
settings.column.value=값
settings.test.sources.directory=테스트 소스 디렉토리\:
settings.processor.fq.name=프로세서 FQ 이름
settings.validate.on.build=빌드 시 유효성 검사
settings.exclude.from.validation=유효성 검사에서 제외\:
settings.validators=유효성 검사기\:
no.compilation.problems.found=컴파일 문제가 없습니다.
cannot.package.file=파일을 패키징할 수 없습니다.
packaging.files=파일 패키징 중
only.works.while.not.running.debugging=(실행/디버그 중이 아닌 경우에만 작동)
disabled.in.power.save.mode=(절전 모드에서 비활성화)
path.to.ecj.compiler.tool=ecj 컴파일러 도구에 대한 경로
choose.members=멤버 선택
all.modules=<All Modules>
create.jar.from.modules=모듈에서 JAR 생성
cannot.delete.0=''{0}''을(를) 삭제할 수 없습니다.
cannot.clean.0.artifact=''{0}'' 아티팩트를 정리할 수 없습니다.
cleaning.artifacts=아티팩트 정리 중
clean.artifacts=아티팩트 정리
0.errors.1.warnings=오류 {0}, 경고 {1}
compilation.finished=컴파일 완료
meta.inf.manifest.mf.file.not.found.in.0=''{0}''에서 META-INF/MANIFEST.MF 파일을 찾을 수 없습니다.
0.manifest.properties=''{0}'' 매니페스트 프로퍼티\:
specify.path.to.manifest.mf.file=MANIFEST.MF 파일에 대한 경로 정
edit.classpath=클래스 경로 편집
synchronizing.output.directories=출력 디렉토리 동기화 중...
button.rebuild=다시 빌드
confirm.project.rebuild=프로젝트 다시 빌드 확인
you.are.about.to.rebuild.the.whole.project=전체 프로젝트를 다시 빌드하려고 합니다.\n'프로젝트 빌드'를 대신 실행하시겠습니까?
class.can.have.more.common.super.class=클래스는 더 일반적인 상위 클래스를 가질 수 있습니다.
cannot.create.directory.0.1=디렉토리 ''{0}''을(를) 생성할 수 없습니다\: {1}
select.directory.for.meta.inf.manifest.mf.file=META-INF/MANIFEST.MF 파일 디렉토리 선택
title.new.archive=새 아카이브
enter.archive.name=아카이브 이름 입력\: 
action.text.move.to=이동 대상
title.create.new.profile=새 프로파일 생성
dialog.message.profile.name=프로파일 이름
title.new.directory=새 디렉토리
dialog.message.enter.directory.name=디렉토리 이름 입력\: 
dialog.title.packaging.choose.module=모듈 선택
dialog.title.packaging.choose.library=라이브러리 선택
node.excluded.flag.tooltip=제외됨
macro.output.path=출력 경로
button.add=추가(&A)...
eclipse.compiler.cross.platform.help.message=(크로스 플랫폼 구성 경로에서 '/'이 권장됩니다)
eclipse.compiler.path.leave.empty.help.message=ECJ 일괄처리 컴파일러 도구에 대한 경로(번들로 사용할 수 있도록 비워 둡니다)\:
eclipse.compiler.proceed.on.errors.option=오류에도 진행
