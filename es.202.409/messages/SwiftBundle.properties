title.method.parameters.group=메소드/함수 선언 매개변수
title.method.arguments.group=메소드/함수 호출 인수
title.closure.group=클로저
title.condition.clauses.group=조건 절
title.if.group='if' 문
title.guard.group='guard' 문
title.for.group='for' 문
title.do.while.group='repeat … while' 문
title.try.group='do' 문
title.superclass.list.group=기본 클래스 및 채택된 프로토콜 목록
title.colon.group=콜론 주위
title.ternary=삼항 조건 연산
title.in.ternary=삼항 조건 연산 내
title.variable.groups=변수 그룹

indent.multiline.strings=여러 줄의 문자열 들여쓰기
indent.directives.title=지시문
indent.directives.as.code=코드 들여쓰기 준수
indent.directives.children=하위 항목 들여쓰기

checkbox.spaces.before.method.parentheses=메소드/함수 선언 소괄호
checkbox.spaces.after.operator.in.function.declarations=함수 선언 내 연산자
checkbox.spaces.before.method.call.parentheses=메소드/함수 호출 소괄호
checkbox.spaces.equality.operator=상등 연산자 '\=\='
checkbox.spaces.shift.operators=시프트 연산자(<<, >>)
checkbox.spaces.around.range.operators=범위 연산자 (..., ..<)
checkbox.spaces.closure.arrow=클로저 화살표(->)
checkbox.spaces.attribute.parameters=속성 매개변수
checkbox.spaces.within.literal.brackets=배열 및 사전 리터럴 대괄호
checkbox.spaces.within.method.parentheses=메소드/함수 선언 소괄호
checkbox.spaces.within.empty.method.parentheses=빈 메소드/함수 선언 소괄호
checkbox.spaces.within.method.call.parentheses=메소드/함수 호출 소괄호
checkbox.spaces.within.empty.method.call.parentheses=빈 메소드/함수 호출 소괄호
checkbox.spaces.attribute.parentheses=속성 소괄호
checkbox.spaces.before.argument.colon=메소드/함수 호출 내 콜론 앞
checkbox.spaces.after.argument.colon=메소드/함수 호출 내 콜론 뒤
checkbox.spaces.before.type.colon=유형 어노테이션 내 콜론 앞
checkbox.spaces.after.type.colon=유형 어노테이션 내 콜론 뒤
checkbox.spaces.before.superclass.colon=유형 상속 절 내 콜론 앞
checkbox.spaces.after.superclass.colon=유형 상속 절 내 콜론 뒤
checkbox.spaces.before.dictionary.type.colon=사전 유형 내 콜론 앞
checkbox.spaces.after.dictionary.type.colon=사전 유형 내 콜론 뒤
checkbox.spaces.before.dictionary.literal.colon=사전 리터럴 'key\:value' 쌍 내 콜론 앞
checkbox.spaces.after.dictionary.literal.colon=사전 리터럴 'key\:value' 쌍 내 콜론 뒤
checkbox.spaces.within.string.interpolations=문자열 보간
checkbox.spaces.before.class.lbrace=유형 선언이 왼쪽 중괄호
checkbox.spaces.before.method.lbrace=메소드/함수 왼쪽 중괄호
checkbox.spaces.before.semicolon=세미콜론 앞
checkbox.spaces.after.semicolon=세미콜론 뒤

wrapping.align.when.multiline=여러 줄일 경우 정렬
wrapping.align.in.columns=열에 정렬
wrapping.else.on.new.line=새 줄에 'else'
wrapping.keep.control.statement.in.one.line=제어문을 한 줄로
wrapping.keep.simple.methods.in.one.line=메소드 및 함수를 한 줄로
wrapping.keep.simple.blocks.in.one.line=블록 및 (후미) 클로저를 한 줄로
wrapping.keep.simple.argument.blocks.in.one.line=클로저 인수를 한 줄에 배치
wrapping.structures.in.one.line=빈 유형 선언을 한 줄로
wrapping.method.brace.placement=메소드 및 함수 내
wrapping.array.literal=배열 및 사전 리터럴
wrapping.array.new.line.after.left.bracket='[' 뒤에 새 줄
wrapping.array.right.bracket.on.new.line=새 줄에 ']' 배치
wrapping.classes.annotation=유형 선언 속성
wrapping.methods.annotation=메소드 속성
wrapping.fields.annotation=프로퍼티 속성
wrapping.parameters.annotation=매개변수 속성
wrapping.local.variables.annotation=지역 변수 속성
wrapping.closure.signature.on.next.line=여러 줄일 경우 매개변수를 새 줄에
wrapping.brace.placement.class.declaration=유형 선언 내

blank.lines.around.class=유형 선언 주위\:
blank.lines.around.field.in.protocol=프로토콜 내 프로퍼티 주위\:
blank.lines.around.field=Around 프로퍼티\:
blank.lines.around.method.in.protocol=프로토콜 내 메소드/함수 주위\:
blank.lines.around.method=메소드/함수 주위\:
blank.lines.before.method.body=메소드/함수 본문 앞\:

create.field.kind=종류(&K)\:
create.file.title=Swift 파일
create.file.dialog.title=새 Swift 파일
create.file.description=새 Swift 파일을 생성합니다.
create.class.title=Swift 유형
create.class.dialog.title=새 Swift 유형
create.type.dialog.title=새 Swift {0}
create.class.description=새 Swift 유형을 생성합니다.

goto.super.action={0} 선택 
goto.super.menu.action=상위 {0}(_U)
goto.super.typealias=유형 별칭 또는 관련 유형
goto.super.class=클래스 또는 프로토콜
goto.base.type=기본 유형

# suprimir la inspección "UnusedProperty"
override.implement.nothing.found={0}에 대해 롤백할 것이 없음
# suprimir la inspección "UnusedProperty"
override.implement.not.allowed={0}할 수 없습니다
show.implement.action.title=구현할 멤버 표시
elements.to.implement.chooser.title=구현할 멤버 선택
elements.to.override.chooser.title=재정의할 멤버 선택
elements.to.override.implement.chooser.title=재정의/구현할 멤버 선택

override.implement.progress=재정의/구현할 멤버 처리 중…
override.implement.show.optional.member=1개의 선택적 멤버 표시(&O)
override.implement.show.optional.members={0}개의 선택적 멤버 표시(&O)
override.implement.show.no.optional.members=선택적 멤버 표시(선택적 항목 없음)
override.implement.show.only.optional.members=선택적 멤버 표시(선택적 항목만)

hashbang.line.is.allowed.only.in.the.first.line.of.the.main.file=Hashbang 줄은 기본 파일의 첫 번째 줄에서만 허용됩니다.
hashbang.line.is.allowed.only.in.the.first.line.of.the.file=Hashbang 줄은 파일의 첫 번째 줄에서만 허용됩니다.
hashbang.line.is.allowed.only.in.the.main.file=Hashbang 줄은 기본 파일에서만 허용됩니다.
0.is.not.allowed=''{0}''은(는) 허용되지 않습니다.
fix.it=Fix-it 적용
0.is.not.resolved=''{0}''이(가) 해결되지 않았습니다.
unrecognized.platform.name.0=인지되지 않은 플랫폼 이름 ''{0}''
must.handle.potential.future.platforms.with.asterisk=향후 나올 수 있는 플랫폼을 '*'로 처리해야 합니다.
add.asterisk=추가 '*'
version.for.0.already.specified=''{0}''의 버전은 이미 지정되어 있습니다.
case.condition.is.not.allowed='case' 조건이 허용되지 않습니다.
syntax.error.typealias.without.assignment=유형 별칭 선언에서 대입이 누락되어 있습니다.

#error handling >>
rethrows.is.not.allowed.in.function.type.elements=함수 유형 요소에서는 'rethrows'가 허용되지 않습니다.
rethrows.is.not.allowed.in.subscripts=하위 스크립트에서는 'rethrows'가 허용되지 않습니다.
rethrows.is.not.allowed.in.closures=클로저에서는 'rethrows'가 허용되지 않습니다.
rethrows.function.must.take.a.throwing.function.argument='rethrows' 함수에는 던지는 함수 인수가 있어야 합니다.
throws.is.not.allowed.in.subscripts=하위 스크립트에서는 'throws'가 허용되지 않습니다.
thrown.expression.type.0.does.not.conform.to.ErrorType=던져진 표현식 유형 ''{0}''이(가) ''{1}''을(를) 준수하지 않습니다.
try.cannot.appear.to.the.right='try'는 대입되지 않은 연산자의 오른쪽에 표시될 수 없습니다.

call.can.throw.in.property.initializer=프로퍼티 이니셜라이저에서 호출은 던질 수 있지만 오류는 던질 수 없습니다.
call.can.throw.in.default.argument=디폴트 인수에서 호출은 던질 수 있지만 오류는 던질 수 없습니다.

call.can.throw.not.marked.with.try=호출은 던질 수 있지만 'try'로 표시되지 않습니다.
call.can.throw.not.marked.with.try.not.handled=호출은 던질 수 있지만 'try'로 표시되지 않으며 오류가 처리되지 않습니다.
call.can.throw.not.marked.with.try.not.exhaustive=호출은 던질 수 있지만 'try'로 표시되지 않으며 둘러싼 catch가 완전하지 않습니다.
call.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=호출은 던질 수 있지만 던지지 않는 autoclosure에서 실행됩니다.
call.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=호출은 던질 수 있지만 'try'로 표시되지 않으며 던지지 않는 autoclosure에서 실행됩니다.

operator.can.throw.not.marked.with.try=연산자는 던질 수 있지만 표현식은 'try'로 표시되지 않습니다.

errors.are.not.handled=여기에서 던져진 오류는 처리되지 않습니다.
errors.are.not.handled.not.exhaustive=둘러싼 catch가 완전하지 않기 때문에 여기에서 던져진 오류는 처리되지 않습니다.

error.is.not.handled=둘러싼 함수가 'throws'로 던져지지 않기 때문에 오류가 처리되지 않습니다.
error.is.not.handled.not.exhaustive=둘러싼 catch가 완전하지 않기 때문에 오류가 처리되지 않습니다.

rethrows.function.can.only.throw.parameter.call='rethrows'로 선언된 함수는 해당 매개변수가 던질 경우에만 던집니다.
rethrows.function.can.only.throw.parameter.call.not.handled=호출은 던질 수 있지만 오류는 처리되지 않습니다. 'rethrows'로 선언된 함수는 해당 매개변수가 던질 경우에만 던집니다.
rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=호출은 던질 수 있지만 'try'로 표시되지 않으며 오류가 처리되지 않습니다. 'rethrows'로 선언된 함수는 해당 매개변수가 던질 경우에만 던집니다.

mark.the.enclosing.function.as.throws='throws'를 함수 시그니처에 추가
add.try.to.expression='try' 추가
suppress.call.error.with.try='try\!'로 오류 억제
surround.with.do.catch='do/catch'로 둘러싸기
add.default.catch.clause=디폴트 'catch' 절 추가
add.catch.clause='catch' 절 추가
fix.try.cannot.appear.to.the.right='try'를 왼쪽으로 이동
intention.create.kind.{0}.from.usage.{1}={0} ''{1}'' 생성
intention.create.type.from.usage.{0}=유형 ''{0}'' 생성
intention.implement.members.error=유형 {0}이(가) {1}을(를) 준수하지 않습니다.
# suprimir la inspección "UnusedProperty"
intention.implement.members.implement.missing.singular={0}의 누락된 멤버 구현
# suprimir la inspección "UnusedProperty"
intention.implement.members.implement.missing.plural={0}의 누락된 멤버 구현
# suprimir la inspección "UnusedProperty"
intention.access.control.error.access={0}에 액세스할 수 없습니다. 해당 항목은 {2}에서 {1}입니다.
# suprimir la inspección "UnusedProperty"
intention.access.control.error.access.dynamic={0}에 액세스할 수 없습니다. 동적 멤버 서브스크립트는 {2}에서 {1}입니다.
intention.access.control.error.override={0}을(를) 재정의할 수 없습니다. 해당 항목은 {2}에서 {1}입니다.
intention.access.control.fix={2} 내 {0} {1} 생성
intention.access.control.remove.setter={0}에서 {1} 제거
intention.redundant.attribute.error=속성 @{0}이(가) 중복되었습니다.
intention.redundant.attribute.fix=중복 속성 @{0} 제거
intention.redundant.return.error='return'이 중복되었습니다.
intention.redundant.return.fix=중복 'return'을 제거합니다.
intention.replace.if.with.guard='if'를 'guard'로 교체
intention.replace.guard.with.if='guard'를 'if'로 교체
intention.add.explicit.type=명시적 유형 추가
intention.remove.explicit.type=명시적 유형 제거
intention.convert.to.multiline.string=여러 줄 문자열 리터럴로 변환
intention.convert.to.string=한 줄 문자열 리터럴로 변환
intention.convert.to.decimal=10진수로 변환
intention.convert.to.hex=16진수로 변환
intention.convert.to.octal=8진수로 변환
intention.convert.to.binary=2진수로 변환
intention.increase.string.escape.level=문자열 이스케이프 수준 높이기
intention.decrease.string.escape.level=문자열 이스케이프 수준 낮추기
intention.add.digit.separators=숫자 구분 기호 추가
intention.remove.digit.separators=숫자 구분 기호 제거
intention.split.into.separate.declarations=개별 선언으로 분할합니다.
intention.split.declaration.and.assignment=선언 및 할당 분할
intention.join.declaration.and.assignment=선언 및 할당 결합
intention.merge.else.if=else if 문 병합
intention.split.else.if=else if 문 분할
intention.invert.if.statement=구문인 경우 반전
intention.demorganslaw=드모르간 법칙
intention.demorganslaw.format=''{0}''을(를) ''{1}''(으)로 교체
intention.merge.nested.if=중첩된 if 문 병합
intention.split.nested.if=중첩된 if로 분할
intention.merge.conditions=조건 병합
intention.split.condition=개별 조건으로 분할
intention.negate.comparison=비교 부정
intention.negate.comparison.format=''{0}''을(를) ''{1}''(으)로 부정
intention.flip.binary.expression=이진 표현식 반전
intention.flip.binary.expression.format=''{0}'' 반전
intention.flip.comparison=비교를 반전시킵니다.
intention.unnecessary.parentheses=불필요한 소괄호를 제거합니다.
intention.unnecessary.parentheses.error=소괄호는 불필요합니다.
intention.unnecessary.tuple.wrap=단일 요소 튜플을 유형으로 교체
intention.unnecessary.tuple.wrap.error=단일 요소 튜플을 유형으로 교체할 수 있습니다
intention.flip.comparison.format=''{0}''을(를)  ''{1}''(으)로 반전
fix.return.type.text=''{0}''이(가) ''{1}''을(를) 반환하도록 설정
#<< error handling

variable.declaration.with.multiple.variables.cannot.have.explicit.getters.setters=여러 변수를 가진 'var' 선언에는 명시적 getter/setter를 사용할 수 없습니다
variable.declaration.with.multiple.variables.cannot.have.implicit.getter.clause=여러 변수를 가진 'var' 선언에는 묵시적 getter 절을 사용할 수 없습니다
variable.declaration.with.multiple.variables.cannot.have.willset.didset.clause=여러 변수를 가진 'var' 선언에는 willSet/didSet 절을 사용할 수 없습니다.
no.expression.found=표현식을 찾을 수 없습니다

feature.are.not.supported.at.version={0} 은(는) Swift {1}.{2}에서 지원되지 않습니다.
feature.attribute=''@{0}'' 속성
feature.raw.strings=원시 문자열 리터럴
feature.diagnostic.directives=진단 지시문
feature.compiler.version.directive.conditions=컴파일러 버전 검사 지시문

usages.base.member.warning.title=경고
usages.base.member.warning.message.implements={0} 은(는) {3}에서 선언된 {1}을(를) 구현합니다.\n\n프로토콜 {2}의 사용 위치를 검색하시겠어요?
usages.base.member.warning.message.override={0} 은(는) {4}에서 선언된 {1}을(를) 구현합니다.\n\n기본 {2}의 사용 위치를 검색하시겠어요?
usages.base.member.warning.message.override.implemented={0} 은(는) {4}에서 선언된 {1}을(를) 재정의하고 {3}에서 선언된 {1}을(를) 구현합니다.\n\n기본 및 프로토콜 {2}의 사용 위치를 검색하시겠어요?
usages.base.member.warning.message.default.implementation={0} 은(는) {3}에서 선언된 {1}의 디폴트 구현입니다.\n\n프로토콜 {2}의 사용 위치를 검색하시겠어요?

cannot.perform.refactoring=리팩토링을 수행할 수 없습니다
extract.method.title.method=메소드 추출
extract.method.title.function=함수 추출
extract.method.title.closure=클로저 추출
extract.method.error.should.represent.expr.or.statements=선택한 블록은 구문 또는 표현식 모음을 나타내야 합니다.
extract.method.error.cannot.determine.expr.type=선택한 표현식의 유형을 파악할 수 없습니다.
extract.method.error.cannot.extract.expr.with.var.declarations=변수 선언이 있는 표현식에서 추출할 수 없습니다.
extract.method.error.cannot.determine.function.result.type=함수 결과의 유형을 파악할 수 없습니다.
extract.method.error.multiple.exit.points=선택한 코드 조각에 여러 종료점이 있습니다.
extract.method.error.cannot.extract.with.returns=코드 조각 내부에 반환 명령이 있는 메소드를 추출할 수 없습니다.
extract.method.error.cannot.determine.parameters.type=매개변수의 유형을 파악할 수 없습니다.
extract.method.error.fragment.should.be.inside.code.block=선택된 코드 조각은 코드 블록 안에 있어야 합니다.
extract.method.function.0.will.conflict.with.1.2=함수 ''{0}''이(가) {1} {2}와(과) 충돌합니다.
extract.method.method.0.will.conflict.with.1.in.2.3=메소드 ''{0}''이(가) {2} ''{3}''에서 {1}와(과) 충돌합니다.
extract.method.at.least.two.parameters.have.name.0=이름이 ''{0}''인 매개변수가 2개 이상입니다.
extract.method.variable.0.will.no.longer.be.accessible=리팩토링 후 변수 ''{0}'' 에 더 이상 액세스할 수 없습니다
extract.method.cannot.extract.mutable.value=가변 값을 추출할 수 없습니다.
extract.method.0.1.will.be.shadowed.by.2.1={0} ''{1}''이(가) {2} ''{1}''으로 그림자화됩니다.

converter.dialog.message=클립보드에 Objective-C 코드가 포함되어 있습니다. Swift로 변환하시겠어요?
converter.dialog.title=Objective-C를 Swift로 변환

swift.name.rename.init.is.not.supported=swift 이니셜라이저의 이름 변경은 지원되지 않습니다.
swift.name.rename.self.is.not.supported=self 매개변수의 이름 변경은 지원되지 않습니다.
swift.name.rename.title=Swift 이름 변경

swift.related.rename.dialog.title=관련 선언의 이름 변경
swift.related.rename.dialog.description=다음 이름을 가진 관련 선언의 이름을 변경\:
swift.related.rename.entity.name=관련 선언

swift.containing.file.rename.dialog.title=포함하는 파일 이름 변경
swift.containing.file.rename.dialog.description=다음 이름을 가진 포함 파일의 이름 변경\:
swift.containing.file.rename.entity.name=포함 파일

generate.init.init.already.exists=이니셜라이저가 이미 있습니다.
generate.init.choose.super.init=상위 클래스 이니셜라이저 선택
generate.init.choose.properties=초기화할 프로퍼티 선택

generate.0.title={0} 생성
generate.description.single.string.template=단일 문자열
generate.description.string.concatenation.template=연결이 있는 여러 문자열 (+)
generate.description.multi.string.template=다중 줄 문자열
generate.template.title=템플릿(&T)\:

generate.0.already.defined={0}이(가) 이미 정의되어 {1,choice,1\#있습니다|2\#있습니다}. {1,choice,1\#해당 항목|2\#해당 항목}을 삭제하고 계속하시겠어요?
generate.equals.hash=equals 및 hash
generate.equals.hash.choose.in.0={0}에 포함할 프로퍼티 선택
generate.single.expression.equals.template=단일 표현식
generate.if.statements.equals.template=여러 개의 if 문

generate.cannot.generate.0.for.1={1}에 대한 {0}을(를) 생성할 수 없습니다.
generate.preparing.generation.title=생성 준비 중…

usage.type.type.parameter=유형 매개변수
usage.type.extension=확장
usage.type.requirement=요구 사항 내 사용 위치
usage.type.type.alias=유형 별칭
usage.type.argument.label=인수 라벨
usage.type.key.path=키 경로 표현식
usage.type.function.declaration=함수 선언
usage.type.operator.declaration=연산자 선언
usage.type.precedence.group.declaration=우선순위 그룹 선언
usage.type.raw.value=원시 값

color.settings.keyword=키워드 및 지시문//키워드
color.settings.property=식별자//프로퍼티
color.settings.colon=괄호 및 연산자//콜론
color.settings.module.name=유형//모듈 이름
color.settings.protocol=유형//프로토콜
color.settings.class=유형//클래스
color.settings.type.alias=유형//유형 별칭
color.settings.struct.and.enum=유형//구조체 및 열거형
color.settings.operator.sign=괄호 및 연산자//연산자 기호
color.settings.enum.case.value=식별자//열거형 case 값
color.settings.self.and.super.keywords=키워드 및 지시문//'self' 및 'super' 키워드
color.settings.function.and.method.declaration=함수//함수 및 메소드 선언
color.settings.function.and.method.call=함수//함수 및 메소드 호출
color.settings.nested.function.declaration=함수//중첩된 함수 선언
color.settings.nested.function.call=함수//중첩된 함수 호출
color.settings.external.parameter.name=식별자//외부 매개변수 이름
color.settings.inline.closure.parameter=식별자//인라인 클로저 매개변수
color.settings.anonymous.closure.parameter=식별자//익명의 클로저 매개변수
color.settings.wildcard=식별자//와일드카드
color.settings.type.parameter=유형//제네릭 매개변수
color.settings.attribute.name=속성//속성 이름
color.settings.attribute.argument=속성//속성 인수
color.settings.inline.hints.type.hint=인라인 힌트//유형 힌트
color.settings.inline.hints.error.hint=인라인 힌트//오류 힌트
color.conditionally.non.compiled=키워드 및 지시문//조건으로 컴파일되지 않은 코드
color.settings.directive=키워드 및 지시문//지시문

introduce.variable.declare.with.var=var로 선언(&V)
introduce.variable.specify.type.explicitly=명시적으로 유형 지정(&T)
introduce.variable.expression.will.be.ambiguous.without.explicit.type=명시적 유형  없이는<br/>  표현식이 모호합니다.

code.generation=코드 생성
swift.create.initializer=이니셜라이저 생성
renaming.swift.member.elements.in.objective.c.code.is.not.supported=Objective-C 코드 내 Swift 멤버 요소의 이름 변경은 지원되지 않습니다.
swift.rename=Swift - 이름 변경
sourcekit.inspections=SourceKit 검사
swift=Swift
swift.redundant.attribute.inspection=중복 속성
swift.rename.inheritors=상속자 이름 변경
rename.inheritors.to=상속자 이름을 다음으로 변경\:
swift.redundant.return.inspection=중복 반환
swift.unnecessary.parentheses.inspection=불필요한 소괄호
swift.unnecessary.tuple.wrap.inspection=불필요한 튜플 둘러싸기
new.swift.type.in.a.new.file=새 파일 내 새 Swift 유형
create.new.swift.declaration=새 Swift 선언 생성
name.colon=이름\:
cannot.rename.dynamic.called.values=동적으로 호출된 값의 이름은 변경할 수 없습니다.
are.you.sure.you.want.to.reload.all.swift.modules=모든 Swift 모듈을 다시 로드하시겠어요?
reload.all.swift.modules=모든 Swift 모듈 다시 로드
module.colon=모듈\:
reload.module=모듈 다시 로드

change.signature.initializer.will.conflict.with.0.in.1.2=이니셜라이저는 {1} ''{2}'' 에서 {0} 와(과) 충돌합니다
change.signature.subscript.will.conflict.with.0.in.1.2=서브스크립트는 {1} ''{2}'' 에서 {0} 와(과) 충돌합니다
change.signature.dialog.title=시그니처 변경
change.info.return.type.label=반환 유형\:
change.info.name.label=이름\:
change.info.internal.name.label=내부 이름\:
change.info.type.label=유형\:
change.info.optional.label=선택적\:
change.info.default.value.label=디폴트 값\:
change.signature.target.not.found=캐럿은 함수, 이니셜라이저 또는 서브스크립트에 위치해야 합니다
change.signature.processed.elements.header=시그니처를 변경할 요소
change.signature.title=시그니처 변경
