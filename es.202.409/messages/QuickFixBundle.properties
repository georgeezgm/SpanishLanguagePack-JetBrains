add.import=Agregar importación
class.to.import.chooser.title=Clase para importar
method.to.import.chooser.title=Método para importar
field.to.import.chooser.title=Campo para importar
access.static.via.class.reference.family=Acceso estático a través de la referencia de clase
access.static.via.class.reference.text=Acceder estático ''{1}.{0}'' mediante referencia a la clase ''{2}''.
add.default.constructor.family=Agregar constructor predeterminado
add.default.constructor.text={0} Agrega un constructor sin argumentos a {1}.
add.catch.clause.family=Agregue una excepción a la cláusula catch
add.catch.clause.text=Agrega una cláusula ''catch''.
add.finally.block.family=''finally'' añadir bloque
add.exception.to.throws.inherited.method.warning.text=El método ''{0}'' se hereda.\n\
¿Le gustaría agregar una excepción a la firma del método de toda la jerarquía de métodos?
method.is.inherited.warning.title=El método es heredado
add.exception.to.throws.text={0, choice, 0\#exception |2\#exception} a la firma del método
add.exception.to.throws.family=Agregar excepción a la firma del método
add.exception.to.existing.catch.family=Agregar una excepción a la cláusula catch existente
add.exception.to.existing.catch.generic=Agregar una excepción a la cláusula catch existente
add.exception.to.existing.catch.replacement=Reemplazar ''{0}'' con el más genérico ''{1}''
add.exception.to.existing.catch.no.replacement=Agregue ''{1}'' para capturar con ''{0}''
add.exception.to.existing.catch.chooser.title=Selección de bloque de captura

add.method.body.text=Agregar el cuerpo del método.
add.method.family=Agregar método
add.method.text=Agregar método ''{0}'' a la clase ''{1}''.
add.new.array.family=Agregar nueva expresión faltante
add.new.array.text=Añadir ''new {0}[]''
add.return.statement.text=Agregue la declaración ''return''.
add.runtime.exception.to.throws.text=Agregar excepción de tiempo de ejecución a la firma del método.
add.runtime.exception.to.throws.family=Agregar excepción de tiempo de ejecución a la firma del método
add.typecast.family=Agregar TypeCast
add.typecast.text=Transmitir a ''{0}''.
add.qualifier.typecast.text=calificador de conversión a ''{0}''.
add.docTag.to.custom.tags=Agregar {0} a las etiquetas personalizadas
fix.javadoc.family=Modificar Javadoc
adjust.package.family=Ajustar el nombre del paquete
adjust.package.text=Establezca el nombre del paquete en ''{0}''.
bring.variable.to.scope.family=Traer variable al alcance
bring.variable.to.scope.text=''{0}'' al alcance.

cast.parameter.text={0, choice, 1\#1ro|2\#2do|3\#3er|4\#{0,number}to} parámetro ''{1}'' para emitir.
cast.single.parameter.text=parámetro de conversión a ''{0}''.

add.type.arguments.text={0, choice, 1\#1ro|2\#2do|3\#3er|4\#{0,number} th} Agrega un argumento de tipo explícito al argumento.
add.type.arguments.single.argument.text=Agregar argumento de tipo explícito.

change.class.signature.text=Cambia la firma de ''{0}'' para que coincida con ''{1}''.
change.class.signature.family=Cambiar la firma de la clase

uidesigner.change.bound.field.type=Cambiar el tipo de campo vinculado
cannot.change.field.exception=No se puede cambiar el tipo de campo ''{0}''.\n\
Razón \: {1}

# {0} - palabra clave original (extiende o implementa), {1} - palabra clave propuesta (implementa o extiende), {2} - nombre de la clase
exchange.extends.implements.keyword=''{1} {2}'' a ''{0} {2}''
uidesigner.change.gui.component.type=Cambiar el tipo de componente de la GUI
change.method.signature.from.usage.family=Cambiar la firma del método en uso

# {0} - original method signature including name, {1} - method name, {2} - proposed new parameters list
change.method.signature.from.usage.text=''{0}''의 시그니처를 ''{1}({2})''(으)로 변경합니다.
add.parameter.from.usage.text=''{0}''을(를) {1,number,ordinal}번째 {2}(으)로 {3} ''{4}''에 추가
remove.parameter.from.usage.text={2} ''{3}''에서 {0,number,ordinal}번째 {1}을(를) 제거
change.parameter.from.usage.text=\ {2} ''{3}''의 {0,number,ordinal} {1}을(를) ''{4}''에서 ''{5}''(으)로 변경
searching.for.usages.progress.title=사용 위치 검색 중...
create.class.from.new.family=신규에서 클래스 생성
create.class.from.usage.family=Crear clase a partir del uso
create.class.from.usage.text={0} Crea ''{1}''.
create.inner.class.from.usage.text=내부 {0} ''{1}''을(를) 생성합니다.
create.element.in.class=''{2}''에서 {0} ''{1}''(을)를 생성
create.constant.from.usage.family=사용 위치에서 상수 생성
create.constructor.from.new.family=신규에서 생성자 생성
create.constructor.from.new.text=생성자를 생성합니다.
create.constructor.from.super.call.family=super() 호출에서 생성자 생성
create.constructor.from.this.call.family=Crear constructor a partir de la llamada this()
create.constructor.family=Crear constructor
create.constructor.text=Cree un constructor a partir de ''{0}''.
create.constructor.matching.super=Crear constructor coincidente super
super.class.constructors.chooser.title=Elija constructor de superclase
create.field.from.usage.family=Crear campo desde la ubicación de uso
target.class.chooser.title=Seleccionar clase de destino
new.method.body.template.error.text=Edite la plantilla "Nuevo cuerpo del método"
new.method.body.template.error.title=Error de plantilla de archivo
cannot.create.java.file.error.text=No se pudo crear {0}.java desde {1}. {2}
cannot.create.java.file.error.title=No se pudo crear el archivo
cannot.create.java.package.error.text=No se pudo crear {0} desde {1}. {2}
cannot.create.java.package.error.title=No se pudo crear el paquete
create.accessor.for.unused.field.family=Crea un acceso para un campo no utilizado
create.getter.for.field=Crear captador de ''{0}''
create.setter.for.field=Crear setter de ''{0}''
create.getter.and.setter.for.field=''{0}'' crear getter y setter
create.local.from.usage.family=Crear local desde la ubicación de uso
create.local.from.instanceof.usage.family=Cree una variable local a partir del uso de instanceof
create.local.from.instanceof.usage.text=Inserte la declaración ''({0}){1}''.
create.member.from.usage.family=Crear miembro desde la ubicación de uso
create.method.from.usage.family=Crear método a partir del uso
create.method.from.usage.text=Crear método ''{0}''.
create.type.parameter.from.usage.family=Crear parámetro de tipo desde la ubicación de uso
create.type.parameter.from.usage.text=Crear parámetro de tipo ''{0}''.
create.type.parameter.from.usage.chooser.title=Dónde agregar el parámetro de tipo
create.parameter.from.usage.family=Crear parámetro desde la ubicación de uso
create.property.from.usage.family=Crear propiedad desde la ubicación de uso
create.property.from.usage.text=Crear propiedad ''{0}''.
create.property.from.usage.full.text=Crear propiedad ''{0}'' desde ''{1}''.
create.read.only.property.from.usage.text=Crear propiedad de solo lectura ''{0}''.
create.read.only.property.from.usage.full.text=''{1}'' crea la propiedad de solo lectura ''{0}''.
create.write.only.property.from.usage.text=Crear propiedad de solo escritura ''{0}''.
create.write.only.property.from.usage.full.text=''{1}'' crea propiedad de solo escritura ''{0}''.
create.getter=Crear captador
create.setter=Crear setter
create.annotation.family=Agregar anotación a la declaración
create.annotation.text=Agregar @''{0}''
defer.final.assignment.with.temp.family=Usar variable temporal para aplazar la asignación final
defer.final.assignment.with.temp.text=Aplazar la asignación a ''{0}'' mediante la variable temp.
delete.catch.family=Eliminar captura
delete.catch.text=''{0}'' Elimina la captura.
delete.body.text=Eliminar el cuerpo del método.
enable.optimize.imports.on.the.fly='' Configuración | editor | General | Importación automática | Habilitar '' optimización inmediata de declaraciones de importación '
generify.family=Generalizar archivos
generify.text=''{0}''.
implement.methods.fix=implementación del método
import.class.fix=Importar clase
insert.new.fix=Insertar nuevo
insert.super.constructor.call.family=Llamar al constructor predeterminado
insert.super.constructor.call.text=Insertar ''{0}''.
make.class.an.interface.family=Hacer de una clase una interfaz
make.class.an.interface.text=''{0}'' como interfaz.
make.interface.an.class.text=''{0}'' como clase.
make.vararg.parameter.last.family=poner el parámetro vararg al final
make.vararg.parameter.last.text=mueva ''{0}'' al final de la lista.
fix.parameter.type.family=Modificar el tipo de parámetro
fix.parameter.type.text=''{0}'' Hace que tome un parámetro de tipo ''{1}''.
fix.return.type.family=Corregir el tipo de retorno
fix.return.type.or.predecessor.text=make ''{0}'' return ''{1}'' o el valor anterior.
fix.return.type.text=''{0}'' hace que ''{1}'' vuelva.
fix.throws.list.family=Modificar lista de lanzamientos
fix.throws.list.add.exception=Agregar ''{0}'' a la lista de lanzamientos ''{1}''
fix.throws.list.remove.exception=Eliminar ''{0}'' de la lista de lanzamientos ''{1}''
fix.modifiers.family=Modificar modificadores

anonymous.class.presentation={0}에서 파생된 익명 클래스
# {0} owner class name
class.initializer.presentation={0} 클래스 이니셜라이저
add.modifier.fix=''{0}'' 을(를) {1} (으)로 만들기
remove.modifier.fix=''{0}''을(를) {1}이(가) 아니도록 만들기

change.inheritors.visibility.warning.text=상속자의 가시성을 기본 메소드의 가시성으로 변경하시겠어요?
change.inheritors.visibility.warning.title=상속자 변경
move.class.in.extend.list.family=확장 목록에서 클래스 이동
move.bound.class.to.front.fix.text=바운드 ''{0}''을(를) 유형 매개변수 ''{1}''의 바운드 목록의 시작 부분으로 이동합니다.
move.catch.up.family=catch를 위로 이동
move.catch.up.text=''{0}''에 대한 catch를 ''{1}'' 앞으로 이동합니다.
move.class.to.separate.file.family=클래스를 별도의 파일로 이동
move.class.to.separate.file.text=클래스 ''{0}''을(를) ''{0}.java''로 이동합니다.
move.class.to.package.family=클래스를 패키지로 이동
move.class.to.package.text=패키지 ''{0}''(으)로 이동합니다.

# change if (!a == b)...  =>  if (!(a == b))...
negation.broader.scope.family=넓은 범위 부정
negation.broader.scope.text=''\!({0})''(으)로 변경합니다.

optimize.imports.fix=import 문 최적화
remove.qualifier.fix=한정자 제거
remove.unused.element.family=사용하지 않는 {0} 제거
rename.wrong.reference.family=잘못된 참조 이름 변경
rename.wrong.reference.text=참조 이름을 변경합니다.
reuse.variable.declaration.family=변수 선언 재사용
reuse.variable.declaration.text=이전 변수 ''{0}'' 선언을 재사용합니다.
navigate.variable.declaration.family=변수 선언으로 이동
navigate.variable.declaration.text=이전에 선언된 변수 ''{0}''(으)로 이동합니다.
safe.delete.family=안전한 삭제
safe.delete.text=안전한 삭제 ''{0}''
setup.jdk.location.family=JDK 위치 설정
setup.jdk.location.text=JDK를 설정합니다.
side.effects.warning.dialog.title=부작용 발견
simplify.boolean.expression.family=부울 표현식 단순화
simplify.boolean.expression.text=''{0}''을(를) {1}(으)로 단순화합니다.
fix.super.method.return.type.family=상위 메소드 반환 유형 수정
fix.super.method.return.type.text=''{0}''이(가) ''{1}''을(를) 반환하도록 만듭니다.
surround.with.try.catch.fix=try/catch로 둘러싸기

make.final.text={0} 을(를) final로 만듭니다
make.final.copy.to.temp=''{0}'' a {1} variable temporal
make.final.transform.to.one.element.array={0}을(를) を 하나의 final 요소 배열로 변환make.final.family=final 설정
fix.variable.type.family=변수 유형 수정
fix.variable.type.text={0} ''{1}'' 유형을 ''{2}''(으)로 변경합니다.

# Sample: Boolean b = "true"; -> Boolean b = Boolean.valueOf("true");
wrap.expression.using.static.accessor.family=표현식 줄 바꿈
wrap.expression.using.static.accessor.text=''{0}()''을(를) 사용하여 줄 바꿈합니다.

# {0} - qualified class name suggested to be imported.
side.effect.action.remove=Elimina&r
side.effect.action.transform=변환(&T)
side.effect.action.cancel=취소(&C)
side.effect.message1=<html><body>변수 ''{0}''에 대입된 표현식에서 부작용이 발생할 수 있습니다.<br>취할 수 있는 조치는 다음과 같습니다.<ul><li>관련된 모든 표현식과 함께 변수의 사용 위치를 <b>제거</b></li></body></html>
# {0} - variable name, {1} - variable type, {2} - expression with side effect, {3} - same expression transformed to hold the effect

change.parameter.class.family=매개변수 클래스 변경

change.extends.list.family=다음에서 클래스 확장
add.class.to.extends.list=''{0}''이(가) ''{1}''을(를) 확장하도록 설정
remove.class.from.extends.list=''{0}''이(가) ''{1}''을(를) 확장하지 않도록 설정
add.interface.to.implements.list=''{0}''이(가) ''{1}''을(를) 구현하도록 설정
remove.interface.from.implements.list=''{0}''이(가) ''{1}''을(를) 구현하지 않도록 설정
convert.method.to.constructor=메소드 생성자 생성

create.field.text=필드 {0}을(를) 생성합니다.
create.property.text=프로퍼티 {0}을(를) 생성합니다.
add.constructor.parameter.name=생성자 매개변수 추가
remove.suppression.action.name=''{0}'' 억제 제거
remove.suppression.action.family=억제 제거
remove.qualifier.action.text=한정자를 제거합니다
fix.argument.family=인수 수정
change.new.operator.type.text=''{0}''을(를) ''new {1}{2}''(으)로 변경합니다.
change.new.operator.type.family=새 연산자 유형 변경

fix.unused.symbol.injection.family=종속 요소 삽입 어노테이션에 추가
fix.unused.symbol.injection.text=''{0}'' (으)로 어노테이션이 추가된 경우 사용되지 않는 경고 억제
fix.add.special.annotation.family=특수 어노테이션에 추가
fix.add.special.annotation.text=''{0}'' 을(를) 특수 어노테이션 목록에 추가합니다

orderEntry.fix.add.dependency.on.module=모듈 ''{0}''에 종속 요소 추가
orderEntry.fix.add.dependency.on.module.choose=모듈에 종속 요소 추가...
orderEntry.fix.choose.module.to.add.dependency.on=종속 요소를 추가할 모듈 선택
orderEntry.fix.family.add.module.dependency=모듈 종속 요소 추가
orderEntry.fix.add.library.to.classpath=라이브러리 ''{0}''을(를) 클래스 경로에 추가
orderEntry.fix.family.add.library.to.classpath=라이브러리를 클래스 경로에 추가
orderEntry.fix.circular.dependency.warning=모듈 ''{0}''에 종속 요소를 추가하면 모듈 ''{1}'' 및 ''{2}'' 간의 순환 종속 요소가 삽입됩니다.\n\
종속 요소를 추가하시겠어요?
orderEntry.fix.title.circular.dependency.warning=순환 종속 요소 경고
static.import.method.text=static 메소드 가져오기
static.import.method.choose.method.to.import=가져올 메소드 선택
static.import.constant.text=static 상수를 가져옵니다.

add.library.title.dialog=''{0}'' 라이브러리를 프로젝트에 추가
add.library.title.choose.folder=디렉토리 선택
add.library.description.choose.folder=라이브러리를 복사할 디렉토리 선택
add.library.error.not.found=라이브러리 파일 ''{0}''이(가) 없습니다.
add.library.error.cannot.copy=''{0}''을(를) ''{1}''에 복사할 수 없습니다.\n\
({2})
add.library.use.bundled.library.radio.button={1} 배포의 ''{0}'' 사용(&U)
add.library.copy.files.to.radio.button=''{0}'' 라이브러리 파일을 다음에 복사(&C)

permute.arguments=순열 인수
fix.single.character.string.to.char.literal.text={0}을(를) {1}(으)로 변경({2} 리터럴로)합니다.
fix.single.character.string.to.char.literal.family=리터럴 유형 수정

change.to.append.family=StringBuilder 추가 수정
change.to.append.text=''{0}''(으)로 변경합니다.

convert.to.string.family=문자 리터럴 수정
convert.to.string.text=문자열 리터럴로 변환합니다.
convert.to.raw.string.text=원시 문자열 리터럴로 변환합니다.

initialize.final.field.in.constructor.name=생성자에서 초기화
initialize.final.field.in.constructor.choose.dialog.title=초기화를 추가할 생성자 선택

remove.redundant.arguments.text=''{0}''을(를) 호출하려면 중복 인수를 제거합니다.
remove.redundant.arguments.family=중복 인수 제거

replace.with.list.access.text=목록 액세스로 대체합니다.

add.qualifier=한정자 추가
add.qualifier.original.class.chooser.title=원본 클래스

annotations.fix=<html>어노테이션</html>
add.missing.annotation.parameters.fix=누락된 어노테이션 매개변수 {0} 을(를) 추가합니다
add.missing.annotation.single.parameter.fix=누락된 어노테이션 매개변수 ''{0}'' 을(를) 추가합니다

add.method.qualifier.fix.text=한정자 ''{0}'' 을(를) 메소드에 추가합니다
add.method.qualifier.fix.family=메소드 한정자 추가

collection.addall.can.be.replaced.with.constructor.fix.options.title=확인할 클래스
collection.addall.can.be.replaced.with.constructor.fix.description='\#ref()' 호출을 매개변수화된 생성자 호출로 대체할 수 있습니다.
collection.addall.can.be.replaced.with.constructor.fix.family.name='addAll()/putAll()' 호출을 매개변수화된 생성자 호출로 대체
collection.addall.can.be.replaced.with.constructor.fix.name=''{0}()'' 호출을 매개변수화된 생성자 호출로 대체

add.exception.from.field.initializer.to.constructor.throws.text=클래스 {0, choice, 0\#디폴트 생성자|1\#생성자|2\#생성자} 시그니처에 예외를 추가합니다.
add.exception.from.field.initializer.to.constructor.throws.family.text=클래스 생성자 시그니처에 예외를 추가합니다
java.8.map.api.inspection.fix.text=''{0}'' 메소드 호출로 대체합니다.
java.8.map.api.inspection.description=단일 ''Map.{0}'' 메소드 호출로 대체할 수 있습니다.
java.8.map.api.inspection.fix.family.name=단일 Map 메소드 호출로 대체
java.8.collection.removeif.inspection.description=루프를 Collection.removeIf로 대체할 수 있습니다.
java.8.collection.removeif.inspection.fix.name=루프를 Collection.removeIf로 대체
java.8.list.sort.inspection.description=Collections.sort를 List.sort로 대체할 수 있습니다.
java.8.list.sort.inspection.fix.name=List.sort로 대체

wrap.with.optional.parameter.text=''java.util.Optional''을 사용하여 {0, choice, 1\#1번째|2\#2번째|3\#3번째|4\#{0,number}번째} 매개변수를 줄 바꿈합니다.
wrap.with.optional.single.parameter.text='java.util.Optional'을 사용하여 줄 바꿈합니다.

move.file.to.source.root.text=파일을 소스 루트로 이동합니다.
delete.return.fix.family=반환 삭제
delete.return.fix.text=반환 {0}을(를) 삭제합니다.
delete.return.fix.side.effects.text=반환 {0}을(를) 삭제하고 부작용을 추출합니다.

delete.reference.fix.text=참조를 삭제합니다.
delete.unreachable.statement.fix.text=도달할 수 없는 구문 삭제

extract.side.effects.convert.to.if='if' 문으로서 부작용 추출
extract.side.effects={0, choice, 1\#부작용|2\#부작용} 추출
extract.side.effects.family.name=부작용을 추출하는 구문 삭제

module.info.add.directive.family.name=module-info.java에 지시문 추가
module.info.add.requires.name=module-info.java에 ''requires {0}'' 지시문 추가
module.info.add.exports.name=module-info.java에 ''exports {0}'' 지시문 추가
module.info.add.uses.name=module-info.java에 ''uses {0}'' 지시문 추가

collection.to.array.text=변환 ''.toArray({0})'' 적용
collection.to.array.family.name=변환 '.toArray()' 적용

insert.sam.method.call.fix.name=''.{0}''을(를) 삽입하여 함수 인터페이스 메소드 호출
insert.sam.method.call.fix.family.name=단일 추상 메소드 호출 삽입

wrap.with.adapter.call.family.name=어댑터 호출 또는 객체를 사용하여 줄 바꿈
wrap.with.adapter.text=''{0}''을(를) 사용하여 줄 바꿈
wrap.with.adapter.parameter.single.text=''{0}''을(를) 사용하여 매개변수를 줄 바꿈합니다.
wrap.with.adapter.parameter.multiple.text=''{1}''을(를) 사용하여 {0, choice, 1\#1번째|2\#2번째|3\#3번째|4\#{0,number}번째} 매개변수를 줄 바꿈합니다.

java.9.merge.module.statements.fix.family.name=다른 ''{0}'' 지시문과 병합
java.9.merge.module.statements.fix.name=다른 ''{0} {1}'' 지시문과 병합

model.create.constructor.quickfix.message=생성자 ''{0}'' 생성
model.create.constructor.quickfix.message.family.name=생성자 생성

adjust.method.accepting.functional.expression.fix.family.name=함수 표현식을 수락하는 메소드 조정
adjust.method.accepting.functional.expression.fix.text=''{0}()''을(를) ''{1}()''(으)로 대체합니다.

add.compiler.option.fix.name=''{0}''을(를) 모듈 컴파일러 옵션에 추가

create.service.implementation.fix.family.name=서비스 구현 클래스 생성
create.service.implementation.fix.name=클래스 ''{0}'' 생성

create.service.interface.fix.family.name=서비스 생성
create.service.interface.fix.name=서비스 ''{0}'' 생성

convert.variable.to.field.in.anonymous.class.fix.name=''{0}''을(를) 익명 객체로 이동
change.method.parameters.text=메소드 매개변수를 ''{0}''(으)로 변경합니다.
change.method.parameters.family=메소드 매개변수 변경

add.default.branch.to.variable.initializing.switch.fix.name=''{0}''을(를) 초기화하는 ''switch'' 문에 ''default'' 브랜치 추가

insert.empty.parenthesis='()' 삽입
remove.parameter.list=매개변수 목록 제거

convert.primitive.to.boxed.type=기본 유형을 박싱된 유형으로 변환

choose.class.to.move.popup.title=이동할 클래스 선택
move.0.in.1=''{1}''의 ''{0}'' 이동...
move.0.from.module.1.to.2=''{1}'' 모듈에서 ''{2}''(으)로 ''{0}'' 이동

add.0.to.classpath=''{0}''을(를) 클래스 경로에 추가

pull.up=위로 이동

iterate.iterable=Iterar
rename.reference=참조 이름 변경

choose.fields.to.generate.constructor.parameters.for=생성자 매개변수를 생성할 필드 선택
choose.constructors.to.add.parameter.to=매개변수를 추가할 생성자 선택
add.constructor.parameters=생성자 매개변수 추가

add.annotation.attribute.name.family.name=어노테이션 속성 이름 추가
add.annotation.attribute.name=''{0}\='' 추가

replace.with.getter.setter=getter/setter로 교체
replace.with.getter=getter로 교체
replace.with.setter=setter로 교체

wrap.with.block=Envolver con bloque
create.block=Crear bloque

replace.for.each.loop.with.iterator.for.loop=Reemplazar ''for each'' bucle con iterador bucle ''for''

surround.annotation.parameter.value.with.quotes=Incluya los valores de los parámetros de anotación entre comillas
surround.with.array.initialization=Envolvente con inicializador de matriz

create.service.implementation=Crear implementación de servicio
create.service=Crear servicio

choose.default.value.parameters.popup.title=Elija parámetros de valor predeterminado
generate.overloaded.method.or.constructor.with.default.parameter.values=Genera {0} sobrecargado con valores de parámetro predeterminados
generate.overloaded.method.with.default.parameter.values=Genera métodos sobrecargados con valores de parámetros predeterminados

remove.unreachable.branches=Eliminar ramas inalcanzables
set.inspection.option.fix=Establecer opciones de inspección
simplify.boolean.expression.extracting.side.effects=\ Extraer efectos secundarios
