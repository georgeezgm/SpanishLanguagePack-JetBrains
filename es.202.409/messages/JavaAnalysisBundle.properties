add.explicit.type.arguments=명시적 유형 인수 추가

# suppress inspection "UnusedProperty"
annotation.target.ANNOTATION_TYPE=어노테이션 유형
# suppress inspection "UnusedProperty"
annotation.target.CONSTRUCTOR=생성자
# suppress inspection "UnusedProperty"
annotation.target.FIELD=필드
# suppress inspection "UnusedProperty"
annotation.target.LOCAL_VARIABLE=지역 변수
# suppress inspection "UnusedProperty"
annotation.target.METHOD=메소드
# suppress inspection "UnusedProperty"
annotation.target.MODULE=모듈
# suppress inspection "UnusedProperty"
annotation.target.PACKAGE=패키지
# suppress inspection "UnusedProperty"
annotation.target.PARAMETER=매개 변수
# suppress inspection "UnusedProperty"
annotation.target.RECORD_COMPONENT=기록 구성 요소
# suppress inspection "UnusedProperty"
annotation.target.TYPE=유형
# suppress inspection "UnusedProperty"
annotation.target.TYPE_PARAMETER=유형 매개변수
# suppress inspection "UnusedProperty"
annotation.target.TYPE_USE=유형 사용

change.type.arguments=유형 인수 변경
change.type.arguments.to.0=유형 인수를 <{0}>(으)로 변경
convert.0.to.float=''{0}''을(를) float로 변환

dataflow.message.array.index.out.of.bounds=배열 색인이 범위를 벗어났습니다.
dataflow.message.arraystore=유형 <code>{0}</code> 요소를 <code>{1}</code> 요소 배열에 저장하면  <code>ArrayStoreException</code>이 발생합니다
dataflow.message.assigning.null.notannotated=<code>null</code> 값을 어노테이션이 없는 필드에 대입
dataflow.message.assigning.null=@NotNull로 어노테이션이 추가된 변수에 <code>null</code>이 대입됩니다
dataflow.message.assigning.nullable.notannotated=표현식 <code>\#ref</code>이(가) \#loc null일 수 있지만 어노테이션이 없는 필드에 대입됩니다
dataflow.message.assigning.nullable=표현식 <code>\#ref</code>이(가) <code>null</code>로 평가될 수 있지만 @NotNull로 어노테이션이 추가된 변수에 대입됩니다.
dataflow.message.cce.always=<code>{0}</code>을(를) <code>\#ref</code>(으)로 형 변환하면 \#loc null이 아닌 임의의 값에 <code>ClassCastException</code>이 생성됩니다.
dataflow.message.cce=Casting <code>{0}</code> to <code>\#ref</code> \#loc may produce <code>java.lang.ClassCastException</code>
dataflow.message.constant.condition.when.reached=조건 <code>\#ref</code>은(는) \#loc 도달되면 항상 <code>{0, choice, 0\#거짓|1\#참}</code>입니다.
dataflow.message.constant.condition=조건 <code>\#ref</code>은(는) \#loc 항상 <code>{0, choice, 0\#거짓|1\#참}</code>입니다.
dataflow.message.constant.method.reference=메소드 참조 결과는 항상 ''{0}''입니다.
dataflow.message.constant.no.ref=조건은 항상 {0, choice, 0\#거짓|1\#참}입니다.
dataflow.message.contract.fail.index=색인이 범위를 벗어났을 때 '\#ref' 호출이 항상 실패합니다.
dataflow.message.contract.fail=The call to '\#ref' always fails,according to its method contracts
dataflow.message.immutable.modified=불변 객체가 수정됩니다.
dataflow.message.immutable.passed=불변 객체가 가변이 예상되는 곳에 전달됩니다.
dataflow.message.npe.array.access.sure=배열 액세스 <code>\#ref</code>이(가) \#loc <code>NullPointerException</code>을 생성하게 됩니다.
dataflow.message.npe.array.access=Array access <code>\#ref</code> \#loc may produce <code>java.lang.NullPointerException</code>
dataflow.message.npe.field.access.sure=Dereference of <code>\#ref</code> \#loc will produce <code>java.lang.NullPointerException</code>
dataflow.message.npe.field.access=Dereference of <code>\#ref</code> \#loc may produce <code>java.lang.NullPointerException</code>
dataflow.message.npe.inner.class.construction.sure=내부 클래스 구조가 <code>NullPointerException</code>을 생성하게 됩니다.
dataflow.message.npe.inner.class.construction=Inner class construction may produce <code>java.lang.NullPointerException</code>
dataflow.message.npe.method.invocation.sure=메소드 호출 <code>\#ref</code>이(가) \#loc <code>NullPointerException</code>을 생성하게 됩니다.
dataflow.message.npe.method.invocation=Method invocation <code>\#ref</code> \#loc may produce <code>java.lang.NullPointerException</code>
dataflow.message.npe.methodref.invocation=Method reference invocation <code>\#ref</code> \#loc may produce <code>java.lang.NullPointerException</code>
dataflow.message.only.switch.label=switch 라벨 <code>\#ref</code>이(가) \#loc 전체 switch에서 유일하게 도달됩니다.
dataflow.message.passing.null.argument.nonannotated=<code>null</code> 인수를 어노테이션이 없는 필드에 전달
dataflow.message.passing.null.argument=<code>null</code> 인수를 @NotNull로 어노테이션이 추가된 매개변수에 전달
dataflow.message.passing.nullable.argument.methodref.nonannotated=메소드 참조 인수가 null이지만 어노테이션이 없는 매개변수로 전달될 수 있습니다
dataflow.message.passing.nullable.argument.methodref=메소드 참조 인수가 null일 수 있습니다.
dataflow.message.passing.nullable.argument.nonannotated=인수 <code>\#ref</code>이(가) \#loc null일 수 있지만 어노테이션이 없는 매개변수에 전달될 수 있습니다
dataflow.message.passing.nullable.argument=인수 <code>\#ref</code>이(가) \#loc null일 수 있습니다.
dataflow.message.pointless.assignment.expression=대입식의 왼쪽에 있는 조건 <code>\#ref</code>이(가) \#loc 항상 <code>{0}</code>입니다. 이를 단순화할 수 있습니다.
dataflow.message.pointless.same.arguments='\#ref'의 인수가 동일합니다. 따라서 인수가 같은 이 메소드를 호출하는 것은 의미가 없습니다.
dataflow.message.pointless.same.argument.and.result='\#ref'의 결과가 {0,choice,1\#첫 번째|2\#두 번째} 인수와 동일하여 호출이 무의미합니다.
dataflow.message.redundant.assignment=변수가 이미 이 값에 대입되었습니다.
dataflow.message.redundant.instanceof=조건 <code>\#ref</code>은(는) \#loc 중복되며 null 검사로 대체할 수 있습니다.
dataflow.message.redundant.update=변수 업데이트로 수행되는 작업이 없습니다.
dataflow.message.return.notnull.from.nullable=@{0} 메소드 ''{1}'' 이(가) null이 아닌 값을 반환합니다
dataflow.message.return.null.from.notnull=<code>null</code>이 @{0}(으)로 선언된 메소드에서 반환됩니다.
dataflow.message.return.null.from.notnullable=<code>null</code>이 @{0}(으)로 선언되지 않은 메소드에서 반환됩니다.
dataflow.message.return.nullable.from.notnull.function=Function may return null,but it's not allowed here
dataflow.message.return.nullable.from.notnull=표현식 <code>\#ref</code>이(가) <code>null</code>로 평가될 수 있지만 @{0}(으)로 선언된 메소드에서 반환됩니다.
dataflow.message.return.nullable.from.notnullable=표현식 <code>\#ref</code>이(가) <code>null</code>로 평가될 수 있지만 @{0}(으)로 선언되지 않은 메소드에서 반환됩니다.
dataflow.message.storing.array.null=<code>null</code>이 @NotNull 요소의 배열에 저장됩니다.
dataflow.message.storing.array.nullable=표현식 <code>\#ref</code>이(가) null로 평가될 수 있지만 @NotNull 요소의 배열에 저장됩니다.
dataflow.message.unboxing.method.reference=Use of <code>\#ref</code> \#loc would need unboxing which may produce <code>java.lang.NullPointerException</code>
dataflow.message.unboxing=Unboxing of <code>\#ref</code> \#loc may produce <code>java.lang.NullPointerException</code>
dataflow.message.unreachable.switch.label=switch 라벨 <code>\#ref</code>이(가) 도달되지 않습니다.
dataflow.method.fails.with.null.argument=매개변수가 null일 때 메소드가 예외를 던집니다.
dataflow.not.precise={0}이(가) 복잡하여 데이터 흐름 결과가 부정확할 수 있습니다.
dataflow.too.complex=Method <code>\#ref</code> is too complex to analyze by data flow algorithm

delete.repeated.0=반복된 ''{0}'' 삭제
delete.repeated.interface=반복된 인터페이스 삭제
exception.removal.will.break.source.code.proceed.anyway=예외를 제거하면 소스 코드가 중단됩니다. 그래도 계속하시겠어요?

feature.generics=제네릭
feature.annotations=어노테이션
feature.static.imports=static import 문
feature.for.each=For-each 루프
feature.varargs=가변 arity 메소드
feature.hex.fp.literals=16진수 부동소수점 리터럴
feature.diamond.types=Diamond 유형
feature.multi.catch=여러 catch
feature.try.with.resources=Try-with-resources
feature.binary.literals=2진 리터럴
feature.underscores.in.literals=리터럴의 밑줄
feature.extension.methods=확장 메소드
feature.method.references=메소드 참조
feature.lambda.expressions=람다 식
feature.type.annotations=유형 어노테이션
feature.type.receivers=리시버 매개변수
feature.intersections.in.casts=형 변환 내 교차 유형
feature.static.interface.calls=Static 인터페이스 메소드 호출
feature.try.with.resources.refs=리소스 참조
feature.modules=모듈
feature.lvti=지역 변수 유형 추론
feature.var.lambda.parameter=람다 매개변수 내 'var'
feature.text.blocks=텍스트 블록 리터럴
feature.text.block.escape.sequences='\\s' 및 '\' 이스케이프 시퀀스
feature.enhanced.switch=향상된 'switch' 블록
feature.switch.expressions='switch' 식
feature.records=기록
feature.patterns.instanceof='instanceof' 내 패턴
feature.sealed.classes=봉인된 클래스
feature.local.interfaces=로컬 인터페이스
feature.local.enums=로컬 열거형

find.searching.for.references.to.class.progress=클래스 {0}에 대한 참조 검색 중...
find.usages.panel.title.derived.classes=파생 클래스
find.usages.panel.title.derived.interfaces=파생 인터페이스
find.usages.panel.title.implementing.classes=클래스 구현
find.usages.panel.title.implementing.methods=메소드 구현
find.usages.panel.title.overloaded.methods.usages=오버로드된 메소드 사용 위치
find.usages.panel.title.overriding.methods=메소드 재정의
message.class.inaccessible.from.module=모듈 ''{1}'' 에서 클래스 ''{0}'' 에 액세스할 수 없습니다
message.class.inaccessible=\ ''{0}'' 에 액세스할 수 없습니다

inspection.i18n.quickfix.annotate=어노테이션 처리...
inspection.i18n.quickfix.annotate.as=@{0}(으)로 어노테이션 추가
inspection.i18n.quickfix.annotate.element={0} ''{1}''에 어노테이션 추가...
inspection.i18n.quickfix.annotate.element.as={0} ''{1}''을(를) @{2}(으)로 어노테이션 추가
inspection.reference.default.package=<디폴트 값>
error.message.invalid.java.type=유효하지 않은 Java 유형
move.0.to.the.beginning=''{0}''을(를) 처음으로 이동
move.to.front=앞으로 이동
processing.method.usages=메소드 사용 위치 처리 중...
qualify.0={0} 정규화
qualify.with.0.this={0}.this로 정규화
remove.annotation=어노테이션 제거
remove.left.side.of.assignment=왼쪽 대입 제거
replace.get.class.with.class.literal=getClass()를 .class 리터럴로 교체
service.provides=서비스 <a href\="\#javaClass/{0}">{0}</a> 제공<br><div style\=''margin-top\: 5px''><font size\=''2''>클릭하여 탐색</font></div>
service.uses=사용 서비스 <a href\="\#javaClass/{0}">{0}</a><br><div style\=''margin-top\: 5px''><font size\=''2''>클릭하여 탐색</font></div>
suppress.for.parameter=매개변수 억제
suppress.for.statement.with.comment=주석이 있는 구문 억제
intention.add.annotation.family=어노테이션 추가
intention.text.remove.annotation=Eliminar

scope.package=패키지 {0}

0.field.is.always.initialized.not.null=@{0} 필드는 항상 null이 아닌 상태로 초기화됩니다.
access.can.be.0=액세스가 {0}일 수 있음
access.to.field.code.ref.code.outside.of.declared.guards.loc=선언된 가드의 외부에서 필드 <code>\#ref</code>에 대한 액세스 \#loc
call.to.method.code.ref.code.outside.of.declared.guards.loc=선언된 가드 외부에서 메소드 <code>\#ref()</code> 호출 \#loc
annotate.as.safevarargs=@SafeVarargs으로 어노테이션 추가
annotate.overridden.methods.parameters.family.name=재정의된 메소드 매개변수에 추가
annotate.overridden.methods.parameters=재정의된 메소드 매개변수에 ''@{0}''9으)로 어노테이션 추가
anonymous.ref.loc.can.be.replaced.with.0=익명의 \#ref을(를) \#loc {0}(으)로 교체할 수 있습니다.
anonymous.ref.loc.can.be.replaced.with.lambda=익명의 \#ref을(를) \#loc 람다로 교체할 수 있습니다.
assigning.a.collection.of.nullable.elements=null이 아닌 요소의 컬렉션에 null 가능한 요소 컬렉션을 대입
nullable.stuff.error.overriding.nullable.with.notnull=null이 될 수 있는 요소 컬렉션을 null이 아닌 요소의 컬렉션으로 재정의
nullable.stuff.error.overriding.notnull.with.nullable=null이 아닌 요소 컬렉션을 null이 될 수 있는 요소 컬렉션으로 재정의
comparision.between.object.and.primitive=객체와 기본 요소 간의 비교는 불법이며 Java 7에서만 허용됩니다.
custom.exception.class.should.have.a.constructor=사용자 지정 예외 클래스에는 문자열 유형의 단일 메시지 매개변수를 가진 생성자가 있어야 합니다.
delimiters.argument.contains.duplicated.characters=구분자 인수에 중복된 문자가 포함되어 있습니다.
deprecated.class.usage.group.xml=XML
deprecated.member.0.is.still.used=더 이상 사용되지 않는 멤버 ''{0}''이(가) 여전히 사용되고 있습니다.
detach.library.quickfix.name=라이브러리 연결 해제
detach.library.roots.quickfix.name=사용하지 않는 라이브러리 루트 연결 해제
don.t.report.unused.jars.inside.used.library=사용된 라이브러리 내부에서 사용되지 않은 Jar를 보고 안 함
explicit.type.argument.ref.loc.can.be.replaced.with=명시적 유형 인수 \#ref을(를) \#loc <>로 교체할 수 있습니다.
exports.to.itself.delete.module.ref.fix=모듈 ''{0}''에 대한 참조를 삭제합니다.
exports.to.itself.delete.statement.fix=지시문을 삭제합니다.
html.classes.exposed.with.code.module.info.code.html=<html><code>module-info</code>로 노출된 클래스</html>
html.ignore.overrides.of.deprecated.abstract.methods=<html>사용 중단되지 않은 상위 항목에서 더 이상 사용되지 않는 추상 메소드의 재정의 무시</html>
ignore.casts.in.suspicious.collections.method.calls=의심스러운 컬렉션 메소드 호출에서의 형 변환 무시
ignore.exceptions.thrown.by.entry.points.methods=진입점 메소드에서 던진 예외 무시
ignore.in.the.same.outermost.class=동일한 가장 바깥쪽 클래스에서 무시
ignore.inside.deprecated.members=더 이상 사용되지 않는 멤버 내에서 무시
ignore.inside.non.static.imports=비정적 import 문 내에서 무시
ignore.members.of.deprecated.classes=더 이상 사용되지 않는 클래스의 멤버 무시
ignore.operation.which.results.in.negative.value=음수값이 도출되는 '<<' 연산 무시
inspection.annotate.method.quickfix.family.name=어노테이션 추가된 메소드
inspection.annotate.overridden.method.and.self.quickfix.family.name=재정의된 메소드 및 자신에게 어노테이션 추가
inspection.annotate.overridden.method.quickfix.family.name=재정의된 메소드에 어노테이션 추가
inspection.c.style.array.declarations.option=변수에서 C 스타일 선언 무시
inspection.can.be.final.accept.quickfix=final로 만듭니다.
inspection.can.be.final.option1=메소드 보고
inspection.can.be.final.option2=필드 보고
inspection.can.be.final.option=클래스 보고
inspection.can.be.local.parameter.problem.descriptor=매개변수 <code>\#ref</code>은(는) <code>final</code> 제어자를 가질 수 있습니다.
inspection.can.be.local.variable.problem.descriptor=변수 <code>\#ref</code>은(는) <code>final</code> 제어자를 가질 수 있습니다.
inspection.can.be.replaced.with.message=''{0}''(으)로 대체할 수 있습니다.
inspection.class.getclass.display.name=Class.getClass() 호출
inspection.class.getclass.fix.remove.name='getClass()' 호출 제거
inspection.class.getclass.fix.replace.name='Class.class'로 교체합니다.
inspection.class.getclass.message='getClass()'가 클래스 인스턴스에서 호출됩니다.
inspection.class.has.no.to.string.method.description=클래스 ''{0}''은(는) ''toString()'' 메소드를 재정의하지 않습니다.
inspection.class.has.no.to.string.method.exclude.classes.reg.exp.option=클래스 제외(정규식)\:
inspection.class.has.no.to.string.method.ignore.abstract.classes.option=추상 클래스 무시
inspection.class.has.no.to.string.method.ignore.deprecated.classes.option=더 이상 사용되지 않는 클래스 무시
inspection.class.has.no.to.string.method.ignore.enum.classes.option=열거형 클래스 무시
inspection.class.has.no.to.string.method.ignore.exception.classes.option=예외 클래스 무시
inspection.class.has.no.to.string.method.ignore.inner.classes.option=내부 클래스 무시
inspection.class.has.no.to.string.method.ignore.test.classes.option=테스트 클래스 무시
inspection.common.if.parts.disable.highlight.tail.call=꼬리 구문이 호출되는 경우 공통 부분을 강조 표시하지 않습니다.
inspection.common.if.parts.family.else.if.description='else if'를 병합할 수 있습니다.
inspection.common.if.parts.family.else.if='else if' 문 병합
inspection.common.if.parts.family='if' 문의 공통 부분 추출
inspection.common.if.parts.settings.highlight.when.tail.call=마지막 공통 구문이 호출될 때 강조 표시합니다.
inspection.compiler.javac.quirks.anno.array.comma.fix=후행 쉼표를 제거합니다.
inspection.compiler.javac.quirks.anno.array.comma.problem=어노테이션 배열 이니셜라이저의 후행 쉼표로 인해 일부 Javac 버전(예\: JDK 5 및 JDK 6)에서 컴파일 오류가 발생할 수 있습니다.
inspection.compiler.javac.quirks.name=Javac 문제
inspection.compiler.javac.quirks.qualifier.type.args.fix=제네릭 매개변수를 제거합니다.
inspection.compiler.javac.quirks.qualifier.type.args.problem=한정자 참조의 제네릭으로 인해 일부 Javac 버전(예\: JDK 5 및 JDK 6)에서 컴파일 오류가 발생할 수 있습니다.
inspection.constant.on.wrong.side.of.a.comparison.side.option=비교 시 상수가 있어야 할 위치\:
inspection.contract.display.name=계약 문제
inspection.data.flow.redundant.instanceof.quickfix=null 검사로 교체합니다.
inspection.data.flow.simplify.boolean.expression.quickfix=부울 표현식 단순화
inspection.data.flow.simplify.to.assignment.quickfix.name=일반 대입으로 단순화
inspection.data.flow.turn.off.constant.references.quickfix=상수로 보장되는 값은 보고하지 않습니다.
inspection.data.flow.turn.off.nullable.returning.notnull.quickfix=null이 아닌 값을 항상 반환하는 null 가능한 메소드를 보고하지 않습니다.
inspection.data.flow.turn.off.true.asserts.quickfix=항상 true인 어설션을 보고하지 않습니다.
inspection.duplicate.throws.display.name=중복 던지기
inspection.duplicate.throws.ignore.subclassing.option=다른 클래스를 하위 분류하는 예외 무시
inspection.duplicate.throws.more.general.problem=There is a more general exception,''{0}'',in the throws list already.
inspection.duplicate.throws.problem=중복으로 던집니다.
inspection.equals.hashcode.only.one.defined.problem.descriptor=클래스에 {0}이(가) 정의되어 있지만 클래스가 {1}을(를) 정의하지 않습니다.
inspection.export.results.can.be.final.description=선언은 최종 제어자를 가질 수 있습니다
inspection.field.not.used.in.to.string.description2=필드 ''{0}''은(는) ''toString()'' 메소드에서 사용되지 않습니다.
inspection.field.not.used.in.to.string.description=메소드 ''{0}''은(는) ''toString()'' 메소드에서 사용되지 않습니다.
inspection.implicit.subclass.display.forClass=클래스 ''{0}''은(는) 묵시적으로 하위 클래스가 될 수 있으며 final이 아니어야 합니다.
inspection.implicit.subclass.display.name=런타임에 final 선언을 재정의할 수 없습니다.
inspection.implicit.subclass.extendable=''{0}''을(를) 재정의 가능하도록 만듭니다.
inspection.implicit.subclass.make.class.extendable=클래스 ''{0}'' {1, choice, 0\#|1\# 및 메소드 {2}을(를) |1<및 메소드가 필요한 {1}을(를)} 확장 가능하도록 만듭니다.
inspection.infinite.loop.option=Thread.run에 배치될 경우 무시
inspection.java.module.naming.terminal.digits=모듈 이름 구성 요소 ''{0}''은(는) 터미널 숫자를 피해야 합니다.
inspection.java.module.naming=Java 모듈 이름 지정 규칙
inspection.local.can.be.final.display.name=지역 변수 또는 매개변수는 final이 될 수 있음
inspection.local.can.be.final.option1=메소드 매개변수 보고
inspection.local.can.be.final.option2=catch 매개변수 보고
inspection.local.can.be.final.option3=foreach 매개변수 보고
inspection.local.can.be.final.option4=묵시적 최종 변수 보고
inspection.local.can.be.final.option=지역 변수 보고
inspection.module.exports.package.to.itself=모듈에서 패키지를 자신에게 내보내거나 자신에서 엽니다.
inspection.nullable.problems.NotNull.parameter.overrides.Nullable=@{0} (으)로 어노테이션이 추가된 매개변수가 @{1} 매개변수를 재정의하면 안 됩니다
inspection.nullable.problems.NotNull.parameter.overrides.not.annotated=@{0} (으)로 어노테이션이 추가된 매개변수가 어노테이션이 없는 매개변수를 재정의하면 안 됩니다
inspection.nullable.problems.NotNull.parameter.receives.null.literal=@{0} (으)로 어노테이션이 추가된 매개변수가 ''null''을 인수로 받으면 안 됩니다
inspection.nullable.problems.Nullable.NotNull.conflict=@{0} 및 @{1} 둘 다에 어노테이션을 추가할 수 없습니다.
inspection.nullable.problems.Nullable.method.overrides.NotNull=@{0} (으)로 어노테이션이 추가된 메소드가 @{1} 메소드를 재정의하면 안 됩니다
inspection.nullable.problems.annotated.field.constructor.parameter.not.annotated=@{0} 필드에 대한 생성자 매개변수가 @{0} 자신으로 어노테이션이 추가될 수 있습니다
inspection.nullable.problems.annotated.field.getter.conflict=@{0} 필드에 대한 getter에 @{1} (으)로 어노테이션이 추가되었습니다
inspection.nullable.problems.annotated.field.getter.not.annotated=@{0} 필드에 대한 getter가 @{0} 자신으로 어노테이션이 추가될 수 있습니다
inspection.nullable.problems.annotated.field.setter.parameter.conflict=@{0} 필드에 대한 setter 매개변수에 @{1} (으)로 어노테이션이 추가되었습니다
inspection.nullable.problems.annotated.field.setter.parameter.not.annotated=@{0} 필드에 대한 setter 매개변수가 @{0} 자신으로 어노테이션이 추가될 수 있습니다
inspection.nullable.problems.method.overrides.NotNull=어노테이션이 없는 메소드가 @{0} (으)로 어노테이션이 추가된 메소드를 재정의합니다
inspection.nullable.problems.parameter.overrides.NotNull=어노테이션이 없는 매개변수가 @{0} 매개변수를 재정의합니다
inspection.nullable.problems.primitive.type.annotation=기본 유형 멤버에는 어노테이션을 추가할 수 없습니다
inspection.objects.equals.can.be.simplified.display.name=objects.equals()를 equals() 으로 교체할 수 있습니다.
inspection.redundant.cast.problem.descriptor={0}에서 {1}(으)로의 형 변환은 중복됩니다.
inspection.redundant.cast.remove.quickfix=중복 형 변환 제거
inspection.redundant.field.initialization.option=null로 초기화하는 경우에만 경고
inspection.redundant.requires.statement.description=중복 지시문 ''requires {0}''
inspection.redundant.requires.statement.fix.family=중복 'requires' 지시문 삭제
inspection.redundant.requires.statement.fix.name=지시문 ''requires {0}'' 삭제
inspection.redundant.throws.problem.descriptor1=The declared exception {0} is never thrown in this method,nor in its derivables
inspection.redundant.throws.problem.descriptor2=선언된 예외 {0}이(가) 전혀 던져지지 않습니다.
inspection.redundant.throws.problem.descriptor=선언된 예외 {0}이(가) 메소드 구현에서 전혀 던져지지 않습니다.
inspection.redundant.throws.remove.quickfix=Remove unnecessary throws declarations
inspection.redundant.type.display.name=중복 유형 인수
inspection.redundant.type.no.generics.method.reference.problem.descriptor=유형 인수는 비 제네릭 메소드 참조에 대해 중복됩니다.
inspection.redundant.type.no.generics.problem.descriptor=유형 인수는 비 제네릭 메소드 호출에 대해 중복됩니다.
inspection.redundant.type.problem.descriptor=명시적 유형 인수를 추론할 수 있습니다.
inspection.redundant.type.remove.quickfix=유형 인수 제거
inspection.reference.anonymous.name=익명({0})
inspection.reference.implicit.constructor.name={0}의 묵시적 생성자
inspection.reference.jsp.holder.method.anonymous.name=<% 페이지 콘텐츠 %>
inspection.requires.auto.module.message=자동 모듈에 대한 'requires' 지시문
inspection.requires.auto.module.option=이행적 종속 요소만 강조 표시
inspection.requires.auto.module.transitive=자동 모듈에 대한 'requires transitive' 지시문
inspection.requires.auto.module=자동 모듈의 종속 요소
inspection.same.return.value.display.name=메소드가 동일한 값을 반환
inspection.same.return.value.problem.descriptor1=메소드 및 모든 파생 항목이 항상 {0}을(를) 반환합니다.
inspection.same.return.value.problem.descriptor2=이 메소드의 모든 구현이 항상 {0}을(를) 반환합니다.
inspection.same.return.value.problem.descriptor=메소드가 {0}을(를) 항상 반환합니다.
inspection.surround.requirenonnull.quickfix=''Objects.requireNonNull({0})''로 교체합니다.
inspection.suspicious.array.method.call.display.name=의심스러운 배열 메소드 호출
inspection.suspicious.array.method.call.problem.arrays=배열 유형은 호환되지 않습니다. 배열은 항상 다릅니다.
inspection.suspicious.array.method.call.problem.element=요소 유형이 배열 유형과 호환되지 않습니다.
inspection.suspicious.collections.method.calls.display.name=의심스러운 컬렉션 메소드 호출
inspection.suspicious.collections.method.calls.problem.descriptor1=의심스러운 ''{0}'' 호출입니다.
inspection.suspicious.collections.method.calls.problem.descriptor=''{0}''에 유형 ''{1}''의 {2}이(가) 포함되지 않을 수 있습니다.
inspection.suspicious.getter.setter.field.option=필드가 일치하는 getter/setter 이름이 있는 경우에만 경고
inspection.suspicious.integer.div.assignment.option=의심스럽지만 정확한 나누기 보고
inspection.test.only.problems.display.name=프로덕션 코드의 테스트 전용 클래스 또는 메소드 호출
inspection.test.only.problems.test.only.class.reference=테스트 전용 클래스가 프로덕션 코드에서 참조됩니다.
inspection.test.only.problems.test.only.field.reference=테스트 전용 필드가 프로덕션 코드에서 참조됩니다.
inspection.test.only.problems.test.only.method.call=테스트 전용 메소드가 프로덕션 코드에서 호출됩니다.
inspection.unary.plus.unary.binary.option=혼란스러운 이진식 또는 단항식 컨텍스트에서만 보고
inspection.unnecessary.super.qualifier.option=명확성 'super' 한정자 무시
inspection.use.compare.method.fix.family.name=단일 비교 메소드로 교체
inspection.visibility.accept.quickfix=제안된 액세스 수준을 수락합니다.
inspection.visibility.compose.suggestion={0}일 수 있습니다.
inspection.visibility.option.constants=상수에 대해 약한 가시성 제안
inspection.visibility.option.package.private.members=클래스 멤버에 대해 package-private 가시성 수준 제안
inspection.visibility.package.private.top.level.classes=최상위 클래스에 대해 package-private 가시성 수준 제안
inspection.visibility.private.inner.members=<html>외부 클래스로부터 참조되는 경우에만 내부 클래스 멤버에 대해 private 제안</html>
instance.member.guarded.by.static.0.loc=static "{0}"(으)로 보호되는 인스턴스 멤버 \#loc
instance.member.guarded.by.static.ref.loc=static으로 보호되는 인스턴스 멤버 \#ref \#loc
junit.rule.classrule.option=@ClassRule 문제 보고
junit.rule.rule.option=@Rule 문제 보고
make.0.default.annotation="{0}" 을(를) 디폴트 어노테이션으로 만들기
make.default.the.last.case.family.name='default'를 마지막 case로 만들기
make.final.and.annotate.as.safevarargs=final을 만들고 @SafeVarargs로 어노테이션 추가
method.reference.mapped.to.comparator=비교자 인터페이스에 맵핑된 메소드 참조가 비교자 계약을 이행하지 않습니다.
module.0.with.language.level.1.depends.on.module.2.with.language.level.3=언어 수준이 {1}인 모듈 {0}이(가) 언어 수준이 {3}인 모듈 {2}에 따라 달라집니다.
non.final.field.code.ref.code.in.immutable.class.loc=@Immutable 클래스의 최종이 아닌 필드 <code>\#ref</code> \#loc
non.final.guarded.by.field.0.loc=최종이 아닌 @GuardedBy 필드 "{0}" \#loc
non.final.guarded.by.field.ref.loc=최종이 아닌 @GuardedBy 필드 \#ref \#loc
non.null.type.argument.is.expected=null이 아닌 유형 인수가 예상됩니다.
not.annotated.method.is.used.as.an.override.for.a.method.annotated.with.0=어노테이션이 없는 메소드가 {0}(으)로 어노테이션이 추가된 메소드의 재정의로 사용됩니다
nullable.stuff.problems.overridden.method.parameters.are.not.annotated=재정의된 메소드 매개변수에 어노테이션이 추가되지 않았습니다
nullable.stuff.problems.overridden.methods.are.not.annotated=재정의된 메소드에 어노테이션이 추가되지 않았습니다
parameter.can.be.null=매개변수가 null일 수 있습니다.
parameter.is.always.not.null=매개변수가 항상 null이 아닙니다.
possible.heap.pollution.from.parameterized.vararg.type.loc=매개변수화된 vararg 유형의 잠재적 힙 오염 \#loc
redundant.block.marker=중복 블록 마커
remove.block.marker.comments=블록 마커 주석 제거
remove.dependency=종속 요소 제거
remove.switch.branch.0=switch 브랜치 ''{0}'' 제거
remove.switch.label.0=switch 라벨 ''{0}'' 제거
remove.switch.label=switch 라벨 제거
replace.0.with=''''{0}''''을(를) ''''\=''''로 교체
replace.anonymous.class.with.lambda.alternative=익명 클래스를 대체 람다로 교체
replace.operator.assignment.with.assignment=연산자 대입을 대입으로 교체
replace.stringtokenizer.delimiters.parameter.with.unique.symbols=StringTokenizer 구분 기호 매개변수를 고유 심볼로 교체
replace.var.with.explicit.type='var'을 명시적 유형으로 교체
replace.with.0={0}(으)로 교체
replace.with.comparator=비교자로 교체
replace.with.constant.value=상수값으로 대체
replace.with.expression.lambda=람다 표현식으로 교체
replace.with.lambda=람다로 교체
report.suspicious.but.possibly.correct.method.calls=의심스럽지만 정확할 수 있는 메소드 호출 보고(&R)
report.when.interface.is.not.annotated.with.functional.interface=인터페이스가 @FunctionalInterface로 어노테이션이 추가되지 않은 경우 보고
searching.for.overriding.methods=재정의 메소드 검색
statement.lambda.can.be.replaced.with.expression.lambda=람다 구문은 람다 표현식으로 교체할 수 있습니다
static.inheritrance.fix.replace.progress={0}의 사용 위치 교체 중
static.member.guarded.by.instance.0.loc=인스턴스 "{0}"(으)로 보호되는 static 멤버 \#loc
static.member.guarded.by.instance.ref.loc=인스턴스로 보호되는 static 멤버 \#ref \#loc
suppress.all.for.class=클래스에 대한 모든 검사 억제
suppress.inspection.class=클래스 억제
suppress.inspection.field=필드 억제
suppress.inspection.member=멤버 억제
suppress.inspection.method=메소드 억제
suppress.inspection.module=모듈 선언 억제
suspected.module.dependency.problem.descriptor=모듈 ''{0}''은(는) 모듈 ''{1}''에 의존하지 않습니다. 그러나 ''{1}''은(는) 범위 ''{2}''에 필요한 내보낸 종속 요소에 대해 검사되지 않았습니다.
unknown.guardedby.reference.0.loc=알 수 없는 @GuardedBy 참조 "{0}" \#loc
unknown.guardedby.reference.ref.loc=알 수 없는 @GuardedBy 참조 \#ref \#loc
unnecessary.module.dependency.display.name=불필요한 모듈 종속 요소
unnecessary.module.dependency.problem.descriptor=모듈 ''{0}'' 소스가 모듈 ''{1}'' 소스에 의존하지 않습니다.
unused.import.display.name=사용하지 않은 import
unused.import.statement=사용되지 않는 import 문
unused.library.display.name=사용되지 않는 라이브러리
unused.library.problem.descriptor=사용되지 않는 라이브러리 ''{0}''
unused.library.roots.problem.descriptor=라이브러리 ''{1}''에서 사용되지 않는 루트 {0}
var.can.be.replaced.with.explicit.type='var'을 명시적 유형으로 교체할 수 있습니다.
vararg.method.call.with.50.poly.arguments=50개가 넘는 여러 인수를 가진 vararg 메소드 호출로 인해 컴파일 및 분석 속도가 느려질 수 있습니다.
visible.for.testing.makes.little.sense.on.test.only.code=@VisibleForTesting은 @TestOnly 코드에서 의미가 거의 없습니다.
inspection.inconsistent.language.level.display.name=일관되지 않는 언어 레벨 설정
inspection.weaker.access.display.name=선언 액세스가 더 약할 수 있습니다
inspection.can.be.final.display.name=선언은 최종 제어자를 가질 수 있습니다
inspection.redundant.throws.display.name=Redundant throws clause
inspection.java.9.redundant.requires.statement.display.name=module-info 내 불필요한 'requires' 명령문
inspection.numeric.overflow.display.name=숫자 오버플로
inspection.redundant.cast.display.name=불필요한 유형 변환
inspection.deprecated.is.still.used.display.name=더 이상 사용되지 않는 멤버가 아직도 사용됩니다
inspection.deprecated.class.usage.inspection.display.name=XML 내 더 이상 사용되지 않는 API 사용
inspection.field.access.not.guarded.display.name=보호되지 않는 필드 액세스 또는 메소드 호출
inspection.instance.guarded.by.static.display.name=static 필드로 보호되는 인스턴스 멤버
inspection.non.final.field.in.immutable.display.name=@Immutable 클래스 내 final이 아닌 필드
inspection.non.final.guard.display.name=final이 아닌 @GuardedBy 필드
inspection.static.guarded.by.instance.display.name=인스턴스 필드 또는 this로 보호되는 static 멤버
inspection.unknown.guard.display.name=알 수 없는 @GuardedBy 필드
inspection.use.compare.method.display.name='compare()' 메소드가 숫자를 비교는 데 사용될 수 있습니다
inspection.convert.2.diamond.display.name=명시적 유형을 <>으로 교체할 수 있습니다
inspection.convert.2.lambda.display.name=익명 유형을 람다로 교체할 수 있습니다
inspection.invalid.comparator.method.reference.display.name=Comparator에 사용된 유효하지 않은 메소드 참조
inspection.safe.varargs.detector.display.name=매개변수화된 vararg 유형의 잠재적 힙 오염
inspection.block.marker.comments.display.name=블록 마커 주석
inspection.string.tokenizer.delimiter.display.name=java.util.StringTokenizer 내 구분자 중복
inspection.anonymous.has.lambda.alternative.display.name=익명 유형에 더 짧은 람다 대체 항목이 있습니다
inspection.java.8.list.sort.display.name=Collections.sort()가 List.sort()로 교체할 수 있습니다
inspection.class.has.no.to.string.method.display.name=클래스가 'toString()' 메소드를 재정의하지 않습니다
inspection.field.not.used.in.to.string.display.name='toString()' 메소드에서 필드가 사용되지 않았습니다
inspection.contract.checker.clause.syntax=컨트렉스 절은 arg1,..., argN 양식이어야 합니다 -> return-value
inspection.contract.checker.unknown.return.value=반환 값이 다음 중 하나여야 합니다\: {0}. 발견\: {1}
inspection.contract.checker.unknown.constraint=제약이 다음 중 하나여야 합니다\: {0}. 발견\: {1}
inspection.contract.checker.empty.constraint=제약이 비어 있으면 안 됩니다
inspection.contract.checker.unreachable.contract.clause=컨트렉트 절 ''{0}'' 에 도달할 수 없습니다\: 이전 컨트렉스가 모든 가능한 절을 포함합니다
inspection.contract.checker.contract.clause.never.satisfied=컨트렉트 절 ''{0}'' 은 조건이 이전 컨트렉트에 포함되므로 충족되지 않습니다
inspection.contract.checker.pure.method.mutation.contract=순수 메소드가 변이 컨트랙트를 가질 수 없습니다
inspection.contract.checker.parameter.count.mismatch=컨트랙트 절 ''{1}'' 이 {2} 을(를) 요구하지만, 메소드가 {0} 매개변수를 받습니다
inspection.contract.checker.primitive.parameter.nullability=매개변수 ''{0}'' 의 기본 유형이 ''{1}'' 이므로 ''{2}'' 을(를) 적용할 수 없습니다
inspection.contract.checker.inferred.notnull.parameter.null=매개변수 ''{0}'' 이(가) null이 아닌 값으로 추론되므로 ''null''을 적용할 수 없습니다
inspection.contract.checker.notnull.parameter.null=매개변수 ''{0}'' 이(가) null이 아닌 값으로 어노테이션 지정되었으므로 ''null''을 적용할 수 없습니다
inspection.contract.checker.inferred.notnull.parameter.notnull=매개변수 ''{0}'' 이(가) null이 아닌 값으로 추론되므로, ''\!null''이 항상 충족됩니다
inspection.contract.checker.notnull.parameter.notnull=매개변수 ''{0}'' 이(가) null이 아닌 값으로 어노테이션 지정되었으므로, ''\!null''이 항상 충족됩니다
inspection.contract.checker.boolean.condition.for.nonboolean.parameter=매개변수 ''{0}'' 의 유형이 ''{1}'' 입니다(boolean 필요)
inspection.contract.checker.contract.violated=컨트랙트 절 ''{0}'' 이(가) 위반되었습니다
inspection.contract.checker.no.exception.thrown=컨트랙트 절 ''{0}'' 이(가) 위반되었습니다\: 예외가 던져지지 않았습니다
inspection.contract.checker.method.always.fails.trivial=메소드가 항상 실패하므로 절 ''{0}'' 의 반환 값을 ''fail''로 교체할 수 있습니다
inspection.contract.checker.method.always.fails.nontrivial=이 경우 메소드가 항상 실패하므로 절 ''{0}'' 의 반환 값을 ''fail''로 교체할 수 있습니다
contract.return.validator.not.applicable.for.constructor=생성자에 적용할 수 없습니다
contract.return.validator.not.applicable.static=static 메소드에 적용할 수 없습니다
contract.return.validator.not.applicable.primitive=기본 반환 유형 ''{0}'' 에 적용할 수 없습니다
contract.return.validator.return.type.must.be.boolean=메소드 반환 유형이 'boolean'이어야 합니다
contract.return.validator.method.return.incompatible.with.method.containing.class=메소드 반환 유형이 클래스를 포함하는 메소드와 호환되어야 합니다
contract.return.validator.too.few.parameters={0, choice, 0\#매개변수가 없는|1\#매개변수가 하나인|2\#매개변수가 {0} 개인} 메소드에 적용할 수 없습니다
contract.return.validator.incompatible.return.parameter.type=반환 유형 ''{0}'' 이(가) 매개변수 유형 ''{1}'' 에서 변환 가능한 유형이어야 합니다
contract.return.value.validation.prefix=컨트랙트 반환 값 ''{0}''\:
suspicious.invocation.handler.implementation.display.name=의심스러운 InvocationHandler 구현
suspicious.invocation.handler.implementation.method.unused.message='invoke'에는 메소드가 사용되지 않습니다. 'hashCode', 'equals'및 'toString'이 올바르게 구현되지 않을 수 있습니다.
suspicious.invocation.handler.implementation.type.mismatch.message=메소드 ''{0}()''을(를) 프록시화하면 호환되지 않는 유형이 반환될 수 있습니다. 필요 항목\: {1}, 얻은 항목\: {2}
suspicious.invocation.handler.implementation.null.returned.for.toString.message=메소드 'toString()'을 프록시화하는 경우 null이 반환될 수 있습니다. 이는 권장되지 않습니다.
suspicious.invocation.handler.implementation.null.returned.message=메소드 ''{0}()''을(를) 프록시화하는 경우 null이 반환될 수 있습니다. 그렇게 되면 NullPointerException이 발생할 수 있습니다.
