found.space=발견된 항목\: 
html.0.has.no.corresponding.expected.declaration.1.html={0}에 해당하는 필요한 선언이 없습니다{1}
html.0.is.not.abstract.and.does.not.implement.abstract.base.class.member.br.1.html={0}은(는) 추상이 아니며 추상 기본 클래스 멤버를 구현하지 않습니다<br/>{1}
html.0.is.not.abstract.and.does.not.implement.abstract.member.br.1.html={0}은(는) 추상이 아니며 추상 멤버를 구현하지 않습니다<br/>{1}
html.0.method.may.be.missing.none.of.the.following.functions.will.be.called.ul.1.ul.html=''{0}'' 메소드가 없는 것 같습니다. 다음 함수가 모두 호출되지 않습니다. <ul>{1}</ul>
html.candidate.resolution.will.be.changed.please.invoke.explicitly.ul.0.ul.html=Candidate resolution will be changed, please invoke explicitly\: <ul>{0}</ul>
html.expected.0.has.no.actual.declaration.in.module.1.2.html=필요한 {0}이(가) 모듈 {1}{2}에서 실제 선언을 갖고 있지 않습니다
html.accidental.override.0.html=우발적 재정의\: {0}
html.method.contains.from.concurrenthashmap.may.have.unexpected.semantics.it.calls.containsvalue.instead.of.containskey.br.use.explicit.form.of.the.call.to.containskey.containsvalue.contains.or.cast.the.value.to.kotlin.collections.map.instead.br.see.https.youtrack.jetbrains.com.issue.kt.18053.for.more.details.html=ConcurrentHashMap의 메소드 'contains'가 예상치 못한 의미를 가지고 있을 가능성이 있습니다. 이 메소드는 'containsKey' 대신 'containsValue'를 호출합니다.<br/>'containsKey'/'containsValue'/'contains' 호출의 명시적인 형식을 사용하거나 kotlin.collections.Map으로 값을 형 변환하세요.<br/>자세한 내용은 https\://youtrack.jetbrains.com/issue/KT-18053 참조
html.javascript.0.html=JavaScript\: {0}
html.platform.declaration.clash.0.html=플랫폼 선언 충돌\: {0}
html.internal.error.occurred.while.analyzing.this.expression.br.table.cellspacing.0.cellpadding.0.tr.td.strong.please.use.the.strong.td.td.img.src.0.td.td.strong.icon.in.the.bottom.right.corner.to.report.this.error.strong.td.tr.table.br.pre.0.pre.html=이 표현식을 분석하는 동안 내부 오류가 발생했습니다 <br/><table cellspacing\="0" cellpadding\="0"><tr><td>(하단 오른쪽 모서리에 있는 <strong>"</strong></td><td><img src\="{0}"/></td><td><strong>" 아이콘을 사용하여 이 오류를 보고</strong>해 주세요)\:</td></tr></table><br/><pre>{0}</pre>
html.property.delegate.must.have.a.0.method.none.of.the.following.functions.is.suitable.ul.1.ul.html=프로퍼티 위임에는 ''{0}'' 메소드가 있어야 합니다. 다음 함수는 어느 것도 적합하지 않습니다. <ul>{1}</ul>
html.overload.resolution.ambiguity.on.method.0.all.these.functions.match.ul.1.ul.html=메소드 ''{0}''에 대한 오버로드 해결이 모호합니다. 이 모든 함수가 일치합니다. <ul>{1}</ul>
html.unresolved.reference.br.none.of.the.following.candidates.is.applicable.because.of.receiver.type.mismatch.ul.0.ul.html=해결되지 않은 참조입니다. <br/> 다음 후보는 리시버 유형이 일치하지 않아 어느 것도 적용할 수 없습니다. <ul>{0}</ul>
html.cannot.choose.among.the.following.candidates.without.completing.type.inference.ul.0.ul.html=유형 추론을 완료하지 않으면 다음 후보 중에서 선택할 수 없습니다. <ul>{0}</ul>
html.none.of.the.following.functions.can.be.called.with.the.arguments.supplied.ul.0.ul.html=제공된 인수로는 다음 함수 중 어느 것도 호출할 수 없습니다. <ul>{0}</ul>
html.overload.resolution.ambiguity.all.these.functions.match.ul.0.ul.html=오버로드 해결이 모호합니다. 이 모든 함수가 일치합니다. <ul>{0}</ul>
html.function.return.type.mismatch.table.tr.td.expected.td.td.1.td.tr.tr.td.found.td.td.2.td.tr.table.html=함수 반환 유형이 일치하지 않습니다.<table><tr><td>필요 항목\:</td><td>{1}</td></tr><tr><td>발견된 항목\:</td><td>{2}</td></tr></table>
html.0.must.override.1.br.because.it.inherits.many.implementations.of.it.html={0}은(는) {1}의 많은 구현을 상속받고 있기 때문에<br />해당 항목을 재정의해야 합니다
html.types.of.inherited.var.properties.do.not.match.br.0.br.1.html=상속된 var 프로퍼티의 유형이 일치하지 않습니다<br/>{0},<br/>{1}
html.types.of.inherited.properties.are.incompatible.br.0.br.1.html=상속된 프로퍼티의 유형이 호환되지 않습니다.<br/>{0},<br/>{1}
html.actual.class.0.has.no.corresponding.members.for.expected.class.members.1.html=필요 클래스 멤버에 해당하는 멤버가 실제 클래스 ''{0}''에 없습니다.{1}
html.val.property.cannot.override.var.property.br.1.html=Val 프로퍼티는 var 프로퍼티를 재정의할 수 없습니다<br />{1}
html.var.property.type.is.0.which.is.not.a.type.of.overridden.br.1.html=Var 프로퍼티의 유형은 {0}(으)로, 재정의된 항목의 유형이 아닙니다<br/>{1}
required.space=필요\: 
type.inference.failed.expected.type.mismatch=유형 추론에 실패했습니다. 필요한 유형이 일치하지 않습니다. 
html.setter.parameter.type.must.be.equal.to.the.type.of.the.property.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=setter 매개변수 유형은 프로퍼티 유형과 동일해야 합니다.<table><tr><td>필요 항목\:</td><td>{0}</td></tr><tr><td>발견된 항목\:</td><td>{1}</td></tr></table>
html.property.type.is.0.which.is.not.a.subtype.type.of.overridden.br.1.html=프로퍼티의 유형은 {0}(으)로, 재정의된 항목의 하위 유형이 아닙니다<br/>{1}
html.return.types.of.inherited.members.are.incompatible.br.0.br.1.html=상속된 멤버의 반환 유형이 호환되지 않습니다.<br/>{0},<br/>{1}
html.return.type.is.0.which.is.not.a.subtype.of.overridden.br.1.html=반환 유형은 ''{0}''(으)로, 재정의된 항목의 하위 유형이 아닙니다<br/>{1}
html.loop.parameter.type.mismatch.table.tr.td.iterated.values.td.td.0.td.tr.tr.td.parameter.td.td.1.td.tr.table.html=루프 매개변수 유형이 일치하지 않습니다.<table><tr><td>반복된 값\:</td><td>{0}</td></tr><tr><td>매개변수\:</td><td>{1}</td></tr></table>
html.type.argument.is.not.within.its.bounds.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=유형 인수가 해당 바운드 내에 없습니다.<table><tr><td>필요 항목\:</td><td>{0}</td></tr><tr><td>발견된 항목\:</td><td>{1}</td></tr></table>
html.method.iterator.is.ambiguous.for.this.expression.ul.0.ul.html=메소드 ''iterator()''는 이 표현식에서 모호합니다.<ul>{0}</ul>
html.getter.return.type.must.be.equal.to.the.type.of.the.property.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=getter 반환 유형은 프로퍼티 유형과 동일해야 합니다.<table><tr><td>필요 항목\:</td><td>{0}</td></tr><tr><td>발견된 항목\:</td><td>{1}</td></tr></table>
html.type.inference.failed.0.html=유형 추론에 실패했습니다. {0}
html.assignment.operators.ambiguity.all.these.functions.match.ul.0.ul.table.html=대입 연산자가 모호합니다. 이 모든 함수가 일치합니다. <ul>{0}</ul></table>
html.type.mismatch.table.tr.td.required.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.br.projected.type.2.restricts.use.of.br.3.html=유형이 일치하지 않습니다.<table><tr><td>필요 항목\:</td><td>{0}</td></tr><tr><td>발견된 항목\:</td><td>{1}</td></tr></table><br />\n프로젝션된 유형 {2}이(가) {3}의 사용을<br />\n제한합니다\n
html.type.mismatch.table.tr.td.required.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=유형이 일치하지 않습니다.<table><tr><td>필요 항목\:</td><td>{0}</td></tr><tr><td>발견된 항목\:</td><td>{1}</td></tr></table>

intention.suppress.family=경고 억제
intention.suppress.text={1} {2}에 대한 ''{0}'' 억제
special.module.for.files.not.under.source.root=<special module for files not under source root>
sdk.0=<sdk {0}>
sources.for.library.0=<라이브러리 {0}용 소스>
library.0=<library {0}>
source.for.script.dependencies=<Source for script dependencies>
script.dependencies=<Script dependencies>
script.0.1=<스크립트 {0} {1}>
module.name.0.test={0}(테스트)
platform.module.0.including.1=<{1}이(가) 포함된 플랫폼 모듈 {0}>
the.following.declarations.have.the.same.jvm.signature.code.0.1.code.br.ul.2.ul=다음 선언에 동일한 JVM 시그너처가 있습니다(<code>{0}{1}</code>).<br/>\n<ul>\n{2}</ul>
declaration.kind.object=객체
declaration.kind.companion.object=컴패니언 객체
declaration.kind.initializer=초기자
declaration.kind.statement=구문
declaration.kind.file=파일
declaration.name.0.of.1={1} 중 {0}
declaration.kind.secondary.constructor.of=보조 생성자
declaration.kind.enum.entry=열거형 항목
declaration.kind.type.parameter=유형 매개변수
declaration.kind.class=클래스
declaration.kind.interface=인터페이스
declaration.kind.fun=fun
declaration.kind.parameter=매개 변수
type.parameters.where=where
cannot.be.inferred=추론할 수 없습니다
i.for.i.br.0=<i> for </i><br/>{0}
defined.in=다음에서 정의됨
root.package=루트 패키지
automatically.declared.based.on.the.expected.type=필요한 유형에 따라 자동으로 선언됨
0.smart.cast.to.1={1}(으)로 {0} 스마트 형 변환
unknown.receiver=알 수 없는 리시버
implicit.receiver=묵시적 리시버
extension.implicit.receiver=확장 묵시적 리시버
always.null=항상 null
value.captured.in.a.closure=클로저에서 캡처된 값
wrapped.into.a.reference.object.to.be.modified.when.captured.in.a.closure=클로저에서 캡처된 경우 수정될 참조 객체로 래핑됨
smart.cast.to.0.for.1.call={0}(으)로 스마트 형 변환({1} 호출 시)
smart.cast.to.0={0}(으)로 스마트 형 변환
replace.overloaded.operator.with.function.call=함수 호출로 오버로드된 연산자 교체
searching.for.implicit.usages=묵시적 사용 위치 검색 중...
class.initializer=<클래스 이니셜라이저>
object.0=객체{0}
show.non.public=비 public 으로 표시
show.properties=Show properties

klib.metadata.short=Klib 메타데이터
function.arguments=인수\: 
function.receiver.0=리시버\: {0}
kotlin.built.in.declarations=Kotlin 기본 제공 선언
kotlin.javascript.meta.file=Kotlin JavaScript 메타 파일
