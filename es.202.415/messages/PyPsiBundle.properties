# Message we display for inspection if user uses custom class type members that do not exist
custom.type.mimic.name=Clase dinámica basada en {0}

### Refactorización

refactoring.extract.method.error.interrupted.execution.flow=No se puede realizar la refactorización cuando se interrumpe el flujo de ejecución
refactoring.extract.method.error.star.import=No se puede realizar la refactorización con la declaración de importación en estrella dentro del bloque de código
refactoring.extract.method.error.yield=No se puede realizar la refactorización con la declaración 'yield' dentro del bloque de código

### Anotadores ###
ANN.deleting.none=Eliminando ninguno
ANN.assign.to.none=Asignación a Ninguno
ANN.cant.assign.to.call=No se puede asignar a la llamada de función
ANN.cant.delete.call=No se puede eliminar la llamada a la función
ANN.cant.aug.assign.to.generator=No es posible la asignación aumentada a la expresión del generador
ANN.cant.aug.assign.to.tuple.or.generator=Asignación aumentada a literal de tupla o expresión generadora no posible
ANN.cant.assign.to.generator=Asignar a la expresión del generador no es posible
ANN.cant.assign.to.operator=No se puede asignar al operador
ANN.cant.assign.to.parens=No se puede asignar a()
ANN.cant.aug.assign.to.list.or.comprh=Asignación aumentada a literal de lista o no es posible la comprensión
ANN.cant.assign.to.comprh=No se puede asignar a la comprensión de la lista
ANN.cant.assign.to.dict.comprh=No se puede asignar a la comprensión de dict
ANN.cant.assign.to.set.comprh=No se puede asignar para establecer la comprensión
ANN.cant.aug.assign.to.comprh=Asignación aumentada a la comprensión de la lista no es posible
ANN.cant.aug.assign.to.dict.comprh=Asignación aumentada a comprensión de dictado no es posible
ANN.cant.aug.assign.to.set.comprh=No es posible la asignación aumentada para establecer la comprensión
ANN.cant.assign.to.literal=No se puede asignar a literal
ANN.cant.delete.literal=No se puede eliminar literal
ANN.cant.assign.to.lambda=No se puede asignar a lambda

ANN.break.outside.loop='break' fuera del bucle
ANN.continue.outside.loop='continue' fuera del bucle

ANN.$0.assigned.before.global.decl=El nombre ''{0}'' se asigna antes de la declaración global

ANN.duplicate.param.name=nombre de parámetro duplicado
ANN.starred.param.after.kwparam=* parámetro después de ** parámetro
ANN.regular.param.after.vararg=parámetro regular después de * parámetro
ANN.regular.param.after.keyword=parámetro regular después de ** parámetro
ANN.non.default.param.after.default=el parámetro no predeterminado sigue al parámetro predeterminado
ANN.named.parameters.after.star=los parámetros con nombre deben seguir al desnudo *
ANN.named.parameters.before.slash=los parámetros con nombre deben preceder a bare /
ANN.tuple.py3=el desempaquetado del parámetro tuple no es compatible con Python 3
ANN.multiple.args=varios * parámetros no están permitidos
ANN.multiple.kwargs=múltiples ** parámetros no están permitidos
ANN.multiple.slash=no se permiten varios/parámetros
ANN.slash.param.after.vararg=/ parámetro debe preceder * parámetro
ANN.slash.param.after.keyword=/ parámetro debe preceder ** parámetro

ANN.star.import.at.top.only='importar *' solo se permite a nivel de módulo

ANN.missing.closing.quote=Falta la comilla de cierre [{0}]
ANN.missing.closing.triple.quotes=Faltan comillas triples de cierre

ANN.method.$0.removed.use.$1=El método ''{0}'' ha sido eliminado, use ''{1}'' en su lugar
ANN.method.$0.removed=Método ''{0}'' eliminado

### análisis
PARSE.expected.expression=expresión esperada
PARSE.expected.rbracket=Se esperaba ']'
PARSE.expected.expr.or.comma.or.bracket=expresión esperada, ',' o ']'
PARSE.expected.in=Se esperaba 'in'
PARSE.expected.for.or.bracket=Se esperaba ']' o 'for'
PARSE.expected.comma=Se esperaba ','
PARSE.expected.colon=Se esperaba ':'
PARSE.expected.rpar=Se esperaba ')'
PARSE.expected.lpar=Se esperaba '('
PARSE.expected.rbrace=Se esperaba '}'
PARSE.expected.tick=Se esperaba '`' (comilla invertida)
PARSE.expected.name=nombre esperado
PARSE.expected.colon.or.rbracket=Se esperaba ':' o ']'
PARSE.expected.comma.or.rpar=Se esperaba ',' o ')'
PARSE.expected.else=Se esperaba 'else'

PARSE.expected.identifier=Identificador esperado
PARSE.expected.comma.lpar.rpar=Se esperaba ',' o '(' o ')'
PARSE.expected.statement.break=Se espera una interrupción de la declaración
PARSE.expected.@.or.def=Se esperaba '@' o 'def'
PARSE.expected.formal.param.name=nombre de parámetro formal esperado
PARSE.0.expected=Se esperaba {0}
PARSE.expected.ellipsis=Se esperaba '...'
PARSE.string.literal.expected=literal de cadena esperado
PARSE.expected.symbols=Se esperaba {0} o {1}
PARSE.declarator.should.be.empty=el declarador debe estar vacío
PARSE.string.literal=literal de cadena
PARSE.newline.expected=nueva línea esperada
PARSE.eq.expected=Se esperaba '='
PARSE.from.expected=Se esperaba 'from'
PARSE.gt.expected=Se esperaba '>'

statement.expected.found.0=Se esperaba una declaración, se encontró {0}
unexpected.indent=sangría inesperada
unindent.does.not.match.any.outer.indent=Unindent no coincide con ningún nivel de sangría exterior
except.or.finally.expected=Se esperaba 'except' o 'finally'
expected.statement=Declaración esperada
dedent.expected=Dedent esperado
indent.expected=Se esperaba Sangría
indented.block.expected=Se espera un bloque con sangría
cannot.assign.to.yield.expression=No se puede asignar a la expresión 'yield'
end.of.statement.expected=Fin de la declaración esperado
import.expected=Se esperaba 'import'
def.or.with.or.for.expected=Se esperaba 'def' o 'with' o 'for'
rbracket.or.comma.expected=Se esperaba ']' o ','
unexpected.expression.syntax=Sintaxis de expresión inesperada
tuple.expression.expected=expresión de tupla esperada
value.expression.expected=expresión de valor esperada
unexpected.expression.part=parte de expresión inesperada
unexpected.f.string.token=token de cadena f inesperado
can.t.assign.to.await.expression=No se puede asignar a una expresión en await
for.expected=Se esperaba 'for'
rarrow.expected=Se esperaba '->'
unexpected.tokens=tokens inesperados
enable.in.python.3=Habilitar en Python 3+

PARSE.function.type.annotations.py2=Las anotaciones de tipo no son compatibles con Python 2
PARSE.function.return.type.annotations.py2=Las anotaciones de tipo de retorno no son compatibles con Python 2

PARSE.console.multiline.magic.warn=La magia multilínea no se puede usar como expresión
PARSE.console.identifier.expected=Identificador esperado.
PARSE.console.help.request.warn=Las solicitudes de ayuda deben seguir su nombre.

### generador de documentos rápido
QDOC.module.path.unknown=(Se desconoce la ruta del módulo)
QDOC.epydoc.python2.sdk.not.found=Necesita configurar Python 2 SDK para renderizar <a href='http://epydoc.sourceforge.net/'> Epydoc</a> docstrings
QDOC.local.sdk.not.found=Necesita un SDK de Python local configurado para renderizar cadenas de documentos.
QDOC.assigned.to=Asignado a:
QDOC.documentation.is.copied.from=La documentación se copia de:
QDOC.accessor.kind=Tipo de acceso:
QDOC.raises=Aumentos:
QDOC.keyword.args=Argumentos de palabras clave:
QDOC.returns=Devoluciones:
QDOC.params=Parámetro:

### Formateador
formatter.panel.dict.alignment.do.not.align=No alinear
formatter.panel.dict.alignment.align.on.colon=Alinear en dos puntos
formatter.panel.dict.alignment.align.on.value=Alinear en valor

ignore.overridden.functions=Ignorar funciones anuladas

### Intenciones ###

INTN.replace.octal.numeric.literal=Convertir literal numérico octal a la forma admitida
INTN.convert.builtin.import=Convertir la importación del módulo incorporado al formato admitido

INTN.Family.convert.except.part=Convertir excepto la parte a la forma admitida
INTN.Family.convert.set.literal=Convertir el conjunto literal de dos formas admitidas
INTN.Family.convert.builtin=Convertir la importación del módulo incorporado
INTN.Family.convert.dict.comp.expression=Convertir expresión de comprensión del diccionario
INTN.Family.convert.string=Convertir una cadena entre comillas simples en comillas dobles


INTN.convert.to.from.$0.import.$1=Convertir a ''from {0} import {1}''
INTN.convert.to.import.$0=Convertir a ''import {0}''
INTN.convert.except.to=Convertir 'except exceptClass, Target' a 'except exceptClass as Target'
INTN.convert.set.literal.to=Convertir set literal en llamada al método 'set'


INTN.alias.for.$0.dialog.title=Alias ​​para ''{0}'':
INTN.add.alias.for.import.$0=Agregar alias a ''{0}''
INTN.remove.alias.for.import.$0=Eliminar alias ''{0}''

INTN.Family.migration.to.python3=Migración a Python 3

INTN.replace.noteq.operator=Reemplazar operador no igual
INTN.convert.dict.comp.to=Convertir la comprensión del diccionario en una llamada al método 'dict'

INTN.remove.leading.$0=Eliminar {0} inicial
INTN.remove.leading.prefix=Eliminar prefijo

INTN.replace.backquote.expression=Reemplazar expresión de comillas inversas
INTN.replace.raise.statement=Convertir la declaración de aumento a la forma admitida

INTN.replace.list.comprehensions=Convertir listas por comprensión a un formato compatible

# PyConvertToFStringIntention
INTN.convert.to.fstring.literal=Convertir a literal f-string
INTN.replace.with.method=Reemplazar con llamada al método str.format

# ConvertFormatOperatorToMethodIntention
INTN.format.operator.to.method=Convertir el uso del operador de formato a la llamada al método str.format

INTN.Family.convert.import.unqualify=Convertir 'módulo de importación' a 'de importación de módulo'
INTN.Family.convert.import.qualify=Convertir 'de importación de módulo' a 'módulo de importación'
INTN.Family.toggle.import.alias=Alternar alias de importación

INTN.replace.list.comprehensions.with.for=Convertir listas por comprensión en bucle for

INTN.replace.method=Método de reemplazo que no es compatible con la versión actual de Python

INTN.split.if=Dividir si
INTN.split.if.text=Dividir en 2 if's

INTN.negate.comparison=Negar comparación
INTN.negate.$0.to.$1=Negar ''{0}'' a ''{1}''

INTN.string.concatenation.to.format=Reemplazar la concatenación de cadenas con el operador de formato
INTN.replace.plus.with.format.operator=Reemplazar + con el operador de formato de cadena
INTN.replace.plus.with.str.format=Reemplazar + con llamada al método str.format


INTN.flip.comparison=Comparación de volteo
INTN.flip.$0=Voltear ''{0}''
INTN.flip.$0.to.$1=Voltear ''{0}'' a ''{1}''

INTN.convert.string=Convertir una cadena entre comillas simples en comillas dobles

INTN.join.if=Unir si
INTN.join.if.text=Unir dos if

INTN.convert.dict.constructor.to.dict.literal=Convertir el constructor dict en forma literal dict
INTN.convert.dict.literal.to.dict.constructor=Convertir literal dict en constructor dict

INTN.quoted.string=Convertir entre cadenas entre comillas simples y comillas dobles
INTN.quoted.string.single.to.double=Convertir una cadena entre comillas simples en una cadena entre comillas dobles
INTN.quoted.string.double.to.single=Convertir una cadena entre comillas dobles en una cadena entre comillas simples

INTN.convert.lambda.to.function=Convertir lambda en función

INTN.convert.variadic.param=Convertir de parámetro (s) variable a normal

# PyConvertTripleQuotedStringIntention
INTN.triple.quoted.string=Convertir cadena entre comillas triples en cadena entre comillas simples

# PyBaseConvertCollectionLiteralIntention
INTN.convert.collection.literal.family=Convertir colección a {0}
INTN.convert.collection.literal.text=Convertir {0} en {1}

# PyConvertTypeCommentToVariableAnnotation
INTN.convert.type.comment.to.variable.annotation.family=Convertir un comentario de tipo en una anotación de variable
INTN.convert.type.comment.to.variable.annotation.text=Convertir a anotación de variable


INTN.demorgan.law=ley de DeMorgan

# PyTransformConditionalExpressionIntention
INTN.transform.into.if.else.statement=Transforma la expresión condicional en una declaración if/else

# PyGenerateDocstringIntention
INTN.doc.string.stub=Insertar código auxiliar de cadena de documentación

#SpecifyTypeInDocstringIntention
INTN.specify.type=Especifique el tipo de referencia en docstring
INTN.specify.return.type=Especifique el tipo de retorno en docstring
INTN.add.parameters.to.docstring=Agregar parámetros a docstring

#SpecifyTypeInPy3AnnotationsIntention
INTN.specify.type.in.annotation=Especifique el tipo de referencia usando una anotación
INTN.specify.return.type.in.annotation=Especifique el tipo de retorno usando la anotación

#PyAnnotateTypesIntention/PyAnnotateVariableTypeIntention
INTN.add.type.hints.for.function.family=Agregar sugerencias de tipo para la función
INTN.add.type.hints.for.function=Agregar sugerencias de tipo para la función ''{0}''
INTN.add.type.hint.for.variable.family=Agregar sugerencia de tipo para la variable
INTN.add.type.hint.for.variable=Agregar sugerencia de tipo para la variable ''{0}''
INTN.add.type.hint.for.variable.PEP484.incompatible.type=El tipo ''{0}'' no se puede expresar en línea en formato PEP 484

#TypeAssertionIntention
INTN.insert.assertion=Insertar aserción de tipo

#PyYieldFromIntention
INTN.yield.from=Transforma la iteración explícita con 'rendimiento' en la expresión 'rendimiento de'

#PyConvertStaticMethodToFunctionIntention
INTN.convert.static.method.to.function=Convertir método estático en función

#PyConvertMethodToPropertyIntention
INTN.convert.method.to.property=Convertir método en propiedad

#PyConvertImportIntentionAction
INTN.convert.relative.to.absolute=Convertir importación relativa en absoluta
INTN.convert.absolute.to.relative=Convertir importación absoluta en relativa

INTN.add.alias.title=Agregar alias

### Arreglos rápidos ###
QFIX.auto.import.family=Importar
QFIX.auto.import.import.this.name=Importar este nombre
QFIX.auto.import.import.name=Importar ''{0}''
QFIX.local.auto.import.family=Importar localmente
QFIX.local.auto.import.import.locally={0} localmente
QFIX.augment.assignment=Reemplazar asignación con asignación aumentada
QFIX.NAME.remove.call=Eliminar llamada
QFIX.replace.equality=Reemplazar igualdad
QFIX.dict.creation=Reemplazar la creación del diccionario
QFIX.NAME.remove.dict.key=Eliminar esta clave
QFIX.NAME.move.except.up=Mover excepto cláusula arriba
QFIX.add.field.to.class=Agregar campo a la clase
QFIX.added.constructor.$0.for.field.$1=Se agregó un __init__a la clase <code>{0}</code><br/>para acomodar el nuevo campo <code>{1}</code>
QFIX.NAME.remove.parameter=Eliminar parámetro
QFIX.rename.parameter.to.$0=Renombrar a ''{0}''
QFIX.NAME.add.field.$0.to.class.$1=Agregar campo ''{0}'' a la clase {1}
QFIX.NAME.remove.statement=Eliminar declaración
QFIX.NAME.remove.target.expr=Eliminar expresión de destino
QFIX.failed.to.add.field=<br/>¡Error al agregar un campo!<br/><br/>
QFIX.redundant.parentheses=Eliminar paréntesis redundantes
QFIX.simplify.boolean.expression=Simplificar expresión booleana
QFIX.simplify.$0=Reemplazar expresión booleana con ''{0}''
QFIX.chained.comparison=Simplifique la comparación encadenada
QFIX.move.from.future.import=Mover 'de __future__import' a un lugar correcto
QFIX.list.creation=Reemplazar creación de lista
QFIX.add.super=Agregar llamada de superclase
QFIX.NAME.remove.assignment=Eliminar asignación
QFIX.NAME.remove.argument=Eliminar argumento
QFIX.add.parameter.self=Agregar parámetro ''{0}''
QFIX.statement.effect=Reemplazar con llamada a función
QFIX.remove.trailing.semicolon=Eliminar el punto y coma al final
QFIX.introduce.variable=Introducir variable para declaración
QFIX.NAME.make.list=Reemplazar tupla con lista
QFIX.NAME.add.specifier=Agregar carácter especificador de formato
QFIX.NAME.wrap.in.exception=Ajustar con llamada de excepción
QFIX.add.global=Agregar declaración global
QFIX.create.property=Crear propiedad
QFIX.replace.with.type.name=Reemplazar con el nombre del tipo
QFIX.remove.function.annotations=Eliminar anotaciones de funciones
QFIX.replace.with.target.name=Reemplazar con el nombre del objetivo
QFIX.remove.generic.parameters=Eliminar parámetro (s) genérico
QFIX.replace.with.square.brackets=Reemplazar con corchetes
QFIX.surround.with.square.brackets=Surround con corchetes
QFIX.remove.square.brackets=Eliminar corchetes
QFIX.add.property=Agregar propiedad para el campo
QFIX.use.property=Usar propiedad para el campo
QFIX.make.public=Hacer público
QFIX.NAME.update.parameters=Actualizar parámetros
QFIX.rename.parameter=Cambiar nombre de parámetro
QFIX.convert.to.new.style=Convertir a clase de estilo nuevo
QFIX.change.base.class=Cambiar clase base
QFIX.classic.class.transform=Heredar del objeto
QFIX.NAME.rename.argument=Cambiar el nombre del argumento
QFIX.NAME.add.exception.base=Agregar clase base de excepción
QFIX.add.encoding=Agregar declaración de codificación
QFIX.remove.trailing.suffix=Eliminar sufijo final
QFIX.action.failed=Acción fallida


#PyRemoveUnderscoresInNumericLiteralsQuickFix
QFIX.NAME.remove.underscores.in.numeric=Eliminar guiones bajos en literales numéricos

# ReplaceFunctionWithSetLiteralQuickFix
QFIX.replace.function.set.with.literal=Reemplazar la llamada a la función con un literal establecido

#RemoveArgumentEqualDefaultQuickFix
QFIX.remove.argument.equal.default=Eliminar argumentos iguales a los predeterminados

#PyDefaultArgumentQuickFix
QFIX.default.argument=Reemplazar el argumento predeterminado mutable

#PyMoveAttributeToInitQuickFix
QFIX.move.attribute=Mover atributo al método __init__

#DocstringQuickFix
QFIX.docstring.add.$0=Agregar parámetro de cadena de documentos ''{0}''
QFIX.docstring.remove.$0=Eliminar el parámetro docstring ''{0}''
QFIX.docstring.insert.stub=Insertar docstring
QFIX.fix.docstring=Corregir docstring

#PyMakeMethodStaticQuickFix
QFIX.NAME.make.static=Hacer que el método sea estático

#PyMakeFunctionFromMethodQuickFix
QFIX.NAME.make.function=Hacer función a partir del método

#ConvertIndents
QFIX.convert.indents=Convertir sangrías
QFIX.convert.indents.to.tabs=Convertir sangrías en tabulaciones
QFIX.convert.indents.to.spaces=Convertir sangrías en espacios

# ConvertDocstringQuickFix
QFIX.convert.single.quoted.docstring=Convertir docstring al formato de cadena triple entre comillas dobles

# RemoveUnnesentialBackslashQuickFix
QFIX.remove.unnecessary.backslash=Eliminar barra invertida innecesaria en la expresión

#RemoveDecoratorQuickFix
QFIX.remove.decorator=Eliminar decorador

#PyMakeFunctionReturnTypeQuickFix
QFIX.NAME.make.$0.return.$1=Make ''{0}'' return ''{1}''

# Agregar método de solución rápida
QFIX.NAME.add.method.$0.to.class.$1=Agregar método {0}() a la clase {1}
QFIX.failed.to.add.method=<br/>¡Error al agregar un método!<br/><br/>
QFIX.NAME.add.function.$0.to.module.$1=Crear función {0}() en el módulo {1}
QFIX.failed.to.add.function=<br/>¡Error al agregar una función!<br/><br/>
QFIX.add.method.to.class=Agregar método a la clase

# InstallAndImportQuickFix
QFIX.install.and.import.package=Instalar e importar paquete
QFIX.NAME.install.and.import.package=Instalar e importar el paquete ''{0}''


# Acciones y comandos asociados
ACT.CMD.use.import=Usar un módulo importado
ACT.qualify.with.module=Calificar con un módulo importado
ACT.from.some.module.import=Importar desde...


python.docstring.file.type=python docstring
python.function.type.annotation.file.type.description=Comentario del tipo de función Python PEP-484
python.docstring.format=Formato Docstring:
python.docstring.select.type=Seleccione el tipo de Docstring

### Inspecciones: INSP ###
INSP.GROUP.python=Python

INSP.compatibility.this.syntax.available.only.since.py3=​​Esta sintaxis está disponible solo desde py3
INSP.compatibility.check.for.compatibility.with.python.versions=Verifique la compatibilidad con las versiones de Python:
INSP.abstract.class.set.as.metaclass=Establecer ''{0}'' como metaclase
INSP.abstract.class.add.to.superclasses=Agregar ''{0}'' a las superclases
INSP.pep8.naming=Violación de la convención de nomenclatura PEP 8
INSP.pep8.naming.excluded.base.classes=Clases base excluidas
INSP.pep8.naming.ignored.errors=Errores ignorados
INSP.shadowing.builtins=Sombreado de elementos integrados
INSP.calling.non.callable=Intentando llamar a un objeto no invocable
INSP.dataclass.definition.and.usages=Definición y usos de la clase de datos
INSP.dunder.slots=Definición de __slots__en una clase
INSP.final.classes.methods.and.variables=Clases, métodos y variables finales
INSP.global.undefined=La variable global no está definida a nivel de módulo
INSP.inconsistent.indentation=Sangría inconsistente
INSP.named.tuple=Definición de Namedtuple
INSP.shadows.name.from.outer.scope=Nombre de las sombras ''{0}'' del alcance externo
INSP.trailing.semicolon=Punto y coma final en la declaración
INSP.raising.string.exception=Generando una excepción de cadena
INSP.protected.member.ignore.annotations=Ignorar anotaciones
INSP.protected.member.ignore.test.functions=Ignorar funciones de prueba
INSP.docstring.types.fix.docstring=Corregir docstring
INSP.docstring.types.change.type=Cambiar el tipo de {0} de {1} a {2}
INSP.interpreter.configure.python.interpreter=Configurar el intérprete de Python
INSP.interpreter.interpreter.settings=Configuración del intérprete
INSP.interpreter.use.interpreter=Usar {0}
INSP.interpreter.use.suggested.interpreter=Usar intérprete sugerido
INSP.mandatory.encoding.encoding.comment.format=Formato de comentario de codificación:
INSP.mandatory.encoding.select.default.encoding=Seleccione la codificación predeterminada:
INSP.mandatory.encoding.no.encoding.specified.for.file=Sin codificación especificada para el archivo
INSP.method.parameters.metaclass.method.first.argument.name=Nombre del primer argumento del método Metaclass
INSP.missing.type.hints.add.type.hints=Agregar sugerencias de tipo
INSP.missing.type.hints.add.type.hints.for=Agregar sugerencias de tipo para ''{0}''
INSP.missing.type.hints.only.when.types.are.known.collected.from.run.time.or.inferred=Solo cuando los tipos son conocidos (recopilados del tiempo de ejecución o inferidos)

INSP.package.requirements.requirements.have.been.ignored=Los requisitos han sido ignorados
INSP.package.requirements.requirement.has.been.ignored=''{0}'' ha sido ignorado
INSP.package.requirements.add.import=Agregar importación
INSP.package.requirements.administrator.privileges.required=Se requieren privilegios de administrador
INSP.package.requirements.administrator.privileges.required.description=\
  La instalación de paquetes en ''{0}'' requiere privilegios de administrador.\n\n\
  Configure un entorno virtual por proyecto como su intérprete de proyecto\n\
  para evitar instalar paquetes en un área protegida del sistema de archivos.
INSP.package.requirements.administrator.privileges.required.button.configure=Configurar
INSP.package.requirements.administrator.privileges.required.button.install.anyway=Instalar de todos modos
INSP.package.requirements.requirements.file.empty=El archivo de requisitos está vacío
INSP.package.requirements.quickfix.family.name=Agregar paquetes importados a los requisitos...
INSP.pep8.ignore.base.class=Ignorar clase base
INSP.pep8.ignore.method.names.for.descendants.of.class=Ignorar los nombres de los métodos para los descendientes de la clase
INSP.shadowing.builtins.ignore.shadowed.built.in.name=Ignorar el nombre integrado sombreado
INSP.stub.packages.compatibility.ignore=Ignore la compatibilidad ''{0}''
INSP.stub.packages.compatibility.ignored.packages=Paquetes de stub ignorados
INSP.stub.packages.compatibility.incompatible.packages.message='' {0} {1} {2} '' es incompatible con '' {3} {4} {5} ''. Versión ''{6}'' esperada: [{7}]
INSP.arguments.not.declared.but.provided.by.decorator=Los siguientes argumentos no están declarados, pero los proporciona el decorador: {0}
INSP.abstract.class=La clase debe implementar todos los métodos abstractos
INSP.assigning.function.call.that.doesnt.return.anything=Asignando una llamada de función que no devuelve nada
INSP.deprecated.function.class.or.module=Función, clase o módulo obsoleto
INSP.mandatory.encoding=No se especificó codificación para el archivo
INSP.missing.type.hints=Falta la sugerencia de tipo para la definición de la función
INSP.overloads.in.regular.python.files=Sobrecargas en archivos Python normales
INSP.pep8.coding.style.violation=Violación de estilo de codificación PEP 8
INSP.protected.member=Acceso a un miembro protegido de una clase o módulo
INSP.protocol.definition.and.usages=Definición y usos del protocolo
INSP.shadowing.names=Sombreado de nombres de ámbitos externos
INSP.stub.packages.compatibility=Inspección de compatibilidad de paquetes stub
INSP.stub.packages=Anunciante de paquetes stub
INSP.type.checker=Comprobador de tipos
INSP.type.hints=Definiciones y usos de sugerencias de tipo
INSP.typed.dict=Definición y usos de TypedDict

# PyArgumentListInspection
INSP.NAME.incorrect.call.arguments=Argumentos de llamada incorrectos
INSP.cannot.appear.past.keyword.arg=No pueden aparecer argumentos de palabras clave anteriores o * arg o ** kwarg
INSP.unexpected.arg=Argumento inesperado
INSP.unexpected.arg(s)=Argumentos inesperados
INSP.parameter.$0.unfilled=Parámetro ''{0}'' sin completar
INSP.parameter(s).unfilled=Parámetro (s) sin completar
INSP.possible.callees=Posibles destinatarios
INSP.func.$0.lacks.first.arg=La función ''{0}'' carece de un argumento posicional
INSP.expected.dict.got.$0=Se esperaba un diccionario, obtuvo {0}
INSP.expected.iter.got.$0=Se esperaba un iterable, obtuvo {0}
INSP.more.args.that.pos.params=Varios valores se resuelven en un parámetro posicional
INSP.multiple.values.resolve.to.positional.$0=Varios valores se resuelven en el parámetro posicional ''{0}''
INSP.cannot.analyze=Esta lista de argumentos no se puede analizar

# PyMethodParametersInspection
INSP.NAME.problematic.first.parameter=Métodos que tienen problemas con el primer parámetro
INSP.must.have.first.parameter=El método debe tener un primer parámetro, generalmente llamado ''{0}''
INSP.probably.mistyped.self=¿No quiso decir 'self'?
INSP.usually.named.self=Por lo general, el primer parámetro de un método se llama 'self'
INSP.usually.named.$0=Por lo general, el primer parámetro de dichos métodos se llama ''{0}''
INSP.first.param.must.not.be.tuple=El primer parámetro de un método no estático no debe ser una tupla

# PyNestedDecoratorsInspection
INSP.NAME.nested.decorators=Anidamiento problemático de decoradores
INSP.decorator.receives.unexpected.builtin=Este decorador no recibirá un invocable que puede esperar; el decorador incorporado devuelve un objeto especial

# PyRedeclarationInspection
INSP.NAME.redeclaration=Nombres recuperados sin uso
INSP.redeclared.name=Redeclarado ''{0}'' definido anteriormente sin uso

# PyUnresolvedReferencesInspection
INSP.try.except.import.error=''{0}'' en el bloque try con '' except ImportError '' también debe definirse en el bloque except
INSP.unused.import.statement=Declaración de importación no utilizada <code> #ref</code>

# PyInterpreterInspection
INSP.NAME.invalid.interpreter=Intérprete no válido configurado

# ReturnValueFromInitInspection
INSP.NAME.init.return=__init__ método que devuelve un valor
INSP.cant.return.value.from.init=No se puede devolver un valor de __init__

# PyUnreachableCodeInspection
INSP.NAME.unreachable.code=Código inalcanzable
INSP.unreachable.code=Este código es inalcanzable

# PyStringFormatInspection
INSP.NAME.str.format=Errores en las operaciones de formato de cadena
INSP.format.requires.no.mapping=El formato no requiere un mapeo
INSP.key.$0.has.no.arg=Key ''{0}'' no tiene un argumento correspondiente
INSP.unexpected.type.$0=Tipo inesperado {0}
INSP.too.few.keys=Muy pocas claves de mapeo
INSP.no.format.specifier.char=Falta el carácter especificador de formato
INSP.format.requires.mapping=El formato requiere una asignación
INSP.too.many.args.for.fmt.string=Demasiados argumentos para la cadena de formato
INSP.too.few.args.for.fmt.string=Muy pocos argumentos para la cadena de formato
INSP.incompatible.options=Las opciones de formato en el fragmento "{0}" son incompatibles
INSP.unused.mapping=La clave de asignación "{0}" no se utiliza
INSP.unsupported.format.character=Carácter de formato no admitido ''{0}''
INSP.manual.to.auto.field.numbering=No se puede cambiar de la especificación de campo manual a la numeración de campo automática
INSP.auto.to.manual.field.numbering=No se puede cambiar de la numeración automática de campos a la especificación manual de campos

# PyMethodOverridingInspection
INSP.NAME.method.over=La firma del método no coincide con la firma del método anulado
INSP.signature.mismatch=La firma del método ''{0}'' no coincide con la firma del método base en la clase ''{1}''

# PyInitNewSignatureInspection
INSP.NAME.new.init.signature=Firmas incompatibles de __new__ y __init__
INSP.new.incompatible.to.init=La firma no es compatible con __init__
INSP.init.incompatible.to.new=La firma no es compatible con __new__

# PyTrailingSemicolonInspection
INSP.NAME.trailing.semicolon=Punto y coma final en la declaración


# PyUnboundLocalVariableInspection
INSP.NAME.unbound=Variable local independiente
INSP.unbound.local.variable=Es posible que se haga referencia a la variable local ''{0}'' antes de la asignación
INSP.unbound.nonlocal.variable=La variable no local ''{0}'' debe estar vinculada en un ámbito de función externo
INSP.unbound.name.undefined=El nombre ''{0}'' puede no estar definido
INSP.unbound.function.too.large=La función ''{0}'' es demasiado grande para analizarla

# PyListCreationInspection
INSP.NAME.list.creation=La creación de la lista puede ser reescrita por literal de lista

# PyTupleAssignmentBalanceInspection
INSP.NAME.incorrect.assignment=El saldo de la asignación de tupla es incorrecto

# PyClassicStyleClassInspection
INSP.NAME.classic.class.usage=Uso de clase de estilo clásico
INSP.classic.class.usage.old.style.class=Clase de estilo antiguo
INSP.classic.class.usage.old.style.class.ancestors=Clase de estilo antiguo, porque todas las clases de las que hereda son de estilo antiguo


# PyExceptionInheritance
INSP.NAME.exception.not.inherit=La excepción no hereda de la clase estándar '' Excepción ''

# PyDefaultArgumentInspection
INSP.NAME.default.argument=El argumento predeterminado es mutable

# PyDocstringTypesInspection
INSP.NAME.docstring.types=El tipo de docstring no coincide con el tipo inferido

# PyStatementEffectInspection
INSP.NAME.statement.effect=La declaración no tiene efecto
INSP.NAME.statement.message=La declaración parece no tener efecto

# PyStringExceptionInspection
INSP.NAME.raising.string.exception=Generando una excepción de cadena

# PySuperArgumentsInspection
INSP.NAME.wrong.super.arguments=Argumentos incorrectos para llamar a super
INSP.$0.is.not.superclass.of.$1=''{0}'' no es una instancia o una subclase de ''{1}''

# PynonAsciiCharInspection
INSP.NAME.non.ascii=El archivo contiene caracteres no ASCII

# PyMandatoryEncodingInspection
INSP.NAME.mandatory.encoding=No se especificó codificación para el archivo

# PyTupleItemAssignmentInspection
INSP.NAME.tuple.item.assignment=Asignación de elementos de tupla
INSP.tuples.never.assign.items=Las tuplas no admiten la asignación de elementos

# PyPropertyAccessInspection
INSP.NAME.property.access=Acceso a propiedades
INSP.property.$0.cant.be.set=La propiedad ''{0}'' no se puede establecer
INSP.property.$0.cant.be.read=La propiedad ''{0}'' no se puede leer
INSP.property.$0.cant.be.deleted=La propiedad ''{0}'' no se puede eliminar

# PyPropertyDefinitionInspection
INSP.NAME.property.definition=Definiciones de propiedad
INSP.doc.param.should.be.str=El parámetro doc debe ser una cadena
INSP.strange.arg.want.callable=Argumento extraño; se espera un invocable
INSP.func.property.name.mismatch=Los nombres de la función y el decorador no coinciden; no se crea el acceso a la propiedad
INSP.getter.return.smth=Getter debería devolver o producir algo
INSP.setter.should.not.return=Setter no debe devolver un valor
INSP.deleter.should.not.return=El eliminador no debe devolver un valor
INSP.getter.signature.advice=La firma del captador debe ser (propia)
INSP.setter.signature.advice=La firma del setter debe ser (self, value)
INSP.deleter.signature.advice=La firma del eliminador debe ser (propia)
INSP.accessor.first.param.is.$0=El primer parámetro de un descriptor de acceso generalmente se llama ''{0}''

# PyProtectedMemberInspection
INSP.protected.member.$0.access=Acceso a un miembro protegido {0} de una clase
INSP.protected.member.$0.access.module=Acceso a un miembro protegido {0} de un módulo

# PyOldStyleClassesInspection
INSP.NAME.oldstyle.class=La clase de estilo antiguo contiene características de clase de estilo nuevo
INSP.oldstyle.class.slots=La clase de estilo antiguo contiene la definición de __slots__
INSP.oldstyle.class.getattribute=La clase de estilo antiguo contiene la definición __getattribute__
INSP.oldstyle.class.super=La clase de estilo antiguo contiene una llamada al súper método

# PyCompatibilityInspection
INSP.NAME.compatibility=Inspección de compatibilidad de código

# PyUnnesentialBackslashInspection
INSP.NAME.unnecessary.backslash=Barra invertida innecesaria

# PySingleQuotedDocstringInspection
INSP.NAME.single.quoted.docstring=Cadena de documentos entre comillas simples
INSP.message.single.quoted.docstring=Se deben utilizar cadenas triples entre comillas dobles para las cadenas de documentos.

# PyMissingConstructorInspection
INSP.NAME.missing.super.constructor=Llamada perdida a __init__de la superclase
INSP.missing.super.constructor.message=Se perdió la llamada a __init__de la superclase

# PySetFunctionToLiteralInspection
INSP.NAME.set.function.to.literal=La llamada a la función se puede reemplazar con set literal

# PyDecoratorInspection
INSP.NAME.decorator.outside.class=Decorador específico de clase en método fuera de clase

# PyPackageRequirementsInspection
INSP.NAME.requirements=Requisitos del paquete

# PyClassHasNoInitInspection
INSP.NAME.class.has.no.init=La clase no tiene método __init__
INSP.class.has.no.init=La clase no tiene método __init__
INSP.parent.$0.has.no.init=Parent ''{0}'' no tiene método __init__

#PyNoneFunctionAssignmentInspection
INSP.NAME.none.function.assignment=Asignando una llamada de función que no devuelve nada (Ninguno)
INSP.none.function.assignment=La función ''{0}'' no devuelve nada

# PyTestParametrizedInspection
INSP.NAME.pytest-parametrized=Comprueba que las funciones decoradas por pytest parametrize tienen argumentos correctos

# PyUnusedLocalInspection
INSP.NAME.unused=Local no utilizado
INSP.unused.locals.parameter.isnot.used=El valor del parámetro ''{0}'' no se utiliza
INSP.unused.locals.local.variable.isnot.used=El valor de la variable local ''{0}'' no se utiliza
INSP.unused.locals.replace.with.wildcard=Reemplazar con _
INSP.unused.locals.local.function.isnot.used=La función local ''{0}'' no se utiliza
INSP.unused.locals.local.class.isnot.used=La clase local ''{0}'' no se usa

INSP.unused.locals.ignore.variables.starting.with=Ignorar las variables que comienzan con '_'
INSP.unused.locals.ignore.range.iteration.variables=Ignorar variables de iteración de rango
INSP.unused.locals.ignore.lambda.parameters=Ignorar los parámetros lambda
INSP.unused.locals.ignore.variables.used.in.tuple.unpacking=Ignorar las variables utilizadas en el desempaquetado de tuplas

# PyChainedComparsonsInspection
INSP.NAME.chained.comparisons=Las comparaciones encadenadas se pueden simplificar

# PyAugmentAssignmentInspection
INSP.NAME.augment.assignment=La asignación se puede reemplazar con una asignación aumentada

# PyBroadExceptionInspection
INSP.NAME.too.broad.exception.clauses=Cláusulas de excepción demasiado amplias

# PyByteLiteralInspection
INSP.NAME.byte.literal=Byte literal contiene caracteres> 255

# PyComparisonWithNoneInspection
INSP.NAME.comparison.with.none=Comparación con None realizada con operadores de igualdad

# PyDictCreationInspection
INSP.NAME.dict.creation=La creación del diccionario puede ser reescrita por literal de diccionario

# PyDictDuplicateKeysInspection
INSP.NAME.duplicate.keys=El diccionario contiene claves duplicadas

# PyFromFutureImportInspection
INSP.NAME.from.future.import=from __future__import debe ser la primera instrucción ejecutable

# PyMethodFirstArgAssignmentInspection
INSP.NAME.first.arg.assign=Reasignación del primer argumento del método
INSP.first.arg.$0.assigned=parámetro del método ''{0}'' reasignado

# PyMethodMayBeStaticInspection
INSP.NAME.method.may.be.static=El método puede ser estático
INSP.method.may.be.static=El método <code> #ref</code> puede ser 'estático'

# PyAbstractClassInspection
INSP.NAME.abstract.class=La clase debe implementar todos los métodos abstractos
INSP.NAME.abstract.class.$0.must.implement=La clase {0} debe implementar todos los métodos abstractos

#PyAssignmentToLoopOrWithParameterInspection
INSP.NAME.assignment.to.loop.or.with.parameter.display.name=Asignación al parámetro de instrucción 'for' o 'with'
INSP.NAME.assignment.to.loop.or.with.parameter.display.message=Variable ''{0}'' ya declarada en '' para '' bucle o '' con '' declaración anterior
INSP.assignment.to.loop.or.with.parameter=Asignación al parámetro de instrucción 'for' o 'with'

# PyArgumentEqualDefaultInspection
INSP.NAME.argument.equal.default=El argumento pasado a la función es igual al valor del parámetro predeterminado
INSP.argument.equals.to.default=El argumento es igual al valor del parámetro predeterminado

#PyAsyncCallInspection
INSP.NAME.coroutine.is.not.awaited=Coroutine ''{0}'' no se espera
INSP.async.call=Coroutine no se espera

# PyAttributeOutsideInitInspection
INSP.NAME.attribute.outside.init=Atributo de instancia definido fuera de __init__
INSP.attribute.$0.outside.init=Atributo de instancia {0} definido fuera de __init__
INSP.attribute.outside.init=Atributo de instancia definido fuera de __init__

# PyCallByClassInspection
INSP.NAME.different.class.call=Llamar a un método por clase usando una instancia de una clase diferente
INSP.instance.of.$0.excpected=Se esperaba una instancia de {0}, no la clase en sí
INSP.passing.$0.en lugar de.$1=Pasando {0} en lugar de {1}. ¿Es esto intencional?

# PyMissingOrEmptyDocstringInspection
INSP.NAME.missing.or.empty.docstring=Falta una cadena de documentos o está vacía
INSP.no.docstring=Falta una cadena de documentos
INSP.empty.docstring=Cadena de documentos vacía

# PyUnresolvedReferencesInspection
INSP.NAME.unresolved.refs=Referencias no resueltas
INSP.module.$0.not.found=Módulo ''{0}'' no encontrado
INSP.unresolved.ref.$0=Referencia no resuelta ''{0}''
INSP.unresolved.ref.$0.for.class.$1=Referencia de atributo no resuelto ''{0}'' para la clase ''{1}''
INSP.cannot.find.$0.in.$1=No se puede encontrar la referencia ''{0}'' en ''{1}''
INSP.unresolved.operator.ref=La clase ''{0}'' no define ''{1}'', por lo que el operador ''{2}'' no se puede utilizar en sus instancias
python.stub=Código auxiliar de Python

# PyRedundantParenthesesInspection
INSP.NAME.redundant.parentheses=Paréntesis redundantes
INSP.redundant.parens.ignore.empty.lists.of.base.classes=Ignorar listas vacías de clases base
INSP.redundant.parens.ignore.tuples=Ignorar tuplas
INSP.redundant.parens.ignore.argument.of.operator=Ignorar el argumento del operador %

# PySimplifyBooleanCheckInspection
INSP.NAME.check.can.be.simplified=La verificación de variables booleanas se puede simplificar
INSP.expression.can.be.simplified=La expresión se puede simplificar
INSP.simplify.boolean.check.ignore.comparison.to.zero=Ignorar comparación a cero

# PyIncorrectDocstringInspection
INSP.NAME.incorrect.docstring=Cadena de documentos incorrecta
INSP.missing.parameter.in.docstring=Falta el parámetro {0} en docstring
INSP.unexpected.parameter.in.docstring=Parámetro inesperado {0} en docstring

# PyExceptClausesOrderInspection
INSP.NAME.bad.except.clauses.order=Orden incorrecto excepto cláusulas
INSP.class.$0.already.caught=La clase de excepción ''{0}'' ya ha sido detectada
INSP.class.$0.superclass.$1.already.caught=''{0}'', superclase de la clase de excepción ''{1}'', ya ha sido detectada

#PyGlobalUndefinedInspection
INSP.NAME.global.undefined=La variable global no está definida a nivel de módulo
INSP.NAME.global.$0.undefined=La variable global ''{0}'' no está definida en el nivel del módulo

# PyHighlightingAnnotator
INSP.python.trailing.suffix.not.support=Python no admite un ''{0}'' final

# PyInterpreterInspection
python.sdk.no.interpreter.configured.owner=No se ha configurado ningún intérprete de Python para {0}

# PyInspectionsSuppressor
INSP.python.suppressor.suppress.for.function=Suprimir para función
INSP.python.suppressor.suppress.for.class=Suprimir para clase
INSP.python.suppressor.suppress.for.statement=Suprimir para declaración

find.usages.unnamed=<sin nombre>
find.usages.keyword.argument=argumento de palabra clave
find.usages.variable=variable
find.usages.imported.module.alias=alias del módulo importado
find.usages.class=clase
find.usages.function=función
find.usages.method=método
find.usages.parameter=parámetro

python.find.usages=Buscar usos
python.find.usages.base.method.question=El método {0} anula el método de la clase {1}.\n¿Desea encontrar usos del método base?
python.find.usages.usage.in.superclass.list=Uso en la lista de superclase
python.find.usages.usage.in.isinstance=Uso en isinstance()
python.find.usages.untyped.probable.usage=Uso sin tipo (probable)
python.find.usages.usage.in.import.statement=Uso en declaración de importación
