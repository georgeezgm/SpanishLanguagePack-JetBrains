0.already.contains.field.1={0} ya contiene el campo {1}
0.already.contains.inner.class.named.1={0} ya contiene una clase interna llamada {1}
0.already.has.parameter.named.1.use.this.name.anyway={0} ya tiene un parámetro llamado ''{1}''.\n¿Usas este nombre de todos modos?
0.contains.call.with.null.argument.for.parameter.1={0} contiene una llamada con un argumento nulo para el parámetro {1}
0.implements.1={0} implementa {1}.
0.is.1.and.will.not.be.accessible.from.2.in.the.target.class={0} es {1} y no será accesible desde {2}.
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.parameters={0} es una parte de la jerarquía del método. ¿Quieres eliminar varios parámetros?
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.type.parameters={0} es parte de la jerarquía de métodos. ¿Quiere eliminar varios parámetros de tipo?
0.is.an.interface.method.implementation.will.be.added.to.all.directly.implementing.classes={0} es una interfaz.\nLa implementación del método se agregará a todas las clases de implementación directa.\n¿Continuar?
0.is.an.interface.that.has.no.implementing.classes={0} es una interfaz que no tiene clases de implementación
0.is.not.a.legal.java.identifier=''{0}'' no es un identificador java legal
0.is.not.accessible.from.1.value.for.introduced.parameter.in.that.method.call.will.be.incorrect={0} no es accesible desde {1}. El valor del parámetro introducido en esa llamada al método será incorrecto.
0.is.not.initialized.in.declaration.such.fields.are.not.allowed.in.interfaces={0} no se inicializa en la declaración. Estos campos no están permitidos en interfaces.
0.is.not.static.it.cannot.be.moved.to.the.interface={0} no es estático. No se puede mover a la interfaz.
0.is.used.for.writing.in.1={0} se usa para escribir en {1}
0.or.all.directories.in.project={0} o todos los directorios del proyecto?
0.refactoring.is.supported.only.for.final.fields={0} la refactorización solo es compatible con los campos finales
0.upcasts.an.instance.of.1.to.2={0} actualiza una instancia de {1} a {2}
0.uses.1.of.an.instance.of.a.2={0} usa {1} de una instancia de un {2}
0.uses.1.which.needs.class.instance={0} uses {1}, que necesita instancia de clase
0.uses.a.package.local.1={0} usa paquete privado {1}
0.uses.non.static.1.which.is.not.passed.as.a.parameter={0} usa no estático {1}, que no se pasa como parámetro
0.will.be.inaccessible.from.1={0} será inaccesible desde {1}
0.will.become.inaccessible.from.1={0} se volverá inaccesible desde {1}
0.will.hide.renamed.1={0} ocultará el nombre renombrado {1}
0.will.no.longer.override.1={0} ya no anulará {1}
0.will.not.be.accessible.from.1.after.inlining={0} no será accesible desde {1} después de la inserción
0.will.override.renamed.1={0} anulará el cambio de nombre {1}
a.package.local.class.0.will.no.longer.be.accessible.from.1=La clase local de paquete {0} ya no será accesible desde {1}
accept.signature.change=Aceptar cambio de firma
add.object.as.a.parameter.to.constructors.with.name=Agregar &objeto como parámetro a los constructores con nombre:
add.parameters.for.fields=Agregar parámetros para ca&mpos:
add.parameters.for.fields.to.constructors=Agregar parámetros para &campos a constructores:
all.candidate.variables.have.types.not.in.project=Todas las variables candidatas tienen tipos que no están en el proyecto
all.candidate.variables.have.unknown.types=Todas las variables candidatas tienen tipos desconocidos
all.invocations.keep.the.method=Inline todos y mant&enga el método
all.references.and.remove.super.class=Inline &todas las referencias y eliminar la clase
all.references.and.remove.the.class=En línea y todas las referencias y eliminar la clase
all.references.and.remove.the.field=Inline todos y elimin&ar el campo
all.references.keep.field=Integrar todo y mantener el campo
all.these.directories.will.be.moved.and.all.references.to.0.will.be.changed=Se moverán todos estos directorios y se cambiarán todas las referencias a {0}\n.
analyze.and.replace.usages=Analizar y reemplazar usos
analyze.module.conflicts=Analizar conflictos de módulos...
annotate.field.as.nonnls.checkbox=Anotar &campo como @NonNls
anonymous.class.text=Clase anónima
anonymous.to.inner.enum.constant.cannot.refactor.message=La constante Enum no se puede convertir a la clase interna
anonymousToInner.class.name.label.text=Nombre de clase:
anonymousToInner.make.class.static.checkbox.text=Hacer clase y estática
anonymousToInner.no.inner.class.name=Se debe especificar el nombre de la clase
anonymousToInner.parameters.panel.border.title=Parámetros del constructor
anonymousToInner.refactoring.name=Convertir anónimo en interno
auto.rename.module.dialog.description=Cambie el nombre de los módulos Java con los siguientes nombres a:
auto.rename.module.dialog.title=Cambiar el nombre de los módulos Java
auto.rename.module.entity=Módulo Java
boolean.method.result=resultado del método booleano
can.t.restore.context.for.method.extraction=No se puede restaurar el contexto para la extracción del método
cannot.find.or.create.destination.directory=No se puede encontrar o crear el directorio de destino
cannot.introduce.field.in.interface=Los campos de instancia no están permitidos en la interfaz
cannot.introduce.field.in.record=Los campos de instancia no están permitidos en el registro
cannot.move=No se puede mover
cannot.move.inner.class.0.into.itself=No se puede mover la clase interna {0} a sí misma
cannot.move.package.into.itself=No se puede mover el paquete a sí mismo
cannot.replace.temp.with.query.in.interface=No se puede reemplazar la temperatura con la consulta en la interfaz
caret.position.warning.message=El signo de intercalación debe colocarse en el tipo de campo, variable, método o parámetro de método que se va a refactorizar
change.method.signature.action.name=Cambiar la firma del método
change.signature.default.value.missing.warning.message=Falta el valor predeterminado. Las llamadas a métodos contendrán espacios en blanco en lugar del nuevo valor del parámetro.
change.signature.use.any.checkbox=&Usar cualquier var
changeClassSignature.bad.value=Valor {0} incorrecto: ''{1}'' para el parámetro ''{2}''
changeClassSignature.class.label.text=Cambiar firma de {0}
changeClassSignature.no.type.parameters=La clase no puede tener parámetros de tipo
changeClassSignature.parameters.panel.border.title=Parámetros
changeClassSignature.refactoring.name=Cambiar firma de clase
changeSignature.bound.value.column=Valor enlazado:
changeSignature.cannot.resolve.return.type=El tipo de retorno ''{0}'' no se puede resolver.\n¿Continuar?
changeSignature.default.value.column=Valor predeterminado:
changeSignature.exception.caller.chooser=Seleccionar métodos para propagar nuevas excepciones
changeSignature.exceptions.panel.border.title=Excepciones
changeSignature.exceptions.wont.propagate=No se realizará la propagación recursiva de cambios de excepción
changeSignature.no.return.type=No se especifica el tipo de retorno
changeSignature.no.type.for.exception=Especifique el tipo de excepción
changeSignature.no.type.for.parameter=Especificar {0} tipo para el parámetro ''{1}''
changeSignature.not.throwable.type=Tipo incorrecto ''{0}'' para la excepción, debería extender java.lang.Throwable
changeSignature.propagate.exceptions.title=Propagar e&xcepciones...
changeSignature.vararg.not.last=El parámetro Vararg debe ser el último en la firma del método
changeSignature.wrong.return.type=Tipo de retorno incorrecto: ''{0}''
changeSignature.wrong.type.for.exception=Tipo incorrecto: ''{0}'' para excepción
changeSignature.wrong.type.for.parameter=Tipo incorrecto: ''{0}'' para el parámetro ''{1}''
checking.conflicts=Comprobando conflictos...
choose.the.ones.you.want.to.be.deleted=Elija los que desea eliminar
class.0.already.exists=La clase {0} ya existe
class.0.is.not.accessible.from.target.1=La clase {0} no es accesible desde el objetivo {1}
class.0.not.found=Clase {0} no encontrada.
class.description=clase {0}
class.does.not.exist.in.the.project=La clase no existe en el proyecto. ¿Quieres crearlo?
class.does.not.have.base.classes.or.interfaces=La clase {0} no tiene clases base ni interfaces
class.does.not.have.implicit.default.constructor=La clase {0} no tiene un constructor predeterminado implícito
class.has.been.successfully.created=La clase {0} se ha creado correctamente
class.is.abstract={0} es abstracto.
class.is.final.warning.message=La clase {0} es final
class.is.interface={0} es una interfaz.
class.is.never.used=La clase nunca se usa
class.name.prompt=Clase y nombre:
collect.overloads=Recoger sobrecargas...
comments.elements.header=Apariciones encontradas en comentarios, cadenas y archivos sin código {0}
constructor.being.refactored.is.used.in.initializer.of.0=El constructor que se está refactorizando se usa en el inicializador de {0}. La fábrica no estática de la clase interna {1} no se puede utilizar en este contexto. El código resultante no se compilará.
constructor.description=constructor {0}
constructor.with.builder.new.setter.prefix.dialog.message=Nuevo prefijo de establecedor:
constructor.with.builder.parameters.to.pass.to.the.builder.title=Parámetros para pasar al constructor
constructor.with.builder.rename.setters.prefix.action.name=Cambiar el nombre del prefijo de Definidor
convert.anonymous.to.inner.action.name=Convertir anónimo en interno...
convert.local.to.field.title=Convertir local en campo
convert.to.instance.method.title=Método de conversión a instancia
convertToInstanceMethod.all.reference.type.parameters.are.not.in.project=No se encuentra ninguna clase de destino para el método de instancia: todos los tipos referenciados no están en el proyecto
convertToInstanceMethod.all.reference.type.parameters.have.unknown.types=No se encuentra ninguna clase de destino para el método de instancia: todos los tipos referenciados son desconocidos
convertToInstanceMethod.method.is.not.static=No se puede realizar la refactorización\nEl método {0} no es estático
convertToInstanceMethod.no.parameters.with.reference.type=No hay parámetros que tengan tipo de referencia
copy.class.clone.0.1=Clonar {0} {1}
copy.class.copy.0.1=Copiar {0} {1}
copy.handler.clone.class=Clase de clonación
copy.handler.copy.class=Copiar clase
copy.handler.copy.class.with.dialog=Copiar clase...
copy.handler.copy.classes.with.dialog=Copiar clases...
copy.handler.is.not.available.during.indexing=Las clases de copia no están disponibles durante la indexación
current.class=clase actual
dataflow.to.here.expand.progress=Expandiendo todos los nodos... {0}
dataflow.to.here.group.by.leaf.action.description=Determine si nulo puede fluir hacia esta expresión
dataflow.to.here.group.by.leaf.action.text=Agrupar por nulidad de expresión de hoja {0,choice, 1#|2# (Análisis en curso)}
dataflow.to.here.variable.dereferenced.tooltip=Variable desreferenciada
declaration.s.to.be.generified=Declaración (es) que se generarán {0}
declare.final=Declarar &final
declare.generated.annotations=&Generar anotaciones
declare.static.checkbox=Declarar &static
declare.static.pass.fields.checkbox=Declare &static (pasar campos como parámetros)
declare.var.type=Declarar tipo &var
declare.varargs.checkbox=Declarar v&arargs
default.visibility.border.title=Visibilidad predeterminada
delegate.members=Miembros delegados
delegating.field=Delegar campo
delete.variable.declaration=Eliminar &declaración de variable
destination.directory.does.not.correspond.to.any.package=El directorio de destino no corresponde a ningún paquete
destination.package=&Paquete de destino:
directory.0.already.contains.1.named.2=Directorio {0}\nya contiene {1} llamado ''{2}''
directory.0.already.contains.a.file.named.1=Directorio {0}\nya contiene un archivo llamado ''{1}''
do.not.replace=No reemplazar
do.not.show.this.message.in.the.future=&No mostrar este mensaje en el futuro
do.you.want.to.process.overriding.methods.with.covariant.return.type=¿Desea procesar métodos de reemplazo\ncon el tipo de retorno covariante?
dont.move.to.another.source.folder.option=&No mover a otra carpeta de origen
edit.migration.entry.title=Editar descripción de migración de clase/paquete
edit.migration.map.title=Editar mapa de migración
element.will.no.longer.be.accessible={0} ya no será accesible desde {1}
encapsulate.fields..encapsulated.fields.visibility.border.title=Visibilidad de campos encapsulados
encapsulate.fields..package.local.radio=Paquete lo&cal
encapsulate.fields.accessors.visibility.border.title=Visibilidad de los accesores
encapsulate.fields.command.name=Encapsular campos en {0}
encapsulate.fields.encapsulate.border.title=Encapsular
encapsulate.fields.field.column.name=Campo
encapsulate.fields.fields.to.be.encapsulated=Campos a encapsular
encapsulate.fields.fields.to.encapsulate.border.title=Campos para encapsular
encapsulate.fields.get.access.checkbox=&Obtener acceso
encapsulate.fields.getter.column.name=Captador
encapsulate.fields.getter.exists=Ya existe un método {0} que difiere del captador {1} solo por el tipo de retorno
encapsulate.fields.nothing.todo.warning.message=La clase no tiene campos para encapsular
encapsulate.fields.private.radio=Pr&ivado
encapsulate.fields.protected.radio=Pro&tegido
encapsulate.fields.refactoring.cannot.be.applied.to.interface=La refactorización de campos encapsulados no se puede aplicar a la interfaz
encapsulate.fields.set.access.checkbox=&Establecer acceso
encapsulate.fields.setter.column.name=Definidor
encapsulate.fields.setter.exists=Ya existe un método {0} que difiere del definidor {1} solo por el tipo de retorno
encapsulate.fields.title=Encapsular campos
encapsulate.fields.use.accessors.even.when.field.is.accessible.checkbox=&Use accessors incluso cuando el campo sea accesible
entity.name.constructor.parameter=Parámetro
entity.name.inheritor=Heredero
entity.name.test=Prueba
entity.name.variable=Variable
entity.name.accessor=Accesor
enum.description=enum {0}
error.cannot.resolve=No se puede resolver {0}
error.incorrect.data=Datos incorrectos
error.not.supported.for.jsp={0} la refactorización no es compatible con JSP
error.not.supported.for.local={0} la refactorización no es compatible con las clases locales
error.not.supported.for.package.info={0} la refactorización no es compatible con package-info.java
error.wrong.caret.position.anonymous=Caret debe colocarse dentro de la clase anónima para ser refactorizado
error.wrong.caret.position.constructor=Caret debe colocarse dentro del constructor para ser refactorizado
error.wrong.caret.position.local.name=Caret debe colocarse en el nombre de la variable local para ser refactorizado
error.wrong.caret.position.local.or.expression.name=Caret debe colocarse en el nombre de la variable o expresión local que se va a refactorizar
error.wrong.caret.position.method=Caret debe colocarse dentro del método para ser refactorizado
error.wrong.name.input=Nombre incorrecto: {0}
expand.method.reference.warning=El método se usa en la referencia del método. Proceder daría como resultado la conversión a expresión lambda
expression.result=resultado de la expresión
extract.chained.constructor.checkbox=Extraer &constructor encadenado
extract.delegate.as.enum.checkbox=Extraer como enumeración
extract.delegate.create.nested.checkbox=Crear clase anidada
extract.delegate.generate.accessors.checkbox=Generar accesos
extract.delegate.unable.create.warning.message=No se puede crear una clase con el nombre dado
extract.method.control.flow.analysis.failed=El código contiene errores de sintaxis. No se puede realizar el análisis necesario.
extract.method.error.prefix=No se puede extraer el método.
extract.method.error.class.outside.used=La clase local se usa fuera del bloque seleccionado.
extract.method.error.class.outside.defined=La clase local se define fuera del bloque seleccionado.
extract.method.error.many.outputs=Hay varias variables para devolver.
extract.method.error.many.exits=Hay varios puntos de salida.
extract.method.error.many.finals=Hay una asignación para el campo final.
extract.method.error.variable.in.expression=Hay una variable para devolver dentro de la expresión seleccionada.
extract.method.error.class.not.found=El bloque seleccionado debe ser parte de la clase java.
extract.method.object.anonymous.make.varargs.option=Crear argumentos &variables
extract.method.object.class.name=&Nombre de clase:
extract.method.object.create.anonymous.class=Crear &clase anónima
extract.method.object.create.inner.class=Crear una clase interna
extract.method.object.inner.class.visibility=Visibilidad:
extract.method.object.inner.make.static.option=Hacer &estático
extract.method.object.inner.make.varargs.option=Crear &varargs
extract.method.object.inner.visibility.package.local=pa&quete local
extract.method.object.inner.visibility.private=pri&vate
extract.method.object.inner.visibility.protected=pr&otected
extract.method.object.inner.visibility.public=pu&blic
extract.method.object.method.name=&Nombre del método:
extract.method.object.parameters=Parámetros
extract.method.object.signature.preview=Vista previa de la firma
extract.method.object.suggestion=¿Le gustaría extraer el objeto de método?
extract.parameters.to.replace.duplicates=Extraer parámetros para reemplazar duplicados
extract.subclass.command=Extraer subclase
extractSuper.rename.original.class.to=&Cambiar el nombre de la clase original a:
extractSuperInterface.javadoc=JavaDoc
factory.method.name.label=Nombre del método de fábrica:
failed.to.re.run.refactoring=No se pudo volver a ejecutar la refactorización
field.0.is.already.defined.in.the.1=El campo {0} ya está definido en {1}
field.0.is.never.used=El campo {0} nunca se usa
field.0.is.not.accessible=El campo {0} no es accesible desde {1}
field.0.will.hide.field.1.of.the.base.class=El campo {0} ocultará \n el campo {1} de la base {2}
field.declaration.radio=Campo y declaración
field.description=campo {0}
field.name=&Nombre de campo:
fields.to.be.refactored.should.belong.to.the.same.class=Los campos a ser refactorizados deben pertenecer a la misma clase
functional.interface.broken=La expresión funcional exige que la interfaz funcional tenga un método exacto
generate.getter.for.delegated.component=Generar &captador para componente delegado
generate.module.descriptors.analysing.message=Analizando dependencias
generate.module.descriptors.build.required.message=No se pudieron generar descriptores de módulo porque el proyecto aún no se ha creado
generate.module.descriptors.collecting.message=Recopilación de dependencias
generate.module.descriptors.command.title=Generar descriptores de información de módulo
generate.module.descriptors.no.suitable.modules.message=No se encontraron módulos que puedan contener información de módulo
generate.module.descriptors.preparing.message=Preparando código
generate.module.descriptors.rebuild.message=El proyecto debe construirse para una mejor precisión del cálculo de dependencias. \n¿Iniciar la compilación antes de generar descriptores de información de módulo?
generate.module.descriptors.scanning.message=Analizando la salida del compilador
generate.module.descriptors.title=Generar descriptores de módulo
generify.title=Generar
getter.and.setter.methods.found.for.the.field.0=Métodos captado y definidor encontrados para el campo {0}.\n{1} ellos también?
getter.method.found.for.the.field.0=Método de obtención encontrado para el campo {0}.\n{1} ¿el captador también?
idea.has.not.found.any.code.that.can.be.replaced.with.method.call={0} no ha encontrado ningún duplicado
ignore.button=Ignorar
information.title=Información
initializer.for.variable.cannot.be.a.constant.initializer=El inicializador de la variable {0} no puede ser un inicializador constante
inline.action.name=Inline
inline.anonymous.conflict.progress=Buscando herederos de la clase "{0}"...
inline.class.elements.header=Clase a en línea
inline.conflicts.progress=Compruebe si es posible en línea...
inline.constant.field.not.supported.for.enum.constants={0} no es compatible con las constantes de enumeración
inline.field.command=Campo en línea {0}
inline.field.elements.header=Campo a en línea
inline.field.field.name.label=Campo {0} {1}
inline.field.title=Campo en línea
inline.local.unable.try.catch.warning.message=No se puede inline fuera de la declaración Try/catch
inline.local.used.as.resource.cannot.refactor.message=La variable se usa como referencia de recurso
inline.local.variable.declared.outside.cannot.refactor.message=La variable se declara fuera de un bloque de código
inline.method.checking.tail.calls.progress=Comprobando los usos de las llamadas de cola
inline.method.elements.header=Método para insertar
inline.method.object.action.name=Objeto en línea
inline.method.object.suggestion.message=¿Desea insertar el objeto y la siguiente llamada?
inline.parameter.cannot.find.initializer.warning.message=No se puede encontrar el inicializador constante para el parámetro
inline.parameter.confirmation=¿Parámetro en línea ''{0}'' con inicializador ''{1}''?
inline.parameter.error.hierarchy=El parámetro en línea no es compatible cuando el método es parte de la jerarquía de herencia
inline.parameter.error.varargs=Inline para parámetros varargs no es compatible
inline.parameter.method.usages.progress=Buscando usos de métodos
inline.parameter.no.usages.warning.message=El método no tiene usos
inline.parameter.not.accessible.warning.message=No se puede acceder al inicializador constante en el cuerpo del método
inline.parameter.refactoring=Parámetro en línea
inline.parameter.replace.with.local.checkbox=R&eemplazar con variable local
inline.parameter.write.usages.warning.message=El parámetro en línea que tiene usos de escritura no es compatible
inline.pattern.variable.title=Variable de patrón en línea
inline.super.non.project.class.warning.message=No se puede insertar una clase que no sea de proyecto
inline.to.anonymous.border.title=Inline
inline.to.anonymous.command.name=Clase en línea {0}
inline.to.anonymous.name.label=Clase {0}
inline.to.anonymous.no.abstract=Las clases abstractas no se pueden insertar
inline.to.anonymous.no.multiple.interfaces=Las clases que implementan múltiples interfaces no se pueden insertar
inline.to.anonymous.no.superclass.and.interface=Las clases que tienen una superclase e implementan una interfaz no se pueden insertar
inline.to.anonymous.refactoring=En línea a clase anónima
inline.vars.elements.header=Variable a en línea
inlined.method.implements.method.from.0=El método insertado implementa el método de {0}
inlined.method.overrides.method.from.0=El método en línea anula el método de {0}
inlined.method.will.be.transformed.to.single.return.form=El método en línea se transformará en un formulario de retorno único
inner.class.0.is.already.defined.in.class.1=La clase interna {0} ya está definida en la clase {1}.\n¿Desea continuar de todos modos?
inner.class.0.is.not.static=La clase interna {0} no es estática.\nLa refactorización {1} solo es compatible con miembros estáticos.
inner.class.exists=La clase interna llamada ''{0}'' ya está definida\nen la clase ''{1}''
inner.class.name=&Nombre de la clase interna:
instance.initializer.description=inicializador de instancia de la clase {0}
instances.casted.to.java.lang.object=Instancias convertidas a java.lang.Object
instances.of.0.upcasted.to.1.were.found=Se encontraron instancias de {0} upcastted a {1}. Si continúa, se mostrarán en una pestaña Buscar separada.
instances.upcasted.to.java.lang.object.found=Instancias subidas a java.lang.Object encontrado
instances.upcasted.to.object=Instancias subidas al objeto
interface.0.does.not.have.inheritors=La interfaz {0} no tiene herederos
interface.description=interfaz {0}
interface.does.not.have.base.interfaces=La interfaz {0} no tiene interfaces base
interface.has.been.successfully.created=La interfaz {0} se ha creado correctamente
introduce.constant.enum.cb=Extraer como constante &enum
introduce.constant.field.of.type=Constante (campo final estático) de &type:
introduce.constant.introduce.to.class=Extraer a &class (nombre completo)\:
introduce.constant.move.to.another.class.checkbox=Mover a otra clase
introduce.constant.used.for.write.cannot.refactor.message=La expresión seleccionada se usa para escribir
introduce.field.field.of.type=Campo de &tipo:
introduce.field.static.field.of.type=Campo estático de &tipo:
introduce.functional.variable.pass.fields.checkbox=Pasar &campos como parámetros
introduce.local.variable.to.reassign.title=Elija variable para reasignar
introduce.parameter.command=Extrayendo parámetro a {0}
introduce.parameter.convert.lambda=&Convertir a expresión funcional
introduce.parameter.duplicates.progress=Método de búsqueda duplicados...
introduce.parameter.elements.header=Añadiendo parámetro a un método
introduce.parameter.object.create.inner.class=Crear una clase interna
introduce.parameter.object.create.new.class=&Crear nueva clase
introduce.parameter.object.escalate.visibility.option=&Escalar visibilidad
introduce.parameter.object.existing.class.name=&Nombre
introduce.parameter.object.generate.accessors.option=&Generar accesos
introduce.parameter.object.inner.class.name=&Nombre
introduce.parameter.object.new.class.name=&Nombre
introduce.parameter.object.new.class.package.name=&Nombre del paquete
introduce.parameter.object.use.existing.class=&Usa la clase existente
introduce.parameter.super.method.checkbox=Refactorizar el súper método
introduce.parameter.to.method=Extraer parámetro al método:
introduced.variable.will.conflict.with.0=La variable introducida entrará en conflicto con {0}
introducing.variable.may.break.code.logic=La introducción de una variable puede romper la lógica del código
invalid.expression.context=Contexto de expresión no válido.
invalid.target.package.name.specified=Se ha especificado un nombre de paquete de destino no válido
invert.boolean.foreach=El inicializador del parámetro Foreach no se puede invertir
invert.boolean.wrong.type=El tipo de retorno del método o el tipo de variable a refactorizar debe ser booleano
invocations.to.be.inlined=Invocaciones que se incluirán {0}
is.modified.in.loop.body={0} se modifica en el cuerpo del bucle
javadoc.for.abstracts=JavaDoc para resúmenes
keep.original.signature=Conservar la firma original
lambda.to.reference.side.effect.warning.message=Hay posibles efectos secundarios encontrados en el calificador de referencia de método.\n¿Introducir la variable local?
local.variable.description=variable local {0}
local.will.be.hidden.renamed=el campo renombrado ocultará {0}
locate.caret.inside.a.method=Ubicar el cursor dentro de un miembro
locate.duplicates.action.name=Localizar duplicados
make.0.static=Hacer {0} estático
make.method.static.title=Hacer que el método sea estático
make.static.command=Haciendo {0} estático
make.static.description.label=Hacer {0} {1} estático
make.static.elements.header={0} se convertirá en estático
make.static.method.references.progress=Buscar referencias de métodos
make.static.methods.to.propagate.dialog.title=Seleccionar métodos para propagar estática
method.0.is.overridden.by.1={1} anula el método {0}
method.0.will.hide.method.of.the.base.class=El método {0} ocultará\nel método de la clase base {1}
method.0.will.implement.method.of.the.base.class=El método {0} implementará \n método de la clase base {1}
method.0.will.override.a.method.of.the.base.class=El método {0} anulará \n método de la clase base {1}
method.call.would.be.linked.to.0.after.rename=La llamada al método se vincularía a "{0}" después del cambio de nombre
method.column=Método
method.description=método {0}
method.does.not.have.a.body=El método {0} no tiene cuerpo
method.duplicates.found.message={0,choice, 1#1 fragmento de código |2# {0, number} fragmentos de código} encontrados
method.has.an.empty.body=El método {0} tiene un cuerpo vacío.
method.is.not.a.constructor=El método no es un constructor
migration.class=Clase
migration.dialog.ok.button.text=Ejecutar
migration.dialog.title=Migración de paquetes y clases
migration.edit.button=Editar...
migration.entry.class=Clase
migration.entry.new.name=Nuevo nombre:
migration.entry.old.name=Nombre anterior:
migration.entry.package=Paquete
migration.map.description.label=Descripción del mapa:
migration.map.name.prompt=Nombre del mapa:
migration.new.name.column.header=Nuevo nombre
migration.no.usages.found.in.the.project=No se encontraron usos en el proyecto
migration.old.name.column.header=Nombre antiguo
migration.package=Paquete
migration.package.with.subpackages=Paquete con subpaquetes
migration.remove.button=Eliminar
migration.title=Migración
migration.type.column.header=Tipo
move.class=Mover clase...
move.class.refactoring.cannot.be.applied.to.anonymous.classes=La refactorización de Move Class no se puede aplicar a clases anónimas
move.class.to.inner.command.name=Mover {0} a {1}
move.class.to.inner.move.to.self.error=No está permitido mover una clase a sí misma
move.class.to.inner.nonstatic.error=No está permitido mover una clase a una clase interna no estática
move.classes=Mover clases...
move.classes.and.packages=Mover clases y paquetes...
move.classes.command=Moviendo {0} al paquete {1}
move.classes.destination.make.inner=&Hacer clase interna de
move.classes.destination.package.prompt=Para empaquetar:
move.classes.destination.to.package=Para empacar
move.classes.invalid.package.name.warning.message=Nombre de paquete no válido
move.classes.or.packages.title=Mover
move.current.directory=Mover y actual
move.directories=Mover &todos
move.directories.to.another.source.root=Mover {0} directorios a &otra raíz de origen
move.directory.to.another.source.root=Mover el directorio {0} a &otra raíz de origen
move.enum.constant.cb=Mover como constantes &enum si es posible
move.everything.from.directories.to.another.directory=Mover todo de los directorios {0} a otro directorio
move.everything.to.another.directory=Mover todo de {0} a otro directorio
move.files.regrouping.command.name=Reagrupando...
move.files.to.new.directory.prompt=Al directorio:
move.inner.class.action.name=Mover clase interior...
move.inner.class.command=Mover la clase interna {0}
move.inner.class.to.another.class=&Mover la clase interna {0} a otra clase
move.inner.class.to.be.moved=Clase a mover
move.inner.class.to.upper.level=Mover &clase interna {0} al nivel superior
move.inner.class.to.upper.level.action.name=Mover la clase interior al nivel superior...
move.instance.method.delegate.title=Mover método de instancia...
move.instance.method.elements.header=Mover método de instancia
move.instance.method.handler.make.method.static=¿Le gustaría hacer que el método ''{0}'' sea estático y luego moverlo?
move.members.action.name=Mover miembros...
move.method.enter.a.valid.name.for.parameter=Ingrese un nombre válido para el parámetro
move.method.is.not.supported.for.0=El método de instancia de movimiento no es compatible con {0}
move.method.is.not.supported.for.constructors=El método Move no es compatible con los constructores
move.method.is.not.supported.for.generic.classes=El método Move no es compatible con clases genéricas
move.method.is.not.supported.for.non.project.methods=El método Move no es compatible con métodos que no son de proyecto
move.method.this.parameter.label=Seleccione un nombre para el parámetro ''{0}.this''
move.methods.used.in.extracted.block.only=Mover métodos usados solo en bloque extraído
move.nonstatic.class.from.jsp.not.supported=No se admite el movimiento de clases no estáticas desde la página JSP
move.package.or.directory=Mover paquete o directorio...
move.package.refactoring.cannot.be.applied.to.default.package=Mover La refactorización del paquete no se puede aplicar al paquete predeterminado
move.package.to.another.package=Mover &empaquetar ''{0}'' a otro paquete
move.packages.or.directories=Mover paquetes o directorios...
move.packages.to.another.package=Mover {0} &paquetes a otro paquete
move.single.class.or.package.name.label=Mover {0} {1}
move.specified.classes=Mover clases especificadas
move.specified.classes.to=Mover clases especificadas a:
move.specified.packages=Mover paquetes especificados
move.to.inner.duplicate.inner.class=La clase {0} ya contiene una clase interna llamada {1}
moving.local.classes.is.not.supported=Mover clases locales no es compatible
no.class.name.specified=Sin nombre de clase especificado
no.exact.method.duplicates.were.found=<html><b>No se encontraron duplicados de métodos exactos</b>, aunque el método cambiado como se muestra a continuación tiene {0} {0,choice, 1#duplicate |2# duplicados}</html>
no.initializer.present.for.the.field=No hay inicializador presente para el campo
no.parameter.name.specified=Sin nombre de parámetro especificado
no.usages.can.be.replaced=No se pueden reemplazar usos de {0}\n con usos de {1}
occurrences.to.be.migrated=Ocurrencias que se migrarán {0}
ok.button=Aceptar
only.fields.variables.of.methods.of.valid.type.can.be.considered=Solo se pueden considerar campos, variables, parámetros de método \ u00A0 o métodos de tipo válido.
package.description=paquete {0}
package.does.not.exist=El paquete {0} no existe.\n¿Quieres crearlo?
package.name.prompt=Nombre del pa&quete:
parameter.description=parámetro {0}
parameter.initializer.contains.0.but.not.all.calls.to.method.are.in.its.class=El inicializador de parámetros contiene {0}, pero no todas las llamadas al método están en su clase
parameter.name.prompt=Parámetro no&mbre\:
parameter.of.type=Parámetro de &tipo:
parameter.type.table.column.title=Tipo
pass.outer.class.instance.as.parameter=Pasar la instancia de la clase externa c&omo parámetro
please.enter.a.valid.target.package.name=Ingrese un nombre de paquete de destino válido
press.the.do.migrate.button=Presione el botón "Do Migrate" en la parte inferior del panel de resultados de búsqueda\npara migrar usando el mapa de migración "{0}"\n
preview.usages.to.be.changed=&Vista previa de usos que se cambiarán
process.duplicates.change.signature.promt=Para reemplazar todas las ocurrencias, se cambiará la firma del método. ¿Continuar?
process.duplicates.title=Procesar duplicados
process.methods.duplicates.title=Método de proceso {2} Duplicado ({0} de {1})
processing.progress.text=Procesando {0}
project.files.have.been.changed=Se han cambiado los archivos del proyecto.\n¿Desea volver a ejecutar la refactorización?
push.down.delete.warning.text={0} Si empuja a los miembros hacia abajo, se eliminarán. ¿Le gustaría continuar?
push.down.enum.no.constants.warning.text=Enum {0} no tiene constantes para incorporar.
push.down.no.inheritors.class.warning.text=La clase {0} no tiene herederos.
push.down.no.inheritors.final.class.warning.text=La clase final {0} no tiene herederos.
re.run.refactoring=Volver a ejecutar la refactorización
refactoring.cannot.be.applied.no.sources.attached={0} no se puede aplicar la refactorización: no se adjuntan fuentes
refactoring.cannot.be.applied.to.abstract.methods={0} la refactorización no se puede aplicar a métodos abstractos
refactoring.cannot.be.applied.to.inline.non.chaining.constructors={0} la refactorización no se puede aplicar a constructores en línea no encadenados
refactoring.cannot.be.applied.to.native.methods={0} la refactorización no se puede aplicar a métodos nativos
refactoring.cannot.be.applied.to.vararg.constructors={0} la refactorización no se puede aplicar a los constructores de vararg
refactoring.extract.method.dialog.duplicates.count={0,choice, 1#One |2#{0,number}} código duplicado {0,choice, 1#fragmento|2# fragmentos} se puede reemplazar con el extraído llamada al método
refactoring.extract.method.dialog.duplicates.pending=Buscando duplicados...
refactoring.extract.method.dialog.duplicates.progress=Buscando duplicados
refactoring.extract.method.preview.button.refactor=&Refactorizar
refactoring.extract.method.preview.button.rerun=Volv&er a refactorizar
refactoring.extract.method.preview.failed=No se pudo extraer el método
refactoring.extract.method.preview.group.duplicates=Fragmentos de código duplicado
refactoring.extract.method.preview.group.method=Método para extraer
refactoring.extract.method.preview.group.original=Fragmento de código original
refactoring.extract.method.preview.preparing=Preparando diferencia
refactoring.extract.method.preview.updating=Actualizando Diff
refactoring.introduce.variable.enum.in.label.message=No se puede extraer la constante de enumeración de la etiqueta de switch
refactoring.is.not.supported.for.jsp.classes=La refactorización no es compatible con las clases JSP
refactoring.is.not.supported.for.language={0} no es compatible con {1}
refactoring.is.not.supported.for.local.and.jsp.classes=La refactorización no es compatible con clases locales y JSP
refactoring.is.not.supported.in.the.current.context={0} la refactorización no es compatible en el contexto actual
references.in.code.to.elements.from.migration.map=Referencias en el código a elementos del mapa de migración "{0}" {1}
references.to.0.to.be.replaced.with.references.to.1=Referencias a ''{0}'' para ser reemplazadas con referencias a ''{1}''
remove.parameter.0.no.longer.used=Eliminar el parámetro ''{0}'' ya no se usa
rename.constructor.parameters.title=Cambiar el nombre de los parámetros del constructor
rename.constructor.parameters.with.the.following.names.to=Cambiar el nombre de los parámetros con los siguientes nombres a:
rename.inheritors.with.the.following.names.to=Cambiar el nombre de los herederos con los siguientes nombres a:
rename.module.already.exists=El módulo ''{0}'' ya existe en el proyecto
rename.module.directory.command=Cambiar el nombre del módulo y directorio a ''{0}''
rename.module.directory.title=Cambiar nombre de módulo y directorio
rename.overloads=Cambiar nombre y sobrecargas
rename.overloads.dialog.title=Cambiar el nombre de las sobrecargas
rename.overloads.to.dialog.description=Cambiar el nombre de las sobrecargas a:
rename.parameter.in.hierarchy.to.dialog.description=Cambiar el nombre del parámetro en la jerarquía a:
rename.parameters.dialog.title=Cambiar el nombre de los parámetros
rename.tests=Cambiar el nombre de las pruebas
rename.tests.title=Cambiar el nombre de las pruebas
rename.tests.with.the.following.names.to=Cambiar el nombre de las pruebas con los siguientes nombres a:
rename.variables=Cambiar nombre de &variables
rename.variables.title=Cambiar nombre de variables
rename.variables.with.the.following.names.to=Cambiar el nombre de las variables con los siguientes nombres a:
rename.accessors=Cambiar nombre y accesos
rename.accessors.title=Cambiar el nombre de Captadores/Definidores
rename.accessors.with.the.following.names.to=Cambiar el nombre de los accesores con los siguientes nombres a:
renamed.class.will.hide.0.in.1=La clase renombrada ocultará {0} en {1}
renaming.method.will.override.final.0=El método de cambio de nombre anulará el "{0}" final
replace.all.fields=&Reemplazar todos los campos
replace.all.occurrences.of.expression.0.occurrences=Reemplazar &todas las ocurrencias ({0})
replace.constructor.0.with.a.factory.method=Reemplazar constructor {0} con un método de fábrica
replace.constructor.builder.create.new=&Crear nuevo
replace.constructor.builder.use.existing=&Usar existente
replace.constructor.existing.builder.fqn=Nombre de la clase &Builder (totalmente calificado)
replace.constructor.new.builder.class.name=Clase y nombre del constructor
replace.constructor.new.builder.package=&Paquete para nuevo constructor
replace.constructor.with.factory.method=Reemplazar constructor con método de fábrica
replace.constructor.with.factory.method.title=Reemplazar constructor con método de fábrica
replace.constructor.with.factory.target.fq.name=En (nombre completo):
replace.default.constructor.of.0.with.a.factory.method=Reemplaza el constructor predeterminado de {0} con un método de fábrica
replace.default.constructor.with.factory.method=Reemplaza el constructor predeterminado con el método de fábrica
replace.fields.inaccessible.in.usage.context=Reemplazar campos e inaccesible en contexto de uso
replace.fields.used.in.expressions.with.their.getters=Reemplazar campos usados en expresiones con sus captadores
replace.inheritance.from=&Reemplazar con herencia de delegación de:
replace.inheritance.with.delegation.command=Reemplazo de herencia con delegación en {0}
replace.inheritance.with.delegation.elements.header=Reemplazar herencia con delegación
replace.inheritance.with.delegation.title=Reemplazar herencia con delegación
replace.instance.qualifiers.with.class.references=Reemplazar calificadores de instancia con referencias de clase
replace.method.code.duplicates.title=Reemplazar duplicados de código
replace.method.duplicates.scope.chooser.message=Alcance del análisis
replace.method.duplicates.scope.chooser.title=Especificar {0} alcance
replace.temp.with.query.title=Reemplazar Temp con Query
replace.this.code.fragment.and.change.signature=\nLa firma del método se cambiará a\n{0}
replace.this.code.fragment.and.make.method.static=(El método se hará estático)
replace.this.code.fragment.and.make.method.static.visible=(El método se hará estático y {0})
replace.this.code.fragment.and.make.method.visible=(El método se hará {0})
replace.with.method.call.does.not.work.for.constructors=Reemplazar con método Call no funciona para constructores
replace.write.access.occurrences=Incidencias de acceso de escritura de repetición y encaje
replacing.inheritance.with.delegation=Reemplazo de herencia con delegación
safe.delete.search.for.caller.method.usages.progress=Buscar usos del método de llamada...
safe.delete.select.members.to.propagate.dialog.title=Seleccionar miembros para propagar la eliminación segura
safe.delete.select.methods.to.propagate.delete.parameters.dialog.title=Seleccionar métodos para propagar la eliminación de parámetros
select.migration.map=Seleccionar mapa de migración:
select.source.root.chooser.title=Seleccionar raíz de origen
selected.block.contains.invocation.of.another.class.constructor=El bloque seleccionado contiene la invocación de otro constructor de clase
selected.block.contains.statement.outside.of.class=El bloque seleccionado contiene una declaración fuera de una clase
selected.block.should.represent.an.expression=El bloque seleccionado debe representar una expresión
selected.expression.cannot.be.a.constant.initializer=La expresión seleccionada no puede ser un inicializador constante
selected.expression.has.void.type=La expresión seleccionada tiene un tipo vacío.
selected.expression.introduces.pattern.variable=La expresión seleccionada introduce la variable de patrón ''{0}''
setter.method.found.for.the.field.0=Método definidor encontrado para el campo {0}.\n{1} ¿el colocador también?
side.effects.detected.title=Efectos secundarios detectados
source.folder.0.has.package.prefix.1=La carpeta de origen {0} tiene el prefijo de paquete ''{1}''\nEl paquete ''{2}'' no se puede crear allí.
static.initializer.description=inicializador estático de la clase {0}
superclass.cannot.be.extracted.from.an.enum=La superclase no se puede extraer de enum
synthetic.jsp.class.is.referenced.in.the.method=Se hace referencia a la clase jsp sintética en el método
target.0.is.not.accessible.from.1=El objetivo {0} no es accesible desde {1}
the.field.should.be.declared.in.a.class=El campo debe declararse en una clase
there.are.going.to.be.multiple.destination.files.with.the.same.name=Habrá varios archivos de destino con el mismo nombre
there.are.multiple.exit.points.in.the.selected.code.fragment=Hay varios puntos de salida en el fragmento de código seleccionado
there.are.multiple.output.values.for.the.selected.code.fragment=Hay varios valores de salida para el fragmento de código seleccionado:
there.are.no.variables.that.have.reference.type=No hay variables que tengan tipo de referencia
there.are.unused.methods.that.override.methods.you.delete=Hay métodos no utilizados que anulan los métodos que eliminas
there.is.already.a.0.in.1=Ya hay un {0} en {1}
there.is.already.a.0.it.will.conflict.with.an.introduced.parameter=Ya hay un {0}. Entrará en conflicto con el parámetro introducido
there.is.already.a.0.it.will.conflict.with.the.renamed.1=Ya hay un {0}. Entrará en conflicto con el {1} renombrado
there.is.already.type.parameter.in.0.with.name.1=Ya hay un parámetro de tipo en {0} con el nombre {1}
this.method=Este método
this.reference.only.and.keep.super.class=Incluya solo esta referencia y mantenga la superclase
this.reference.only.and.keep.the.class=Incluya solo esta referencia y &mantenga la clase
this.reference.only.and.keep.the.field=Incluya esto solo y &mantenga el campo
to.delete.with.usage.search=para eliminar (con búsqueda de uso)
turn.refs.to.super.command=Reemplazo de usos de {0} con {1}
turnRefsToSuper.change.usages.to=&Cambiar los usos de {0} a:
turnRefsToSuper.use.superclass.in.instanceof=&Usar interfaz/superclase en instancia de
type.cook.command=Generar
type.cook.drop.obsolete.casts=&Soltar moldes obsoletos
type.cook.elements.header=Alcance (s) para generar
type.cook.generify.objects=Generar &Objetos
type.cook.leave.object.parameterized.types.raw=&Dejar sin formato los tipos parametrizados por objeto
type.cook.perform.exhaustive.search=Realizar una búsqueda exhaustiva
type.cook.preserve.raw.arrays=Conservar sin formato y matrices
type.cook.produce.wildcard.types=Producir y tipos de comodines
type.cook.ratio.generified={0,choice,-1#no calculado|0#{0,number} de {1}}
type.cook.report=Elementos generados: {0}, yesos eliminados: {1}
type.migration.action.name=Tipo de migración
type.migration.choose.scope.title=Elija el alcance donde puede ocurrir el cambio de firma
type.migration.conflicts.found=Conflictos migratorios encontrados
type.migration.exclude.action.text=&Excluir
type.migration.include.action.text=&Incluir
type.migration.label=Migrar {0} "{1}" a
type.migration.migrate.button.text=&Migrar
type.migration.no.conflicts.found=No se encontraron conflictos de migración
type.migration.no.scope.warning.message=No se elige el alcance
type.migration.preview.warning.text=Se encontraron más de 10 raíces para migrar. ¿Quieres una vista previa?
type.migration.reasons.to.migrate=Razones encontradas para migrar
type.migration.rerun.button.text=&Volver a ejecutar la migración de tipo
type.migration.select.suggestion=Seleccione la raíz para encontrar razones para migrar
type.of.the.selected.expression.cannot.be.determined=No se puede determinar el tipo de expresión seleccionada.
unable.to.start.type.migration=No se puede iniciar la migración de tipos
unknown.expression.type=Tipo de expresión desconocido.
unused.overriding.methods.title=Métodos de anulación no utilizados
usages.detected.title=Usos detectados
use.interface.superclass.in.instanceof=Usar interfaz/superclase en instancia de
use.interface.where.possible.title=Use la interfaz donde sea posible
use.super.references.prompt=En esta etapa, {0} puede analizar los usos de {1}\ny reemplazarlos con usos de {2} cuando sea posible.\n¿Desea continuar?
use.variable.initializer.to.initialize.parameter=Utilice el &inicializador de variables para inicializar el parámetro
variable.0.is.changed.before.last.access=La variable ''{0}'' se cambia antes del último acceso a la variable ''{1}''.
variable.does.not.have.an.initializer=La variable {0} no tiene inicializador.
variable.is.accessed.for.writing=Se accede a la variable ''{0}'' para escribir
variable.is.never.used.before.modification=La variable {0} nunca se usa antes de la modificación
variable.of.type=Variable de &tipo:
would.you.like.to.replace.default.constructor.of.0.with.factory.method=¿Le gustaría reemplazar el constructor predeterminado de {0} con el método de fábrica?
wrap.return.value.create.inner.class=Crear &clase interna
wrap.return.value.create.new.class=&Crear nueva clase
wrap.return.value.existing.class.name=Nombre
wrap.return.value.inner.class.name=No&mbre
wrap.return.value.new.class.name=&Nombre
wrap.return.value.new.class.package.name=&Nombre del paquete
wrap.return.value.use.existing.class=&Usar clase existente
wrap.return.value.wrapper.field=Envolver &campo
replace.inside.current.lambda=Crear variable dentro de lambda actual
replace.as.separate.operation=Extraer como operación ''{0}''
replace.all.read.and.write=Reemplazar las ocurrencias de lectura y escritura (¡cambiará la semántica!)
replace.all.and.extract=Reemplazar todas las {0} ocurrencias y extraer como operación ''{1}''
replace.lambda.chain.detected=Cadena lambda detectada
replace.occurrences.inside.statement=Reemplazar {0} ocurrencias en el bloque {2,choice, 1#|2# externo} ''{1}''
