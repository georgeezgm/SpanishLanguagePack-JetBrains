title.method.parameters.group=Parámetros de declaración de método/función
title.method.arguments.group=Argumentos de llamada de método/función
title.closure.group=Cerradores
title.condition.clauses.group=Cláusulas de condición
title.if.group=Declaración 'si'
title.guard.group=Declaración 'guardia'
title.for.group=Declaración 'para'
title.do.while.group=repetir... declaración while
title.try.group=Declaración 'do'
title.superclass.list.group=Lista de clases base y protocolos adoptados
title.colon.group=Alrededor de los dos puntos
title.ternary=operación condicional ternaria
title.in.ternary=Dentro de la operación condicional ternaria
title.variable.groups=Grupos de variables
indent.multiline.strings=Sangrar cadenas de varias líneas
indent.directives.title=Directivas
indent.directives.as.code=Cumplir con la sangría del código
indent.directives.children=Sangrar niños
checkbox.spaces.before.method.parentheses=Paréntesis de declaración de método/función
checkbox.spaces.after.operator.in.function.declarations=Operadores en declaraciones de funciones
checkbox.spaces.before.method.call.parentheses=Paréntesis de llamada de método/función
checkbox.spaces.equality.operator=Operador de igualdad '\=\='
checkbox.spaces.shift.operators=Desplazar operadores (<<, >>)
checkbox.spaces.around.range.operators=Operadores de rango (..., ..<)
checkbox.spaces.closure.arrow=flecha de cierre (->)
checkbox.spaces.attribute.parameters=Parámetros de atributos
checkbox.spaces.within.literal.brackets=Corchetes literales de matriz y diccionario
checkbox.spaces.within.method.parentheses=Declaración de método/función entre paréntesis
checkbox.spaces.within.empty.method.parentheses=Declaración de función/método vacío entre paréntesis
checkbox.spaces.within.method.call.parentheses=Paréntesis de llamada de método/función
checkbox.spaces.within.empty.method.call.parentheses=Paréntesis de llamada de método/función vacíos
checkbox.spaces.attribute.parentheses=Atributo paréntesis
checkbox.spaces.before.argument.colon=Antes de los dos puntos en la llamada de método/función
checkbox.spaces.after.argument.colon=Después de dos puntos en llamada de método/función
checkbox.spaces.before.type.colon=Antes de los dos puntos en la anotación de tipo
checkbox.spaces.after.type.colon=Después de dos puntos en la anotación de tipo
checkbox.spaces.before.superclass.colon=Antes de los dos puntos en la cláusula de herencia de tipo
checkbox.spaces.after.superclass.colon=Después de dos puntos en la cláusula de herencia de tipo
checkbox.spaces.before.dictionary.type.colon=Antes de los dos puntos en el tipo de diccionario
checkbox.spaces.after.dictionary.type.colon=Después de dos puntos en el tipo de diccionario
checkbox.spaces.before.dictionary.literal.colon=Antes de los dos puntos dentro del par 'clave\:valor' del literal del diccionario
checkbox.spaces.after.dictionary.literal.colon=Después de dos puntos en el par 'clave\:valor' literal del diccionario
checkbox.spaces.within.string.interpolations=Interpolaciones de cadenas
checkbox.spaces.before.class.lbrace=La declaración de tipo se deja entre llaves
checkbox.spaces.before.method.lbrace=Método/función llave izquierda
checkbox.spaces.before.semicolon=Antes del punto y coma
checkbox.spaces.after.semicolon=Después del punto y coma
wrapping.align.when.multiline=Ordenar en caso de varias líneas
wrapping.align.in.columns=alinear con las columnas
wrapping.else.on.new.line='otro' en nueva línea
wrapping.keep.control.statement.in.one.line=Una línea de sentencias de control
wrapping.keep.simple.methods.in.one.line=Métodos y funciones en una línea
wrapping.keep.simple.blocks.in.one.line=cierre de bloque y (cola) en una línea
wrapping.keep.simple.argument.blocks.in.one.line=Colocar argumentos de cierre en una línea
wrapping.structures.in.one.line=Declaración de tipo vacía en una línea
wrapping.method.brace.placement=En métodos y funciones
wrapping.array.literal=Literales de matriz y diccionario
wrapping.array.new.line.after.left.bracket=Nueva línea después de [
wrapping.array.right.bracket.on.new.line=Colocar ']' en la nueva línea
wrapping.classes.annotation=Atributo de declaración de tipo
wrapping.methods.annotation=Atributos del método
wrapping.fields.annotation=Atributos de propiedad
wrapping.parameters.annotation=Atributos de parámetros
wrapping.local.variables.annotation=Atributos de variables locales
wrapping.closure.signature.on.next.line=Si hay múltiples envolturas, coloque el parámetro en una nueva línea
wrapping.brace.placement.class.declaration=En la declaración de tipo
blank.lines.around.class=Alrededor de la declaración de tipo\:
blank.lines.around.field.in.protocol=alrededor de propiedades en protocolo\:
blank.lines.around.field=Alrededor de la propiedad\:
blank.lines.around.method.in.protocol=Alrededor de métodos/funciones en protocolo\:
blank.lines.around.method=Alrededor de método/función\:
blank.lines.before.method.body=antes del cuerpo del método/función\:
create.field.kind=&Clase\:
create.file.title=Archivo rápido
create.file.dialog.title=Nuevo archivo Swift
create.file.description=Crea un nuevo archivo Swift.
create.class.title=Tipo rápido
create.class.dialog.title=Nuevo tipo Swift
create.type.dialog.title=Nuevo Swift {0}
create.class.description=Crea un nuevo tipo Swift.
goto.super.action={0} seleccionar
goto.super.menu.action=P_adre {0}
goto.super.typealias=Alias de tipo o tipo relacionado
goto.super.class=Clase o Protocolo
goto.base.type=Tipo base
override.implement.nothing.found=No hay nada que revertir para {0}
override.implement.not.allowed={0}No puedo hacerlo
show.implement.action.title=Mostrar miembros para implementar
elements.to.implement.chooser.title=Seleccionar miembros para implementar
elements.to.override.chooser.title=Seleccionar miembro para anular
elements.to.override.implement.chooser.title=Seleccionar miembro para anular/implementar
override.implement.progress=Procesando miembros para anular/implementar...
override.implement.show.optional.member=Marcar &O un miembro opcional
override.implement.show.optional.members=Marcar {0} miembros opcionales
override.implement.show.no.optional.members=Mostrar miembros opcionales (nada opcional)
override.implement.show.only.optional.members=Mostrar miembros opcionales (solo elementos opcionales)
hashbang.line.is.allowed.only.in.the.first.line.of.the.main.file=Las líneas Hashbang sólo se permiten en la primera línea del archivo principal.
hashbang.line.is.allowed.only.in.the.first.line.of.the.file=Las líneas Hashbang solo se permiten en la primera línea del archivo.
hashbang.line.is.allowed.only.in.the.main.file=Las líneas Hashbang sólo se permiten en archivos principales.
0.is.not.allowed=''{0}'' no está permitido.
fix.it=Aplicar Fix-it
0.is.not.resolved=''{0}'' no se resolvió.
unrecognized.platform.name.0=Nombre de plataforma no reconocido ''{0}''
must.handle.potential.future.platforms.with.asterisk=Las plataformas que puedan aparecer en el futuro deben marcarse con '*'.
add.asterisk=Añadir '*'
version.for.0.already.specified=La versión de ''{0}'' ya está especificada.
case.condition.is.not.allowed=La condición 'caso' no está permitida.
syntax.error.typealias.without.assignment=Falta la asignación en la declaración de alias de tipo.
rethrows.is.not.allowed.in.function.type.elements='relanzamientos' no están permitidos en elementos de tipo función
rethrows.is.not.allowed.in.subscripts='relanzamientos' no están permitidos en los subíndices.
rethrows.is.not.allowed.in.closures=No se permiten 'relanzamientos' en cierres.
rethrows.function.must.take.a.throwing.function.argument=La función 'rethrows' debe tener un argumento de función de lanzamiento.
throws.is.not.allowed.in.subscripts='lanzamientos' no está permitido en los subíndices.
thrown.expression.type.0.does.not.conform.to.ErrorType=El tipo de expresión arrojada ''{0}'' no se ajusta a ''{1}''.
try.cannot.appear.to.the.right='try' no puede aparecer en el lado derecho de un operador no asignado.
call.can.throw.in.property.initializer=Los inicializadores de propiedades pueden generar llamadas, pero no pueden generar errores.
call.can.throw.in.default.argument=Las llamadas con argumentos predeterminados pueden generar errores, pero no.
call.can.throw.not.marked.with.try=La llamada se puede realizar pero no se marca como "intentar".
call.can.throw.not.marked.with.try.not.handled=Es posible que la llamada se produzca, pero no se marcará como un "intento" y no se gestionará ningún error.
call.can.throw.not.marked.with.try.not.exhaustive=La llamada puede lanzarse, pero no está marcada como un "intento" y la captura circundante está incompleta.
call.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=La llamada puede lanzarse, pero se ejecuta en un cierre automático sin lanzamiento.
call.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=La llamada puede generarse, pero no se marca como un "intento" y se ejecuta en un cierre automático sin lanzamiento.
operator.can.throw.not.marked.with.try=Se pueden lanzar operadores, pero las expresiones no se marcan como "intentar".
errors.are.not.handled=Los errores arrojados aquí no serán manejados.
errors.are.not.handled.not.exhaustive=Los errores arrojados aquí no se manejarán porque el mensaje adjunto está incompleto.
error.is.not.handled=El error no se maneja porque la función adjunta no se lanza como "lanzamientos".
error.is.not.handled.not.exhaustive=El error no se maneja porque la captura circundante está incompleta.
rethrows.function.can.only.throw.parameter.call=Una función declarada como 'relanzamiento' solo se lanzará si su parámetro lo hace.
rethrows.function.can.only.throw.parameter.call.not.handled=Es posible que se realice la llamada, pero el error no se gestionará. Una función declarada como 'relanzamiento' solo se lanzará si su parámetro lo hace.
rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=Es posible que la llamada se produzca, pero no se marcará como un "intento" y no se gestionará ningún error. Una función declarada como 'relanzamiento' solo se lanzará si su parámetro lo hace.
mark.the.enclosing.function.as.throws=Agregue 'lanzamientos' a la firma de función
add.try.to.expression=Añadir 'try'
suppress.call.error.with.try=Suprime errores con 'try\!'
surround.with.do.catch=Rodear con 'hacer/atrapar'
add.default.catch.clause=Agregar cláusula 'catch' predeterminada
add.catch.clause=Añadir cláusula de "captura"
fix.try.cannot.appear.to.the.right=Mover 'intentar' a la izquierda
intention.create.kind.{0}.from.usage.{1}=Crear {0} ''{1}''
intention.create.type.from.usage.{0}=Crear tipo ''{0}''
intention.implement.members.error=El tipo {0} no se ajusta a {1}.
intention.implement.members.implement.missing.singular=Implementación del miembro faltante de {0}
intention.implement.members.implement.missing.plural=Implementación del miembro faltante de {0}
intention.access.control.error.access=No se puede acceder a {0}. Los elementos son del {1} al {2}.
intention.access.control.error.access.dynamic=No se puede acceder a {0}. Los subíndices de miembros dinámicos son del {1} al {2}.
intention.access.control.error.override={0} no se puede redefinir. Los elementos son del {1} al {2}.
intention.access.control.fix=Crear {0} {1} en {2}
intention.access.control.remove.setter=Eliminar {1} de {0}
intention.redundant.attribute.error=La propiedad @{0} está duplicada.
intention.redundant.attribute.fix=Eliminar atributo duplicado @{0}
intention.redundant.return.error='Devolucion' duplicada.
intention.redundant.return.fix=Eliminar el 'retorno' redundante.
intention.replace.if.with.guard=Reemplace 'si' con 'guardia'
intention.replace.guard.with.if=Reemplace 'guardia' con 'si'
intention.add.explicit.type=Agregar tipos explícitos
intention.remove.explicit.type=Eliminar tipos explícitos
intention.convert.to.multiline.string=Convertir a literal de cadena multilínea
intention.convert.to.string=Convertir a literal de cadena de una línea
intention.convert.to.decimal=Convertir a decimal
intention.convert.to.hex=Convertir a hexadecimal
intention.convert.to.octal=Convertir a octal
intention.convert.to.binary=Convertir a número binario
intention.increase.string.escape.level=Aumentar el nivel de escape de la cuerda
intention.decrease.string.escape.level=Nivel de escape de cuerda inferior
intention.add.digit.separators=Agregar separador de números
intention.remove.digit.separators=Quitar separador de números
intention.split.into.separate.declarations=Dividido en declaraciones individuales.
intention.split.declaration.and.assignment=División de declaraciones y asignaciones
intention.join.declaration.and.assignment=Combinando declaración y cesión
intention.merge.else.if=Fusionar declaraciones else if
intention.split.else.if=Dividir otra declaración si
intention.invert.if.statement=frase inversa si
intention.demorganslaw=ley de demorgan
intention.demorganslaw.format=Reemplace ''{0}'' con ''{1}''
intention.merge.nested.if=Fusionar declaraciones if anidadas
intention.split.nested.if=Dividir en condiciones anidadas
intention.merge.conditions=Condiciones de fusión
intention.split.condition=Dividido en condiciones individuales
intention.negate.comparison=Negar comparación
intention.negate.comparison.format=Negar ''{0}'' como ''{1}''
intention.flip.binary.expression=Invertir expresión binaria
intention.flip.binary.expression.format=Invertir ''{0}''
intention.flip.comparison=Invertir comparación.
intention.unnecessary.parentheses=Elimine los paréntesis innecesarios.
intention.unnecessary.parentheses.error=Los paréntesis son innecesarios.
intention.unnecessary.tuple.wrap=Reemplazo de tuplas de un solo elemento con tipos
intention.unnecessary.tuple.wrap.error=Puedes reemplazar tuplas de un solo elemento con tipos
intention.flip.comparison.format=Invertir ''{0}'' a ''{1}''
fix.return.type.text=Establezca ''{0}'' para devolver ''{1}''
variable.declaration.with.multiple.variables.cannot.have.explicit.getters.setters=El captador/definidor explícito no se puede utilizar en la declaración 'var' con múltiples variables
variable.declaration.with.multiple.variables.cannot.have.implicit.getter.clause=La cláusula getter implícita no se puede utilizar en la declaración 'var' con múltiples variables
variable.declaration.with.multiple.variables.cannot.have.willset.didset.clause=Las cláusulas willSet/didSet no se pueden utilizar en declaraciones 'var' con múltiples variables.
no.expression.found=expresión no encontrada
feature.are.not.supported.at.version={0} no es compatible con Swift {1}.{2}.
feature.attribute=''@{0}'' atributo
feature.raw.strings=literal de cadena sin formato
feature.diagnostic.directives=Instrucciones de diagnóstico
feature.compiler.version.directive.conditions=Directiva de verificación de versión del compilador
usages.base.member.warning.title=advertencia
usages.base.member.warning.message.implements={0} implementa {1} declarado en {3}.\n\n¿Le gustaría buscar el uso del protocolo {2}?
usages.base.member.warning.message.override={0} implementa {1} declarado en {4}.\n\n¿Le gustaría buscar el uso del {2} predeterminado?
usages.base.member.warning.message.override.implemented={0} anula {1} declarado en {4} e implementa {1} declarado en {3}.\n\nUso de bases y protocolos {2} ¿Le gustaría buscar una ubicación?
usages.base.member.warning.message.default.implementation={0} es la implementación predeterminada de {1} declarada en {3}.\n\n¿Le gustaría buscar el uso del protocolo {2}?
cannot.perform.refactoring=No se puede realizar la refactorización
extract.method.title.method=Método de extracción
extract.method.title.function=Extracción de funciones
extract.method.title.closure=Extracción de cierre
extract.method.error.should.represent.expr.or.statements=El bloque seleccionado debe representar una declaración o colección de expresiones.
extract.method.error.cannot.determine.expr.type=No se puede determinar el tipo de expresión seleccionada.
extract.method.error.cannot.extract.expr.with.var.declarations=No se puede extraer de una expresión con declaración de variable.
extract.method.error.cannot.determine.function.result.type=No se puede determinar el tipo de resultado de la función.
extract.method.error.multiple.exit.points=El fragmento de código seleccionado tiene múltiples puntos de salida.
extract.method.error.cannot.extract.with.returns=No se puede extraer un método con una instrucción de retorno dentro de un fragmento de código.
extract.method.error.cannot.determine.parameters.type=No se puede determinar el tipo de parámetro.
extract.method.error.fragment.should.be.inside.code.block=El fragmento de código seleccionado debe estar dentro de un bloque de código.
extract.method.function.0.will.conflict.with.1.2=La función ''{0}'' entra en conflicto con {1} {2}.
extract.method.method.0.will.conflict.with.1.in.2.3=El método ''{0}'' entra en conflicto con {1} en {2} ''{3}''.
extract.method.at.least.two.parameters.have.name.0=Hay más de dos parámetros con el nombre ''{0}''.
extract.method.variable.0.will.no.longer.be.accessible=Ya no se puede acceder a la variable ''{0}'' después de la refactorización
extract.method.cannot.extract.mutable.value=Los valores de las variables no se pueden extraer.
extract.method.0.1.will.be.shadowed.by.2.1={0} ''{1}'' está sombreado por {2} ''{1}''.
converter.dialog.message=El portapapeles contiene código Objective-C. ¿Quieres convertirte a Swift?
converter.dialog.title=Convertir Objective-C a Swift
swift.name.rename.init.is.not.supported=No se admite el cambio de nombre de los inicializadores rápidos.
swift.name.rename.self.is.not.supported=No se admite cambiar el nombre del parámetro self.
swift.name.rename.title=Cambio de nombre rápido
swift.related.rename.dialog.title=Cambiar el nombre de la declaración relacionada
swift.related.rename.dialog.description=Cambie el nombre de la declaración asociada con el siguiente nombre\:
swift.related.rename.entity.name=Declaración relevante
swift.containing.file.rename.dialog.title=Cambiar el nombre del archivo que lo contiene
swift.containing.file.rename.dialog.description=Cambie el nombre de los archivos incluidos con los siguientes nombres\:
swift.containing.file.rename.entity.name=Archivos incluidos
generate.init.init.already.exists=El inicializador ya existe.
generate.init.choose.super.init=Seleccionar inicializador de clase principal
generate.init.choose.properties=Seleccione propiedades para inicializar
generate.0.title=Crear {0}
generate.description.single.string.template=sola cuerda
generate.description.string.concatenation.template=Varias cadenas con concatenación (+)
generate.description.multi.string.template=cadena de varias líneas
generate.template.title=Plan&tilla\:
generate.0.already.defined={0} ya está definido y {1,choice,1\#is|2\#is} ya está definido. ¿Quiere eliminar {1,choice,1\#el elemento|2\#el elemento} y continuar?
generate.equals.hash=es igual a hash
generate.equals.hash.choose.in.0=Seleccione propiedades para incluir en {0}
generate.single.expression.equals.template=expresión única
generate.if.statements.equals.template=múltiples declaraciones if
generate.cannot.generate.0.for.1=No se puede generar {0} para {1}.
generate.preparing.generation.title=Preparándonos para crear...
usage.type.type.parameter=tipo de parámetro
usage.type.extension=expansión
usage.type.requirement=Dónde usarlo en mis requisitos
usage.type.type.alias=escriba alias
usage.type.argument.label=etiqueta de argumento
usage.type.key.path=expresión de ruta clave
usage.type.function.declaration=declaración de función
usage.type.operator.declaration=declaración del operador
usage.type.precedence.group.declaration=Declaración de grupo prioritario
usage.type.raw.value=valor bruto
color.settings.keyword=Palabras clave y directivas//Palabras clave
color.settings.property=Identificador//Propiedad
color.settings.colon=Paréntesis y operadores//dos puntos
color.settings.module.name=tipo // nombre del módulo
color.settings.protocol=tipo//protocolo
color.settings.class=tipo//clase
color.settings.type.alias=tipo // escriba alias
color.settings.struct.and.enum=Tipos//Estructuras y Enumeraciones
color.settings.operator.sign=Paréntesis y operadores//Símbolos de operador
color.settings.enum.case.value=Identificador//Valor de caso de enumeración
color.settings.self.and.super.keywords=Palabras clave y directivas // palabras clave 'propias' y 'super'
color.settings.function.and.method.declaration=Funciones//Declaraciones de funciones y métodos
color.settings.function.and.method.call=Funciones//Llamadas a funciones y métodos
color.settings.nested.function.declaration=Función // Declaración de función anidada
color.settings.nested.function.call=Función // Llamada a función anidada
color.settings.external.parameter.name=Identificador//Nombre del parámetro externo
color.settings.inline.closure.parameter=identificador // parámetro de cierre en línea
color.settings.anonymous.closure.parameter=identificador // parámetro de cierre anónimo
color.settings.wildcard=Identificador//Comodín
color.settings.type.parameter=tipo // parámetro genérico
color.settings.attribute.name=propiedades//nombre de la propiedad
color.settings.attribute.argument=propiedades//argumentos de propiedad
color.settings.inline.hints.type.hint=sugerencias en línea // sugerencias de tipo
color.settings.inline.hints.error.hint=Sugerencia en línea//Sugerencia de error
color.conditionally.non.compiled=Código no compilado con palabras clave y directivas//condiciones
color.settings.directive=Palabras clave y directivas//Directivas
introduce.variable.declare.with.var=&Declarar con var
introduce.variable.specify.type.explicitly=Especificar el tipo explícitamente
introduce.variable.expression.will.be.ambiguous.without.explicit.type=Sin un tipo explícito, la expresión <br/> es ambigua.
code.generation=Codigo de GENERACION
swift.create.initializer=Crear un inicializador
renaming.swift.member.elements.in.objective.c.code.is.not.supported=No se admite el cambio de nombre de los elementos miembros de Swift dentro del código Objective-C.
swift.rename=Swift - cambiar el nombre
sourcekit.inspections=Inspección del kit de origen
swift=Swift
swift.redundant.attribute.inspection=atributo duplicado
swift.rename.inheritors=Cambiar el nombre del heredero
rename.inheritors.to=Cambie el nombre del heredero a\:
swift.redundant.return.inspection=declaración duplicada
swift.unnecessary.parentheses.inspection=paréntesis innecesarios
swift.unnecessary.tuple.wrap.inspection=Alrededor de tuplas innecesarias
new.swift.type.in.a.new.file=Nuevo tipo Swift dentro de un archivo nuevo
create.new.swift.declaration=Crear una nueva declaración Swift
name.colon=nombre\:
cannot.rename.dynamic.called.values=Los nombres de los valores llamados dinámicamente no se pueden cambiar.
are.you.sure.you.want.to.reload.all.swift.modules=¿Quieres recargar todos los módulos Swift?
reload.all.swift.modules=Vuelva a cargar todos los módulos Swift
module.colon=módulo\:
reload.module=Recargar módulo
change.signature.initializer.will.conflict.with.0.in.1.2=El inicializador entra en conflicto con {0} en {1} ''{2}''
change.signature.subscript.will.conflict.with.0.in.1.2=El subíndice entra en conflicto con {0} en {1} ''{2}''
change.signature.dialog.title=Cambio de firma
change.info.return.type.label=tipo de retorno\:
change.info.name.label=nombre\:
change.info.internal.name.label=Nombre interno\:
change.info.type.label=categoría\:
change.info.optional.label=opcional\:
change.info.default.value.label=Valor por defecto\:
change.signature.target.not.found=El cursor debe colocarse en una función, inicializador o subíndice.
change.signature.processed.elements.header=Elemento cuya firma desea cambiar
change.signature.title=Cambio de firma
