add.property=프로퍼티 추가
add.property.dialog.title={0}에 프로퍼티 추가
property.name.field.label=프로퍼티 이름\:
property.type.field.label=프로퍼티 유형\:
create.property.getter.checkbox=프로퍼티 getter 생성
create.property.setter.checkbox=프로퍼티 setter 생성
add.property.to.constructors.checkbox=생성자에 프로퍼티 추가
make.property.final.checkbox=프로퍼티 final 생성
initialization.expression.checkbox=표현식 초기화(선택 사항)\:
cannot.perform.the.refactoring=리팩토링을 수행할 수 없습니다.
refactor.j.is.not.licensed=Refactor-J에는 라이선스가 없습니다.
the.caret.should.be.positioned.in.the.class.to.add.to.property.to=캐럿은 프로퍼티를 추가할 클래스에 위치해야 합니다.
class.to.be.add.property.to=프로퍼티를 추가할 클래스
constructor.calls.to.be.updated.view.descriptor=업데이트할 생성자 호출 {0}
unable.to.find.the.requested.class=요청된 클래스를 찾을 수 없습니다.
no.class.found=클래스를 찾을 수 없습니다.
search.for.class.text=클래스 검색
search.for.class.family.name=클래스 검색
add.global.library=라이브러리 종속성 추가
global.library.source=전역 라이브러리\: {0}
add.module.dependency=모듈 종속성 추가
module.source=모듈\: {0}
project.library.source=프로젝트 라이브러리\: {0}
add.project.library=라이브러리 종속성 추가
class.found.column.header=발견된 클래스
source.column.header=소스
action.column.header=조치
class.search.results.title=클래스 검색 결과
extract.class.title=위임자를 추출합니다.
extract.class.from.label={0}에서 위임자 추출
name.for.new.class.label=새 클래스 이름(&N)\:
choose.destination.package.label=대상 패키지 선택
package.for.new.class.label=패키지 이름(&P)\:
name.for.wrapper.class.label=클래스 이름\:
package.for.wrapper.class.label=패키지 이름\:
members.to.extract.label=추출할 멤버(&B)
generate.array.access.methods.title=배열 액세스 메소드를 생성할 멤버 선택
generate.collection.access.methods.title=컬렉션 액세스 메소드를 생성할 멤버 선택
generate.array.methods.undo.string=배열 메소드 생성
generate.collection.methods.undo.string=컬렉션 메소드 생성

there.already.exists.a.class.with.the.chosen.name=선택한 이름의 클래스가 이미 존재합니다.
introduce.parameter.object=매개변수 오브젝트 소개
introduce.type.parameter=유형 매개변수 삽입
the.caret.should.be.positioned.at.on.a.type.to.be.parameterized=캐럿은 매개변수화될 유형에 위치해야 합니다.
type.selected.is.not.in.class.context=선택한 유형이 클래스 컨텍스트에 없습니다.
type.parameters.can.not.be.introduced.as.type.parameters=유형 매개변수는 유형 매개변수로 삽입될 수 없습니다.
primitive.types.can.not.be.introduced.as.type.parameters=기본 유형은 유형 매개변수로 삽입될 수 없습니다.
conflicts.found=발견된 충돌
there.are.non.genericizable.instances.of.the.type.you.selected=선택한 형식의 인스턴스 중 일반화할 수 없는 인스턴스가 있습니다.\n
do.you.wish.to.continue=계속하시겠습니까?
introduce.type.parameter.title=유형 매개변수 삽입
name.for.new.type.parameter.label=새 유형 매개변수 이름\:
the.caret.should.be.positioned.within.a.class.to.be.refactored=캐럿이 리팩토링할 클래스 내부에 위치해야 합니다.
push.javadoc.down=Javadoc을 아래로 이동
the.selected.class.is.an.enumeration=선택한 클래스는 열거형입니다.
the.selected.class.has.no.overridden.methods.with.javadoc=선택한 클래스에는 javadoc으로 재정의된 메소드가 없습니다.
push.javadoc.down.title=Javadoc을 아래로 이동
replace.existing.comments.checkbox=기존 주석 교체
use.inheritdoc.comments=@inheritdoc 주석 사용
push.javadoc.down.from.label=다음에서 Javadoc을 아래로 이동\:
methods.to.copy.javadoc.from=다음에서 javadoc을 복사할 메소드
remove.property=프로퍼티 제거
the.caret.should.be.positioned.at.on.a.property.to.be.removed=캐럿은 제거될 프로퍼티에 위치해야 합니다.
remove.property.getter.checkbox=프로퍼티 getter 제거
remove.property.setter.checkbox=프로퍼티 setter 제거
remove.property.title=프로퍼티 제거
remove.property.border=프로퍼티 {0} 제거
replacement.expression.label=표현식 교체(선택 사항)\:
remove.middleman=Middleman 제거
the.caret.should.be.positioned.at.the.name.of.the.field.to.be.refactored=캐럿이 리팩토링할 필드 이름에 위치해야 합니다.
field.selected.is.not.used.as.a.delegate=선택한 필드는 위임자로 사용되지 않습니다.
wrap.return.value=반환값 줄 바꿈
the.caret.should.be.positioned.at.the.name.of.the.method.to.be.refactored=캐럿은 리팩토링할 메소드의 이름, 매개변수 목록 내부 또는 메소드 호출 내부에 위치해야 합니다.
method.selected.returns.void=선택한 메소드는 'void'를 반환합니다.
constructor.returns.can.not.be.wrapped=생성자 반환은 래핑될 수 없습니다.
wrap.return.value.title=반환값 줄 바꿈
the.caret.should.be.positioned.at.an.annotation.to.be.refactored.to.be.refactored=캐럿이 리팩토링할 어노테이션에 위치해야 합니다.
pull.annotation.up=어노테이션 위로 이동
pull.annotation.up.title=어노테이션 위로 이동
replace.existing.annotations.checkbox=기존 어노테이션 교체
pull.up.annotation.from.label={0}에서 어노테이션을 위로 이동할 위치\:
pull.javadoc.up.title=Javadoc 위로 이동
pull.up.javadoc.from.label={0}의 javadoc을 위로 이동할 위치\:
methods.to.pull.up.javadoc.from.panel=다음에서 javadoc을 위로 이동할 메소드
remove.type.parameter=유형 매개변수 제거
the.caret.should.be.positioned.at.the.name.of.the.type.parameter.to.be.refactored=캐럿이 리팩토링할 유형 매개변수 이름에 위치해야 합니다.
type.parameter.selected.extends.multiple.types=선택한 유형 매개변수는 여러 형식을 확장합니다.
type.parameter.question.label=유형 매개변수 {0} 및 관련된 모든 사용을 제거하시겠습니까?
method.to.wrap.returns.from.label=반환을 줄 바꿈할 메소드\:
method.whose.return.are.to.wrapped=내부 반환을 줄 바꿈할 메소드
references.to.be.modified.usage.view=수정할 참조 {0}
reference=참조
type.parameter.to.be.remove=제거할 유형 매개변수
references.to.be.changed.usage.view=변경할 참조 {0}
references.to.be.made.removed.usage.view=생성할 참조가 {0}(을)를 제거했습니다.
property.to.be.removed=제거할 프로퍼티
remove.middleman.field.header=middleman 필드 제거\:
references.to.expose.usage.view=노출할 참조 {0}
retain.all.delegating.methods.radio.button=모든 위임 메소드 보존
remove.middleman.title=Middleman 제거
delete.all.delegating.methods.radio.button=모든 위임 메소드 삭제
field.label=필드 {0}
delete.delegating.methods.border=위임 메소드 삭제
make.class.inner.title=클래스를 내부 클래스로 만들기
make.class.an.inner.class.border={0} 클래스를 내부 클래스로 만들기
outer.class.label=외부 클래스\:
choose.destination.class.label=대상 클래스 선택
add.property.command={0} 프로퍼티를 {1}에 추가
refactor=리팩토링
preview=미리보기
wrapped.return.command.name=\ {1}{2}{3}()에 대해 {0}(으)로 래핑된 반환
split.loop.text=루프 분할
split.loop.family.name=루프 분할
removed.type.parameter.from.class.command.name={1} 클래스에서 제거된 유형 매개변수 {0}
removed.type.parameter.from.method.command.name={1}() 메소드에서 제거된 유형 매개변수 {0}
remove.property.command.name=프로퍼티 {0} 제거
exposed.delegation.command.name={0}{1}{2}에 노출된 위임자
push.up.javadoc.command.name=Javadoc 위로 이동
javadoced.class=Javadoc에서 생성된 클래스
superclass.methods.to.be.javadoced=Javadoc에서 생성된 상위 클래스
push.annotation.down=어노테이션 아래로 이동
0.refactor.j.is.not.licensed={0}Refactor-J에는 라이선스가 없습니다.
0.the.caret.should.be.positioned.at.an.annotation.to.be.refactored.to.be.refactored={0}캐럿이 리팩토링할 어노테이션에 위치해야 합니다.
push.down.annotation.command.name=어노테이션 아래로 이동
annotation=어노테이션
subclass.elements.to.be.annotated=어노테이션 처리할 하위 클래스 요소
push.annotation.down.title=어노테이션 아래로 이동
pull.up.annotation.command.name=어노테이션 위로 이동
superclass.elements.to.be.annotated=어노테이션 처리할 상위 클래스 요소
pull.javadoc.up=Javadoc 위로 이동
pull.up.javadoc.command.name=Javadoc 위로 이동
merge.loops.text=루프 병합
merge.loops.family.name=루프 병합
make.class.inner=클래스를 내부 클래스로 만들기
the.caret.should.be.positioned.at.on.a.class.to.be.made.into.an.inner.class=캐럿은 내부 클래스로 만들어질 클래스에 위치해야 합니다.
only.outer.classes.and.static.inner.classes.may.be.made.inner=외부 클래스 및 정적 내부 클래스만이 내부 클래스로 만들어질 수 있습니다.
a.class.can.not.be.made.an.inner.class.of.itself=클래스는 자체의 내부 클래스로 만들어질 수 없습니다.
a.class.can.not.be.made.an.inner.class.of.one.of.it.s.decendents=클래스는 하위 클래스의 내부 클래스로 만들어질 수 없습니다.
make.class.inner.command.name={0} 클래스를 {1} 클래스 내부로 이동
invert.boolean=부울 반전
the.caret.should.be.positioned.at.the.name.of.the.variable.or.parameter.to.be.refactored=캐럿이 리팩토링할 변수 또는 매개변수 이름에 위치해야 합니다.
variable.selected.is.not.boolean=선택한 변수는 부울이 아닙니다.
invert.boolean.title=부울 반전
do.you.wish.to.invert.all.uses.of.variable={0} 변수의 모든 사용을 반전하시겠습니까?
parameter.selected.is.not.boolean=선택한 매개변수는 부울이 아닙니다.
do.you.wish.to.invert.all.uses.of.parameter={0} 매개변수의 모든 사용을 반전하시겠습니까?
invert.parameter.command.name=반전된 {0}({1})
invert.variable.command.name=반전된
variable.to.be.inverted=반전할 변수
references.to.be.inverted.0=반전될 참조 {0}
parameterize.class.radio.button=매개변수화된 클래스 {0}
parameterize.method.radio.button=매개변수화된 메소드 {0}()
genericize.uses.border={0} 사용 일반화
introduced.type.parameter.command.name={1} 클래스에 매개변수로 삽입된 유형 {0}
type.parameter.to.be.introduced=삽입할 유형 매개변수
class.references.to.be.made.inner=내부 클래스로 만들 클래스 참조
references.to.be.made.inner.usage.view=내부 클래스로 만들 참조 {0}
control.flow.category=제어 흐름
other.category=기타
genericize.uses.in.border={1}의 {0} 사용 일반화
extract.class=클래스 추출
the.selected.class.is.an.interface=선택한 클래스는 인터페이스입니다.
the.selected.class.is.an.annotation.type=선택한 클래스는 어노테이션 유형입니다.
the.refactoring.is.not.supported.on.non.static.inner.classes=리팩토링은 비 'static' 내부 클래스에서 지원되지 않습니다.
the.selected.class.has.no.members.to.extract=선택한 클래스에는 추출할 멤버가 없습니다.
references.to.extract=추출할 참조
extracting.from.class=클래스에서 추출\:
extracted.class.command.name=추출된 클래스 {0}
method.to.extract.parameters.from.label=다음에서 매개변수를 추출하는 메소드
name.for.new.parameter.label=새 매개변수 이름\:
method.selected.has.no.parameters=선택한 메소드에는 매개변수가 없습니다.
parameters.to.extract.border=추출할 매개변수
parameter=매개변수
your.evaluation.license.for.refactor.j.will.expire.in.less.than.n.days=Refactor-J 평가 라이선스 만료일까지 {0}일이 남았습니다.\n
refactor.j.licensed.to=라이선스를 얻은 Refactor-J\:
can.only.pull.annotations.up.on.methods.parameters.and.classes=메소드, 매개변수 및 클래스에서만 어노테이션을 위로 이동할 수 있습니다
can.not.find.any.available.superclasses.for.the.selected.class=선택한 클래스에 사용 가능한 상위 클래스를 찾을 수 없습니다.
can.not.find.any.available.super.methods.for.the.selected.method=선택한 메소드에 사용 가능한 상위 메소드를 찾을 수 없습니다.
can.only.push.annotations.down.on.methods.parameters.and.classes=메소드, 매개변수 및 클래스에서만 어노테이션을 아래로 이동할 수 있습니다.
can.not.find.any.available.subclasses.for.the.selected.class=선택한 클래스에 사용 가능한 하위 클래스를 찾을 수 없습니다.
can.not.find.any.available.overriding.methods.for.the.selected.method=선택한 메소드에 사용 가능한 재정의 메소드를 찾을 수 없습니다.
delete.selected.annotation.checkbox=선택한 어노테이션 삭제
push.annotation.down.from.label=다음에서 어노테이션을 아래로 이동\:
there.already.exists.an.incompatible.class.with.the.chosen.name=선택한 이름의 호환 불가 클래스가 이미 존재합니다.
weaken.type=유형 약화
weaken.type.label={1}의 ''{0}'' 유형을 다음으로 약화\:
weaken.type.command.name=유형 약화
weaken.type.refactoring.is.not.supported.for.primitive.types=유형 리팩토링 약화는 기본 유형에 지원되지 않습니다.
weaken.type.refactoring.is.not.supported.for.arrays=유형 리팩토링 약화는 배열에 지원되지 않습니다.
weaken.type.refactoring.is.not.supported.for.type.parameters=유형 리팩토링 약화는 유형 매개변수에 지원되지 않습니다.
invalid.type.for.weaken.type.refactoring=유형 리팩토링 약화에 유효하지 않은 유형
weaken.type.refactoring.is.not.supported.for.constructors=유형 리팩토링 약화는 생성자에 지원되지 않습니다.
the.selected.type.cannot.be.weakened=선택한 유형은 약화될 수 없습니다.
the.selected.type.cannot.be.weakened.because.the.method.is.declared.in.a.non.project.class=메소드가 비 project 클래스에서 선언되므로 선택한 유형은 약화될 수 없습니다.
the.selected.method.cannot.be.wrapped.because.it.is.defined.in.a.non.project.class=비 project 클래스에서 선언되므로 선택한 메소드는 래핑될 수 없습니다.
existing.wrapper.class.label=기존 매개변수 클래스 사용
select.wrapper.class=매개변수 클래스 선택
could.not.find.selected.wrapping.class=선택한 래핑 클래스를 찾을 수 없습니다.
there.already.exists.a.class.with.the.selected.name=선택한 이름의 클래스가 이미 존재합니다.
pull.annotation.up.from.label=다음에서 어노테이션을 위로 이동\:
convert.equality.disjunction.to.set.contains=상등 논리합을 Set.contains()로 변환
convert.to.set.contains=Set.contains()로 변환
the.caret.should.be.positioned.at.the.name.of.the.variable.parameter.or.method.to.be.refactored=캐럿이 리팩토링할 변수, 매개변수 또는 메소드 이름에 위치해야 합니다.
convert.to.String.format=String.format으로 변환
convert.to.printf=printf로 변환
convert.to.MessageFormat.format=MessageFormat.format으로 변환
split.string=문자열 분할
copy.javadoc.to.inheritors=Javadoc을 상속자에 복사
copy.javadoc.to.ancestors=Javadoc을 상위 요소에 복사
