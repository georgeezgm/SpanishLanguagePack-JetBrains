jvm.inspections.group.name=JVM 언어

jvm.inspections.unstable.api.usage.display.name=불안정한 API 사용
jvm.inspections.unstable.api.usage.annotations.list=불안정한 API 어노테이션:
jvm.inspections.unstable.api.usage.ignore.inside.imports=import 문 내에서 무시
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=이 프로젝트에서 선언된 API 무시
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}''이(가) @{1}에서 불안정한 것으로 표시됩니다.
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}''이(가) @{3}(으)로 표시된 불안정한 {1} ''{2}''에서 선언되었습니다.
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=재정의된 메서드 ''{0}''이(가) @{1}에서 불안정한 것으로 표시됩니다.
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=재정의된 메서드 ''{0}''이(가) @{3}(으)로 표시된 불안정한 {1} ''{2}''에서 선언되었습니다.
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}''이(가) @{3}(으)로 표시된 불안정한 {1} ''{2}''을(를) 해당 시그니처에서 참조하고 있으므로 불안정합니다

jvm.inspections.scheduled.for.removal.future.version=향후 버전
jvm.inspections.scheduled.for.removal.predefined.version=버전 {0}
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}''은(는) {1}에서 제거될 예정입니다.
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}''이(가) {3}에서 제거될 예정인 {1} ''{2}''에서 선언되었습니다.
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=재정의된 메서드 ''{0}''은(는) {1}에서 제거될 예정입니다.
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=재정의된 메서드 ''{0}''이(가) {3}에서 제거될 예정인 {1} ''{2}''에서 선언되었습니다.
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}''이(가) {3}에서 제거될 예정인 {1} ''{2}''을(를) 해당 시그니처에서 참조하고 있으므로 제거될 예정입니다

jvm.inspections.unstable.type.used.in.signature.display.name=불안정한 타입이 시그니처에서 사용됨
jvm.inspections.unstable.type.used.in.class.signature.description=클래스가 해당 선언에서 불안정한 타입 ''{1}''을(를) 참조하고 있으므로 ''@{0}'' 어노테이션으로 표시되어야 합니다.
jvm.inspections.unstable.type.used.in.method.signature.description=메서드가 불안정한 타입 ''{1}''을(를) 해당 시그니처에서 참조하고 있으므로 ''@{0}'' 어노테이션으로 표시되어야 합니다
jvm.inspections.unstable.type.used.in.field.signature.description=필드가 불안정한 타입 ''{1}''을(를) 해당 타입에서 참조하고 있으므로 ''@{0}'' 어노테이션으로 표시되어야 합니다.

jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=제거 예정인 API에서 누락된 '@Deprecated' 어노테이션
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=제거 예정인 API도 '@Deprecated' 어노테이션으로 표시되어야 합니다.
jvm.inspections.must.already.be.removed.api.display.name=API가 이미 제거되었습니다.
jvm.inspections.must.already.be.removed.api.earlier.version.description=API가 {0}에서 제거되었으나 현재 버전은 {1}입니다.
jvm.inspections.must.already.be.removed.api.current.version.description=API가 현재 버전 {0}에서 제거되었습니다.
jvm.inspections.blocking.method.problem.descriptor=비 블로킹 컨텍스트에서 호출을 막는 것은 스레드에서 기아 상태를 일으킬 수 있습니다
jvm.inspections.blocking.method.display.name=비 블로킹 컨텍스트의 잠재적 블로킹 호출
jvm.inspections.blocking.method.annotation.blocking=Blocking 어노테이션
jvm.inspections.blocking.method.annotation.non-blocking=Non-Blocking 어노테이션
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=Blocking 어노테이션 추가
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=Non-Blocking 어노테이션 추가
jvm.inspections.blocking.method.annotation.configure.empty.text=추가된 어노테이션이 없습니다.

jvm.inspections.api.no.extension.display.name=클래스, 인터페이스 또는 메서드가 확장되면 안 됨
jvm.inspections.api.no.extension.class.description=클래스 ''{0}''은(는) 확장되면 안 됩니다.
jvm.inspections.api.no.extension.interface.implement.description=인터페이스 ''{0}''은(는) 구현되면 안 됩니다.
jvm.inspections.api.no.extension.interface.extend.description=인터페이스 ''{0}''은(는) 확장되면 안 됩니다.
jvm.inspections.api.no.extension.method.overriding.description=메서드 ''{0}''은(는) 재정의되면 안 됩니다.
jvm.inspections.api.override.only.display.name=메서드는 재정의만 가능
jvm.inspections.api.override.only.description=메서드 ''{0}''은(는) 재정의만 가능합니다.

jvm.inspections.dependency.display.name=잘못된 패키지 종속성
jvm.inspections.dependency.edit.rules.text=종속성 규칙 "{0}" 편집
jvm.inspections.dependency.edit.rules.family=종속성 규칙 편집
jvm.inspections.dependency.configure.button.text=종속성 규칙 구성
jvm.inspections.dependency.violator.problem.descriptor=종속성 규칙 ''{0}.''이(가) 위반되었습니다

jvm.inspections.junit.rule.display.name=형식이 잘못된 @Rule/@ClassRule 필드
jvm.inspections.junit.rule.problem.descriptor=''@{0}''(으)로 어노테이션이 추가된 필드는 {1}이어야(여야) 합니다
jvm.inspections.junit.rule.type.problem.descriptor=필드 타입은 'org.junit.rules.TestRule'의 하위 타입이어야 합니다

jvm.inspections.testonly.display.name=프로덕션 코드 내 테스트 전용 사용 위치
jvm.inspections.testonly.class.reference=테스트 전용 클래스가 프로덕션 코드에서 참조됩니다
jvm.inspections.testonly.field.reference=테스트 전용 필드가 프로덕션 코드에서 참조됩니다
jvm.inspections.testonly.method.call=테스트 전용 메서드가 프로덕션 코드에서 호출됩니다
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting은 @TestOnly 코드에서 의미가 없습니다

jvm.inspections.string.touppercase.tolowercase.without.locale.description=국제화된 문자열을 사용하는 로케일을 지정하지 않은 상태에서 <code>String.{0}()</code>이(가) 호출됩니다 #loc
can.t.build.uast.tree.for.file=파일에 대한 UAST 트리를 빌드할 수 없습니다.
title.uast=UAST
current.version=현재 버전
dialog.title.choose.annotation={0} 선택 
jvm.inspection.test.failed.line.display.name=테스트에서 실패한 줄
jvm.inspections.source.to.sink.flow.display.name=안전하지 않은 문자열이 안전한 메서드로 전달됨
jvm.inspections.junit5.assertions.converter.display.name=JUnit 5 테스트에서 곧 사용할 수 없게 될 어설션
jvm.inspections.junit5.assertions.converter.problem.descriptor=''{0}''의 <code>#ref()</code> 호출을 ''{1}''의 메서드 호출로 바꿔야 합니다 #loc
jvm.inspections.junit5.assertions.converter.quickfix=''{0}'' 메서드 호출로 바꿉니다
jvm.inspections.junit5.assertions.converter.familyName=JUnit 5 호환 호출로 바꾸기
jvm.inspections.junit5.converter.display.name=JUnit 4 테스트가 JUnit 5가 될 수 있음
jvm.inspections.junit5.converter.problem.descriptor=#ref이(가) JUnit 5 테스트일 수 있습니다
jvm.inspections.junit5.converter.quickfix=JUnit 5로 마이그레이션
jvm.inspections.junit5.converter.quickfix.presentation.text=어설션 변환
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=호환되지 않는 상속자가 있으므로 클래스 {0}을(를) JUnit 5로 변환할 수 없습니다. {1}
jvm.inspections.thread.run.display.name='Thread.run()' 호출
jvm.inspections.serializable.class.without.serialversionuid.display.name='serialVersionUID'가 없는 serializable 클래스
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code>이(가) 'serialVersionUID' 필드를 정의하지 않습니다 #loc
jvm.inspections.source.to.sink.flow.passed.unsafe=안전하지 않은 문자열이 안전한 매개변수로 사용됨
jvm.inspections.source.to.sink.flow.passed.unknown=알 수 없는 문자열이 안전한 매개변수로 사용됨
jvm.inspections.source.to.sink.flow.returned.unsafe=안전하지 않은 문자열이 안전한 메서드에서 반환됨
jvm.inspections.source.to.sink.flow.returned.unknown=알 수 없는 문자열이 안전한 메서드에서 반환됨
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=검증 필요로 표시
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=''{0}''을(를) 검증 필요로 표시
jvm.inspections.blocking.method.consider.unknown.context.blocking=알 수 없는 컨텍스트를 블로킹으로 고려
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=안전한 어노테이션 전달
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=''{0}''(으)로부터 안전한 어노테이션 전달
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=안전하다고 어노테이션을 추가할 멤버 선택
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=제외된 것만 빼고 모두 어노테이션 추가
propagated.from=안전하다고 표시할 사유:
propagated.to=안전하다고 표시할 대상:
propagate.from.empty.text=안전함으로 표시할 사유가 여기에 표시됩니다
propagate.to.empty.text=안전함으로 표시할 대상이 여기에 표시됩니다
jvm.inspections.blocking.method.problem.wildcard.descriptor={0}에서 호출을 블로킹하면 스레드에서 기아 상태를 일으킬 수 있습니다
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=안전하지 않은 흐름
jvm.inspections.source.to.sink.flow.assigned.unsafe=안전하지 않은 문자열이 안전한 변수에 대입됨
jvm.inspections.source.to.sink.flow.assigned.unknown=알 수 없는 문자열이 안전한 변수에 대입됨
jvm.inspections.source.to.sink.flow.common.unsafe=안전하지 않은 문자열이 안전한 컨텍스트에 사용됨
jvm.inspections.source.to.sink.flow.common.unknown=알 수 없는 문자열이 안전한 컨텍스트에 사용됨
jvm.inspections.api.display.name=구성된 언어 수준에서 사용할 수 없는 API 사용
jvm.inspections.1.5.problem.descriptor=@since {0}+로 기록된 API 사용
jvm.inspections.1.7.problem.descriptor=JDK {0}에 컴파일 문제를 일으킬 수 있는 1.6 이후에 일반화된 API 사용
jvm.inspections.1.8.problem.descriptor=디폴트 {0, choice, 0#|1#메서드가|2#메서드가} 재정의되지 않았습니다. JDK {1)에 컴파일 문제를 일으킬 수 있습니다.
jvm.inspections.1.8.problem.single.descriptor=디폴트 메서드 ''{0}''이(가) 재정의되지 않았습니다. 이로 인해 JDK {1}에 컴파일 문제가 발생할 수 있습니다
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=검증 필요로 표시
jvm.inspections.source.unsafe.to.sink.flow.preview.multiple.files={0}에 ''@Untainted'' 어노테이션 추가
jvm.inspections.dependency.on.internal.display.name=내부 패키지에 유효하지 않은 종속 요소
inspection.message.illegal.dependency.module.doesn.t.export=유효하지 않은 종속 요소: 모듈 ''{0}''은(는) 패키지 ''{1}''을(를) 내보내지 않습니다