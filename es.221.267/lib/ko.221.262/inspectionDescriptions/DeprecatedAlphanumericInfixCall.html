<html>
<body>
<p>'infix' 제어자를 infix 연산자로 포함하지 않는 영숫자 정의의 사용 위치를 보고합니다.</p>

<ul>
<li>"백틱(')에 랩" 빠른 수정은 호출 주위로 <code>'</code> 기호를 추가합니다.</li>
<li>"infix 표현식에서 변환" 빠른 수정은 infix 호출을 <code>.method(...)</code> 메서드 구문으로 변환합니다.</li>
<li>"infix 표현식에서 변환" 빠른 수정은 infix 호출을  <code>Type[...]</code> 접두사 구문으로 변환합니다.</li>
<li>"infix 패턴에서 변환" 빠른 수정은 infix 호출을 <code>pattern(...)</code> 접두사 구문으로 변환합니다.</li>
</ul>

<p><b>예:</b></p>
<pre><code>
  class C:
    def op(x: Int): Int = ???
  type Or[X, Y]
  case class Pair[T](x: T, y: T)

  val c = C()
  val p = Pair(1, 2)

  c op 2
  val or: Int Or String = ???
  val _ Pair _ = p
</code></pre>

<p>"백틱에 랩" 빠른 수정 적용 후:</p>
<pre><code>
  class C:
    def op(x: Int): Int = ???
  type Or[X, Y]
  case class Pair[T](x: T, y: T)

  val c = C()
  val p = Pair(1, 2)

  c 'op' 2
  val or: Int 'Or' String = ???
  val _ 'Pair' _ = p
</code></pre>

<p>"infix 표현식으로부터 변환" 빠른 수정 적용 후:</p>
<pre><code>
  class C:
    def op(x: Int): Int = ???
  type Or[X, Y]
  case class Pair[T](x: T, y: T)

  val c = C()
  val p = Pair(1, 2)

  c.op(2)
  val or: Int Or String = ???
  val _ Pair _ = p
</code></pre>

<p>"infix 유형으로부터 변환" 빠른 수정 적용 후:</p>
<pre><code>
  class C:
    def op(x: Int): Int = ???
  type Or[X, Y]
  case class Pair[T](x: T, y: T)

  val c = C()
  val p = Pair(1, 2)

  c op 2
  val or: Or[Int, String] = ???
  val _ Pair _ = p
</code></pre>

<p>"infix 패턴으로부터 변환" 빠른 수정 적용 후:</p>
<pre><code>
  class C:
    def op(x: Int): Int = ???
  type Or[X, Y]
  case class Pair[T](x: T, y: T)

  val c = C()
  val p = Pair(1, 2)

  c op 2
  val or: Int Or String = ???
  val Pair(_, _) = p
</code></pre>
<!-- tooltip end -->
</body>
</html>
