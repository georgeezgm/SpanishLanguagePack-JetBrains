0.already.contains.field.1={0}에 필드 {1}이(가) 이미 포함되어 있습니다
0.already.contains.inner.class.named.1=이름이 {1}인 내부 클래스가 {0}에 이미 포함되어 있습니다
0.already.has.parameter.named.1.use.this.name.anyway=이름이 ''{1}''인 매개변수가 {0}에 이미 있습니다.\n\
그래도 이 이름을 사용하시겠어요?
0.contains.call.with.null.argument.for.parameter.1={0}에는 매개변수 {1}의 null 인수가 있는 호출이 포함되어 있습니다
0.implements.1={0} 은(는) {1}을(를) 구현합니다.
0.is.1.and.will.not.be.accessible.from.2.in.the.target.class={0} 은(는) {1}이며 {2}에서 액세스할 수 없습니다.
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.parameters={0} 은(는) 메서드 계층 구조의 일부입니다. 여러 매개변수를 삭제하시겠어요?
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.type.parameters={0} 은(는) 메서드 계층 구조의 일부입니다. 여러 유형 매개변수를 삭제하시겠어요?
0.is.an.interface.method.implementation.will.be.added.to.all.directly.implementing.classes={0} 은(는) 인터페이스입니다. \n\
메서드 구현은 모든 구현 클래스에 바로 추가됩니다.\n\
 진행하시겠어요?
0.is.an.interface.that.has.no.implementing.classes={0} 은(는) 구현 클래스가 없는 인터페이스입니다
0.is.not.a.legal.java.identifier=''{0}''은(는) 정규 Java 식별자가 아닙니다
0.is.not.accessible.from.1.value.for.introduced.parameter.in.that.method.call.will.be.incorrect={1}에서 {0}에 액세스할 수 없습니다. 해당 메서드 호출에 삽입된 매개변수의 값이 올바르지 않습니다.
0.is.not.initialized.in.declaration.such.fields.are.not.allowed.in.interfaces={0}이(가) 선언에서 초기화되지 않습니다. 이러한 필드는 인터페이스에서 허용되지 않습니다.
0.is.not.static.it.cannot.be.moved.to.the.interface={0}이(가) 정적이지 않습니다. 인터페이스로 이동시킬 수 없습니다.
0.is.used.for.writing.in.1={0} 은(는) {1}에서 쓰기에 사용됩니다
0.or.all.directories.in.project={0} 또는 프로젝트의 모든 디렉터리?
0.refactoring.is.supported.only.for.final.fields={0} 리팩터링은 final 필드에만 지원됩니다
0.upcasts.an.instance.of.1.to.2={0} 은(는) {1}의 인스턴스를 {2}(으)로 업캐스트합니다
0.uses.1.of.an.instance.of.a.2={0} 은(는) {2}의 인스턴스의 {1}을(를) 사용합니다
0.uses.1.which.needs.class.instance={0} uses {1},which needs class instance
0.uses.a.package.local.1={0} 은(는) 패키지 프라이빗 {1}을(를) 사용합니다
0.uses.non.static.1.which.is.not.passed.as.a.parameter={0} uses non-static {1},which is not passed as a parameter
0.will.be.inaccessible.from.1={1}에서 {0}에 액세스할 수 없게 됩니다
0.will.become.inaccessible.from.1={1}에서 {0}에 액세스할 수 없게 됩니다
0.will.hide.renamed.1={0} 은(는) 이름 변경된 {1}을(를) 숨깁니다
0.will.no.longer.override.1={0}이(가) {1}을(를) 더 이상 재정의하지 않습니다
0.will.not.be.accessible.from.1.after.inlining=인라인화하면 {1}에서 {0}에 액세스할 수 없게 됩니다
0.will.override.renamed.1={0} 은(는) 이름 변경된 {1}을(를) 재정의합니다
a.package.local.class.0.will.no.longer.be.accessible.from.1={1}에서 패키지 로컬 클래스 {0}에 더 이상 액세스할 수 없습니다
accept.signature.change=시그니처 변경 수락
add.object.as.a.parameter.to.constructors.with.name=객체를 다음 이름의 생성자에 추가(&O)\:
add.parameters.for.fields=필드 매개변수 추가(&F)\:
add.parameters.for.fields.to.constructors=필드 매개변수를 생성자에 추가(&F)\:
all.candidate.variables.have.types.not.in.project=모든 후보 변수는 프로젝트에 없는 유형을 포함합니다.
all.candidate.variables.have.unknown.types=모든 후보 변수는 알 수 없는 유형을 포함합니다.
all.invocations.keep.the.method=전체 인라인화 및 메서드 유지(&E)
all.references.and.remove.super.class=전체 참조 인라인화 및 클래스 제거(&A)
all.references.and.remove.the.class=전체 참조 인라인화 및 클래스 제거(&A)
all.references.and.remove.the.field=전체 인라인화 및 필드 제거(&A)
all.references.keep.field=전체 인라인화 및 필드 유지(&E)
all.these.directories.will.be.moved.and.all.references.to.0.will.be.changed=All these directories will be moved,and all references to {0} \n\
will be changed.
analyze.and.replace.usages=사용 위치 분석 및 바꾸기
analyze.module.conflicts=모듈 충돌 분석...
annotate.field.as.nonnls.checkbox=@NonNls로 필드에 어노테이션 추가(&F)
anonymous.class.text=익명 클래스
anonymous.to.inner.enum.constant.cannot.refactor.message=열거형 상수는 내부 클래스로 변환될 수 없습니다.
anonymousToInner.class.name.label.text=클래스 이름\:
anonymousToInner.make.class.static.checkbox.text=클래스를 정적으로 설정(&S)
anonymousToInner.no.inner.class.name=클래스 이름을 지정해야 합니다.
anonymousToInner.parameters.panel.border.title=생성자 매개변수
anonymousToInner.refactoring.name=익명을 내부로 변환
auto.rename.module.dialog.description=다음 이름을 가진 Java 모듈의 이름 변경\:
auto.rename.module.dialog.title=Java 모듈 이름 변경
auto.rename.module.entity=Java 모듈
boolean.method.result=부울 메서드 결과
can.t.restore.context.for.method.extraction=메서드 추출 컨텍스트를 복원할 수 없습니다.
cannot.find.or.create.destination.directory=대상 디렉터리를 찾거나 생성할 수 없습니다.
cannot.introduce.field.in.interface=인스턴스 필드가 인터페이스에서 허용되지 않습니다.
cannot.introduce.field.in.record=인스턴스 필드가 기록에서 허용되지 않습니다.
cannot.move=No se puede mover
cannot.move.inner.class.0.into.itself=내부 클래스 {0}을(를) 자체 내로 이동할 수 없습니다
cannot.move.package.into.itself=패키지를 자체로 이동할 수 없습니다.
cannot.replace.temp.with.query.in.interface=인터페이스에서 임시를 쿼리로 바꿀 수 없습니다.
caret.position.warning.message=캐럿은 리팩터링할 필드, 변수, 메서드 또는 메서드 매개변수의 유형에 있어야 합니다.
change.method.signature.action.name=메서드 시그니처 변경
change.signature.default.value.missing.warning.message=디폴트 값이 없습니다. 메서드 호출에 새로운 매개변수 값 대신 공백이 포함됩니다.
change.signature.use.any.checkbox=임의의 변수 사용(&U)
changeClassSignature.bad.value=잘못된 {0} 값\: 매개변수 ''{2}''의 ''{1}''
changeClassSignature.class.label.text={0}의 시그니처 변경
changeClassSignature.no.type.parameters=클래스는 유형 매개변수를 가질 수 없습니다.
changeClassSignature.parameters.panel.border.title=매개 변수
changeClassSignature.refactoring.name=클래스 시그니처 변경
changeClassSignature.already.contains.type.parameter=''{0}''에 유형 매개변수 ''{1}''이(가) 이미 있습니다
changeClassSignature.Type.parameter.can.not.be.primitive=유형 매개변수는 기본일 수 없습니다
changeSignature.bound.value.column=바운드 값\:
changeSignature.cannot.resolve.return.type=반환 유형 ''{0}''을(를) 해결할 수 없습니다.\n\
계속하시겠어요?
changeSignature.default.value.column=디폴트 값\:
changeSignature.exception.caller.chooser=새 예외를 전달할 메서드 선택
changeSignature.exceptions.panel.border.title=예외
changeSignature.exceptions.wont.propagate=예외 변경 내용의 재귀적 전달이 수행되지 않습니다.
changeSignature.no.return.type=반환 유형이 지정되지 않았습니다.
changeSignature.no.type.for.exception=예외 유형 지정
changeSignature.no.type.for.parameter=매개변수 ''{1}''의 유형을 {0}(으)로 지정
changeSignature.not.throwable.type=Wrong type ''{0}'' for exception,should extend java.lang.Throwable
changeSignature.propagate.exceptions.title=예외 전달(&X)...
changeSignature.vararg.not.last=Vararg 매개변수는 메서드 시그니처의 마지막 매개변수여야 합니다
changeSignature.wrong.return.type=잘못된 반환 유형\: ''{0}''
changeSignature.wrong.type.for.exception=잘못된 유형\: 예외의 ''{0}''
changeSignature.wrong.type.for.parameter=잘못된 유형\: 매개변수 ''{1}''의 ''{0}''
changeSignature.empty.caller.method.text=피호출자 호출이 강조 표시된 호출자 메서드 텍스트가 여기에 표시됩니다
changeSignature.empty.callee.method.text=피호출자 메서드 텍스트가 여기에 표시됩니다
changeSignature.contract.converter.external.annotations=외부 어노테이션의 자동 업데이트는 지원되지 않습니다
changeSignature.contract.converter.mutation.contract=어노테이션에 변형 컨트랙트가 있습니다
changeSignature.contract.converter.definition.error=컨트랙트 정의 내 오류\: {0}
changeSignature.contract.converter.invalid.clause=잘못된 컨트랙트 절 ''{0}''
changeSignature.contract.converter.parameter.removed=매개변수 ''{0}''이(가) 삭제되었지만 컨트랙트 절 ''{1}''이(가) 해당 매개변수에 종속되어 있습니다
changeSignature.contract.converter.invalid.return.reference=반환 값 내 잘못된 참조\: {0}
changeSignature.contract.converter.return.parameter.removed=매개변수 ''{0}''이(가) 삭제되었지만 컨트랙트 절 ''{1}''이(가) 해당 매개변수를 반환합니다
changeSignature.contract.converter.can.not.update.annotation=@Contract 어노테이션은 자동으로 업데이트되지 않습니다. {0}
changeSignature.contract.converter.inherited.annotation=어노테이션은 기본 메서드에서 상속됩니다
changeSignature.use.any.var=임의의 변수를 사용합니다.
checking.conflicts=충돌 확인 중...
choose.the.ones.you.want.to.be.deleted=삭제할 항목을 선택하세요.
class.0.already.exists=클래스 {0}이(가) 이미 있습니다
class.0.is.not.accessible.from.target.1=대상 {1}에서 클래스 {0}에 액세스할 수 없습니다
class.0.not.found=클래스 {0}을(를) 찾을 수 없습니다.
class.description=클래스 {0}
class.does.not.exist.in.the.project=프로젝트에 클래스가 없습니다. 생성하시겠어요?
class.does.not.have.base.classes.or.interfaces=클래스 {0}에 기본 클래스 또는 인터페이스가 없습니다
class.does.not.have.implicit.default.constructor=클래스 {0}에 암묵적 디폴트 생성자가 없습니다
class.has.been.successfully.created=클래스 {0}이(가) 성공적으로 생성되었습니다
class.is.abstract={0} 은(는) 추상입니다.
class.is.final.warning.message={0} 클래스는 final 클래스입니다.
class.is.interface={0} 은(는) 인터페이스입니다.
class.is.never.used=클래스가 사용되지 않습니다.
class.name.prompt=클래스 이름(&N)\:
collect.overloads=오버로드 수집...
comments.elements.header=Occurrences found in comments,strings and non-code files {0}
constructor.being.refactored.is.used.in.initializer.of.0=리팩터링되는 생성자는 {0}의 이니셜라이저에서 사용됩니다. 내부 클래스 {1}의 비정적 factory는 이 컨텍스트에서 사용할 수 없습니다. 결과 코드는 컴파일되지 않습니다.
constructor.description=생성자 {0}
constructor.with.builder.new.setter.prefix.dialog.message=새로운 setter 접두사\:
constructor.with.builder.parameters.to.pass.to.the.builder.title=빌더에 전달할 매개변수
constructor.with.builder.rename.setters.prefix.action.name=setter 접두사 이름 변경
convert.anonymous.to.inner.action.name=익명을 내부로 변환...
convert.local.to.field.title=로컬을 필드로 변환
convert.to.instance.method.title=인스턴스 메서드로 변환
convertToInstanceMethod.all.reference.type.parameters.are.not.in.project=인스턴스 메서드에 대한 대상 클래스를 찾을 수 없습니다. 참조된 모든 유형이 프로젝트에 없습니다.
convertToInstanceMethod.all.reference.type.parameters.have.unknown.types=인스턴스 메서드에 대한 대상 클래스를 찾을 수 없습니다. 참조된 모든 유형을 알 수 없습니다.
convertToInstanceMethod.method.is.not.static=리팩터링을 수행할 수 없습니다\n\
메서드 {0}이(가) 정적이지 않습니다
convertToInstanceMethod.no.default.ctor=포함 클래스에 디폴트 생성자가 없습니다.
convertToInstanceMethod.no.parameters.with.reference.type=참조 유형이 있는 매개변수가 없습니다.
convert.to.record.title=레코드 클래스로 변환
convert.to.record.weakens.field.visibility={0}은(는) {1}입니다.\n\
특정 {2} 레코드 접근자를 생성하면 가시성이 약해집니다.
convert.to.record.weakens.accessor.visibility={0}은(는) {1}입니다.\n\
이 항목을 {2} 레코드 접근자로 변환하면 가시성이 약해집니다.
convert.to.record.weakens.ctor.visibility={0}은(는) {1}입니다.\n\
이 항목을 {2} 레코드 표준 접근자로 변환하면 가시성이 약해집니다.
copy.class.clone.0.1=Clonar {0} {1}
copy.class.copy.0.1={0} {1} 복사
copy.handler.clone.class=클래스 복제
copy.handler.copy.class=클래스 복사
copy.handler.copy.class.with.dialog=클래스 복사...
copy.handler.copy.classes.with.dialog=클래스 복사...
copy.handler.is.not.available.during.indexing=색인 생성 중 클래스 복사를 사용할 수 없습니다.
current.class=현재 클래스
dataflow.to.here.expand.progress=모든 노드 확장...{0}
dataflow.to.here.group.by.leaf.action.description=null이 해당 식으로 유입될 수 있는지 판단
dataflow.to.here.group.by.leaf.action.text=리프 식 Nullness{0, choice, 1\#|2\#  (Analysis in Progress)}에 따라 그룹 지정
dataflow.to.here.variable.dereferenced.tooltip=역참조된 변수
declaration.s.to.be.generified=일반화될 선언 {0}
declare.final=final 선언(&F)
declare.generated.annotations=어노테이션 생성(&G)
declare.static.checkbox=static 선언(&S)
declare.static.pass.fields.checkbox=static 선언(필드를 매개변수로 전달)(&S)
declare.var.type=var 유형 선언(&V)
declare.varargs.checkbox=vararg 선언(&A)
default.visibility.border.title=디폴트 가시성
delegating.field=위임 필드
delete.variable.declaration=변수 선언 삭제(&D)
destination.directory.does.not.correspond.to.any.package=대상 디렉터리가 패키지와 일치하지 않습니다.
destination.package=대상 패키지(&P)\:
different.name.expected=다른 이름이 필요합니다
directory.0.already.contains.1.named.2=이름이 ''{2}''인 {1}이(가) \n\
디렉터리 {0}에 이미 포함되어 있습니다
directory.0.already.contains.a.file.named.1=이름이 ''{1}''인 파일이 \n\
디렉터리 {0}에 이미 포함되어 있습니다
do.not.replace=바꾸기 안 함(&N)
do.not.show.this.message.in.the.future=이 메시지를 다시 표시 안 함(&D)
do.you.want.to.process.overriding.methods.with.covariant.return.type=공변성 반환 유형이 있는\n\
재정의 메서드를 처리하시겠어요?
dont.move.to.another.source.folder.option=다른 소스 폴더로 이동하지 않음(&D)
edit.migration.entry.title=클래스/패키지 마이그레이션 설명 편집
edit.migration.map.title=마이그레이션 맵 편집
element.will.no.longer.be.accessible={1}에서 {0}에 더 이상 액세스할 수 없습니다
encapsulate.fields..encapsulated.fields.visibility.border.title=캡슐화된 필드의 가시성
encapsulate.fields..package.local.radio=로컬 패키지(&C)
encapsulate.fields.accessors.visibility.border.title=접근자 가시성
encapsulate.fields.command.name={0}의 필드 캡슐화
encapsulate.fields.encapsulate.border.title=캡슐화
encapsulate.fields.existed.accessor.hidden=생성된 접근자로 숨겨지는 {0}이(가) 이미 있습니다
encapsulate.fields.existed.accessor.hides.generated={1}에 대한 생성된 접근자를 숨기는 {0}이(가) 이미 있습니다
encapsulate.fields.expression.type.is.used=접미사/접두사 표현식의 결과 유형이 사용되는 경우 해당 표현식을 진행할 수 없습니다
encapsulate.fields.field.column.name=필드
encapsulate.fields.fields.to.be.encapsulated=캡슐화할 필드
encapsulate.fields.fields.to.encapsulate.border.title=캡슐화할 필드
encapsulate.fields.get.access.checkbox=액세스 권한 획득(&G)
encapsulate.fields.getter.column.name=Getter
encapsulate.fields.getter.exists=getter {1} 와(과) 반환 유형만 다른 메서드 {0} 이(가) 이미 있습니다
encapsulate.fields.no.target=캡슐화할 항목이 없습니다
encapsulate.fields.nothing.todo.warning.message=클래스에 캡슐화할 필드가 없습니다.
encapsulate.fields.private.radio=비공개(&I)
encapsulate.fields.protected.radio=보호됨(&T)
encapsulate.fields.refactoring.cannot.be.applied.to.interface=필드 캡슐화 리팩터링을 인터페이스에 적용할 수 없습니다.
encapsulate.fields.set.access.checkbox=액세스 설정(&S)
encapsulate.fields.setter.column.name=Setter
encapsulate.fields.setter.exists=setter {1} 와(과) 반환 유형만 다른 메서드 {0} 이(가) 이미 있습니다
encapsulate.fields.title=필드 캡슐화
encapsulate.fields.use.accessors.even.when.field.is.accessible.checkbox=필드에 액세스할 수 있는 경우에도 접근자 사용(&U)
entity.name.constructor.parameter=매개변수
entity.name.inheritor=상속자
entity.name.test=테스트
entity.name.variable=변수
entity.name.accessor=접근자
enum.description=열거형 {0}
error.cannot.resolve={0}을(를) 해결할 수 없습니다
error.incorrect.data=Datos incorrectos
error.not.supported.for.jsp={0} 리팩터링은 JSP에서 지원되지 않습니다
error.not.supported.for.local={0} 리팩터링은 로컬 클래스에서 지원되지 않습니다
error.not.supported.for.package.info={0} 리팩터링은 package-info.java에서 지원되지 않습니다
error.wrong.caret.position.anonymous=캐럿은 리팩터링할 익명 클래스 내부에 있어야 합니다.
error.wrong.caret.position.constructor=캐럿은 리팩터링할 생성자 내부에 있어야 합니다.
error.wrong.caret.position.local.name=캐럿이 리팩터링할 지역 변수 이름에 있어야 합니다.
error.wrong.caret.position.local.or.expression.name=캐럿이 리팩터링할 지역 변수 또는 표현식 이름에 있어야 합니다.
error.wrong.caret.position.method=캐럿이 리팩터링할 메서드 내부에 있어야 합니다.
error.wrong.name.input=잘못된 이름\: {0}
expand.method.reference.warning=메서드는 메서드 참조에 사용됩니다. 진행하면 람다 식으로 변환됩니다.
expression.result=표현식 결과
extract.chained.constructor.checkbox=체인 생성자 추출(&C)
extract.delegate.as.enum.checkbox=열거형으로 추출
extract.delegate.create.nested.checkbox=중첩 클래스 생성
extract.delegate.generate.accessors.checkbox=접근자 생성
extract.delegate.unable.create.warning.message=지정된 이름으로 클래스를 생성할 수 없습니다.
extract.method.control.flow.analysis.failed=코드에 구문 오류가 포함되어 있습니다. 필요한 분석을 수행할 수 없습니다.
extract.method.error.prefix=메서드를 추출하지 못했습니다.
extract.method.error.class.outside.used=지역 클래스가 선택된 블록 외부에서 사용되고 있습니다.
extract.method.error.class.outside.defined=지역 클래스가 선택된 블록 외부에 정의되어 있습니다.
extract.method.error.many.outputs=반환할 변수가 여러 개 있습니다.
extract.method.error.many.exits=종료점이 여러 개 있습니다.
extract.method.error.many.finals=final 필드에 대입할 항목이 1개 있습니다.
extract.method.error.variable.in.expression=선택된 표현식 내에서 반환할 변수가 1개 있습니다.
extract.method.error.class.not.found=선택된 블록은 Java 클래스의 일부여야 합니다.
extract.method.error.invalid.name=잘못된 메서드 이름
extract.method.error.method.conflict=시그니처가 동일한 메서드가 이미 있습니다
extract.method.object.anonymous.make.varargs.option=가변인수 생성(&V)
extract.method.object.class.name=클래스 이름(&C)\:
extract.method.object.create.anonymous.class=Crear &clase anónima
extract.method.object.create.inner.class=Crear una clase interna
extract.method.object.inner.class.visibility=Visibilidad:
extract.method.object.inner.make.static.option=Hacer &estático
extract.method.object.inner.make.varargs.option=Crear &varargs
extract.method.object.inner.visibility.package.local=pa&quete local
extract.method.object.inner.visibility.private=pri&vate
extract.method.object.inner.visibility.protected=pr&otected
extract.method.object.inner.visibility.public=pu&blic
extract.method.object.method.name=&Nombre del método:
extract.method.object.parameters=Parámetros
extract.method.object.signature.preview=Vista previa de la firma
extract.method.object.suggestion=¿Le gustaría extraer el objeto de método?
extract.parameters.to.replace.duplicates=Extraer parámetros para reemplazar duplicados
extract.subclass.command=Extraer subclase
extractSuper.rename.original.class.to=&Cambiar el nombre de la clase original a:
extractSuperInterface.javadoc=JavaDoc
factory.method.name.label=factory 메서드 이름\:
failed.to.re.run.refactoring=리팩터링을 다시 실행하지 못했습니다.
field.0.is.already.defined.in.the.1=필드 {0} 은(는) {1}에 이미 정의되어 있습니다
field.0.is.never.used=필드 {0} 은(는) 전혀 사용되지 않습니다
field.0.is.not.accessible={1}에서 필드 {0}에 액세스할 수 없습니다
field.0.will.hide.field.1.of.the.base.class=필드 {0} 은(는) 기본 {2}의 \n\
필드 {1}을 숨깁니다
field.declaration.radio=필드 선언(&D)
field.description=필드 {0}
field.name=필드 이름(&F)\:
fields.to.be.refactored.should.belong.to.the.same.class=리팩터링할 필드는 동일한 클래스에 속해야 합니다.
functional.interface.broken=함수식은 정확한 한 가지 메서드를 가지려면 함수 인터페이스가 있어야 합니다.
generate.getter.for.delegated.component=위임된 구성 요소의 getter 생성(&G)
generate.module.descriptors.analysing.message=종속성 분석 중
generate.module.descriptors.build.required.message=프로젝트가 아직 빌드되지 않았기 때문에 모듈 설명자를 생성할 수 없습니다.
generate.module.descriptors.collecting.message=종속성 수집 중
generate.module.descriptors.command.title=module-info 설명자 생성
generate.module.descriptors.no.suitable.modules.message=module-info를 포함할 수 있는 모듈을 찾지 못했습니다.
generate.module.descriptors.preparing.message=코드 준비 중
generate.module.descriptors.rebuild.message=종속성 계산의 정확도를 높이기 위해 프로젝트를 빌드해야 합니다. \n\
module-info 설명자를 생성하기 전 빌드를 시작하시겠어요?
generate.module.descriptors.scanning.message=컴파일러 출력 검사 중
generate.module.descriptors.title=모듈 설명자 생성
generify.title=일반화
getter.and.setter.methods.found.for.the.field.0=필드 {0} 의 getter 및 setter 메서드가 발견되었습니다. \n\
이 메서드도 {1} 하시겠어요?
getter.method.found.for.the.field.0=필드 {0} 의 getter 메서드가 발견되었습니다. \n\
이 getter도 {1} 하시겠어요?
idea.has.not.found.any.code.that.can.be.replaced.with.method.call={0}이(가) 중복을 찾지 못했습니다
ignore.button=무시
implicit.last.parameter.warning=묵시적 마지막 매개변수는 삭제하면 안 됩니다
infer.class.type.args.warning=클래스 유형 인수를 추론할 수 없습니다. 계속하면 원시 {0}이(가) 생성됩니다
information.title=정보
initializer.for.variable.cannot.be.a.constant.initializer=변수 {0}의 이니셜라이저는 상수 이니셜라이저가 될 수 없습니다
inline.action.name=인라인
inline.anonymous.conflict.progress=클래스 "{0}" 상속자 검색 중...
inline.class.elements.header=인라인화할 클래스
inline.conflicts.progress=인라인화가 가능한지 확인...
inline.constant.field.not.supported.for.enum.constants={0} 은(는) 열거형 상수에서 지원되지 않습니다.
inline.element.unknown.header=알 수 없는 요소
inline.field.action.name=필드 인라인화...
inline.field.command=필드 {0} 인라인화
inline.field.elements.header=인라인화할 필드
inline.field.field.name.label=필드 {0}
inline.field.field.occurrences=필드 {0}에 {1}개의 {1, choice, 1\#사용 위치|2\#사용 위치}가 있습니다
inline.field.title=필드 인라인화
inline.field.used.in.javadoc=인라인화된 필드가 JavaDoc에서 사용됩니다
inline.field.used.in.reflection=인라인화된 필드가 리플렉티브로 사용됩니다
inline.field.initializer.is.not.accessible=필드 이니셜라이저가 {1}에서 액세스할 수 없는 {0}을(를) 참조합니다
inline.local.unable.try.catch.warning.message=Try/catch 문 외부에서 인라인화할 수 없음
inline.local.used.as.resource.cannot.refactor.message=변수가 리소스 참조로 사용됩니다.
inline.local.variable.declared.outside.cannot.refactor.message=변수가 코드 블록 외부에서 선언됩니다.
inline.method.calls.not.accessible.in=인라인화된 메서드가 {1}에서 액세스되지 않는 {0}을(를) 호출합니다
inline.method.calls.not.accessible.on.qualifier=인라인화된 메서드가 한정자 {1}에서 액세스되지 않는 {0}을(를) 호출합니다
inline.method.checking.tail.calls.progress=테일 호출 사용 위치 확인 중
inline.method.elements.header=인라인할 메서드
inline.method.method.label=메서드 {0}
inline.method.method.occurrences=메서드 {0}에 {1}개의 {1, choice, 1\#사용 위치|2\#사용 위치}가 있습니다
inline.method.multiline.method.in.ctor.call=생성자 호출의 여러 줄 메서드에는 인라인화를 적용할 수 없습니다
inline.method.multiline.method.in.loop.condition=루프 조건의 여러 줄 메서드에는 인라인화를 적용할 수 없습니다
inline.method.object.action.name=객체 인라인화
inline.method.object.suggestion.message=개체와 후속 호출을 인라인화하시겠어요?
inline.method.qualifier.usage.side.effect=인라인화된 메서드가 한정자에서 부작용이 있는 메서드 참조에서 사용됩니다
inline.method.used.in.javadoc=인라인화된 메서드가 JavaDoc에서 사용됩니다
inline.method.used.in.reflection=인라인화된 메서드가 리플렉티브로 사용됩니다
inline.parameter.action.name=매개변수 인라인화...
inline.parameter.cannot.find.initializer.warning.message=매개변수에 대한 상수 이니셜라이저를 찾을 수 없습니다.
inline.parameter.confirmation=매개변수 ''{0}''을(를) 이니셜라이저 ''{1}''(으)로 인라인화하시겠어요?
inline.parameter.error.hierarchy=메서드가 상속 계층 구조의 일부인 경우 Inline 매개변수가 지원되지 않습니다.
inline.parameter.error.non.project.method=인라인화는 비 프로젝트 메서드에 대해 지원되지 않습니다
inline.parameter.error.varargs=varargs 매개변수에 대한 인라인화는 지원되지 않습니다.
inline.parameter.dependency.unavailable.in.static.method=매개변수 이니셜라이저가 static 메서드 내에서 사용할 수 없는 {0}에 종속되어 있습니다
inline.parameter.depends.on.caller.parameter=매개변수 이니셜라이저가 호출자 매개변수에 종속되어 있습니다
inline.parameter.depends.on.non.static=매개변수 이니셜라이저가 다른 일부 클래스의 비 static 멤버에 종속되어 있습니다
inline.parameter.depends.on.non.static.class=매개변수 이니셜라이저가 static 메서드 내에서 사용할 수 없는 비 static 클래스에 종속되어 있습니다
inline.parameter.depends.on.this.inside.static.method=매개변수 이니셜라이저가 static 메서드 내에서 사용할 수 없는 this에 종속되어 있습니다
inline.parameter.depends.on.unavailable.element.inside.method=매개변수 이니셜라이저가 메서드 내에서 사용할 수 없고 인라인화할 수 없는 {0}에 종속되어 있습니다
inline.parameter.depends.on.unavailable.value=매개변수 이니셜라이저가 메서드 내에서 사용할 수 없는 값에 종속되어 있습니다
inline.parameter.initializer.depends.on.inaccessible.value=매개변수 이니셜라이저가 메서드 내에서 사용할 수 없고 인라인화할 수 없는 값에 종속되어 있습니다
inline.parameter.method.usages.progress=메서드 사용 위치 검색 중
inline.parameter.no.usages.warning.message=메서드에 사용 위치가 없습니다.
inline.parameter.not.accessible.warning.message=메서드 본문에서 상수 이니셜라이저에 액세스할 수 없습니다.
inline.parameter.refactoring=Inline 매개변수
inline.parameter.replace.with.local.checkbox=지역 변수로 바꾸기(&E)
inline.parameter.write.usages.warning.message=쓰기에 사용되는 Inline 매개변수는 지원되지 않습니다.
inline.pattern.variable.title=패턴 변수 인라인화
inline.super.class=상위 클래스 인라인화
inline.super.class.action.name=상위 클래스 인라인화...
inline.super.class.label=클래스 {0}
inline.super.ctor.can.be.replaced=생성자 {0}을(를) {1} 중 하나로 바꿀수 있습니다
inline.super.doc.panel.title=인라인화된 멤버에 관한 JavaDoc
inline.super.expr.can.be.replaced={0}을(를) {1} 중 하나로 바꿀수 있습니다
inline.super.no.anonymous.class=익명 클래스로 인라인화할 수 없습니다.
inline.super.no.ctor=상위 항목과 일치하는 생성자를 찾을 수 없습니다
inline.super.no.inner.class=내부 클래스로 인라인화할 수 없습니다. ''{0}''을(를) 상위 수준으로 이동합니다
inline.super.no.substitution={0}의 일관된 대체 항목을 찾을 수 없습니다. ''{1}''이(가) 필요하지만 ''{2}''이(가) 발견되었습니다.
inline.super.no.return.in.super.ctor=return 문이 상위 생성자의 실행 흐름을 중단하면 리팩터링이 지원되지 않습니다
inline.super.non.project.class.warning.message=비 프로젝트 클래스를 인라인화할 수 없습니다.
inline.super.static.import.can.be.replaced=static import 문을 {0} 중 하나로 바꿀수 있습니다
inline.super.target.instead.of.super.class=대상 유형의 인스턴스는 상위 클래스가 필요한 곳으로 전달됩니다.
inline.super.type.element.can.be.replaced={0}을(를) {1} 중 하나로 바꿀수 있습니다
inline.super.type.params.differ=유형 매개변수가 {0}에서 일치하지 않습니다. {1}이(가) 필요하지만 {2}이(가) 발견되었습니다
inline.super.unknown.type=유형을 알 수 없습니다
inline.to.anonymous.border.title=인라인
inline.to.anonymous.command.name=클래스 {0} 인라인화
inline.to.anonymous.name.label=클래스 {0}
inline.to.anonymous.no.abstract=추상 클래스는 인라인화할 수 없습니다.
inline.to.anonymous.no.ctor.calls=본문 내에 클래스의 생성자에 대한 호출이 있으므로 클래스를 인라인화할 수 없습니다
inline.to.anonymous.no.get.class.calls=getClass() 호출의 결과가 변경됩니다
inline.to.anonymous.no.method.calls=본문 내에 클래스의 멤버에 대한 호출이 있으므로 클래스를 인라인화할 수 없습니다
inline.to.anonymous.no.multiple.interfaces=여러 인터페이스를 구현하는 클래스는 인라인화할 수 없습니다.
inline.to.anonymous.no.superclass.and.interface=상위 클래스가 있고 인터페이스를 구현하는 클래스는 인라인화할 수 없습니다.
inline.to.anonymous.refactoring=익명 클래스로 인라인화
inline.vars.elements.header=인라인화할 변수
inlined.method.implements.method.from.0=인라인화된 메서드는 {0}의 메서드를 구현합니다
inlined.method.overrides.method.from.0=인라인화된 메서드는 {0}의 메서드를 재정의합니다
inlined.method.will.be.transformed.to.single.return.form=인라인화된 메서드는 단일 반환 형식으로 변환됩니다.
inner.class.0.is.already.defined.in.class.1=내부 클래스 {0} 은(는) 클래스 {1}에 이미 정의되어 있습니다.\n\
그래도 계속하시겠어요?
inner.class.0.is.not.static=내부 클래스 {0} 은(는) 정적이지 않습니다.\n\
{1} 리팩터링은 정적 멤버에만 지원됩니다.
inner.class.exists=''{0}''(이)라는 이름의 내부 클래스가 클래스 ''{1}''에\n\
이미 정의되어 있습니다
inner.class.name=내부 클래스 이름(&I)\:
instance.initializer.description=클래스 {0}의 인스턴스 이니셜라이저
instances.casted.to.java.lang.object=java.lang.Object로 형 변환된 인스턴스
instances.of.0.upcasted.to.1.were.found=Instances of {0} upcasted to {1} were found. If you continue,they will be shown in a separate Find tab.
instances.upcasted.to.java.lang.object.found=java.lang.Object로 업캐스트된 인스턴스 발견
instances.upcasted.to.object=객체로 업캐스트된 인스턴스 발견
interface.0.does.not.have.inheritors=인터페이스 {0}에 상속자가 없습니다
interface.description=인터페이스 {0}
interface.does.not.have.base.interfaces=인터페이스 {0}에 기본 인터페이스가 없습니다
interface.has.been.successfully.created=인터페이스 {0}이(가) 성공적으로 생성되었습니다
introduce.constant.enum.cb=열거형 상수로서 추출(&E)
introduce.constant.field.of.type=유형의 상수(static final 필드)(&T)\:
introduce.constant.introduce.to.class=클래스(정규화된 이름)로 추출(&C)\:
introduce.constant.move.to.another.class.checkbox=다른 클래스로 이동
introduce.constant.used.for.write.cannot.refactor.message=선택한 표현식은 쓰기에 사용됩니다.
introduce.field.field.of.type=유형의 필드(&T)\:
introduce.field.static.field.of.type=유형의 정적 필드(&T)\:
introduce.functional.variable.pass.fields.checkbox=필드를 매개변수로 전달(&F)
introduce.local.variable.to.reassign.title=재할당할 변수 선택
introduce.parameter.command=매개변수를 {0}(으)로 추출
introduce.parameter.convert.lambda=함수형 표현식으로 변환(&C)
introduce.parameter.duplicates.progress=메서드 중복 검색...
introduce.parameter.elements.header=메서드에 매개변수 추가
introduce.parameter.object.create.inner.class=내부 클래스 생성(&I)
introduce.parameter.object.create.new.class=새 클래스 생성(&C)
introduce.parameter.object.escalate.visibility.option=가시성 에스컬레이션(&E)
introduce.parameter.object.existing.class.name=이름(&N)
introduce.parameter.object.generate.accessors.option=접근자 생성(&G)
introduce.parameter.object.inner.class.name=이름(&N)
introduce.parameter.object.new.class.name=이름(&N)
introduce.parameter.object.new.class.package.name=패키지 이름(&P)
introduce.parameter.object.use.existing.class=기존 클래스 사용(&U)
introduce.parameter.super.method.checkbox=상위 메서드 리팩터링
introduce.parameter.to.method=매개변수를 메서드로 추출\:
introduced.variable.will.conflict.with.0=삽입된 변수가 {0}와(과) 충돌합니다
introducing.variable.may.break.code.logic=변수를 도입하면 코드 논리가 깨질 수 있습니다.
invalid.expression.context=잘못된 표현식 컨텍스트.
invalid.package.name=잘못된 패키지 이름\: {0}
invalid.target.package.name.specified=대상 패키지의 이름이 잘못 지정되었습니다.
invert.boolean.foreach=Foreach 매개변수 이니셜라이저를 반전할 수 없습니다.
invert.boolean.wrong.type=리팩터링할 메서드 또는 변수의 반환 유형은 부울이어야 합니다.
invocations.to.be.inlined=인라인화할 호출 {0}
is.modified.in.loop.body={0}이(가) 루프 본문에서 수정됩니다
javadoc.for.abstracts=추상에 대한 JavaDoc
keep.original.signature=원본 시그니처 유지
lambda.to.reference.side.effect.warning.message=메서드 참조 한정자에 가능한 부작용이 있습니다.\n\
지역 변수를 도입하시겠어요?
local.variable.description=variable local {0}
local.will.be.hidden.renamed.description=이름 변경된 필드는 {0}을(를) 숨깁니다
locate.caret.inside.a.method=멤버 내부의 캐럿 검색
locate.duplicates.action.name=중복 검색
make.0.static=Hacer {0} estático
make.method.static.title=메서드를 정적으로 설정
make.static.command={0}을(를) static으로 설정
make.static.description.label={0} {1}을(를) 정적으로 설정
make.static.elements.header={0}을(를) 정적으로 설정
make.static.method.references.progress=메서드 참조 검색
make.static.methods.to.propagate.dialog.title=Static 문을 전달할 메서드 선택
members.to.form.interface.title=인터페이스를 형성하는 멤버
members.to.form.superclass.title=상위 클래스를 형성하는 멤버
method.0.is.overridden.by.1=메서드 {0}이(가) {1}(으)로 재정의됩니다
method.0.will.hide.method.of.the.base.class=메서드 {0} 은(는) 기본 클래스 {1}의 \n\
메서드를 숨깁니다
method.0.will.implement.method.of.the.base.class=메서드 {0} 은(는) 기본 클래스 {1}의 \n\
메서드를 구현합니다
method.0.will.override.a.method.of.the.base.class=메서드 {0} 은(는) 기본 클래스 {1}의 \n\
메서드를 재정의합니다
method.call.would.be.linked.to.0.after.rename=메서드 호출은 이름 변경 후 "{0}"에 연결됩니다.
method.column=메서드
method.description=메서드 {0}
method.does.not.have.a.body=메서드 {0}에 본문이 없습니다
method.duplicates.found.message={0, choice, 1\#1개의 코드 조각|2\#{0,number} 개의 코드 조각} 발견
method.has.an.empty.body=메서드 {0}에 본문이 비어 있습니다.
method.is.not.a.constructor=메서드가 생성자가 아닙니다
migration.class=클래스
migration.dialog.ok.button.text=실행
migration.dialog.title=패키지 및 클래스 마이그레이션
migration.edit.button=편집...
migration.entry.class=클래스
migration.entry.new.name=새 이름\:
migration.entry.old.name=이전 이름\:
migration.entry.package=패키지
migration.map.description.label=맵 설명\:
migration.map.name.prompt=맵 이름\:
migration.new.name.column.header=새 이름
migration.no.usages.found.in.the.project=프로젝트에서 사용 위치를 찾을 수 없습니다.
migration.old.name.column.header=이전 이름
migration.package=패키지
migration.package.with.subpackages=하위 패키지가 있는 패키지
migration.remove.button=제거
migration.title=마이그레이션
migration.type.column.header=유형
move.class=클래스 이동...
move.class.refactoring.cannot.be.applied.to.anonymous.classes=클래스 이동 리팩터링을 익명 클래스에 적용할 수 없습니다.
move.class.to.inner.command.name={0,choice,1\#클래스|2\#클래스} {1}을(를) {2}(으)로 이동
move.class.to.inner.move.to.self.error=클래스를 자체로 이동할 수 없습니다.
move.class.to.inner.nonstatic.error=클래스를 비 ''static'' 내부 클래스로 이동할 수 없습니다.
move.classes=클래스 이동...
move.classes.and.packages=클래스 및 패키지 이동...
move.classes.command=패키지 {1}(으)로 {0} 이동
move.classes.destination.make.inner=다음의 내부 클래스 생성(&M)
move.classes.destination.package.prompt=패키지로\:
move.classes.destination.to.package=대상 패키지(&G)
move.classes.invalid.package.name.warning.message=잘못된 패키지 이름
move.classes.or.packages.title=이동
move.current.directory=현재 디렉터리 이동(&C)
move.directories=모두 이동(&A)
move.directories.to.another.source.root={0} 디렉터리를 다른 소스 루트로 이동(&A)
move.directory.to.another.source.root=디렉터리 {0}을(를) 다른 소스 루트로 이동(&A)
move.enum.constant.cb=가능한 경우 열거형 상수로서 이동(&E)
move.everything.from.directories.to.another.directory={0} 디렉터리에서 다른 디렉터리로 전체 이동
move.everything.to.another.directory={0}에서 다른 디렉터리로 전체 이동
move.files.regrouping.command.name=다시 그룹 지정 중...
move.files.to.new.directory.prompt=대상 디렉터리\:
move.inner.class.action.name=내부 클래스 이동...
move.inner.class.command=내부 클래스 {0} 이동
move.inner.class.to.another.class=내부 클래스 {0}을(를) 다른 클래스로 이동(&M)
move.inner.class.to.be.moved=이동할 클래스
move.inner.class.to.upper.level=내부 클래스 {0}을(를) 상위 수준으로 이동(&I)
move.inner.class.to.upper.level.action.name=내부 클래스를 상위 수준으로 이동...
move.instance.method.delegate.title=인스턴스 메서드 이동...
move.instance.method.elements.header=인스턴스 메서드 이동
move.instance.method.handler.make.method.static=''{0}'' 메서드를 static 메서드로 만들고 이동하시겠어요?
move.members.action.name=멤버 이동...
move.method.enter.a.valid.name.for.parameter=올바른 매개변수 이름을 입력하세요.
move.method.is.not.supported.for.0=인스턴스 이동 메서드는 {0}에서 지원되지 않습니다
move.method.is.not.supported.for.constructors=생성자에 대한 메서드 이동이 지원되지 않습니다.
move.method.is.not.supported.for.generic.classes=제네릭 클래스에 대한 메서드 이동이 지원되지 않습니다.
move.method.is.not.supported.for.non.project.methods=비 프로젝트 메서드에 대한 메서드 이동이 지원되지 않습니다.
move.method.this.parameter.label=''{0}.this'' 매개변수의 이름 선택
move.methods.panel.title=추출된 클래스로 이동할 메서드(&M)
move.methods.used.in.extracted.block.only=추출된 블록에만 사용되는 메서드 이동
move.nonstatic.class.from.jsp.not.supported=JSP 페이지의 비 ''static'' 클래스 이동이 지원되지 않습니다.
move.package.or.directory=패키지 또는 디렉터리 이동...
move.package.refactoring.cannot.be.applied.to.default.package=패키지 이동 리팩터링을 디폴트 패키지에 적용할 수 없습니다.
move.package.to.another.package=패키지 ''{0}''을(를) 다른 패키지로 이동(&P)
move.packages.or.directories=패키지 또는 디렉터리 이동...
move.packages.to.another.package={0} 패키지를 다른 패키지로 이동(&P)
move.single.class.or.package.name.label={0} {1} 이동
move.specified.classes=지정된 클래스 이동
move.specified.classes.to=지정된 클래스를 다음으로 이동\:
move.specified.packages=지정된 패키지 이동
move.to.inner.duplicate.inner.class=이름이 {1}인 내부 클래스가 클래스 {0}에 이미 포함되어 있습니다
moving.local.classes.is.not.supported=로컬 클래스 이동은 지원되지 않습니다.
no.class.name.specified=클래스 이름이 지정되지 않았습니다.
no.exact.method.duplicates.were.found=<html><b>정확한 메서드 중복을 찾을 수 없습니다.</b>아래에 표시된 것처럼 변경된 메서드는 {0} {0,choice, 1\#중복|2\#중복}을 포함합니다.</html>
no.initializer.present.for.the.field=해당 필드에 대한 이니셜라이저가 존재하지 않습니다.
no.parameter.name.specified=매개변수 이름이 지정되지 않았습니다.
no.usages.can.be.replaced={0}의 사용 위치가 없습니다 \n\
{1}의 사용 위치로 바꿀수 있습니다
occurrences.to.be.migrated=마이그레이션할 사용 위치 {0}
ok.button=확인
only.fields.variables.of.methods.of.valid.type.can.be.considered=Only fields,variables,method parameters or methods of valid type can be considered.
package.description=패키지 {0}
package.does.not.exist=패키지 {0}이(가) 없습니다.\n\
생성하시겠어요?
package.name.prompt=패키지 이름(&G)\:
parameter.description=매개변수 {0}
parameter.initializer.contains.0.but.not.all.calls.to.method.are.in.its.class=Parameter initializer contains {0},but not all calls to method are in its class
parameter.name.prompt=매개변수 이름(&M)\:
parameter.of.type=유형의 매개변수(&T)\:
parameter.type.table.column.title=유형
parameter.used.in.method.body.warning={0}이(가) 메서드 본문에서 사용됩니다
pass.outer.class.instance.as.parameter=외부 클래스의 인스턴스를 매개변수로 전달(&O)
please.enter.a.valid.target.package.name=유효한 대상 패키지 이름을 입력하세요.
press.the.do.migrate.button=Press the "Do Migrate" button at the bottom of the search results panel\n\
to migrate using the migration map "{0}"
preview.usages.to.be.changed=변경할 사용 위치 미리 보기(&P)
process.duplicates.change.signature.promt=모든 사용 위치를 대체하기 위해 메서드 시그니처가 변경됩니다. 진행하시겠어요?
process.duplicates.title=프로세스 중복
process.methods.duplicates.title=메서드 {2} 중복 처리({1} 중 {0})
processing.progress.text={0} 처리 중
project.files.have.been.changed=프로젝트 파일이 변경되었습니다.\n\
리팩터링을 다시 실행하시겠어요?
push.down.delete.warning.text={0}멤버를 아래로 이동하면 해당 멤버가 삭제됩니다. 진행하시겠어요?
push.down.enum.no.constants.warning.text=열거형 {0}에는 인라인화할 상수가 없습니다.
push.down.no.inheritors.class.warning.text=클래스 {0}에 상속자가 없습니다.
push.down.no.inheritors.final.class.warning.text=final 클래스 {0}에 상속자가 없습니다.
re.run.refactoring=리팩터링 다시 실행
refactoring.cannot.be.applied.no.sources.attached=연결된 소스가 없어 {0} 리팩터링을 적용할 수 없습니다
refactoring.cannot.be.applied.to.abstract.methods={0} 리팩터링은 추상 메서드에 적용할 수 없습니다
refactoring.cannot.be.applied.to.inline.non.chaining.constructors={0} 리팩터링은 체인이 아닌 생성자에 적용할 수 없습니다
refactoring.cannot.be.applied.to.native.methods={0} 리팩터링은 기본 메서드에 적용할 수 없습니다
refactoring.cannot.be.applied.to.vararg.constructors={0} 리팩터링은 vararg 생성자에 적용할 수 없습니다
refactoring.extract.method.dialog.duplicates.count={0,choice, 1\#하나의|2\#{0,number}개의} 중복 코드 {0,choice, 1\#조각|2\#조각}은 추출된 메서드 호출을 사용하여 바꿀수 있습니다
refactoring.extract.method.dialog.duplicates.pending=중복 검색 중...
refactoring.extract.method.dialog.duplicates.progress=중복 검색
refactoring.extract.method.inner.class.defined=내부 클래스 {0}은(는) 클래스 {1}에 이미 정의되어 있습니다.
refactoring.extract.method.preview.button.refactor=리팩터링 수행(&D)
refactoring.extract.method.preview.button.rerun=리팩터링 다시 실행(&E)
refactoring.extract.method.preview.failed=메서드 추출 실패
refactoring.extract.method.preview.group.duplicates=코드 조각 복제
refactoring.extract.method.preview.group.method=추출할 메서드
refactoring.extract.method.preview.group.original=원본 코드 조각
refactoring.extract.method.preview.preparing=Diff 준비 중
refactoring.extract.method.preview.updating=Diff 업데이트 중
refactoring.extract.method.reference.to.change=변경할 참조
refactoring.introduce.variable.enum.in.label.message=switch 라벨의 열거형 상수를 추출할 수 없습니다
refactoring.is.not.supported.for.jsp.classes=\ 리팩터링은 JSP 클래스에서 지원되지 않습니다
refactoring.is.not.supported.for.local.and.jsp.classes=리팩터링은 로컬 및 JSP 클래스에서 지원되지 않습니다.
refactoring.is.not.supported.in.the.current.context={0} 리팩터링은 현재 컨텍스트에서 지원되지 않습니다
references.in.code.to.elements.from.migration.map=마이그레이션 맵 "{0}" {1}의 요소에 대한 코드 내 참조
references.to.0.to.be.replaced.with.references.to.1=''{0}''에 대한 참조를 ''{1}''{2}에 대한 참조로 바꾸기
remove.parameter.0.no.longer.used=더 이상 사용되지 않는 매개변수 ''{0}'' 제거
rename.constructor.parameters.title=생성자 매개변수 이름 변경
rename.constructor.parameters.with.the.following.names.to=다음 이름을 가진 매개변수의 이름 변경\:
rename.inheritors.with.the.following.names.to=다음 이름을 가진 상속자의 이름 변경\:
rename.module.already.exists=프로젝트에 모듈 ''{0}''이(가) 이미 있습니다
rename.module.directory.command=모듈 및 디렉터리 이름을 ''{0}''(으)로 변경합니다
rename.module.directory.title=모듈 및 디렉터리 이름 변경(&A)
rename.overloads=오버로드 이름 변경(&O)
rename.overloads.dialog.title=오버로드 이름 변경
rename.overloads.to.dialog.description=오버로드 이름을 다음으로 변경\:
rename.parameter.in.hierarchy.to.dialog.description=계층 구조에서 매개변수 이름을 다음으로 변경\:
rename.parameters.dialog.title=매개변수 이름 변경
rename.tests=테스트 이름 변경(&E)
rename.tests.title=테스트 이름 변경
rename.tests.with.the.following.names.to=다음 이름을 가진 테스트의 이름 변경\:
rename.variables=변수 이름 변경(&V)
rename.variables.title=변수 이름 변경
rename.variables.with.the.following.names.to=다음 이름을 가진 변수의 이름 변경\:
rename.accessors=접근자 이름 변경(&A)
rename.accessors.title=Getter/Setter 이름 변경 
rename.accessors.with.the.following.names.to=다음 이름을 가진 접근자의 이름 변경\:
renamed.class.will.hide.0.in.1=이름 변경된 클래스는 {1}에서 {0}을(를) 숨깁니다
renaming.method.will.override.final.0=메서드 이름 변경은 final "{0}"을(를) 재정의합니다.
replace.all.fields=모든 필드 바꾸기(&R)
replace.all.occurrences.of.expression.0.occurrences=모든 사용 위치 바꾸기({0})(&A)
replace.constructor.0.with.a.factory.method=factory 메서드로 생성자 {0} 바꾸기
replace.constructor.builder.create.new=새로 만들기(&C)
replace.constructor.builder.use.existing=기존 사용(&U)
replace.constructor.existing.builder.fqn=빌더 클래스 이름(정규화된)(&B)
replace.constructor.new.builder.class.name=빌더 클래스 이름(&N)
replace.constructor.new.builder.package=새 빌더를 위한 패키지(&P)
replace.constructor.with.factory.method=factory 메서드로 생성자 바꾸기
replace.constructor.with.factory.method.title=Factory 메서드로 생성자 바꾸기
replace.constructor.with.factory.target.fq.name=대상 위치(정규화된 이름)\:
replace.default.constructor.of.0.with.a.factory.method=factory 메서드로 {0}의 디폴트 생성자 바꾸기
replace.default.constructor.with.factory.method=factory 메서드로 의 디폴트 생성자 바꾸기
replace.fields.inaccessible.in.usage.context=사용 컨텍스트에서 접근할 수 없는 필드 바꾸기(&I)
replace.fields.used.in.expressions.with.their.getters=표현식에 사용된 필드를 getter로 바꾸기
replace.inheritance.from=다음에서 위임 상속으로 바꾸기(&R)\:
replace.inheritance.with.delegation.command={0}에 있는 위임으로 상속 바꾸기
replace.inheritance.with.delegation.delegate.members.title=멤버 위임
replace.inheritance.with.delegation.elements.header=상속을 위임으로 바꿉니다
replace.inheritance.with.delegation.invalid.field=''{0}''은(는) 위임에 대한 잘못된 필드 이름입니다
replace.inheritance.with.delegation.invalid.inner.class=''{0}''은(는) 위임에 대한 잘못된 필드 이름입니다
replace.inheritance.with.delegation.title=상속을 위임으로 바꾸기
replace.instance.qualifiers.with.class.references=인스턴스 한정자를 클래스 참조로 바꾸기
replace.method.code.duplicates.title=코드 중복 바꾸기
replace.method.duplicates.scope.chooser.message=범위 분석
replace.method.duplicates.scope.chooser.title={0} 범위 지정
replace.temp.with.query.title=임시를 쿼리로 바꾸기
replace.this.code.fragment.and.change.signature=Method signature will be changed to \n\
{0}
replace.this.code.fragment.and.make.method.static=(메서드는 정적으로 설정됩니다)
replace.this.code.fragment.and.make.method.static.visible=(메서드는 정적 및 {0}(으)로 생성)
replace.this.code.fragment.and.make.method.visible=(메서드는 {0}(으)로 생성)
replace.with.method.call.does.not.work.for.constructors=''메서드 호출로 바꾸기''는 생성자에서 작동하지 않습니다.
replace.write.access.occurrences=쓰기 액세스 사용 위치 바꾸기(&L)
replacing.inheritance.with.delegation=상속을 위임으로 바꾸기
safe.delete.search.for.caller.method.usages.progress=호출 메서드 사용 위치 검색 중...
safe.delete.select.members.to.propagate.dialog.title=안전한 삭제를 전달할 멤버 선택
safe.delete.select.methods.to.propagate.delete.parameters.dialog.title=매개변수 삭제를 전달할 메서드 선택
safe.delete.parameter.usage.warning=매개변수 ''{0}''에 안전하게 삭제할 수 없는 사용 위치가 있습니다
select.migration.map=마이그레이션 맵 선택\:
select.source.root.chooser.title=소스 루트 선택
selected.block.contains.invocation.of.another.class.constructor=선택한 블록에 다른 클래스 생성자의 호출이 포함되어 있습니다
selected.block.contains.statement.outside.of.class=선택한 블록에는 클래스 외부 구문이 포함되어 있습니다.
selected.block.should.represent.an.expression=선택한 블록이 표현식을 나타내야 합니다.
selected.expression.cannot.be.a.constant.initializer=선택한 표현식은 상수 이니셜라이저가 될 수 없습니다.
selected.expression.has.void.type=선택한 표현식에 void 유형이 있습니다.
selected.expression.introduces.pattern.variable=선택한 표현식은 패턴 변수 ''{0}''(을)를 삽입합니다.
popup.title.choose.class.to.introduce.constant=상수를 삽입할 클래스 선택
popup.title.choose.class.to.introduce.field=필드를 삽입할 클래스 선택
setter.method.found.for.the.field.0=필드 {0} 의 setter 메서드가 발견되었습니다. \n\
이 setter도 {1} 하시겠어요?
side.effects.detected.title=부작용 탐지됨
source.folder.0.has.package.prefix.1=소스 폴더 {0}에 패키지 접두사 ''{1}''이(가) 있습니다.\n\
패키지 ''{2}''을(를) 거기에 생성할 수 없습니다.
static.initializer.description=클래스 {0}의 정적 이니셜라이저
superclass.cannot.be.accessed.in.subclass=상위 클래스는 하위 클래스에서 액세스할 수 없습니다
superclass.cannot.be.extracted.from.an.enum=상위 클래스는 열거형에서 추출할 수 없습니다.
synthetic.jsp.class.is.referenced.in.the.method=통합 jsp 클래스는 메서드에서 참조됩니다.
target.0.is.not.accessible.from.1={1}에서 대상 {0}에 액세스할 수 없습니다
the.field.should.be.declared.in.a.class=해당 필드는 클래스에서 선언되어야 합니다.
there.are.going.to.be.multiple.destination.files.with.the.same.name=같은 이름의 여러 대상 파일이 존재할 것입니다.
there.are.multiple.exit.points.in.the.selected.code.fragment=선택한 코드 조각에 여러 종료점이 있습니다.
there.are.multiple.output.values.for.the.selected.code.fragment=선택한 코드 조각에 여러 출력 값이 있습니다.
there.are.no.variables.that.have.reference.type=참조 유형이 있는 변수가 없습니다.
there.are.unused.methods.that.override.methods.you.delete=삭제한 메서드를 재정의하는 사용되지 않는 메서드가 있습니다.
there.is.already.a.0.in.1={1}에 {0}이(가) 이미 있습니다
there.is.already.a.0.it.will.conflict.with.an.introduced.parameter={0}이(가) 이미 있습니다. 삽입된 매개변수와 충돌하게 됩니다
there.is.already.a.0.it.will.conflict.with.the.renamed.1={0}이(가) 이미 있습니다. 이름 변경된 {1}와(과) 충돌하게 됩니다.
there.is.already.type.parameter.in.0.with.name.1={0}에 이미 이름이 {1} 유형 매개변수가 있습니다.
this.method=이 메서드
this.reference.only.and.keep.super.class=이 참조만 인라인화하고 상위 클래스 유지(&K)
this.reference.only.and.keep.the.class=이 참조만 인라인화하고 클래스 유지(&K)
this.reference.only.and.keep.the.field=이 항목만 인라인화하고 필드 유지(&K)
turn.refs.to.super.command={0}의 사용 위치를 {1}(으)로 바꾸기
turnRefsToSuper.change.usages.to={0}의 사용 위치를 다음으로 변경(&C)\:
turnRefsToSuper.use.superclass.in.instanceof=인스턴스에서 인터페이스/상위 클래스 사용(&U)
type.cook.command=일반화
type.cook.drop.obsolete.casts=사용되지 않는 형 변환 드롭(&D)
type.cook.elements.header=일반화할 범위
type.cook.generify.objects=객체 일반화(&O)
type.cook.leave.object.parameterized.types.raw=객체 매개변수화된 유형을 원시 상태로 두기(&L)
type.cook.perform.exhaustive.search=정밀 검색 수행(&E)
type.cook.preserve.raw.arrays=원시 및 배열 보존(&A)
type.cook.produce.wildcard.types=와일드카드 유형 생성(&W)
type.cook.ratio.generified={0,choice,-1\#계산되지 않음|0\#{0,number}/{1}}
type.cook.report=Items generified\: {0},casts removed\: {1}
type.migration.action.name=유형 마이그레이션
type.migration.choose.scope.title=시그니처 변경이 발생할 수 있는 범위 선택
type.migration.conflicts.found=발견된 마이그레이션 충돌
type.migration.exclude.action.text=제외(&E)
type.migration.include.action.text=포함(&I)
type.migration.label=다음으로 {0} "{1}" 마이그레이션
type.migration.migrate.button.text=마이그레이션(&M)
type.migration.no.conflicts.found=마이그레이션 충돌이 없습니다.
type.migration.no.scope.warning.message=범위가 선택되지 않았습니다.
type.migration.preview.warning.text=마이그레이션할 10개 이상의 루트를 찾았습니다. 미리보기를 하시겠어요?
type.migration.reasons.to.migrate=마이그레이션할 이유 발견
type.migration.rerun.button.text=유형 마이그레이션 다시 실행(&R)
type.migration.select.suggestion=마이그레이션할 이유를 발견하려면 루트를 선택합니다.
type.of.the.selected.expression.cannot.be.determined=선택한 표현식의 유형을 지정할 수 없습니다.
unable.to.start.type.migration=유형 마이그레이션을 시작할 수 없음
unknown.expression.type=알 수 없는 표현식 유형
unused.overriding.methods.title=사용되지 않는 재정의 메서드
usages.detected.title=사용 위치 탐지됨
use.interface.superclass.in.instanceof=인스턴스에서 인터페이스/상위 클래스 사용
use.interface.where.possible.title=가능하면 인터페이스 사용
use.super.references.prompt=이 단계에서 {0} 은(는) {1}의 사용 위치를 분석하여 \n\
가능한 곳에서 {2}의 사용 위치와 바꿀수 있습니다.\n\
계속하시겠어요?
use.variable.initializer.to.initialize.parameter=변수 및 이니셜라이저를 사용하여 매개변수 초기화(&I)
variable.0.is.changed.before.last.access=변수 ''{0}''이(가) ''{1}''에 마지막으로 액세스하기 전에 변경됩니다.
variable.does.not.have.an.initializer=변수 {0}에 이니셜라이저가 없습니다.
variable.is.accessed.for.writing=변수 ''{0}''은(는) 쓰기용으로 액세스됩니다
variable.is.never.used.before.modification=변수 {0} 은(는) 수정 전에 전혀 사용되지 않습니다
variable.of.type=유형의 변수(&T)\:
would.you.like.to.replace.default.constructor.of.0.with.factory.method={0}의 디폴트 생성자를 factory 메서드로 바꾸시겠어요?
wrap.return.value.create.inner.class=내부 클래스 생성(&I)
wrap.return.value.create.new.class=새 클래스 생성(&C)
wrap.return.value.existing.class.name=이름
wrap.return.value.inner.class.name=이름(&M)
wrap.return.value.new.class.name=이름(&N)
wrap.return.value.new.class.package.name=패키지 이름(&P)
wrap.return.value.use.existing.class=기존 클래스 사용(&U)
wrap.return.value.wrapper.field=래퍼 필드(&F)

replace.inside.current.lambda=현재 람다 내부에 변수 생성
replace.as.separate.operation=''{0}'' 연산으로 추출
replace.all.read.and.write=읽기 및 쓰기 사용 위치 바꾸기[(의미가 변경됩니다\!)
replace.all.and.extract={0}의 모든 사용 위치를 바꾸고 ''{1}'' 연산으로 추출
replace.lambda.chain.detected=람다 체인 탐지됨
replace.occurrences.inside.statement={2, choice, 1\#|2\# 외부} ''{1}'' 블록의 {0} 사용 위치 바꾸기
extract.method.object=메서드 객체 추출
replace.constructor.with.builder=생성자를 빌더로 바꾸기
type.migration.error.hint.title=유형 마이그레이션

extract.method.dialog.separator.parameters=매개변수(&P)
extract.method.conflict.parameter=충돌하는 매개변수 이름\: {0}
extract.method.conflict.variable=이름이 {0}인 변수가 선택한 범위에 이미 정의되어 있습니다
extract.method.error.annotation.value=어노테이션 값에서 메서드를 추출할 수 없습니다
extract.method.error.local.class.defined.outside=선택한 코드 조각이 조각 외부에서 정의된 지역 클래스를 사용하므로 메서드를 추출할 수 없습니다
extract.method.error.local.class.used.outside=선택한 코드 조각이 조각 외부에서 사용되는 지역 클래스를 정의하므로 메서드를 추출할 수 없습니다
extract.method.error.local.class.variable.used.outside=선택한 코드 조각이 조각 외부에서 사용되는 지역 클래스 유형의 변수를 정의하므로 메서드를 추출할 수 없습니다
extract.method.error.make.static=static으로 설정하지 못했습니다
extract.method.preview.node.invalid.prefix=유효하지 않음 
suggest.signature.preview.method.call.prefix=메서드 호출\:
suggest.signature.preview.title.before=이전
suggest.signature.preview.after.title=이후
removing.redundant.imports.progress.title=중복 import 문 제거 중
introduce.parameter.object.error.class.does.not.exist=''{0}''이(가) 없습니다
introduce.parameter.object.error.invalid.qualified.parameter.class.name=''{0}''은(는) 잘못된 정규화된 매개변수 클래스 이름입니다
introduce.parameter.object.error.invalid.parameter.class.package.name=''{0}''은(는) 잘못된 매개변수 클래스 패키지 이름입니다
introduce.parameter.object.error.invalid.parameter.class.name=''{0}''은(는) 잘못된 매개변수 클래스 이름입니다
introduce.parameter.object.error.inner.class.already.exist=이름이 ''{0}''인 내부 클래스가 이미 있습니다
introduce.parameter.object.error.invalid.inner.class.name=''{0}''은(는) 잘못된 내부 클래스 이름입니다
introduce.parameter.object.error.no.field.associated.found={0}와(과) 관련된 필드를 찾을 수 없습니다
introduce.parameter.object.error.existing.class.misses.compatible.constructor=기존 클래스에 호환되는 생성자가 없습니다
introduce.parameter.object.error.created.class.wont.be.accessible=생성된 클래스에 액세스할 수 없습니다
introduce.parameter.object.error.file.already.exits=파일이 이미 있습니다. {0}
replace.constructor.builder.error.identifier.invalid=식별자 ''{0}''(이)가 올바르지 않습니다
replace.constructor.builder.optional.setter.table.title=선택적 setter
replace.constructor.builder.default.value.table.title=디폴트 값
replace.constructor.builder.setter.name.table.title=setter 이름
replace.constructor.builder.field.name.table.title=필드 이름
replace.constructor.builder.parameter.table.title=매개변수
replace.constructor.builder.select.builder.class.chooser.title=빌더 클래스 선택
replace.constructor.builder.error.invalid.builder.qualified.class.name=''{0}''은(는) 잘못된 빌더 정규화된 클래스 이름입니다
replace.constructor.builder.error.invalid.builder.package.name=''{0}''은(는) 잘못된 빌더 클래스 패키지 이름입니다
replace.constructor.builder.error.invalid.builder.class.name=''{0}''은(는) 잘못된 빌더 클래스 이름입니다
replace.constructor.builder.error.invalid.setter.name=''{0}''은(는) 올바른 setter 이름이 아닙니다
replace.constructor.builder.error.invalid.field.name=''{0}''은(는) 올바른 필드 이름이 아닙니다
replace.constructor.builder.error.no.constructors=현재 클래스에는 빌더로 바꿀 생성자가 없습니다.
replace.constructor.builder.error.caret.position=캐럿은 생성자가 빌더로 대체될 클래스 내부에 있어야 합니다.
replace.constructor.builder.error.no.constructor.chain=발견된 생성자는 단순 체인으로 줄일 수 없습니다
replace.constructor.builder.error.class.with.chosen.name.already.exist=선택한 이름의 클래스가 이미 있습니다.
replace.constructor.builder.error.selected.class.was.not.found=선택한 클래스를 찾을 수 없습니다.
replace.constructor.factory.error.invalid.factory.method.name=''{0}''은(는) 잘못된 factory 메서드 이름입니다
replace.constructor.factory.error.factory.method.already.exists=factory 메서드 {0}이(가) 이미 있으므로 새로 생성된 것 대신 사용됩니다.
java.safe.delete.empty.callee.text=피호출자 텍스트가 여기에 표시됩니다
java.safe.delete.caller.text=피호출자가 강조 표시된 호출자 텍스트가 여기에 표시됩니다
# {0} = method; {1} = class; {2} = protected/package-private/private
push.up.super.class.signature.conflict=상위 클래스의 {0}이(가) {1}의 {2} 메서드와 충돌합니다
push.up.abstract.accessibility.in.subclass.conflict={0}이(가) 하위 클래스에서 액세스할 수 없는 {1}을(를) 사용합니다.
push.up.abstract.accessible.from.the.subclass.conflict={0}은(는) 하위 클래스에서 액세스할 수 없으므로 추상으로 설정할 수 없습니다.
push.down.unrelated.defaults.conflict={0}이(가) {1} 및 {2}에서 관련 없는 디폴트를 상속합니다
move.member.write.access.in.interface.conflict={0}은(는) 쓰기 액세스 권한이 있지만 인터페이스로 이동되었습니다
remove.middleman.tooltip.warning=삭제하면 유형 계층 구조가 손상됩니다
remove.middleman.column.header=삭제
remove.middleman.methods.to.inline.title=인라인할 메서드(&M)
remove.middleman.deleted.hierarchy.conflict={0}이(가) 삭제됩니다. 계층 구조가 손상됩니다
refactor.only.current.method.choice=현재 메서드만 리팩터링
refactor.base.method.choice=기본 {0, choice, 0\#메서드|1\#메서드} 리팩터링
automatic.parameter.renamer.entity.name=매개변수
automatic.overload.renamer.entity.name=오버로드
extract.method.checkbox.annotate=어노테이션 추가
extract.method.checkbox.make.static=static으로 설정
extract.method.checkbox.make.static.and.pass.fields=static으로 설정 후 필드 전달
extract.method.link.label.go.to.declaration=선언으로 이동
extract.method.link.label.more.options=기타 옵션
dialog.message.field.doesnt.have.initializer=필드 {0}에 이니셜라이저가 없습니다
dialog.message.replace.duplicates.works.with.constants.only=중복 항목 바꾸기는 상수에만 작동합니다
dialog.message.caret.should.be.inside.method.or.constant=캐럿은 메서드 또는 상수 내에 있어야 합니다
inline.object.command.name=객체 인라인화
local.to.field.popup.title.choose.class.to.introduce.constant=상수를 삽입할 클래스 선택
local.to.field.popup.title.choose.class.to.introduce.field=필드를 삽입할 클래스 선택
extract.method.gotit.signature.header=메서드 시그니처 변경
extract.method.gotit.signature.message=<html><p style\=''margin-bottom\:3px;''>1. 시그너처 편집</p><p style\=''margin-bottom\:3px;''>2. 사용법법 업데이트\: gutter 내 아이콘을 클릭하거나 {0} 을(를) 누르세요</p><p><font color\=gray>매개변수 정렬하려면 {1} 또는 {2} 을(를) 사용하세요.</font></p></html>
extract.method.gotit.navigation.header=메서드 시그니처를 변경하시겠어요?
extract.method.gotit.navigation.message=메서드 선언으로 이동하여 실행\:<br/>메서드 이름 {0} 또는 {1} 을(를) 누르세요.
