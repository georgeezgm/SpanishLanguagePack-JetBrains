0.is.not.an.identifier=''{0}'' 은(는) 식별자가 아닙니다.
annotation.name.is.missing=어노테이션 프로퍼티는 ''name\=value'' 양식이어야 합니다.
anonymous.class.context.display={0}에서 익명
anonymous.class.derived.display={0}에서 파생된 익명 클래스
aux.context.display=({0} 내부)
bound.not.expected=예기치 않은 바운드
catch.without.try=''try''가 없는 ''catch''
class.context.display={1}의 {0}
class.literal.expected=.class가 필요합니다
context.type.java.comment=주석
context.type.string=문자열

default.language.level.description=SDK 디폴트 값

# These constants are used from JavaElementKind
# When localizing you may use the parameter #0 which signals the desired grammatical case:
# 0 = nominative case (subject)
# 1 = accusative case (object)
element.abstract_method=추상 메서드
element.annotation=어노테이션
element.anonymous_class=익명 클래스
element.class=클래스
element.constant=상수 필드
element.constructor=생성자
element.enum=열거형
element.enum_constant=열거형 상수
element.expression=표현식
element.field=필드
element.initializer=초기자
element.interface=인터페이스
element.label=라벨
element.local_variable=지역 변수
element.method=메서드
element.module=모듈
element.package=패키지
element.parameter=매개 변수
element.pattern_variable=패턴 변수
element.record=기록
element.record_component=기록 구성 요소
element.statement=구문
element.unknown=요소
element.variable=변수

else.without.if=''if''가 없는 ''else''
enum.constant.context=''{1}''의 열거형 상수 ''{0}''
expected.array.initializer=배열 이니셜라이저 기대
expected.boolean.expression=bool 표현식 기대
expected.catch.or.finally=''catch'' 또는 ''finally'' 기대
expected.class.or.interface=''class'' 또는 ''interface''가 필요합니다
expected.class.reference=클래스 참조가 필요합니다
expected.colon=''\:'' 예상
expected.comma='','' 예상
expected.comma.or.rparen='','' 또는 '')'' 기대
expected.comma.or.semicolon='','' 또는 '';''가 필요합니다.
expected.dot=''.'' 예상
expected.eq=''\='' 예상
expected.expression=표현식 기대
expected.gt=''>'' 예상.
expected.gt.or.comma=''>'' 또는 '''','' 기대
expected.identifier=식별자 기대
expected.identifier.or.type=식별자 또는 유형 기대
expected.lbrace=''{'' 예상
expected.lbrace.or.semicolon=''{'' 또는 '';''가 필요합니다.
expected.lbracket=''['' 예상
expected.lparen=''('' 예상
expected.lparen.or.lbracket=''('' 또는 '']'' 기대
expected.lt.or.lparen=''<'' 또는 ''(''가 필요합니다.
expected.module.declaration=모듈 선언이 필요합니다
expected.module.statement=모듈 지시문이 필요합니다
expected.package.reference=패키지 참조가 필요합니다
expected.parameter=매개변수 기대
expected.rbrace=''}'' 예상
expected.rbracket='']'' 예상
expected.resource=리소스 정의가 필요합니다
expected.rparen='')'' 예상
expected.semicolon='';'' 예상
expected.statement=명령문 기대
expected.string=문자열 리터럴이 필요합니다
expected.switch.label=''case'', ''default'' 또는 ''}'' 기대
expected.switch.rule=표현식, 블록 또는 throw 문 기대
expected.type=유형이 필요합니다
expected.type.parameter=유형 매개변수가 필요합니다
expected.value=값이 필요합니다
expected.while=''while'' 기대
expected.with=''with''가 필요합니다
filetype.description.class=Java 클래스
filetype.description.java=Java
filetype.description.jshell=JShell 스니펫
finally.without.try=''try''가 없는 ''finally''
import.statement.identifier.or.asterisk.expected.=식별자 또는 ''*''가 필요합니다

java.terms.anonymous.class.base.ref=익명 {0}
javadoc.exception.tag.class.is.not.throwable={0} 클래스는 Throwable의 하위 항목이 아닙니다.
javadoc.exception.tag.exception.is.not.thrown={0} 은(는) {1} 메서드로 던져지도록 선언되지 않았습니다.
javadoc.exception.tag.wrong.tag.value=잘못된 태그 값
javadoc.param.tag.parameter.name.expected=매개변수 이름이 필요합니다
javadoc.param.tag.type.parameter.gt.expected=''>'' 예상
javadoc.param.tag.type.parameter.name.expected=유형 매개변수 이름이 필요합니다
javadoc.ref.tag.class.ref.expected=클래스 참조가 필요합니다
javadoc.value.field.required=@value 태그는 필드를 참조해야 합니다.
javadoc.value.field.with.initializer.required=@value 태그는 상수 이니셜라이저가 포함된 필드를 참조해야 합니다.
javadoc.value.static.field.required=@value 태그는 정적 필드를 참조해야 합니다.
javadoc.value.tag.jdk15.required=JDK 1.4 또는 이전 버전 사용 시 @value 태그에 인수가 포함되지 않을 수 있습니다.
jdk.1.3.language.level.description=1.3 - 일반 구형 Java
jdk.1.4.language.level.description=1.4 - ''assert'' 키워드
jdk.1.5.language.level.description=5 - ''enum'' 키워드, 제네릭, 오토박싱 등
jdk.1.6.language.level.description=6 - 인터페이스 내 @Override 태그
jdk.1.7.language.level.description=7 - 다이아몬드, ARM, 다중 catch 등.
jdk.1.8.language.level.description=8 - 람다, 유형 어노테이션 등
jdk.1.9.language.level.description=9 - 모듈, 인터페이스 내 private 메서드 등.
jdk.10.language.level.description=10 - 지역 변수 유형 추론
jdk.11.language.level.description=11 - 람다 매개변수의 지역 변수 구문
jdk.12.language.level.description=12 - 신규 언어 기능 없음
jdk.13.language.level.description=13 - 신규 언어 기능 없음
jdk.14.language.level.description=14 - Switch 식
jdk.14.preview.language.level.description=14(미리보기) - 기록, 패턴, 텍스트 블록
jdk.15.language.level.description=15 - 텍스트 블록
jdk.15.preview.language.level.description=15 (미리보기) - Sealed 유형, 기록, 패턴, 로컬 열거형 및 인터페이스
jdk.X.language.level.description=X - 실험 기능

local.class.preposition=로컬
method.context.display={1}의 {0}()
node.abstract.flag.tooltip=Abstract
node.annotation.tooltip=어노테이션
node.anonymous.class.tooltip=익명 클래스
node.class.tooltip=클래스
node.enum.tooltip=열거형
node.exception.tooltip=예외
node.field.tooltip=필드
node.final.flag.tooltip=Final
node.interface.tooltip=인터페이스
node.junit.test.tooltip=JUnit 테스트
node.method.tooltip=메서드
node.record.tooltip=기록(미리보기 기능)
node.runnable.class.tooltip=실행 가능한 클래스
node.static.flag.tooltip=정적
psi.error.attempt.to.edit.class.file=''{0}'' 파일에서 컴파일된 요소 수정 불가

task.background.title.maven=Maven

unexpected.identifier=예기치 않은 식별자
unexpected.token=예기치 않은 토큰
unexpected.tokens=예기치 않은 토큰
error.message.wildcard.not.expected=예기치 않은 와일드카드

bad.return.type.in.method.reference=메서드 참조의 잘못된 반환 유형\: {0} 을(를) {1}로 변환 불가
bad.return.type.in.lambda.expression=람다 식의 잘못된 반환 유형\: {0} 을(를) {1}로 변환 불가
bad.return.type.in.lambda.expression1=람다 식의 잘못된 반환 유형\: {0} 을(를) void로 변환 불가
missing.return.value.lambda=반환 값 누락
unexpected.return.value=예기치 않은 반환 값
lambda.body.must.be.a.statement.expression=람다 본문은 구문식이어야 합니다.
diamond.error.explicit.type.parameters.for.constructor=다이아몬드는 생성자의 명시적 유형 매개변수와 함께 사용할 수 없습니다
diamond.error.cannot.infer.arguments=인수를 추론할 수 없습니다
diamond.error.cannot.infer.arguments.unable.to.resolve.constructor=인수를 추론할 수 없습니다(생성자를 해결할 수 없음)
diamond.error.anonymous.inner.classes=''<>''는 익명의 내부 클래스와 함께 사용할 수 없습니다
diamond.error.anonymous.inner.classes.non.private=상위 유형의 메서드를 재정의하거나 구현하지 않는 비 private 메서드가 아니므로 ''<>''를 사용할 수 없습니다
diamond.error.cannot.infer.type.arguments={0}의 유형 인수를 추론할 수 없습니다
error.incompatible.type.no.type.variable=유형 변수의 인스턴스가 없으므로 {0}
error.incompatible.type.no.type.variable.0={0} 유형 변수의 인스턴스가 없으므로 {1}
type.conforms.to.constraint={0}이(가) {1}을(를) 준수합니다
type.can.be.converted={0}을(를) {1}(으)로 변환할 수 있습니다
conflicting.conjuncts={0} 및 {1}
error.type.parameter.has.incompatible.upper.bounds=유형 매개변수 {0}에 호환되지 않는 상위 바운드가 있습니다. {1}
error.incompatible.upper.bounds=호환되지 않는 상위 바운드\: {0}
error.inference.variable.has.incompatible.bounds=추론 변수 {0}에 호환되지 않는 바운드가 있습니다.\n {1}\: {2}\n{3}\: {4}
error.incompatible.type={0}이(가) {1}와(과) 호환되지 않습니다
error.incompatible.type.not.a.functional.interface={0}은(는) 함수 인터페이스가 아닙니다
error.incompatible.type.no.valid.function.type.found={0}에 대한 올바른 함수 유형을 찾을 수 없습니다
error.incompatible.type.parameter.type.is.not.yet.inferred=매개변수 유형이 아직 추론되지 않았습니다. {0}
error.incompatible.type.return.type.is.not.yet.inferred=반환 유형이 아직 추론되지 않았습니다. {0}
error.incompatible.type.unhandled.exception=처리되지 않은 예외\: {0}
error.incompatible.type.failed.to.resolve.argument=인수를 해결하지 못했습니다
error.incompatible.type.incompatible.parameter.types.in.lambda=람다 식에서 호환되지 않는 매개변수 유형
error.incompatible.type.incompatible.types.expected.void.lambda=호환되지 않는 유형\: void가 필요하지만 람다 본문이 구문 표현식도 아니고 void 호환되는 블록도 아닙니다
error.incompatible.type.expected.value.lambda=호환되지 않는 유형\: 비 void가 필요하지만 람다 본문이 값이 호환되지 않는 블록입니다
error.incompatible.type.bad.lambda.return.type=람다 식 내 잘못된 반환 유형\: {0}은(는) {1}(으)로 변환할 수 없습니다
error.incompatible.type.incompatible.parameter.types.in.method.reference=메서드 참조 표현식 내 호환되지 않는 매개변수 유형
error.incompatible.type.incompatible.types.expected.not.void.got.void.method.reference=호환되지 않는 유형\: 비 void가 필요하지만 메서드 참조에 대한 컴파일 타임 선언에 void 반환 유형이 있습니다
error.incompatible.type.declaration.for.the.method.reference.not.found=메서드 참조에 대한 컴파일 타임 선언을 찾을 수 없습니다
error.incompatible.type.expected.non.void.got.void.method.reference=호환되지 않는 유형\: 비 void가 필요하지만 메서드 참조에 대한 컴파일 타임 선언에 void 반환 유형이 있습니다
error.incompatible.type.not.convertible=호환되지 않는 유형\: {0}은(는) {1}(으)로 변환할 수 없습니다
error.incompatible.type.incompatible.equality.constraint=호환되지 않는 상등 제약 조건\: {1} 및 {0}
list.item.no.module=<모듈 없음>
# {0} = localized element kind ('class', 'field', 'method', etc.); {1} = element name  
element.kind.and.name={0} {1}
