fix.insert.delegation.call=''{0}()'' 호출 삽입
fix.introduce.non.null.assertion=null이 아닌 어설션 (\!\!) 호출을 추가합니다.
fix.remove.non.null.assertion=null이 아닌 불필요한 어설션 (\!\!)를 제거합니다
fix.add.annotation.target=어노테이션 대상을 추가합니다
fix.add.const.modifier=''const'' 제어자를 추가합니다
fix.add.constructor.parameter=생성자 매개변수 ''{0}''을(를) 추가합니다.
fix.make.data.class=''{0}''을(를) 데이터 클래스로 만듭니다.
fix.add.default.constructor=''expect'' 클래스에 디폴트 생성자를 추가합니다.
fix.add.explicit.import=명시적 import 문을 추가합니다.
fix.add.function.body=함수 본문을 추가합니다.
fix.add.is.to.when=''{0}'' 앞에 ''is''를 추가합니다.
fix.add.new.line.after.annotations=어노테이션 다음에 새 줄을 추가합니다
fix.make.type.parameter.reified={0}을(를) 구체화하고 {1}을(를) 인라인화합니다.
fix.add.return.last.expression=마지막 표현식에 ''return''을 추가합니다.
fix.add.return.before.expression=표현식 앞에 ''return''을 추가합니다.
fix.add.return.before.lambda.expression=람다 식 앞에 ''run''을 추가합니다.
fix.add.semicolon.lambda.expression=세미콜론으로 선행 호출을 종료합니다.
fix.add.spread.operator.after.sam=''vararg''로서 전달할 때 배열 앞에 스프레드 연산자를 추가합니다.
fix.add.else.branch.when=다른 브랜치를 추가합니다.
fix.replace.with.assign.function.call=''{0}'' 호출로 바꿉니다.
fix.assign.to.property=프로퍼티에 대입합니다.
fix.change.mutability.change.to.val=''{0}''을(를) val로 변경합니다.
fix.change.type.argument=유형 인수를 {0}(으)로 변경합니다.
fix.change.to.function.invocation=함수 호출로 변경합니다.
fix.change.to.mutable.type=유형을 {0}(으)로 변경합니다.

fix.change.to.property.access.family.remove=호출 제거
fix.change.to.property.access.family.change=프로퍼티 액세스로 변경

fix.change.to.labeled.return.family=라벨을 포함하여 반환하도록 변경
fix.change.to.labeled.return.text=''{0}''(으)로 변경합니다.

fix.change.suspend.hierarchy.add=계층 구조의 모든 함수에 ''suspend'' 제어자를 추가합니다.
fix.change.suspend.hierarchy.remove=계층 구조의 모든 함수에서 ''suspend'' 제어자를 제거합니다.
fix.change.progress.looking.inheritors=클래스 {0} 상속자 검색 중…
fix.change.progress.analyzing.class.hierarchy=클래스 계층 구조 분석 중…

fix.change.return.type.family=유형 변경
fix.change.return.type.text.primary.constructor=클래스 ''{1}''의 기본 생성자의 매개변수 ''{0}'' 유형을 ''{2}''(으)로 변경합니다.
fix.change.return.type.text.function=함수 ''{1}''의 매개변수 ''{0}'' 유형을 ''{2}''(으)로 변경합니다.
fix.change.return.type.lambda=람다 식 반환 유형을 {0}(으)로 변경합니다.
fix.change.return.type.remove.explicit.return.type=명시적으로 지정된 반환 유형을 제거합니다.
fix.change.return.type.remove.explicit.return.type.of={0}의 명시적으로 지정된 반환 유형을 제거합니다.
fix.change.return.type.return.type.text=반환 유형을 ''{0}''(으)로 변경합니다.
fix.change.return.type.return.type.text.of={0}의 반환 유형을 ''{1}''(으)로 변경합니다.
fix.change.return.type.type.text=유형을 ''{0}''(으)로 변경
fix.change.return.type.type.text.of={0}의 유형을 ''{1}''(으)로 변경합니다.
fix.change.return.type.presentation.property=프로퍼티 {0}
fix.change.return.type.presentation.function=함수 {0}
fix.change.return.type.presentation.enclosing.function=둘러싸는 함수
fix.change.return.type.presentation.enclosing=둘러싸는 {0}
fix.change.return.type.presentation.called.function=호출된 함수
fix.change.return.type.presentation.accessed=액세스된 {0}
fix.change.return.type.presentation.called=호출된 {0}
fix.change.return.type.presentation.base=기본 {0}

fix.cast.expression.family=표현식 변환
fix.cast.expression.text=표현식 ''{0}''을(를) ''{1}''(으)로 형 변환합니다.

fix.change.accessor.family=접근자 유형 변경
fix.change.accessor.getter=getter 유형을 {0} (으)로 변경합니다
fix.change.accessor.setter.parameter=setter 매개변수 유형을 {0} (으)로 변경합니다

fix.create.from.usage.dialog.title=사용 위치에서 생성

fix.add.remaining.branches=남아 있는 브랜치를 추가합니다.
fix.add.remaining.branches.with.star.import=* import 문이 있는 남아 있는 브랜치를 추가합니다.

fix.add.type.annnotation.family=유형 어노테이션 추가
fix.add.type.annnotation.text=유형 ''{0}''을(를) 매개변수 ''{1}''에 추가합니다.

fix.add.tostring.call.family=''toString()'' 호출 추가
fix.add.tostring.call.text=''toString()'' 호출을 추가합니다.
fix.add.tostring.call.text.safe=안전한 ''?.toString()'' 호출을 추가합니다.

fix.add.star.projection.family=스타 프로젝션 추가
fix.add.star.projection.text=''{0}''을(를) 추가합니다.

fix.change.to.star.projection.family=스타 프로젝션으로 변경
fix.change.to.star.projection.text=유형 인수를 {0}(으)로 변경합니다.

fix.change.to.use.spread.operator.family=스프레드 연산자를 사용하도록 변경
fix.change.to.use.spread.operator.text=''{0}''을(를) ''{1}''(으)로 변경합니다.

fix.change.type.family=유형 변경
fix.change.type.text=유형을 ''{0}''에서 ''{1}''(으)로 변경합니다.

fix.add.suspend.modifier.function={0} 을(를) 일시 중지합니다
fix.add.suspend.modifier.function.generic=포함 함수를 일시 중지합니다
fix.add.suspend.modifier.receiver={0} 유형을 일시 중지합니다.
fix.add.suspend.modifier.receiver.generic=리시버 유형을 일시 중지합니다.

fix.add.property.to.supertype.family=상위 유형에 프로퍼티 추가
fix.add.property.to.supertype.text=''{0}''을(를) ''{1}''에 추가합니다.
fix.add.property.to.supertype.text.generic=상위 유형에 프로퍼티 추가…
fix.add.property.to.supertype.progress=유형에 프로퍼티 추가
fix.add.property.to.supertype.choose.type=유형 선택

fix.add.function.parameters.change.signature.constructor=생성자 ''{0}'' 의 시그니처를 변경합니다
fix.add.function.parameters.change.signature.function=함수 ''{0}'' 의 시그니처를 변경합니다
fix.add.function.parameters.add.parameter.constructor={0,number,ordinal}번째 {1,choice,1\#매개변수|2\#매개변수}를 생성자 ''{2}''에 추가합니다.
fix.add.function.parameters.add.parameter.function={0,number,ordinal}번째 {1,choice,1\#매개변수|2\#매개변수}를 함수 ''{2}''에 추가합니다.
fix.add.function.parameters.add.parameter.generic.constructor={0,choice,1\#매개변수|2\#매개변수}를 생성자 ''{1}''에 추가합니다.
fix.add.function.parameters.add.parameter.generic.function={0,choice,1\#매개변수|2\#매개변수}를 함수 ''{1}''에 추가합니다.

fix.change.signature.family=함수/생성자의 시그니처 변경
fix.change.signature.function.family=함수 시그니처 변경
fix.change.signature.function.text=함수 시그니처를 ''{0}''(으)로 변경합니다.
fix.change.signature.function.text.generic=함수 시그니처 변경...
fix.change.signature.function.popup.title=시그니처 선택
fix.change.signature.lambda=람다 식의 시그니처를 변경합니다
fix.change.signature.remove.parameter=매개변수 ''{0}''을(를) 제거합니다.
fix.change.signature.unavailable=<사용할 수 없음>
fix.change.signature.error=<오류>
fix.change.signature.unnamed.parameter=매개 변수

fix.change.object.to.class=''object''를 ''class''로 변경합니다.

fix.add.function.supertype.family=상위 유형에 함수 추가
fix.add.function.supertype.text=상위 유형에 함수 추가...
fix.add.function.supertype.progress=유형에 함수 추가
fix.add.function.supertype.choose.type=유형 선택
fix.add.function.supertype.add.to=''{0}''을(를) ''{1}''에 추가합니다.

fix.add.generic.upperbound.text=''{0}''을(를) ''{1}''의 상위 바운드로서 추가합니다.
fix.add.generic.upperbound.family=제네릭 상위 바운드 추가

fix.add.modifier.inline.parameter.family=''{0}''을(를) 매개변수에 추가합니다.
fix.add.modifier.inline.parameter.text=''{0}''을(를) 매개변수 ''{1}''에 추가합니다.

fix.add.modifier.inline.function.family=함수에 ''inline'' 추가
fix.add.modifier.inline.function.text=함수 ''{0}''에 ''inline''을 추가합니다.

fix.add.array.of.type.text={0} 래퍼를 추가합니다.
fix.add.array.of.type.family=''arrayOf'' 래퍼 추가

fix.add.loop.label.text.generic=루프에 라벨을 추가합니다.
fix.add.loop.label.text=''{0}''을(를) {1}에 추가합니다.

fix.add.modifier.family=제어자 추가
fix.add.modifier.text={0}을(를) ''{1}''(으)로 만듭니다.
fix.add.modifier.text.generic=''{0}'' 제어자를 추가합니다

fix.add.argument.name.family=인수에 이름 추가
fix.add.argument.name.text.generic=인수에 이름 추가...
fix.add.argument.name.text=인수 ''{0}''에 이름을 추가합니다.
fix.add.argument.name.step.choose.parameter.name=매개변수 이름을 선택합니다.

fix.change.feature.support.family={0} 지원 활성화/비활성화
fix.change.feature.support.enabled={0} 지원을 활성화합니다.
fix.change.feature.support.enabled.warning={0} 지원을 활성화합니다(경고 표시).
fix.change.feature.support.disabled={0} 지원을 비활성화합니다.

fix.create.expect.actual=expect/actual 선언을 생성합니다.
fix.create.missing.actual.members=누락된 실제 멤버를 추가합니다.

fix.create.declaration.error={0}을(를) 생성할 수 없습니다. {1}
fix.create.declaration.error.inaccessible.type=액세스할 수 없는 유형
fix.create.declaration.error.some.types.inaccessible=액세스할 수 없는 유형\:

fix.add.annotation.family=어노테이션 추가
fix.add.annotation.text.self=''@{0}'' 어노테이션을 추가합니다
fix.add.annotation.text.declaration=''@{0}'' 어노테이션을 ''{1}''에 추가합니다
fix.add.annotation.text.containing.class=''@{0}'' 어노테이션을 포함 클래스 ''{1}'' 에 추가합니다

fix.import=가져오기
fix.import.kind.delegate.accessors=접근자를 위임합니다.
fix.import.kind.component.functions=구성 요소 함수
fix.import.exclude=자동 가져오기에서 ''{0}''을(를) 제외합니다.

fix.move.file.to.package.family=파일을 패키지가 일치하는 디렉터리로 이동
fix.move.file.to.package.text=파일을 {0}(으)로 이동합니다.

fix.change.package.family=파일의 패키지를 디렉터리와 일치하도록 변경
fix.change.package.text=파일의 패키지를 {0}(으)로 변경합니다.

action.add.import.chooser.title=가져오기

goto.super.chooser.function.title=상위 함수 선택
goto.super.chooser.property.title=상위 프로퍼티 선택
goto.super.chooser.class.title=상위 클래스 또는 인터페이스 선택

inspection.unused.receiver.parameter=리시버 매개변수가 전혀 사용되지 않습니다.
fix.unused.receiver.parameter.remove=중복 리시버 매개변수를 제거합니다.

inspection.migration.title=코드 마이그레이션
inspection.migration.profile.name=마이그레이션

fix.create.from.usage.family=사용 위치에서 생성
fix.create.from.usage.local.variable=지역 변수 ''{0}''을(를) 생성합니다.

overridden.marker.implementations.multiple=구현이 있습니다.
overridden.marker.implementation=다음에서 구현됩니다. <br/>
overridden.marker.overrides.multiple=하위 클래스에서 재정의됩니다.
overridden.marker.overrides=다음에서 재정의됩니다. <br/>
searching.for.overriding.methods=재정의하는 메서드 검색

overridden.marker.implementations.choose.implementation.title={0}의 구현 선택
overridden.marker.implementations.choose.implementation.find.usages={0}의 프로퍼티 재정의
overridden.marker.overrides.choose.implementation.title={0}의 상위 구현 선택
overridden.marker.overrides.choose.implementation.find.usages={0}의 상위 구현

remove.expression=''{0}'' 제거
unwrap.expression=''{0}'' 래핑 해제
remove.else=''{0}''에서 else를 제거합니다.
unwrap.else=''{0}''에서 else를 줄 바꿈 해제합니다.

override.declaration.x.in.y={1}의 {0}
override.declaration.x.implements.y={1}의 {0}에서 {3}의 {2}을(를) 구현합니다.
override.declaration.x.overrides.y.in.class.list={0}이(가) 다음 클래스/인터페이스, {1}에서 선언을 재정의합니다. 기본 선언을 {2}하시겠어요?

override.declaration.unused.overriding.methods.title=사용되지 않는 재정의 멤버
override.declaration.unused.overriding.methods.description=삭제한 메서드를 재정의하는 사용되지 않는 멤버가 있습니다.
override.declaration.choose.to.delete=삭제할 항목을 선택합니다.
override.declaration.member=구성원
override.declaration.delete.multiple.parameters={0} 은(는) 메서드 계층 구조의 일부입니다. 여러 매개변수를 삭제하시겠어요?

hierarchy.legend.member.is.defined.in.class=멤버는 클래스에 정의되어 있습니다.
hierarchy.legend.member.defined.in.superclass=멤버는 클래스가 아닌 상위 클래스에 정의되어 있습니다.
hierarchy.legend.member.should.be.defined=클래스가 추상적이지 않으므로 멤버를 정의해야 합니다.

intention.change.package.text=패키지 변경

intention.extract.declarations.from.file.text=현재 파일에서 선언 추출
intention.extract.declarations.from.file.text.details=현재 파일에서 ''{0}'' {1, choice, 0\#| 1\#및 하위 클래스 }추출

kotlin.compiler.option.generate.no.warnings=컴파일러 경고 보고(&W)
kotlin.compiler.option.additional.command.line.parameters=추가 명령줄 매개변수(&A)\:

kotlin.compiler.jvm.option.panel.title=Kotlin에서 JVM으로

kotlin.compiler.js.option.panel.title=Kotlin에서 JavaScript로
kotlin.compiler.js.option.generate.sourcemaps=소스 맵 생성(&S)
kotlin.compiler.js.option.output.prefix=생성된 코드 앞에 추가할 파일(&P)\:
kotlin.compiler.js.option.output.postfix=생성된 코드에 추가할 파일(&O)\:
kotlin.compiler.js.option.output.copy.files=라이브러리 런타임 파일 복사(&C)

# Android Lint
android.klint.inspections.group.name=Kotlin용 Android Lint

# Scratch Files
scratch.run.button=스크래치 파일 실행
scratch.run.from.here.button=여기에서 스크래치 실행
scratch.stop.button=스크래치 실행 중지
scratch.clear.button=결과 지우기
scratch.module.combobox=모듈 클래스 경로 사용
scratch.is.repl.checkbox=REPL 사용
scratch.is.repl.checkbox.description=Kotlin REPL로 실행합니다. 스크래치 끝에 추가된 새 표현식만 실행합니다.
scratch.is.interactive.checkbox=대화형 모드
scratch.is.interactive.checkbox.description=입력을 중지한 후 {0}초 후에 실행됩니다.
scratch.make.before.run.checkbox=실행하기 전에 모듈 생성
scratch.make.before.run.checkbox.description=스크래치 실행 전에 모듈 {0}을(를) 생성합니다. 이 범위에서는 컴파일된 코드에만 도달할 수 있습니다.
scratch.inlay.output.mode=인레이 출력 모드\n\n출력이 코드 에디터에서 표현식 바로 옆에 표시됩니다. 짧은 한 줄 출력에 적합합니다.
scratch.side.panel.output.mode.description=측면 패널 출력 모드
scratch.side.panel.output.mode=측면 패널 출력 모드\n\n출력이 별도의 패널에 표시됩니다. 출력이 길거나 여러 줄인 경우에 유용합니다.
scratch.inlay.output.mode.description=인레이 출력 모드

# Code insight
dialog.import.on.paste.title3=제거할 가져오기 선택
copy.paste.reference.notification={0}개의 {0, choice, 1\#import 문이|2\#import 문이} 추가되었습니다.<p><span><a href\=''show''>추가된 import 문 검토...</a></span>

# Experimental features
experimental.ml.completion=Kotlin용 ML 완성


plugin.verifier.compatibility.issue.title=호환성 문제
plugin.verifier.compatibility.issue.message=설치된 Kotlin 플러그인 버전({0})이 {1}와(과) 호환되지 않습니다.\n일부 기능이 손상될 수 있습니다.\n\nKotlin 플러그인을 다시 설치하세요.

plugin.updater.notification.group=Kotlin 플러그인 업데이트
plugin.updater.notification.title=Kotlin
plugin.updater.notification.message=Kotlin 플러그인의 새 버전 {0}을(를) 사용할 수 있습니다. <b><a href\="\#">설치하기</a></b>
plugin.updater.downloading=플러그인 다운로드
plugin.updater.not.installed=플러그인 업데이트가 설치되지 않았습니다. <a href\="\#">로그에서 자세한 내용 확인하기</a>
plugin.updater.not.installed.misc=플러그인 업데이트가 설치되지 않았습니다. {0} <a href\="\#">로그에서 자세한 내용 확인하기</a>
plugin.updater.error.check.failed=Kotlin 플러그인 업데이트 확인 실패
plugin.updater.error.unexpected.repository.response=예기치 않은 플러그인 저장소 응답
plugin.updater.error.cant.find.plugin.version=저장소 응답에서 플러그인 버전을 찾을 수 없습니다.
plugin.updater.error.custom.repository=사용자 지정 플러그인 저장소 {0}을(를) 확인하지 못했습니다.

quick.doc.text.enum.ordinal=열거형 상수 서수\: {0}
quick.doc.text.tailrec=''tailrec''은 함수를 <a href\="https\://kotlinlang.org/docs/reference/functions.html\#tail-recursive-functions">꼬리 재귀적</a>으로 표시합니다(컴파일러가 재귀를 반복으로 바꾸도록 허용).
quick.doc.text.lateinit=''lateinit''은 <a href\="https\://kotlinlang.org/docs/reference/properties.html\#late-initialized-properties-and-variables">생성자 외부에 있는 null이 아닌 프로퍼티</a>을 초기화할 수 있도록 허용합니다.
quick.doc.no.documentation=사용할 수 있는 문서가 없습니다.
quick.doc.section.deprecated=중단된 기능\:
quick.doc.section.replace.with=다음으로 바꾸기\:
quick.doc.section.java.declaration=Java 선언\:

action.decompile.java.name=Java로 디컴파일
action.decompile.busy.text=Kotlin 클래스 파일

action.j2k.name=Java를 Kotlin으로 변환
action.j2k.task.name=파일을 Java에서 Kotlin으로 변환
action.j2k.correction.investigate=오류 조사
action.j2k.correction.proceed=변환 진행
action.j2k.correction.required=이 변환을 수행하면 프로젝트의 나머지 부분에 있는 일부 코드를 수정해야 할 수 있습니다. 해당 코드를 검색한 후 함께 수정하시겠어요?
action.j2k.correction.errors.single=''{0}''에 구문 오류가 있어 변환 결과가 올바르지 않을 수 있습니다.
action.j2k.correction.errors.multiple=''{0}'' 및 기타 {1}개의 Java 파일에 구문 오류가 있어 변환 결과가 올바르지 않을 수 있습니다.
action.j2k.error.cant.save.result=변환 결과 {0}을(를) 저장하지 못했습니다.
action.j2k.error.cant.find.document=''{0}'' 관련 문서를 찾을 수 없습니다.
action.j2k.error.read.only=파일 ''{0}'' 은 읽기 전용입니다
action.j2k.errornothing.to.convert=변환할 것이 없습니다.<br>쓰기 가능한 Java 파일을 찾을 수 없습니다.

formatter.settings.title=Kotlin 서식 지정 도구 설정

action.generate.functions.already.defined=함수 {0}이(가) 클래스 {1}에 대해 이미 정의되어 있습니다. 해당 함수를 삭제하고 계속하시겠어요?

action.generate.equals.choose.equals=''equals()''에 포함할 프로퍼티 선택
action.generate.equals.choose.hashcode=''hashCode()''에 포함할 프로퍼티 선택

action.generate.secondary.constructor.choose.properties=생성자로 초기화할 프로퍼티 선택
action.generate.secondary.constructor.error.already.exists=생성자가 이미 있습니다.

action.generate.test.support.choose.framework=프레임워크 선택
action.generate.test.support.generate.test.function=테스트 함수 생성
action.generate.test.support.choose.test.name=테스트 이름 선택\:
action.generate.test.support.edit.template=템플릿 편집
action.generate.test.support.error.no.template.found={0}에 대한 템플릿을 찾을 수 없습니다. {1}
action.generate.test.support.error.cant.convert.java.template=Java 템플릿을 Kotlin으로 변환하지 못했습니다.
action.generate.test.support.error.cant.generate.method=메서드 {0}을(를) 생성할 수 없습니다.

action.generate.tostring.name=toString() 생성
action.generate.tostring.template.single=단일 템플릿
action.generate.tostring.template.multiple=연결이 있는 여러 템플릿
action.generate.tostring.choose.implementation=구현 선택\:
action.generate.tostring.generate.super.call=super.toString() 호출 생성

action.new.file.text=Kotlin 클래스/파일
action.new.file.description=새 Kotlin 클래스 또는 파일 생성
action.new.file.dialog.title=새 Kotlin 클래스/파일
action.new.file.dialog.file.title=파일
action.new.file.dialog.class.title=클래스
action.new.file.dialog.data.class.title=데이터 클래스
action.new.file.dialog.sealed.class.title=봉인된 클래스
action.new.file.dialog.annotation.title=어노테이션
action.new.file.dialog.interface.title=인터페이스
action.new.file.dialog.enum.title=열거형 클래스
action.new.file.dialog.object.title=객체
action.new.file.error.empty.name=이름이 있어야 합니다.
action.new.file.error.empty.name.part=이름에 빈 부분이 있으면 안 됩니다.

action.new.script.name=Kotlin 스크립트
action.new.script.description=새 Kotlin 스크립트를 생성합니다.
action.new.script.dialog.title=새 Kotlin 스크립트

action.new.worksheet.name=Kotlin 워크시트
action.new.worksheet.description=새 Kotlin 워크시트 생성
action.new.worksheet.dialog.title=새 Kotlin 워크시트

breadcrumbs.tooltip.indexing=색인 생성 중…

copy.paste.resolve.references=붙여넣은 참조 해결

type.provider.anonymous.object=익명 객체
type.provider.unknown.type=알 수 없는 유형
type.provider.smart.cast.from=({0}의 스마트 캐스트)
type.provider.no.expression.found=표현식을 찾을 수 없습니다

optimize.imports.collect.unused.imports=사용되지 않은 import 문 수집
optimize.imports.task.removing.redundant.imports=중복 import 문 제거

kdoc.section.title.receiver=리시버
kdoc.section.title.parameters=매개변수
kdoc.section.title.returns=리턴
kdoc.section.title.throws=처리
kdoc.section.title.author=작성자
kdoc.section.title.properties=프로퍼티
kdoc.section.title.constructor=생성자
kdoc.section.title.since=시작 시간
kdoc.section.title.suppress=억제
kdoc.section.title.samples=샘플
kdoc.section.title.see.also=관련 주제
kdoc.comment.unresolved=미해결

livetemplate.description.main=main() 함수
livetemplate.description.soutp=함수 매개변수 이름 및 값을 System.out으로 출력합니다.
livetemplate.description.iter=반복 가능한 요소(for-in 루프)를 반복합니다.
livetemplate.description.ifn=''if null'' 식을 삽입합니다.
livetemplate.description.inn=''if not null'' 식을 삽입합니다.
livetemplate.description.void=아무 것도 반환하지 않는 함수
livetemplate.description.fun0=매개변수가 없는 함수
livetemplate.description.fun1=매개변수가 1개 있는 함수
livetemplate.description.fun2=매개변수가 2개 있는 함수
livetemplate.description.interface=인터페이스
livetemplate.description.singleton=싱글턴
livetemplate.description.closure=클로저(이름 없는 함수)
livetemplate.description.anonymous=익명 클래스
livetemplate.description.exfun=확장 함수
livetemplate.description.exval=확장 읽기 전용 프로퍼티
livetemplate.description.exvar=확장 읽기/쓰기 프로퍼티

hints.progress.calculating.parameter.info=매개변수 정보 계산 중

hints.settings.common.items=다음에 대한 힌트 표시\:
hints.settings.types=유형
hints.settings.types.property=프로퍼티 유형
hints.settings.types.variable=지역 변수 유형
hints.settings.types.return=함수 반환 유형
hints.settings.types.parameter=함수 매개변수 유형

hints.settings.lambdas=람다
hints.settings.lambda.return=return 식
hints.settings.lambda.receivers.parameters=묵시적 리시버 및 매개변수

hints.settings.suspending=호출 일시 중지

hints.title.argument.name.enabled=인수 이름

presentation.text.paren=({0})
presentation.text.in.container.paren=({0} 내)
presentation.text.in.container={1}의 {0}
presentation.text.for.receiver.in.container.paren=({1} 내 {0} 대상)
presentation.text.object.in.container={0} 내 객체

project.view.class.initializer=\ 클래스 이니셜라이저
project.view.class.error.name=이름이 제공되지 않음

copy.text.adding.imports=import 문 추가 중...
copy.text.clipboard.content.seems.to.be.java.code.do.you.want.to.convert.it.to.kotlin=클립보드 내용이 Java 코드인 것 같습니다. Kotlin으로 변환하시겠어요?
copy.text.convert.java.to.kotlin=Java를 Kotlin으로 변환
copy.text.copied.kotlin.code=복사된 Kotlin 코드
copy.text.resolving.references=참조 해결 중...
copy.title.convert.code.from.java=Java에서 코드 변환

editor.checkbox.title.auto.add.val.keyword.to.data.inline.class.constructor.parameters=데이터/인라인 클래스 생성자 매개변수에 val 키워드 자동 추가
editor.checkbox.title.convert.pasted.java.code.to.kotlin=붙여넣은 Java 코드를 Kotlin으로 변환
editor.checkbox.title.don.t.show.java.to.kotlin.conversion.dialog.on.paste=붙여넣기 시 Java에서 Kotlin으로 변환하는 대화상자에 표시 안 함
editor.title.kotlin=Kotlin

facet.checkbox.text.use.project.settings=프로젝트 설정 사용
facet.column.name.options=옵션
facet.column.name.plugin=플러그인
facet.error.text.at.least.one.target.platform.should.be.selected=하나 이상의 대상 플랫폼을 선택해야 합니다.
facet.label.text.selected.target.platforms=선택한 대상 플랫폼\:
facet.label.text.target.platform=대상 플랫폼\:
facet.label.text.the.project.is.imported.from.external.build.system.and.could.not.be.edited=외부 빌드 시스템에서 가져온 프로젝트이므로 편집할 수 없습니다.
facet.link.text.edit.project.settings=프로젝트 설정 편집
facet.name.compiler.plugins=컴파일러 플러그인
facet.name.general=일반
facet.text.following.arguments.are.redundant=다음 인수가 중복됩니다. {0}
facet.text.following.arguments.override.facet.settings=다음 인수가 패싯 설정을 재정의합니다. {0}
facet.text.following.options.are.not.correct=다음 옵션이 올바르지 않습니다.
facet.text.multiplatform=멀티플랫폼

filters.text.inline.function.body=함수 본문 인라인화
filters.text.inline.function.call.site=함수 호출 사이트 인라인화
filters.title.navigate.to=다음으로 이동

find.usages.progress.text.declaration.superMethods=상위 메서드 해결 중...

formatter.button.text.use.import.with.when.at.least=다음의 경우 ''*''가 있는 import 문 사용
formatter.button.text.use.import.with=''*''가 있는 import 문 사용
formatter.button.text.use.single.name.import=단일 이름 import 문 사용
formatter.checkbox.text.insert.imports.for.nested.classes=중첩된 클래스에 대한 import 문 삽입
formatter.checkbox.text.use.trailing.comma=후행 쉼표 사용
formatter.text.names.used=\ 사용된 이름
formatter.text.use.defaults.from=다음의 디폴트 값 사용\:
formatter.title.after.colon.before.declaration.type=콜론 뒤, 선언 유형 앞
formatter.title.after.colon.in.new.type.definition=새 유형 정의 내 콜론 뒤
formatter.title.align.when.branches.in.columns=열에 ''when'' 브랜치 정렬
formatter.title.around.arrow.in.function.types=함수 유형의 화살표 주위
formatter.title.around.arrow.in="when" 절의 화살표 주위
formatter.title.around.when.branches.with={}가 있는 ''when'' 브랜치 주위
formatter.title.before.declaration.with.comment.or.annotation=주석 또는 어노테이션이 있는 선언 앞
formatter.title.before.colon.after.declaration.name=콜론 앞, 선언 이름 뒤
formatter.title.before.colon.in.new.type.definition=새 유형 정의 내 콜론 앞
formatter.title.before.lambda.arrow=람다 화살표 앞
formatter.title.chained.function.calls=체인 함수 호출
formatter.title.elvis.expressions=Elvis 식
formatter.title.expression.body.functions=표현식 본문 함수
formatter.title.function.annotations=함수 어노테이션
formatter.title.function.call.arguments=함수 호출 인수
formatter.title.function.declaration.parameters=함수 선언 매개변수
formatter.title.function.parentheses=함수 소괄호
formatter.title.in.simple.one.line.methods=간단한 한 줄 메서드로
formatter.title.java.statics.and.enum.members=Java 정적 및 열거형 멤버
formatter.title.load.save=로드/저장
formatter.title.other=기타
formatter.title.trailing.comma=후행 쉼표
formatter.title.property.annotations=프로퍼티 어노테이션
formatter.title.put.left.brace.on.new.line=새 줄에 왼쪽 중괄호 배치
formatter.title.range.operator=범위 연산자 (..)
formatter.title.top.level.symbols=최상위 심볼
formatter.title.use.continuation.indent.in.conditions=조건에서 연속 들여쓰기 사용
formatter.title.use.continuation.indent=연속 들여쓰기 사용
formatter.title.when.parentheses=''when'' 소괄호
formatter.title.when.statements=''when'' 구문

framework.name.kotlin.sdk=Kotlin SDK

hierarchy.text.anonymous=[익명]
hierarchy.text.in=\ {0} 내

highlighter.action.text.go.to.actual.declarations=actual 선언으로 이동
highlighter.action.text.go.to.expected.declaration=expected 선언으로 이동
highlighter.action.text.go.to.implementations=구현으로 이동
highlighter.action.text.go.to.overridden.methods=재정의된 메서드로 이동
highlighter.action.text.go.to.overridden.properties=재정의된 프로퍼티로 이동
highlighter.action.text.go.to.subclasses=하위 클래스로 이동
highlighter.action.text.go.to.super.method=상위 메서드로 이동
highlighter.action.text.go.to.super.property=상위 프로퍼티로 이동
highlighter.descriptor.text.android.extensions.property=프로퍼티 및 변수//Android Extensions 통합 프로퍼티
highlighter.descriptor.text.annotation=어노테이션//어노테이션 이름
highlighter.descriptor.text.annotation.attribute.name=어노테이션//어노테이션 속성 이름
highlighter.descriptor.text.arrow=괄호 및 연산자//화살표
highlighter.descriptor.text.builtin.annotation=키워드//제어자
highlighter.descriptor.text.builtin.keyword.val=키워드//''val''
highlighter.descriptor.text.builtin.keyword.var=키워드//''var''
highlighter.descriptor.text.builtin.keyword=키워드//키워드
highlighter.descriptor.text.captured.variable=프로퍼티 및 변수//클로저에서 캡처된 변수 및 값
highlighter.descriptor.text.closure.braces=괄호 및 연산자//람다 식 괄호 및 화살표
highlighter.descriptor.text.colon=괄호 및 연산자//콜론
highlighter.descriptor.text.constructor.call=함수//생성자 호출
highlighter.descriptor.text.double.colon=괄호 및 연산자//이중 콜론
highlighter.descriptor.text.dynamic.fun.call=함수//동적 함수 호출
highlighter.descriptor.text.dynamic.property=프로퍼티 및 변수//동적 프로퍼티
highlighter.descriptor.text.enumEntry=클래스 및 인터페이스//열거형 항목
highlighter.descriptor.text.exclexcl=괄호 및 연산자//null이 아닌 어설션
highlighter.descriptor.text.extension.fun.call=함수//확장 함수 호출
highlighter.descriptor.text.extension.property=프로퍼티 및 변수//확장 프로퍼티
highlighter.descriptor.text.field=프로퍼티 및 변수//백킹 필드 변수
highlighter.descriptor.text.fun.call=함수//함수 호출
highlighter.descriptor.text.fun=함수//함수 선언
highlighter.descriptor.text.instance.property.custom.property.declaration=프로퍼티 및 변수//사용자 지정 프로퍼티 선언이 있는 인스턴스 프로퍼티
highlighter.descriptor.text.instance.property=프로퍼티 및 변수//인스턴스 프로퍼티
highlighter.descriptor.text.it=매개변수//람다 식 디폴트 매개변수
highlighter.descriptor.text.kdoc.comment=주석//KDoc//KDoc 주석
highlighter.descriptor.text.kdoc.tag=주석//KDoc//KDoc 태그
highlighter.descriptor.text.kdoc.value=주석//KDoc//KDoc 태그 내 링크
highlighter.descriptor.text.label=라벨
highlighter.descriptor.text.local.variable=프로퍼티 및 변수//지역 변수 또는 값
highlighter.descriptor.text.named.argument=이름 지정된 인수
highlighter.descriptor.text.object=클래스 및 인터페이스//객체
highlighter.descriptor.text.enum=클래스 및 인터페이스//열거형
highlighter.descriptor.text.package.fun.call=함수//패키지 수준 함수 호출
highlighter.descriptor.text.package.property.custom.property.declaration=프로퍼티 및 변수//사용자 지정 프로퍼티 선언이 있는 패키지 수준 프로퍼티
highlighter.descriptor.text.package.property=프로퍼티 및 변수//패키지 수준 프로퍼티
highlighter.descriptor.text.quest=괄호 및 연산자//유형 null 값 가능성 마커
highlighter.descriptor.text.safe.access=괄호 및 연산자//안전한 액세스 마침표
highlighter.descriptor.text.smart.cast.receiver=스마트 캐스트//스마트 캐스트 묵시적 리시버
highlighter.descriptor.text.smart.cast=스마트 캐스트//스마트 캐스트 값
highlighter.descriptor.text.smart.constant=스마트 캐스트//스마트 상수
highlighter.descriptor.text.string.escape=문자열// 문자열 및 템플릿 괄호 내 이스케이프
highlighter.descriptor.text.suspend.fun.call=함수//함수 호출 일시 중지
highlighter.descriptor.text.synthetic.extension.property=프로퍼티 및 변수//통합 확장 프로퍼티
highlighter.descriptor.text.typeAlias=클래스 및 인터페이스//유형 별칭
highlighter.descriptor.text.var=프로퍼티 및 변수//Var(가변 변수, 매개변수 또는 프로퍼티)
highlighter.descriptor.text.variable.as.function.call=프로퍼티 및 변수//함수 호출로서의 변수
highlighter.descriptor.text.variable.as.function.like.call=프로퍼티 및 변수//함수 같은 호출로서의 변수
highlighter.message.suspend.function.call=함수 호출 일시 중지
highlighter.message.suspending.iteration=반복 일시 중지
highlighter.name.dsl.markers=DSL 마커
highlighter.name.dsl=Dsl//
highlighter.name.implemented.declaration=구현된 선언
highlighter.name.implementing.declaration=선언 구현
highlighter.name.kotlin.line.markers=Kotlin 줄 마커
highlighter.name.multiplatform.actual.declaration=멀티플랫폼 실제 선언
highlighter.name.multiplatform.expect.declaration=멀티플랫폼 기대 선언
highlighter.name.overridden.declaration=재정의된 선언
highlighter.name.overriding.declaration=선언 재정의
highlighter.name.style=스타일
highlighter.notification.text.navigation.to.overriding.classes.is.not.possible.during.index.update=색인 업데이트 중에는 클래스를 재정의하는 탐색이 불가능합니다.
highlighter.prefix.text.has.actuals.in=실제 포함
highlighter.text.click.for.navigate={0}을(를) 클릭하여 탐색
highlighter.text.has.functional.implementations=함수 구현 포함
highlighter.text.implements=구현
highlighter.text.in=''{1}'' 내 {0}
highlighter.text.modules=\ ({0} 모듈)
highlighter.text.or.press=\ 또는 {0} 누르기
highlighter.text.overrides=재정의
highlighter.title.actuals.for={0}에 대한 실제
highlighter.title.choose.actual.for={0}에 대한 실제 선택
highlighter.title.choose.expected.for={0}에 필요한 항목 선택
highlighter.title.expected.for={0}에 대한 기대
highlighter.title.overriding.declarations.of={0}의 선언 재정의
highlighter.title.searching.for.overriding.declarations=재정의하는 선언 검색
highlighter.title.searching.for.overriding.methods=재정의하는 메서드 검색
highlighter.tool.tip.has.declaration.in.common.module=공통 모듈에 선언이 있습니다.
highlighter.tool.tip.marker.annotation.for.dsl=DSL에 대한 마커 어노테이션
highlighter.tool.tip.text.function=함수
highlighter.tool.tip.text.property=프로퍼티
highlighter.tool.tip.text.recursive.call=재귀적 호출
highlighter.tool.tip.text.run.test=테스트 실행

import.optimizer.notification.text.unused.imports.not.found=사용되지 않는 import 문을 찾을 수 없습니다.
import.optimizer.progress.indicator.text.collect.imports.for={0}에 대한 import 문을 수집합니다.
import.optimizer.text.import={0, choice, 0\#import 문|2\#import 문}
import.optimizer.text.non.zero={0} {1} 제거{2, choice, 0\#|1\# 및 {2} {3} 추가}
import.optimizer.text.zero=재정렬된 import 문

internal.action.text.decompile.kotlin.bytecode=Kotlin 바이트코드 디컴파일
internal.error.text.cannot.decompile={0}을(를) 디컴파일할 수 없습니다.
internal.indicator.text.decompiling={0} 디컴파일
internal.title.decompiler.error=디컴파일러 오류

version.title.no.runtime.found=런타임을 찾을 수 없음
version.dialog.message.is.not.found.make.sure.plugin.is.properly.installed={0}을(를) 찾을 수 없습니다. 플러그인이 올바르게 설치되어 있는지 확인하세요.
version.message.is.deprecated.since.1.2.0.and.should.be.replaced.with={0} 은(는) 1.2.0 이후 더 이상 사용되지 않으므로 {1}(으)로 바꿔야 합니다.

update.name.android.studio=Android Studio
update.reason.text.exception.during.verification=검사 {0} 중 예외가 발생했습니다.
update.reason.text.no.verified.versions.for.this.build=이 빌드에 대해 확인된 버전이 없습니다.
update.reason.text.unable.to.connect.to.compatibility.verification.repository=호환성 확인 저장소에 연결할 수 없습니다.
update.reason.text.unable.to.parse.compatibility.verification.metadata=호환성 확인 메타데이터를 구문 분석할 수 없습니다.
update.reason.text.version.to.be.verified=버전을 확인해야 합니다.

test.integration.button.text.cancel=취소
test.integration.button.text.rewrite=재작성
test.integration.message.text.create.test.in.the.same.source.root=동일한 소스 루트에서 테스트를 생성하시겠어요?
test.integration.message.text.kotlin.class=Kotlin 클래스 ''{0}''이(가) 이미 있습니다. 업데이트하시겠어요?
test.integration.title.no.test.roots.found=테스트 루트를 찾을 수 없음

slicer.text.in=내
slicer.text.tracking.enclosing.lambda=\ (둘러싸는 람다 추적)
slicer.text.tracking.lambda.calls=\ (람다 호출 추적)
slicer.text.tracking.lambda.argument=\ (람다 매개변수 추적)
slicer.text.tracking.lambda.receiver=\ (람다 리시버 추적)
slicer.title.dataflow.from.here=여기에서 유입되는 데이터 흐름
slicer.title.dataflow.to.here=여기로 유입되는 데이터 흐름
slicer.tool.tip.text.variable.dereferenced=역참조된 변수

script.action.text.ignore=무시
script.action.text.open.settings=설정 열기
script.action.text.show.all=모두 표시
script.name.kotlin.scripting=Kotlin 스크립트
script.progress.text.kotlin.scanning.dependencies.for.script.definitions=Kotlin\: 스크립트 정의에 대한 종속성 검색 중...
script.text.multiple.script.definitions.are.applicable.for.this.script=이 스크립트에는 여러 스크립트 정의를 적용할 수 있습니다. {0}이(가) 사용됩니다.

roots.description.text.update.source.roots.for.non.jvm.modules.in.kotlin.project=Kotlin 프로젝트에서 JVM이 아닌 모듈에 대한 소스 루트를 업데이트합니다.

reporter.button.text.ignore=무시
reporter.button.text.update=업데이트
reporter.message.text.you.re.running.kotlin.plugin.version=현재 실행 중인 Kotlin 플러그인 버전은 {0}이며 최신 버전은 {1}입니다.
reporter.text.can.t.report.exception.from.patched.plugin=패치 플러그인의 예외를 보고할 수 없습니다.
reporter.title.update.kotlin.plugin=Kotlin 플러그인 업데이트

configuration.action.text.ignore=무시
configuration.action.text.update=업데이트
configuration.description.always=항상
configuration.description.amd=AMD
configuration.description.commonjs=CommonJS
configuration.description.never=안 함
configuration.description.plain.put.to.global.scope=일반(전역 범위에 배치)
configuration.description.umd.detect.amd.or.commonjs.if.available.fallback.to.plain=UMD(가능한 경우 AMD 또는 CommonJS를 탐지하여 일반으로 대체)
configuration.description.when.inlining.a.function.from.other.module.with.embedded.sources=포함된 소스가 있는 다른 모듈의 함수를 인라인화할 경우
configuration.error.text.shouldn.t.add.null.urls.to.custom.repositories=사용자 지정 저장소에 null URL을 추가하면 안 됩니다.
configuration.feature.text.new.experimental.project.wizard=새 실험적 프로젝트 마법사
configuration.feature.text.new.java.to.kotlin.converter=Java에서 Kotlin으로 변환하는 새로운 컨버터
configuration.message.enter.fully.qualified.method.name=정규화된 메서드 이름 입력\:
configuration.message.text.a.new.version.is.available=새 버전 {0}을(를) 사용할 수 있습니다.
configuration.message.text.a.new.version.is.found=새 버전 {0}이(가) 발견되었지만 {1}(으)로 검사되지 않았습니다.
configuration.message.text.update.check.failed=업데이트 검사가 실패했습니다. {0}
configuration.message.text.you.have.the.latest.version.of.the.plugin.installed=최신 버전의 플러그인이 설치되어 있습니다.
configuration.message.verifier.disabled=(verifier가 비활성화됨)
configuration.migration.text.api.version=API 버전\: {0} -> {1}
configuration.migration.text.detected.migration=탐지된 마이그레이션\:
configuration.migration.text.language.version=언어 버전\: {0} -> {1}
configuration.migration.text.migrations.for.kotlin.code.are.available=Kotlin 코드에 대한 마이그레이션을 사용할 수 있습니다.
configuration.migration.text.run.migrations=마이그레이션 실행
configuration.migration.text.standard.library=표준 라이브러리\: {0} -> {1}
configuration.migration.title.kotlin.migration=Kotlin 마이그레이션
configuration.name.kotlin.compiler=Kotlin 컴파일러
configuration.name.kotlin=Kotlin
configuration.name.method=메서드
configuration.status.text.installation.failed=설치 실패
configuration.status.text.installing=설치...
configuration.text.add.exclusion=제외 추가
configuration.text.and=및
configuration.text.other.s=기타
configuration.text.patched.original={0}(패치 완료\! 적용 전\: {1})
configuration.text.the.compiler.bundled.to.kotlin.plugin=Kotlin 플러그인({0})에 번들로 포함된 컴파일러가 모듈 빌드에 사용되는 외부 컴파일러보다 오래되었습니다.
configuration.text.this.may.cause.different.set.of.errors.and.warnings.reported.in.ide.p=이로 인해 IDE에 보고된 오류 및 경고 모음이 다를 수 있습니다.
configuration.title.choose.output.directory=출력 디렉터리 선택
configuration.title.early.access.preview.1.4.x=얼리 액세스 프리뷰 1.4.x
configuration.title.early.access.preview.1.5.x=얼리 액세스 테스트 버전 1.5.x
configuration.title.edit.exclusion=제외 편집
configuration.title.kotlin.compiler.js.option.output.postfix.browse.title=생성된 코드에 추가할 파일 선택
configuration.title.kotlin.compiler.js.option.output.prefix.browse.title=생성된 코드 앞에 추가할 파일 선택
configuration.title.outdated.bundled.kotlin.compiler=오래된 Kotlin 번들 컴파일러
configuration.title.stable=안정적
configuration.warning.text.following.modules.override.project.settings=다음 모듈은 프로젝트 설정을 재정의합니다.
configuration.warning.text.modules.override.project.settings={0} 모듈이 프로젝트 설정을 재정의합니다.
configuration.warning.text.language.version.unsupported=언어 버전 {0}은(는) 더 이상 지원되지 않습니다
configuration.warning.text.api.version.unsupported=API 버전 {0}은(는) 더 이상 지원되지 않습니다
configuration.kotlin.code.style=Kotlin 코드 스타일
configuration.notification.update.code.style.to.official=Kotlin 코드 스타일 설정을 권장 설정으로 업데이트하시겠어요?
configuration.apply.new.code.style=코드 스타일 적용
configuration.do.not.suggest.new.code.style=다시 표시 안 함

#Refactoring
0.1.is.never.used={0} ''{1}''이(가) 한 번도 사용되지 않습니다.
0.has.detected.1.code.fragments.in.2.that.can.be.replaced.with.3={0}이(가) {3}(으)로 대체 가능한 {2}에서 {1} 코드 {1,choice,1\#조각 |2\#조각}을 탐지했습니다. {1,choice,1\#코드 조각|2\#코드 조각}을 검토 후 바꾸시겠어요?
0.usages.are.not.supported.by.the.inline.refactoring.they.won.t.be.processed={0} 사용 위치가 인라인 리팩터링에서 지원되지 않아 처리되지 않습니다.
0.will.become.invisible.after.extraction={0} 은(는) 추출 후 보이지 않게 됩니다.
0.will.no.longer.be.accessible.after.extraction={0} 은(는) 추출 후 액세스할 수 없게 됩니다.
action.text.append=추가
action.text.cancel=취소
action.text.overwrite=겹쳐쓰기
button.text.move.nested.class.0.to.upper.level=중첩된 클래스 {0} 을(를) 상위 수준으로 이동(&N)
button.text.move.nested.class.0.to.another.class=중첩된 클래스 {0} 을(를) 다른 클래스로 이동(&M)
cannot.extract.method=추출할 구문을 찾을 수 없습니다.
cannot.extract.super.call=상위 호출을 추출할 수 없습니다.
cannot.inline.property.with.accessor.s.and.backing.field=접근자 및 백킹 필드가 있는 프로퍼티를 인라인화할 수 없습니다.
cannot.introduce.parameter.of.0.type=유형 ''{0}''의 매개변수를 삽입할 수 없습니다.
cannot.refactor.expression.has.unit.type=유닛 유형의 표현식을 삽입할 수 없습니다.
cannot.refactor.no.container=이곳에서 리팩터링할 수 없습니다.
cannot.refactor.no.expression=표현식 없이 리팩터링을 수행할 수 없습니다.
cannot.refactor.no.type=유형 없이 리팩터링을 수행할 수 없습니다.
cannot.refactor.not.expression.to.extract=추출할 표현식을 찾을 수 없습니다.
cannot.refactor.not.expression=삽입할 표현식을 찾을 수 없습니다.
cannot.refactor.package.expression=패키지 참조를 삽입할 수 없습니다.
cannot.refactor.syntax.errors=잘못된 코드로 인해 리팩터링할 수 없습니다.
cannot.refactor.synthesized.function=통합 함수 ''{0}''을(를) 리팩터링할 수 없습니다.
checkbox.text.declare.with.var=var로 선언(&V)
checkbox.text.delete.empty.source.files=빈 소스 파일 삭제(&D)
checkbox.text.extension.property=확장 프로퍼티(&X)\: 
checkbox.text.introduce.default.value=디폴트 값 삽입(&D)
checkbox.text.open.moved.files.in.editor=에디터에서 이동된 멤버 열기
checkbox.text.replace.all.occurrences.0=모든 사용 위치 바꾸기({0})(&R)
checkbox.text.search.references=참조 검색(&R)
checkbox.text.specify.type.explicitly=명시적으로 유형 지정(&T)
checkbox.text.update.package.directive=패키지 지시문 업데이트(Kotlin 파일)
column.name.receiver=리시버\:
column.name.val.var=Val/Var
declarations.are.used.outside.of.selected.code.fragment=다음 선언은 선택한 코드 조각 외부에서 사용됩니다.
declarations.will.move.out.of.scope=다음 선언은 추출된 함수 본문의 외부에서 사용할 수 없습니다.
description.a.reference.to.extracted.type.parameter=추출된 유형 매개변수에 대한 참조
error.cant.refactor.vararg.functions=변수 인수가 있는 함수는 리팩터링할 수 없습니다.
error.hint.text.cannot.inline.0.from.a.decompiled.file=디컴파일된 파일의 ''{0}''은(는) 인라인화할 수 없습니다.
error.text.can.t.change.signature.of.method={0} 메서드의 시그니처를 변경할 수 없습니다.
error.text.can.t.copy.class.to.the.containing.file=포함 파일에 클래스를 복사할 수 없습니다.
error.text.can.t.generate.0.1={0}을(를) 생성할 수 없습니다. {1}
error.text.can.t.introduce.lambda.parameter.for.this.expression=이 표현식에 대한 람다 매개변수를 삽입할 수 없습니다.
error.text.can.t.introduce.property.for.this.expression=이 표현식에 대한 프로퍼티를 삽입할 수 없습니다.
error.text.different.name.expected=다른 이름이 기대됩니다.
error.text.expression.has.no.type=표현식에 유형이 없습니다.
error.text.extraction.from.expect.class.is.not.yet.supported=expect 클래스에서 추출하는 것은 아직 지원되지 않습니다.
error.text.extraction.from.non.jvm.class.is.not.yet.supported=JVM이 아닌 클래스에서 추출하는 것은 아직 지원되지 않습니다.
error.text.inline.function.is.not.supported.for.functions.with.multiple.return.statements=함수 인라인화는 여러 반환문이 있는 함수에는 지원되지 않습니다.
error.text.inline.function.is.not.supported.for.functions.with.return.statements.not.at.the.end.of.the.body=함수 인라인화는 반환문이 본문 끝에 없는 함수에는 지원되지 않습니다.
error.text.interface.cannot.be.extracted.from.an.annotation.class=인터페이스는 어노테이션 클래스에서 추출할 수 없습니다
error.text.introduce.parameter.is.not.available.for.default.value=매개변수 삽입은 디폴트 값에 사용할 수 없습니다.
error.text.introduce.parameter.is.not.available.inside.of.annotation.entries=매개변수 삽입은 어노테이션 항목의 내부에서 사용할 수 없습니다
error.text.invalid.default.receiver.value=잘못된 디폴트 리시버 값
error.text.invalid.name=잘못된 이름
error.text.invalid.parameter.name=잘못된 매개변수 이름
error.text.invalid.parameter.type=잘못된 매개변수 유형
error.text.invalid.receiver.type=잘못된 리시버 유형
error.text.invalid.return.type=잘못된 반환 유형
error.text.no.type.to.refactor=리팩터링할 유형이 없습니다.
error.text.refactoring.is.not.applicable.in.the.current.context=현재 컨텍스트에서는 리팩터링을 적용할 수 없습니다.
error.text.superclass.cannot.be.extracted.from.an.annotation.class=상위 클래스는 어노테이션 클래스에서 추출할 수 없습니다
error.text.type.reference.is.expected=유형 참조가 필요합니다.
error.types.in.generated.function=잘못된 반환 유형이 있는 함수는 생성할 수 없습니다.
error.wrong.caret.position.function.or.constructor.name=캐럿이 리팩터링할 함수 또는 생성자 이름의 위치에 있어야 합니다.
extract.function=함수 추출
family.name.update.usages.on.declarations.cut.paste=선언 잘라내기/붙여넣기 시 사용 위치 업데이트
file.does.not.exist=파일 {0} 이(가) 없습니다.\n생성하시겠어요?
function.name.is.invalid=함수 이름이 잘못되었습니다.
introduce.parameter=매개변수 삽입
introduce.property=프로퍼티 삽입
introduce.type.parameter.to.declaration=선언에 유형 매개변수를 삽입합니다.
introduce.type.parameter=유형 매개변수 삽입
introduce.variable=변수 삽입
label.text.default.receiver.value=디폴트 리시버 값(&D)\: 
label.text.destination.directory=대상 디렉터리(&D)\:
label.text.file.name=파일 이름(&N)\:
label.text.introduce.as=다음으로 삽입(&I)\: 
label.text.name=이름(&N)\:
label.text.package.name=패키지 이름(&G)\:
label.text.receiver.type=리시버 유형(&T)\: 
label.text.target.file.name=대상 파일 이름\:
label.text.to.file=대상 파일(&F)\:
label.text.to.package=패키지로(&A) \:
label.text.to.class=클래스로\:
label.text.to.object=객체로\:
class.name.prompt=클래스 이름(&N)\:
search.for.text.occurrences=텍스트 사용 위치 검색(&T)
search.in.comments.and.strings=주석 및 문자열에서 검색(&C)
parameter.name.prompt=매개변수 이름(&M)\:
pass.outer.class.instance.as.parameter=외부 클래스의 인스턴스를 매개변수로 전달(&O)
label.text.type=유형(&T)\:
label.text.move.expect.actual.counterparts=기대/실제 대응 항목 이동(&M)
label.text.visibility=가시성(&V)\:
member.info.abstract.0=추상 {0}
member.info.companion.0=컴패니언 {0}
message.change.signature.is.not.applicable.to.dynamically.invoked.functions=시그니처 변경은 동적으로 호출된 함수에 적용되지 않습니다.
message.do.not.show.for.local.variables.in.future=이후 지역 변수에 대해 표시하지 않습니다.
message.text.return.type.cannot.be.resolved=반환 유형 ''{0}''을(를) 해결할 수 없습니다.\n계속하시겠어요?
message.text.type.alias.0.is.never.used=유형 별칭 ''{0}''이(가) 한 번도 사용되지 않습니다.
message.type.for.cannot.be.resolved=''{1}''의 유형 ''{0}''을(를) 해결할 수 없습니다.\n계속하시겠어요?
name.extract.interface=인터페이스 추출
name.inline.type.alias=유형 별칭 인라인화
name.introduce.import.alias=import 문 별칭 삽입
name.introduce.lambda.parameter=람다 매개변수 삽입
name.introduce.parameter1=매개변수 삽입
name.introduce.type.alias=유형 별칭 삽입
name.kdoc.for.abstracts=추상에 대한 KDoc
naming.convention.will.be.violated.after.rename=이름을 변경하면 이름 지정 규칙에 위반됩니다.
non.kotlin.usage.0=Kotlin이 아닌 사용 위치\: {0}
parameter.name.is.invalid=매개변수 이름 ''{0}''이(가) 유효하지 않습니다
parameter.type.is.invalid=매개변수 유형 ''{0}''이 유효하지 않습니다
parameter.types.are.not.denotable=다음 유형은 대상 범위에서 표시할 수 없으므로 메서드를 추출할 수 없습니다.
refactoring.move.non.kotlin.file=대상은 Kotlin 파일이어야 합니다.
return.type.is.invalid=반환 유형이 유효하지 않습니다.
searching.usages.of.0.parameter=''{0}'' 매개변수의 사용 위치 검색 중
selected.code.fragment.has.multiple.exit.points=선택한 코드 조각에 종료점이 여러 개 있습니다.
selected.code.fragment.has.multiple.output.values=선택한 코드 조각에 3개 이상의 출력값이 있습니다.
selected.code.fragment.has.output.values.and.exit.points=선택한 코드 조각에 출력값과 대체 종료점이 있습니다.
setter.of.0.will.become.invisible.after.extraction={0} 의 setter는 추출 후 보이지 않게 됩니다
text.0.1.must.be.moved.with.sealed.parent.class.and.all.its.subclasses={0} ''{1}''은(는) 봉인된 상위 클래스 및 모든 하위 클래스와 함께 이동해야 합니다.
text.0.already.contains.1={0}에 {1}이(가) 이미 포함되어 있습니다.
text.0.already.contains.nested.class.1=이름이 {1}인 중첩된 클래스가 {0}에 이미 포함되어 있습니다.
text.0.already.declared.in.1={0}이(가) {1}에 이미 정의되어 있습니다.
text.0.have.no.inheritors.warning={0}에 상속자가 없습니다.\n멤버를 아래로 이동하면 해당 멤버가 삭제됩니다. 계속하시겠어요?
text.0.in.1.will.override.corresponding.member.of.2.after.refactoring={0}의 {1}이(가) 리팩터링 후에 {2}의 멤버를 재정의합니다.
text.0.inherits.from.1.it.will.not.be.affected.by.refactoring={0}이(가) {1}에서 상속됩니다.\n이는 리팩터링의 영향을 받지 않습니다.
text.0.is.invalid.destination.package=''{0}''은(는) 잘못된 대상 패키지 이름입니다.
text.0.is.not.allowed.in.the.target.context=''{0}''은(는) 인터페이스에서 허용되지 않습니다
text.0.is.not.valid.package.name={0} 은(는) 유효한 패키지 이름이 아닙니다.
text.0.to.inline=인라인화할 {0}
text.0.uses.1.which.is.not.accessible.from.2={0}이(가) {2}에서 액세스할 수 없는 {1}을(를) 사용합니다.
text.0.uses.1.which.will.be.inaccessible.after.move={0}이(가) 이동 후에 액세스할 수 없게 되는 {1}을(를) 사용합니다.
text.0.uses.1.which.will.not.be.accessible.from.subclass={0}이(가) 하위 클래스에서 액세스할 수 없게 되는 {1}을(를) 사용합니다.
text.0.uses.internal.1.which.will.be.inaccessible.after.move={0}이(가) 이동 후에 액세스할 수 없게 되는 내부 {1}을(를) 사용합니다.
text.0.will.be.shadowed.by.1={0}이(가) {1}으로 그림자화됩니다.
text.0.will.clash.with.existing.1.in.2=이름을 변경하면 {0}이(가) {2}의 기존 {1}와(과) 충돌합니다.
text.0.will.no.longer.be.accessible.after.signature.change={0} 은(는) 시그니처 변경 후에 액세스할 수 없게 됩니다.
text.all.declarations.must.belong.to.the.same.directory.or.class=모든 선언은 동일한 디렉터리 또는 클래스에 속해야 합니다.
text.all=모두
text.anonymous=[익명]
text.at.least.one.file.must.be.selected=하나 이상의 멤버를 선택해야 합니다.
text.callee.text.would.be.shown.here=피호출자 텍스트가 여기에 표시됩니다.
text.caller.text.with.highlighted.callee.call.would.be.shown.here=피호출자 호출이 강조 표시된\n호출자 텍스트가 여기에 표시됩니다.
text.cannot.create.target.directory.0=대상 디렉터리 {0}을(를) 생성할 수 없습니다.
text.cannot.determine.source.directory=소스 디렉터리를 확인할 수 없습니다.
text.cannot.find.package.corresponding.to.0={0}에 해당하는 해당 패키지를 찾을 수 없습니다.
text.cannot.find.target.package.name=대상 패키지 이름을 찾을 수 없습니다.
text.cannot.inline.0.1.usages={0}/{1}의 사용 위치를 인라인화할 수 없습니다.
text.cannot.move.for.current.project=현재 프로젝트에 대해 이동할 수 없습니다.
text.cannot.move.inner.class.0.into.itself=중첩된 클래스 {0}을(를) 그 자체 내에 이동할 수 없습니다.
text.cannot.move.to.original.file=원본 파일로 이동할 수 없습니다.
text.cannot.move.expect.actual.declaration.to.file=기대/실제 선언을 파일로 이동하지 못했습니다
text.change.file.package.to.0=파일의 패키지를 ''{0}''(으)로 변경합니다.
text.choose.containing.file=포함 파일을 선택합니다.
text.class.0.already.contains.member.1={0}에 {1}이(가) 이미 포함되어 있습니다.
text.class.0.already.exists.in.package.1=클래스 {0}에 패키지 {1}이(가) 이미 있습니다.
text.class.0.already.exists.in.the.target.scope=클래스 {0}이(가) 대상 범위에 이미 있습니다. 
text.class.0.is.final={0}이(가) final입니다.
text.constructor=생성자
text.convert._it_.to.explicit.lambda.parameter=''it''을 명시적 람다 매개변수로 변환합니다.
text.create.destructuring.declaration=구조 분해 선언을 생성합니다.
text.create.single.variable=단일 변수를 생성합니다.
text.declaration=선언
text.declarations.clash.move.0.destination.1.declared.in.scope.2=다음 선언이 충돌합니다. 범위 {2}에서 선언된 {0} 및 대상 {1}을(를) 이동합니다.
text.default.value=\ // 디폴트 값 \= {0}
text.destination.class.should.be.kotlin.class=대상 클래스가 Kotlin 클래스여야 합니다.
text.do.you.want.to.rename.0.as.well={0}()의 이름도 변경하시겠어요?
text.do.you.want.to.rename.base.property.from.0={0}에서 기본 프로퍼티의 이름을 변경하시겠어요?
text.do.you.want.to.rename.base.property=기본 프로퍼티의 이름을 변경하시겠어요?
text.duplicating.local.variable=지역 변수 ''{0}'' 중복
text.duplicating.parameter=매개변수 ''{0}'' 중복
text.duplicating.property=프로퍼티 ''{0}'' 중복
text.explicit.receiver.is.already.present.in.call.element.0=명시적 리시버가 호출 요소에 이미 있습니다. {0}
text.extract.superclass=상위 클래스 추출
text.file.0.already.exists.in.1=파일 {0}이(가) {1}에 이미 있습니다.
text.file.name.cannot.be.empty=파일 이름이 비어 있지 않을 수 있습니다.
text.function.already.exists=함수가 이미 있습니다. ''{0}''
text.function.in.ticks.0=함수 ''{0}''
text.function=함수
text.anonymous.function=익명 함수
text.implicit.companion.object.will.be.inaccessible.0=묵시적 컴패니언 객체에 액세스할 수 없게 됩니다. {0}
text.incorrect.target.path.directory.0.does.not.belong.to.current.project=잘못된 대상 경로입니다. 디렉터리 {0} 은(는) 현재 프로젝트에 속해 있지 않습니다.
text.indirect.outer.instances.will.not.be.extracted.0=간접 외부 인스턴스는 추출되지 않습니다. {0}
text.inline.0.1.2={0} ''{1}''을(를) 인라인화하시겠어요? {2}
text.inline.0={0} 인라인화
text.inline.all.references.and.verb.0.the.kind.1.occurrences.2=모든 참조를 인라인화하고 {1} {2}을(를) {0}
text.inline.recursive.function.is.supported.only.on.references=재귀 함수 인라인화는 참조에서만 지원됩니다.
text.inline.this.reference.and.keep.the.0=이 참조를 인라인화하고 {0} 을(를) 유지합니다 
text.inlining.0.1={0} {1} 인라인화
text.inlined.0.overrides.0.1=인라인화된 {0}이(가) {0} {1}을(를) 재정의합니다
text.inner.class.0.cannot.be.moved.to.intefrace={0} 은(는) 내부 클래스이므로 인터페이스로 이동할 수 없습니다.
text.introduce.default.value=디폴트 값 삽입(&D)
text.invalid.target.path.0=잘못된 대상 경로 {0}
text.invalid.target.specified=잘못된 대상 지정
text.keep=유지
text.lambda.parameter=람다 매개변수
text.lambda.parameters=람다 매개변수(&P)\: 
text.lambda.return.type=람다 반환 유형(&T)
text.lazy.property=지연 프로퍼티
text.local.property=프로퍼티
text.local.variable=지역 변수
text.looking.for.usages=사용 위치 검색 중
text.member.0.in.super.class.will.clash.with.existing.member.of.1=상위 클래스의 {0}(가) {1}의 기존 멤버와 충돌합니다.
text.member.extension.call.will.not.be.processed.0=멤버 확장 호출이 처리되지 않습니다. {0}
text.move.declaration.no.support.for.companion.objects=선언 이동은 컴패니언 객체에 지원되지 않습니다.
text.move.declaration.no.support.for.enums=선언 이동은 열거형 항목에 지원되지 않습니다.
text.move.declaration.supports.only.top.levels.and.nested.classes=선언 이동은 최상위 선언 및 중첩된 클래스에만 지원됩니다.
text.move.declaration.proceed.move.without.mpp.counterparts.text=이 리팩터링을 수행하면 선택한 선언을 기대/실제 대응 항목 없이 이동하므로 컴파일 오류가 발생할 수 있습니다.\n계속 진행하시겠어요?
text.move.declaration.proceed.move.without.mpp.counterparts.title=이 리팩터링에서 MPP 선언 지원 안 됨
text.move.declarations=선언 이동
text.no.destination.object.specified=대상 객체가 지정되지 않았습니다
text.select.a.name.for.this.parameter=''this@{0}'' 매개변수의 이름 선택
text.move.method.is.not.supported.for.non.project.methods=move 메서드는 비 프로젝트 메서드에 지원되지 않습니다
text.move.method.is.not.supported.for.generic.classes=move 메서드는 제네릭 클래스에 지원되지 않습니다
text.move.method.is.not.supported.when.method.is.a.part.of.inheritance.hierarchy=move 메서드는 메서드가 상속 계층 구조의 일부인 경우 지원되지 않습니다
text.references.to.outer.classes.have.to.be.added.manually=외부 클래스에 대한 참조는 이동 후 수동으로 추가해야 합니다
text.move.method=move 메서드
text.move.file.0={0} 이동
text.move.refactoring.not.available.during.indexing=색인 생성이 진행되는 동안 이동 리팩터링을 사용할 수 없습니다.
text.moving.multiple.nested.classes.to.top.level.not.supported=여러 중첩된 클래스를 최상위 수준으로 이동하는 것은 지원되지 않습니다.
text.Name=이름
text.nested.classes.to.upper.level=중첩된 클래스에서 상위 수준으로
text.no.elements.to.move.are.selected=이동할 요소가 선택되지 않았습니다.
text.no.files.to.move=이동하도록 지정된 파일이 없습니다.
text.no.name.provided.for.type.alias=유형 별칭에 제공된 이름이 없습니다.
text.no.package.corresponds.to.directory=이 디렉터리에 해당하는 패키지가 없습니다.
text.non.kotlin.0.will.not.be.affected.by.refactoring=Kotlin이 아닌 {0} 은(는) 리팩터링의 영향을 받지 않습니다.
text.overload=오버로드
text.package.directive.dont.match.file.location=패키지 지시문이 파일 위치와 일치하지 않습니다.
text.parameter.0=매개변수 ''{0}''
text.parameter.name=매개변수 이름(&N)\: 
text.parameter.reference.can.t.be.safely.replaced.with.0.since.1.is.ambiguous.in.this.context={1}이(가) 이 컨텍스트에서 모호하여 매개변수 참조를 {0}(으)로 안전하게 바꿀 수 없습니다.
text.parameter.reference.can.t.be.safely.replaced.with.0.since.target.function.can.t.be.referenced.in.this.context=대상 함수를 이 컨텍스트에서 참조할 수 없으므로 매개변수 참조를 {0}(으)로 안전하게 바꿀 수 없습니다.
text.parameter.type=매개변수 유형(&T)\: 
text.parameter=매개변수
text.parameters=매개변수(&P)\:
text.proceed.with.extraction=추출 진행
text.process.duplicates=프로세스 중복
text.processing.file.0={0} 처리 중
text.property.in.ticks.0=프로퍼티 ''{0}''
text.property.with.getter=getter가 있는 프로퍼티
text.property.with.initializer=이니셜라이저가 있는 프로퍼티
text.property=프로퍼티
text.pushed.member.will.not.be.available.in.0=푸시된 멤버는 ''{0}''에서 사용할 수 없게 됩니다.
text.qualified.call.will.not.be.processed.0=정규화된 호출은 처리되지 않습니다. {0}
text.receiver.can.t.be.safely.transformed.to.value.argument=리시버는 값 인수로 안전하게 변환할 수 없습니다. {0}
text.receiver=리시버
text.refactoring.can.t.be.performed.on.the.selected.code.element=선택한 코드 요소에서 리팩터링을 수행할 수 없습니다.
text.refactoring.is.not.applicable.to.this.code.fragment=이 코드 조각에는 리팩터링이 적용되지 않습니다.
text.references.in.code.to.0.1.and.its.declarations={0} {1} 및 해당 선언에 대한 코드 내 참조
text.remove.0.no.longer.used=더 이상 사용되지 않는 {0}을(를) 제거합니다.
text.remove.question=\ ''?'' 제거
text.remove=제거
text.rename.as.part.of.phrase=이름 바꾸기
text.rename.is.not.applicable.to.secondary.constructors=이름 변경은 보조 생성자에는 적용되지 않습니다.
text.rename.is.not.applicable.to.synthetic.declarations=이름 변경은 통합 선언에 적용되지 않습니다.
text.rename.not.applicable.to.backing.field.reference=이름 변경은 백킹 필드 참조에 적용되지 않습니다.
text.rename.not.applicable.to.dynamically.invoked.methods=시그니처 변경은 동적으로 호출된 멤버에 적용되지 않습니다.
text.rename.overloads.title=오버로드 이름 변경
text.rename.overloads.to=오버로드 이름을 다음으로 변경\:
text.rename.parameters.in.hierarchy.to=계층 구조에서 매개변수 이름을 다음으로 변경\:
text.rename.parameters.title=매개변수 이름 변경
text.rename.warning=이름 변경 경고
text.sealed.class.0.must.be.moved.with.all.its.subclasses=봉인된 클래스 ''{0}''은(는) 모든 하위 클래스와 함께 이동해야 합니다.
text.select.target.code.block.file=대상 코드 블록/파일을 선택합니다.
text.select.target.code.block=대상 코드 블록을 선택합니다.
text.select.target.file=대상 파일을 선택합니다.
text.the.following=다음
text.there.is.already.a.parameter={1}에 매개변수 ''{0}''이(가) 이미 있으므로 새 매개변수와 충돌하게 됩니다.
text.there.is.already.a.variable.0.in.1.it.will.conflict.with.the.new.parameter={1}에 변수 ''{0}''이(가) 이미 있으므로 새 매개변수와 충돌하게 됩니다.
text.type.alias.cannot.refer.to.types.which.aren.t.accessible.in.the.scope.where.it.s.defined=유형 별칭은 정의된 범위에서 액세스할 수 없는 유형을 참조할 수 없습니다.
text.type.alias.name.must.be.a.valid.identifier.0=유형 별칭 이름은 유효한 식별자여야 합니다. {0}
text.type.alias=유형 별칭
text.type.already.exists.in.the.target.scope=유형 {0}이(가) 대상 범위에 이미 있습니다.
text.type.parameter.names.must.be.distinct=유형 매개변수 이름은 고유해야 합니다.
text.type.parameters=유형 매개변수(&P)
text.type=유형
text.unexpected.element.type.0=예기치 않은 요소 유형\: {0}
text.update.usages.to.reflect.declaration.0.move={0, choice, 0\#선언|1\#선언}을 반영하도록 사용 위치를 업데이트합니다.
text.updating.usages.progress=사용 위치 업데이트 중...
text.variable=변수
text.cannot.inline.reference.from.0.to.1=참조를 {0}에서 {1}(으)로 인라인화할 수 없습니다
title.change.signature=시그니처 변경
title.inline.function=인라인 함수
title.inline.property=인라인 프로퍼티
title.inline.type.alias=유형 별칭 인라인화
refactoring.cannot.be.applied.no.sources.attached=연결된 소스가 없어 {0} 리팩터링을 적용할 수 없습니다
refactoring.cannot.be.applied.to.abstract.declaration={0} 리팩터링은 abstract 선언에 적용할 수 없습니다
refactoring.cannot.be.applied.to.expect.declaration={0} 리팩터링은 expect 선언에 적용할 수 없습니다
refactoring.cannot.be.applied.to.anonymous.function.without.invocation={0} 리팩터링은 호출이 없는 익명 함수에 적용할 수 없습니다
refactoring.the.function.not.found=함수를 찾을 수 없습니다
refactoring.the.function.cannot.be.converted.to.anonymous.function=함수는 익명 함수로 변환할 수 없습니다
refactoring.the.invocation.cannot.be.resolved=호출은 해결할 수 없습니다
refactoring.cannot.be.applied.to.lambda.expression.without.invocation={0} 리팩터링은 호출이 없는 람다 식에 적용할 수 없습니다
text.reference.cannot.be.converted.to.a.lambda=참조는 람다로 변환할 수 없습니다
title.introduce.parameter.to.declaration=선언에 매개변수를 삽입합니다.
title.move.nested.classes.to.upper.level=중첩된 클래스에서 상위 수준으로 이동
title.move.method=move 메서드
title.choose.destination.object=대상 객체 선택
title.select.target.code.block=대상 코드 블록 선택
unsupported.usage.0=지원되지 않는 사용 위치\: {0}
parameter.used.in.declaration.body.warning=''{0}이(가) 선언 본문에서 사용됩니다

do.you.want.to.delete.this.parameter.in.expected.declaration.and.all.related.actual.ones=기대되는 선언 및 모든 관련된 실제 선언에서 이 매개변수를 삭제하시겠어요?
do.you.want.to.delete.expected.declaration.together.with.all.related.actual.ones=기대되는 선언 및 모든 관련된 실제 선언을 삭제하시겠어요?
delete.with.usage.search=삭제(사용 위치 검색 사용)

destination.not.found.for.package.0=패키지에 ''{0}''의 대상을 찾을 수 없습니다.
leave.in.same.source.root=동일한 소스 루트에서 남겨둡니다.
test.root.is.selected.while.the.source.root.is.expected=기대되는 것은 소스 루트이지만 테스트 루트가 선택되어 있습니다.
source.root.is.selected.while.the.test.root.is.expected=기대되는 것은 테스트 루트이지만 소스 루트가 선택되어 있습니다.
premature.end.of.template=템플릿이 제대로 완료되지 않았습니다.
choose.target.class.or.interface=대상 클래스 또는 인터페이스를 선택합니다.
text.abstract=추상
text.secondary.constructor=보조 생성자
text.create=생성
text.member=구성원
text.extension=확장
text.object=객체
text.interface=인터페이스
text.enum.constant=열거형 상수
text.enum=enum
text.annotation=어노테이션
create.0.1={0} ''{1}'' 생성합니다.
choose.class.container=클래스 컨테이너를 선택합니다.
file.0.already.exists.but.does.not.correspond.to.kotlin.file=파일 {0}이(가) 이미 존재하지만 Kotlin 파일에 해당하지 않습니다.
create.file=파일 생성
create.0={0} 생성
create.package.0=패키지 ''{0}''을(를) 생성합니다.
text.type.parameter=유형 {0, choice, 0\#매개변수|2\#매개변수}
create.0.in.1={1}에서 {0}을(를) 생성합니다.
searching.0={0} 검색 중...
create.property.0.as.constructor.parameter=프로퍼티 ''{0}''을(를) 생성자 매개변수로서 생성합니다.
create.parameter.0=매개변수 ''{0}'' 생성
add.property=프로퍼티를 추가합니다.
text.add=추가 ''
property.0.to.1=프로퍼티 ''{0}''을(를) ''{1}''(으)로
add.method=메서드 추가
add.0.constructor.to.1={0} 생성자를 ''{1}''에 추가합니다.
text.secondary=보조
text.primary=기본
add.method.0.to.1=메서드 ''{0}''을(를) ''{1}''에 추가합니다.
create.actual.0.for.module.1.2=모듈 {1}에 대한 실제 {0}을(를) 생성합니다({2}).
create.expected.0.in.common.module.1=일반 모듈 {1}에서 필요한 {0}을(를) 생성합니다.
repair.actual.members=실제 멤버를 수정합니다.
these.declarations.cannot.be.transformed=이 선언은 변환할 수 없습니다.
unknown.types=알 수 없는 유형
choose.actual.members=실제 멤버를 선택합니다.
text.annotation.class=어노테이션 클래스
text.enum.class=열거형 클래스
text.class=클래스
type.0.1.is.not.accessible.from.target.module=대상 모듈에서 {0, choice, 0\#유형|2\#유형} {1}에 액세스할 수 없습니다.
the.function.declaration.shouldn.t.have.a.default.implementation=함수 선언에 기본 구현이 없어야 합니다.
some.types.are.not.accessible.from.0.1={0}에서 액세스할 수 없는 유형\:\n{1}
the.declaration.has.0.modifier=선언에 ''{0}'' 제어자가 있습니다
inaccessible.declaration=액세스할 수 없는 선언
fix.with.asdynamic=''asDynamic''으로 수정합니다.
migrate.type.parameter.list.syntax=유형 매개변수 목록 구문을 마이그레이션합니다.
replace.deprecated.symbol.usage=더 이상 사용되지 않는 심볼의 사용 위치를 바꿉니다.
replace.with.0=''{0}''(으)로 바꾸기
there.is.own.replacewith.on.0.that.is.used.through.this.alias.please.replace.usages.first=이 별칭을 통해 사용되는 ''{0}''에 고유한 ''ReplaceWith''가 있습니다. 먼저 사용 위치를 바꾸세요.
replace.deprecated.symbol.usage.in.whole.project=더 이상 사용되지 않는 심볼의 사용 위치를 전체 프로젝트에서 대체합니다.
applying.0=''{0}'' 적용
replace.usages.of.0.in.whole.project=''{0}''의 사용 위치를 전체 프로젝트에서 대체합니다.
replace.with.publishedapi.bridge.call=@PublishedApi 브리지 호출로 바꿉니다.
replace.with.generated.publishedapi.bridge.call.0=생성된 @PublishedApi 브리지 호출 ''{0}''(으)로 바꿉니다.
convert.sealed.sub.class.to.object.fix.family.name=봉인된 하위 클래스를 객체로 변환합니다.
generate.identity.equals.fix.family.name=ID별로 equals 및 hashCode 생성
and.delete.initializer=\ 및 이니셜라이저 삭제
change.to.val=val로 변경합니다.
change.to.var=var로 변경합니다.
change.type.of.0.to.1={0}의 유형을 ''{1}''(으)로 변경합니다.
change.type.to.0=유형을 ''{0}''(으)로 변경
base.property.0=기본 프로퍼티 {0}
make.0={0}을(를) 만듭니다.
make.0.1.explicitly=''{0}''을(를) {1}(으)로 명시적으로 만듭니다.
make.0.explicitly={0}을(를) 명시적으로 만듭니다.
use.inherited.visibility=상속된 가시성을 사용합니다.
replace.with.in.when=when에서 '',''를 ''||''로 바꾸기합니다.
remove.0=''.{0}'' 제거
remove.conversion.from.kclass.to.class=''KClass''에서 ''Class''로의 변환을 제거합니다.
convert.to.0={0}(으)로 변환합니다.
convert.expression.to.0.by.inserting.1=''.{1}''을(를) 삽입하여 표현식을 ''{0}''(으)로 변환합니다.
convert.extension.property.initializer.to.getter=확장 프로퍼티 초기자를 getter로 변환합니다.
convert.supertype.to.0=상위 유형을 ''{0}''(으)로 변환합니다.
convert.extension.function.type.to.regular.function.type=확장 함수 유형을 일반 함수 유형으로 변환합니다.
convert.to.notnull.delegate=notNull 위임으로 변환합니다.
convert.to.anonymous.object=익명 객체로 변환합니다.
select.loop.statement.to.label=라벨을 지정할 루프 문을 선택합니다.
select.lambda.to.label=라벨을 지정할 람다를 선택합니다.
create.label=라벨을 생성합니다.
create.label.0=라벨 {0}@을(를) 생성합니다.
convert.member.to.extension=멤버를 확장으로 변환합니다.
replace.annotation=어노테이션을 바꿉니다
replace.annotation.with.0=어노테이션을 {0} (으)로 바꿉니다
add.initializer=이니셜라이저를 추가합니다.
move.to.constructor.parameters=생성자 매개변수로 이동합니다.
initialize.with.constructor.parameter=생성자 매개변수로 초기화합니다.
inline.type.parameter=유형 매개변수를 인라인화합니다.
insert.explicit.delegation.call=명시적 위임 호출을 삽입합니다.
kotlin.add.required.module.fix.family.name=module-info.java에 ''requires'' 지시문을 추가합니다.
the.anonymous.object=익명 객체
text.implement=구현
text.extend=확장
let.0.1={0}이(가) {1}하도록 합니다.
let.type.implement.interface=유형이 인터페이스를 구현하도록 합니다.
0.interface.1=인터페이스 ''{1}''을(를) {0}합니다.
lift.assignment.out.of.try.expression=''try'' 표현식에서 대입을 제거합니다.
make.class.an.annotation.class=클래스를 어노테이션 클래스로 만듭니다
make.0.an.annotation.class=''{0}'' 을(를) 어노테이션 클래스로 만듭니다
make.constructor.parameter.a.property.0=생성자 매개변수를 프로퍼티 {0}(으)로 만듭니다.
in.class.0=\ 클래스 ''{0}'' 내
add.0.to.module.1.compiler.arguments=''{0}''을(를) 모듈 {1} 컴파일러 인수에 추가합니다.
add.an.opt.in.requirement.marker.compiler.argument=선택 요구 사항 마커 컴파일러 인수를 추가합니다.
make.0.in.1.open={1}의 ''{0}''을(를) 엽니다.
add.modifier=제어자 추가
make.private.and.0.1=private 및 {0} ''{1}''(으)로 만듭니다.
text.overrides=재정의
text.implements=구현
make.type.parameter.reified.and.function.inline=유형 매개변수를 구체화하고 함수를 인라인화합니다.
change.all.usages.of.0.in.this.file.to.1=이 파일에 있는 ''{0}''의 모든 사용 위치를 ''{1}''(으)로 변경합니다.
change.all.usages.of.0.in.this.file.to.a.kotlin.class=이 파일에 있는 ''{0}''의 모든 사용 위치를 Kotlin 클래스로 변경합니다.
change.to.kotlin.class=Kotlin 클래스로 변경합니다.
choose.an.appropriate.kotlin.class=적절한 Kotlin 클래스를 선택합니다.
add.empty.brackets.after.primary.constructor=기본 생성자 뒤에 빈 대괄호를 추가합니다.
add.constructor.keyword=''constructor'' 키워드를 추가합니다.
move.annotation.to.receiver.type=어노테이션을 리시버 유형으로 이동합니다
move.type.parameter.constraint.to.where.clause=유형 매개변수 제약 조건을 ''where'' 절로 이동합니다.
move.else.branch.to.the.end=else 브랜치를 끝으로 이동합니다.
insert.number.conversion=숫자 변환을 삽입합니다.
convert.expression.to.0=표현식을 ''{0}''(으)로 변환합니다.
remove.from.annotation.argument=어노테이션 인수에서 @을 제거합니다
remove.default.parameter.value=디폴트 매개변수 값을 제거합니다.
remove.final.upper.bound=final 상위 바운드를 제거합니다.
remove.function.body=함수 본문을 제거합니다.
remove.redundant.0.modifier=중복 ''{0}'' 제어자를 제거합니다.
make.0.not.1={0}을(를) {1}이(가) 아니도록 만듭니다.
remove.0.modifier=''{0}'' 한정자를 제거합니다.
remove.modifier=제어자 제거
remove.identifier.from.anonymous.function=익명 함수에서 식별자를 제거합니다.
remove.constructor.call=생성자 호출을 제거합니다.
make.not.nullable=null이 되지 않도록 만듭니다.
remove.useless=필요 없는 ''?''를 제거합니다.
remove.redundant=중복 ''?''를 제거합니다.
remove.0.from.property=프로퍼티에서 {0}을(를) 제거합니다.
remove.parts.from.property=프로퍼티에서 일부분을 제거합니다.
text.initializer=초기자
text.setter=setter
text.getter=getter
remove.element=요소를 제거합니다.
for.0=''{0}''에 대한
remove.conflicting.import.0=충돌하는 import 문 {0}을(를) 제거합니다.
remove.type.parameters=유형 매개변수를 제거합니다.
remove.type.arguments=유형 인수 제거
remove.star=''*'' 제거
remove.variable.0=변수 ''{0}''을(를) 제거합니다.
remove.redundant.initializer=불필요한 이니셜라이저 제거
remove.redundant.label=중복 라벨을 제거합니다.
remove.single.lambda.parameter.declaration=단일 람다 매개변수 선언을 제거합니다.
remove.supertype=상위 유형 제거
remove.0.variance.from.1=''{1}''에서 ''{0}'' 분산을 제거합니다.
remove.parameter.0=매개변수 ''{0}''을(를) 제거합니다.
remove.redundant.assignment=중복 할당 제거
there.are.possible.side.effects.found.in.expressions.assigned.to.the.variable.0=변수 ''{0}에 대입된 표현식에서 잠재적 부작용이 발견되었습니다.<br>문제를 해결하려면 다음을 수행하세요.<br>-\\&nbsp;전체 대입을 <b>제거</b><br>-\\&nbsp;오른쪽 대입을 자체 내의 구문으로 <b>변환</b><br>
remove.useless.cast=필요 없는 형 변환을 제거합니다.
remove.useless.elvis.operator=필요 없는 elvis 연산자를 제거합니다.
remove.useless.is.check=필요 없는 is 검사를 제거합니다.
remove.val.var.from.parameter=매개변수에서 ''val/var''을 제거합니다.
remove.0.from.parameter=매개변수에서 ''{0}''을(를) 제거합니다.
remove.else.branch=else 브랜치를 제거합니다.
remove.branch=브랜치 제거
rename.identifier.fix.text=이름 바꾸기
rename.to.0=''{0}''로 이름 바꾸기
rename.parameter.to.match.overridden.method=매개변수 이름을 변경하여 재정의된 메서드와 일치시킵니다.
rename.to.underscore=다음으로 이름 변경 _
replace.with.safe.this.call=안전한 (this?.) 호출로 바꿉니다.
replace.with.safe.call=안전한 (?.) 호출로 바꿉니다.
replace.scope.function.with.safe.call=범위 함수를 안전한 (?.) 호출로 바꿉니다.
replace.with.dot.call=마침표 호출로 바꿉니다.
replace.with.safe.call1=안전한 (?.) 호출로 바꿉니다.
replace.invalid.positioned.arguments.for.annotation=어노테이션에 대해 잘못 배치된 인수를 바꿉니다
replace.jvmfield.with.const=''@JvmField''를 ''const''로 바꿉니다.
replace.modifier=제어자를 바꿉니다.
update.obsolete.label.syntax=사용되지 않는 라벨 구문을 업데이트합니다.
replace.with.label.0.at={0}@으로 바꿉니다.
replace.cast.with.call.to.to.0=형 변환을 ''to{0}()'' 호출로 바꿉니다.
replace.cast.with.primitive.conversion.method=형 변환을 기본 변환 메서드로 바꿉니다.
replace.with.array.call=배열 호출로 바꿉니다.
remove.expression.target=표현식 대상을 제거합니다.
change.existent.retention.to.source=기존 보관 항목을 소스로 변경합니다.
add.source.retention=소스 보관 항목을 추가합니다.
round.using.0={0}()을(를) 사용하여 반올림합니다.
simplify.0.to.1={0}을(를) ''{1}''(으)로 단순화합니다.
simplify.comparison=비교를 단순화합니다.
specify.override.for.0.explicitly=''{0}''에 대한 재정의를 명시적으로 지정합니다.
specify.override.explicitly=재정의를 명시적으로 지정합니다.
specify.return.type.explicitly=명시적으로 반환 유형을 지정합니다.
specify.type.explicitly=유형을 명시적으로 지정합니다.
add.constructor.parameters.from.0.1={0}{1}의 생성자 매개변수를 추가합니다.
change.to.constructor.invocation=생성자 호출로 변경합니다.
add.constructor.parameters.from.superclass=상위 클래스의 생성자 매개변수를 추가합니다.
surround.with.star.0=*{0}(...)(으)로 둘러쌉니다.
surround.with.lambda=람다로 둘러쌉니다.
surround.with.null.check=null 검사로 둘러쌉니다.
convert.too.long.character.literal.to.string=너무 긴 문자 리터럴을 문자열로 변환합니다.
replace.array.of.boxed.with.array.of.primitive=박싱의 배열을 기본 배열로 바꿉니다.
migrate.unsupported.yield.syntax=지원되지 않는 yield 구문을 마이그레이션합니다.
wrap.with=[]으로 래핑합니다.
wrap.with.array.literal=배열 리터럴로 래핑합니다.
wrap.with.collection.literal.call=컬렉션 리터럴 호출로 래핑합니다.
wrap.element.with.0.call=요소를 ''{0}()'' 호출로 래핑합니다.
replace.with.0.call=''{0}()'' 호출로 바꿉니다.
wrap.with.let.call=''?.let { ... }'' 호출로 래핑합니다.
change.to.0=''{0}''(으)로 변경합니다.
change.to.correct.long.suffix.l=올바른 긴 접미사 ''L''로 변경합니다.
change.to.correct.primitive.type=올바른 기본 유형으로 변경합니다.
0.from.1={1}의 {0}
checking.data.classes=데이터 클래스 확인
checking.data.class.0.of.1=데이터 클래스 {0}/{1} 확인 중...
difference.found.for.data.class.0.found.1.2=데이터 클래스 {0}에 대해 발견된 차이점이 없습니다. {1}개의 사용 위치가 발견되었으나 필요한 것은 {2}개입니다.
title.error=오류
analyzed.0.classes.no.difference.found={0}개의 클래스를 분석했으나 차이점이 발견되지 않았습니다.
title.success=성공
can.t.finish.while.indexing.is.in.progress=색인 생성이 진행되는 동안에는 완료할 수 없습니다.
enable.tremble.dumb.mode=Tremble Dumb 모드 활성화
disable.tremble.dumb.mode=Tremble Dumb 모드 비활성화
finding.implicit.nothing.s=묵시적 Nothing 찾는 중
scanning.files.0.fo.1.file.2.occurrences.found=파일 검사 중\: {0}/{1} 파일. {2}개의 사용 위치가 발견되었습니다.
implicit.nothing.s=묵시적 Nothing
not.found.in.0.files={0}개의 파일에서 발견되지 않았습니다.
titile.not.found=찾을 수 없음
search.for.not.property.candidates=프로퍼티가 아닌 후보를 검색합니다.
enter.package.fqname=패키지 FqName을 입력합니다.
searching.for.not.property.candidates=프로퍼티가 아닌 후보 검색
step.1.collecting.0.1.2=1단계\: {0}\:{1}\:{2} 수집
step.2.0.of.1=2단계\: {0}의 {1}
step.3.0.of.1=3단계\: {0}의 {1}
title.done=완료
revert.applied.imports=적용된 import 문을 되돌립니다.
delete.0={0} 삭제
replace.if.expression.with.elvis.expression=''if'' 식을 elvis 식으로 바꿉니다.
report.also.on.statement=구문세서도 보고합니다.
if.then.foldable.to=''?\:''로 접을 수 있는 If-Then
replace.if.expression.with.safe.access.expression=''if'' 식을 안전한 액세스 식으로 바꿉니다.
remove.redundant.if.expression=중복 ''if'' 식을 제거합니다.
replace.if.expression.with.safe.cast.expression=''if'' 식을 안전한 형 변환 식으로 바꿉니다.
simplify.foldable.if.then=접을 수 있는 if-then을 단순화합니다.
foldable.if.then=접을 수 있는 if-then
introduce.when.subject=''when'' 대상을 삽입합니다.
when.with.subject.should.be.used=대상이 있는 ''when''을 사용해야 합니다.
introduce.0.as.subject.0.when=''{0}''을(를) ''when''의 대상으로서 삽입합니다.
convert.call.chain.into.sequence.fix.text=호출 체인을 ''Sequence''로 변환합니다.
call.chain.length.to.transform=변환할 호출 체인 길이\:
call.chain.on.collection.could.be.converted.into.sequence.to.improve.performance=성능 향상을 위해 컬렉션의 호출 체인을 ''Sequence''로 변환할 수 있습니다.
remove.useless.call.fix.text=필요 없는 호출을 제거합니다.
rename.useless.call.fix.text=호출을 ''{0}''(으)로 변경합니다.
call.chain.on.collection.type.may.be.simplified=컬렉션 유형에 대한 호출 체인을 단순화할 수 있습니다.
0.call.could.be.simplified.to.1={0} 호출을 {1}(으)로 단순화할 수 있습니다.
simplify.call.fix.text=''{0}'' 호출을 ''{1}''(으)로 변환합니다.
simplify.call.chain.fix.text=호출 체인을 ''{0}''에 병합합니다.
call.on.collection.type.may.be.reduced=컬렉션 유형에 대한 호출을 줄일 수 있습니다.
useless.call.on.collection.type=컬렉션 유형에 대한 불필요한 호출
this.call.is.useless.with=이 호출은 ?.를 사용하면 필요 없습니다.
useless.call.on.not.null.type=null이 아닌 유형에 대한 불필요한 호출
call.on.not.null.type.may.be.reduced=null이 아닌 유형에 대한 호출을 줄일 수 있습니다.
replace.total.order.equality.with.ieee.754.equality=total order 상등을 IEEE 754 상등으로 바꿉니다.
replace.with.binary.operator=2진 연산자로 바꿉니다.
call.replaceable.with.binary.operator=2진 연산자로 대체 가능한 호출
replace.get.or.set.call.with.indexing.operator=get 또는 set 호출을 색인 생성 연산자로 바꿉니다.
should.be.replaced.with.indexing=색인 생성으로 바꿔야 합니다.
replace.0.call.with.indexing.operator=''{0}'' 호출을 색인 생성 연산자로 바꿉니다.
function.returning.0.with.a.name.that.does.not.end.with.1=이름이 {1}(으)로 끝나지 않는 {0}을(를) 반환하는 함수
add.call.or.unwrap.type.fix.text=''.{0}()''을(를) 함수 결과에 추가합니다(use-sites 분리).
add.call.or.unwrap.type.fix.text1=''{0}'' 반환 유형을 래핑 해제합니다(use-sites 분리).
reports.only.function.calls.from.kotlinx.coroutines=kotlinx.coroutines의 함수 호출만 보고합니다.
deferred.result.is.never.used=연기된 결과가 한 번도 사용되지 않습니다.
function.0.returning.1.without.the.corresponding=''{3}''을(를) 반환하는 함수 ''{2}'' 없이 ''{1}''을(를) 반환하는 함수 ''{0}''
redundant.async.call.may.be.reduced.to.0=중복 ''async'' 호출을 ''{0}''(으)로 줄일 수 있습니다.
redundant.runcatching.call.may.be.reduced.to.0=중복 ''runCatching'' 호출을 ''{0}''(으)로 줄일 수 있습니다.
rename.to.fix.text=''{0}''로 이름 바꾸기
wrap.with.coroutine.scope.fix.text=''coroutineScope { ... }''로 함수 본문을 래핑합니다.
wrap.with.coroutine.scope.fix.text2=''coroutineScope { ... }''로 호출을 래핑합니다.
wrap.with.coroutine.scope.fix.text3=리시버를 제거하고 ''coroutineScope { ... }''로 래핑합니다.
wrap.with.coroutine.scope.fix.family.name=coroutineScope로 래핑
ambiguous.coroutinecontext.due.to.coroutinescope.receiver.of.suspend.function=suspend 함수의 CoroutineScope 리시버로 인해 모호해진 coroutineContext
replace.with.kotlin.analog.function.family.name=Kotlin 아날로그로 바꾸기
should.be.replaced.with.kotlin.function=Kotlin 함수로 바꿔야 합니다.
replace.with.kotlin.analog.function.text=''{0}'' 함수로 바꾸기
add.documentation.fix.text=문서를 추가합니다.
missing.documentation=문서가 누락되었습니다.
0.is.missing.documentation={0}에 문서가 누락되었습니다.
library.should.be.updated.to.be.compatible.with.kotlin.1.3=Kotlin 1.3과 호환되도록 라이브러리를 업데이트해야 합니다.
it.s.prohibited.to.call.0.with.min.value.step.since.1.3=1.3부터 MIN_VALUE 단계로 {0} 호출하는 것은 금지됩니다.
obsolete.coroutine.usage.in.whole.fix.family.name=프로젝트에서 실험적 코루틴 사용 위치 수정
obsolete.kotlin.js.packages.usage.in.whole.fix.family.name=프로젝트에서 ''kotlin.dom'' 및 ''kotlin.browser'' 패키지의 사용을 수정
apply.in.the.project.0=프로젝트에서 적용\: {0}
obsolete.coroutine.usage.fix.family.name=실험적인 코루틴 사용 위치 수정
obsolete.package.usage.fix.family.name=''{0}'' 패키지의 사용을 수정
0.is.expected.to.be.used.since.kotlin.1.3=''{0}''은(는) Kotlin 1.3부터 사용될 예정입니다
methods.are.absent.in.coroutines.class.since.1.3=메서드는 1.3부터 코루틴 클래스에서 사라집니다.
experimental.coroutines.usages.are.obsolete.since.1.3=실험적 코루틴 사용 위치는 1.3부터 지원 중단됩니다.
package.usages.are.obsolete.since.1.4=''{0}'' 패키지의 사용은 1.4부터 지원 중단됩니다
replace.substring.call.with.droplast.call=''substring'' 호출을 ''dropLast'' 호출로 바꿉니다.
replace.substring.call.with.indexing.operation.call=''substring'' 호출을 색인 생성 작업 호출로 바꿉니다.
replace.substring.call.with.substringbefore.call=''substring'' 호출을 ''substringBefore'' 호출로 바꿉니다.
replace.substring.call.with.substringafter.call=''substring'' 호출을 ''substringAfter'' 호출로 바꿉니다.
replace.substring.call.with.take.call=''substring'' 호출을 ''take'' 호출로 바꿉니다.
add.operator.modifier=''operator'' 제어자를 추가합니다.
function.should.have.operator.modifier=함수에 ''operator'' 제어자가 있어야 합니다.
type.parameter.can.have.0.variance=유형 매개변수에 {0} 분산이 있어야 합니다.
add.variance.fix.text=''{0}'' 분산을 추가합니다.
add.variance.fix.family.name=분산 추가
generate.equals.and.hashcode.fix.text=equals() 및 hashCode() 생성
array.property.in.data.class.it.s.recommended.to.override.equals.hashcode=데이터 클래스의 배열 프로퍼티\: equals()/hashCode()를 재정의하는 것이 좋습니다.
report.also.on.call.with.single.boolean.literal.argument=단일 부울 리터럴 인수가 있는 호출에서도 보고합니다.
boolean.literal.argument.without.parameter.name=매개변수 이름이 없는 부울 리터럴 인수
constructor.parameter.is.never.used.as.a.property=생성자 매개변수는 속성으로 사용되지 않습니다.
property.is.explicitly.assigned.to.parameter.0.can=프로퍼티가 매개변수 {0}에 명시적으로 대입되어 생성자에서 바로 프로퍼티를 선언할 수 있습니다.
variable.is.never.modified.and.can.be.declared.immutable.using.val=변수는 한정되지 않으며 ''val''을 사용하여 불변으로 선언할 수 있습니다.
sealed.sub.class.has.no.state.and.no.overridden.equals=봉인된 하위 클래스에 상태도 없고 재정의된 equals도 없습니다.
cascade.if.should.be.replaced.with.when=캐스케이드 if를 when으로 바꿔야 합니다.
mark.as.deprecated.level.deprecationlevel.hidden=@Deprecated(..., level \= DeprecationLevel.HIDDEN)로 표시합니다.
searching.for.imports.to.delete=삭제할 import 문 검색
delete.redundant.extension.property=중복 확장 프로퍼티를 삭제합니다.
this.property.conflicts.with.synthetic.extension.and.should.be.removed.or.renamed.to.avoid.breaking.code.by.future.changes.in.the.compiler=이 속성은 통합 확장과 충돌하므로 컴파일러에서 향후 변경으로 인해 코드가 손상되지 않도록 하려면 해당 프로퍼티를 제거하거나 이름을 변경해야 합니다.
condition.is.always.0=조건이 항상 ''{0}''입니다.
remove.fix.text=표현식을 삭제합니다.
simplify.fix.text=표현식 단순화
0.has.empty.body=''{0}''의 본문이 비어 있습니다.
convert.na.n.equality.quick.fix.text=''isNaN()''으로 바꿉니다.
equality.check.with.nan.should.be.replaced.with.isnan=NaN과의 상등 검사를 ''isNaN()''으로 바꿔야 합니다.
convert.pair.constructor.to.to.fix.text=''to''로 변환합니다.
can.be.converted.to.to=''to''로 변환할 수 있습니다.
convert.to.a.range.check=범위 검사로 변환합니다.
two.comparisons.should.be.converted.to.a.range.check=두 개의 비교 항목을 범위 검사로 변환해야 합니다.
copy.method.of.data.class.is.called.without.named.arguments=데이터 클래스의 ''copy'' 메서드가 이름 지정된 인수 없이 호출됩니다.
private.data.class.constructor.is.exposed.via.the.generated.copy.method=private 데이터 클래스 생성자가 생성된 ''copy'' 메서드를 통해 노출됩니다.
remove.var.keyword.text=var 제거
delegating.to.var.property.does.not.take.its.changes.into.account=''var'' 속성으로 위임해도 해당 변경이 고려되지 않습니다.
add.replacewith.argument.to.specify.replacement.pattern=''replaceWith'' 인수를 추가하여 대체 패턴을 지정합니다.
deprecated.annotation.without.replacewith.argument=''replaceWith'' 인수가 없는 @Deprecated 어노테이션
variable.name.0.matches.the.name.of.a.different.component=변수 이름 ''{0}''이(가) 다른 구성 요소의 이름과 일치합니다.
replace.with.down.to.fix.text=''downTo''로 바꿉니다.
this.range.is.empty.did.you.mean.to.use.downto=이 범위는 비어 있습니다. ''downTo''를 사용하시겠어요?
equals.hashcode.in.object.declaration=객체 선언의 equals()/hashCode()
hash.code.text=''hashCode()'' 생성
equals.text=''equals()'' 생성
delete.equals.and.hash.code.fix.text=equals()/hashCode()를 삭제합니다.
redundant.explicit.this=중복 명시적 this
explicit.this.expression.fix.family.name=중복 ''{0}'' 제거
use.of.non.const.kotlin.property.as.java.constant.is.incorrect.will.be.forbidden.in.1.4=상수가 아닌 Kotlin 프로퍼티를 Java 상수로서 사용하는 것은 올바르지 않으며 1.4에서 금지됩니다.
replace.if.with.elvis.operator=''if''를 elvis 연산자로 바꿉니다.
if.null.return.break.foldable.to=''?\:''로 접을 수 있는 If-Null return/break/...
loop.parameter.0.is.unused=루프 매개변수 ''{0}''이(가) 사용되지 않습니다.
replace.with.repeat.fix.family.name=''repeat()''으로 바꾸기
introduce.anonymous.parameter.fix.family.name=익명 매개변수 삽입
wrap.run.fix.text={ ... }을(를) 실행하도록 변환합니다.
remove.braces.fix.text=중괄호 제거
function.with.and.inferred.return.type=''\= { ... }''이(가) 있는 함수 및 추론된 반환 유형
report.for.types.with.platform.arguments=플랫폼 인수가 있는 유형에 대해 보고합니다.
apply.only.to.public.or.protected.members=public 또는 protected 멤버에만 적용합니다.
declaration.has.type.inferred.from.a.platform.call.which.can.lead.to.unchecked.nullability.issues=선언에 플랫폼 호츨에서 추론된 유형이 있어, 확인되지 않은 null 값 가능성 문제로 이어질 수 있습니다. 유형을 명시적으로 null 가능 또는 null 불가능으로 지정합니다.
callable.reference.fix.family.name=명시적 ''{0}'' 추가
java.collections.static.method.call.should.be.replaced.with.kotlin.stdlib=Java 컬렉션 정적 메서드 호출을 Kotlin stdlib으로 바꿔야 합니다.
replace.with.std.lib.fix.text={0}.{1}(으)로 바꿉니다.
call.of.java.mutator.0.on.immutable.kotlin.collection.1=불변 Kotlin 컬렉션 ''{1}''에서의 Java 변경자 ''{0}''의 호출
replace.with.kotlin.s.foreach=Kotlin의 forEach로 바꿉니다.
java.map.foreach.method.call.should.be.replaced.with.kotlin.s.foreach=Java Map.forEach 메서드 호출을 Kotlin의 forEach로 바꿔야 합니다.
remove.deprecated.symbol.import=더 이상 사용되지 않는 심볼의 import 문을 제거합니다.
usage.of.redundant.or.deprecated.syntax.or.deprecated.symbols=중복되거나 사용되지 않는 구문 또는 사용되지 않는 심볼의 사용 위치
equals.should.take.any.as.its.argument=''equals''가 ''Any?''를 인수로 취해야 합니다.
double.negation.fix.text=중복 부정을 제거합니다.
redundant.double.negation=중복 이중 부정
equals.between.objects.of.inconvertible.types=변환할 수 없는 유형의 객체 간의 ''equals()''
usage.of.kotlin.internal.declaration.from.different.module=다른 모듈의 Kotlin 내부 선언 사용 위치
junit.static.methods=JUnit 정적 메서드
redundant.override.fix.text=중복 재정의 메서드를 제거합니다.
redundant.overriding.method=중복 재정의 메서드
throwable.instance.0.is.not.thrown=던지기 가능한 인스턴스 ''{0}''이(가) 던져지지 않습니다.
result.of.0.call.is.not.thrown=''{0}'' 호출의 결과가 던져지지 않습니다.
optimize.imports=import 문 최적화
unused.import.directive=사용되지 않는 import 지시문
lateinit.var.overrides.lateinit.var=lateinit var가 lateinit var를 재정의합니다.
leaking.this.in.constructor.of.non.final.class.0=final이 아닌 클래스 {0}의 생성자 내 ''this'' 누수
leaking.this.in.constructor.of.enum.class.0.with.overridable.members=열거형 클래스 {0}(재정의 가능한 멤버 포함)의 생성자 내 ''this'' 누수
accessing.non.final.property.0.in.constructor=생성자 내 final이 아닌 프로퍼티 {0}에 액세스
calling.non.final.function.0.in.constructor=생성자 내 final이 아닌 함수 {0} 호출
text.can=할 수 있습니다
text.should=해야 합니다
text.Assignment=대입
text.Return=반환
text.return=리턴
0.1.be.lifted.out.of.2={0}을(를) ''{2}''에서 제거{1}.
lift.assignment.out.fix.text.0=''{0}''에서 대입을 제거합니다.
lift.return.out.fix.text.0=''{0}''에서 return 제거
change.main.function.return.type.to.unit.fix.text=명시적 Unit 반환 유형을 추가합니다.
change.main.function.return.type.to.unit.fix.text2=반환 유형을 Unit으로 변경합니다.
0.should.return.unit={0}이(가) Unit을 반환해야 합니다.
junit.test=JUnit 테스트
map.get.with.not.null.assertion.operator=null이 아닌 어설션 연산자 (\!\!)가 있는 map.get()
replace.with.get.or.else.fix.text=''getOrElse'' 호출로 바꿉니다.
replace.with.get.value.call.fix.text=''getValue'' 호출로 바꿉니다.
replace.with.elvis.error.fix.text=''?\: error("")''로 바꿉니다.
might.be.const=''const''일 수 있습니다.
const.might.be.used.instead.of.jvmfield=''@JvmField'' 대신 ''const''를 사용할 수 있습니다.
text.Function=함수
text.Property=프로퍼티
0.1.could.be.private={0} ''{1}''은(는) private이 될 수 있습니다.
diagnostic.name.should.be.replaced.by.the.new.one=진단 이름을 새 이름으로 바꿔야 합니다.
replace.diagnostic.name.fix.text={0}을(를) {1}(으)로
replace.diagnostic.name.fix.family.name=진단 이름 바꾸기
lambda.argument.0.be.moved.out=람다 인수 {0}을(를) 소괄호 밖으로 이동{0}.
move.lambda.argument.out.of.parentheses=람다 인수를 소괄호 밖으로 이동합니다.
suspicious.callable.reference.as.the.only.lambda.element=유일한 람다 요소로서의 의심스러운 호출 가능한 참조
inline.variable=변수 인라인화
move.variable.declaration.into.when=변수 선언을 ''when''으로 이동합니다.
nothing.to.do=수행할 것이 없습니다.
variable.declaration.could.be.inlined=변수 선언을 인라인화할 수 있습니다.
variable.declaration.could.be.moved.into.when=변수 선언을 ''when''으로 이동할 수 있습니다.
may.contain.only.letters.digits.or.underscores=문자, 숫자 또는 밑줄만 포함할 수 있습니다.
may.contain.only.letters.and.digits=문자와 숫자만 포함할 수 있습니다.
should.not.contain.underscores.in.the.middle.or.the.end=중간 또는 끝에 밑줄이 있으면 안 됩니다.
should.not.start.with.an.underscore=밑줄로 시작하면 안 됩니다.
should.not.start.with.an.uppercase.letter=대문자로 시작하면 안 됩니다.
should.not.contain.underscores=밑줄이 있으면 안 됩니다.
should.start.with.a.lowercase.letter=소문자로 시작해야 합니다.
should.start.with.an.uppercase.letter=대문자로 시작해야 합니다.
doesn.t.match.regex.0=정규식 ''{0}''와(과) 일치하지 않습니다.
text.pattern=패턴
package.name=패키지 이름
text.part=부분
text.name=이름
text.Package=패키지
add.explicit.parameter.to.outer.lambda.fix.text=외부 람다에 명시적 매개변수 이름을 추가합니다.
implicit.parameter.it.of.enclosing.lambda.is.shadowed=둘러싸는 람다의 묵시적 매개변수 ''it''이 그림자화되어 있습니다.
equality.cehck.0.be.used.instead.of.elvis.for.nullable.boolean.check=elvis 대신 상등 검사 {0}을(를) null 가능한 부울 검사에 사용{0}.
replace.with.equality.check.fix.text=상등 검사로 바꿉니다.
null.checks.to.safe.call.check.fix.text=체인 null 검사를 안전한 호출로 바꿉니다.
null.checks.replaceable.with.safe.calls=안전한 호출로 대체 가능한 null 검사
optionally.expected.annotation.has.no.actual.annotation.in.module.0.for.platform.1=플랫폼 {1} 에 대한 모듈 {0} 에서 선택적으로 필요한 어노테이션에 실제 어노테이션이 없습니다
call.of.inline.function.with.nullable.extension.receiver.can.provoke.npe.in.kotlin.1.2=null 가능한 확장 리시버가 있는 인라인 함수의 호출은 Kotlin 1.2 이후 버전에서 NPE를 발생시킬 수 있습니다.
make.open.fix.text=클래스를 엽니다.
make.private.fix.text=private으로 설정
protected.visibility.is.effectively.private.in.a.final.class=''protected'' 가시성은 final 클래스에서 사실상 ''private''입니다.
apply.also.to.private.members=private 멤버에도 적용합니다.
apply.also.to.internal.members=내부 멤버에도 적용합니다.
for.api.stability.it.s.recommended.to.specify.explicitly.declaration.types=API 안정성을 위해 선언 유형을 명시적으로 지정하는 것이 좋습니다.
for.api.stability.it.s.recommended.to.specify.explicitly.public.protected.declaration.types=API 안정성을 위해 public 및 protected 선언 유형을 명시적으로 지정하는 것이 좋습니다.
recursive.equals.call=재귀적 equals 호출
replace.with.field.fix.text=''field''로 바꿉니다.
recursive.synthetic.property.accessor=재귀적 통합 프로퍼티 접근자
recursive.property.accessor=재귀적 프로퍼티 접근자
remove.redundant.companion.reference.fix.text=중복 컴패니언 참조를 제거합니다.
redundant.companion.reference=중복 컴패니언 참조
remove.redundant.else.fix.text=중복 ''else''를 제거합니다.
redundant.else=중복 ''else''
remove.initializer.block.fix.text=이니셜라이저 블록을 제거합니다.
redundant.empty.initializer.block=중복된 빈 이니셜라이저 블록
remove.enum.constructor.invocation.fix.text=열거형 생성자 호출을 제거합니다.
redundant.enum.constructor.invocation=중복된 열거형 생성자 호출
explicitly.given.type.is.redundant.here=명시적으로 지정된 유형이 여기에서 중복됩니다.
remove.redundant.getter.fix.text=중복 getter를 제거합니다.
redundant.getter=중복 getter
remove.redundant.if.text=중복 ''if'' 문을 제거합니다.
redundant.if.statement=중복 ''if'' 문
delete.fix.family.name=화살표 제거
redundant.lambda.arrow=중복된 람다 화살표
remove.let.call=''let'' 호출을 제거합니다.
redundant.let.call.could.be.removed=중복된 ''let'' 호출을 제거할 수 있습니다.
redundant.modality.modifier=중복된 모달리티 제어자
this.type.probably.can.be.changed.to.nullable=이 유형은 null 가능으로 변경할 수 있습니다.
redundant.type.checks.for.object=객체에 대한 중복 유형 검사
replace.with.equality.fix.text=''{0}''을(를) ''{1}''(으)로 바꾸기
redundant.0.call=중복 ''{0}'' 호출
remove.require.not.null.call.fix.text=''{0}'' 호출 제거
remove.return.label.fix.text=중복 ''@{0}''을(를) 제거합니다.
remove.return.label.fix.family=중복 라벨을 제거합니다.
redundant.0=중복 ''@{0}''
remove.redundant.sam.constructors=중복 SAM 생성자를 제거합니다.
remove.redundant.sam.constructor=중복 SAM 생성자를 제거합니다.
redundant.sam.constructors=중복 SAM 생성자
redundant.sam.constructor=중복 SAM 생성자
fix.text=중복 세미콜론을 제거합니다.
redundant.semicolon=중복 세미콜론
remove.redundant.setter.fix.text=중복 setter를 제거합니다
redundant.setter=중복 setter
redundant.suspend.modifier=중복 ''suspend'' 제어자
redundant.unit.return.type=중복 ''Unit'' 반환 유형
redundant.visibility.modifier=중복된 가시성 제어자
remove.redundant.unit.fix.text=중복 ''Unit''을 제거합니다.
redundant.unit=중복 ''Unit''
remove.redundant.with.fix.text=중복 ''with'' 호출을 제거합니다.
redundant.with.call=중복 ''with'' 호출
reformat.quick.fix.family.name=파일 서식 다시 지정
apply.only.to.modified.files.for.projects.under.a.version.control=수정된 파일(버전 관리에 있는 프로젝트의 파일)에만 적용합니다.
file.is.not.properly.formatted=파일의 서식이 올바르게 지정되지 않았습니다.
remove.jvmoverloads.annotation=@JvmOverloads 어노테이션을 제거합니다
report.also.for.a.variables.without.a.whitespace.around=주위에 공백이 없는 변수에 대해서도 보고합니다.
remove.curly.braces=중괄호를 제거합니다.
redundant.curly.braces.in.string.template=문자열 템플릿의 중복 중괄호
remove.empty.parentheses.from.annotation.entry.fix.text=불필요한 소괄호를 제거합니다.
parentheses.should.be.removed=소괄호를 제거해야 합니다.
remove.redundant.qualifier.name.quick.fix.text=중복 한정자 이름을 제거합니다
redundant.qualifier.name=중복 한정자 이름
remove.redundant.backticks.quick.fix.text=중복 백틱을 제거합니다.
remove.redundant.spread.operator.quickfix.text=중복 스프레드 연산자를 제거합니다.
remove.to.string.fix.text=''toString()'' 호출을 제거합니다.
redundant.tostring.call.in.string.template=문자열 템플릿 내 중복 ''toString()'' 호출
redundant.setter.parameter.type=중복 setter 매개변수 유형
replace.with.contentequals=''\!\=''를 ''contentEquals''로 바꿉니다.
replace.with.contentequals2=''\=\=''를 ''contentEquals''로 바꿉니다.
replace.with.contentequals3=''contentEquals''로 바꿉니다.
dangerous.array.comparison=위험한 배열 비교
replace.with.array.literal.fix.family.name=[...](으)로 바꾸기
0.call.should.be.replaced.with.array.literal=''{0}'' 호출을 배열 리터럴 [...]로 바꿔야 합니다.
replace.assert.boolean.with.assert.equality=어설션 부울을 어설션 상등으로 바꿉니다.
replace.0.with.1=''{0}''을(를) ''{1}''(으)로 바꾸기
replace.collection.count.with.size.quick.fix.text=''count''를 ''size''로 바꿉니다.
could.be.replaced.with.size=''size''로 바꿀수 있습니다.
replace.with.kotlin.s.function.call=Kotlin의 함수 호출로 바꿉니다
replace.guard.clause.with.kotlin.s.function.call=guard 절을 Kotlin의 함수 호출로 바꿉니다
replace.index.loop.with.collection.loop.quick.fix.text=요소에 대한 루프로 바꿉니다.
replace.manual.range.with.indices.call.quick.fix.text=색인으로 바꿉니다.
range.could.be.replaced.with.indices.call=범위를 ''.indices'' 호출로 바꿀수 있습니다.
for.loop.over.indices.could.be.replaced.with.loop.over.elements=색인에 대한 for 루프를 요소에 대한 루프로 바꿀수 있습니다.
replace.negated.0.with.1=부정된 ''{0}''을(를) ''{1}''(으)로 바꿉니다.
replace.with.elvis.return.fix.text=''?\: return{0}''(으)로 바꿉니다.
replace.with.return=''\!\!''를 ''?\: return''으로 바꿉니다.
convert.put.to.assignment=put을 대입으로 변환합니다.
map.put.should.be.converted.to.assignment=map.put()을 대입으로 변환해야 합니다.
replace.int.range.end.inclusive.with.last.quick.fix.text=''endInclusive''를 ''last''로 바꿉니다.
replace.int.range.start.with.first.quick.fix.text=''start''를 ''first''로 바꿉니다.
could.be.replaced.with.unboxed.last=박싱되지 않은 ''last''로 바꿀수 있습니다.
could.be.replaced.with.unboxed.first=박싱되지 않은 ''first''로 바꿀수 있습니다.
replace.with.until.quick.fix.text=until로 바꿉니다.
rangeto.or.the.call.should.be.replaced.with.until=''rangeTo'' 또는 ''..'' 호출을 ''until''로 바꿔야 합니다.
replace.with.string.literal.fix.family.name=문자열 템플릿으로 바꾸기
string.format.call.can.be.replaced.with.string.templates=String.format 호출을 문자열 템플릿으로 바꿀수 있습니다.
replace.tostring.with.string.template=''toString''을 문자열 템플릿으로 바꿉니다.
call.of.tostring.could.be.replaced.with.string.template=''toString''의 호출을 문자열 템플릿으로 바꿀수 있습니다.
replace.to.with.infix.form.quickfix.text=''to''를 infix 형식으로 바꿉니다.
replace.with.enum.map.fix.text=EnumMap으로 바꿉니다.
replaceable.with.enummap=EnumMap으로 바꿀 수 있습니다.
replace.with.operator.assignment=연산자 대입으로 바꿉니다.
replaceable.with.operator.assignment=연산자 대입으로 바꿀 수 있습니다.
replace.with.0.eq=''{0}\=''로 바꿉니다.
replace.with.if.fix.text=''if'' 유형 검사로 바꿉니다.
should.be.replaced.with.if.type.check=''if'' 유형 검사로 바꿔야 합니다.
call.is.replaceable.with.another.scope.function=호출을 다른 범위 함수로 바꿀수 있습니다.
convert.scope.function.fix.family.name=''{0}''(으)로 변환
variable.0.is.assigned.to.itself=''{0}'' 변수는 자체 할당됩니다.
remove.self.assignment.fix.text=자체 할당 제거
convert.to.nullable.type.fix.text=null 가능 유형으로 변환합니다.
constructor.has.non.null.self.reference.parameter=생성자에 null이 아닌 자체 참조 매개변수가 있습니다.
assign.backing.field.fix.text=백킹 필드를 대입합니다.
existing.backing.field.is.not.assigned.by.the.setter=기존 백킹 필드가 setter로 대입되지 않았습니다
replace.with.error=''?\: error(...)''로 바꿉니다.
replace.assert.with.operator=어설션을 연산자로 바꿉니다.
assert.should.be.replaced.with.operator=어설션을 연산자로 바꿔야 합니다.
simplify.negated.operation=부정된 연산을 단순화합니다.
negated.operation.should.be.simplified=부정된 연산을 단순화해야 합니다.
replace.negated.0.operation.with.1=부정된 ''{0}'' 연산을 ''{1}''(으)로 바꿉니다.
simplify.when.fix.text=''when''을 단순화합니다.
this.when.is.simplifiable=이 ''when''을 단순화할 수 있습니다.
sort.modifiers=제어자 정렬
non.canonical.modifiers.order=비표준 제어자 순서
modifiers.should.follow.annotations=제어자는 어노테이션 다음에 와야 합니다
remove.as.dynamic.call.fix.text=''asDynamic'' 호출을 제거합니다.
suspicious.asdynamic.member.invocation=의심스러운 ''asDynamic'' 멤버 호출
0.creates.new.1.under.the.hood=''{0}''이(가) 후드에서 새 {1} 생성
replace.with.filter.fix.text=필터로 바꿉니다.
change.type.to.mutable.fix.text=유형을 가변으로 변경합니다.
replace.with.assignment.fix.text=대입으로 바꿉니다(원본이 비어 있음).
join.with.initializer.fix.text=이니셜라이저로 결합합니다.
suspicious.combination.of.and=\=\=와 \=\=\=의 의심스러운 조합
unlabeled.return.inside.lambda=람다 내부의 라벨 지정되지 않은 반환
suspicious.var.property.its.setter.does.not.influence.its.getter.result=의심스러운 ''var'' 프로퍼티\: 해당 setter가 해당 getter 결과에 영향을 미치지 않습니다.
variable.used.only.in.following.return.and.should.be.inlined=변수가 다음 반환에서만 사용되고 인라인화되어야 합니다.
variable.is.same.as.0.and.should.be.inlined=변수가 ''{0}''와(과) 동일하고 인라인화되어야 합니다.
implicit.unsafe.cast.from.dynamic.to.0=동적에서 {0}(으)로의 묵시적인 (안전하지 않은) 형 변환
cast.explicitly.fix.text=명시적으로 형 변환합니다.
unused.equals.expression=사용되지 않는 equals 식
since.kotlin.1.3.main.parameter.is.not.necessary=Kotlin 1.3부터 주요 매개변수가 필요하지 않습니다.
remove.token.from.function.declaration=함수 선언에서 ''\='' 토큰을 제거합니다.
unused.return.value.of.a.function.with.lambda.expression.body=람다 식 본문이 있는 함수의 사용되지 않는 반환값
safe.delete.constructor=안전한 delete 생성자
remove.unary.operator.fix.text=사용되지 않는 단항 연산자를 제거합니다.
unused.unary.operator=사용되지 않는 단항 연산자
one.line.return=한 줄 반환
return.when='when 반환'
block.body=블록 본문
use.expression.body.instead.of.0={0} 대신 표현식 본문을 사용합니다.
convert.to.expression.body.fix.text=표현식 본문으로 변환합니다.
when.has.only.else.branch.and.should.be.simplified=''when''에 ''else'' 브랜치만 있으므로 단순화해야 합니다.
wrap.unary.operator.quickfix.text=단항 연산자와 값을 ()로 래핑합니다.
make.0.1=''{0}''을(를) {1}(으)로 만들기
replace.with.0.operator=''{0}'' 연산자로 바꾸기
do.you.want.to.make.new.extension.an.expected.declaration=새로운 확장을 기대 선언으로 만드시겠어요?
loop.to.call.fix.family.name=stdlib 연산으로 바꾸기
loop.to.call.fix.family.name2=''asSequence()''를 사용하는 stdlib 연산으로 바꾸기
loop.can.be.replaced.with.stdlib.operations=루프를 stdlib 연산으로 바꿀수 있습니다
text.add.setter=setter 추가
text.add.getter=getter 추가
text.add.getter.and.setter=getter 및 setter 추가
text.add.use.site.target.0=사용 사이트 대상 ''{0}'' 추가
choose.use.site.target=사용 사이트 대상 선택
add.use.site.target=사용 사이트 대상 추가
add.braces.to.0.statement=''{0}'' 문에 중괄호를 추가합니다.
add.braces.to.when.entry=''when'' 항목에 중괄호 추가
add.jvmoverloads.annotation.to.0=''@JvmOverloads'' 어노테이션을 {0}에 추가
text.primary.constructor=기본 생성자
function.0=함수 ''{0}''
looking.for.usages.in.java.files=Java 파일 내 사용 위치 검색 중...
add.return.at.0=return@ 추가{0}
add.0.to.argument=''{0} \=''를 인수에 추가
add.val.var.to.parameter.0=val/var을 매개변수 ''{0}''에 추가
add.val.var.to.primary.constructor.parameter=val/var을 기본 생성자 매개변수에 추가
make.primary.constructor.0=기본 생성자 {0} 생성
change.visibility.modifier=가시성 제어자 변경
0.may.break.code={0}(코드를 손상시킬 수 있음)
convert.to.vararg.parameter=vararg 매개변수로 변환
replace.with=''||''를 ''\\&\\&''로 바꾸기
replace.with2=''\\&\\&''를 ''||''로 바꾸기
can.t.modify.0={0}을(를) 수정할 수 없습니다
0.already.exists={0} 이(가) 이미 존재합니다
type.arguments.will.be.lost.after.conversion.0=변환하면 유형 인수가 손실됩니다. {0}
call.with.arguments.will.be.skipped.0=인수가 있는 호출을 건너뜁니다. {0}
looking.for.usages.and.conflicts=사용 위치 및 충돌 검색 중...
following.expression.won.t.be.processed.since.refactoring.can.t.preserve.its.semantics.0=다음 표현식은 리팩터링에서 해당 의미를 유지할 수 없으므로 처리되지 않습니다. {0}
callable.reference.transformation.is.not.supported.0=호출 가능한 참조 변환이 지원되지 않습니다. {0}
can.t.replace.non.kotlin.reference.with.call.expression.0=Kotlin이 아닌 참조를 호출 표현식으로 바꿀 수 없습니다. {0}
convert.0.to.1=''{0}''을(를) ''{1}''(으)로 변환
convert.lambda.to.reference=람다를 참조로 변환
select.target.code.block.file=대상 코드 블록/파일을 선택합니다.
select.target.file=대상 파일을 선택합니다.
replace.expression.with.if.expression=''\!\!'' 식을 ''if'' 식으로 바꾸기
eliminate.argument.of.when=''when''의 인수 제거
replace.elvis.expression.with.if.expression=elvis 식을 ''if'' 식으로 바꾸기
flatten.when.expression=''when'' 식 평면화
replace.if.expression.with.return=''if'' 식을 return으로 바꾸기
lift.return.out.of.if.expression=''if'' 식에서 return 제거
replace.if.with.when=''if''를 ''when''으로 바꾸기
replace.safe.access.expression.with.if.expression=안전한 액세스 표현식을 ''if'' 식으로 바꾸기
replace.assignment.with.if.expression=대입을 ''if'' 식으로 바꾸기
replace.assignment.with.when.expression=대입을 ''when'' 식으로 바꾸기
replace.property.initializer.with.if.expression=프로퍼티 이니셜라이저를 ''if'' 식으로 바꾸기
replace.property.initializer.with.when.expression=프로퍼티 이니셜라이저를 ''when'' 식으로 바꾸기
replace.return.with.if.expression=return을 ''if'' 식으로 바꾸기
replace.return.with.when.expression=return을 ''when'' 식으로 바꾸기
replace.when.with.if=''when''을 ''if''로 바꾸기
replace.call.with.unary.operator=호출을 단항 연산자로 바꾸기
replace.contains.call.with.in.operator=''contains'' 호출을 ''in'' 연산자로 바꾸기
replace.invoke.with.direct.call=''invoke''를 직접 호출로 바꾸기
copy.concatenation.text.to.clipboard=연결 텍스트를 클립보드에 복사
split.property.declaration=프로퍼티 선언 분할
replace.with.stdlib.operations.with.use.of.assequence=''asSequence()''를 사용하는 stdlib 연산으로 바꾸기
replace.with.stdlib.operations=stdlib 연산으로 바꾸기
use.withindex.instead.of.manual.index.increment=수동 색인 증분 대신 withIndex() 사용
add.braces=중괄호 추가
add.indices.to.for.loop=''for'' 루프에 색인 추가
add.jvmoverloads.annotation=''@JvmOverloads'' 어노테이션 추가
add.jvmstatic.annotation=''@JvmStatic'' 어노테이션 추가
add.labeled.return.to.last.expression.in.a.lambda=람다 내 마지막 표현식에서 라벨 지정된 return 제거
add.missing.component=누락된 구성 요소 추가
add.names.to.call.arguments=호출 인수에 이름 추가
add.names.to.this.argument.and.following.arguments=이 인수 및 다음 인수에 이름 추가
add.name.to.argument=인수에 이름 추가
make.open=open 생성
add.throws.annotation=''@Throws'' 어노테이션 추가
add.remaining.branches=남아 있는 브랜치를 추가합니다.
convert.anonymous.function.to.lambda.expression=익명 함수를 람다 식으로 변환
convert.to.lambda.expression=람다 식으로 변환
put.arguments.on.separate.lines=인수를 별도의 줄에 배치
put.parameters.on.separate.lines=매개변수를 별도의 줄에 배치
demorgan.law=드모르간 법칙
replace.with.end.of.line.comment=줄 주석의 끝으로 바꾸기
convert.collection.constructor.to.function=컬렉션 생성자를 함수로 변환
convert.to.sealed.class=봉인된 클래스로 변환
replace.with.a.for.loop=''for'' 루프로 바꾸기
convert.function.to.property=함수를 프로퍼티로 변환
convert.function.type.parameter.to.receiver=함수 유형 매개변수를 리시버로 변환
convert.function.type.receiver.to.parameter=함수 유형 리시버를 매개변수로 변환
convert.to.nullable.var=null 가능 var로 변환
convert.to.ordinary.property=일반 프로퍼티로 변환
replace.with.block.comment=블록 주석으로 바꾸기
convert.to.lateinit.var=lateinit var로 변환
convert.object.literal.to.class=객체 리터럴을 클래스로 변환
convert.to.lazy.property=lazy 프로퍼티로 변환
convert.parameter.to.receiver=매개변수를 리시버로 변환
convert.to.secondary.constructor=보조 생성자로 변환
convert.property.getter.to.initializer=프로퍼티 getter를 이니셜라이저로 변환
convert.property.initializer.to.getter=프로퍼티 이니셜라이저를 getter로 변환
convert.property.to.function=프로퍼티를 함수로 변환
can.t.replace.foreign.reference.with.call.expression.0=외부 참조를 호출 표현식으로 바꿀 수 없습니다. {0}
unrecognized.reference.will.be.skipped.0=인식되지 않는 참조는 건너뛰기됩니다. {0}
property.overloaded.in.child.class.constructor=하위 클래스 생성자에서 오버로드된 프로퍼티
property.has.an.actual.declaration.in.the.class.constructor=프로퍼티의 실제 선언이 클래스 생성자에 있습니다
convert.to.comparisons=비교로 변환
convert.receiver.to.parameter=리시버를 매개변수로 변환
convert.reference.to.lambda=참조를 람다로 변환
following.problems.are.found=다음 문제가 발견되었습니다.\n
all.expected.and.actual.classes.must.be.sealed.classes=모든 기대 및 실제 클래스는 봉인된 클래스여야 합니다.\n
all.inheritors.must.be.nested.objects.of.the.class.itself.and.may.not.inherit.from.other.classes.or.interfaces=모든 상속자는 클래스 자체의 중첩된 객체여야 하며 다른 클래스나 인터페이스에서 상속받으면 안 됩니다.\n
searching.inheritors=상속자 검색 중...
convert.to.enum.class=열거형 클래스로 변환
convert.to.primary.constructor=기본 생성자로 변환
rename.to.01={0}(으)로 이름 변경
replace.0.name.with.spaces={0} 이름을 공백으로 바꾸기
convert.to.block.body=블록 본문으로 변환
convert.template.to.concatenated.string=템플릿을 연결된 문자열로 변환
replace.with.a.foreach.function.call=''forEach'' 함수 호출로 바꾸기
convert.concatenation.to.raw.string=연결을 원시 문자열로 변환
convert.concatenation.to.template=연결을 템플릿으로 변환
convert.try.finally.to.use=try-finally를 .use()로 변환
convert.to.unsafe.cast=안전하지 않은 형 변환으로 변환
convert.to.0.as.1=''{1}(으)로서 {0}으(로)'' 변환
convert.to.0.unsafecast.1=''{0}.unsafeCast<{1}>()''로 변환
convert.to.unsafecast.call=unsafeCast() 호출로 변환
convert.to.array.parameter=배열 매개변수로 변환
convert.to.assignment.expression=대입을 대입식으로 변환
create.kotlin.subclass=Kotlin 하위 클래스 생성
use.destructuring.declaration=구조 분해 선언 사용
implement.as.constructor.parameter=생성자 매개변수로서 구현
implement.abstract.member=추상 멤버 구현
import.members.from.0=''{0}''의 멤버 가져오기
import.members.with=''*''가 있는 멤버 가져오기
add.import.for.0=''{0}''의 import 문 추가
add.import.for.member=멤버의 import 문 추가
indent.raw.string=원시 문자열 들여쓰기
replace.infix.call.with.ordinary.call=infix 호출을 ordinary 호출로 바꾸기
insert.curly.braces.around.variable=중괄호를 변수 주위에 삽입
add.explicit.type.arguments=명시적 유형 인수 추가
introduce.backing.property=backing 프로퍼티
introduce.import.alias=import 문 별칭 삽입
invert.if.condition=''if'' 조건을 반전시킵니다.
iterate.over.0=''{0}'' 반복
iterate.over.collection=컬렉션 반복
join.declaration.and.assignment=선언 및 할당 결합
can.be.joined.with.assignment=대입과 결합할 수 있습니다
put.arguments.on.one.line=인수를 한 줄에 배치
put.parameters.on.one.line=매개변수를 한 줄에 배치
convert.lambda.expression.to.anonymous.function=람다 식을 익명 함수로 변환
convert.to.anonymous.function=익명 함수로 변환
merge.else.if=''else if'' 문 병합
merge.if.s=''if'' 문 병합
move.lambda.argument.into.parentheses=람다 인수를 소괄호 안으로 이동
class.0.already.contains.1=클래스'' {0}''에 {1}이(가) 이미 포함되어 있습니다
0.in.1.will.require.class.instance={1}의 ''{0}''에 클래스 인스턴스가 필요합니다
searching.for.0={0} 검색 중
move.out.of.companion.object=컴패니언 객체 외부로 이동
calls.with.explicit.extension.receiver.won.t.be.processed.0=명시적 확장 리시버가 있는 호출은 처리되지 않습니다. {0}
usages.of.outer.class.instance.inside.of.property.0.won.t.be.processed=프로퍼티 ''{0}'' 내부에 있는 외부 클래스 인스턴스의 사용 위치가 처리되지 않습니다
companion.object.already.contains.0=컴패니언 객체에 {0}이(가) 이미 포함되어 있습니다
0.references.type.parameters.of.the.containing.class=포함된 클래스의 {0} 참조 유형 매개변수
0.is.overridden.by.declaration.s.in.a.subclass={0}이(가) 하위 클래스의 선언으로 재정의되어 있습니다
move.to.companion.object=컴패니언 객체 내부로 이동
move.to.top.level=최상위 수준으로 이동
package.0.already.contains.1=패키지 ''{0}''에 {1}이(가) 이미 포함되어 있습니다
move.to.class.body=클래스 본문으로 이동
move.to.constructor=생성자로 이동
convert.boolean.const.to.elvis=Boolean? \=\= const를 elvis로 변환
convert.object.literal.to.lambda=객체 리터럴을 람다로 변환
convert.to.lambda=람다로 변환
replace.by.0=''{0}''(으)로 바꾸기
replace.by.reconstructed.type=재생성된 유형으로 바꾸기
remove.argument.name=인수 이름 제거
remove.braces.from.when.entry=''when'' 항목에 중괄호 제거
remove.braces.from.0.statement=''{0}'' 문의 중괄호를 제거합니다.
remove.braces=중괄호 제거
remove.constructor.keyword=생성자 키워드 제거
redundant.empty.class.body=빈 클래스 본문 중복
remove.unnecessary.parentheses.from.function.call.with.lambda=람다가 있는 함수 호출에서 불필요한 소괄호 제거
remove.empty.primary.constructor=빈 기본 생성자 제거
remove.empty.constructor.body=빈 생성자 본문 제거
remove.explicit.lambda.parameter.types.may.break.code=명시적 람다 매개변수 유형 제거(코드가 손상될 수 있음)
remove.explicit.supertype.qualification=명시적 상위 유형 정규화 제거
remove.explicit.type.arguments=명시적 유형 인수 제거
remove.explicit.type.specification=명시적 유형 사양 제거
remove.indices.in.for.loop=''for'' 루프의 색인 제거
index.is.not.used.in.the.loop.body=색인이 루프 본문에서 사용되고 있지 않습니다
remove.return.0=return@{0} 제거
remove.labeled.return.from.last.expression.in.a.lambda=람다 내 마지막 표현식에서 라벨 지정된 반환 제거
remove.redundant.calls.of.the.conversion.method=변환 메서드의 중복 호출 제거
remove.single.expression.string.template=단일 표현식 문자열 템플릿 제거
redundant.string.template=문자열 템플릿 중복
remove.unnecessary.parentheses=불필요한 소괄호를 제거합니다.
rename.class.to.0=클래스 이름을 {0}(으)로 변경
rename.class.to.containing.file.name=클래스 이름을 포함된 파일 이름으로 변경
rename.file.to.0.1=파일 이름을 {0}.{1}(으)로 변경
rename.file.to.match.top.level.class.name=최상위 클래스 이름과 일치하도록 파일 이름 변경
replace.0.with=''{0}()''을(를) ''+\=''로 바꾸기
replace.with1=''+\=''로 바꾸기
replace.explicit.parameter.0.with.it=명시적 매개변수 ''{0}''을(를) ''it''으로 바꾸기
replace.it.with.explicit.parameter=''it''을 명시적 매개변수로 바꾸기
replace.with.0.1.2={0}[{1}] ?\: {2}(으)로 바꾸기
replace.with.indexing.and.elvis.operator=색인 생성 연산자 및 elvis 연산자로 바꾸기
replace.size.check.with.isnotempty=크기 검사를 ''isNotEmpty''로 바꾸기
replace.size.zero.check.with.isempty=제로 크기 검사를 ''isEmpty''로 바꾸기
replace.with.parameter.name=''_''를 매개변수 이름으로 바꾸기
replace.with.ordinary.assignment=일반 대입으로 바꾸기
simplify.boolean.expression=부울 표현식 단순화
specify.explicit.lambda.signature=명시적 람다 시그니처 지정
specify.all.types.explicitly.in.destructuring.declaration=구조 분해 선언에서 모든 유형을 명시적으로 지정
cannot.infer.type.for.this.declaration=이 선언의 유형을 추론할 수 없습니다
split.if.into.two=''if''를 두 부분으로 분할
flip.0=''{0}'' 반전
flip.binary.expression=이진 표현식 반전
flip.equals=''equals'' 반전
replace.with.infix.function.call=infix 함수 호출로 바꾸기
to.ordinary.string.literal=일반 문자열 리터럴로
to.raw.string.literal=원시 문자열 리터럴로
remove.underscores=밑줄 제거
add.underscores=밑줄 추가
excluded.methods=제외된 메서드
use.of.0.method.instead.of.property.access.syntax=프로퍼티 액세스 구문 대신 {0} 메서드 사용
use.property.access.syntax=프로퍼티 액세스 구문 사용
convert.to.object.declaration=객체 선언으로 변환
comment=주석
expression=표현식
statement=구문
class=클래스
object.declaration=객체 선언
top.level=최상위
analyse.modules.with.different.platforms.together=서로 다른 플랫폼에서 모듈을 함께 분석
toggle.composite.analysis.mode.for.multiplatform=멀티플랫폼용 복합 분석 모드 전환
rethrow.stored.pce.as.a.new.runtime.exception=저장된 PCE를 새 런타임 예외로 다시 던지기
internal.toggle.throwing.cached.pce=내부\: 캐싱된 PCE 던지기 전환
minimal.line.count=최소 줄 수
files.to.visit=참조할 파일
random.seed=랜덤 시드
number.of.attempts.then.files.in.project.0=시도 횟수 > 프로젝트 내 파일, {0}
text.done=완료
file.lines=파일 줄
max.functions.to.visit=참조할 최대 함수
move.refactoring.testing=리팩터링 테스트 이동
compiling.project=프로젝트 컴파일 중...
saving.files=파일 저장 중...
perform.refactoring=리팩터링 수행...
update.indices=색인 업데이트...
reset.files=파일 재설정...
cannot.get.or.create.results.file=결과 파일을 가져오거나 생성할 수 없습니다
cannot.get.project.root.directory=프로젝트 루트 디렉터리를 가져올 수 없습니다
0.try.1.with.2.fails.and.3.verifications={0} [{1}회 시도 중 {2}회 실패, {3}회 검증]
test.result.log.file.will.be.placed.here=테스트 결과 로그 파일이 여기에 배치됩니다
maximum.count.of.applied.refactoring.before.validity.check=유효성 검사 전에 적용되는 리팩터링의 최대 수
move.refactoring.test=리팩터링 테스트 이동
resolve.pasted.references=붙여넣은 참조 해결
create.kotlin.file=Kotlin 파일 생성
type.alias.0=유형 별칭 "{0}"
type.parameter.0=유형 매개변수 "{0}"
parameter.0=매개변수 "{0}"
property.0=프로퍼티 "{0}"
function.01=함수 "{0}"
object.0=객체 "{0}"
interface=인터페이스
constructor=생성자
implicit.nothing.type=묵시적 ''Nothing?'' 유형
move.suspicious.callable.reference.into.parentheses=의심스러운 호출 가능한 참조를 소괄호 ''()'' 안으로 이동
local.variable=지역 변수
const.property=Const 프로퍼티
private.property=Private 프로퍼티
object.or.top.level.property=객체 또는 최상위 프로퍼티
property=프로퍼티
test.function=테스트 함수
function=함수
enum.entry=열거형 항목
create.subclass=하위 클래스 생성
implement.sealed.class=봉인된 클래스 구현
implement.abstract.class=추상 클래스 구현
implement.interface=인터페이스 구현
implement.abstract.function=추상 함수 구현
implement.abstract.property=추상 프로퍼티 구현
replace.explicit.lambda.parameter.with.it=명시적 람다 매개변수를 ''it''으로 바꾸기
create.test=테스트 생성
convert.class.0.to.kotlin=클래스 ''{0}''을(를) Kotlin으로 변환
destination.directory=대상 디렉터리(&D)
language.version=언어 버전(&L)
add.prefix.to.paths.in.source.map=소스 맵의 경로에 접두사 추가\:
api.version=API 버전(&I)
compiler.coroutines=코루틴(&U)
embed.source.code.into.source.map=소스 코드를 소스 맵에 포함\:
enable.incremental.compilation=증분 컴파일 활성화
keep.compiler.process.alive.between.invocations=호출 사이에 컴파일러 프로세스 지속
script.templates.classpath=스크립트 템플릿 클래스 경로(&P)\:
module.kind=모듈 종류(&K)\:
script.template.classes=스크립트 템플릿 클래스(&T)\:
target.jvm.version=대상 JVM 버전(&J)
reload.script.dependencies.on.file.change=파일 변경 시 스크립트 종속성 다시 로드
additional.command.line.parameters=추가 명령줄 매개변수
mnemonic.install=설치(&I)
status=(상태)
build.number.internal.mode=빌드 번호(내부 모드)\:
check.again=다시 확인(&K)
current.kotlin.plugin.version=현재 Kotlin 플러그인 버전\:
experimental.features=실험적 기능
action.text.install=설치
update.channel=채널 업데이트(&C)\:
version={버전}
don.t.show.this.dialog.next.time=다음에는 이 대화상자를 표시 안 함(&D)
clipboard.content.copied.from.java.file.do.you.want.to.convert.it.to.kotlin.code=클립보드 내용이 Java 파일에서 복사되었습니다. Kotlin 코드로 변환하시겠어요?
name=이름(&N)\:
return.type=반환 유형(&R)\:
visibility=가시성(&V)\:
title.parameters=매개 변수
signature.preview=시그니처 미리보기
move.members.from=다음의 멤버를 이동\:
open.moved.members.in.editor=에디터에서 이동된 멤버 열기
open.moved.method.in.editor=에디터에서 이동된 메서드 열기
to.fully.qualified.name=대상 (정규화된 이름)\:
toggle.library.to.source.dependency.support=라이브러리를 소스 종속성 지원으로 전환
enable.components.for.library.to.source.analysis.in.kotlin=Kotlin의 프로젝트 소스 파일에 따라 라이브러리 분석을 위한 구성 요소 활성화
incomplete.destructuring.declaration.text=불완전한 구조 분해 선언
incomplete.destructuring.fix.family.name=누락된 변수를 구조 분해 선언에 추가

action.Kotlin.StopScratch.text=스크래치 실행 중지
action.Kotlin.StopScratch.description=스크래치 실행 중지
action.Kotlin.ClearScratch.text=Kotlin 스크래치 지우기
action.Kotlin.ClearScratch.description=Kotlin 스크래치 지우기
action.Kotlin.RunScratch.text=Kotlin 스크래치 실행
action.Kotlin.RunScratch.description=Kotlin 스크래치 실행
action.KotlinGenerateToString.text=toString()
action.KotlinGenerateEqualsAndHashCode.text=equals() 및 hashCode()
action.KotlinGenerateSecondaryConstructor.text=보조 생성자
action.KotlinGenerateDataMethod.text=매개변수 함수
action.KotlinGenerateTearDownMethod.text=TearDown 함수
action.KotlinGenerateSetUpMethod.text=SetUp 함수
action.KotlinGenerateTestMethod.text=Test 함수
action.KotlinShellExecute.text=Kotlin 코드 실행
action.KotlinShellExecute.description=콘솔에서 Kotlin 코드를 실행합니다
action.IntroduceTypeAlias.text=유형 별칭(_A)…
action.IntroduceTypeParameter.text=유형 매개변수(_Y)…
action.ExtractFunctionToScope.text=함수를 범위로(_S)…
action.KotlinThrowException.text=Kotlin 플러그인의 오류 삭제
action.KotlinFormattingSettingsStatusAction.text=서식 지정 도구 설정 정보
action.CopyAsDiagnosticTest.text=현재 파일을 진단 테스트로서 복사
action.MultiplatformCompositeAnalysisToggleAction.text=복합 분석 전환
action.StoredExceptionsThrowToggleAction.text=캐싱된 PCE 던지기
action.PrintOutNotPropertyMatches.text=프로퍼티가 아닌 후보 검색
action.FindImplicitNothingAction.text=묵시적 Nothing 호출 찾기
action.CheckComponentsUsageSearchAction.text=구성 요소 함수 사용 위치 검색 확인
action.CacheResetOnProcessCanceledToggleAction.text=ProcessCanceledException의 캐시 재설정
action.HighlightingBenchmarkAction.text=벤치마크 강조 표시
action.LocalCompletionBenchmarkAction.text=로컬 시나리오
action.TopLevelCompletionBenchmarkAction.text=최상위 시나리오
group.KotlinCompletionBenchmarkGroup.text=벤치마크 완성
group.KotlinInternalGroup.text=Kotlin
action.TestMoveRefactiringAction.text=열려 있는 프로젝트에서 이동 리팩터링 테스트
group.KotlinRefactoringTesting.text=Kotlin 리팩터링 테스트
action.DumbModeTremble.text=Tremble Dumb 모드
group.InternalKotlin.text=Kotlin 내부 액션
action.IntroduceProperty.text=프로퍼티(_R)…
action.ExtractFunction.text=함수(_F)…
action.KotlinCodeMigrationToggle.text=마이그레이션 탐지 활성화(실험)
action.KotlinCodeMigration.text=코드 마이그레이션 실행
action.CopyKotlinProjectInformation.text=Kotlin 프로젝트 개요를 클립보드에 복사
action.DecompileKotlinToJava.text=Kotlin을 Java로 디컴파일
action.KotlinConfigureUpdates.text=Kotlin 플러그인 업데이트 구성
action.KotlinConfigureUpdates.description=Kotlin 플러그인의 자동 업데이트를 구성합니다
group.KotlinToolsGroup.text=Kotlin
action.ConvertJavaToKotlin.text=Java 파일을 Kotlin 파일로 변환
action.Kotlin.XDebugger.ToggleKotlinVariableView.text=Kotlin 변수만 표시
action.InspectBreakpointApplicability.text=중단점 적용 가능성 검사
action.Kotlin.XDebugger.CoroutinesDump.text=코루틴 덤프 가져오기
action.AddToProblemApiInspection.text=호환되지 않는 API로서 보고합니다.
action.ShowKotlinBytecode.text=Kotlin 바이트코드 표시
action.ConfigureKotlinJsInProject.text=프로젝트에서 Kotlin(JavaScript) 구성
action.ConfigureKotlinInProject.text=프로젝트에서 Kotlin 구성
action.KotlinConsoleREPL.text=Kotlin REPL
action.LibraryToSourceDependencySupportToggleAction.text=라이브러리를 소스 종속성 지원으로 전환

inspection.unused.unary.operator.display.name=사용되지 않는 단항 연산자
inspection.incomplete.destructuring.declaration.display.name=불완전한 구조 분해 선언
inspection.replace.guard.clause.with.function.call.display.name=guard 절을 Kotlin의 함수 호출로 바꿉니다
inspection.lateinit.var.overrides.lateinit.var.display.name=lateinit var 프로퍼티가 lateinit var 프로퍼티를 재정의
inspection.kotlin.equals.between.inconvertible.types.display.name=변환할 수 없는 유형의 객체 간의 ''equals()''
inspection.redundant.empty.initializer.block.display.name=중복된 빈 이니셜라이저 블록
inspection.add.operator.modifier.display.name=함수에 ''operator'' 제어자가 있어야 합니다.
inspection.control.flow.with.empty.body.display.name=본문이 비어 있는 제어 흐름
inspection.replace.java.static.method.with.kotlin.analog.display.name=Java static 메서드를 Kotlin 아날로그로 바꾸기
inspection.self.reference.constructor.parameter.display.name=생성자에 null이 아닌 자체 참조 매개변수가 있습니다.
inspection.replace.not.null.assertion.with.elvis.return.display.name=''\!\!''를 ''?\: return''으로 바꿉니다.
inspection.kotlin.covariant.equals.display.name=공분산 ''equals()''
inspection.replace.associate.function.display.name=''associate''를 ''associateBy'' 또는 ''associateWith''로 바꾸기
inspection.java.map.for.each.display.name=Java Map.forEach 메서드 호출을 Kotlin의 forEach로 바꿔야 합니다.
inspection.kotlin.throwable.not.thrown.display.name=throwable이 던져지지 않음
inspection.redundant.require.not.null.call.display.name=중복 ''requireNotNull'' 또는 ''checkNotNull'' 호출
inspection.replace.range.start.end.inclusive.with.first.last.display.name=범위 ''start'' 또는 ''endInclusive''를 ''first'' 또는 ''last''로 바꾸기
inspection.redundant.enum.constructor.invocation.display.name=중복된 열거형 생성자 호출
inspection.replace.negated.is.empty.with.is.not.empty.display.name=부정된 ''isEmpty''/''isBlank''를 ''isNotEmpty''/''isNotBlank''로 바꾸기
inspection.function.with.lambda.expression.body.display.name=''\= { ... }''이(가) 있는 함수 및 추론된 반환 유형
inspection.suspend.function.on.coroutine.scope.display.name=suspend 함수의 CoroutineScope 리시버로 인해 모호해진 coroutineContext
inspection.boolean.literal.argument.display.name=매개변수 이름이 없는 부울 리터럴 인수
inspection.suspicious.collection.reassignment.display.name=증강 대입이 내부에 새 컬렉션을 생성
inspection.redundant.else.in.if.display.name=''if'' 내 ''else'' 중복
inspection.deferred.is.result.display.name=Deferred를 직접 반환하는 함수
inspection.map.get.with.not.null.assertion.operator.display.name=null이 아닌 어설션 연산자 (\!\!)가 있는 ''map.get()''
inspection.delegation.to.var.property.display.name=''var'' 프로퍼티로 위임
inspection.unused.main.parameter.display.name=주요 매개변수가 필요하지 않습니다
inspection.suspicious.var.property.display.name=의심스러운 ''var'' 프로퍼티\: 해당 setter가 해당 getter 결과에 영향을 미치지 않습니다.
inspection.setter.backing.field.assignment.display.name=기존 백킹 필드가 setter로 대입되지 않았습니다.
inspection.unlabeled.return.inside.lambda.display.name=람다 내부의 라벨 지정되지 않은 반환
inspection.optional.expectation.display.name=선택적으로 필요한 어노테이션에 실제 어노테이션이 없습니다
inspection.remove.empty.parentheses.from.annotation.entry.display.name=불필요한 소괄호를 제거합니다.
inspection.safe.cast.with.return.display.name=''return''이 있는 안전한 형 변환은 ''if'' 유형 검사로 바꿔야 함
inspection.simplifiable.call.display.name=라이브러리 함수 호출을 단순화 가능
inspection.redundant.run.catching.display.name=중복 ''runCatching'' 호출
inspection.direct.use.of.result.type.display.name=Result를 직접 반환하는 함수
inspection.redundant.return.label.display.name=중복 ''return'' 라벨
inspection.replace.assert.boolean.with.assert.equality.display.name=어설션 부울을 어설션 상등으로 바꿉니다.
inspection.suspicious.as.dynamic.display.name=의심스러운 ''asDynamic'' 멤버 호출
inspection.convert.call.chain.into.sequence.display.name=성능 향상을 위해 컬렉션의 호출 체인을 ''Sequence''로 변환할 수 있습니다.
inspection.redundant.with.display.name=중복 ''with'' 호출
inspection.obsolete.experimental.coroutines.display.name=실험적 코루틴 사용 위치는 1.3부터 지원 중단됨
inspection.obsolete.kotlin.js.packages.display.name=''kotlin.browser'' 민 ''kotlin.dom'' 패키지는 1.4부터 더 이상 사용되지 않습니다
inspection.warning.on.main.unused.parameter.migration.display.name=''main''의 ''args''는 1.4부터 사용되지 않음
inspection.prohibit.repeated.use.site.target.annotations.migration.display.name=''@Repeatable'' 없는 반복 가능한 어노테이션은 1.4부터 허용되지 않음
inspection.prohibit.use.site.target.annotations.on.super.types.migration.display.name=상위 클래스의 어노테이션은 1.4부터 의미가 없음
inspection.redundant.label.migration.display.name=1.4부터 중복 라벨
inspection.restrict.return.statement.target.migration.display.name=1.4부터 대상 라벨이 함수를 표시하지 않음
inspection.prohibit.jvm.overloads.on.constructors.of.annotation.classes.migration.display.name=1.4부터 ''@JvmOverloads'' 어노테이션은 어노테이션 클래스의 생성자에서 사용할 수 없음
inspection.prohibit.type.parameters.for.local.variables.migration.display.name=1.4부터 지역 변수는 유형 매개변수를 가질 수 없습니다
inspection.from.closed.range.migration.display.name=1.3부터 fromClosedRange()에 있는 MIN_VALUE 단계
inspection.replace.to.string.with.string.template.display.name=''toString''을 문자열 템플릿으로 바꿉니다.
inspection.nested.lambda.shadowed.implicit.parameter.display.name=중첩된 람다에 가려진 묵시적 매개변수가 있음
inspection.for.each.parameter.not.used.display.name=반복 요소가 forEach에서 사용되지 않음
inspection.replace.string.format.with.literal.display.name=문자열 템플릿으로 바꾸기
inspection.deferred.result.unused.display.name=연기된 결과가 한 번도 사용되지 않습니다.
inspection.redundant.async.display.name=중복 ''async'' 호출
inspection.main.function.return.unit.display.name=진입점 함수는 Unit을 반환해야 함
inspection.move.variable.declaration.into.when.display.name=변수 선언을 ''when'' 내부로 이동 가능
inspection.move.lambda.outside.parentheses.display.name=소괄호 내 람다 인수
inspection.can.sealed.sub.class.be.object.display.name=상태도 없고 재정의된 equals도 없는 봉인된 하위 클래스
inspection.public.api.implicit.type.display.name=public API 선언에 묵시적 반환 유형이 있음
inspection.redundant.companion.reference.display.name=중복 컴패니언 참조
inspection.convert.pair.constructor.to.to.function.display.name=Pair 생성자를 ''to'' 함수로 변환
inspection.redundant.not.null.extension.receiver.of.inline.display.name=인라인 함수의 null이 아닌 확장 리시버를 null 가능하도록 만들 수 있음
inspection.platform.extension.receiver.of.inline.display.name=null 가능한 확장 리시버가 있는 인라인 함수의 안전하지 않은 호출
inspection.scope.function.conversion.display.name=범위 함수를 다른 함수로 변환 가능
inspection.redundant.object.type.check.display.name=객체에 대한 중복 유형 검사
inspection.fake.jvm.field.constant.display.name=const가 아닌 Kotlin 프로퍼티가 Java 상수로 사용됨
inspection.may.be.constant.display.name=''const''일 수 있습니다.
inspection.sort.modifiers.display.name=비표준 제어자 순서
inspection.redundant.suspend.modifier.display.name=중복 ''suspend'' 제어자
inspection.replace.put.with.assignment.display.name=''map.put()''을 대입으로 변환할 수 있습니다
inspection.replace.to.with.infix.form.display.name=''to''를 infix 형식으로 바꾸기
inspection.recursive.equals.call.display.name=재귀적 equals 호출
inspection.java.collections.static.method.on.immutable.list.display.name=불변 Kotlin 컬렉션''에서의 Java 변경자 호출
inspection.java.collections.static.method.display.name=Java 컬렉션 static 메서드 호출을 Kotlin stdlib으로 바꾸기 가능
inspection.simplify.when.with.boolean.constant.condition.display.name=''when'' 단순화 가능
inspection.implicit.nullable.nothing.type.display.name=묵시적 ''Nothing?'' 유형
inspection.self.assignment.display.name=변수의 자기 대입
inspection.redundant.unit.expression.display.name=중복 ''Unit''
inspection.implicit.this.display.name=묵시적 ''this''
inspection.explicit.this.display.name=중복 명시적 this''
inspection.migrate.diagnostic.suppression.display.name=진단 이름을 바꿔야 함
inspection.redundant.setter.display.name=중복 프로퍼티 setter
inspection.remove.redundant.qualifier.name.display.name=중복 한정자 이름을 제거합니다.
inspection.remove.redundant.backticks.display.name=중복 백틱을 제거합니다.
inspection.redundant.getter.display.name=중복 프로퍼티 getter
inspection.suspicious.equals.combination.display.name=\=\=와 \=\=\=의 의심스러운 조합
inspection.kotlin.redundant.override.display.name=중복 재정의 메서드
inspection.package.name.display.name=패키지 이름 지정 규칙
inspection.local.variable.name.display.name=지역 변수 이름 지정 규칙
inspection.const.property.name.display.name=Const 프로퍼티 이름 지정 규칙
inspection.private.property.name.display.name=Private 프로퍼티 이름 지정 규칙
inspection.object.property.name.display.name=Object 프로퍼티 이름 지정 규칙
inspection.property.name.display.name=프로퍼티 이름 지정 규칙
inspection.test.function.name.display.name=Test 함수 이름 지정 규칙
inspection.function.name.display.name=함수 이름 지정 규칙
inspection.enum.entry.name.display.name=열거형 항목 이름 지정 규칙
inspection.class.name.display.name=클래스 이름 지정 규칙
inspection.redundant.lambda.arrow.display.name=중복된 람다 화살표
inspection.redundant.lambda.or.anonymous.function.display.name=람다 또는 익명 함수의 중복 생성
inspection.redundant.lambda.description=중복 람다 생성
inspection.redundant.anonymous.function.description=중복 익명 함수 생성
inspection.redundant.lambda.or.anonymous.function.fix=본문 인라인화
inspection.when.with.only.else.display.name=''when''에 ''else'' 브랜치만 있으므로 단순화 가능
inspection.kotlin.double.negation.display.name=중복 이중 부정
inspection.unnecessary.variable.display.name=불필요한 지역 변수
inspection.constant.condition.if.display.name=''if'' 표현식의 조건은 상수임
inspection.null.checks.to.safe.call.display.name=안전한 호출로 바꾸기 가능한 null 검사
inspection.cascade.if.display.name=캐스케이드 if를 when으로 바꾸기 가능
inspection.lift.return.or.assignment.display.name=return 또는 대입을 제거 가능
inspection.use.expression.body.display.name=여기에는 표현식 본문 구문을 권장
inspection.simplifiable.call.chain.display.name=컬렉션 유형에 대한 호출 체인을 단순화 가능
inspection.useless.call.on.collection.display.name=컬렉션 유형에 대한 불필요한 호출
inspection.redundant.explicit.type.display.name=명시적으로 지정된 유형이 여기에서 중복됩니다.
inspection.useless.call.on.not.null.display.name=null이 아닌 유형에 대한 불필요한 호출
inspection.remove.redundant.spread.operator.display.name=중복 스프레드 연산자
inspection.empty.range.display.name=endInclusive보다 큰 start가 있는 범위는 비어 있게 됨
inspection.wrap.unary.operator.display.name=숫자 상수를 가진 모호한 단항 연산자 사용
inspection.nullable.boolean.elvis.display.name=elvis 대신 상등 검사를 null 가능한 부울 검사에 사용 가능
inspection.member.visibility.can.be.private.display.name=클래스 멤버는 ''private'' 가시성을 가질 수 있음
inspection.replace.range.to.with.until.display.name=''rangeTo'' 또는 ''..'' 호출을 ''until''로 바꾸기 가능
inspection.recursive.property.accessor.display.name=재귀적 프로퍼티 접근자
inspection.replace.array.of.with.literal.display.name=''arrayOf'' 호출을 배열 리터럴 [...]로 바꾸기 가능
inspection.copy.without.named.arguments.display.name=데이터 클래스의 ''copy'' 메서드가 이름 지정된 인수 없이 호출됩니다.
inspection.move.suspicious.callable.reference.into.parentheses.display.name=람다 결과로서 사용되는 의심스러운 호출 가능한 참조
inspection.kotlin.internal.in.java.display.name=Java의 Kotlin 내부 선언 사용 위치
inspection.unused.lambda.expression.body.display.name=람다 식 본문이 있는 함수의 사용되지 않는 반환값
inspection.destructuring.wrong.name.display.name=구조 분해 선언의 변수가 잘못된 데이터 클래스 프로퍼티의 이름을 사용
inspection.data.class.private.constructor.display.name=private 데이터 클래스 생성자가 ''copy'' 메서드를 통해 노출됨
inspection.replace.with.enum.map.display.name=EnumMap으로 바꿉니다.
inspection.unused.equals.display.name=사용되지 않는 equals 식
inspection.convert.na.n.equality.display.name=''NaN''을 통한 상등 검사를 ''isNaN'' 호출로 변환
inspection.convert.two.comparisons.to.range.check.display.name=두 개의 비교 항목을 범위 검사로 변환해야 합니다.
inspection.convert.try.finally.to.use.call.display.name=try/finally를 use() 호출로 변환
inspection.join.declaration.and.assignment.display.name=선언 및 할당 결합
inspection.remove.empty.secondary.constructor.body.display.name=빈 생성자 본문 제거
inspection.remove.empty.primary.constructor.display.name=빈 기본 생성자 제거
inspection.remove.redundant.calls.of.conversion.methods.display.name=변환 메서드의 중복 호출 제거
inspection.remove.empty.class.body.display.name=빈 클래스 본문 바꾸기
inspection.replace.size.zero.check.with.is.empty.display.name=제로 크기 검사를 ''isEmpty()''로 바꾸기
inspection.replace.size.check.with.is.not.empty.display.name=크기 검사를 ''isNotEmpty()''로 바꾸기
inspection.convert.secondary.constructor.to.primary.display.name=기본 생성자로 변환
inspection.complex.redundant.let.display.name=인수 기반 ''let'' 호출 중복
inspection.simple.redundant.let.display.name=리시버 기반 ''let'' 호출 중복
inspection.replace.array.equality.op.with.arrays.equals.display.name=''\=\=''를 ''Arrays.equals''로 바꾸기
inspection.remove.empty.parentheses.from.lambda.call.display.name=람다가 있는 함수 호출에서 불필요한 소괄호 제거
inspection.remove.to.string.in.string.template.display.name=문자열 템플릿 내 중복 ''toString()'' 호출 제거
inspection.remove.single.expression.string.template.display.name=중복 문자열 템플릿 제거
inspection.replace.call.with.binary.operator.display.name=2진 연산자로 바꾸기 가능
inspection.remove.setter.parameter.type.display.name=중복 setter 매개변수 유형
inspection.convert.reference.to.lambda.display.name=람다로 바꾸기 가능
inspection.convert.lambda.to.reference.display.name=함수 참조로 바꾸기 가능
inspection.can.be.primary.constructor.property.display.name=프로퍼티가 생성자 매개변수에 명시적으로 대입되어 있음
inspection.has.platform.type.display.name=함수 또는 프로퍼티에 플랫폼 유형이 있음
inspection.leaking.this.display.name=생성자 내 ''this'' 누수
inspection.redundant.if.display.name=중복 ''if'' 문
inspection.redundant.unit.return.type.display.name=중복 ''Unit'' 반환 유형
inspection.redundant.semicolon.display.name=중복 세미콜론
inspection.redundant.modality.modifier.display.name=중복된 모달리티 제어자
inspection.can.be.parameter.display.name=생성자 매개변수는 프로퍼티로 사용되지 않습니다.
inspection.replace.substring.with.substring.before.display.name=''substring'' 호출을 ''substringBefore'' 호출로 바꿉니다.
inspection.replace.substring.with.substring.after.display.name=''substring'' 호출을 ''substringAfter'' 호출로 바꿉니다.
inspection.replace.substring.with.indexing.operation.display.name=''substring'' 호출을 색인 생성 작업 호출로 바꿉니다.
inspection.replace.substring.with.take.display.name=''substring'' 호출을 ''take'' 호출로 바꿉니다.
inspection.replace.substring.with.drop.last.display.name=''substring'' 호출을 ''dropLast'' 호출로 바꿉니다.
inspection.add.variance.modifier.display.name=유형 매개변수가 ''in'' 또는 ''out'' 분산을 가질 수 있음
inspection.protected.in.final.display.name=''protected'' 가시성은 final 클래스에서 사실상 ''private''입니다.
inspection.array.in.data.class.display.name=데이터 클래스 내 배열 프로퍼티
inspection.can.be.val.display.name=지역 ''var''은 한정되지 않으며 ''val''로서 선언 가능
inspection.destructure.display.name=구조 분해 선언 사용
inspection.redundant.visibility.modifier.display.name=중복된 가시성 제어자
inspection.equals.or.hash.code.display.name=''equals()'' 및 ''hashCode()''가 쌍으로 되어 있지 않습니다
inspection.conflicting.extension.property.display.name=확장 프로퍼티가 통합 프로퍼티와 충돌
inspection.use.with.index.display.name=수동으로 증분된 색인 변수는 ''withIndex()''를 사용하여 바꾸기 가능
inspection.loop.to.call.chain.display.name=루프를 stdlib 연산으로 바꾸기 가능
inspection.remove.for.loop.indices.display.name=사용되지 않는 루프 색인
inspection.kotlin.deprecation.display.name=중복되거나 사용되지 않는 구문 또는 사용되지 않는 심볼의 사용 위치
inspection.package.directory.mismatch.display.name=패키지 이름이 포함하는 디렉터리와 일치하지 않음
inspection.k.doc.missing.documentation.display.name=public 선언의 KDoc 주석 누락
inspection.k.doc.unresolved.reference.display.name=KDoc 내 해결되지 않은 참조
inspection.overriding.deprecated.member.display.name=더 이상 사용되지 않는 멤버 재정의
inspection.unsafe.cast.from.dynamic.display.name=동적 유형으로부터의 묵시적인 (안전하지 않은) 형 변환
inspection.redundant.sam.constructor.display.name=중복 SAM 생성자
inspection.kotlin.unused.import.display.name=사용되지 않는 import 지시문
inspection.unused.receiver.parameter.display.name=사용되지 않는 리시버 매개변수
inspection.unused.symbol.display.name=사용되지 않는 심볼
inspection.use.property.access.syntax.display.name=프로퍼티 액세스 구문으로 바꾸기 가능한 접근자 호출
inspection.simplify.boolean.with.constants.display.name=단순화 가능한 bool 표현식
inspection.remove.curly.braces.from.template.display.name=문자열 템플릿의 중복 중괄호
inspection.introduce.when.subject.display.name=인수 삽입으로 단순화 가능한 ''when''
inspection.replace.with.operator.assignment.display.name=연산자 대입으로 바꾸기 가능한 대입
inspection.simplify.negated.binary.expression.display.name=단순화 가능한 부정된 bool 표현식
inspection.remove.explicit.super.qualifier.display.name=불필요한 상위 유형 정규화
inspection.remove.explicit.type.arguments.display.name=불필요한 유형 인수
inspection.fold.initializer.and.if.to.elvis.display.name=''?\:''로 접을 수 있는 If-Null return/break/...
inspection.if.then.to.safe.access.display.name=''?.''로 접을 수 있는 If-Then
inspection.if.then.to.elvis.display.name=''?\:''로 접을 수 있는 If-Then
inspection.replace.manual.range.with.indices.calls.display.name=수동 범위를 색인 또는 컬렉션 반복으로 변환
inspection.replace.get.or.set.display.name=명시적 ''get'' 또는 ''set'' 호출
inspection.convert.to.string.template.display.name=문자열 템플릿으로 변환 가능한 문자열 연결
inspection.deprecated.callable.add.replace.with.display.name=''replaceWith'' 인수가 없는 @Deprecated 어노테이션
inspection.replace.collection.count.with.size.display.name=컬렉션 집계를 크기로 변환 가능
inspection.reformat.display.name=파일의 서식이 프로젝트 설정에 따라 지정되지 않음
inspection.simplify.assert.not.null.display.name=''assert'' 호출을 ''\!\!'' 또는 ''?\:''으로 바꾸기 가능
inspection.object.literal.to.lambda.display.name=객체 리터럴을 람다로 변환 가능
remove.redundant.elvis.return.null.text=중복 ''?\: return null'' 제거
inspection.redundant.elvis.return.null.descriptor=중복 ''?\: return null''
inspection.redundant.elvis.return.null.display.name=중복 ''?\: return null''
inspection.redundant.inner.class.modifier.descriptor=중복 ''inner'' 제어자
inspection.redundant.inner.class.modifier.display.name=중복 ''inner'' 제어자
fix.remove.annotation.text=어노테이션 제거
inspection.trailing.comma.display.name=후미 쉼표 권장
inspection.trailing.comma.report.also.a.missing.comma=누락된 쉼표 또는 줄 바꿈도 보고
inspection.trailing.comma.add.line.break=줄 바꿈 추가
inspection.trailing.comma.missing.line.break=줄 바꿈 누락
inspection.trailing.comma.remove.trailing.comma=후행 쉼표를 제거합니다.
inspection.trailing.comma.useless.trailing.comma=불필요한 후행 쉼표
inspection.trailing.comma.add.trailing.comma=후행 쉼표 추가
inspection.trailing.comma.missing.trailing.comma=후행 쉼표 누락
inspection.trailing.comma.fix.comma.position=쉼표 위치 수정
inspection.trailing.comma.comma.loses.the.advantages.in.this.position=이 위치에서는 쉼표의 이점이 소실됨
inspection.redundant.label.text=중복 라벨
intention.convert.lambda.line={0,choice,0\#단일|1\#여러} 줄의 람다로 변환
intention.trailing.comma.custom.text=서식 지정 도구에서 후행 쉼표를 디폴트로 {0,choice,0\#활성화|1\#비활성화}
intention.trailing.comma.text=서식 지정 도구에서 후행 쉼표를 활성화/비활성화
fix.remove.argument.text=인수 제거
fix.remove.redundant.star.text=중복 * 제거
refactoring.extract.to.separate.file.text=별도의 파일로 추출
action.usage.update.text=사용 위치 업데이트
progress.title.analyze.extraction.data=추출 데이터 분석...
fix.move.file.to.package.dir.name.text=소스 루트
move.refactoring.error.text.cannot.perform.refactoring.since.the.following.files.already.exist=다음 파일이 이미 있으므로 리팩터링을 수행할 수 없습니다.\n\n
kotlin.script.definitions.title=스크립트 정의 관리
kotlin.script.definitions.model.name.autoReloadScriptDependencies.description=파일 변경 시 스크립트 구성을 자동으로 로드하려면 자동 다시 로드를 활성화하세요
kotlin.script.definitions.model.name.autoReloadScriptDependencies=자동 다시 로드
kotlin.script.definitions.model.name.is.enabled=활성화됨
kotlin.script.definitions.model.name.pattern.extension=패턴/확장
kotlin.script.definitions.model.name.name=이름
codestyle.name.kotlin=Kotlin
add.missing.class.keyword=누락된 ''class'' 키워드 추가
fix.move.typealias.to.top.level=유형 별칭을 최상위 수준으로 이동
fix.change.jvm.name=JVM 이름 변경
expand.boolean.expression.to.if.else=bool 표현식을 ''if else'' 문으로 확장
inspection.logger.initialized.with.foreign.class.display.name=로거가 외부 클래스로 초기화되었습니다
logger.initialized.with.foreign.class=로거가 외부 클래스 ''{0}''(으)로 초기화되었습니다
logger.factory.method.name=로거 factory 메서드 이름
logger.factory.class.name=로거 팩토리 클래스 이름
choose.logger.factory.class=로거 팩토리 클래스 선택
inspection.redundant.assequence.call=중복 ''asSequence'' 호출
remove.assequence.call.fix.text=''asSequence'' 호출 제거
codestyle.layout.import.aliases.separately=별칭을 개별적으로 가져오기
button.add.package=패키지 추가
listbox.import.package=패키지
listbox.import.with.subpackages=하위 패키지 포함
title.import.layout=레이아웃 가져오기
title.packages.to.use.import.with=''*''가 포함된 import 문을 사용하는 패키지
redundant.qualifier.unnecessary.non.direct.parent.class.qualifier=불필요한 비 직접적 상위 클래스 한정자
fix.add.exception.to.throws=''{0}'' 추가
fix.add.eq.eq.true=''\=\= true'' 추가
inspection.replace.with.ignore.case.equals.display.name=''equals(..., ignoreCase \= true)''로 바꾸기
inspection.redundant.nullable.return.type.display.name=중복된 null 가능한 반환 유형
0.always.returns.non.null.type=''{0}''이(가) null이 아닌 유형을 항상 반환합니다
0.is.always.non.null.type=''{0}''이(가) 항상 null이 아닌 유형입니다
inspection.simplifiable.scope.function.display.name=중첩된 forEach가 있는 범위 함수를 단순화할 수 있습니다
nested.1.call.in.0.could.be.simplified.to.2=''{0}''에 있는 중첩된 ''{1}'' 호출을 {2}(으)로 단순화할 수 있습니다
evaluate.compile.time.expression=compile-time 표현식 평가

hints.title.codevision=Code Vision
hints.title.codevision.show.hints.for=다음에 대한 힌트 표시\:
hints.title.codevision.usages=사용 위치
hints.title.codevision.inheritors=구현/상속자/재정의

hints.codevision.usages.format={0, choice, 1\#1개 사용 위치|2\#{0,number}개 사용 위치}
hints.codevision.usages.too_many.format={0,number}개 이상의 사용 위치
hints.codevision.implementations.format={0, choice, 1\#1개 구현|2\#{0,number}개 구현}
hints.codevision.implementations.too_many.format={0,number}개 이상의 구현
hints.codevision.inheritors.format={0, choice, 1\#1개 상속자|2\#{0,number}개 상속자}
hints.codevision.inheritors.to_many.format={0,number}개 이상의 상속자
hints.codevision.overrides.format={0, choice, 1\#1개 재정의|2\#{0,number}개 재정의}
hints.codevision.overrides.to_many.format={0,number}개 이상의 재정의
hints.codevision.settings=설정...
inspection.kotlin.invalid.bundle.or.property.display.name=잘못된 프로퍼티 키
inspection.type.parameter.find.view.by.id.display.name=유형 매개변수를 사용하여 형 변환을 findViewById로 변환할 수 있습니다
inspection.illegal.identifier.display.name=잘못된 Android 식별자
inspection.gradle.kotlinx.coroutines.deprecation.display.name=Gradle에서 호환되지 않는 kotlinx.coroutines 종속성은 Kotlin 1.3 이상에서 사용됩니다
inspection.deprecated.gradle.dependency.display.name=Gradle에서 사용되지 않는 라이브러리가 사용되었습니다
inspection.different.stdlib.gradle.version.display.name=Kotlin 라이브러리와 Gradle 플러그인 버전이 다릅니다
inspection.different.kotlin.gradle.version.display.name=Kotlin Gradle과 IDE 플러그인 버전이 다릅니다
action.Kotlin.Gradle.ShowDslLogs.text=Kotlin Gradle DSL 로그 표시
description.Kotlin.Gradle.ShowDslLogs.description=Kotlin Gradle DSL 로그 표시
inspection.incompatible.API.display.name=호환되지 않는 API 사용
inspection.maven.coroutines.deprecation.display.name=Maven에서 호환되지 않는 kotlinx.coroutines 종속성은 Kotlin 1.3 이상에서 사용됩니다
inspection.deprecated.maven.dependency.display.name=Maven에서 사용되지 않는 라이브러리가 사용되었습니다
inspection.different.kotlin.maven.version.display.name=Maven과 IDE 플러그인 버전이 다릅니다
inspection.different.maven.stdlib.version.display.name=라이브러리와 Maven 플러그인 버전이 다릅니다
inspection.kotlin.test.j.unit.display.name=kotlin-test-junit을 사용할 수 있습니다
inspection.kotlin.maven.plugin.phase.display.name=Kotlin Maven Plugin이 잘못 구성되었습니다
action.KotlinGenerateMavenPluginAction.text=Kotlin 플러그인
action.KotlinGenerateMavenTestCompileExecutionAction.text=Kotlin 테스트 컴파일 실행
action.KotlinGenerateMavenCompileExecutionAction.text=Kotlin 컴파일 실행
dialog.message.incorrect.target.path.directory.not.specified=잘못된 대상 경로입니다. 디렉터리가 지정되지 않았습니다.
dialog.message.none.elements.were.selected=선택된 요소가 없습니다
a.field.without.an.initializer.is.not.yet.supported=이니셜라이저가 없는 필드는 아직 지원되지 않습니다
a.constructor.call.is.not.yet.supported=생성자 호출은 아직 지원되지 않습니다
failed.to.create.a.wrapper.for.inlining.to.kotlin=Kotlin로 인라인화할 래퍼를 생성하지 못했습니다
inspection.unused.result.of.data.class.copy=사용되지 않는 데이터 클래스 복사 결과
