go.feature.trainer.specify.sdk.to.continue.learning.title=학습을 계속하려면 Go SDK 지정
go.feature.trainer.too.old.go.sdk.notification.title=<b>{0}</b> 이후 버전으로 Go SDK 업데이트
go.feature.trainer.too.old.go.sdk.notification.text=튜토리얼에서는 Go 모듈을 사용한 종속성 관리에 GoSDK <b>{1}</b> 이후 버전이 필요합니다. 현재의 GoSDK 버전은 <b>{0}</b>입니다.

## Release Module
go.dump.goroutines.name=Goroutines 덤프
go.dump.goroutines.toggle.breakpoint={4} 섹션에서는 <ide/>에 추가된 기능 몇 가지를 설명합니다. 다른 기능은 <a href\="{0}">새로운 기능 페이지</a>에서 확인하세요.\n\
Go에서는 동시 작업을 goroutine이라고 부릅니다. goroutine을 생성하려면 함수 또는 메서드의 호출 앞에 {1} 구문을 사용하세요.\n\
프로그램이 사용하는 모든 goroutine의 덤프를 작성하거나 특정 goroutine을 검색하는 필터를 적용하거나 필터링한 결과를 조사할 수 있습니다.\n\
goroutine을 덤프하기 위해서는 디버그를 시작해야 합니다. 단, 우선 중단점을 생성해야 합니다. {2} 을(를) 누르면 중단점을 전환합니다.{3}
go.dump.goroutines.click.button.DlvDumpAction={0} 도구 창에서 {1} 버튼을 클릭하세요.
go.dump.goroutines.click.button.DlvFilterGoroutinesAction=열린 {0} 탭에서 {1} 버튼을 클릭하세요.
go.dump.goroutines.filter.goroutines={0} 검색 필드에서 {1} 을(를) 입력해 목록을 필터링하세요. 이 필터는 이름에 {1} 이(가) 있는 goroutines를 가진 실행 스택만 남깁니다.

go.support.for.table.tests.name=테이블 테스트 지원
go.support.for.table.tests.call.context.menu=테스트를 실행할 때 <ide/>는 캐럿의 위치를 고려합니다.\n\
예를 들어, 현재 캐럿이 {0} 함수에 위치합니다. {1} 을(를) 눌러 이 함수 내 모든 테스트를 실행하세요.
go.support.for.table.tests.run.subtest=같은 방법을 사용해 각각의 하위 테스트를 실행할 수 있습니다. 현재 캐럿이 {2} 하위 테스트에 있습니다. {0} 을(를) 눌러 실행하세요. \n\
현재 이 방법에는 몇 가지 제약이 있습니다. 자세한 내용은 <a href\="{1}">GoLand 문서</a>에서 확인할 수 있습니다.

go.code.completion.for.benchmarks.bn.name=벤치마크 잋 테스르 코드 완성
go.code.completion.for.benchmarks.bn.for.loop=벤치마크 내에서 {0} 을(를) 입력하면 <ide/>이(가) {0} 루프의 조건식으로 {1} 을(를) 제안합니다.\n\
예를 들어 {0} 을(를) 입력한 다음 제안 목록에서 {2} 을(를) 선택하세요.
go.code.completion.for.benchmarks.bn.create.bench=새 벤치마크를 생성하려면 {0} 을(를) 입력하기 시작한 다음 제안 목록에서 {0} 을(를) 선택하세요.

go.code.completion.for.time.package.name=시간 패키지 코드 완성
go.code.completion.for.time.package.year= 날짜 및 시간 요소의 서식을 지정하기 위해 {0} 패키지는 이미 정의된 레이아웃인 {1} 을(를) 사용합니다. 그렇기 때문에 참조 시간 요소를 자리표시자로 사용해 서식을 정의하게 됩니다.\n\
미리 정의된 레이아웃을 기억하지 못한다면 코드 완성을 사용하여 힌트를 확인할 수 있습니다. 예를 들어 {2} 을(를) 누른 다음 {3} 을(를) 선택하여 년도 요소를 붙여넣습니다.
go.code.completion.for.time.package.month= 다시 {0} 을(를) 누르고 달로 {1} 을(를) 선택하세요.
go.code.completion.for.time.package.hour=제안 목록에서 {0} 을(를) 선택해 시간에 대해서도 동일한 작업을 하세요.
go.code.completion.for.time.package.minute=분으로 {0} 을(를) 선택하여 템플릿을 완료하세요.

go.inspection.unsafe.context.cancellation.name=안전하지 않은 컨텍스트 취소
go.inspection.unsafe.context.cancellation.go.to.error={0} 코드 검사는 {2} 이(가) 반환하는 {1} 함수와 그와 유사한 함수가 모든 실행 경로에서 호출되는지 확인합니다. 컨텍스트 패키지에 관해 더 자세히 알아보려면 <a href\="{3}">golang.org의 패키지 컨텍스트</a>를 참조하세요.\n\
{4} 을(를) 누르면 오류로 이동합니다.
go.inspection.unsafe.context.cancellation.add.defer={1} 실행 경로에서 {0} 을(를) 호출하지 않으므로 {2} 을(를) 입력하여 경고를 수정해야 합니다.

go.support.of.testify.framework.completion.and.subtests.name=코드 완성 및 testify 프레임워크 내 하위 테스트
go.support.of.testify.framework.completion.and.subtests.assert=<strong>전제 조건</strong>\: 이 수업을 종료하려면 <a href\="{0}">GOPATH 전체의 색인화를 활성화</a>하고 <a href\="{1}">{2} 패키지</a>를 설치하세요.\n\
<strong>참고</strong>\: GOPATH 전체를 인덱스화하는 데 시간이 걸릴 수 있습니다. 인덱스화 속도는 GOPATH 아래의 패키지 수와 컴퓨터의 성능에 따라 달라집니다.\n\
<ide/>는 {3} 을(를) 첫 번째 인수로 받아들이는 함수 또는 메서드를 완성할 수 있으며 IDE는 해당 인수를 자동으로 넘겨줍니다.\n\
예를 들어, 16번째 줄에 있는 {6} 뒤에 캐럿 두세요. 점 뒤에 {4} 을(를) 입력하여 완성 목록에서 {4} 을(를) 선택하세요. {5} 을(를) 입력하여 인수 목록을 완성하세요(쉼표 뒤에 공백을 입력하는 것을 잊지 마세요).
go.support.of.testify.framework.completion.and.subtests.run.subtest=게다가 하위 테스트 이름이 문자열 상수라면 {0} 및 {1} 하위 테스트를 실행할 수 있습니다.\n\
예를 들어, 이제 캐럿이 {2} 에 위치하기 때문에 {3} 을(를) 눌러 실행할 수 있습니다.

## Basic Editing Module

go.wrapping.lesson.name=긴 줄 줄 바꿈
go.wrapping.put.arguments.on.separate.lines={0} 함수에 상당히 많은 인수가 전달됩니다. 문제는 첫 번째 인수가 매우 길고 그 뒤의 내용을 확인할 수 없다는 것입니다. 이 문제를 수정할 수 있습니다. 여는 대괄호 뒤에 캐럿이 배치되었으므로 이제 {1} 을(를) 누르고 {2} 을(를) 선택해야 합니다.
go.wrapping.enable.soft.wrap=첫 번째 인수가 여전히 가시 영역 밖에 있습니다. 긴 줄에 소프트 랩을 활성화하는 것이 좋습니다. {0}을(를) 누르고 {1}을(를) 입력한 다음, {2} 스위치를 전환하세요. 나중에 {3}을(를) 눌러 검색을 닫을 수 있습니다.
go.wrapping.put.parameters.on.same.lines={0} 함수의 인수는 한 줄로 처리하면 더 보기 좋을 것 같습니다. 병합하려면 여는 대괄호 뒤에 캐럿을 배치하고 {1}을(를) 눌러 인텐션 액션을 호출한 다음, {2}을(를) 선택하세요.

go.struct.inspections.lesson.name=구조체 검사
go.struct.inspections.jump.to.warning=Go에는 구조체 태그 프로그래밍에 관한 규칙이 있습니다. 이 규칙에 대한 자세한 내용은 <a href\="{0}">golang.org의 이 도움말</a>에서 확인할 수 있습니다.\n\
IDE는 이미 이러한 규칙을 알고 있으므로 사용자가 Go 규칙을 위반하는 불일치 항목를 찾을 수 있도록 도와줍니다. 발견된 모든 문제는 강조 표시됩니다. 예를 들어 {1} 필드 주변은 강조 표시되어 있습니다.\n\
이 오류로 이동하여 무엇이 잘못되었는지 살펴보겠습니다. 경고로 이동하려면 {2}을(를) 누르세요.
go.struct.inspections.delete.line=경고에서는 두 개의 구조체 필드({0} 및 {1})를 동일한 JSON 필드 이름에 매핑하려는 시도가 좋지 않다는 것을 나타냅니다. 이 오류가 발생하면 프로그램은 실행되지만 출력에서 하나의 키가 누락됩니다.\n\
이 문제를 해결하려면 태그 문자열 값의 이름을 바꾸거나 전체 문자열을 삭제하면 됩니다. 간단히 처리하기 위해 {2}을(를) 눌러 전체 문자열을 제거하겠습니다.

go.comment.navigation.lesson.name=주석에서 이동
go.comment.navigation.task={0} 패키지는 별로 크지 않으므로 쉽게 탐색할 수 있습니다. 그러나 일부 패키지는 수백 개의 코드와 주석 줄이 포함되어 거대할 수 있습니다.\n\
IDE에서 선언이 동일한 패키지에 있는 경우 주석에서 선언으로 이동할 수 있습니다. 32행의 주석 섹션에 있는 {1} 함수와 같이 주석 내 메서드, 함수, 구조체의 이름은 조금씩 다르게 색상이 지정됩니다.\n\
이 주석에서 함수 선언으로 이동하려면 주석의 함수 이름에 캐럿을 배치한 후, {2}을(를) 누르세요.

go.formatting.lesson.name=코드 스타일을 코드에 적용
go.formatting.reformat.selection=<ide/>은(는) 코드 서식 지정을 지원합니다. 선택한 코드 블록의 서식을 다시 지정하려면 {0}을(를) 누르세요.
go.formatting.clear.selection=선택 범위를 정리하려면 {0}을(를) 누르세요.
go.formatting.whole.file=줄이 선택되지 않은 경우 전체 소스 파일의 서식을 다시 지정하려면, {0}을(를) 사용하세요.

go.fmt.lesson.name=go fmt 실행
go.fmt.task=코드 서식을 {0} (으)로 지정하고 싶은 경우 {1} 을(를) 눌러 실행할 수 있습니다.

go.comments.lesson.name=주석 추가 및 제거
go.comments.comment.one.line={0} (으)로 어느 줄이든 주석 처리하세요.
go.comments.uncomment.line=같은 단축키 {0}(으)로 주석이 추가된 줄에서 주석 제거
go.comments.comment.block=코드 블록에서 주석을 제거할 수 있습니다. 예를 들어 선택한 블록에서 주석을 제거하려면 {0}을(를) 눌러봅시다.


## Completion Module

go.basic.completion.lesson.name=기본 코드 완성
go.basic.completion.complete.again=조회 메뉴 내에서 {0} 을(를) 선택한 후 {1} 을(를) 누르세요.
go.basic.completion.complete.statement={0}을(를) 눌러 이 구문을 완성한 후 새 줄로 이동하세요.
go.basic.completion.invoke.completion=<ide/>은(는) 새 import 문을 자동으로 삽입합니다. 이제 ''기본 완성''을 활성화하기 위해 {0}을(를) 누르면 조회 메뉴가 다시 표시됩니다.
go.basic.completion.type.and.choose=기본적으로 <ide/>은(는) 코드 완성을 즉시 제안합니다. 캐럿이 있는 곳에서 {0}을(를) 입력하기 시작하면 그에 대응하는 제안 항목이 포함된 조회 메뉴가 표시됩니다. {2}을(를) 누르면 조회 메뉴에서 {1}을(를) 선택할 수 있습니다.

go.smart.type.completion.lesson.name=스마트 유형 완성
go.smart.type.completion.task=스마트 유형 완성은 제안 목록을 필터링하여 현재 컨텍스트에서 적용 가능한 유형만을 포함합니다. {0}을(를) 눌러 대응하는 제안 목록을 확인하세요. 첫 번째 항목을 선택하려면 {1}을(를) 누르세요.

go.smart.type.completion.special.cases.lesson.name=유형 어설션 및 switch 생성
go.smart.type.completion.special.cases.number=변수 유형의 유효성을 검사하거나 확인해야 하는 경우, 유형 어설션이나 switch 구문을 사용할 수 있습니다. <ide/>은(는) 제안 목록의 시작 부분에 그러한 유형을 표시합니다. 제안 개수를 줄이려면 유형 이름을 계속 입력하세요.\n\
{0} 함수에서 유효성 검사를 완료해 보겠습니다. 이를 완료하려면 {2} 인터페이스에 대해 {1} 유형을 전달해야 합니다. {3}을(를) 눌러 {4} 유형을 선택하세요.
go.smart.type.completion.special.cases.line={0} 함수에 문자열을 전달하기로 했다면 {1} 오류가 표시될 것입니다. 값의 유형을 확인하려는 경우 유형 switch 구문을 사용할 수 있습니다. {2}을(를) 눌러 {3}을(를) 선택하세요.

go.smart.type.completion.and.pointers.lesson.name=스마트 유형 완성 및 포인터
go.smart.type.completion.and.pointers.first.task=<ide/>은(는) 가능한 포인터 및 변수 주소 목록을 제안할 수 있습니다.\n\
{1} 함수에서 {0}의 주소를 반환해 보겠습니다. {2}을(를) 눌러 완성 목록에서 {3}을(를) 선택하세요.
go.smart.type.completion.and.pointers.second.task=스마트 유형 완성은 포인터에서도 작동합니다. 포인터를 반환하려면 {0}을(를) 눌러 {1}을(를) 선택하세요.

go.postfix.templates.lesson.name=접미사 템플릿(nn, panic, rr, return)
go.postfix.templates.nn=접미사 템플릿을 사용하면 점 뒤의 접미사, 표현식 유형, 해당 컨텍스트를 기반으로 이미 입력된 표현식을 다른 표현식으로 변환할 수 있습니다. 사전 정의된 접미사 완성 템플릿 세트를 사용하거나 새 템플릿을 생성할 수 있습니다. 사용자 지정 접미사 템플릿에 관한 자세한 내용은 <a href \= "{0}">이 문서 자료</a>를 참조하세요.\n\
{1}을(를) 입력하고 완성 목록에서 {2} 접미사 템플릿을 선택하세요.
go.postfix.templates.choose.item={0}을(를) 입력하고 <action>EditorEnter</action>를 누르세요. 제안 목록에서 {1}을(를) 선택하세요.
go.postfix.templates.rr={0} 접미사 완성 템플릿은 오류 변수가 {1}이(가) 아닌지 확인하는 코드를 생성합니다. 오류 처리를 위해 {0} 접미사 완성 템플릿을 사용할 수 있습니다.\n\
이제 {2}을(를) 입력하고 {3}을(를) 눌러 접미사 템플릿을 선택하세요.
go.postfix.templates.return={0}을(를) 입력하고 {1} 접미사 템플릿을 적용하세요.

go.postfix.completion.lesson.name=접미사 완성 및 정렬
go.postfix.completion.task=알파벳 슬라이스가 무질서한 상태입니다. 문자열 슬라이스를 올바르게 정렬하기 위해 {1} 패키지의 {0} 함수를 슬라이스에 적용할 수 있습니다.\n\
해당 슬라이스가 포함된 변수는 이미 입력되었습니다. 앞뒤로 이동할 필요 없이 {1} 접미사 템플릿을 적용해 보겠습니다. 접미사 완성 제안 목록을 확인하려면 {3} 변수 뒤에 점({2})을 입력하세요. 목록에서 {1}을(를) 선택하거나 에디터에 입력한 다음, {4}을(를) 눌러 구문을 완성하세요.

go.completion.for.functions.lesson.name=함수의 코드 완성
go.completion.for.functions.choose.item=목록에서 {0}을(를) 선택하고 {1}을(를) 누르세요. 제안 목록이 표시되면 입력을 시작하여 결과 수를 줄일 수 있습니다.
go.completion.for.functions.press.twice=요소를 첫 번째 인수로 허용하는 모든 함수를 찾으려면 {0}을(를) <strong>두 번</strong> 누르세요. 요소는 메서드가 아니지만 점 때문에 그렇게 보이니 유의하세요.

## Debug Module

go.debug.function.calls.lesson.name=함수 호출 디버그
go.debug.function.calls.version.warning=<strong>참고</strong>\: 이 기능을 사용하려면 Go 1.11 또는 이후 버전을 설치해야 합니다.
go.debug.function.calls.toggle.breakpoint=디버그 모드에서 함수에 다른 값을 전달하고 함수가 반환하는 결과를 확인할 수 있습니다. 표현식 평가 기능에 관한 자세한 내용은 <a href\="{0}">문서 </a>를 참조하세요.\n\
{1}디버그를 시작하려면 중단점을 만들어야 합니다. 중단점을 전환하려면 {2}을(를) 누르세요.
go.debug.function.calls.mac.note=디버그 서버를 시작하기 위해 운영 체제에서 비밀번호를 요청할 수 있습니다.
go.debug.function.calls.start.debug={0}을(를) 눌러 디버그 세션을 실행하세요.
go.debug.function.calls.run.to.cursor=이제 캐럿은 15행의 끝에 있습니다. {1} 액션의 작동 방식을 확인하려면 {0}을(를) 누르세요.
go.debug.function.calls.step.over={1}을(를) 사용하여 {0} 구문을 스텝오버해 보세요.
go.debug.function.calls.evaluate.expression={1}을(를) 눌러 {0} 액션을 호출하세요.
go.debug.function.calls.enter.expression.to.evaluate={0} 필드에 {1}을(를) 입력하기 시작한 다음 제안 목록에서 {2}을(를) 선택하세요.
go.debug.function.calls.add.arguments.for.evaluation=소괄호 안에 {0}을(를) 입력하세요. 필드에 {1}이(가) 표시되어야 합니다.
go.debug.function.calls.click.evaluate={0}을(를) 클릭하거나 {1}을(를) 누르세요. 그 후에 대화상자를 닫을 수 있습니다.
go.debug.function.calls.stop.debug=디버그를 중지하고 강의를 마치려면 {0}을(를) 누르세요.

go.better.variable.names.in.templates.lesson.name=라이브 및 접미사 템플릿의 변수 이름 개선
go.better.variable.names.in.templates.description=<ide/>은(는) {0} 및 {1} 라이브 템플릿으로 생성된 변수의 이름을 지정할 수 있도록 도와줍니다. 예를 들어 다음 제안 중에서 색인의 경우 {2} 또는 {3}, 값의 경우 {4}, {5}, {6} 을(를) 선택할 수 있습니다.
go.better.variable.names.in.templates.use.forr={0}을(를) 입력하고 완성 목록에서 {1} 접미사 템플릿을 선택하세요.
go.better.variable.names.in.templates.finish=<ide/>에서 색인에 대해 {0} 을(를), 값에 대해 {1} 을(를) 제안하는 것을 확인해 보세요. 이 강의를 마치려면 {2} 을(를) 누르세요.

# Code Generation

go.general.templates.lesson.name=라이브 및 접미사 템플릿\: else, fori, var
go.general.templates.else=라이브 템플릿은 루프, 조건, 다양한 선언 또는 print 문과 같은 일반적인 구문을 코드에 삽입합니다. 이는 접미사 템플릿과 함께 코드를 더 빠르게 작성하는 데 도움이 됩니다.\n\
먼저 {0} 접미사 템플릿부터 시작해 보겠습니다. {0} 접미사 템플릿을 사용하여 표현식이 {1}인지 확인할 수 있습니다.\n\
점 뒤에 {2}을(를) 입력합니다. {3} 필드가 {1}이면 {4} 함수를 실행하세요.
go.general.templates.fori=이제 {0}을(를) 입력하고 제안 목록에서 이 라이브 템플릿을 선택하세요. 루프에서 다음 조건을 설정하세요. {1}.
go.general.templates.type.iteration=각 반복에서 {0} 루프는 {1}을(를) 실행해야 합니다
go.general.templates.vars=현재 프로그램은 사용자가 키보드로 입력한 숫자를 읽고 {0} 루프에서 사용합니다. 그러나 <ide/> 2020.1부터는 템플릿을 사용하여(상수에는 {1}, 변수에는 {2}, 유형에는 {3}, import 문에는 {4}) 구문 그룹을 더 빠르게 코딩할 수 있습니다.\n\
사용자 입력을 {5} 및 {6} 변수의 코딩된 값으로 대체해 보겠습니다. {7}을(를) 입력하기 시작하고 완성 목록에서 {2} 라이브 템플릿을 선택하세요. {5} 및 {6} 변수에 대한 임의의 값을 설정하세요.

go.handling.errors.with.templates.lesson.name=라이브 및 접미사 템플릿의 오류 처리\: if 및 rr
go.handling.errors.with.templates.if.not.null=일부 함수는 두 개의 값을 반환합니다. 예를 들어 {0}은(는) {1}에 대한 포인터와 오류 값을 반환합니다. 오류 값이 {2}이면 파일이 성공적으로 열립니다. 오류가 {3}이 아니면 오류가 발생한 것입니다. <ide/>에서 라이브 및 접미사 템플릿을 사용하면 오류 값 처리를 훨씬 빠르게 작성할 수 있습니다.\n\
{4}을(를) 입력하고 완성 목록에서 {5} 라이브 템플릿을 선택하세요.
go.handling.errors.with.templates.select.err=처리하려는 {0} 변수를 자동 완성 목록에서 선택하세요.
go.handling.errors.with.templates.return.nil.err=파일을 여는 동안 오류가 발생하면 슬라이스와 오류를 반환해야 합니다. 여기서는 {0} 및 {1}을(를) 반환할 수 있습니다. {2}을(를) 입력하기 시작하고 {3} 라이브 템플릿을 선택하세요.
go.handling.errors.with.templates.error.case=접미사 코드 완성은 코드를 작성할 때 역방향 캐럿 이동을 줄이는 데 도움이 됩니다. 이러한 템플릿을 사용하면 이미 입력한 표현식을 다른 표현식으로 변환할 수 있습니다. 접미사 완성에 관한 더 많은 강의는 {0} 섹션에서 찾을 수 있습니다.\n\
파일을 검사하는 동안 {1}에서 오류가 발생할 수 있습니다. 오류가 발생한 경우 스캐너에서 {2} 메서드를 호출하면 해당 오류가 반환됩니다.\n\
{2} 메서드에서 반환된 가능한 오류를 처리하려면 {3}을(를) 입력하고 {4}을(를) 눌러 접미사 템플릿을 적용하기만 하면 됩니다.

go.live.templates.with.types.lesson.name=라이브 템플릿 및 유형 사용
go.live.templates.with.types.struct.template=구조체는 이름이 지정된 필드가 포함된 유형입니다. 구조체는 데이터를 그룹화하여 레코드를 형성하는 데 유용합니다. 이 코드용으로 하나 만들어 보겠습니다.\n\
{0}을(를) 입력하기 시작하고 {1}을(를) 선택하세요. 구조체 이름으로 {2}을(를) 사용하세요. {3}을(를) 누르세요.
go.live.templates.with.types.type.fields={1} 구조체의 필드로 {0}을(를) 추가하세요.
go.live.templates.with.types.interface.template=Go에서 인터페이스는 메서드 시그너처 세트를 지정할 수 있는 사용자 지정 유형입니다. 하나 추가해 봅시다\!\n\
{0}을(를) 입력하고 {1}을(를) 선택하세요. 인터페이스 이름을 {2}(으)로 지정하고 {3}을(를) 누르세요.
go.live.templates.with.types.add.method={1} 인터페이스에 대한 메서드 시그니처로 {0}을(를) 추가하세요.
go.live.templates.with.types.complete.in.comment=주석은 프로그램 작동 방식과 거기에 내포된 사용자의 의도를 설명합니다. 주석에서 코드 완성을 사용하여 매개변수, 함수, 메서드의 이름을 완성할 수 있습니다.\n\
{0}을(를) 누르고 {1}을(를) 선택하여 {2} 함수 앞에 주석을 완성해보세요.
go.live.templates.with.types.add.second.return.value=현재 {0} 메서드는 문자열 매개변수만 반환합니다. 면적 값을 가진 {1} 반환 값을 추가해야 합니다. <ide/>은(는) 여러 반환 유형 주위에 소괄호를 자동으로 추가합니다.\n\
쉼표({2})를 입력하고 스페이스 버튼을 누른 다음, {3}을(를) 입력하세요.
go.live.templates.with.types.complete.return=캐럿이 함수 내에서 {0} 키워드 뒤에 있으면, 코드 완성은 오류가 발생해도 지역 변수와 제로 값을 제안합니다. 면적을 계산하는 {1} 메서드를 완성해 보겠습니다.\n\
{2}을(를) 입력하기 시작하고 {3}을(를) 선택하세요. 그런 다음 {4} 변수를 선택하고 {5}을(를) 누르세요. 사각형 영역을 계산하는 다음 수식을 입력하세요. {6}.
go.live.templates.with.types.fill.all.fields=마지막으로 사각형의 새 인스턴스를 만들고 {0} 및 {1}에 대한 값을 전달해 보겠습니다.\n\
{2}을(를) 입력하기 시작하고 자동 완성 목록에서 이 유형을 선택하세요. 그런 다음 {3} 액션을 선택하세요. {4} 및 {5}의 임의의 값을 입력하세요.

go.generate.missing.methods.lesson.name=누락된 메서드 생성
go.generate.missing.methods.task={0} 액션을 사용하면 메서드나 매개변수 이름이 인터페이스 정의에서 생략된 경우에도 누락된 메서드를 생성하고 매개변수 이름을 지정할 수 있습니다.\n\
{1}을(를) 누르고 {2} 유형을 선택하세요. {3} 창에서 {4}을(를) 입력하고 {5}을(를) 누르세요.

## Intentions Module

go.fixing.test.lesson.name=테스트 파일 수정
go.fixing.test.open.problems.toolwindow={0} 도구 창은 현재 파일의 경고 및 오류 목록을 표시하고 해당 문제에 대한 설명을 제시합니다.\n\
테스트 파일이 손상되었습니다. 무엇이 잘못되었는지 살펴봅시다.\n\
{1} 을(를) 눌러 {0} 도구 창을 여세요.
go.fixing.test.close.problems=주의해야 할 몇가지 문제가 있습니다. 일부 문제는 {0} 도구 창 자체에서 수정할 수 있습니다. 그러나 일부 문제는 에디터에서 특정 액션이 필요합니다. 에디터에서 모든 수정을 적용해 보겠습니다\!\n\
{2}을(를) 다시 눌러 {1} 도구 창을 닫으세요.
go.fixing.test.fix.string.conversion=이 {0} 변환은 필요한 10진수 문자열 표현이 아닌 유니코드 코드 포인트의 UTF-8 표현을 반환합니다.\n\
이 문제를 해결하기 위해 {2} 패키지의 {1} 메서드를 사용해 보겠습니다. {3}을(를) 누르고 {4}을(를) 선택하세요.
go.fixing.test.use.multicursors=다음 오류는 매우 명백하게도 익명 구조체에 닫는 중괄호와 쉼표가 없습니다. 그렇다고 각 줄에 반복해서 입력하고 싶지는 않습니다. 이럴 때 다중 커서가 도움이 될 수 있습니다.\n\
다중 커서를 트리거하려면 영역을 선택하고 {0}을(를) 누르세요. {1}을(를) 입력하여 구조체를 완성하세요.
go.fixing.test.fix.camelcase={1} 패키지에 관한 <a href\="{0}">Go 문서</a>에는 함수 이름을 낙타 표기법(예\: {2})으로 작성해야 한다고 나와 있습니다. 여기서 {3} 함수는 이 규칙을 준수하지 않습니다.\n\
함수 이름을 수정하려면 {4}을(를) 누르고 {5}을(를) 선택하세요.
go.fixing.test.negate=마지막은 실제로 오류가 아니라 코드를 단순화하는 간단한 리팩터링입니다. {0} 함수의 부정을 확인하세요. 여기서 무엇을 할 수 있는지 살펴보겠습니다.\n\
{1}을(를) 누르고 선택 항목을 {2} 노드로 이동한 다음, {3}을(를) 눌러 수행하려는 변경을 미리 확인하세요.\n\
보기 좋군요. {5}을(를) 눌러 {4} 제안을 적용해 봅시다.

go.quick.fix.refactorings.lesson.name=빠른 수정, 리팩터링, 외부 문서
go.quick.fix.refactorings.change.to.formatting={0} 함수는 디폴트 형식으로 변수 목록을 인쇄합니다. 한편 {1} 함수를 사용하면 출력 형식을 지정할 수 있습니다. 이 예시에서는 부동 소수점 숫자에 대해 형식화 동사({2})를 사용합니다. 하지만 {1} 대신 {0}을 사용합니다.\n\
이것을 수정해 봅시다\! {3}을(를) 누르고 {4}을(를) 선택하세요.
go.quick.fix.refactorings.create.variable=변수를 선언하는 방법에는 여러 가지가 있습니다. 변수가 선언되면 등호({0})를 사용하여 값을 대입할 수 있습니다.\n\
여기서는 {1} 변수는 선언되었지만 {2} 변수는 아직 선언되지 않았습니다.\n\
{3}을(를) 누르고 {4}을(를) 선택하세요. 이제 변수가 선언되었지만 초기화되지 않았습니다. 여기에 제로 값을 저장해 봅시다\! 이를 위해 제안 목록에서 {5}을(를) 선택하세요.
go.quick.fix.refactorings.rename=<ide/>에서 요소의 이름을 변경하면 해당 변경 내용을 적용할 수 있습니다. <ide/>은(는) 코드 요소의 이름을 변경하고 그에 따라 사용 위치를 업데이트합니다.\n\
{1} 함수 앞에 {0}을(를) 입력하여 함수 이름을 {2}(으)로 변경하세요. {3}을(를) 누르고 {4}을(를) 선택하세요.
go.quick.fix.refactorings.extract.method=메서드 추출 리팩터링을 사용하면 코드 조각을 취해 분리된 함수로 이동하고 이전 코드를 함수 호출로 바꿀수 있습니다. 모든 인쇄를 별도의 함수로 이동해 보겠습니다.\n\
{0}을(를) 누르세요.
go.quick.fix.refactorings.external.doc=외부 문서는 웹 브라우저에서 필요한 정보를 열어 주기 때문에 관련 심볼을 탐색하는 동시에 추가 참조를 위해 정보를 보관할 수 있습니다.\n\
이제 캐럿이 {0} 함수의 위치에 있습니다. {1}을(를) 눌러 {2}에서 {0}에 관한 문서를 여세요.

go.apply.fix={0} 을(를) 선택하고 {1} 을(를) 누르세요.

go.introduce.function.lesson.name=함수 유형에서 함수 생성
go.introduce.function.intro=<ide/>은(는) 호출에서 함수와 메서드를 생성할 수 있습니다. 이제 함수나 메서드가 누락된 경우 해당 유형에서 생성할 수도 있습니다.
go.introduce.function.invoke.intentions=캐럿이 함수 참조로 사용되는 {0} 식별자의 위치에 있는지 확인하세요. {1}을(를) 눌러 인텐션 액션을 호출하세요.
go.introduce.function.final.propose=그런 다음, 이제 필요에 따라 매개변수를 조정할 수 있습니다.

go.delete.parameter.names.lesson.name=매개변수 이름 삭제
go.delete.parameter.names.intro=<ide/>은(는) 사용되지 않는 매개변수의 유형이 메서드 사양을 구현하는 데 사용되는 경우 해당 매개변수의 이름만 강조 표시합니다. 이 경우 이 매개변수의 이름을 {0}(으)로 변경하거나 완전히 제거할 수 있습니다.
go.delete.parameter.names.invoke.intentions=인터페이스를 구현하는 메서드에 매개변수가 필요한 경우, 이러한 매개변수를 제거하는 것은 안전하지 않습니다. {0}을(를) 눌러 가능한 옵션 목록을 확인하세요.

go.delete.unused.parameters.lesson.name=사용되지 않는 매개변수 삭제
go.delete.unused.parameters.intro=<ide/>은(는) 메서드 또는 함수의 본문에서 사용되지 않는 시그니처의 매개변수를 탐지할 수 있습니다. 해당 매개변수가 사용되지 않는 경우 {0} 빠른 수정을 사용하여 삭제할 수 있습니다.
go.delete.unused.parameters.invoke.intentions=에디터에서 {0} 메서드를 확인하세요. 캐럿은 첫 번째 매개변수의 위치에 있습니다. {1}을(를) 눌러 인텐션 액션을 호출하세요.

go.fill.struct.fields.lesson.name=구조체 필드 입력
go.fill.struct.fields.intro=새 구조체를 생성할 때 해당 구조체의 필드 이름을 자동으로 생성할 수 있습니다. {0} 인텐션 액션에 관한 자료는 <a href\="{1}">GoLand 문서</a>에서 확인하세요.
go.fill.struct.fields.invoke.intentions=캐럿이 {0} 구조체의 중괄호 사이에 배치된 것을 확인하세요. {1}을(를) 눌러 인텐션 액션을 호출하세요.

go.implement.missing.methods.lesson.name=누락된 메서드 구현
go.implement.missing.methods.goto.next.error={0} 을(를) 눌러 파일 내 강조 표시된 다음 오류로 이동합니다.

go.delete.conversion.lesson.name=중복된 유형 변환
go.delete.conversion.intro=<strong>중복된 유형 변환</strong> 검사는 생략 가능한 중복된 유형 변환을 경고합니다(예\: 문자열 리터럴을 문자열로 변환하는 경우). 이 검사에 관한 자세한 내용은 <a href\="{0}">중복된 유형 변환</a>을 참조하세요.
go.delete.conversion.invoke.intentions=에디터에서 {0} 함수를 확인하세요. 캐럿은 {2}에서 {1} 유형으로의 형 변환의 위치에 있습니다. {3}을(를) 눌러 인텐션 액션을 호출하세요.

go.parameters.specification.lesson.name=매개변수에 대한 짧은 유형 및 긴 유형 사양
go.parameters.specification.intro=함수 또는 메서드 시그니처에 단일 유형의 여러 매개변수가 있는 경우 이러한 매개변수에 대해 짧은 유형 사양({0})을 사용하거나 각 매개변수에 대해 별도의 유형 사양({1})을 사용할 수 있습니다.
go.parameters.specification.invoke.intentions=캐럿이 {0} 메서드의 첫 번째 매개변수의 위치에 있는 것을 확인하세요. {1}을(를) 눌러 인텐션 액션을 호출하세요.
go.parameters.specification.notice.signature.combined=시그니처 유형이 결합된 방식을 확인하세요.
go.parameters.specification.notice.signature.expanded=시그니처가 초기 상태로 돌아갔습니다.
go.parameters.specification.press.again={0}을(를) 다시 누르세요.

## Refactorings

go.variadic.functions.lesson.name=가변 함수 처리
go.variadic.functions.unpack.slice=가변 함수는 {0} 등 다양한 수의 인수를 사용하여 호출할 수 있는 함수입니다.\n\
가변 함수는 가변 인수를 슬라이스로 처리합니다.\n\
이 예시에서 이 가변 함수는 {1}입니다.\n\
그러나 {2} 슬라이스를 그대로 가변 함수 {3}에 전달할 수는 없습니다. 이러한 경우 Go는 특수 구문을 제공합니다. 이는 바로 슬라이스 뒤의 줄임표({4})입니다.\n\
{5}을(를) 누르고 {6}을(를) 선택하여 오류를 수정하세요.
go.variadic.functions.inline=슬라이스를 슬라이스의 가변 인수로 바꿀수 있습니다. {0}을(를) 눌러 {1} 리팩터링을 호출하세요.
go.variadic.functions.introduce.variable={0} 리팩터링을 되돌리려면 {1} 리팩터링을 사용하세요. {2}을(를) 누르고 제안 목록에서 {3}을(를) 선택하세요.

go.improve.names.lesson.name=오류 변수의 이름 개선
go.improve.names.intro=<ide/>은(는) 오류({0}) 및 컨텍스트({1}) 변수의 가장 인기 있는 이름 변형을 제안합니다.
go.improve.names.introduce.variable=캐럿이 {0} 호출의 위치에 있는지 확인하세요. {1}을(를) 눌러 변수를 추출하세요.
go.improve.names.apply.fix=목록에서 전체 호출을 선택하고 {0}을(를) 누르세요. {1}은(는) 가장 일반적인 오류 이름이므로 <ide/>에서 변수 이름으로 제안했습니다.

go.extract.method.lesson.name=함수 및 메서드 추출
go.extract.method.task={0} 리팩터링을 사용하면 사용자 지정 가능한 매개변수 및 반환 유형을 가진 새 함수 또는 메서드로 코드를 캡슐화할 수 있습니다. 일부 코드 줄을 새 함수로 추출해 보겠습니다. {1}을(를) 누르세요.

go.extract.methods.with.returns.lesson.name=return이 포함된 메서드 추출
go.extract.methods.with.returns.intro={0} 리팩터링을 사용하면 코드 조각을 취해 분리된 메서드로 이동하고 이전 코드를 새 메서드 호출로 바꿀수 있습니다. 코드가 return 문에서 종료되면 그대로 추출됩니다. {0} 리팩터링에 관한 자세한 내용은 <a href\="{1}">함수 및 메서드 추출</a> 자료를 참조하세요.
go.extract.methods.with.returns.invoke.refactoring=추출할 수 있는 {0} 절 앞에 캐럿이 있는지 확인하세요. {1}을(를) 누르세요.
go.extract.methods.with.returns.complete.refactoring={0}을(를) 입력하고 {1}을(를) 누르세요.

go.extract.variable.lesson.name=변수 추출
go.extract.variable.task={0}을(를) 눌러 변수를 추출하고 문자열 표현식을 선택한 다음, 새 이름을 입력하고 {1}을(를) 눌러 리팩터링을 완료하세요.

go.inline.variable.lesson.name=추출된 변수 인라인화
go.inline.variable.task={0} 리팩터링과 반대로 {1}은(는) 중복 변수의 제거를 돕습니다. {2}을(를) 눌러 {3} 변수를 단일 사용 위치로 인라인화하세요.

go.rename.lesson.name=이름 변경
go.rename.invoke.intentions=심볼에 캐럿을 배치하고 {0} 리팩터링을 사용하여 이름을 변경할 수 있습니다. 코드의 {1} 필드에 캐럿을 배치하고 {2}을(를) 누르세요.
go.rename.apply.intention=이 필드의 새 이름을 입력하세요. 예를 들어 {0}을(를) 입력한 다음, {1}을(를) 눌러 결과를 저장합니다.
go.what.s.new.module.name=GoLand 2020.3의 새로운 기능
go.what.s.new.module.description=GoLand 2020.3(2020년 12월)의 새로운 기능입니다.
go.basic.editing.module.name=기본 편집
go.basic.editing.module.description=코드 편집에 도움이 될 수 있는 기본 액션입니다.
go.code.completion.module.name=코드 완성
go.code.completion.module.description=컨텍스트를 인식하는 코드 완성은 코딩 프로세스의 속도를 높이고 오타를 줄입니다.
go.debugging.module.name=디버그
go.debugging.module.description=디버그는 애플리케이션 내 문제를 찾고 해결하는 데 도움이 될 수 있습니다.
go.generating.code.module.name=코드 생성
go.generating.code.module.description=코드 청크를 생성하는 액션 및 템플릿입니다.
go.intention.actions.module.name=인텐션 액션
go.intention.actions.module.description=인텐션 액션은 코드에 대한 대체 변형은 물론, 탐지된 문제에 대한 해결 방법까지 제안할 수 있습니다.
go.refactorings.module.name=리팩터링
go.refactorings.module.description=리팩터링은 코드를 빈틈이나 중복 코드 없이 관리하기 쉽게 유지하는 데 도움이 됩니다.
