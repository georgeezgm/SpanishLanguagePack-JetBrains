# File Types
javascript.filetype.description=JavaScript
actionscript.filetype.description=ActionScript
typescript.filetype.description=TypeScript
typescript.jsx.filetype.description=TypeScript JSX
ecmascript6.filetype.description=ECMAScript 6
jsx.filetype.description=React JSX
flow.filetype.description=Flow JS
javascript.file=Archivo JavaScript
typescript.file=Archivo TypeScript
label.typescript.config=TypeScript 구성

# Languages
javascript.language.simple.name=JavaScript
typescript.language.simple.name=TypeScript

# Language terms
javascript.language.term.function=función
javascript.language.term.inner.function=función interna
javascript.language.term.method=método
javascript.language.term.constructor=constructor
javascript.language.term.class=clase
javascript.language.term.inner.class=clase interna
javascript.language.term.interface=interfaz
javascript.language.term.inner.interface=interfaz interna
javascript.language.term.enum=enumeración
javascript.language.term.type.alias=tipo alias
javascript.language.term.definition=definición
javascript.language.term.namespace=espacio de nombres
javascript.language.term.parameter=parámetro
javascript.language.term.property=propiedad
javascript.language.term.variable=variable
javascript.language.term.const=constante
javascript.language.term.const.field=campo constante
javascript.language.term.readonly.field=campo de solo lectura
javascript.language.term.local.variable=variable local
javascript.language.term.local.const=constante local
javascript.language.term.field=campo
javascript.language.term.tag=etiqueta
javascript.language.term.label=etiqueta
javascript.language.term.attribute=atributo
javascript.language.term.decorator=decorador
javascript.language.term.attribute.value=Valor de atributo
javascript.language.term.package=paquete
javascript.language.term.module=módulo
javascript.language.term.external.module.reference=referencia de módulo externo
javascript.language.term.import.specifier=especificador de importación
javascript.language.term.export.specifier=especificador de exportación
javascript.language.term.entity.name=nombre de la entidad
javascript.language.term.jsdoc.tag=etiqueta JSDoc
javascript.language.term.imported.default.binding=enlace predeterminado importado
javascript.language.term.exported.default.binding=enlace predeterminado exportado
javascript.language.term.namespace.import=importación de espacio de nombres
javascript.language.term.namespace.export=exportación de espacio de nombres
javascript.language.term.import.statement=declaración de importación
javascript.language.term.type.parameter=parámetro de tipo
javascript.language.term.destructuring.property=propiedad de desestructuración
javascript.language.term.default.export=exportación predeterminada
javascript.language.term.file=archivo
javascript.language.term.global=global
javascript.language.term.xml.tag=etiqueta xml

# Mensajes de error del analizador
javascript.parser.message.expected.expression=expresión esperada
javascript.parser.message.expected.xml.element=elemento xml esperado
javascript.parser.property.expected=propiedad esperada
javascript.parser.message.expected.lbrace=Se esperaba {
javascript.parser.message.expected.at=Se esperaba @
javascript.parser.message.expected.rbrace=Se esperaba }
javascript.parser.message.expected.identifier.string.literal.or.numeric.literal=identificador o literal de cadena o literal numérico esperado
javascript.parser.message.expected.colon=Se esperaba :
javascript.parser.message.expected.colon.or.comma=Se esperaba : o ,
javascript.parser.message.expected.semicolon=Se esperaba ;
javascript.parser.message.expected.lbrace.or.semicolon=Se esperaba { o ;
javascript.parser.message.expected.rbracket=Se esperaba ]
javascript.parser.message.expected.lparen=Se esperaba (
javascript.parser.message.expected.rparen=Se esperaba )
javascript.parser.message.expected.name=nombre esperado
javascript.parser.message.expected.comma.or.rparen=Se esperaba , o )
javascript.parser.message.expected.function.name=nombre de función esperado
javascript.parser.message.expected.formal.parameter.name=nombre de parámetro formal esperado
javascript.parser.message.expected.statement=declaración esperada
javascript.parser.message.expected.parameter.name=nombre del parámetro esperado
javascript.parser.message.expected.property.name=nombre de propiedad esperado
javascript.parser.message.expected.case.or.default=Se esperaba ''catch'' o ''default''
javascript.parser.message.expected.forloop.left.hand.side.expression.or.variable.declaration=''in'' 앞에 왼쪽 표현식 또는 변수 선언이 필요합니다
javascript.parser.message.expected.forloop.in.or.semicolon=''in'' 또는 ; 기대
javascript.parser.message.expected.while.keyword=''while''이 필요합니다
javascript.parser.message.expected.comma=, 예상
javascript.parser.message.expected.comma.or.rbrace=, 또는 } 기대
javascript.parser.message.expected.variable.name=변수 이름이 필요합니다
javascript.parser.message.expected.mult.or.lbrace=* 또는 { 기대
javascript.parser.message.missing.rbrace=} 누락
javascript.parser.message.missing.or_rbrace=|} 누락
javascript.parser.message.missing.backquote='' 누락
javascript.parser.message.missing.attribute.name=속성 이름 누락
javascript.parser.message.unexpected.end.of.file=예기치 않은 파일의 끝
javascript.parser.message.expected.type.name=유형 이름이 필요합니다
javascript.parser.message.unclosed.string.literal=닫히지 않은 문자열 리터럴
javascript.parser.message.unclosed.comment=닫히지 않은 주석
javascript.parser.message.are.not.supported.by.dialect={0}는 현재 JavaScript 버전에서 지원하지 않습니다
javascript.parser.message.expected.from=''from'' 기대
javascript.parser.message.expected.typename=유형 이름이 필요합니다
javascript.parser.message.expected.typename.or.*=* 또는 유형 이름 기대
javascript.parser.message.expected.name.or.lbrace=패키지 이름 또는 { 가 필요합니다
javascript.parser.message.expected.declaration=선언이 필요합니다
javascript.parser.message.expected.namespace=''namespace'' 기대
javascript.parser.message.expected.string.literal=문자열 리터럴이 필요합니다
javascript.parser.message.expected.xml=XML 컨텍스트 키워드가 필요합니다
javascript.parser.message.expected.equal=\= 가 필요합니다
javascript.parser.message.expected.identifier.lbrace.or.lbracket=식별자, { 또는 [ 가 필요합니다
javascript.parser.message.expected.eqgt=\=> 가 필요합니다
javascript.parser.message.expected.identifier=식별자가 필요합니다
javascript.parser.message.expected.instanceof=''instanceof'' 기대
javascript.parser.message.expected.in=''in''이 필요합니다
javascript.parser.message.expected.value=값이 필요합니다
javascript.parser.message.expected.identifier.or.value=식별자 또는 값이 필요합니다
javascript.parser.message.expected.as=''as'' 기대
javascript.parser.message.expected.identifier.string.literal.or.lbrace=식별자, 문자열 리터럴 또는 { 가 필요합니다
javascript.parser.message.expected.import.value=Import 바인딩 또는 지정자가 필요합니다
javascript.parser.message.expected.import.specifier=Import 지정자가 필요합니다
javascript.parser.message.expected.heredoc.closing.identifier=Heredoc 닫는 식별자가 필요합니다
javascript.parser.message.expected.type.member=유형 멤버가 필요합니다
javascript.parser.message.expected.tuple.comma.or.rbracket=, 또는 ] 기대
javascript.parser.message.expected.target=New의 메타 프로퍼티로 ''target''만 허용됩니다
javascript.parser.message.expected.meta=import의 메타 프로퍼티로 ''meta''만 허용됩니다
javascript.parser.message.expected.declare=''declare'' 기대
javascript.parser.message.expected.exports=''exports'' 기대
javascript.parser.message.expected.checks=''checks''가 필요합니다
javascript.parser.message.expected.type.keyword=''type'' 기대
javascript.parser.message.expected.type=유형이 필요합니다
javascript.parser.message.expected.question=? 예상
javascript.parser.message.expected.class=''class''가 필요합니다

# Mensajes de validación
javascript.validation.message.conflicting.definition.was.found.with.the.same.name=Se encontró una declaración heredada en conflicto {0} en el espacio de nombres {1}
javascript.validation.message.duplicate.declaration=Declaración duplicada
javascript.validation.message.duplicate.declaration.fix.remove=Eliminar tipo (s)
javascript.validation.message.redundant.type=El argumento de tipo explícito {0} se puede reemplazar con {1}
javascript.validation.message.redundant.type.remove=Se puede eliminar el argumento de tipo explícito {0}
javascript.validation.message.duplicate.export.declaration=La declaración de exportación entra en conflicto con la declaración exportada ''{0}''
javascript.validation.message.duplicate.default.export.declaration=Un módulo no puede tener varias exportaciones predeterminadas
javascript.validation.message.duplicate.default.export.in.module=Una exportación predeterminada solo se puede usar en un módulo de estilo ECMAScript
javascript.validation.message.duplicate.declaration.fix.text=Navegar a la declaración anterior ''{0}''
javascript.validation.message.duplicate.declaration.fix.text.no.name=Navegar a la declaración anterior
javascript.validation.message.redeclaration.of.block.scope=Las variables de ámbito de bloque no se pueden volver a declarar
javascript.validation.message.redeclaration.of.block.scope.in.scope.of.var=Las variables de ámbito de bloque no pueden compartir el nombre con variables o parámetros 'var' en el mismo ámbito de bloque
javascript.validation.message.redeclaration.of.var.in.scope.of.block.scope=las variables 'var' no pueden compartir el nombre con las variables de alcance de bloque dentro de su alcance de visibilidad
javascript.validation.message.assignment.to.const=Intento de asignar a constante o variable de solo lectura
javascript.validation.message.assignment.to.const.fix.replace=Reemplazar con let
javascript.validation.message.assignment.to.const.fix.remove.readonly=Eliminar modificador de solo lectura
javascript.validation.message.arguments.out.of.function=Usando el objeto de argumentos de función fuera de la función
javascript.validation.message.must.be.lvalue=Lado izquierdo no válido en {0}
javascript.validation.message.const.variable.without.initializer=variable constante sin inicializador. No será posible asignar un valor significativo más adelante.
javascript.validation.message.constructor.field.not.allowed=Las clases no pueden tener un campo no estático llamado 'constructor'
es6.validation.message.const.variable.without.initializer=no se permite la variable const sin inicializador
javascript.validation.message.continue.without.target=No se puede determinar el objetivo para 'continuar'
javascript.validation.message.break.without.target=No se puede determinar el objetivo para el 'descanso'
javascript.validation.message.continue.outside.loop='continuar' fuera de la declaración de bucle
javascript.validation.message.return.outside.function.definition='return' fuera de la definición de función
javascript.validation.message.duplicate.label=Etiqueta duplicada
javascript.validation.message.extend.multiple.classes=La clase no puede extender varias clases
javascript.validation.message.extend.final.class=No se puede extender la clase final ''{0}''
javascript.validation.message.identifier.not.allowed.in.strict.mode={0} no está permitido como identificador en modo estricto
javascript.validation.message.for.await.top.level=Se utilizó el nivel superior 'for await'.
javascript.validation.message.for.await.no.async.context='for await' no se puede usar fuera de una función asincrónica
typescript.validation.message.invalid.modifier.cannot.be.here=El modificador {0} no puede aparecer aquí
typescript.validation.message.duplicate.modifier=Modificador {0} ya visto
typescript.validation.message.duplicate.modifier2=Modificador de accesibilidad ya visto
typescript.validation.message.abstract.cannot.be.used=El modificador ''{0}'' no se puede usar con el modificador '' abstracto ''
typescript.validation.message.abstract.class.be.created=No se puede crear una instancia de la clase abstracta ''{0}''
typescript.validation.message.abstract.member.access.super=No se puede acceder al método abstracto ''{0}'' a través de una súper expresión.
typescript.validation.message.abstract.cannot.have.body=El método no puede tener una implementación porque está marcado como 'abstracto'
typescript.validation.message.abstract.overload=Las firmas de sobrecarga deben ser todas abstractas o no abstractas.
typescript.validation.message.constructor.cannot.be.abstract=El constructor no puede ser 'abstracto'
typescript.validation.message.function.implementation.missing=Falta la implementación de la función o no sigue inmediatamente a la declaración
typescript.validation.message.abstract.class.should.be=Los métodos abstractos solo pueden aparecer dentro de una clase abstracta
typescript.validation.module.reference.with.extension=La referencia del módulo externo no puede terminar con la extensión
typescript.validation.class.extend.not.constructor.type=El tipo ''{0}'' no es un tipo de función de constructor
typescript.validation.class.extend.no.type.arguments.type=Ningún constructor base tiene el número especificado de argumentos de tipo
typescript.validation.class.extend.many.constructors=Todos los constructores base deben tener el mismo tipo de retorno
typescript.validation.class.extend.cycled.definition=Definición de clase de círculo
typescript.validation.class.extend.constructor.return.not.class=El tipo de retorno del constructor base ''{0}'' no es un tipo de clase o interfaz.
javascript.validation.generators.yield.not.iterable=El tipo de expresión no tiene [Symbol.iterator] o [Symbol.asyncIterator] definido
javascript.validation.generators.yield.not.assignable.to.return=El tipo ''{1}'' no se puede asignar al tipo ''{0}''
typescript.validation.generators.incorrect.type.annotation=Un generador no puede tener una anotación de tipo ''{0}''
typescript.validation.async.incorrect.type.annotation=Una función asíncrona no puede tener una anotación de tipo ''{0}''
typescript.validation.generators.incorrect.type.annotation.iterable=El tipo ''{0}'' no se puede asignar al tipo ''{1}''.
typescript.validation.generators.overload=No se puede declarar una firma de sobrecarga como generador
typescript.validation.generators.ambient=Los generadores no están permitidos en un contexto ambiental
typescript.validation.generators.no.yield=El generador tiene implícitamente el tipo 'IterableIterator <any>' porque no da ningún valor. Considere proporcionar un tipo de devolución.
typescript.validation.generators.async.no.yield=El generador tiene implícitamente el tipo 'AsyncIterableIterator <cualquier>' porque no produce ningún valor. Considere proporcionar un tipo de devolución.
typescript.validation.cannot.find.best.common.type=El argumento de tipo no se puede inferir del uso


# Rodear de nombres
javascript.surround.with.do.while=do / while
javascript.surround.with.for=for
javascript.surround.with.if=if
javascript.surround.with.if.else=if / else
javascript.surround.with.if.cond=if (cond)
javascript.surround.with.if.else.cond=if (cond) / else
javascript.surround.with.parenthesis=(expr)
javascript.surround.with.not.parenthesis=\!(expr)
javascript.surround.with.cast=Type(expr)
javascript.surround.with.try.catch=try / catch
javascript.surround.with.try.finally=try / finally
javascript.surround.with.try.catch.finally=try / catch / finally
javascript.surround.with.while=while
javascript.surround.with.with=con
javascript.surround.with.function=función
javascript.surround.with.function.expression=expresión de función
javascript.surround.with.object.literal=literal de objeto

# Introduce variable
javascript.introduce.variable.title=Extraer variable
javascript.introduce.variable.title.local=Introducir variable local
javascript.introduce.variable.error.no.expression.selected=No se puede introducir la variable.\nLa selección no forma una expresión.
javascript.introduce.variable.error.expression.has.void.type=No se puede introducir la variable.\nEl tipo de expresión seleccionado es nulo.
javascript.introduce.variable.name.prompt=&Nombre:
javascript.introduce.variable.replace.all.occurrences=Reemplazar &todas las ocurrencias ({0} ocurrencias encontradas)
javascript.introduce.variable.invalid.name=Ingrese un nombre válido.
javascript.introduce.element.already.exists={0} con el mismo nombre ya existe en el alcance.
javascript.introduce.variable.arrow.function.parameter.referenced=No se puede introducir.\nLa selección contiene referencias a los parámetros de la función de flecha
javascript.introduce.variable.arrow.await.referenced=No se puede introducir.\nLa selección contiene expresiones de espera
javascript.introduce.variable.xml.embedded=No se puede introducir una variable en una expresión incrustada
javascript.introduce.incorrect.context=No se puede introducir la variable.\nLa selección contiene una referencia a 'esto'
javascript.introduce.field.title=Introducir campo
javascript.introduce.field.error.no.expression.selected=No se puede introducir el campo.\nLa selección no forma una expresión.
javascript.introduce.field.error.expression.has.void.type=No se puede introducir el campo.\nEl tipo de expresión seleccionado es nulo.
javascript.introduce.field.error.no.enclosing.class=No se puede introducir el campo.\nSin clase adjunta.
javascript.introduce.field.make.readonly=Crear y solo lectura
javascript.introduce.field.initialize.in.scope=&Inicializar en:
javascript.introduce.field.visibility=&Visibilidad:
javascript.introduce.field.keyboard.hint=Presiona {0} para los atajos de teclado
javascript.introduce.field.before.super.call=No se puede introducir el campo.\nNo se puede acceder a 'this' antes de las invocaciones 'super'.
javascript.introduce.field.current.method=현재 메서드
javascript.introduce.field.field.declaration=필드 선언
javascript.introduce.field.constructor=생성자
javascript.introduce.constant.title=Introducir constante
javascript.introduce.constant.error.no.expression.selected=No se puede introducir constante.\nLa selección no forma una expresión.
javascript.introduce.constant.error.expression.has.void.type=No se puede introducir constante.\nEl tipo de expresión seleccionado es nulo.
javascript.introduce.constant.error.not.constant.expression.selected=No se puede introducir constante.\nLa selección no es una expresión constante.
javascript.introduce.parameter.title=Extraer parámetro
javascript.introduce.parameter.error.no.expression.selected=No se puede introducir el parámetro.\nLa selección no forma una expresión.
javascript.introduce.parameter.error.no.containing.function=No se puede introducir el parámetro.\nNo se pudo encontrar la función contenedora para usar.
javascript.introduce.parameter.error.expression.has.void.type=No se puede introducir el parámetro.\nEl tipo de expresión seleccionado es nulo.
javascript.introduce.parameter.error.not.async.context=No se puede introducir el parámetro para la expresión que contiene 'await'.\nNo todos los usos están dentro de una función asincrónica
javascript.introduce.parameter.error.target.not.async=No se puede introducir el parámetro para la expresión que contiene 'await'.\nLa función de destino no es una función asincrónica
javascript.introduce.parameter.error.yield=No se puede introducir el parámetro para la expresión que contiene ''yield''.
javascript.introduce.parameter.generate.jsdoc=JSDoc 생성
javascript.introduce.parameter.optional.parameter=선택적 매개변수
javascript.introduce.throw.expressions.unsupported=No se puede invocar la refactorización.\nActualmente, las expresiones de lanzamiento no son compatibles con las refactorizaciones de 'Extracción'.
javascript.introduce.breaks.operator.precedence=No se puede invocar la refactorización.\nIntroducir cambiará la precedencia del operador en la expresión.
javascript.introduce.constant.in.es5=No se puede invocar la refactorización.\nNo se puede introducir una constante en el código ECMAScript 3 o ECMAScript 5.
javascript.introduce.in.embedded.expression=No se puede invocar la refactorización.\nNo se puede introducir en una expresión incrustada
javascript.introduce.variable.make.constant=상수 생성
list.item.class.field=클래스 필드
list.item.global.or.module.constant=전역 또는 모듈 상수
list.item.local.constant=지역 상수

# Categorías destacadas
javascript.keyword=palabra clave
javascript.string=Cadena
javascript.number=Número
javascript.linecomment=comentario de línea
javascript.doccomment=Comentario del documento
javascript.blockcomment=Bloquear comentario
javascript.regexp=Expresión regular
javascript.operation=Operación
javascript.parens=Paréntesis
javascript.brackets=corchetes
javascript.braces=llaves
javascript.semicolon=punto y coma
javascript.badcharacter=carácter incorrecto
javascript.docmarkup=Marcado de documentación
javascript.doctag=Etiqueta de documentación
javascript.valid.string.escape=Cadena de escape válida
javascript.invalid.string.escape=Cadena de escape no válida
javascript.comma=coma
javascript.dot=Punto

# Errores con intenciones
javascript.unresolved.function.name.message=Función o método no resuelto {0}() #loc
javascript.unresolved.variable.name.message=Variable no resuelta {0} #loc
javascript.unresolved.variable.null.qualifier.message=El calificador de ''{0}'' es posiblemente nulo #loc
javascript.unresolved.variable.undefined.qualifier.message=El calificador de ''{0}'' posiblemente no esté definido #loc
javascript.unresolved.variable.null.or.undefined.qualifier.message=El calificador de ''{0}'' es posiblemente nulo o indefinido #loc
javascript.unresolved.type.name.message=Tipo no resuelto {0} #loc
javascript.unresolved.circle.definition=Definición de círculo de importación
javascript.missing.read.property=Propiedad de lectura no resuelta #loc
javascript.missing.write.property=Propiedad de escritura no resuelta #loc
javascript.unresolved.variable.or.type.name.message=Variable sin resolver o tipo {0} #loc
javascript.unresolved.variable.or.type.name.message2=Variable no resuelta o tipo {0}
javascript.unresolved.symbol.message=Símbolo no resuelto
javascript.unresolved.file=Archivo {0} no encontrado
javascript.unknown.metadata.tag=Etiqueta de metadatos desconocida
javascript.unknown.metadata.attribute=Atributo de metadatos desconocido
javascript.undeclared.variable.name.message=Variable {0} declarada implícitamente #loc
javascript.create.function.intention.name=Crear función ''{0}''
javascript.create.variable.intention.name=Crear variable ''{0}''
javascript.create.constant.intention.name=Crear constante ''{0}''
javascript.declare.variable.intention.name=Insertar declaración var para ''{0}''
javascript.declare.variable.intention.family.name=Insertar declaración var
javascript.declare.variable.in.previous.var.statement.intention.name=Inserte la declaración var para ''{0}'' en la declaración var anterior
javascript.declare.variable.in.previous.var.statement.intention.family=Insertar declaración var en la declaración var anterior
javascript.create.field.intention.name=Crear campo ''{0}''
javascript.create.constant.field.intention.name=Crear campo constante ''{0}''
javascript.create.method.intention.name=Crear método ''{0}''
javascript.create.property.intention.name=Crear propiedad ''{0}''
javascript.create.function.property.intention.name=Crear propiedad de función ''{0}''
javascript.create.constructor.intention.name=Crear constructor en la clase ''{0}''
javascript.create.get.property.intention.name=''get'' 프로퍼티 ''{0}'' 생성
javascript.create.set.property.intention.name=''set'' 프로퍼티 ''{0}'' 생성
javascript.create.function.intention.family=JavaScript 함수 또는 메서드 생성
javascript.create.variable.intention.family=JavaScript 변수 또는 프로퍼티 생성
javascript.intention.create.getter.setter=''{0}''의 getter 및 setter 생성
javascript.intention.create.getter.setter.desc=getter 및 setter 생성
javascript.intention.create.setter=''{0}''의 setter 생성
javascript.intention.create.setter.desc=setter 생성
javascript.intention.create.getter=''{0}''의 getter 생성
javascript.intention.create.getter.desc=getter 생성
create.mobile.view=뷰 ''{0}'' 생성
javascript.rename.reference.intention.name=참조 이름을 변경합니다.
typescript.rename.javascript.references=JavaScript 파일에서 검색(&J)
typescript.rename.dynamic.references=동적 참조 검색(&D)
js.usage.type.string=문자열 리터럴에서 사용 위치
js.usage.type.call=함수 호출에서 사용 위치
js.anonymous.to.named.function=익명 함수를 명명된 함수로 변환
js.convert.to.named.function=명명된 함수로 변환
js.convert.to.named.function.to.class.method=클래스 메서드로 변환
js.convert.to.arrow.function=화살표 함수로 변환
js.add.braces.to.arrow.function=화살표 함수에 중괄호 추가
js.inspection.function.expression.is.used.instead.of.arrow=화살표 함수 대신 함수 표현식이 사용됩니다
js.arrow.function.braces.can.be.removed.key=화살표 함수 본문 주변의 중괄호를 제거할 수 있습니다
js.arrow.function.braces.can.be.removed.problem.description=화살표 함수 본문 주변의 중괄호를 제거할 수 있습니다.
js.arrow.function.braces.can.be.removed.fix.family.name=화살표 함수 본문 주변 중괄호 제거
js.convert.to.anonymous.function.family.name=화살표 함수를 익명 함수로 변환
js.convert.to.anonymous.function=익명 함수로 변환
js.named.to.anonymous.family.name=함수 표현식으로 변환
js.named.to.function.expression.text = 함수 표현식을 담은 변수로 변환
js.named.to.function.hoisting.conflict.text=함수는 선언 전에 사용됩니다. 변수로 변환 한 후 사용 위치가 끊어집니다
js.named.to.arrow.text = 화살표 함수를 담은 {0}(으)로 변환
js.split.into.multiple.declarations=여러 선언으로 분할
js.remove.digit.separators=숫자 구분 기호 제거
js.copy.qualified.to.clipboard=클립보드에 정규화된 이름 복사
js.iterate=for..of로 반복
js.iterate.async=await..of로 반복
js.separate.digits=숫자 분리
js.separate.nibbles=니블 분리
js.separate.bytes=바이트 분리
js.separate.words=16비트 단어 분리
js.separate.thousands=천 단위 분리
js.separate.thousands.in.integer.part=정수 부분에서 천 단위 분리
js.split.declarations=선언 분할
js.replace.string.with.es6.template=템플릿 문자열로 바꾸기
js.replace.string.concatenation.with.es6.template.inspection.name=문자열 템플릿 대신 문자열 연결이 사용됩니다
js.replace.string.concatenation.with.es6.template.fix.text=템플릿 문자열로 바꾸기
js.string.template.line.separators.visible=가시선 구분 기호로 변환
js.string.template.line.separators.multispan=여러 줄 문자열 템플릿으로 변환
js.string.template.line.separators.visible.family.name=가시선 구분 기호를 사용하도록 템플릿 문자열 변환
js.string.template.line.separators.multispan.family.name=여러 줄 문자열 템플릿으로 변환
js.convert.var.to.let.text=let으로 변환
js.convert.var.to.const.text=const로 변환
js.convert.var.to.let.or.const=let/const로 변환
js.convert.var.to.let.or.const.family.name=var을 let/const로 변환
js.convert.var.to.let.or.const.inspection.text=''let'' 또는 ''const'' 대신 ''var''이 사용되었습니다
js.convert.let.to.const.inspection.text=''const''를 사용할 수 있는 곳에서 ''let''이 사용됩니다
js.convert.var.to.let.or.const.inspection.conservative.option=모든 작업 수정을 통해 var을 보수적으로 변환
js.convert.var.to.let.or.const.inspection.conservative.option.description=선언은 변수를 처음 사용하기 전에 함수의 맨 위로 이동할 수 있습니다.\n모든 작업 수정을 사용할 때 이 동작을 비활성화하려면 ''var을 보수적으로 변환'' 옵션을 확인하세요.
js.convert.require.into.es6.import.text=require()를 import로 변환
js.convert.require.into.es6.import.family.name=require()를 import로 변환
js.convert.require.into.es6.import.inspection.text=''import'' 대신 ''require()''이 사용됩니다
js.convert.require.into.es6.import.inspection.withConditional.option=모든 작업 수정을 통해 내부 범위 안에서 require() 변환
js.convert.require.into.es6.import.inspection.withConditional.option.description=내부 범위 안에서 require() 변환 (예\: ''if'' 문 또는 내부 함수)
js.convert.module.exports.into.es6.export.text=export로 변환
js.convert.module.exports.into.es6.export.family.name=export로 변환
js.convert.module.exports.into.es6.export.inspection.text=\ ''export'' 대신 ''module.export''가 사용됩니다
js.convert.for.in.to.for.of.text=''for..in''을 ''for..of''로 변환
js.convert.for.in.to.for.of.family.name=''for..in''을 ''for..of''로 변환
js.convert.for.in.to.for.of.inspection.text=''for..of'' 대신 ''for..in''이 사용됩니다
js.convert.indexed.for.to.for.of.text=색인 생성된 ''for''을 ''for..of''로 변환
js.convert.indexed.for.to.for.of.family.name=색인 생성된 ''for''을 ''for..of''로 변환
js.convert.indexed.for.to.for.of.inspection.text=색인 생성된 ''for'' 루프를 ''for..of''로 바꿀 수 있습니다
js.convert.for.each.to.for.of.intention.family=''forEach''를 ''for..of'' 루프로 바꾸기
js.convert.for.each.to.indexed.intention.family=''forEach''를 색인 생성된 ''for'' 루프로 바꾸기
js.convert.for.of.to.indexed.intention.family=''for..of''를 색인 생성된 ''for'' 루프로 바꾸기
js.convert.map.to.for.of.intention.family=''map'' 배열 호출을 ''for..of'' 루프로 바꾸기
js.convert.indexed.for.to.foreach.intention.family=색인 생성된 ''for''을 ''forEach'' 배열 호출로 변환
js.add.then.fix=''.then()'' 추가
js.quote.unquote.intention.plural={0} 프로퍼티 이름
js.quote.unquote.intention.singular={0} 프로퍼티 이름
js.quote.unquote.intention.quote=따옴표
js.quote.unquote.intention.unquote=따옴표 해제
js.property.to.indexer.intention=인덱서 액세스로 바꾸기
js.indexer.to.property.intention=프로퍼티 액세스로 바꾸기
js.join.vars.intention=후속 변수 선언 결합
js.infer.parameter.types.intention=사용 위치에서 매개변수 유형 추론
js.infer.parameter.types.intention.jsdoc=사용 위치에서 JSDoc 매개변수 유형 추론
js.infer.parameter.types.intention.failure.title=유형을 추론할 수 없습니다
js.infer.parameter.types.intention.progress.text=유형 추론
js.infer.parameter.types.intention.failure.text=사용 위치에서 유형을 추론할 수 없습니다
js.infer.parameter.types.intention.failure.readonly.text=사용 위치에서 유형을 추론할 수 없습니다\: 파일이 읽기 전용입니다

# Move module members
es6.move.module.members.refactoring.name=모듈 멤버 이동
es6.move.module.members.table.title=이동할 멤버
es6.move.module.members.refactoring.create.file=파일 생성
es6.move.module.members.refactoring.file.does.not.exist=파일 {0}이(가) 없습니다
es6.move.module.members.refactoring.create.file.message=파일 {0} 이(가) 없습니다.\n생성하시겠어요?
es6.move.module.members.refactoring.dialog.error.no.script.tag=대상 파일에 스크립트 태그가 없습니다
es6.move.module.members.refactoring.dialog.error.invalid.file.name=대상 파일 이름이 이 운영 체제에서 유효하지 않습니다
es6.move.module.members.refactoring.dialog.error.no.selected.items=선택된 이동할 멤버가 없습니다
es6.move.module.members.refactoring.dialog.error.incorrect.module=대상 모듈이 올바르지 않습니다
es6.move.module.members.refactoring.dialog.error.modules.same=소스와 대상 모듈은 달라야 합니다
es6.move.module.members.refactoring.dialog.move.member.to=멤버 이동
es6.move.module.members.refactoring.dialog.field.from=From\:
es6.move.module.members.refactoring.dialog.field.to=To\:
es6.move.module.members.references.unresolved.import.message=선택한 {0} 이(가) 해결되지 않은 import {1} 을(를) 참조합니다
es6.move.module.members.references.local.message=선택한 {0} 이(가) 내보내기되지 않은 {1} 을(를) 참조합니다
es6.move.module.members.has.local.usage.message=내보내기 하지 않은 {0} 이(가) 파일 {1}에서 사용됩니다
es6.move.module.members.non.es6.module.usage={0} 은(는) ES6 모듈이 아닌 파일 {1}에서 사용됩니다
es6.move.module.members.destination.not.es6=대상 파일 {0} 은(는) ES6 모듈이 아닙니다
es6.move.module.members.cannot.detect.js.language=대상 파일이 JS 파일이 아닙니다.
es6.move.module.members.destination.contains.default.export=대상 모듈이 디폴트 내보내기를 포함합니다
es6.move.module.members.destination.does.not.support.jsx={0} 은(는) JSX 태그를 포함하지만 대상 언어는 이를 지원하지 않습니다
es6.move.module.members.syntax.errors=대상 언어가 소스와 다르므로 {0} 을(를) 이동하면 구문 오류가 발생합니다
es6.move.module.members.incompatible.language=대상 모듈에 호환되지 않는 언어가 있습니다
dialog.title.move.members=멤버 이동

js.pull.up.will.be.made.abstract=추상이 아닌 {0} 이(가) 추상화될 것입니다
es6.extract.super.destination.label=대상 파일(&D)\:
es6.extract.super.members.in.interface=새 인터페이스의 멤버
es6.extract.super.members.in.superclass=새로운 상위 클래스의 멤버
es6.extract.super.overload.declaration.without.implementation.conflict=구현하지 않은 오버로드 선언 {0} 은(는) 클래스에서 허용되지 않습니다
es6.extract.super.different.name.expected=다른 이름이 필요합니다

# Examen de la unidad
js.testing.inspection.group.name=Prueba unitaria
js.testing.highlight.line=Resaltar la línea de falla en el código de prueba
rc.environmentVariables.label=&Variables de entorno:
rc.testRunScope.all=&Todas las pruebas
rc.testRunScope.testFile=Arc&hivo de prueba
rc.testRunScope.suite=&Suite
rc.testRunScope.test=&Prueba
rc.nodeOptions.label=Nodo y opciones:
rc.workingDirectory.label=&directorio de trabajo:
rc.workingDirectory.browseDialogTitle=Seleccionar directorio de trabajo
rc.testOrSuiteScope.suite.title=Editar nombre de suite
rc.testOrSuiteScope.suite.label=Nombre de la suite:
rc.testOrSuiteScope.test.title=Editar nombre de prueba
rc.testOrSuiteScope.test.label=Nombre de la prueba:
rc.testOrSuiteScope.emptyTest=Nombre de prueba vacío
rc.testRunScope.testFile.label=Archivo de prueba:
rc.testRunScope.testFile.browseTitle=Seleccionar archivo de prueba

# Prueba unitaria: broma
jest.snapshot.update.rc.name=Actualizar instantánea para {0}
jest.snapshot.update.single.test.text=<link>Haga clic para actualizar la instantánea </link>para {0}
jest.snapshot.update.test.file.text=<link>Haga clic para actualizar las instantáneas fallidas </link>en {0}
jest.snapshot.update.all.tests.text=<link>Haga clic para actualizar todas las instantáneas fallidas </link>
jest.rc.configurationFile.label=&Archivo de configuración:
jest.rc.configurationFile.title=Seleccionar archivo de configuración de Jest
jest.rc.jestPackageField.label=Paquete &Jest:
jest.rc.jestOptions.label=Opciones de broma:
jest.rc.jestOptions.emptyText=Opciones de CLI, p. ej. --watch o --env=jsdom

# Prueba unitaria: transportador
protractor.rc.configurationFile.label=&Archivo de configuración:
protractor.rc.configurationFile.title=Seleccione el archivo de configuración del transportador
protractor.rc.protractorPackage.label=Paquete &Transportador:
protractor.rc.protractorOptions.label=Transportador y opciones:
protractor.rc.protractorOptions.emptyText=Opciones de CLI, p. ej. --browser o --rootElement

# Node.js
node.js.inspection.group.name=Node.js
node.js.missing.require=Falta la declaración require()
node.js.unresolved.api=API de Node.js sin resolver
node.js.invalid.node=El proyecto usó una ruta no válida a Node.js.<br>Se actualizó para usar Node.js de {0}.
node.js.configure=Configurar Node.js
node.js.downloading=Descargando Node.js {0}
node.js.interpreters=Intérpretes de Node.js
node.js.set.project.interpreter.action=Establecer como intérprete del proyecto
node.js.add.interpreter.action=Agregar {0}...
notification.title.cannot.enable.node.js.coding.assistance=Node.js 코딩 지원을 활성화할 수 없음
notification.title.cannot.download.types.node=@types/node를 다운로드할 수 없음
status.text.add.interpreter.with={0}(으)로 인터프리터 추가
status.text.no.interpreters.added=추가할 인터프리터가 없습니다
popup.content.cannot.edit.selected.node.js.interpreter=선택한 Node.js 인터프리터를 편집할 수 없습니다
node.no.interpreter=인터프리터가 없습니다
node.interpreter.not.found={0}(을)를 찾을 수 없습니다
no.executable.found.in.path={0, choice, 0\#%PATH%|1\#$PATH}에서 실행 파일을 찾을 수 없습니다
merged.process.output.text={0}{2, choice, 0\#\n\n표준 오류\:\n{1}|1\#}{4, choice, 0\#\n\n표준 출력\:\n{3}|1\#}\n\n{5}
node.interpreter.download=Node.js 다운로드
node.interpreter.project_node.reference.name=Proyecto
node.interpreter.node_from_path.reference.name=노드

# Inspecciones
js.inspection.group.name=General
typescript.inspection.group.name=TypeScript
js.inspection.bitwise.group.name=Problemas de operación bit a bit
js.code.style.issues.group.name=Problemas de estilo de código
js.probable.bugs.group.name=Errores probables
js.annotator.inspection.name=Errores generales de JavaScript
js.inspection.convert.to.es6.group.name=ayudas de migración de ECMAScript 6
js.inspection.switch.group.name=Problemas con la declaración de cambio
js.inspection.async.group.name=Código asíncrono y promesas
js.function.metrics.group.name=Métricas de función
js.validity.issues.group.name=Problemas de validez
js.imports.dependencies.group.name=Importaciones y dependencias
js.unused.symbols.group.name=Símbolos no utilizados
js.unwanted.symbols.group.name=Construcciones de código potencialmente indeseables
js.assignment.issues.group.name=Problemas de asignación
js.potentially.invalid.usage.of.this.inspection.name=Referencia potencialmente inválida a 'esto' del cierre
js.potentially.invalid.usage.of.class.this.inspection.name=Referencia potencialmente inválida a 'esto' de una clase desde el cierre
js.potentially.invalid.target.of.indexed.property.access.inspection.name=Objetivo posiblemente incorrecto del acceso a la propiedad indexada
javascript.potentially.invalid.usage.of.this=Uso potencialmente no válido de esto
javascript.potentially.invalid.usage.of.class.this=Acceso de referencia potencialmente no válido a un campo de clase a través de 'this'. de una función anidada
javascript.potentially.invalid.target.of.indexed.property.access=Destino potencialmente no válido del acceso a la propiedad indexada
js.unfiltered.for.in.loop.inspection.name=Sin filtrar para..en bucle
javascript.unfiltered.for.in.loop=Posible iteración sobre miembros inesperados (personalizados/heredados), probablemente falte la verificación hasOwnProperty
js.unfiltered.for.in.loop.skip.primitives=Omitir iteraciones sobre referencia con inicializador de matriz o objeto
js.unfiltered.for.in.loop.skip.primitives.tooltip=Habilítelo cuando Object.prototype y Array.prototype no estén modificados
js.referencing.mutable.variable.from.closure.inspection.name=Haciendo referencia a la variable mutable del cierre
javascript.mutable.variable.accessible.from.closure=Se puede acceder a la variable mutable desde el cierre
js.unresolved.variable.inspection.name=Variable JavaScript no resuelta
ts.unresolved.variable.inspection.name=해결되지 않은 TypeScript 변수
js.undeclared.variable.inspection.name=Variable JavaScript global declarada implícitamente
js.duplicate.declaration.inspection.name=Declaración de JavaScript duplicada
# WI-11522 solo la primera palabra debe comenzar con una letra mayúscula
js.linters.inspection.group.name=Herramientas de calidad del código
js.linters.detect.automatically.caption=Detectar el paquete y el archivo de configuración del package.json más cercano
js.unused.local.symbol.inspection.name=Símbolo local no utilizado
js.unused.es6.import.inspection.name=Importaciones de ES6 / TypeScript no utilizadas
js.unused.assignment.inspection.name=Tarea no utilizada
js.join.declaration.assignment.inspection.name=La declaración de variable se puede fusionar con la primera asignación a la variable
js.join.declaration.assignment.inspection.fix=Declaración y asignación de variables de unión
js.unused.global.symbol.inspection.name=Símbolo global no utilizado
js.missing.await.symbol.inspection.name=Espera perdida para una llamada de función asíncrona
js.missing.await.symbol.inspection.for.returns=Utilice siempre 'await' para las llamadas a funciones asíncronas para evitar errores y ayudar a los seguimientos de pila asíncronos de V8
js.missing.await.symbol.inspection.for.generator.name=Los generadores asincrónicos deben iterarse utilizando el bucle for-await
jsx.missing.namespace.inspection.name=Falta la importación de React con JSX
jsx.missing.namespace.inspection.text=JSX se usa sin importar {0}
tsx.missing.name.quick.fix.name="Agregar {0} declaración de importación
js.destructuring.merge.inspection=Las propiedades de desestructuración con la misma clave se pueden fusionar
js.destructuring.merge.inspection.text=Se pueden fusionar propiedades de desestructuración con claves idénticas
js.destructuring.merge.inspection.fix=Fusionar propiedades de desestructuración
js.nested.template.literal.inspection=Anidación redundante en la plantilla literal
js.nested.template.literal.fix=Literal anidado en línea
js.redundant.await.inspection=Expresión redundante 'en espera'
js.await.promise.resolve.inspection='await Promise.resolve()' redundante
js.await.promise.reject.inspection=Redundante 'await Promise. reject()'
js.await.promise.double.await.inspection='espera espera' redundante
js.await.promise.return.await.inspection='Espera de retorno' redundante
js.await.promise.trivial.await.inspection='espera' redundante para un tipo que no es de promesa
js.await.promise.resolve.fix=Reemplazar con ''{0}''
js.top.level.await.expression.inspection= Expresión 'await' de nivel superior
js.top.level.await.expression.inspection.description= Se utilizó la expresión 'await' de nivel superior.
js.possibly.async.function.inspection=Posiblemente función asincrónica
js.await.in.synchronous.function=El operador 'await' solo se puede usar en funciones 'async'
js.possibly.async.function.quick.fix=Hacer que la función {0} sea asincrónica
js.possibly.async.function.quick.fix.family.name=Hacer la función asincrónica
js.property.can.be.replaced.with.shorthand=La propiedad se puede reemplazar con taquigrafía
js.property.can.be.replaced.with.shorthand.method=La propiedad se puede reemplazar con un método abreviado
js.replace.with.shorthand.property.quick.fix=Reemplazar con propiedad abreviada
js.replace.with.shorthand.method.quick.fix=Reemplazado por abreviatura
js.expand.shorthand.property.quick.fix=Expandir propiedad de taquigrafía
js.unresolved.function.inspection.name=Función de JavaScript no resuelta
ts.unresolved.function.inspection.name=해결되지 않은 TypeScript 함수
js.unresolved.react.component.name=해결되지 않은 React 구성 요소
js.deprecated.symbols.inspection.name=Símbolo de JavaScript obsoleto
js.suspicious.eq.plus.inspection.name=Asignación sospechosa '=+'
js.suspicious.eq.plus.inspection.desc=Sospechoso '=+' asignación: posiblemente mal escrito '+ ='
js.suspicious.eq.plus.fix.name=Reemplazar con '+ ='
js.suspicious.name.combination.inspection.name=Combinación de nombres sospechosos
js.bitwise.operator.usage.name=Uso del operador bit a bit
js.bitwise.operator.usage.popup=Operador bit a bit utilizado
js.bitwise.operator.usage.quickfix=Reemplazar con {0}
js.potentially.invalid.constructor.usages.inspection.name=Uso de constructor potencialmente no válido
js.mismatched.update.collection.inspection.name=Consulta no coincidente y actualización de la colección
js.mismatched.update.collection.update.method.names=Actualizar nombres de métodos
js.closure.compiler.syntax.inspection.name=Sintaxis del compilador de cierre
js.closure.compiler.syntax.implements.not.interface={0} no está anotado con @interface
js.closure.compiler.syntax.cyclic.inheritance=Herencia cíclica que involucra a {0}
js.closure.compiler.syntax.empty.type=El tipo vacío no está disponible
js.closure.compiler.syntax.invalid.type=Sintaxis de tipo no válida
collection.updated.but.not.queried=El contenido de la colección <code>#ref </code>se actualiza, pero nunca se consulta
collection.queried.but.not.update=Se consulta el contenido de la colección <code>#ref </code>, pero nunca se actualiza
javascript.constructor.with.lower.case.name.used.message=Los nombres de los constructores suelen empezar con una letra mayúscula. ¿Un error?
interface.function.declaration.should.have.no.body=La declaración de funciones de interfaz no debe tener cuerpo
javascript.ambient.declaration.should.have.no.body=La declaración ambiental no debe tener cuerpo
javascript.ambient.declaration.should.have.no.initializer=La declaración ambiental no debe tener inicializador
javascript.ambient.declaration.const.should.be.primitive=Un inicializador 'const' en contexto ambiental debe ser una referencia de enumeración literal o literal primitiva
javascript.deprecated.symbol.used.name.message=Símbolo obsoleto usado, consulte los documentos para una mejor alternativa #loc
javascript.deprecated.symbol.used.name.message2=Dado que el símbolo de la versión {0} está marcado como obsoleto, use {1} como reemplazo #loc
js.unused.symbol=사용하지 않는 {0} \#ref
js.unused.symbol.full=사용하지 않는 {0}
js.unused.symbol.remove=사용하지 않는 {0} 제거
js.suspicious.name.assignment=''{0}''을(를) {1}''에 할당할 수 없습니다
js.suspicious.name.parameter=''{0}''을(를) 매개 변수 ''{1}''로 전달할 수 없습니다
js.suspicious.name.return=''{0}''을(를) 메서드 ''{1}''에서 반환할 수 없습니다
js.constructor.cant.have.return.type=생성자는 반환 유형을 가질 수 없습니다
invalid.identifier.value.0=유효하지 않은 식별자\: ''{0}''
js.suspicious.bind.with.arrow.function=의심스러운 화살표 함수와 ''bind'' 사용 위치
javascript.change.signature.invalid.parameter.declaration=유효하지 않은 매개변수\: ''{0}''
javascript.change.signature.invalid.function.name.0=유효하지 않은 함수 이름\: ''{0}''
javascript.validation.generators.yield.not.in.generator=''yield'' 표현식은 생성기 본문에서만 허용됩니다.
javascript.validation.new.target.not.in.function=메타 프로퍼티 ''new.target''은 함수 선언, 함수 표현식 또는 생성자의 본문에만 허용됩니다
javascript.validation.message.this.referenced.from.static.context=정적 컨텍스트에서 참조된 ''this''
javascript.validation.message.super.referenced.without.class.instance.context=클래스 인스턴스 컨텍스트 없이 참조된 ''super''
javascript.validation.message.super.referenced.from.static.context=정적 컨텍스트에서 참조된 ''super''
javascript.validation.message.function.override.without.override.modifier=메서드가 키워드를 재정의하지 않고 상위 클래스 {0}의 메서드를 재정의합니다
javascript.validation.multiple.var.in.for.loop=''{0}'' 루프에 단일 변수만 허용됩니다
javascript.validation.initialized.var.in.for.loop=변수 이니셜라이저는 ''{0}'' 루프에서 허용되지 않습니다
javascript.fix.add.override.modifier=재정의 제어자 추가
javascript.fix.property.spelling.family=프로퍼티 이름에 가능한 오타 수정
javascript.fix.property.spelling.text=''{0}'' 맞춤법 조정
js.code.style.tab.name=JavaScript
js.code.style.file.name.relaxed.style=Reutilizar caso del archivo actual
js.code.style.file.name.camel.style=Funda de camello (appComponent)
js.code.style.file.name.pascal.style=Caso Pascal (AppComponent)
js.code.style.file.name.snake.style=Estuche de serpiente (componente_aplicación)
js.code.style.file.name.lisp.style=Caso de Dash (componente de la aplicación)
js.code.style.file.name.mixed.style=Caso de Dash con sufijo (my-app.component)
es6.code.style.path.mapping.always=Siempre
es6.code.style.path.mapping.never=Nunca
es6.code.style.path.mapping.different.paths=Solo en archivos fuera de las rutas especificadas
typescript.code.style.tab.name=TypeScript
jsx.code.style.attribute.default.value=Agregar a la propiedad JSX:
jsx.code.style.attribute.default.value.braces=Tirantes
jsx.code.style.attribute.default.value.quotes=Cotizaciones
jsx.code.style.attribute.default.value.none=Ninguno
jsx.code.style.attribute.default.value.typebased=Basado en el tipo
javascript.formatting.options.panel.naming.conventions=Convenciones de nomenclatura
javascript.formatting.options.panel.comments=Comentarios
js.convert.parameters.to.object.intention.name=Convertir parámetros en objeto
js.convert.parameters.to.object.with.interface.intention.name=Convierta los parámetros en un objeto e introduzca la interfaz
js.convert.parameters.to.object.non.call.usage.will.not.be.updated=El uso que no sea de llamada no se actualizará
js.convert.parameters.to.object.usage.will.not.be.updated.for.contextual.type=El método implementa un método de interfaz. El método base no se actualizará
js.convert.parameters.to.object.usage.will.not.be.updated.for.spread=La llamada con argumentos extendidos no terminales no se actualizará
js.undefined.property.assignment.inspection.name=Asignación de propiedad no definida
js.undefined.property.assignment.inspection.message=La propiedad {0} no está definida en el tipo {1}
js.jquery.efficiency.inspection.name=Eficiencia de uso de JQuery
js.jquery.efficiency.inspection.allow.attribute.and.pseudo.selectors=속성 및 의사 선택자 허용
js.jquery.efficiency.inspection.attribute.used.message=jQuery 속성 선택자는 비효율적일 수 있습니다
js.jquery.efficiency.inspection.pseudoselector.used.message=jQuery 의사 선택자는 비효율적일 수 있습니다
js.jquery.efficiency.inspection.duplicated.selector=jQuery 선택자 중복
js.accessibility.check.inspection.name=@private 및 @protected 멤버 접근성
js.convert.to.foreach.intention.name=배열에서 forEach 호출로 변환
js.consecutive.commas.in.array.literal.inspection.name=배열 리터럴의 연속 쉼표
js.consecutive.commas.in.array.literal.inspection.message=배열 리터럴의 연속 쉼표
js.consecutive.commas.in.array.literal.inspection.insert.undefined=''undefined'' 삽입
js.check.function.signature.guess.optionality=매개변수 선택성 추측
js.check.function.signature.guess.optionality.hint=비활성화하면 유형이 지정되지 않은 모든 매개변수가 선택 사항으로 간주됩니다
es6.redundant.await.report.for.promises=프로미스 보고
es6.redundant.await.report.for.promises.hint=항상 ''return await''은 항상 필요없는 것으로 보고되지만 V8의 비동기 스택 추적 기능을 무효화합니다
es6.missing.await.report.for.promises=return 문의 프로미스 보고
es6.missing.await.report.for.promises.hint=비동기 함수 호출 전에 ''await''를 사용하면 V8이 비동기 스택 추적을 제공하는 데 도움이 됩니다
js.file.references.inspection.name=파일 참조 유효성 검사
js.file.references.inspection.ignore.complex.cases=복잡한 사례 무시
js.referencing.arguments.outside.of.function.inspection.name=함수 외부에서 ''arguments'' 참조
js.inspection.es6.modules.dependencies.family.name=import 문 누락
js.inspection.amd.modules.dependencies.family.name=AMD 모듈 종속성 누락
js.inspection.promise.ignored.display.name=프로미스를 반환 하는 메서드 호출의 결과는 무시됩니다
js.inspection.promise.ignored.problem.descriptor={0}에서 반환되는 프로미스는 무시됩니다
js.inspection.promise.value.expected.problem.descriptor={0}에서 반환되는 프로미스는 값이 기대되는 위치에서 사용됩니다
js.flowjs.group.name=Flow 유형 검사기
js.flowjs.config.inspection.name=.flowconfig 누락
js.flowjs.config.inspection.message=관련 .flowconfig가 없습니다
js.flowjs.coverage.inspection.name=코드는 Flow에서 다루지 않습니다.
js.flowjs.coverage.inspection.error.text=이 요소는 Flow에서 다루지 않습니다
js.flowjs.config.inspection.to.project.path.name=프로젝트 루트에 .flowconfig 추가
js.flowjs.config.inspection.to.module.path.name=모듈 콘텐츠 루트에 .flowconfig 추가
js.flowjs.config.inspection.to.current.path.name=현재 디렉터리에 .flowconfig 추가
js.flowjs.annotation.inspection.name=Flow 오류
js.flowjs.flag.comment.placement.inspection.name=Flow 플래그가 잘못 배치되었습니다
js.flowjs.flag.comment.placement.inspection.error=Flow 플래그 주석이 파일 시작에 있지 않습니다
js.flowjs.flag.comment.placement.inspection.fix=Flow 플래그 주석을 파일 시작으로 이동
js.flowjs.flag.without.language.version=Flow 언어 버전이 없는 Flow 플래그
js.extjs.unresolved.ext.xtype.inspection.name=미해결 Flow JS xtype
js.frameworks.sencha.xtype.not.found=xtype ''{0}''에 대한 Ext JS 클래스를 찾을 수 없습니다
javascript.equality.comparison.with.coercion.family.name=유형 강제 변환 없이 바꾸기
javascript.equality.comparison.with.coercion.display.name=동치 연산자는 유형 강제 변환을 일으킬 수 있습니다
javascript.equality.comparison.with.coercion.error.string=비교 \#ref이(가) 예기치 않은 유형 강제 변환을 일으킬 수 있습니다 \#loc
javascript.equality.comparison.with.coercion.fix=''{0}''(으)로 바꾸기
javascript.equality.comparison.with.coercion.options.label=''\=\='' 및 ''\!\='' 사용 위치 강조 표시\:
javascript.equality.comparison.with.coercion.option.always=모두
javascript.equality.comparison.with.coercion.option.always.except.null=null 또는 typeof와 비교하는 경우를 제외한 모두
javascript.equality.comparison.with.coercion.option.only.suspicious=의심스러운 표현식만
js.strict.mode.inspection.name=비엄격 모드가 사용되었습니다
js.strict.mode.inspection.error={0} 이(가) 엄격 모드가 아닙니다
js.strict.mode.inspection.fix="use strict" 프라그마 추가
js.strict.mode.inspection.redundant.pragma="use strict" 프라그마가 불필요합니다
js.strict.mode.remove.pragma="use strict" 프라그마 제거
js.class.member.initialization.inspection.name=정적 이니셜라이저에서 할당되지 않은 프로퍼티가 사용될 가능성이 있습니다
js.class.member.initialization.inspection.text=필드 ''{1}'' 이(가) ''{0}'' 이후 선언되었으며 아직 할당되지 않았을 수 있습니다
js.class.member.initialization.inspection.text.id=필드 ''{0}'' 이(가) 자신을 참조합니다
js.assignment.used.as.condition.name=할당이 조건으로 사용되었습니다
js.assignment.used.as.condition.text=<code>\#ref</code>가 조건으로 사용되었습니다
js.assignment.used.as.condition.fix=''\=''을(를) ''{0}''(으)로 바꾸기
js.missing.switch.branches.inspection.name=''switch'' 문에 분기가 누락되었습니다
js.missing.switch.branches.inspection.desc=''switch'' 문이 case를 누락합니다\: {0}
js.missing.switch.branches.ignore.with.default=디폴트 분기가 있는 switch 문 무시
js.unreachable.switch.branches.inspection.name=도달할 수 없는 ''switch'' 문의 ''case'' 분기
js.unreachable.switch.branches.inspection.desc=도달할 수 없는 ''case'' 분기
js.unreachable.switch.branches.ignore.with.dynamic=동적 유형의 컨텍스트에서 이 경고를 표시하지 마세요
js.unreachable.switch.branches.remove=도달할 수 없는 ''case'' 분기 제거
js.redundant.switch.problems.inspection.name=''switch'' 문은 중복이며 바꿀 수 있습니다
js.redundant.switch.problems.inspection.empty=''switch'' 문이 비어 있습니다
js.redundant.switch.problems.inspection.empty.remove=빈 ''switch'' 문 제거
js.redundant.switch.problems.inspection.default=''switch'' 문이 단일 ''default'' 절만 포함합니다
js.redundant.switch.problems.inspection.default.unwrap=''switch'' 문 줄바꿈 해제
js.redundant.switch.problems.inspection.side.effects=및 부작용 추출
js.redundant.switch.problems.inspection.single=''switch'' 문이 default가 아닌 단일 절만 포함합니다
js.redundant.switch.problems.inspection.single.replace=''switch''를 ''if''로 바꾸기
js.switch.no.default=''switch'' 문에 ''default'' 분기가 없습니다
js.switch.no.default.add=누락된 디폴트 분기 생성
js.variable.problems.inspection.name=변수가 선언되고 다른 ''case'' 절에서 사용됩니다
js.variable.problems.inspection.desc=변수 ''{0}'' 이(가)  절 ''{1}''에서 선언되었지만 에서 절 ''{2}''에서 사용됩니다
js.variable.problems.inspection.desc.ref.error=액세스 시 참조 오류
js.variable.problems.ignore.desc=var-변수에 대해 무시
js.inspection.package.json.dependencies=package.json에서 일치하지 않는 종속성
js.inspection.missing.amd.dependency=AMD 모듈 종속성 누락
js.inspection.missing.import=import 문 누락
js.inspection.missing.module.dependency=모듈 종속성 누락
typescript.narrowed.to=''{0}''(으)로 좁혀졌습니다
label.exclude.methods.classes=클래스의 메서드 제외\:
dialog.title.add.classes=클래스 추가
typescript.suspicious.constructor.parameter.assignment=Asignación de parámetros sospechosa en el constructor. ¿Olvidaste agregar "esto"?
typescript.suspicious.constructor.parameter.assignment.desc=생성자에서 의심스러운 매개변수 할당
typescript.abstract.class.constructor.can.be.made.protected=추상 클래스 생성자를 protected로 만들 수 있습니다
typescript.make.constructor.protected=생성자 protected로 설정
typescript.private.field.modifiers.mix=전용 이름 필드는 ''public'', ''private'' 또는 ''protected'' 접근 제어자 가질 수 없습니다
javascript.validation.message.flowjs.path=La ruta del flujo es incorrecta
javascript.validation.message.interface.members.cannot.have.access.modifiers=인터페이스 멤버는 접근 제어자를 가질 수 없습니다
javascript.validation.message.interface.members.cannot.have.namespace.attributes=인터페이스 멤버는 네임스페이스 속성을 가질 수 없습니다
javascript.validation.message.interface.members.cannot.be.final.modifiers=인터페이스 멤버는 final일 수 없습니다.
javascript.validation.message.static.modifier.is.allowed.only.for.class.members=static 제어자는 클래스 멤버에만 허용됩니다
javascript.validation.message.interface.cannot.be.final.modifiers=인터페이스는 final일 수 없습니다
javascript.template.context.type=JavaScript 및 TypeScript(&R)
interface.should.have.no.variable.declarations=인터페이스는 변수 선언을 가질 수 없습니다
javascript.validation.message.implements.for.interface.not.allowed=인터페이스에 대한 구현 목록이 허용되지 않습니다
javascript.validation.message.interface.name.expected.here=인터페이스 이름 기대
javascript.validation.message.class.name.expected.here=클래스 이름 기대
javascript.validation.message.circular.dependency=순환 종속성
javascript.validation.message.index.no.type=색인 시그니처 매개변수는 유형 어노테이션이 필요합니다
javascript.validation.message.index.wrong.type=색인 시그니처 매개변수 유형은 ''string | number | symbol''에 할당이 가능해야 합니다
javascript.fix.remove.circular.dependency=순환 종속성 제거
react.jsx.syntax.used=React JSX 구문
react.jsx.syntax.used.description=사용된 React JSX 구문

# estos elementos se utilizan implícitamente; consulte JSClosureCompilerSyntaxInspection.getNotImplementedTextId
javascript.validation.message.interface.method.not.implemented=El método {0} de la interfaz {1} no está implementado
javascript.validation.message.abstract.method.not.implemented=El método abstracto {0} de la clase {1} no está implementado
javascript.validation.message.abstract.get.accessor.not.implemented=El acceso de obtención abstracto {0} de la clase {1} no está implementado
javascript.validation.message.abstract.set.accessor.not.implemented=El descriptor de acceso del conjunto abstracto {0} de la clase {1} no está implementado
javascript.validation.message.interface.property.not.implemented=La propiedad {0} de la interfaz {1} no está implementada
javascript.validation.message.interface.get.accessor.not.implemented=La propiedad get accessor {0} de la interfaz {1} no está implementada
javascript.validation.message.interface.set.accessor.not.implemented=El acceso al conjunto de propiedades {0} de la interfaz {1} no está implementado

javascript.validation.message.class.method.incompatible=El método ''{0}'' en la clase ''{1}'' no se puede asignar al mismo método en la base ''{2}''
javascript.validation.message.class.property.incompatible=La propiedad ''{0}'' en la clase ''{1}'' no se puede asignar a la misma propiedad en la base ''{2}''
javascript.validation.message.class.method.not.implemented=El método {0} de la clase {1} no está implementado
javascript.validation.message.class.property.not.implemented=La propiedad {0} de la clase {1} no está implementada
javascript.validation.message.interface.call.signature.not.implemented=La firma de llamada de la interfaz {0} no está implementada
javascript.validation.message.interface.index.signature.not.implemented=La firma de índice de la interfaz {0} no está implementada
javascript.validation.message.class.setter.cannot.have.return.type=Un descriptor de acceso 'set' no puede tener un tipo de retorno
javascript.fix.remove.externally.visible.symbol=Eliminar símbolo visible externamente
javascript.fix.remove.abstract.keyword=Eliminar el modificador ''abstract''
javascript.fix.remove.modifier=제어자 제거
javascript.fix.implement.members=멤버 구현
javascript.fix.implement.methods=메서드 구현
javascript.implement.all.interfaces=모든 멤버 구현
javascript.implement.required.interfaces=필요한 모든 멤버 구현
javascript.implement.members.abstract=멤버 추상으로 구현

# Símbolos
javascript.parameter=Parámetro
javascript.local.variable=Variable local
javascript.global.variable=Variable global
javascript.global.function=Función global
javascript.local.function=Función local
javascript.global.decorator=Decorador
javascript.static.member.function=Función miembro estática
javascript.static.member.variable=Variable miembro estática
javascript.instance.member.variable=Variable miembro de instancia
javascript.instance.member.function=Función miembro de instancia
javascript.create.class.intention.name=Crear clase ''{0}''
javascript.create.interface.intention.name=Crear interfaz ''{0}''
choose.class.to.import.title=Clase para importar
javascript.fix.remove.override.modifier=Eliminar modificador de anulación
javascript.fix.remove.virtual.modifier=Eliminar modificador virtual
javascript.validation.message.attribute.was.specified.multiple.times=El modificador {0} se especificó varias veces
javascript.fix.remove.dynamic.modifier=Eliminar modificador dinámico
javascript.validation.message.function.override.for.object.method=El método heredado de Object no necesita anulación
javascript.validation.message.function.override.without.parent.method=El método no anula el método de la superclase
javascript.parser.message.expected.gt=Se esperaba >
javascript.parser.message.expected.lbracket=Se esperaba [
javascript.parser.message.expected.readonly=Se esperaba 'solo lectura'
javascript.module.name=Nombre del módulo
javascript.exported.variable=Variable exportada
javascript.exported.function=Función exportada
javascript.exported.class=Clase exportada
javascript.fix.create.function.component.jsx.name=함수 구성 요소 ''{0}'' 생성
javascript.fix.create.function.component.jsx.family=함수 구성 요소 생성
javascript.fix.create.class.component.jsx.name=클래스 구성 요소 ''{0}'' 생성
javascript.fix.create.class.component.jsx.family=클래스 구성 요소 생성
typescript.module.name=모듈 이름
typescript.type.alias.name=유형 별칭
typescript.type.guard.name=변수 유형이 타입 가드에 의해 좁혀졌습니다
typescript.type.guard.name.disable=타입 가드로 좁혀진 유형 컬러링 비활성화
typescript.primitive.types.name=기본 유형
typescript.type.parameter=유형 매개변수
typescript.remove.type.declaration=유형 선언 제거

generate.constructor.overloads.and.fields.chooser.title=사용할 오버로드 및 초기화할 필드 선택
generate.to.string.chooser.title=toString 함수에서 사용할 필드 선택
members.to.implement.chooser.title=구현할 멤버 선택
members.to.override.chooser.title=재정의할 멤버 선택
no.candidates=후보가 없습니다
no.methods.to.implement=No se han encontrado métodos para implementar
no.members.to.implement=No se han encontrado miembros para implementar
implement.members.abstract=멤버 추상으로 구현
no.methods.to.override=No se han encontrado métodos para anular
no.members.to.override=No se han encontrado miembros para anular
no.variables.for.getter=No se han encontrado campos sin getter
no.variables.for.setter=No se han encontrado campos sin setter
no.variables.for.getter.setter=No se han encontrado campos sin getter y setter
javascript.validation.unused.import=Importación no utilizada
javascript.validation.fqn.to.replace.with.import=El nombre calificado se puede reemplazar con la declaración de importación
javascript.fix.optimize.imports=Optimizar importaciones
javascript.parser.message.expected.doc.tag.value=Valor de etiqueta esperado
javascript.parser.message.expected.doc.tag.name=Se esperaba el nombre de la etiqueta del documento
javascript.invalid.number.of.parameters=Número de argumentos no válido, esperado {0}
javascript.expression.type.implicitly.coerced.to.unrelated.type=El tipo de expresión {1} se coacciona implícitamente a un tipo no relacionado {0}
javascript.argument.type.mismatch=El tipo de argumento {1} no se puede asignar al tipo de parámetro {0}
javascript.initializer.type.mismatch=El tipo de inicializador {1} no se puede asignar al tipo de variable {0}
javascript.incorrect.variable.type.mismatch=El tipo de variable {1} no se puede asignar al tipo {0}
javascript.term.does.not.evaluate.to.function=La expresión del método no es del tipo de función
javascript.term.does.not.evaluate.to.function.nullable=La expresión del método puede ser nula o indefinida
javascript.term.does.not.evaluate.to.function2=La propiedad no se puede invocar como función
javascript.term.does.not.evaluate.to.function.line.break=La expresión no es invocable. Si no se supone que sea una llamada, compruebe si falta un punto y coma
javascript.term.does.not.evaluate.to.function2.fix=Eliminar lista de argumentos
javascript.term.nullable.indexer.qualifier=La expresión indexada puede ser nula o indefinida
javascript.unused.import.remove=Eliminar 'importación' no utilizada
javascript.unused.import.remove.specifier=Eliminar elemento no utilizado
javascript.assigned.expression.type.mismatch=El tipo de expresión asignado {1} no se puede asignar al tipo {0}
javascript.vector.literal.element.type.mismatch=El tipo de elemento literal de vector {1} no se puede asignar al tipo {0}
javascript.type.is.not.assignable.to.type=El tipo {1} no se puede asignar al tipo {0}
javascript.no.call.signatures=El tipo asignado no contiene firmas de llamada
javascript.known.props.only=El literal de objeto solo puede especificar propiedades conocidas, pero las siguientes son adicionales: {0}
javascript.returned.expression.type.mismatch=El tipo de expresión devuelto {1} no se puede asignar al tipo {0}
javascript.insert.cast.fix=Insertar transmisión
javascript.insert.primitive.wrapper.fix.family.name=Ajustar con tipo primitivo
javascript.insert.generic.wrapper.fix.family.name=Envolver con tipo genérico
javascript.insert.wrapper.fix.text=Ajustar con ''{0}''
typescript.insert.cast.fix=Insertar afirmación de tipo
es6.insert.await.fix=Insertar espera
es6.change.to.default.fix=Usar importación predeterminada para ''{0}''
es6.change.to.named.import.fix=Usar importación con nombre para ''{0}''
typescript.insert.type.guard.fix.family=Insertar protector de tipo
typescript.insert.type.guard.surround=Incluir en ''{0}''
typescript.insert.type.guard.prefix=Prefijo con ''{0}''
typescript.insert.type.guard.postfix=Consulta como opcional con ''{0}''
typescript.insert.type.guard.nc=Reemplazar calificador con ''{0}''
typescript.insert.type.guard.nc.self=Reemplazar con ''{0}''
error.not.available.in.javascript.code={0} no está disponible en código JavaScript
cannot.modify.library.code=No se puede modificar la biblioteca o el código SDK
javascript.extract.method.title=Función de extracción
javascript.validation.message.function.override.incompatible.signature.generic=Anulación incompatible
javascript.validation.message.function.override.incompatible.access.modifier=Anulación incompatible, debería tener el modificador de acceso ''{0}''
javascript.validation.message.function.override.incompatible.signature=Anulación incompatible, debería tener la firma ''{0}''
javascript.validation.message.function.override.incompatible.signature2=Anulación incompatible, debería tener el tipo de retorno ''{0}''
javascript.validation.message.function.override.incompatible.signature3=Anulación incompatible, debería tener el tipo ''{0}''
javascript.validation.message.function.method.invalid.overridden.parameter.type=Anulación incompatible, debe tener el tipo ''{0}''
javascript.validation.message.interface.method.invalid.access.modifier=Implementación incompatible, debería tener un modificador de acceso 'público'
javascript.validation.message.interface.method.invalid.signature=Implementación incompatible, debería tener la firma ''{0}''
javascript.validation.message.interface.method.invalid.signature2=Implementación incompatible, debería tener el tipo de retorno ''{0}''
javascript.validation.message.interface.method.invalid.signature3=Implementación incompatible, debería tener get/set ''{0}''
javascript.validation.message.duplicate.catch.block=Bloque de captura duplicado #loc
javascript.validation.message.duplicate.catch.block.fix=Eliminar bloque de captura duplicado
javascript.validation.message.missing.catch.or.finally=Falta la cláusula de captura o finalización
javascript.validation.message.return.value.of.type.is.required=Se requiere el valor de retorno del tipo {0}
javascript.validation.message.return.statement.required=Se requiere declaración de devolución para el tipo de devolución no nulo
typescript.validation.message.invalid.module.member.modifier=''{0}'' no es un modificador válido para el miembro del módulo
javascript.validation.message.unresolved.component=해결되지 않은 구성 요소 {0}
javascript.validation.message.super.constructor.call.should.be.in.constructor=수퍼클래스 생성자 호출이 생성자 본문에 있어야 합니다
javascript.fix.remove.constructor=생성자 제거
javascript.metadata=메타데이터
javascript.class=클래스
javascript.interface=인터페이스
javascript.label=라벨
javascript.function.arrow=화살표 함수
javascript.validation.message.unneeded.comma=불필요한 쉼표
javascript.validation.message.remove.unneeded.comma.fix=불필요한 쉼표 제거
javascript.validation.message.constructor.cannot.be.static=생성자는 정적일 수 없습니다
javascript.create.event.handler.intention.name=이벤트 핸들러 ''{0}'' 생성
javascript.validation.message.missed.super.constructor.call=상위 클래스 생성자 호출 누락
javascript.validation.message.this.before.super.call=상위 클래스 생성자 호출 전에는 ''this''가 허용되지 않습니다
javascript.validation.message.baseMethod.before.super.call=''super''는 상위 클래스 생성자 호출 전에 허용되지 않습니다
javascript.validation.message.base.constructor.in.not.derived=기본 생성자 호출은 파생된 생성자에서만 허용 됩니다
typescript.validation.message.base.constructor.must.be.first.statement=클래스에 초기화된 프로퍼티가 포함되어 있거나 매개변수 프로퍼티가 있는 경우 base 생성자 호출이 생성자의 첫 번째 명령문이어야 합니다
javascript.fix.create.constructor.invoke.super=super와 일치하는 생성자 생성
javascript.fix.create.invoke.super=상위 클래스 생성자 호출 삽입
javascript.interface.can.not.be.instantiated.message=인터페이스는 인스턴스화할 수 없습니다
javascript.abstract.class.can.not.be.instantiated.message=추상 클래스는 인스턴스화할 수 없습니다
javascript.validation.message.set.method.should.be.void.or.without.type=setter 정의의 반환 유형은 지정하지 않거나 void여야 합니다
javascript.validation.message.set.method.should.have.one.parameter=setter 정의는 정확히 하나의 매개변수가 필요합니다
javascript.validation.message.get.method.should.have.no.parameter=getter 정의는 매개변수를 가질 수 없습니다
javascript.validation.message.get.method.should.be.valid.type=getter 정의의 반환 유형이 {0} 일 수 없습니다
javascript.validation.message.use.namespace.reference.or.access.modifier=네임스페이스 또는 접근 제어자 사용
javascript.validation.message.one.visibility.modifier.allowed=하나의 가시성 제어자(public, protected, internal, private)만 허용됩니다
javascript.validation.destructuring.without.initializer=구조 분해 선언은 이니셜라이저가 필요합니다
javascript.fix.remove.access.modifier=접근 제어자 제거
javascript.fix.remove.final.modifier=final 제어자 제거
javascript.validation.message.final.modifier.allowed.only.for.methods=final 제어자는 클래스 및 클래스 메서드에만 적용할 수 있습니다
javascript.fix.remove.namespace.reference=네임스페이스 참조 제거
javascript.fix.remove.visibility.modifier=가시성 제어자 제거
javascript.incorrect.array.type.in.for-in=배열 키 유형이 String이어야 합니다
javascript.validation.message.unexpected.type.for.rest.parameter=나머지 매개변수는 유형을 가질 수 없습니다
typescript.validation.message.unexpected.type.for.rest.parameter=Rest 매개변수는 배열 유형이거나 배열 제약 조건이 있는 제네릭이어야 합니다
typescript.validation.message.unexpected.type.for.rest.parameter.fix=배열 유형으로 바꾸기
javascript.fix.remove.type.reference=유형 참조 제거
javascript.validation.message.parameter.is.not.allowed.after.rest.parameter=매개변수는 rest 매개변수 이후 허용되지 않습니다
javascript.validation.message.comma.is.not.allowed.after.rest.element=쉼표는 나머지 요소 이후 허용되지 않습니다
javascript.validation.message.comma.is.not.allowed.after.last.parameter=쉼표는 마지막 매개변수 뒤에 허용되지 않습니다.
javascript.fix.remove.comma=쉼표 제거
javascript.fix.remove.parameter=매개변수 제거
javascript.fix.remove.parameters=매개변수 제거
javascript.fix.remove.initializer=이니셜라이저 제거
javascript.validation.message.parameter.should.be.initialized=매개변수를 초기화해야 합니다
javascript.validation.message.parameter.non.optional.after.optional=필수 매개변수 이후 선택적 매개변수를 사용할 수 없습니다
javascript.validation.message.parameter.rest.optional=나머지 매개변수는 선택 사항일 수 없습니다
javascript.fix.initialize.parameter=매개변수 초기화
javascript.validation.message.rest.parameter.should.not.be.initialized=rest 매개변수를 초기화할 수 없습니다
javascript.validation.message.nested.classes.are.not.allowed=중첩 클래스는 허용되지 않습니다
javascript.validation.message.implements.is.not.allowed=구현 절은 표준 ECMAScript에서 허용되지 않습니다
javascript.validation.message.arguments.with.rest.parameter=''arguments'' 객체는 나머지 매개변수 사용 시 사용할 수 없습니다
js.validate.types.inspection.name=유형 불일치
typescript.validate.optional.parameter.inspection.error=매개변수로 물음표와 이니셜라이저를 사용할 수 없습니다
typescript.validate.optional.parameter.inspection.fix.question=물음표 제거
typescript.validate.generic.types.inspection.name=제네릭 유형 불일치
typescript.redundant.typescript.type.argument.inspection.name=제네릭 유형에 대한 불필요한 유형 인수
typescript.duplicate.typescript.union.inspection.name=공용체 또는 교차 유형 구성요소 중복
typescript.validate.generic.types.fix.delete=제네릭 인수 제거
typescript.validate.generic.types.fix.add=제네릭 인수 추가
typescript.validate.generic.types.inspection.error.argument.number=제네릭 유형 ''{0}'' 이(가) ''{1}'' 유형 인수를 필요로 합니다
typescript.validate.generic.types.inspection.error.argument.number.between=제네릭 유형 ''{0}''이 {1}에서 {2} 사이 유형의 인수를 필요로 합니다
typescript.validate.generic.types.inspection.error.not.empty.argument=유형 인수 목록이 공백일 수 없습니다
typescript.validate.generic.types.inspection.error.not.empty.parameter=유형 매개변수가 공백일 수 없습니다
typescript.validate.types.any.inspection.name=''any'' 유형 컨텍스트에서 유형 불일치
typescript.validate.template.literal.types=템플릿 유형 {1}을(를) 제약 유형 {0}에 대입할 수 없습니다
js.incompatible.types.comparison.inspection.name=호환되지 않는 유형이 있는 표현식 비교
js.incompatible.types.comparison.message=유형 ''{1}'' 및 ''{2}''가 겹치지 않으므로 조건은 항상 {0, choice, 0\#false|1\#true} 입니다
javascript.validate.imports.name=import 문 유효성 검사
es6.validate.import.error=심볼 ''{0}''을(를) 해결할 수 없습니다.
es6.prefer.short.import.name=가져오기를 단축할 수 있습니다
typescript.reference.to.umd.global=UMD 전역으로 참조
typescript.field.can.be.made.readonly=필드가 생성자에만 할당되어 있으며 readonly로 설정될 수 있습니다
javascript.suspicious.type.guard.desc=소리 없는 타입 가드 검사
javascript.object.null.or.undefined.desc=객체가 ''null'' 또는 ''undefined''입니다
javascript.suspicious.typeof.guard=유효하지 않은 ''typeof'' 검사\: ''{0}'' 이(가) 유형 ''{1}''을(를) 가질 수 없습니다
javascript.redundant.typeof.guard=불필요한 ''typeof'' 검사\: ''{0}'' 이(가) 항상 타입 ''{1}''을(를) 가집니다
javascript.falsy.typeof.guard=''typeof'' 검사가 항상 false입니다\: ''{0}'' 이(가) 항상 유형 ''{1}''을(를) 가집니다 
typescript.suspicious.instanceof.guard=유효하지 않은 ''instanceof'' 검사\: ''{0}'' 이(가) ''{1}''과 관련 없는 유형을 가집니다
typescript.redundant.instanceof.guard=불필요한 ''instanceof'' 검사\: ''{0}'' 이(가) 유형 ''{1}'' 또는 ''{1}''의 하위 유형을 가집니다
typescript.redundant.instanceof.inheritor.guard=불필요한 ''instanceof'' 검사\: ''{0}'' 이(가) 유형 ''{1}'' 또는 ''{1}''의 상속자를 가집니다
javascript.object.is.null={0} 이(가) null입니다
javascript.object.is.possibly.null={0} 이(가) null일 수 있습니다
javascript.object.is.undefined={0} 이(가) undefined입니다
javascript.object.is.possibly.undefined={0} 이(가) undefined일 수 있습니다
javascript.object.is.null.or.undefined={0} 이(가) null 또는 undefined입니다
javascript.object.is.possibly.null.or.undefined={0} 이(가) null 또는 undefined일 수 있습니다
typescript.smart.cast=변수 유형이 타입 가드로 좁혀졌습니다
typescript.smart.cast.hyperlink=글꼴 및 배경 설정
typescript.missing.augmentation.import=증강 가져오기 누락
typescript.explicit.member.type.inspection.name=명시적 멤버 유형
typescript.config.inspection=tsconfig.json 유효성 검사
typescript.config.inspection.libs=필수 TypeScript 라이브러리가 tsconfig.json에 포함되어 있지 않습니다
typescript.config.inspection.missing.option=tsconfig.json의 옵션 누락
typescript.config.inspection.libs.fix=tsconfig.json의 라이브러리 ''{0}'' 활성화 
typescript.config.inspection.config.options.fix=''{0}''을(를) tsconfig.json에 추가
typescript.config.inspection.fix.pattern=''{0}'' 프로퍼티 추가
typescript.config.inspection.path.mapping.info=경로 매핑은 baseUrl 프로퍼티가 필요합니다
typescript.config.inspection.checkjs.info=프로퍼티 checkJs가 allowJs 프로퍼티를 필요로 합니다
typescript.redundant.declaration=유형 선언이 추론된 유형과 일치하며 제거될 수 있습니다
unnecessary.parentheses.display.name=불필요한 소괄호
unnecessary.parentheses.problem.descriptor=<code>\#ref</code> 주변의 소괄호가 불필요합니다. \#loc
remove.unnecessary.parentheses.fix.text=불필요한 소괄호 제거
typescript.specify.type.explicitly=유형을 명시적으로 지정합니다.
typescript.specify.type.explicitly.from.hint=명시적 유형 어노테이션 추가
typescript.specify.all.param.types.explicitly=모든 매개변수 유형을 명시적으로 지정하세요
typescript.specify.all.param.types.explicitly.from.hint=모든 매개변수에 명시적 유형 어노테이션 추가
typescript.make.field.readonly=필드를 readonly로 설정
es6.replace.import.action.name={0}(으)로 바꾸기
es6.replace.import.family.name=더 짧은 경로로 바꾸기
js.validate.signature.inspection.name=시그니처 불일치
find.usages.of.base.interface={1}의 메서드 {0} 이(가) \n{2}의 메서드를 구현합니다.\n기본 메서드를 {3}하시겠어요?
find.usages.of.base.class={1}의 메서드 {0} 이(가) \n{2}의 메서드를 재정의합니다.\n기본 메서드를 {3}하시겠어요?
javascript.fix.visibility.family=가시성 문제 해결
javascript.fix.set.element.visibility=''{0}''을(를) {1}(으)로 만들기
javascript.fix.add.sharp=참조 액세스에 \# 추가
javascript.fix.remove.sharp=참조 액세스에서 \# 제거
javascript.fix.set.method.return.type=''{0}''이(가) ''{1}''을(를) 반환하도록 만듭니다.
javascript.fix.generate.argument.stubs=인수 스텁 생성
javascript.deprecated.symbol.replace.fix=더 이상 사용되지 않는 코드를 {0}(으)로 바꾸기
javascript.deprecated.symbol.replace.fix.family=더 이상 사용되지 않는 코드를 권장 대체 코드로 대체
javascript.label.visibility.public=공개(&B)
javascript.label.visibility.package_local=Internal(&I)
javascript.label.visibility.private=비공개(&V)
javascript.label.visibility.protected=보호됨(&O)
move.members.refactoring.name=멤버 이동
move.members.dialog.title=멤버 이동
class.0.cannot.be.created=이름이 같은 정규화된 요소가 존재하므로 대상 클래스 {0} 을(를) 생성할 수 없습니다
# Used in JSFormatUtil.formatVisibility
javascript.visibility.public=public
javascript.visibility.internal=internal
javascript.visibility.private=private
javascript.visibility.protected=protected
entity.in.parent.description={1}의 {0}
package.description=패키지 {0}
0.with.1.visibility.in.the.target.class.is.not.accessible.from.2=대상 클래스의 {0} 가시성을 가진 {1} 을(를) {2}에서 액세스할 수 없습니다
0.with.1.visibility.is.not.accessible.from.2={1} 표시가 있는 {0} 은(는) {2}에서 액세스할 수 없습니다.

# Refactorización
javascript.refactoring.variable.used.as.lvalue=La variable que se incluirá se usa en el lado izquierdo de una tarea
javascript.refactoring.variable.value.is.changed.when.accessed.from.closure=El valor de la variable se cambia cuando se accede desde el cierre
javascript.refactoring.inline.variable.title=Variable en línea
javascript.refactoring.inline.function.title=Función en línea
javascript.refactoring.cannot.find.usages.of.definition.to.inline=No se pueden encontrar usos de la definición en línea
javascript.refactoring.searching.usages=Encontrar usos
javascript.refactoring.cannot.inline.not.initialized.variable=No se puede insertar la variable no inicializada
javascript.refactoring.cannot.inline.destructuring.variable.with.default=No se puede incorporar una variable de desestructuración con el valor predeterminado
javascript.refactoring.cannot.inline.destructuring.rest.variable=No se puede incorporar una variable de descanso de desestructuración
javascript.inline.element.is.not.used={0} nunca se usa
javascript.refactoring.inline.dialog.title=Inline {0}
javascript.refactoring.inline.all.message=Inline &todas las referencias y elimine el {0} ({1})
javascript.refactoring.inline.this.only=Incluya solo esta referencia y mantenga el {0}
javascript.refactoring.cannot.inline.function.defined.in.library=No se puede definir la función en línea en una biblioteca externa
javascript.refactoring.cannot.inline.function.referencing.arguments=La función en línea no puede hacer referencia a argumentos
javascript.refactoring.cannot.inline.interface.method=No se puede utilizar el método de interfaz en línea
javascript.refactoring.cannot.inline.function.referencing.rest.parameter=La función en línea no puede hacer referencia al parámetro de descanso
javascript.refactoring.cannot.inline.overrided.or.overridden.method=No se puede utilizar el método en línea que participa en la jerarquía
javascript.refactoring.cannot.inline.recursive.function=No se puede utilizar la función recursiva en línea
javascript.refactoring.cannot.inline.function.with.multiple.returns=No se puede funcionar en línea con múltiples puntos de salida
javascript.refactoring.cannot.inline.complex.expression.evaluation=No se puede evaluar una expresión compleja en línea
javascript.refactoring.cannot.inline.constructor=No se puede construir el constructor en línea
javascript.refactoring.cannot.inline.jsx.usage=No se puede utilizar la etiqueta JSX en línea
javascript.refactoring.cannot.inline.ambient.function=No se puede realizar una declaración en línea sin implementación
javascript.refactoring.function.to.es6.class.command=Convertir función {0} a clase
js.convert.to.es6.class=Convertir a clase
js.convert.to.es6.class.family.name=Convertir función y sus declaraciones de miembros a clase
js.move.type.to.file.family=Mover a un archivo con nombre coincidente
js.create.derived.type.family=Crear clase derivada/implementar interfaz
js.create.derived.type.class=Crear clase derivada
js.create.switch.cases=Crear ramas de 'cambio' faltantes
js.create.switch.cases.fix=Crear ramas faltantes: {0}
js.edit.object.literal=Editar valores de propiedades literales del objeto
js.create.derived.type.interface=Implementar interfaz
js.create.derived.type.abstract.class=Implementar clase abstracta
js.rename.file.to.match.type.name.family=Cambiar el nombre del archivo para que coincida con el nombre del tipo
js.rename.file.to.match.type.name=Cambiar el nombre del archivo a {0} para que coincida con el nombre de {1}
js.move.type.to.file.text=Mover {0} al archivo {1}
javascript.refactoring.function.to.es6.class.defineProperty.warning.text=경고\: "Object.defineProperty", "Object.defineProperties" 또는 "Object.create"를 ES6 구문으로 변환하면 열거성 및 설성 가능성에 영향을 줄 수 있습니다
rename.destructuring.property.title=구조 분해 프로퍼티 이름 변경
rename.destructuring.property.description=구조 분해 프로퍼티가 여러 멤버를 참조합니다. 관련 프로퍼티의 이름을 변경해야 하며, 그렇지 않으면 코드가 일치하지 않을 수 있습니다.
rename.type.members.title=유형 멤버 이름 변경
rename.type.members.union.intersection.mapped.description=공용체, 교차 또는 매핑된 유형 사용 위치가 탐지되었습니다. 관련 프로퍼티의 이름을 변경해야 하며, 그렇지 않으면 코드가 일치하지 않을 수 있습니다.
rename.type.members.destructuring.description=구조 분해 프로퍼티 사용 위치가 탐지되었습니다. 관련 프로퍼티의 이름을 변경해야 하며, 그렇지 않으면 코드가 일치하지 않을 수 있습니다.
make.private=private으로 설정
choose.destination.scope=대상 범위 선택
list.item.function.to.be.converted.to.class=클래스로 변환할 함수
list.item.declarations.function.members.to.be.converted.to.class.members=클래스 멤버로 변환할 함수 멤버 선언
tab.title.convert.to.class=클래스로 변환
tab.title.refactoring.preview=리팩터링 미리보기
list.item.function.converted.to.class=클래스로 변환된 함수
list.item.declarations.that.were.not.converted=변환되지 않은 선언
tab.title.refactoring.result=리팩터링 결과
extract.method.declare.static=static 선언(&S)
extract.function.declare.functional.expression=함수 표현식 선언(&F)
extract.function.return.type=반환 유형(&T)\:
extract.function.parameters=매개변수
extract.function.signature.preview=시그니처 미리보기
extract.function.function=함수
extract.function.name=이름(&N)\:
extract.constant.type=유형(&T)\:
introduce.constant.target.class=대상 클래스(&A)\:
introduce.field.type=유형(&T)\:
introduce.field.initialize.in=다음에서 초기화
introduce.field.declaration=필드 선언(&D)
introduce.field.current.method=현재 메서드(&M)
introduce.field.class.constructor=클래스 생성자(&C)
introduce.parameter.type=유형(&T)\:
introduce.parameter.optional=선택적 매개변수(&O)
introduce.variable.declaration=변수 선언
introduce.variable.const=const(&C)
introduce.variable.let=let(&L)
introduce.variable.var=var(&V)
introduce.variable.var.of.type=유형의 변수(&T)\:
introduce.variable.make.constant=상수 생성(&C)
custom.template.variables=사용자 지정 템플릿 변수(&C)\:

# Desestructuración
javascript.find.usages.destructuring.target.dialog=La variable de desestructuración abreviada se inicializa con {0}.\n¿Qué usos desea encontrar?
javascript.destructuring.initializer=Inicializador {0}
javascript.destructuring.variable.only=Única variable en la desestructuración
javascript.rename.destructuring.target.dialog.title=La variable de desestructuración abreviada se inicializa con {0}
javascript.rename.choose.target.message=¿A cuál le gustaría cambiar el nombre?
javascript.rename.shorthand.target.dialog.title=La propiedad abreviada se inicializa con {0}
javascript.rename.shorthand.property.description=Propiedad
javascript.rename.file.with.related.title=Cambiar nombre de archivo
javascript.rename.containing.file.message=¿También desea cambiar el nombre del archivo y sus usos a {0}?
javascript.rename.related.declaration.message=¿También desea cambiar el nombre de {0} y sus usos a {1}?
dialog.message.some.usages.cannot.be.updated.properly=일부 사용 위치를 제대로 업데이트할 수 없습니다.\nimport 문 및 export 문 내 사용 위치, 문자열 사용 위치 또는 동적 참조는 구조 분해로 바꿀 수 없습니다.
dialog.message.cannot.propagate.when.having.usages.declarations.in.different.files=다른 파일에 사용 위치 및 선언이 있는 경우 전달할 수 없습니다
dialog.message.write.usages.cannot.be.updated.with.destructuring=쓰기 사용 위치는 구조 분해로 업데이트할 수 없습니다
dialog.message.expression.indexed.by.non.numeric.value=표현식이 숫자가 아닌 값으로 색인 생성되어 있습니다
dialog.message.incomplete.destructuring.pattern.encountered.in.code=코드에 불완전한 구조 분해 패턴이 있습니다
dialog.message.unsupported.destructuring.container=지원되지 않는 구조 분해 컨테이너\: {0}
dialog.message.some.usages.cannot.be.updated.properly.wrong.access=일부 사용 위치를 제대로 업데이트할 수 없습니다.\n이름으로 프로퍼티에 액세스하지 않거나 색인으로 요소에 액세스하지 않는 사용 위치는 바꿀 수 없습니다.
dialog.message.cannot.transform.object.array.destructuring.patterns.for.same.element=동일한 요소에 대한 객체 및 배열 구조 분해 패턴을 변환할 수 없습니다
dialog.message.transforming.multiple.nested.patterns.not.supported=여러 중첩 패턴의 변환은 배열 구조 분해에서 지원되지 않습니다

javascript.refactoring.asdoc.for.abstracts=ASDoc para resúmenes
0.is.not.allowed.in.interface={0} no está permitido en la interfaz
javascript.fix.remove.static.modifier=Eliminar modificador estático
javascript.validation.message.override.can.be.applied.to.method=재정의는 함수 선언에만 적용할 수 있습니다
javascript.validation.message.dynamic.can.be.applied.to.class=동적 속성은 클래스 선언에만 적용할 수 있습니다
javascript.illegal.variable.type.void=올바르지 않은 변수 유형\: ''void''
javascript.cannot.return.expression.from.function.with.void.result.type=결과 유형이 void인 함수에서 값을 반환할 수 없습니다
javascript.cannot.return.expression.from.function.with.void.result.type.fix=반환 값 제거
javascript.validation.message.function.override.for.interface={0}의 메서드와 호환되지 않는 재정의
javascript.validation.message.incompatible.override={0}의 멤버와 호환되지 않는 재정의
class.does.not.have.inheritors.in.current.project=현재 프로젝트에 {0}의 상속자가 없습니다
javascript.kind.unknown=알 수 없는 요소
js.unnecessary.semicolon.inspection.name=불필요한 세미콜론
js.unnecessary.semicolon.problem=불필요한 세미콜론 \#loc
js.unnecessary.semicolon.fix.name=불필요한 세미콜론 제거
javascript.refactoring.extract.function.title=함수 추출
javascript.refactoring.extract.function.bad.selection=선택한 블록이 명령문 또는 표현식의 집합을 나타내야 합니다
javascript.refactoring.extract.function.multiple.exit.points=선택한 조각에 종료점이 여러 개 있습니다
javascript.refactoring.extract.function.yield.and.return=선택한 조각이 yield 표현식과 return 문을 동시에 포함합니다
javascript.refactoring.extract.function.no.loop.for.continue=코드 조각 내부의 continue 문에 해당하는 루프가 없습니다
javascript.refactoring.extract.function.no.loop.for.break=코드 조각 내부의 break 문에 해당하는 루프가 없습니다
javascript.refactoring.extract.function.no.switch.for.break=코드 조각 내부의 break 문에 해당하는 ''switch''가 없습니다
javascript.refactoring.extract.function.function.used.before.declaring=선택 영역이 선언 전에 사용되는 함수를 포함합니다
javascript.refactoring.extract.function.already.exists.in.this.scope={0}이(가) 이 범위에 이미 있습니다
javascript.validation.message.constructor.cannot.have.custom.visibility=생성자는 public이거나 가시성이 지정되어 있지 않아야 합니다
javascript.validation.message.can.not.override.final.method={0} 에서 최종 메서드를 재정의할 수 없습니다
top.level.package=최상위 패키지
javascript.parser.message.expected.dot=. 기대
js.comparison.with.nan.inspection.name=NaN과 비교
js.comparison.with.nan.inspection.problem=NaN과 동치 비교는 항상 false으로 평가됩니다
js.comparison.with.nan.inspection.problem2=NaN과의 비동치 비교는 항상 true로 평가됩니다
js.comparison.with.nan.inspection.quickfix={0}isNaN(...)으로 바꾸기
js.constructor.returns.primitive.inspection.name=생성자가 기본 값을 반환합니다
js.constructor.returns.primitive.inspection.problem=생성자에서 반환된 기본 값이 ''new''로 호출 될 때 손실됩니다
js.constructor.returns.primitive.inspection.quickfix=반환 형식을 {0}(으)로 명시적으로 설정
js.comment.matches.signature.inspection.name=JSDoc 주석이 함수 시그니처와 일치합니다
js.comment.matches.signature.inspection.problem1=매개변수 {0} 이(가) JSDoc에 설명되어 있지 않습니다
js.comment.matches.signature.inspection.problem2=JSDoc에 설명된 매개변수 {0} 이(가) 함수 시그니처에 나타나지 않습니다
js.comment.matches.signature.inspection.quickfix=JSDoc 주석 업데이트

livetemplate.description.fori=Crear bucle de iteración
livetemplate.description.iter=Iterar (for..of)
livetemplate.description.itera=Iterar (for await..of)
livetemplate.description.itin=Iterar (for..in)
livetemplate.description.itar=Iterar elementos de la matriz
livetemplate.description.ritar=Iterar elementos de la matriz en orden inverso
livetemplate.description.us=Inserta la declaración 'use estricto'
livetemplate.description.ref=Inserta un comentario de ruta de referencia
livetemplate.description.defi=Inserta la expresión define()
livetemplate.description.flow=Inserta la anotación @flow
livetemplate.description.importfrom=Declaración de importación - importar {b} desde 'a'
livetemplate.description.importns=Declaración de importación - importar * como b desde 'a'
livetemplate.description.importdefault=Declaración de importación - importar b desde 'a'
livetemplate.description.exportall=Declaración de exportación - exportar * desde 'a'
livetemplate.description.exportfrom=Declaración de exportación - exportar {b} de 'a'
livetemplate.description.exportitems=Declaración de exportación - exportar {b}
livetemplate.description.moduleexports=export 문 - module.exports \= a

livetemplate.description.console.log=console.log()
livetemplate.description.console.warn=console.warn()
livetemplate.description.console.error=console.error()
livetemplate.description.console.info=console.info()
livetemplate.description.console.trace=console.trace()
livetemplate.description.console.assert=console.assert()

postfix.template.provider.name=JavaScript 및 TypeScript
postfix.template.condition.non.void.name=비 Void
postfix.template.condition.array.name=배열

macro.js.component.type.of=jsComponentTypeOf(Array)
macro.js.suggest.default.variable.kind=jsSuggestDefaultVariableKind(Boolean)

# Marcadores de línea
linemarker.implements.invalid=<inválido>
linemarker.implements.text=Implementa {0} en {1}
linemarker.overrides.text=Anula {0} en {1}
linemarker.implements.several=Implementación de múltiples métodos de interfaz
linemarker.overridden=Anulado
linemarker.implemented=Implementado
linemarker.overriding=Anulando
linemarker.implementing=Implementando
linemarker.javascript.typescript=Marcadores de línea JavaScript/TypeScript

js.validate.jsdoc.inspection.name=Errores de sintaxis y referencias no resueltas en JSDoc
javascript.expected.class.or.descendant=Clase esperada {0} o descendiente
javascript.qualified.class.name.expected=정규화된 클래스 이름 기대
javascript.validation.message.unknown.metadata.annotation.used=알 수 없는 메타데이터 속성 사용
javascript.validation.message.set.method.type.is.different.from.getter=Set 접근자 메서드에 get 접근자 유형과 호환 되지 않는 유형이 있습니다, ''{0}'' 이(가) 필요합니다
javascript.validation.message.get.method.type.is.different.from.setter=get 접근자 메서드에는 set 접근자 유형과 호환 되지 않는 유형이 있습니다, ''{0}'' 이(가) 필요합니다
typescript.validation.message.getter.and.setter.must.have.same.access.type=getter와 setter는 엑세스 유형이 동일해야 합니다
actionscript.validation.message.set.method.access.type.is.different.from.getter=플래시 컴파일러 버그 174646\: set 접근자 메서드 액세스 유형이 get 접근자 액세스 유형과 다릅니다, ''{0}'' 이(가) 필요합니다
actionscript.validation.message.get.method.access.type.is.different.from.setter=플래시 컴파일러 버그 174646\: Get 접근자 메서드 액세스 유형이 set 접근자 액세스 유형과 다릅니다, ''{0}'' 이(가) 필요합니다
javascript.validation.message.static.method.cannot.be.final=Static 메서드는 final일 수 없습니다
javascript.assign.parameter.to.field.intention.name=매개변수 ''{0}''을(를) 필드에 할당
javascript.fix.create.parameter=매개변수 ''{0}'' 생성
javascript.introduce.parameter.introduced.variable.value=값(&V)\:
0.is.not.a.legal.name=''{0}'' 은(는) 올바른 클래스 이름이 아닙니다
item.already.exists={0} {1} 이(가) 이미 존재합니다
directory.already.contains.file=디렉터리 ''{0}'' 이(가) 파일 ''{1}''을(를) 이미 포함합니다
extract.subclass.command.name={1}에서 상위 클래스 {0} 추출
extract.interface.command.name=인터페이스 추출
extract.type.alias.command.name=유형 별칭 추출
new.actionscript.class.dialog.title=새 ActionScript 클래스
new.actionscript.interface.dialog.title=새 ActionScript 인터페이스
class.template.title=Clase
class.with.supers.template.title=Clase con Supers
interface.template.title=Interfaz
extract.0.turn.refs=Ex&traer {0} y úselo siempre que sea posible
superclass.cannot.be.extracted.from.mxml.component=La superclase no se puede extraer del componente MXML.
superclass.cannot.be.extracted.from.type.alias=La superclase no se puede extraer del alias de tipo
superclass.cannot.be.extracted.from.enum=La superclase no se puede extraer de la enumeración
interface.cannot.be.extracted.from.type.alias=La interfaz no se puede extraer del alias de tipo
interface.cannot.be.extracted.from.enum=La interfaz no se puede extraer de la enumeración
javascript.fix.message.change.parameters.to.expected=Cambiar los parámetros a los esperados
javascript.fix.message.change.return.type.to.expected=Cambiar el tipo de retorno al esperado
js.last.comma.in.array.literal.inspection.name=Última coma innecesaria en el literal de matriz
js.last.comma.in.object.literal.inspection.name=Última coma innecesaria en el objeto literal
error.wrong.caret.position.method.name=El signo de intercalación debe colocarse en el nombre del método que se va a refactorizar.
changeSignature.vararg.not.last=El parámetro de descanso debe ser el último en la firma del método
parameter.type.is.not.specified=El tipo de parámetro ''{0}'' no está especificado.\n¿Continuar?
return.type.is.not.resolved=El tipo de retorno ''{0}'' no está resuelto.\n¿Continuar?
change.signature.column.name.initializer=Inicializador
change.signature.column.name.default.parameter=Parámetro predeterminado
change.signature.column.name.call.value=Valor en la llamada
change.signature.parameter.table.empty.message=Agregar nuevos parámetros con el botón '+'
required.parameters.are.not.permitted.after.optional.parameters=Los parámetros obligatorios no están permitidos después de los parámetros opcionales
javascript.fix.remove.setter.parameter.initializer=Eliminar el valor predeterminado del parámetro
javascript.validation.message.setter.parameter.cannot.have.initializer=La definición de Setter no puede tener parámetros opcionales
javascript.changeSignature.no.call.value=Se ha agregado un nuevo parámetro obligatorio ''{0}''.\nEspecifique un valor predeterminado que se usará en todas las llamadas existentes de este método.
es6.changeSignature.no.call.value=Se ha agregado un nuevo parámetro ''{0}''.\nEspecifique un valor predeterminado o un valor que se usará en todas las llamadas existentes de este método.
javascript.changeSignature.call.value.not.allowed=El valor predeterminado no está permitido para el parámetro ''{0}'', ya que no se especificó para los parámetros anteriores.
es6.changeSignature.call.value.not.allowed=El valor de la llamada no está permitido para el parámetro ''{0}'', ya que no se especificó para los parámetros anteriores.
change.signature.usage.view.declarations.header=Métodos a refactorizar
{0}.visibility.will.break.methods.hierarchy={1} 가시성을 가진 {0} 이(가) 계층 구조에 참여할 수 없습니다
generate.delegate.method.conflict.message=고유한 프로퍼티를 통해 동일한 이름의 멤버에 대한 위임자를 생성할 수 없습니다
generate.delegate.method.conflict.message.title=위임자를 생성할 수 없습니다
invalid.return.type.expression=반환 유형 ''{0}'' 이 유효하지 않습니다
invalid.parameter.type.expression=매개변수 유형 ''{0}''이 유효하지 않습니다
type.is.not.resolved=유형 ''{0}''이 해결되지 않습니다\n계속하시겠어요?
invalid.field.type.expression=유효하지 않은 필드 유형\: ''{0}''
choose.field.type=필드 유형 선택
new.field.action.text=필드
new.field.action.description=클래스에 새 필드 생성
create.field.dialog.title=필드 생성
field.initializer.is.not.specified=필드 초기화가 지정되지 않았습니다
new.method.action.text=메서드
new.method.action.description=클래스에 새 메서드 생성
create.method.dialog.title=메서드 생성
create.button.text=생성(&C)
class.already.contains.method.warning=클래스 ''{0}'' 에 메서드 ''{2}()'' 이(가) 이미 {1, choice, 1\#포함|2\#상속} 되어 있습니다.\n계속 하시겠어요?
class.already.contains.field.warning=클래스 ''{0}'' 이(가) 이미 필드 ''{1}''을(를) 이미 포함합니다.\n계속하시겠어요?
declare.static=static 선언(&S)
new.constructor.action.text=생성자
new.constructor.action.description=클래스 생성자 생성
create.constructor.dialog.title=생성자 생성
change.method.signature.fix.text={0} 시그니처 변경
change.method.signature.and.update.delegating.call.fix.text={0} 시그니처를 {1} 호출과 일치하도록 변경 및 호출 업데이트
change.method.signature.and.update.delegating.call.noname.fix.text=시그니처를 {0} 호출과 일치하도록 변경 및 호출 업데이트
change.method.signature.delegating.default.text=위임
change.method.signature.fix.family.name=메서드 시그니처 변경
change.method.signature.and.update.delegating.call.fix.family.name=메서드 시그니처 변경 및 위임 호출 업데이트

# Settings
settings.javascript.root.configurable.name=JavaScript
settings.typescript.root.configurable.name=TypeScript
settings.javascript.linters.configurable.name=코드 품질 도구
settings.javascript.linters.autodetect.disabled={0} 비활성화(&D)
settings.javascript.linters.autodetect.configure.automatically=자동 {0} 설정(&A)
settings.javascript.linters.autodetect.configure.automatically.help.text={0} 이(가) 현재 파일 또는 상위 폴더와 동일한 폴더에 있는 node_modules 디렉터리와 {2} 구성 파일에서 {1} 패키지를 사용할 것입니다.
settings.javascript.linters.autodetect.configure.manually=수동 {0} 설정(&M)
settings.javascript.linters.jshint.configurable.name=JSHint
settings.javascript.only.type.based.completion=유형 기반 코드 완성만(&C)
settings.javascript.opt.chain.completion=nullable 유형에 대한 선택적 체인이 있는 항목 제안(&O)
settings.javascript.overrides.completion=재정의 완료 시 메서드 본문 확장
settings.javascript.var.names.completion=변수 및 매개변수 이름 제안(&V)
settings.javascript.field.names.completion=클래스 필드 이름 제안(&F)
settings.javascript.var.names.completion.desc=이름 완성 기능
settings.javascript.var.names.completion.types=제안된 매개변수 이름에 대한 형식 어노테이션 추가(&T)
settings.javascript.var.names.completion.names.only=유형 없이
settings.javascript.var.names.completion.types.for.params=함수 매개변수에 대한 유형 사용
settings.javascript.var.names.completion.types.for.params.fields=매개변수 및 필드에 대한 유형 사용
settings.javascript.var.names.completion.types.except.fields=필드를 제외한 모든 곳의 유형 사용
settings.javascript.var.names.completion.types.everywhere=모든 곳의 유형 사용
settings.javascript.only.type.based.completion.tooltip=유형 정보에 따라 코드 완성 제안을 적게 표시합니다. 성능이 크게 향상될 수 있습니다.
settings.javascript.lang.templates.configurable.name=템플릿
es6.auto.import.options.completion.add.imports=코드 완성 시 ES6 import 문 추가
es6.auto.import.options.title=TypeScript / JavaScript
typescript.auto.import.options.add.imports=Agregar importaciones de TypeScript automáticamente
typescript.auto.import.options.add.imports.on.the.fly=Importaciones inequívocas sobre la marcha
typescript.auto.import.options.add.on.code.completion=Al completar el código
typescript.auto.import.options.show.popup=Con ventana emergente de importación
js.import.options.merge.import=Fusionar importaciones para miembros del mismo módulo
js.import.options.use.node.resolution=Usar la importación de directorio cuando index.js esté disponible (resolución de módulo de estilo nodo)
js.import.options.use.explicit.js.extension=Usar extensión de archivo en el nombre del módulo
ts.import.options.use.explicit.js.extension=Use la extensión de archivo .js en el nombre del módulo
js.add.members.to.type.desc=Agregar miembros a la clase o interfaz
js.add.members.to.type=Agregar miembros {0} a ''{1}''
js.import.options.sort.members=Ordenar miembros importados
js.import.options.sort.module.name=Ordenar importaciones por módulos
es6.import.options.paths=Use alias de ruta:
es6.import.options.paths.help=이 옵션은 import 문에 사용되는 경로 스타일을 설정합니다.<br><br>"항상"을 선택하면 IDE는 가져오기를 추가할 때 항상 webpack, system.js 또는 jsconfig.json 설정의 별칭을 사용합니다.<br><br>"지정된 경로 외부의 파일에만"을 성택하면 IDE는 별칭이 정의된 파일 간의 가져오기에 대한 상대 경로를 사용합니다. 다른 모든 파일에서는 경로 매핑이 사용됩니다.<br><br>"사용 안함"을 선택하면 별칭이 사용되지 않습니다.
typescipt.import.options.paths.help=이 옵션은 import 문에 사용되는 경로 스타일을 설정합니다.<br><br>"항상"을 선택하면 IDE는 가져오기를 추가할 때 항상 tsconfig.json의 경로 매핑을 사용합니다.<br><br>"지정된 경로 외부의 파일에만"을 성택하면 IDE는 매핑이 정의된 파일 간의 가져오기에 대한 상대 경로를 사용합니다. 다른 모든 파일에서는 경로 매핑이 사용됩니다.<br><br>"사용 안함"을 선택하면 경로 매핑이 사용되지 않습니다.
typescript.import.options.paths=tsconfig.json의 경로 매핑 사용\:
typescript.import.options.use.config=tsconfig.json에 대한 상대 경로 사용
javascript.import.options.use.resource.root=프로젝트, 리소스 또는 소스 루트에 대한 상대 경로 사용
typescript.import.options.blacklist.title=다음에서 가져오지 마세요\:
js.flow.settings.executable.label=Flow 패키지 또는 실행 파일(&F)\:
js.flow.settings.executable.dialog.title=Flow 패키지 또는 실행 파일 선택
js.flow.services.label=Flow 서버를 다음 용도로 사용\:
js.flow.enable.type.checking=유형 검사
js.flow.enable.other.services=탐색, 코드 완성 및 유형 힌트 표시
js.flow.enable.flow.service.error=잘못된 Flow 경로
js.flow.enable.flow.service.error.empty=Flow 실행 파일 경로가 비어 있습니다
js.flow.enable.flow.service.error.on.checking=Flow 경로 확인 중 오류\: {0}
js.flow.enable.flow.service.error.message={0}. 모든 Flow 서비스를 비활성화하거나 실행 파일에 대한 유효한 경로를 제공하세요
js.flow.settings.auto.save=수정된 파일 자동으로 모두 저장
js.flow.settings.auto.save.warning=Flow는 다른 수정된 파일이 모두 저장된 경우에만 현재 파일을 검사합니다
js.flow.settings.auto.save.warning.lsp=이렇게 하면 Flow에서 항상 최신 오류 상태를 표시합니다.
js.dialect.settings.dialog.title=JavaScript 언어 버전
js.dialect.settings.caption=
js.dialect.settings.tableTitle=언어
js.dialect.settings.override.question=하위 디렉터리 및 파일의 언어 버전을 재정의하시겠어요?
js.dialect.settings.override.title=언어 버전 설정 재정의
js.dialect.settings.empty.text=+ 버튼으로 디렉터리를 추가하고 JavaScript 버전을 선택하세요
js.dialects.customized.label=디렉터리별 사용자 정의
configure.code.completion.settings=코드 완성 설정

# Bower
settings.javascript.bower.configurable.name=Bower
bower.packages.view.dependencies=종속성\:
bower.package=Bower 패키지(&B)\:
bower.json=bower.json(&O)\:
bower.correct.path=경로를 {0}(으)로 수정하세요
bower.node.interpreter=노드 인터프리터
bower.package.name=Bower 패키지
bower.dialog.message.specify.package=올바른 bower 패키지를 지정하세요. "{0}" 파일을 찾을 수 없습니다
bower.required.version.notification.content=bower 패키지를 보려면 bower@1.0.0 이상이 필요합니다
bower.no_description_available.text=사용할 수 있는 설명이 없습니다
dialog.message.command.timed.out=명령어 ''{0}''이(가) 시간 초과되었습니다
dialog.message.command.cancelled=명령어 ''{0}''이(가) 취소되었습니다
dialog.message.command.finished.with.exit.code=명령어 ''{0}''이(가) 종료 코드 {1}(으)로 완료되었습니다. 표준 출력\:\n{2}\n\n표준 오류\:\n{3}

node.interpreter.mnenonic=노드 인터프리터(&N)\:

# JS language version management
js.language.version.combo.es5=ECMAScript 5.1
js.language.version.combo.js185=JavaScript 1.8.5
js.language.version.combo.js185.description=Firefox 전용 ECMAScript 구현은 더 이상 사용되지 않습니다. 전환을 고려하세요.
js.language.version.combo.es6=ECMAScript 6+
js.language.version.combo.es6.description=ECMAScript 2015~2020, 일부 제안 및 JSX
js.language.version.combo.nashorn=Nashorn JS
js.language.version.combo.nashorn.description=Java의 JavaScript 구현
js.language.version.combo.flow=Flow
js.language.version.combo.flow.description=Flow 및 ECMAScript 6의 JSX 
js.language.version.label=JavaScript 언어 버전
js.switch.to.jsx.inspection.dismiss=닫기
ts.switch.to.jsx.inspection.name=파일 확장자를 .tsx로 변경
javascript.change.language.level.message=JavaScript 언어 버전을 {0}(으)로 변경
javascript.change.language.level.family=JavaScript 언어 버전 변경

# JS library management
js.library.attach.debug=디버그 버전 첨부(&D)...
js.library.attach.release=릴리스 버전 첨부(&R)...
js.library.unresolved.url.inspection.name=HTTP 링크에 대한 로컬에 저장된 라이브러리가 없습니다
js.library.download.fix=라이브러리 다운로드
js.library.downloading.library=라이브러리 다운로드
js.library.documentation=문서
js.library.configurable.name=라이브러리
js.library.download.stubs.label=TypeScript 커뮤니티 스텁
js.library.successfully.downloaded={0}이(가) 성공적으로 다운로드되었습니다

choose.super.method=<html><body><b>{0}</b>의 상위 메서드 선택 ({1}개 발견)</body></html>
choose.super.function=<html><body><b>{0}</b>의 상위 함수 선택 ({1}개 발견)</body></html>
choose.super.field=<html><body><b>{0}</b>의 상위 필드 선택 ({1}개 발견)</body></html>
choose.super.classifier=<html><body><b>{0}</b>의 상위 인터페이스 선택 ({1}개 발견)</body></html>
choose.subclass=<html><body><b>{0}</b>의 하위 클래스 선택({1}개 발견)</body></html>
choose.implementing.class=<html><body><b>{0}</b>의 구현 선택({1}개 발견)</body></html>
choose.overridden.method=<html><body><b>{0}</b>의 재정의된 메서드 선택 ({1}개 발견)</body></html>
choose.overridden.function=<html><body><b>{0}</b>의 재정의된 함수 선택 ({1}개 발견)</body></html>
choose.implementing.method=<html><body><b>{0}</b>의 구현 선택({1}개 발견)</body></html>
javascript.parser.message.expected.newline.or.semicolon=줄 바꿈 또는 세미콜론 기대
javascript.invalid.delete.target.message=유효하지 않은 삭제 연산자 대상, 필드 참조 기대
javascript.with.statement.is.not.allowed.in.strict.mode.message=with 문은 엄격 모드에서 허용되지 않습니다
javascript.validation.message.redefining.is.not.allowed={0} 재정의가 허용되지 않습니다
javascript.validation.message.referencing.arguments.caller.callee.is.not.allowed=인수에서 ''caller'' 및 ''callee''을 참조할 수 없습니다
javascript.validation.message.referencing.function.arguments.property.is.not.allowed=''arguments'' 함수 프로퍼티를 참조할 수 없습니다
javascript.validation.message.arguments.is.readonly=''arguments''는 읽기 전용입니다
javascript.validation.message.eval.cannot.be.assigned=''eval''은 엄격 모드에서 할당할 수 없습니다
javascript.octal.literals.are.not.allowed.es6.message=접두사 ''0''이 있는 9진수 리터럴은 허용되지 않습니다. 대신 ''0o'' 접두사를 사용하세요.
javascript.octal.literals.are.not.allowed.es5.message=접두사 ''0''이 있는 8진수 리터럴은 사용되지 않으며 사용하지 않는 것을 권장합니다
javascript.octal.sequences.are.not.allowed.message=8진수 이스케이프 시퀀스는 허용되지 않습니다
javascript.invalid.extended.unicode.escape=확장된 유니코드 이스케이프는 0x0 및 0x10FFFF FF 사이의 값만 허용합니다
javascript.octal.literals.are.not.allowed.in.strict.mode=8진수 리터럴은 엄격 모드에서 허용되지 않습니다
javascript.octal.literals.warn.always=ES5- 코드에서 오래된 8진수 리터럴 사용에 대한 경고
javascript.validation.message.only.one.default.is.allowed=하나의 디폴트 절만 switch에서 허용됩니다
javascript.fix.remove.default=default 절 제거
javascript.validation.message.accessor.could.not.be.nested.under.other.function=접근자 메서드는 다른 함수 안에 중첩될 수 없습니다
javascript.validation.message.es5.function.declarations.allowed.on.top.level.or.function=프로그램 또는 함수의 최상위 수준에 있지 않은 함수 명령문은 금지됩니다
class.chooser.not.available.in.dumb.mode=선택기는 색인 업데이트가 진행 중일 때 사용할 수 없습니다.
choose.super.class.title=상위 클래스 선택
choose.base.component.title=상위 클래스 선택
choose.super.interface.title=상위 인터페이스 선택
0.is.not.accessible.from.1={0} 을(를) {1}에서 액세스할 수 없습니다
javascript.constructor.call.without.new.message=new 없이 생성자 호출
javascript.qualified.name.is.not.imported.message=정규화된 이름을 가져올 수 없습니다 \#loc
javascript.element.is.not.accessible.message=요소에 액세스할 수 없습니다 \#loc
javascript.protected.member.is.not.accessible.message=protected 멤버에 액세스할 수 없습니다 \#loc
javascript.protected.constructor.is.not.accessible.message=protected 생성자에 액세스할 수 없습니다 \#loc
javascript.private.member.is.not.accessible.message=private 멤버는 액세스할 수 없습니다 \#loc
javascript.export.only.member=요소는 내보내기 전용입니다.
javascript.private.constructor.is.not.accessible.message=private 생성자에 액세스할 수 없습니다 \#loc
javascript.public.member.is.not.accessible.via.sharp.message=공용 멤버를 \#-구문을  통해 참조할 수 없습니다 \#loc
javascript.private.member.is.not.accessible.via.sharp.message=private \#가 아닌 멤버를 \#-구문을 통해 참조할 수 없습니다 \#loc
javascript.private.member.is.not.accessible.without.sharp.message=private 멤버를 \#-구문 없이 참조할 수 없습니다 \#loc
javascript.private.member.obsolete.syntax.name=명시적 ''this''없이 \#-private 필드에 액세스합니다
javascript.private.member.obsolete.syntax=\#-private 필드는 명시적 ''this.'' 한정자 없이 액세스할 수 없습니다
javascript.jsdoc.protected.member.is.not.accessible.message=protected 멤버에 액세스할 수 없습니다 \#loc
javascript.jsdoc.private.member.is.not.accessible.message=private 멤버에 액세스할 수 없습니다 \#loc
javascript.static.member.is.not.accessible.message=static 멤버에 액세스할 수 없습니다 \#loc
javascript.instance.member.is.not.accessible.message=인스턴스 멤버에 액세스할 수 없습니다 \#loc
javascript.element.need.to.be.exported=요소를 내보내지 않습니다
javascript.element.need.to.be.imported=요소를 가져오지 않습니다
javascript.element.default.instead.named=디폴트 가져오기가 명명된 가져오기 대신 사용됩니다
javascript.element.need.to.be.included.to.config=해당 파일이 tsconfig.json에 포함되어 있지 않습니다
javascript.argument.types.mismatch=인수 유형이 매개변수와 일치하지 않습니다
javascript.member.from.unopened.namespace.message=열지 않은 네임스페이스의 멤버 \#loc 
javascript.property.is.read.only.message=프로퍼티가 읽기 전용입니다 \#loc
javascript.property.is.write.only.message=프로퍼티가 쓰기 전용입니다 \#loc
javascript.assume.uppercase.functions.to.be.constructors=대문자의 함수만 생성자라고 가정합니다
javascript.not.a.constructor.call.message=생성자 호출이 아닙니다
cannot.refactor.anonymous.function=호출 사이트 분석은 기존 비호출 사용 위치에 의해 방지됩니다.
change.signature.method.references.arguments=함수 참조 인수, 코드가 시그니처 변경 후 중단될 수 있습니다
change.signature.call.expression.contains.spreads=함수 호출이 전개 인수를 포함합니다. 사용 위치는 바뀌지 않습니다.
change.signature.tagged.template.issue=태그가 지정된 템플릿 호출을 업데이트할 수 없습니다. 사용 위치는 변경되지 않습니다.
change.signature.conflict.incompatible.override={0} 재정의가 리팩터링된 {1}와 다른 수의 매개변수를 가집니다. 리펙토링하는 동안 {2}가 무시됩니다.
change.signature.conflict.incompatible.implementation={0} 구현이 리팩터링된 {1}와 다른 수의 매개변수를 가집니다. 리펙토링하는 동안 {2}가 무시됩니다.
change.signature.conflict.eliminating.parameter.property.breaks.usages=매개변수-프로퍼티를 간단한 매개변수로 전환하면 {0} 필드 사용 위치가 중단됩니다
change.signature.conflict.readonly.parameter.property.write.usage={0} 을(를) 읽기 전용으로 만들면 읽지 않은 사용 위치가 중단됩니다
javascript.missed.argument.for.parameter=매개변수 {0}에 대한 인수가 누락되었습니다

# Configuración de plegado de código
checkbox.collapse.object.literals=Literales de objeto
checkbox.collapse.one.line.function.literals=Funciones de una línea en JavaScript y TypeScript
checkbox.collapse.array.literals=Literales de matriz
checkbox.collapse.xml.literals=Literales XML
change.signature.value.column.title=Valor
change.signature.column.name.optional.flag=Opcional
change.signature.column.name.modifier=Modificador

# Flujo general
javascript.flow.error.panel.all.errors=Mostrar todos los errores
js.flow.all.servers.action.restart=Reiniciar todos los servidores de Flow
js.flow.has.unsaved.files=No se realizó el resaltado porque se modificaron algunos archivos
js.flow.tool.window.name=Flow
flow.js.get.type=Flow JS\:유형 받기
flow.show.error.details=오류 세부 정보 표시
can.t.find.flow.executable=flow 실행 파일을 찾을 수 없습니다
process.terminated=프로세스가 종료되었습니다
progress.text.modifying={0} 수정 중
progress.text.initializing.opened.files=열려 있는 파일 초기화 중

# Code style settings
js.code.style.punctuation.tab.title=문장 부호
space.before.name.value.separator=Antes del separador nombre-valor de propiedad ':'
space.after.name.value.separator=Después del separador de nombre-valor de propiedad ':'
space.before.function.left.parenth=En expresión de función
actionscript.space.after.dots.in.rest.parameter=Después de '...' en el parámetro de descanso
space.after.dots.in.rest.spread=Después de '...' en reposo/propagación
space.before.generator.mult=Antes de '*' en el generador
space.after.generator.mult=Después de '*' en el generador
spaces.within.object.type.braces=Llaves de tipo literal de objeto
space.before.type.colon=Antes del tipo de referencia, dos puntos ':'
space.after.type.colon=Después del tipo de referencia, dos puntos ':'
space.before.class.lbrace=Llave izquierda de clase
space.before.class.interface.module.lbrace=clase/interfaz/módulo llave izquierda
spaces.within.object.literal.braces=llaves literal de objeto
spaces.within.import.braces=llaves de importación/exportación de ES6
spaces.within.indexer.brackets=Corchetes de acceso al índice
spaces.within.array.initializer=Corchetes de matriz
spaces.within.union.and.intersection=Tipos de unión e intersección
spaces.within.type.assertion=Tipo de aserciones
spaces.arrow.function=Función de flecha (=>)
spaces.async.arrow.function=En función de flecha asíncrona
spaces.within.interpolation.expressions=Expresiones de interpolación
spaces.within.unary.additive=Operadores aditivos unarios (+,-,++,--)
spaces.after.unary.not=Después de unario 'not' (!) y '!!'
spaces.before.unary.not=Antes unario 'not' (!) y '!!'
js.blank.lines.around.method=Método Around:
js.blank.lines.around.function=Función alrededor:
js.spaces.in.flow.category=En flujo
js.wrap.settings.import=Importación/exportación de ES6
js.align.properties.none=정렬하지 않음
js.align.properties.on.colon=콜론을 기준으로 정령
js.align.properties.on.value=값을 기준으로 정령
js.function.call.parentheses=함수 호출 소괄호
js.function.declaration.parentheses=함수 선언 소괄호
js.function.brace.style=함수 선언에서
js.function.expression.brace.style=함수 표현식에서
js.function.parameters.wrap=함수 선언 매개변수
js.function.call.wrap=함수 호출 인수
js.space.before.function.left.brace=함수 왼쪽 중괄호
js.format.cstyle.comments=여러 줄 정렬
js.chained.call.dot.on.next.line=새 줄의 ''.''
js.generated.use.public.modifier=''public'' 제어자 사용
js.generated.use.as.cast=''as'' 형 변환 선호
js.generated.types=유형
js.generated.types.settings.link=명시적 유형에 대한 코드 스타일 설정
js.generated.explicit.types=다음에 대한 명시적 유형 선호\:
js.generated.explicit.var.types=변수 및 필드
js.generated.explicit.return.types=함수 선언 반환
js.generated.explicit.return.expression.types=함수 표현식 반환
js.trailing.comma.keep=유지
js.trailing.comma.remove=제거
js.trailing.comma.whenMultiline=여러 줄일 경우 추가
js.extends.list.wrap=확장 목록
js.align.multiline.extends.list=여러 줄일 경우 정렬
js.extends.keyword.wrap=키워드 확장
js.wrap.settings.union.and.intersection.types=공용체 및 교차 유형
js.code.style.object.literals.category.name=객체
js.code.style.align.caption=정렬
js.code.style.align.from.clause.caption=''from'' 절 정렬
js.wrap.settings.var.group.name=변수 선언
js.code.style.do.not.align.var.statement=정렬하지 않음
js.code.style.align.var.statements=여러 줄일 경우
js.code.style.align.var.statements.and.assignments=그룹화된 경우
js.code.style.array.group.name=배열
js.array.new.line.after.left.bracket=''['' 뒤에 새 줄
js.array.new.line.before.right.bracket=새 줄에 '']'' 배치

js.method.can.be.static=El método puede ser estático
js.method.can.be.static.option=Verificar solo métodos 'privados'
make.method.static=Hacer 'estático'
typescript.fix.change.member.access=Hacer ''{0}''
js.fix.change.member.access.to.sharp=Hacer privado usando '#'
declare.event.0=Declarar evento ''{0}''
js.variable.might.not.been.initialized=Es posible que la variable no se haya inicializado #loc
js.variable.initializer.is.redundant=El inicializador de variable es redundante #loc
js.value.assigned.is.never.used=El valor asignado nunca se usa #loc
javascript.fix.change.type=Cambiar el tipo ''{0}'' a ''{1}''
javascript.fix.change.parameter.type=Cambiar el tipo de parámetro ''{0}'' a ''{1}''
javascript.change.jsdoc.type.family.name=Cambiar el tipo de elemento en JSDoc
change.signature.dialog.title=Cambiar firma de {0}
javascript.fix.add.enum.values=Agregar valores de enumeración explícitos
javascript.fix.add.string.enum.values=Agregar valores de enumeración de cadena que coincidan con los nombres de campo
javascript.fix.create.implements=Hacer ''{0}'' implementar ''{1}''
javascript.fix.create.inheritor.family=Heredar del super tipo
javascript.fix.implement.family=Implementar en clases derivadas
javascript.fix.implement.chooser.title=Implementar miembro en
javascript.fix.implement.chooser.all=Todas las clases
javascript.fix.implement=Implementar {0}
javascript.fix.create.extends=Hacer ''{0}'' extender ''{1}''
javascript.report.unused.properties=Informar propiedades no utilizadas
javascript.report.unused.definitions=Informar definiciones no utilizadas
javascript.check.global.definitions=Verificar asignaciones en el alcance global
javascript.strictly.check.global.vars=Informar las variables globales no declaradas como error
javascript.strictly.check.object.properties=Informar propiedades no declaradas como error
javascript.strictly.check.global.functions=Informar funciones globales no declaradas como error
change.signature.column.type=Tipo
change.signature.column.name=Nombre
javascript.invalid.invoker.target=Destino de llamada no válido
js.declarations.at.scope.start.inspection=Las declaraciones de variables están al inicio del alcance
js.make.single.var.statement=Hacer una declaración var única
js.declaration.is.not.at.scope.start=La declaración Var no está al inicio del alcance
js.move.to.scope.start=Mover la instrucción var al inicio del alcance
js.primitive.type.wrapper.usage.inspection=Envoltorio de objeto de tipo primitivo utilizado
js.replace.with.type.cast.to.primitive=Reemplazar con el tipo de conversión a {0}
js.assigning.to.primitive.type.property=El valor asignado a la primitiva se perderá
js.primitive.type.improper.instantiation.inspection={0} la creación de instancias se puede simplificar
js.replace.with.literal=Reemplazar con {0} literal
non.ascii.identifiers.inspection.name=Identificadores con símbolos no ASCII
non.ascii.identifiers.only.ascii=Permitir solo nombres ASCII
non.ascii.identifiers.non.ascii.found=<html>El nombre contiene símbolos que no son ASCII: {0} </html>
non.ascii.identifiers.mixed.set=<html>El nombre contiene símbolos ASCII y no ASCII: {0} </html>

element.name.anonymous=<anonymous>
element.name.default=<디폴트값>
duplicate.parameter.name=매개 변수 이름 중복\: {0}
rename.accessors.dialog.title=필드 이름 변경
rename.accessors.dialog.text=프로퍼티 접근자 이름도 역시 ''{0}''(으)로 변경하시겠어요?
insert.new.keyword.fix.name=새 키워드 삽입
insert.this.keyword.fix.name=this 한정자 추가
insert.class.fix.name=클래스 이름 한정자 추가
replace.implements.keyword.fix.name=''implements''을 ''extends''으로 변경
superclass.label.text=상위 클래스(&S)\:
varible.name.column.title=이름
varible.value.column.title=값
custom.variables.step.title.label.text=템플릿 ''{0}'' 의 사용자 정의 변수(&C)\:
create.class.ok.button.text=생성
create.class.name.label=이름(&N)\:
create.class.package.label=패키지\:
create.class.template.label=템플릿(&T)\:
create.class.superclass.label=상위 클래스(&S)\:
create.class.interfaces.label=인터페이스(&I)\:
action.structureview.show.object.inherited=객체로부터 상속

# JSHint
jshint.option.edit.dialog.title=Configuración de la opción ''{0}''
jshint.clear.field.to.disable=Eliminar campo para deshabilitar
jshint.illegal.integer=Entero no válido
jshint.use.config.files=Usando archivos de configuración
jshint.version.label=&Versión\:
jshint.label.bundled.suffix=(번들)
jshint.tree.link.set=설정
jshint.label.no.version=버전 없음
jshint.exception.balloon.action.retry=<a href\=''{0}''>다시 시도</a>
jshint.exception.balloon.action.configure.proxy.or.retry=<a href\=''{0}''>HTTP 프록시 구성</a> 또는 <a href\=''{1}''>다시 시도</a>
jshint.config.file.type.description=JSHint 구성
jshint.suppress.text.suppress.for.line=줄 억제
jshint.options.tree.tooltip.set.a.new.value=새 값 설정
jshint.config.option.default.name=디폴트
jshint.config.default.description=<div style\="padding-bottom\:10px"><div><b>.jshintrc</b></div><div style\="padding-left\:10px; padding-top\:4px;">JavaScript 파일을 린팅할 때 IDE는 파일의 폴더에서 시작하여 파일 시스템 루트로 이동하며 .jshintrc를 찾습니다.</div></div><div><div><b>package.json</b></div><div style\="padding-left\:10px; padding-top\:4px;"> 프로젝트의 package.json 파일 내 <code>jshintConfig</code> 프로퍼티 아래에 설정을 추가합니다.
jshint.config.option.custom.name=Archivo de configuración personalizado
jshint.config.option.custom.browser.title=Seleccionar archivo de configuración JSHint (*.jshintrc)
jshint.config.failed.to.read=No se pudo leer la configuración de JSHint
jshint.config.extends.cyclically=La configuración de JSHint se extiende cíclicamente
jshint.config.error.failed.to.read.property=package.json에서 ''{0}'' 프로퍼티를 읽지 못했습니다
jshint.config.error.cannot.locate.ext.config=JSHint\: 확장된 구성을 찾을 수 없습니다
jshint.config.error.cannot.parse.ext.config=JSHint\: 확장된 구성을 분석할 수 없습니다
jshint.latedef.false.text=Sin advertencia
jshint.latedef.true.text=Prohibir el uso de variables antes de que se definan
jshint.latedef.nofunc.text=<html><body>Prohíbe el uso de variables antes de ser definidas y <br>permite declaraciones de funciones.</body></html>
jshint.unused.false.text=No marques nada
jshint.unused.true.text=<html><body>Comprueba todas las variables y parámetros, pero permite los <br>parámetros no utilizados después de los parámetros utilizados.</body></html>
jshint.unused.vars.text=Verificar variables que no son parámetros de función
jshint.unused.strict.text=Verifique todas las variables y parámetros
jshint.progress.title.updating.jshint=JSHint에서 {0} (으)로 업데이트 중
jshint.progress.title.downloading={0} 다운로드 중
jshint.progress.title=JSHint {0}
jshint.quotmark.false.text=Se permiten ambas comillas
jshint.quotmark.true.text=Solo se permiten comillas simples o dobles
jshint.quotmark.single.text=Solo se permiten comillas simples
jshint.quotmark.double.text=Solo se permiten comillas dobles
jshint.inspection.message.duplicate.options=JSHint 옵션 {0}, {1}이(가) 중복됩니다.
jshint.inspection.message.unexpected.jshint.option.name=예기치 않은 JSHint 옵션 이름
jshint.inspection.message.unexpected.value=예기치 않은 값
jshint.inspection.message.expected.values.x.or.y=필요한 값\: {0} 또는 {1}
jshint.inspection.message.expected.value=필요한 값\: {0}
jshint.inspection.message.object.or.array.expected=객체 또는 배열이 필요합니다
jshint.inspection.message.not.loaded=JSHint {0}이(가) 로드되지 않았습니다
jshint.inspection.message.config.not.found=JSHint 구성을 찾을 수 없습니다
jshint.inspection.message.malformed.config=형식이 잘못된 JSHint 구성
jshint.inspection.message.prefix=JSHint\:

jshint.option.esversion.description.short=지정된 ECMAScript 버전과의 비호환성 경고
jshint.option.latedef.description.short=변수가 정의되기 전에 사용되는 경우 경고
jshint.option.unused.description.short=사용되지 않는 변수에 대해 경고
jshint.option.indent.description.short=들여쓰기
jshint.option.quotmark.description.short=따옴표 표시
jshint.option.predef.details=전역 변수 및 해당 변수의 대입 가능한 상태를 지정합니다.\n<pre>DISQUS\:true, jQuery\:false</pre>\n<p/>여기에서 JSHint를 사용하면 DISQUS를 재정의할 수 있지만\n jQuery를 재정의하려고 하면 오류가 표시됩니다.
jshint.option.bitwise.description.short=비트 연산자 사용 시 경고
jshint.option.camelcase.description.short=변수 이름 지정 시 경고
jshint.option.curly.description.short=블록에서 <code>{}</code>가 생략될 시 경고
jshint.option.enforceall.description.short=코드가 가장 엄격한 구성을 준수하지 않을 시 경고
jshint.option.eqeqeq.description.short=안전하지 않은 비교 시 경고
jshint.option.es3.description.short=ES3 사양과의 비호환성 경고
jshint.option.es5.description.short=ES5 사양과의 비호환성 경고
jshint.option.forin.description.short=안전하지 않은 <code>for..in</code>에 대해 경고
jshint.option.freeze.description.short=네이티브 객체의 프로토타입을 덮어쓸 시 경고
jshint.option.immed.description.short=괄호로 묶지 않은 채 즉시 함수 호출을 사용하는 경우 경고
jshint.option.newcap.description.short=대문자가 없는 생성자의 사용에 대해 경고
jshint.option.noarg.description.short=<code>arguments.caller</code> 및 <code>.callee</code>에 대해 경고
jshint.option.nocomma.description.short=쉼표 연산자 사용 시 경고
jshint.option.noempty.description.short=빈 블록에 대해 경고
jshint.option.nonbsp.description.short="줄 바꿈 없는 공백" 문자에 대해 경고
jshint.option.nonew.description.short=부작용 관련 <code>new</code>의 사용에 대해 경고
jshint.option.plusplus.description.short=단항 증가 및 감소 연산자 사용에 대해 경고
jshint.option.undef.description.short=변수가 정의되지 않은 경우 경고
jshint.option.varstmt.description.short=VariableStatements의 사용에 대해 경고
jshint.option.strict.description.short=코드가 엄격 모드에 있지 않은 경우 경고
jshint.option.trailing.description.short=후행 공백에 대해 경고
jshint.option.maxparams.description.short=함수 내 형식 매개변수의 최대 수
jshint.option.maxdepth.description.short=블록의 최대 깊이
jshint.option.maxstatements.description.short=함수 내 구문의 최대 수
jshint.option.maxcomplexity.description.short=코드 내 최대 순환 복잡성
jshint.option.maxlen.description.short=줄의 최대 길이
jshint.option.asi.description.short=세미콜론 누락에 대한 경고 억제
jshint.option.boss.description.short=<code>if/for/...</code> 내 대입에 대한 경고 억제
jshint.option.debug.description.short=코드 디버그에 대한 경고 억제
jshint.option.elision.description.short=ES3 배열 제거 요소에 대한 경고 표시 억제
jshint.option.eqnull.description.short=<code>\=\= null</code>에 대한 경고 억제
jshint.option.esnext.description.short=EcmaScript.next
jshint.option.evil.description.short=<code>eval</code>에 대한 경고 억제
jshint.option.expr.description.short=표현식을 구문으로서 사용하는 것에 대한 경고 억제
jshint.option.funcscope.description.short=선언된 블록 외부에서의 변수 사용에 대한 경고 억제
jshint.option.futurehostile.description.short=향후 JavaScript 버전에서 정의된 식별자 사용 시 경고
jshint.option.gcl.description.short=JSHint를 Google Closure Compiler와 호환되도록 설정
jshint.option.globalstrict.description.short=전역 엄격 모드 사용에 대한 경고 억제
jshint.option.iterator.description.short=<code>__iterator__</code> 프로퍼티에 대한 경고 억제
jshint.option.lastsemic.description.short=한 줄 블록의 마지막 구문에서 세미콜론이 생략된 경우에만 세미콜론 누락에 대한 경고를 억제
jshint.option.laxbreak.description.short=안전하지 않은 줄 바꿈에 대한 경고 억제
jshint.option.laxcomma.description.short=쉼표 우선 코딩 스타일에 대한 경고 억제
jshint.option.loopfunc.description.short=루프 내 함수에 대한 경고 억제
jshint.option.moz.description.short=코드에서 Mozilla JavaScript 확장 프로그램을 사용하는지 확인
jshint.option.multistr.description.short=여러 줄 문자열에 대한 경고 억제
jshint.option.notypeof.description.short=잘못된 <code>typeof</code> 연산자 값에 대한 경고 억제
jshint.option.proto.description.short=<code>__proto__</code> 프로퍼티에 대한 경고 억제
jshint.option.scripturl.description.short=스크립트 대상 URL 사용에 대한 경고 억제
jshint.option.smarttabs.description.short=공백이 정렬에만 사용되고 탭과 공백이 혼재되어 있는 경우에 대한 경고 억제
jshint.option.shadow.description.short=변수 그림자화에 대한 경고 억제
jshint.option.singlegroups.description.short=엄밀히 필요하지 않은 경우 그룹화 연산자의 사용 금지
jshint.option.sub.description.short=점 표기로 표현할 수 있는 경우 <code>[]</code> 표기를 사용하는 것에 대한 경고 억제
jshint.option.supernew.description.short="이상한" 생성에 대한 경고 억제
jshint.option.validthis.description.short=가능한 엄격한 위반에 대한 경고 억제
jshint.option.withstmt.description.short=with 문 사용에 대한 경고 억제
jshint.option.noyield.description.short=yield 문이 없는 생성기 함수에 대한 경고 억제
jshint.option.browser.description.short=브라우저
jshint.option.devel.description.short=개발
jshint.option.nonstandard.description.short=이스케이프 및 이스케이프 해제
jshint.option.typed.description.short=유형 지정된 배열
jshint.option.worker.description.short=Web Worker
jshint.option.wsh.description.short=Windows Script Host
jshint.option.module.description.short=ECMAScript 6 모듈
jshint.option.nomen.description.short=변수 내에서 _ 사용 허용 안 함
jshint.option.onevar.description.short=함수당 var 문 1개
jshint.option.passfail.description.short=첫 오류 시 중지
jshint.option.white.description.short=지저분한 공백 허용 안 함
jshint.option.maxerr.description.short=최대 오류 수
jshint.option.predef.description.short=사전 정의됨( , 구분)

#common linters
javascript.linter.import.error.timeout.processing.configuration.file=구성 파일 처리가 시간 초과되었습니다
javascript.linter.import.error.generic=구성 파일의 코드 스타일 규칙을 적용하는 동안 오류가 발생했습니다. 이는 구성 파일이 올바르지 않기 때문일 수 있습니다.
javascript.linter.import.error.package.not.found=''{0}'' 패키지를 찾을 수 없습니다
javascript.linter.import.error.entry.point.not.found=''{0}'' 패키지에서 진입점을 찾을 수 없습니다
javascript.linter.import.error.bin.file.not.found=''{1}'' 패키지에서 ''{0}''을(를) 찾을 수 없습니다
javascript.linter.import.notification={0}\: 프로젝트 코드 스타일 및 에디터 설정이 ''{1}''을(를) 기반으로 업데이트되었습니다.
javascript.linter.import.notification.edit=''{0}'' 편집
javascript.linter.import.notification.rules.applied=다음 {0} 적용\: {1}
javascript.linter.import.notification.reset=Restablecer
javascript.linter.import.notification.restored=디폴트 코드 스타일 및 에디터 설정이 복원되었습니다
javascript.linter.import.translate.config.title=ESLint 코드 스타일 규칙 적용
javascript.linter.import.translate.config.description=ESLint 코드 스타일 규칙 적용
javascript.linter.import.translate.config.progress.title={0} 코드 스타일 규칙 적용 중
javascript.linter.import.translate.config.file.error=코드 스타일 규칙을 적용할 수 없습니다
javascript.linter.import.nothing.to.import={0}\: 알려진 모든 규칙이 이미 적용되었습니다
javascript.linter.use.severity.from.config.label=설정 파일에서 규칙 중요도 사용
javascript.linter.configuration.file.title=구성 파일
javascript.linter.radio.button.configuration.file=구성 파일(&C)\:
javascript.linter.error.empty.path=빈 경로
javascript.linter.error.no.such.file=해당 파일 없음
javascript.linter.error.specify.correct.path.to=올바른 {0} 경로를 지정하세요
javascript.linter.error.failed.to.lint={0} Lint에 실패했습니다
javascript.linter.error.can.not.find.psi.file={0}에 대한 PSI 파일을 찾을 수 없습니다
javascript.linter.error.can.not.find.document={0}에 대한 문서를 찾을 수 없습니다
javascript.linter.error.notification.problem.with.reformatting={0}의 서식을 다시 지정하는 데 문제가 발생했습니다.<br/>{1}
javascript.linter.error.no.path.to.package=''{0}'' 패키지의 경로를 지정하세요
javascript.linter.error.package.not.installed=''{0}'' 패키지를 설치하세요
javascript.linter.error.invalid.path.to.package=''{0}'' 패키지의 경로를 올바르게 지정하세요
dialog.message.please.specify.stylelint.package.correctly=Stylelint 패키지를 올바르게 지정하세요. stylelint 바이너리를 찾을 수 없습니다

javascript.linter.action.edit.config={0} 편집
javascript.linter.action.edit.property={1} 내 {0} 편집
javascript.linter.action.edit.settings.text={0} 설정...
javascript.linter.action.fix.prompt={0}(으)로 선택한 파일의 서식을 다시 지정하시겠어요?
javascript.linter.action.fix.problems.file.text={0}\: 현재 파일 수정
javascript.linter.action.fix.problems.name={0} 문제 해결
javascript.linter.action.fix.problems.name.start={0} 문제 해결이 시작되었습니다
javascript.linter.action.fix.problems.name.finish={0} 문제 해결이 완료되었습니다
javascript.linter.configurable.config.autoSearch.title=자동 검색(&S)
javascript.linter.suppress.rules.for.line.family.name=현재 줄 억제
javascript.linter.suppress.rule.for.line.description=현재 줄의 ''{0}'' 억제
javascript.linter.suppress.all.rules.for.line.description=현재 줄의 모든 {0} 규칙 억제
javascript.linter.suppress.rules.for.file.family.name=현재 파일 억제
javascript.linter.suppress.rule.for.file.description=현재 파일의 ''{0}'' 억제
javascript.linter.suppress.all.rules.for.file.description=현재 파일의 모든 {0} 규칙 억제
javascript.linter.progress.reformatting.with={0} 을(를) 사용해 서식 다시 지정 중...

javascript.linter.intention.name.details=세부 정보
javascript.linter.intention.family.name.show.details={0}\: 세부 정보 표시

# eslint
settings.javascript.linters.eslint.configurable.name=ESLint
eslint.configurable.eslintPackage.label=ESLint 패키지(&E)\:
eslint.configurable.config.autoSearch.description.bodyInnerHtml=ESLint는 린팅할 파일이 위치한 파일 디렉터리에서와 파일 시스템의 루트 디렉터리까지 모든 상위 디렉터리에서 .eslintrc.* 및 package.json 파일을 자동으로 찾습니다. <div style\="padding-top\:8px">package.json을 사용하려면 <code>eslintConfig</code> 프로퍼티 아래에 설정을 추가하세요. 
eslint.configurable.label.working.directories=작업 디렉터리(&W)\:
eslint.configurable.working.dir.field.empty.text=가장 가까운 .eslintrc 또는 .eslintignore로 탐지
eslint.configurable.working.directories.comment=<html>경로 또는 <a href\=''https\://github.com/isaacs/node-glob\#glob-primer''>glob 패턴</a>을 세미콜론으로 구분합니다. 자동 탐지를 위해 비워두세요.</html>
eslint.configurable.config.select.config.text=ESLint 설정 파일 선택(*.eslintrc.*)
eslint.configurable.additionalRulesDir.label=추가 규칙 디렉터리(&R)\:
eslint.configurable.additionalRulesDir.browseDialogTitle=ESLint 추가 규칙 디렉터리 선택
eslint.configurable.extraOptions.label=추가 eslint 옵션(&O)\:
eslint.run.on.save=저장 시 eslint --fix 실행(&U)
eslint.action.fix.problems.description=''eslint --fix''를 호출하여 ESLint 문제를 해결합니다
eslint.fix.problems.text.with.error.code={0}\: ''{1}'' 수정
eslint.fix.problems.text.current={0}\: 현재 오류 수정
eslint.fix.problems.family.name={0}\: 현재 오류 수정
eslint.error.package.directory.expected=패키지 디렉터리 예상
eslint.code.style.apply.message=ESLint에 코드 스타일을 적용하시겠어요?
eslint.code.style.dismiss.text=아니오
eslint.code.style.apply.text=예
eslint.version.0.is.not.supported.please.upgrade.eslint=ESLint {0} 버전은 지원되지 않습니다. ESLint를 업그레이드하세요.
eslint.additional.rules.directory.field.name=추가 규칙 디렉터리
eslint.configuration.file.field.name=ESLint 구성 파일
eslint.inspections.error.can.not.parse.message=메시지를 분석할 수 없습니다. json 객체가 필요하지만 {0}을(를) 얻었습니다
eslint.inspections.error.messages.not.array=메시지가 배열이 아닙니다. {0}
eslint.inspections.error.unexpected.language.service.response=예기치 않은 언어 서비스 응답\: {0}
eslint.inspections.error.unknown.message.severity=알 수 없는 메시지 심각도\: {0}\n본문\:\n{1}

#standardJS
standardjs.name=표준 코드 스타일
standardjs.editor.notification.can.be.enabled.text=이 프로젝트에 JavaScript 표준 코드 스타일을 사용하시겠어요?
standardjs.editor.notification.action=예
standardjs.editor.notification.do.not.show.text=아니오
standardjs.edit.settings.caption=ESlint/표준 코드 스타일
standardjs.action.fix.problems.description=표준 코드 스타일 문제 해결
standardjs.error.unsupported.package=지원되지 않는 패키지 버전입니다. ''표준'' 패키지를 최소 버전 {0}(으)로 업그레이드하세요
standardjs.codestyle.updated={0}\: 프로젝트 코드 스타일 설정이 업데이트되었습니다
standardjs.codestyle.updated.config.section={0}\: 프로젝트 코드 스타일 설정이 package.json의 ''standard'' 섹션을 기반으로 업데이트되었습니다
standardjs.codestyle.updated.dependency={0}\: 프로젝트 코드 스타일 설정이 package.json의 ''standard'' 종속성을 기반으로 업데이트되었습니다

# Acciones
js.show.type.info.action.error=No se encontró ninguna expresión
javascript.ignore.unused.function.parameters=Ignore los parámetros no utilizados:
javascript.ignore.unused.catch.parameters=Ignorar los parámetros de captura no utilizados
complete.import.binding=Enlace de importación completo
complete.import.name=Nombre de importación completo
remove.type.prefix=Eliminar prefijo de tipo
add.import.binding.to.import=Agregar enlace de importación a la importación
add.import.specifier.to.import=Agregar especificador de importación a la importación
create.js.file.description=Crea un archivo JavaScript a partir de la plantilla especificada
create.ts.file.description=Crea un nuevo archivo TypeScript
create.file.name=파일 ''{0}'' 생성
create.file.name.with={1}이(가) 있는 파일 ''{0}'' 생성
create.file.name.with.and={1} 및 {2}이(가) 있는 파일 ''{0}'' 생성
class.names={0,choice,1\#클래스|2\#클래스} {1}
function.names={0,choice,1\#함수|2\#함수} {1}

# todo eliminar, tiene usos externos
javascript.completion.several.definitions=(varias definiciones)

# File watchers
js.file.watcher.6to5.description=Babel을 사용하여 ECMAScript 6 코드를 ECMAScript 5 코드로 변환
editor.notification.label.enable.babel.file.watcher.question=파일 감시기가 Babel을 사용하여 ECMAScript 6을 ECMAScript 5로 변환하도록 설정하시겠어요?

# Anotador
typescript.export.assignment.cannot.be.used.in.internal.modules=La asignación de exportación no se puede utilizar en módulos internos
typescript.type.predicate.not.return=Un predicado de tipo solo se permite en la posición de tipo de retorno para funciones y métodos
typescript.type.this.predicate.not.return=Un predicado de tipo basado en 'this' solo se permite dentro de una clase o miembros de la interfaz, obtener accesores o devolver posiciones de tipo para funciones y métodos.
typescript.type.predicate.not.match.name=No se puede encontrar el parámetro {0}
typescript.type.predicate.rest=Un predicado de tipo no puede hacer referencia a un parámetro de descanso
typescript.type.predicate.destructuring=Un predicado de tipo no puede hacer referencia a un elemento en un patrón de vinculación.
typescript.type.predicate.incompatible.types=El predicado de tipo no se puede asignar a {0}
typescript.generics.should.not.be=El tipo ''{0}'' no es genérico
es6.default.export.not.declared=La exportación predeterminada no se declara en el módulo importado
js.annotator.assignment.pattern.rhs=Los patrones de asignación deben estar en el lado izquierdo de la asignación
es6.generate.index.action=Generar index.js/index.ts
es6.generate.index.action.description=Generar index.js/index.ts
js.annotator.thin.arrow.used=얇은 화살표가 사용되었습니다
js.annotator.newline.before.arrow=화살표 앞에 줄 바꿈이 허용되지 않습니다
js.annotator.replace.with.fat.arrow=굵은 화살표로 바꾸기
js.annotator.unary.operator.within.exponential=지수식 바로 앞에서 단항 연산자 ''{0}'' 이(가) 허용되지 않습니다. 모호성 해결을 위해 소괄호를 추가하세요.

# Plantillas en vivo
jsx.html.context.type=JSX HTML
js.expression.context.type=Expresión
js.statement.context.type=Declaración
js.top.level.statement.context.type=Sintaxis de nivel superior
js.class.context.type=Clase/Interfaz
ecmascript.6.or.higher=ECMAScript 6 o superior

# Gulp
gulp.rc.gulpfile.label=Arc&hivo Gulp:
gulp.rc.gulpfile.browseDialogTitle=Seleccione gulpfile.js
gulp.rc.tasks.label=&Tareas:
gulp.rc.arguments.label=&Argumentos:
gulp.rc.nodeInterpreter.label=&Intérprete de Node:
gulp.rc.nodeOptions.label=&Opción de Node:
gulp.rc.gulpPackage.label=Paquete &Gulp:
gulp.rc.environmentVariables.label=&Entorno:
gulp.task.title=Tarea de Gulp
gulp.before.run.task=Ejecutar la tarea Gulp
gulp.before.run.task.descr=gulp {0, choice, 0\#작업|1\#작업 |2\#작업 }{1} [{2}] 실행
gulp.gulpfile.unspecified=Gulpfile이 지정되지 않았습니다
gulp.gulpfile.not.found=Gulpfile을 찾을 수 없습니다

# Gruñido
grunt.rc.gruntfile.label=Grunt &archivo:
grunt.rc.gruntfile.browseDialogTitle=Seleccione Gruntfile
grunt.rc.tasks.label=&Tareas:
grunt.rc.arguments.label=&Argumentos:
grunt.rc.nodeInterpreter.label=Nodo e intérprete:
grunt.rc.nodeOptions.label=Nodo y opciones:
grunt.rc.gruntCliPackage.label=&Paquete grunt-cli:
grunt.rc.environmentVariables.label=&Entorno:
grunt.task.title=Tarea gruñona
grunt.before.run.task=Ejecutar tarea de Grunt
grunt.before.run.task.descr=Ejecutar {0,choice,0#tarea|1#tarea|2#tareas} Grunt {1} [{2}]
grunt.unspecified.gruntfile=지정되지 않은 Gruntfile
grunt.gruntfile.not.found=Gruntfile을 찾을 수 없습니다

#nodo
settings.nodejs.name=Node.js y NPM
settings.nodejs.coding.assistance.label=Codificación y asistencia para Node.js
settings.nodejs.coding.assistance.manage.scopes.label=Administrar alcances...

node.interpreter.label=&Intérprete de Node:
node.interpreter.unspecified.error.text=Especifique el intérprete de Node.js
node.package.manager.label=Paquete y administrador:
node.package.empty.hint=ruta al directorio del paquete {0}
node.package.empty.hint.pkg1.or.pkg2={0} o {1}
node.package.selector.single.package.title=Seleccione {0} Directorio de paquetes
node.package.selector.multiple.packages.title=Seleccionar directorio de paquetes
node.package.selector.multiple.packages.description=Seleccione {0}
node.package.none=Sin paquete
node.package.dropDownList.select=Seleccionar...

node.js.modules.dependencies.missing.family.name=falta la llamada require()
inspection.NodeCoreCodingAssistanceInspection.no.coding.assistance.message=Node.js에 대한 코딩 지원이 비활성화되었습니다
action.ToggleNodeCoreCodingAssistanceAction.toggle.coding.assistance.for.node.js.text=Node.js에 대한 코딩 지원 전환

#npm
npm.rc.packageJson.label=&package.json:
npm.rc.packageJson.browseDialogTitle=Seleccionar archivo package.json
npm.rc.command.label=&Comando:
npm.rc.scripts.label=Scrip&ts:
npm.rc.scriptsArguments.label=A&rgumentos:
npm.rc.nodeInterpreter.label=&Intérprete de Node:
npm.rc.nodeOptions.label=Opciones de nodo:
npm.rc.environmentVariables.label=Entorno:
npm.task.title=Secuencia de comandos de NPM
npm.before.run.task=Ejecutar el script npm
npm.before.run.task.descr=npm {0, choice, 0\#스크립트|1\#스크립트 |2\#스크립트 }{1} [{2}] 실행 
npm.dialog.message.cannot.resolve.package.manager=''{0}'' 패키지 관리자를 해결할 수 없습니다
npm.no.scripts.found=스크립트를 찾을 수 없습니다
dialog.message.unspecified.package=지정되지 않은 {0} 패키지
dialog.message.invalid.package.file.specified.but.directory.with.package.json.expected=잘못된 {0} 패키지\: 파일이 지정되었지만 package.json이 있는 디렉터리가 필요합니다
dialog.message.invalid.package.no.such.directory=잘못된 {0} 패키지\: 해당 디렉터리가 없습니다
dialog.message.invalid.npx.command=잘못된 npx 명령어
dialog.message.package.yarn.installed.package.format.yarn.relative.path.to.package.json.package.name={0} 패키지\: Yarn 설치 패키지 형식은 ''yarn\:[package.json의 상대 경로]\:[패키지 이름]''입니다.
dialog.message.no.path.to.package.json.found=package.json 경로를 찾을 수 없습니다.
dialog.message.unspecified.package.name=패키지 이름이 지정되지 않았습니다.
dialog.message.invalid.package.no.such.file=잘못된 {0} 패키지\: 해당 파일이 없습니다
enable.notifications.about.installing.dependencies.from.package.json=package.json으로부터 종속성 설치 시 알림 활성화
notification.content.notifications.are.enabled.for.current.package.json=현재 package.json에 대한 알림이 활성화됩니다
notification.content.notifications.are.enabled.for.all.package.json.files=모든 package.json 파일에 대한 알림이 활성화됩니다
dialog.message.please.specify.npm.or.yarn.package.cannot.find.inside.directory=npm 또는 yarn 패키지를 지정하세요. "{1}" 디렉터리에서 "{0}"을(를) 찾을 수 없습니다
dialog.message.please.correct.path.to.npm.or.yarn.package.no.such.directory=npm 또는 yarn 패키지의 경로를 수정하세요. "{0}" 디렉터리가 없습니다

#build tools
buildTools.JsbtRunTaskAction.text=Ejecutar la tarea Gulp/Grunt/npm
buildTools.JsbtAddBuildfileAction.text=Agregar {0}
buildTools.choose_buildfile.text=Elija {0}
buildTools.JsbtRemoveBuildfileAction.text=Eliminar {0}
buildTools.JsbtReloadTasksAction.text=Recargar tareas
buildTools.JsbtReloadTasksAction.npm.text=Recargar scripts
buildTools.JsbtShowTasksAction.text=Mostrar {0} tareas
buildTools.JsbtShowTasksAction.npm.text=Mostrar scripts npm
buildTools.searchEverywhere.text=Ejecutar tarea ''{0}''
buildTools.searchEverywhere.npm.text=Ejecutar secuencia de comandos npm ''{0}''
buildTools.ShowSettingsAction.text={0} Configuración...
buildTools.ShowSettingsAction.npm.text=&Editar configuraciones de npm...
buildTools.EditRunSettingsAction.text=&Editar ''{0}'' Configuración...
buildTools.tree.sortBy.text=Ordenar por
buildTools.tree.sortBy.definitionOrder.text=Orden de definición
buildTools.tree.sortBy.name.text=Nombre
buildTools.no.tasks.found=작업을 찾을 수 없습니다
buildTools.edit.run.configuration=실행 구성 편집
buildTools.no.files.added=추가된 파일이 없습니다
buildTools.add.with={1}(으)로 {0} 추가
buildTools.no.such.file=해당 파일 없음
buildTools.failed.to.list.tasks=작업을 나열하지 못했습니다
buildTools.failed.to.list.tasks.details.reference=세부 정보
buildTools.tooltip.click.to.show.error.details=클릭하여 오류 세부 정보 표시

#módulos npm
npm.modules.inspection.content.of.require.not.in.dependencies.warning=El módulo no aparece en las dependencias de package.json
npm.modules.inspection.content.of.require.module.not.installed.warning=El módulo no está instalado
npm.modules.install.global.types.fix.name=Instale las definiciones de TypeScript para obtener una mejor información de tipos
package.json.install.types.fix.family.name=Instalar @types para el paquete
node.js.quickfix.install.node.module.with.dev.dependencies.text=Instalar ''{0}'' como dependencia de desarrollo
node.js.quickfix.install.node.module.text=Instalar ''{0}''
node.js.quickfix.install.node.module.family.name=Instalar módulos
node.js.quickfix.install.node.module.devDependencies.family.name=Instalar módulos como dependencias de desarrollo
node.js.quickfix.install.node.module.update.modules.family.name=Ejecute 'npm install'
node.js.quickfix.run.command=Ejecutar ''{0}''
node.js.quickfix.install.node.module.error.prefix.text=No se puede instalar el módulo Node.js: {0}
node.js.quickfix.install.node.module.error.no.interpreter.text=No se puede instalar el módulo Node.js: especifique el intérprete Node.js predeterminado.
node.js.quickfix.install.node.module.error.no.interpreter.title=Instalar el módulo Node.js
node.js.select.file=Seleccione {0} archivo
dialog.message.cannot.determine.package.json.directory=package.json 디렉터리를 확인할 수 없습니다
action.InstallNodeLocalDependencies.text=Node.js 종속성 설치
action.InstallNodeLocalDependencies$Root.text={1}에 대한 ''{0}'' 실행

typescript.types.module.not.installed.warning=No se pueden resolver las definiciones del módulo ''{0}''
npm.modules.install.global.types.directory.error=No se pueden crear los directorios necesarios
npm.modules.install.global.types.dialog.title=Instalar definiciones de TypeScript

typescript.types.union=Unión
typescript.types.intersection=Intersección
typescript.types.mapped=Asignado
typescript.types.key=Referencia clave a
typescript.types.merged=fusionado
typescript.types.merged.accessor=Accesor combinado
typescript.types.type.member={0} propiedad de tipo
typescript.types.merged.parts=Propiedades referenciadas:

# Intenciones
ts.generate.reference.path.name=참조 경로 주석 생성
ts.add.import.statement.family.name=import 문추가
ts.add.import.statement.dialog.title=import 문 추가
ts.add.import.all.family.name=모호하지 않은 import 문 모두 추가
ts.add.import.hint.text={1}(으)로 {0} 추가
ts.add.import.hint.multiple.text={1}(으)로 {0} import 문 추가
ts.add.import.hint.all.part=또는 {0} 이(가) 있는 모든 import 문
ts.change.import.action.one.title={0}로 변경
ts.change.import.action.many.title=가져오기 변경...
ts.change.import.action.command=가져오기 변경
ts.change.import.action.family.name=ES6 가져오기 변경
ts.change.import.action.dialog.title=...으로부터 가져오기
ts.convert.alias.to.interface.action.title=별칭을 인터페이스로 변환
ts.convert.alias.to.interface.action.family.name=유형 별칭을 인터페이스로 변환
ts.convert.alias.to.enum.action.title=별칭을 열거형으로 변환
ts.convert.alias.to.enum.action.family.name=유형 별칭을 열거형으로 변환
ts.convert.parameter.property.to.field=매개변수 프로퍼티를 클래스 필드로 변환
ts.convert.field.to.parameter.property=필드를 매개변수 프로퍼티로 변환
anonymous.to.named.intention.function.name=함수 이름\:
initialize.fields.intention.visibility=가시성\:
command.name.import={0} 가져오기
please.specify.package.manager=<a href\=''>패키지 관리자</a>를 지정하세요.
please.specify.local.node.js.interpreter.in.node.js.and.npm={0}에서 로컬 Node.js 인터프리터를 지정하세요
intention.name.add.file.to.tsconfig=파일 ''{0}''을(를) tsconfig.json에 추가
intention.name.import.augmentation=증강 {0} 가져오기

# Servicio de lenguaje
javascript.language.service.default.empty.text=Sin errores
javascript.language.service.tracking.disabled=El seguimiento de errores está deshabilitado
javascript.language.service.tracking.is.not.started=El servicio no se inició
javascript.language.service.default.project.errors=Mostrar errores del proyecto
javascript.service.node.error=La ruta del intérprete de nodo es incorrecta. Verifique la configuración del intérprete
javascript.starting.service=Iniciando servicio {0}
javascript.language.service.cannot.get.results=No se pueden obtener resultados del servicio de lenguajes.
javascript.language.service.start.timeout=Tiempo de espera al iniciar el proceso de servicio de lengaje
javascript.language.service.cannot.start=No se pudo iniciar el proceso del servicio de lenguaje.
cannot.parse.service.initialization.answer.0=서비스 초기화 응답 {0}을(를) 분석할 수 없습니다\n
tab.title.errors=Error
tab.title.project.errors=프로젝트 오류
tab.title.compile.errors=컴파일 오류
dialog.message.no.results.for.after={1} 후에 {0}의 결과가 없습니다
intention.name.loading.service.fixes=서비스 수정 로드 중...

# TypeScript Compiler
typescript.compiler.notification.editor.configure=TypeScript 구성...
typescript.compiler.configurable.name=TypeScript
typescript.use.service.configurable.options.enable=TypeScript 언어 서비스
typescript.compiler.configurable.options.output.path=출력 경로 사용\:
typescript.compiler.configurable.options.compile.main=main 파일만 컴파일\:
typescript.compiler.configurable.options.compile.main.error=main 파일에 대한 잘못된 경로
typescript.compiler.configurable.options.version=TypeScript\:
typescript.compiler.configurable.options.generate.source.map=소스 맵 생성
typescript.compiler.configurable.options.enable.no.config=tsconfig.json이 없는 프로젝트인 경우도
typescript.compiler.configurable.options.track.file.system=변경 시 다시 컴파일
typescript.compiler.configurable.options.scope=컴파일 범위\:
typescript.compiler.configurable.options.command.line=옵션\:
dialog.message.cannot.compile.typescript.config.file.incorrect=TypeScript를 컴파일할 수 없습니다. 구성 파일이 잘못되었습니다
intention.family.name.suppress.with.ts.ignore=@ts-ignore로 억제
typescript.compiler.structure.tab.title=구조
typescript.compiler.starting=TypeScript 시작 중...

typescript.service.no.config=파일이 tsconfig.json에 포함되어 있지 않습니다.
typescript.service.no.main.reference=파일이 main 파일에서 참조되지 않아 처리되지 않았습니다


js.tool.window.limit=첫 {0}개의 오류가 표시됩니다.
js.tool.window.limit.all=모든 {0} 오류 표시
typescript.compiler.action.compile.all=모두 컴파일
typescript.compiler.action.compile.toolbar=컴파일
typescript.compiler.action.compile.all.description=모든 프로젝트 파일 컴파일
typescript.service.action.restart=TypeScript 서비스 다시 시작
typescript.compiler.action.compile.all.compile.config=구성 {0}을 위한 파일 컴파일
typescript.compiler.action.compile.current=현재 파일 컴파일
typescript.compiler.action.compile.simple=TypeScript 컴파일
typescript.compiler.action.compile.description=현재 프로젝트 컴파일
typescript.compiler.action.no.compile.message=파일이 main 파일에서 참조되지 않아 컴파일되지 않았습니다
typescript.compiler.before.run=TypeScript 컴파일

typescript.language.service.clean=Restablecer cachés
typescript.language.service.compile.file=Archivo de compilación... {0}
typescript.language.service.compile.project=Proyecto de compilación... {0}
typescript.language.service.compile.file.errors=Calculando errores... {0}
typescript.language.service.compile.project.errors=Calculando errores del proyecto... {0}
typescript.language.service.compile.project.open.file=Abriendo archivo... {0}

typescript.before.task.check.errors=Comprobar errores
typescript.before.task.config.path=Archivo de configuración:
typescript.before.task.title=Configuración de compilación de TypeScript
typescript.before.task.config.dialog.title=Seleccione tsconfig.json

# Documentación
js.documentation.fires=Incendios:
js.documentation.more.overload=+{0} más sobrecarga
js.documentation.more.overloads=+{0} más sobrecargas

node.js.remote.interpreters.plugin.missing=Node.js 원격 인터프리터 플러그인이 없습니다. {0} 플러그인을 활성화하세요.

# Module Dependencies
javascript.module.dependencies.got.it.title=Diagrama de dependencias del módulo
javascript.module.dependencies.got.it.text=<div align\=''left''>이 다이어그램은 선택한 파일 또는 디렉터리가 지닌 모듈 종속성을 시각화합니다.<br/>여러 파일 또는 디렉터리에 대한 종속성을 보려면 선택 영역의 컨텍스트 메뉴에서 <i>프로젝트 뷰</i><br/>및 <i>다이어그램 - 다이어그램 표시</i>를 선택하세요.</div>
javascript.module.dependencies.empty.got.it.text=<div align\=''left''>현재 파일 또는 폴더에 종속성이 없습니다.<br/>다른 파일 또는 폴더로 시도하세요.</div>
modules.selected=선택됨

js.remove.redundant.initializer.fix=Eliminar inicializador redundante
js.remove.unused.assignment=Eliminar asignación no utilizada
js.inject.with.comment.intention.family.name=Anotar inyección con comentario
js.inject.dont.format.intention.text=No formatee el contenido inyectado

js.webpack.config.highlighting.name=Validación de la configuración del paquete web

js.linter.guesser.linter.enabled.because.of.dependency={0} está habilitado: ''{1}'' aparece en package.json.
js.linter.guesser.linter.enabled.because.of.package.json.section={0} está habilitado: ''{1}'' está en package.json.
js.linter.guesser.linter.enabled.because.of.config.file={0} está habilitado: el archivo de configuración está en el proyecto.
js.linter.guesser.linter.disabled={0} está deshabilitado.

# Migas de pan
js.breadcrumbs.callback.for=devolución de llamada para {0}()

typescript.extract.type.alias.name=Tipo de alias...
typescript.include.js.sources.element=Buscar declaración de JavaScript
typescript.include.js.sources.dialog.title=Incluir paquete {0}
typescript.include.js.sources.dialog.message=¿Incluir archivos JavaScript de ''{0}'' al proyecto?
start.template.string.interpolation.on.typing=Iniciar la interpolación de cadenas de la plantilla al escribir '$'
typescript.include.js.sources.action=Incluir archivos JavaScript
escape.pasted.text=Texto de escape al pegar en cadenas literales
jsx.convert.html.attributes.to.jsx=Convertir atributos al pegar HTML en archivos JSX

# Rename member
rename.prompt.do.you.want.to.rename.base.method=기본 메서드의 이름을 변경하시겠어요?
js.rename.base.member=기본 {0}의 이름 변경
js.rename.current.member=현재 {0}의 이름 변경
js.rename.member.title={3}의 {0} {1} {2}
js.rename.member.title.implements=구현
js.rename.member.title.overrides=재정의

# Generar diálogo
generate.filter.indexers=Indexadores
generate.filter.methods=Métodos
generate.filter.fields=Campos y propiedades
generate.filter.button.tooltip=Mostrar {0}
generate.filter.button.description=Mostrar {0} en la lista
codestyle.ui.field.prefix=&prefijo de campo:
codestyle.ui.property.prefix=&Prefijo de propiedad:
codestyle.ui.file.name.style=Convención de nombre y archivo:
codestyle.ui.generated.jsdoc.use.types.checkbox=Incluir &tipos en JSDoc
inline.type.used.in.reference.list=''{0}'' 목록에서 사용을 인라인화할 수 없습니다
inline.cannot.inline.references.this.type=''this'' 유형을 참조하는 인터페이스를 인라인화할 수 없습니다
inline.cannot.inline.has.supers=다른 유형을 확장하는 {0} 을(를) 인라인화할 수 없습니다
generation.bindable.event=바인드 가능한 이벤트(&B)\:
generation.event.constant=이벤트 상수(&E)\:

refactoring.extract.react.component.component.for.refactor.this=Componente...
refactoring.extract.react.component.title=구성 요소 추출
refactoring.extract.react.component.no.expression=선택 영역이 JSX 식을 형성하지 않습니다
refactoring.extract.react.component.no.scope=생성된 구성 요소를 배치할 범위를 찾을 수 없습니다
refactoring.create.react.component.title=구성 요소 생성
refactoring.react.function.to.class.refactoring.title=클래스 구성 요소로 변환
refactoring.react.function.to.class.intention.title=클래스 구성 요소로 변환
refactoring.react.function.to.class.used.in.new.conflict={0} 이(가) ''new'' 표현식에 사용됩니다
refactoring.react.function.to.class.used.in.call.conflict={0} 이(가) 호출 표현식에 사용됩니다
refactoring.react.class.to.function.conflict.used.with.ref={0} 이(가) ''ref'' 속성과 함께 사용됩니다. 무상태 함수 구성 요소는 참조를 지정할 수 없습니다
refactoring.react.class.to.function.refactoring.title=함수 구성 요소로 변환
refactoring.react.class.to.function.intention.title=함수 구성 요소로 변환
refactoring.react.could.not.find.in.template=리팩터링에 실패했습니다. 이름 {0}(으)로 요소를 찾을 수 없습니다. 코드 템플릿 {1} 이(가) 유효하지 않습니까?
react.function.to.class.caret.at.function=캐럿은 변환할 함수에 위치해야 합니다
react.class.to.function.caret.at.class=캐럿이 변환할 클래스에 위치해야 합니다
react.class.component.type.class=클래스
react.class.component.type.function=함수

js.arrangement.group.arrow.fields.with.methods=메서드를 사용하여 화살표 함수로 초기화된 필드 그룹화
intellilang.tagged.literal.injection.name.label=패턴
intellilang.tagged.literal.expression.border.title=템플릿 태그

refactoring.destructuring.vars.for.refactor.this=Desestructuración de objetos o matrices...
refactoring.destructuring.vars.intention.name=Introducir objeto o desestructuración de matriz
refactoring.destructuring.vars.intention.name.object=Introducir la desestructuración de objetos
refactoring.destructuring.vars.intention.name.array=Introducir la desestructuración de matrices
refactoring.destructuring.vars.intention.replace.object=Reemplazar con desestructuración de objetos
refactoring.destructuring.vars.intention.replace.array=Reemplazar con desestructuración de matriz
refactoring.destructuring.vars.intention.replace.promise=Reemplazar con 'await Promise.all'
refactoring.destructuring.vars.intention.propagate=Propagar a la declaración de desestructuración
refactoring.destructuring.vars.intention.depropagate=Reemplazar la desestructuración con acceso a la propiedad y al índice
refactoring.destructuring.vars.intention.deconstruct=Generar patrón de desestructuración
refactoring.destructuring.vars.intention.replace.shorthand=Reemplazar con propiedades de desestructuración y taquigrafía
refactoring.destructuring.vars.intention.const.to.var.warning=Durante la transformación, las variables const resaltadas se convertirán para permitir variables.\n¿Desea continuar?
refactoring.destructuring.vars.intention.const.to.var.warning.title=Cambio de palabra clave variable
refactoring.destructuring.vars.intention.guard.conflict=El tipo de expresión se reduce a ''{0}'' por un tipo de protección que no tendrá ningún efecto después de la refactorización
javascript.intention.add.export.family.name=Agregar exportación
javascript.intention.add.export.fix.text=Hacer {0} exportado en archivo {1}
javascript.intention.add.default.export.family.name=Agregar exportación predeterminada
javascript.intention.remove.export.family.name=Eliminar exportación
javascript.intention.remove.export.inaccessible.conflict.text={0} tiene uso en {1}
javascript.intention.promise.to.async.name=Convertir a función asíncrona
javascript.intention.code.optimizations.text=Optimización del código generado
javascript.intention.add.template.argument=Insertar argumento de cadena de plantilla
javascript.intention.call.chain.to.pipe=Reemplazar llamadas anidadas con expresión de tubería
javascript.intention.pipe.to.call.chain=Reemplazar expresión de tubería con llamadas anidadas
javascript.intention.opt.chain.family=Utilice encadenamiento opcional o fusión nula
javascript.intention.opt.chain.chain.only=Usar encadenamiento opcional
javascript.intention.opt.chain.coalesce.only=Usar fusión nula
javascript.intention.opt.chain.conditional.only=Use '||'
javascript.intention.opt.chain.chain.and.coalesce=Usar encadenamiento opcional y fusión null
javascript.intention.expand.opt.chain.family=Encadenamiento opcional extendido o fusión nullish con verificación explícita
javascript.intention.expand.opt.chain=Extensión de cadena opcional
javascript.intention.expand.nullish.coalescing=extensión de fusión nullish
javascript.intention.expand.or.coalescing=Usando el operador?\:
javascript.intention.expand.opt.chain.and.nullish.coalescing=Encadenamiento selectivo y extensión de fusión nullish
javascript.intention.expand.opt.chain.and.or.coalescing=Expansión de cadena opcional y uso del operador?\:
javascript.intention.explicit.fields=Declarar campos de clase explícitos
javascript.intention.explicit.fields.single=Declarar campo de clase explícito
javascript.intention.explicit.fields.dialog.title=Seleccionar campos para declarar explícitamente
javascript.intention.init.fields=Inicializar nuevos campos a partir de parámetros
javascript.intention.init.fields.dialog.title=Seleccionar parámetros para inicializar campos

js.param.hints.show.names.for.all.args=Para argumentos no literales
js.param.hints.show.names.for.tagged=Para argumentos de plantilla etiquetados
js.param.hints.show.names.for.pipes=Para operadores de canalización
js.param.hints.blacklist.pattern.explanation=<html>메서드 또는 함수에 대한 힌트를 비활성화하려면, 다음 패턴 중 하나를 사용하세요\: <p style\="margin-left\: 5px"><code><b>(*info)</b></code> - 매개변수 이름이 <em>info</em>로 끝나는 모든 단일 매개변수 메서드<br><code><b>(key, value)</b></code> - <em>key</em> 및 <em>value</em>를 매개변수로 가진 모든 메서드<br><code><b>*.put(key, value)</b></code> - <em>key</em> 및 <em>value</em> 매개변수를 가진 모든 <em>put</em> 메서드<br><code><b>Console.log(*, *)</b></code> - 정확히 두 개의 매개변수를 가진 <em>Console</em> 유형의 <em>log</em> 메서드</p><br><p>선택적 매개변수를 포함하여 모든 매개변수에 대해 이름 또는 자리표시자를 제공해야 합니다.<br>정규화된 메서드 이름에는 클래스 또는 인터페이스 이름을 포함해야 합니다.<br>"현재 메서드에 대한 힌트 표시 안함" {0} 액션을 사용하여 코드를 편집할 때 패턴을 추가할 수 있습니다.</p></html>

js.checkbox.make.readonly=readonly로 만들기(&R)

action.JavaScriptGenerateDictionaries.text=JavaScript 맞춤법 검사기 사전 생성
action.ReactClassToFunctionComponentAction.description=함수 구성 요소로 변환
action.ReactFunctionToClassComponentAction.description=클래스 구성 요소로 변환
action.ReactExtractComponentAction.description=Extraer componente
action.EslintImportCodeStyle.description=Aplicar estilo de código ESLint
action.TypeScriptExtractTypeAlias.description=Alias ​​del tipo de extracción
action.JS.TypeScript.Include.Generated.Declarations.text=Incluir archivos secundarios '.d.ts'
action.JS.TypeScript.Include.Generated.Declarations.description=Incluir archivos .d.ts secundarios en el proyecto
action.Generate.GetSetAccessor.JavaScript.text=Captador y Definidor
action.Generate.SetAccessor.JavaScript.text=Definidor
action.Generate.GetAccessor.JavaScript.text=Captador
action.Generate.Constructor.JavaScript.text=Constructor
action.Generate.Missing.Members.ES6.text=Implementar métodos...
action.Generate.Missing.Members.TypeScript.text=Implementar miembros...
group.Editor.JSLibrariesMenu.LibraryList.text=Usar biblioteca
group.Editor.JSLibrariesMenu.LibraryList.description=Establecer bibliotecas JS usadas
group.Editor.JSLibrariesMenu.text=Usar biblioteca JavaScript
group.Editor.JSLibrariesMenu.description=Seleccione las bibliotecas JavaScript que se usarán con el archivo actual
configurable.JSTemplateLangConfigurable.display.name=Plantillas
configurable.JSCodeCompletionConfigurable.display.name=JavaScript
configurable.JSSmartKeysConfigurable.display.name=JavaScript
configurable.MyConfigurable.display.name=JSX
import.options.find.more.configuration.options=Encuentra más opciones de configuración en
import.options.find.more.configuration.options.code.style=Estilo de código
settings.code.style.indent.chained.methods=Métodos encadenados de sangría
settings.code.style.indent.all.chained.calls.in.a.group=Aplicar sangría a todas las llamadas encadenadas en un grupo
settings.code.style.semicolon.to.terminate.statements=&punto y coma para terminar declaraciones
settings.code.style.use=Usar
settings.code.style.quotes=&comillas
settings.code.style.Trailing.comma=&coma final:
settings.code.style.single=single
settings.code.style.double=doble
settings.code.style.in.new.code=en código nuevo
settings.code.style.always=siempre
settings.code.style.option.use=Usar
settings.code.style.dont.use=No usar
checkbox.enable=Activar
webpack.configuration.title=Paquete web
webpack.configuration.detect.description=모듈 확인을 위한 webpack 구성 파일 탐지
webpack.configuration.manual=수동
webpack.configuration.automatic=자동
webpack.configuration.disabled=사용 안함
webpack.configuration.automatic.how.it.works=작동 원리
webpack.configuration.automatic.hint=WebStorm은 현재 파일과 동일한 폴더 또는 상위 폴더에 있는 webpack 구성 파일의 모듈 해결 규칙을 사용합니다.
webpack.configuration.field=Archivo de configuración\:
webpack.configuration.field.required.error=수동 모드에서는 구성 파일 경로가 필요합니다
create.react.app.name=Aplicación React
create.react.app.description=<a href=\"https://github.com/facebookincubator/create-react-app\">Create React App </a>es una nueva forma oficialmente compatible de crear Aplicaciones React de una sola página. Ofrece una configuración de construcción moderna sin configuración.
create.react.app.scripts.version=&Versión de script
create.react.app.typescript.checkbox=Crear proyecto &TypeScript
dialog.title.new.javascript.file=Nuevo archivo JavaScript
list.item.javascript.file=archivo JavaScript
dialog.title.new.typescript.file=Nuevo archivo TypeScript
list.item.typescript.file=Archivo TypeScript
list.item.typescript.jsx.file=Archivo JSX de TypeScript
dialog.kind.0.file={0} archivo
action.creates.new.file.description=Crear nuevo archivo {0}
build.event.title.failed.to.list.tasks=No se pudo enumerar {0} tareas
action.show.error.details.text=Mostrar detalles del error
dialog.title.grunt.settings=Configuración de Grunt
dialog.title.gulp.settings=Configuración de Gulp
dialog.title.error.details=Detalles del error
dialog.message.failed.to.download.0.1={0} no se pudo descargar. {1}
dialog.title.download.error=Error de descarga
label.import.popup=Importar ventana emergente\:
label.namespace=Espacio de nombres\:
dialog.message.cannot.infer.type.new.parameter=No se puede inferir un nuevo tipo de parámetro
dialog.title.cannot.introduce.new.interface=No se puede insertar en la nueva interfaz
notification.title.coloring.types.narrowed.by.type.guard.was.disabled=Se ha deshabilitado la coloración de tipo restringida por tipo de protección
notification.content.html.href.settings.show.inspection.settings.or.href.undo.undo.html=<html> <a href\='settings'> Mostrar configuración de inspección </a> o <a href \='deshacer'> Deshacer </a> </html>
dialog.message.cannot.propagate.variable=No se puede pasar la variable\: {0}
dialog.title.cannot.propagate=No se puede entregar
dialog.message.usages.search.was.interrupted=Se ha detenido la búsqueda de ubicación de uso
dialog.title.cannot.convert=No se puede convertir
dialog.message.cannot.proceed.when.having.non.read.usages.in.embedded.expressions=Si la expresión incluida tiene una posición de uso diferente a read, no puede continuar
dialog.message.variables.from.destructuring.pattern.have.no.usages=No hay una ubicación de uso para las variables de patrón de desestructuración
button.continue=Continuar
button.abort=abortar
action.don.t.use.library.description=No use la biblioteca
action.already.set.for.containing.folder.or.project.description=Ya está configurado para la carpeta o proyecto que lo contiene.
action.use.library.description=Usar biblioteca
text.cannot.download={0} no se pudo descargar. {1}
notification.content.show.details=Mostrar detalles
action.name.disable.category={0} inhabilitar
progress.text.processing=Procesando {0}{1}
label.path=&Ruta\:
border.title.inspection.export.results.capitalized.location=Ubicación
border.title.inspection.description.title=Descripción
progress.title.install.npm.module=Instalar módulo npm ''{0}''
dialog.message.cannot.find.module.types=No se pudo encontrar el módulo @types/{0}
action.jump.to.text=Ir al siguiente...
dialog.title.select.navigation.target=Seleccionar destino de navegación
dialog.title.select.targets.to.convert.to.class=Seleccionar objetivos para convertir a clase
dialog.message.component.name=Nombre del componente\:
label.name=Nombre\:
label.type=tipo\:
label.minimum.language.level=Nivel mínimo de idioma\:
dialog.message.cannot.create.argument.stubs.invoked.method.function=No se puede crear el código auxiliar del argumento\: el método llamado no es una función
action.show.structure.text=Mostrar estructura
status.text.no.errors.in.current.file=No hay errores en el archivo actual.
status.text.javascript.language.service.default.project.errors=Mostrar errores del proyecto
progress.title.compiling.typescript.files=Compilación de archivos TypeScript
dialog.message.cannot.find.file=No se pudo encontrar el archivo {0}
radio.set.options.manually=Establecer opciones manualmente
radio.use.tsconfig.json=Usar tsconfig.json
separator.deprecated.settings=Configuraciones obsoletas
dialog.title.main.file=Archivo principal
label.choose.main.file=Seleccionar archivo de correo
dialog.title.output.directory=Directorio de salida
label.choose.output.directory=Seleccionar directorio de salida
dialog.message.incorrect.path.to.typescript.package=Ruta del paquete de mecanografiado no válida
status.text.project.structure.isn.t.available=La estructura del proyecto no está disponible
status.text.service.doesn.t.contain.open.projects=Los servicios no incluyen proyectos abiertos
status.text.refresh.required=Se requiere actualización
dialog.message.cannot.find.module.for.import=No se puede encontrar el módulo para importar
action.js.tagged.literal.injection.text=inyección literal con etiqueta JS
dialog.title.wsl.node.interpreter={0} intérprete de nodo WSL
dialog.title.wsl.node.interpreter.edit=Editar
dialog.title.wsl.node.interpreter.edit.add=Agregar
label.linux.distribution=&Distribución de Linux\:
label.wsl.node.interpreter=I&ntérprete de nodo WSL\:
dialog.message.please.select.distribution=Seleccione una distribución
dialog.message.please.specify.wsl.path.to.node.js.interpreter=Especifique la ruta WSL al intérprete de Node.js
status.text.running.which.node=Ejecutando `qué nodo`...
progress.title.configuring.node.js.coding.assistance=Configurando el soporte de codificación de Node.js...
action.PackageJsonNewFile.text={0} 파일
action.PackageJsonNewFile.description={0} 파일 생성
progress.title.install=Instalar {0}
progress.subtitle.install=Instalando {0} usando {1}...
inspection.message.package.installed=El paquete {0} no está instalado
inspection.message.package.version.specified=No se ha especificado la versión del paquete
inspection.message.installed.version.doesn.t.match.version.range=La versión instalada {0} no coincide con el rango de versiones {1}
dialog.title.missing.dependencies=Faltan dependencias
button.install.update=Instalar/Actualizar
action.view.install.text=Ver e instalar...
action.don.t.ask.again.text=No volver a preguntar
dialog.title.configure.coding.assistance.for.node.js.api=Configurar el soporte de codificación para la API de Node.js
action.Anonymous.text.configure=Configuración
inspection.message.sm.test.runner.magnitude.assertion.failed.title=Aserción fallida
text.html.front.end.template.a.href.http.html5boilerplate.com=<html> plantilla de interfaz <a href\='http\://html5boilerplate.com'> http\: //html5boilerplate.com </a> </html>
dialog.message.node.interpreter.unspecified.error.text=Especifique el intérprete de Node.js
text.html.sleek.intuitive.and.powerful.front.end.framework=<html> Marco de interfaz elegante, intuitivo y potente para un desarrollo web más rápido y sencillo <a href \='http\: //getbootstrap.com '> http\: //getbootstrap.com </a> </html>
popup.title.target.function=Función de destino
popup.title.select.destructuring.assignment.target=Seleccionar destino de asignación de descomposición de estructura
visibility.level.overview=Resumen
visibility.level.details=Detalles
js.module.uml.presentable.name=Dependencia del módulo JavaScript
intention.family.name.run.npm.install=Ejecutar'npm install'
intention.name.run.npm=''{0}'' ejecución
intention.family.name.navigate.to.package.json=Ir a package.json
intention.name.navigate.to.0.package.json=Ir a {0}/package.json
popup.advertisement.start.typing.package.name=Empiece a escribir el nombre del paquete para obtener resultados más específicos del registro público oficial de npm
popup.advertisement.latest.available.versions.for.all.distribution.tags=Última versión disponible para todas las etiquetas de distribución
intention.family.name.select.in.test.tree=Seleccionar del árbol de prueba
intention.family.name.introduce.parameter.properties.for.unused.parameters=Insertar la propiedad de los parámetros en los parámetros no utilizados
dialog.title.select.parameters.to.convert.to.parameter.properties=Parámetros: seleccione los parámetros para convertir en propiedades
intention.family.name.add.required.property=Agregar propiedad requerida
intention.name.create.library.with.files.outside.project=Cree una biblioteca que contenga archivos fuera del proyecto
dialog.message.unspecified.suite.name=Nombre de la herramienta no especificado
dialog.message.unspecified.test.name=Nombre de prueba no especificado
dialog.message.unspecified={0} no especificado
dialog.message.no.such=No {0}
dialog.message.please.specify.package.json=Especifique package.json
dialog.message.please.specify.package.json.correctly=Especifique package.json correctamente
dialog.message.please.specify.npm.scripts.to.run=Por favor, especifique el script npm para ejecutar
dialog.message.command.supported.by={1} no admite el comando ''{0}''
dialog.message.no.npm.script=''{0}'' Sin secuencia de comandos npm
titled.separator.predefined=Predefinido
label.compiles.js.files=compilación de archivos .js
label.compress.js.files=compresión de archivos .js
dialog.title.edit.run.debug.configuration=Editar configuración de ejecución/depuración\: ''{0}''
js.commandline.configure.language.version=Configurar la versión en lenguaje JavaScript del proyecto
js.commandline.configure.nodejs=Configure el intérprete NodeJS e instale el paquete para el archivo package.json.

# Language features
js.language.feature.xml.tags=XML 태그
js.language.feature.for.each.statements=For each 문
js.language.feature.for.of.loops=for..of 루프
js.language.feature.let.definitions=let 정의
js.language.feature.const.definitions=상수 정의
js.language.feature.generators=생성기
js.language.feature.destructuring.assignments=대입 구조 분해
js.language.feature.let.statements=let 문
js.language.feature.array.comprehensions=배열 내포
js.language.feature.top.level.yield.expressions=최상위 yield 표현식
js.language.feature.reference.namespace=참조 네임스페이스
js.language.feature.default.parameter.values=디폴트 매개변수 값
js.language.feature.pipe.expressions=파이프 표현식
js.language.feature.decorator.declarations=데코레이터 선언
js.language.feature.throw.expressions=throw 표현식
js.language.feature.ecmascript.syntax.for.private.members=private 멤버에 대한 ECMAScript \#-구문
js.language.feature.class.member.visibility.modifiers=클래스 멤버 가시성 제어자
js.language.feature.optional.chaining.operator=optional 체인 연산자
js.language.feature.arbitrary.precision.integers=임의의 정밀도 정수
js.language.feature.trailing.commas.in.function.parameter.lists.and.calls=함수 매개변수 목록 및 호출 내 후행 쉼표
js.language.feature.unicode.escapes.with.braces=괄호가 있는 유니코드 이스케이프
js.language.feature.bind.expressions=바인드 표현식
js.language.feature.optional.catch.bindings=선택적 catch 바인딩
js.language.feature.string.templates=문자열 템플릿
js.language.feature.method.definition.shorthands=메서드 정의 축약
js.language.feature.computed.property.names=계산된 프로퍼티 이름
js.language.feature.shorthand.property.names=축약형 프로퍼티 이름
js.language.feature.binary.0b.and.new.octal.0o.literals=2진(0b) 및 새로운 8진(0o) 리터럴
js.language.feature.async.await=async/await
js.language.feature.types=유형
js.language.feature.annotations=어노테이션
js.language.feature.interfaces=인터페이스
js.language.feature.classes=클래스
js.language.feature.es6.export.declarations=ES6 export 선언
js.language.feature.es6.import.declarations=ES6 import 선언
js.language.feature.generics=제네릭
js.language.feature.rest.parameters=Rest 매개변수
js.language.feature.arrow.functions=화살표 함수
js.language.feature.getters.and.setters=getter 및 setter
js.language.feature.generator.expressions=생성기 표현식
js.language.feature.expression.closures=표현식 클로저
js.language.feature.destructuring.parameters=매개변수 구조 분해

# Webpack
webpack.failed.to.load={0}을(를) 로드하지 못했습니다
webpack.analyzing.configs.progress=Analyzing webpack configs
webpack.cannot.analyze={0}을(를) 분석할 수 없습니다. 코딩 지원이 이 파일의 모듈 해결 규칙을 무시합니다.\n가능한 이유\: 이 파일이 올바른 webpack 구성 파일이 아니거나 해당 형식이 현재 IDE에서 지원되지 않습니다.
file.name.masks.to.skip.from.analysis=분석에서 건너뛸 파일 이름 마스크\:
webpack.trusted.project.title=Analyze untrusted webpack configuration
webpack.trusted.project.message=To improve coding assistance, {0} runs code in the project''s webpack configuration files. Potentially malicious code might be executed. If you don''t trust the source, skip the analysis.
webpack.trusted.project.message.allow=Analyze webpack configuration
webpack.trusted.project.message.skip=Skip

# Node
node.wsl.no_available_distributions.text=사용할 수 있는 배포가 없습니다
node.wsl.unavailable_distribution.text={0}을(를) 사용할 수 없습니다
node.wsl.cannot_find_installed_wsl_distribution.message={0}에 대한 WSL 설치를 찾을 수 없습니다
node.core.enable_coding_assistance_intention.name=Node.js에 대한 코딩 지원 활성화
node.interpreter.unresolved_reference.error.message=해결되지 않은 인터프리터 ''{0}''
node.interpreter.invalid_interpreter.error.message=잘못된 ''{0}''
node.interpreter.no_local_interpreter.error.message=로컬 Node.js 인터프리터가 없습니다
node.debug.cannot_connect_to_vm.error.message=VM {0}에 연결할 수 없습니다
node.debug.cannot_get_localhost_IPv4.error.message=127.0.0.1 IPv4를 받을 수 없습니다
node.core.make.sure.javascript.debugger.plugin.enabled.dialog.message=''JavaScript Debugger'' 플러그인이 활성화되었는지 확인하세요
node.core.failed_to_fetch_node_core_modules.dialog.message=노드 코어 모듈을 가져오지 못했습니다
node.core.core_modules_fetch_timed_out.dialog.message=시간이 초과되어 코어 모듈을 가져올 수 없습니다
node.core.not_ready_for_core_modules_configuration.dialog.message=코어 모듈 구성 준비가 되지 않았습니다
node.core.navigate_action_text.text=Node.js 및 NPM 구성...
node.core.failed_to_install.title.message={0} 설치 실패
node.interpreter.field.add.item.text=추가...
node.interpreter.field.unexpected_value.text=예기치 않은 값 {0}
node.interpreter.unspecified_interpreter.dialog.message=Node.js 인터프리터를 지정하세요
node.interpreter.unspecified_local_interpreter.dialog.message=로컬 Node.js 인터프리터를 지정하세요
node.interpreter.specified_interpreter_correctly.dialog.message=Node.js 인터프리터를 올바르게 지정하세요
node.interpreter.reference_not_found.text=찾을 수 없음
node.interpreter.command_timed_out.dialog.message=''{0}'' 명령어 실행이 시간 초과되었습니다(>{1}밀리초)
node.package_documentation.installed_version.text=설치된 버전\: {0}
node.package_documentation.latest_version.text=최신 버전\: {0}
node.packages.cannot_find_working_directory.text={0}에 대한 작업 디렉터리를 확인할 수 없습니다. {1}
node.package.field.not_found.text=No encontrado
node.npm.cannot_find_package_by_reference.dialog.message=패키지 관리자 ''{0}''을(를) 찾을 수 없습니다
node.npm.specify_npm_or_yarn_package.dialog.message=npm 또는 yarn 패키지를 지정하세요
node.npm.correct_path_to_npm_or_yarn_package.dialog.message=npm 또는 yarn 패키지의 경로를 수정하세요. "{0}" 디렉터리가 없습니다
node.npm.invalid_package_manager.binary_file_not_found.dialog.message=올바른 패키지 관리자를 지정하세요. ''{0}'' 디렉터리에서 바이너리 파일을 찾을 수 없습니다
node.npm.project_package_manager_disallowed_here.dialog.message=프로젝트 npm 패키지는 여기에서 참조할 수 없습니다
node.npm.unspecified_package_manager.dialog.message=El administrador de paquetes no está especificado
node.npm.cannot_resolve_package_manager.dialog.message=''{0}'' 패키지 관리자를 해결할 수 없습니다
node.npm.no_bundled_npm_detected.dialog.message=Las NPM que se incluyen para {0} no se pueden detectar
package_json.install_dependencies.notification.title=Instalación de dependencia
package_json.install_dependencies_multiple.notification.content={0} 및 그 외 {1}개에서
package_json.install_dependencies.notification.content=Desde {0}
package_json.update_dependencies.notification.title=Actualización de dependencias
package_json.update_dependencies.notification.content=Desde {0}
package_json.notifications_are_disabled.notification.content={0}의 종속성 설치에 대한 알림이 비활성화되었습니다.<p>"{1}" 액션을 사용하여 다시 활성화하세요.
node.wsl.unavailable.dialog.message=WSL no está disponible
node.wsl.unavailable_distribution.dialog.message=WSL {0}을(를) 사용할 수 없습니다
node.npm.cannot_find_project_package_manager.dialog.message=프로젝트 Node.js 패키지 관리자를 찾을 수 없습니다
node.npm.package_manager_link.text=패키지 관리자
yarn.package_requires_yarn.dialog.message=패키지 "{0}"에 Yarn {1}이(가) 필요합니다.

# Jest
jest.package.placeholder.text=jest 경로, react-scripts(또는 그 대체 항목) 패키지 디렉터리
jest.coverage.cannot.create.temporary.directory.dialog.message=임시 디렉터리를 생성할 수 없습니다
jest.snapshot.label=Jest 스냅샷
jest.go.to.snapshot.text=''{0}'' 스냅샷으로 이동
jest.cannot.find.bin.file.for.package.dialog.message=''{0}'' 패키지의 bin 파일을 찾을 수 없습니다

# Protractor
dialog.message.cannot.locate.wrapper.config.file=래퍼 구성 파일을 찾을 수 없습니다

# Style guides
list.item.google.javascript.style.guide=Google JavaScript 스타일 가이드
list.item.javascript.standard.style=JavaScript 표준 스타일

# Inlay hints
method.return.types.in.call.chains=호출 체인 내 메서드 반환 유형
type.annotations=유형 어노테이션
parameters.in.parentheses=소괄호로 묶인 매개변수
non.parenthesized.single.parameter=소괄호로 묶이지 않은 단일 매개변수
function.returns=함수 반환
variables.and.fields=변수 및 필드
command.name.add.explicit.value=명시적 값 ''{0}'' 추가
numeric.enum.values=숫자 열거형 값 추가

# Libraries
progress.title.downloading.library=라이브러리 다운로드 중
progress.title.downloading.documentation=문서 다운로드 중
successfully.downloaded=성공적으로 다운로드되었습니다
failed.to.download=다운로드하지 못했습니다
progress.title.downloading.typings=typings 다운로드 중
notify.urls.more=... 및 그 외 {0,number}개

# Structural Search
structural.search.anonymous.functions=익명 함수
structural.search.functions=함수
structural.search.variables=변수
structural.search.function.calls=함수 호출
structural.search.while.loops=While 루프
structural.search.constants=상수
structural.search.classes=클래스
structural.search.empty.functions=빈 함수
structural.search.console.log.calls=console.log() 호출
structural.search.with.statements=With 문
structural.search.var.statements=Var 문
structural.search.functions.with.boolean.parameters=부울 매개변수가 있는 함수
structural.search.comparison.to.self=자신과 비교

# Project Generators
copying.files=파일 복사 중
project.generation=프로젝트 생성
notification.title.cannot.generate={0}을(를) 생성할 수 없습니다
dialog.message.cannot.find.npx.bundled.with={0}에 번들로 포함된 npx를 찾을 수 없습니다
generating.0={0} 생성 중

# Find Usages
js.show.dynamic.usages=동적 사용 위치 표시

# Test Runners
action.JasmineGenerateNewSuiteAction.text=Jasmine Suite
action.JasmineGenerateNewSpecAction.text=Jasmine Spec
action.JasmineGenerateBeforeEachMethodAction.text=Jasmine beforeEach
action.JasmineGenerateAfterEachMethodAction.text=Jasmine afterEach
action.QUnitGenerateNewTestAction.text=QUnit Test
action.QUnitGenerateSetupAction.text=QUnit Setup
action.QUnitGenerateTearDownAction.text=QUnit TearDown

# Diagrams
diagram.element.not.found={0}(찾을 수 없음)

# Other
command.name.create.javascript.file=JavaScript 파일 {0} 생성
command.name.create.typescript.file=TypeScript 파일 {0} 생성
checkbox.move.simple.expressions.to.field.initializer=단순 표현식을 필드 이니셜라이저로 이동
popup.title.choose.class=클래스 선택
multiple.inheritance=다중 상속
label.method.should.be.defined=메서드가 정의되어야 합니다
recursive.call=재귀 호출
command.name.extract.named.type=이름 지정된 유형 추출
inspection.message.reference.includes.files.outside.project=프로젝트 외부에 있는 파일이 참조에 있습니다
progress.title.executing.performance.task.on.files=파일에서 성능 작업 실행 중
terminal.add_node_modules_bin_to_path.label=프로젝트 루트를 ''node_modules/.bin''을 {0}에 추가
label.name.injection=이름(&N)\:
reg.exp.tagged.template=''{1}'' 태그 지정된 템플릿 내 {0}
unwrap.with.kind=''{0}...'' 래핑 해제


