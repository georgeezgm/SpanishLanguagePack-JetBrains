python.f.string.completion.lesson.name=f 문자열 코드 완성
python.f.string.completion.type.prefix=<ide/>는 자동 f 문자열 변환을 지원합니다. {0} 을(를) 입력하세요.
python.f.string.completion.invoke.manually={0} 을(를) 사용해 코드 완성 기능을 수동으로 호출할 수 있습니다.
python.f.string.completion.complete.it={0} (으)로 구문을 완성하세요. {1} 을(를) 누르기만 하면 첫 번째 항목이 적용됩니다.
python.f.string.completion.result.message=코드 완성 후에 단순 Python 문자열이 f 문자열로 교체된 것을 확인할 수 있습니다.

python.postfix.completion.select.item=코드 완성 목록에서 {0} 항목을 선택하세요.

python.smart.completion.lesson.name=스마트 코드 완성
python.smart.completion.try.basic.completion={0} 을(를) 눌러 기본 코드 완성 기능을 사용해보세요.
python.smart.completion.use.smart.completion=아쉽게도 <ide/>에는 {0} 유형에 대한 직접적인 정보가 없습니다. 그러나 컨텍스트에 따라 코드 완성을 제안할 수 있는 경우도 있습니다. {1} 을(를) 사용하여 스마트 완성을 호출하세요.
python.smart.completion.finish.completion=이제 {0} 항목을 선택하여 이 강의를 완료하세요.

python.tab.completion.lesson.name=탭 완성
python.tab.completion.start.completion={0} 을(를) {1} (으)로 교체하고자 한다고 가정해봅시다. {2} 을(를) 눌러 코드 완성 기능을 호출하세요.
python.tab.completion.select.item=키보드 화살표를 사용하여 항목 {0} 을(를) 선택하거나 항목을 입력하세요.
python.tab.completion.use.tab.completion={0} 을(를) 누르면 {2} 앞에 {1} 이(가) 삽입됩니다. 대신 {3} 을(를) 눌러 {2} 을(를) {1} (으)로 교체하세요.

python.in.place.refactoring.lesson.name=즉시 리팩터링
python.in.place.refactoring.start.type.new.name=리팩터링을 실행하기 위한 대체 접근법을 생각해봅시다. 지역 변수 {0} 의 이름을 {1} (으)로 변경하고자 한다고 가정해봅시다. 새 이름을 입력하세요.
python.in.place.refactoring.invoke.intentions=<ide/>는 변수의 이름을 변경하려고 한다고 추측하고 있습니다. 여백에 위치한 {0} 아이콘으로 확인할 수 있습니다. 새 이름 입력이 끝나면 {1} 에서 인텐션을 호출하세요.
python.in.place.refactoring.finish.rename={0} 을(를) 눌러 이름 변경을 완료하세요.
python.in.place.refactoring.add.parameter=이 메서드에 인수를 추가하겠습니다. 첫 번째 매개변수 뒤에 에디터 캐럿을 둡니다. 이제 쉼표와 매개변수 이름을 입력하세요\: {0}.
python.in.place.refactoring.invoke.intention.for.parameter=<ide/>는 메서드 시그니처를 변경할 것을 기대하고 있습니다. 여백에 위치한 같은 아이콘 {0} (으)로 이를 알 수 있습니다. 새 매개변수 입력이 끝나면 {1} 을(를) 눌러 인텐션을 호출하세요.
python.in.place.refactoring.update.callers={0} 을(를) 눌러 호출자를 업데이트하세요.
python.in.place.refactoring.signature.preview=<ide/>는 짧은 시그니처 미리보기를 표시하고 있습니다. {0} 을(를) 눌러 계속 진행하세요.
python.in.place.refactoring.set.default.value=이제 각 호출에 인수로 삽입되는 값을 입력해야 합니다. 이 샘플에서는 {0} 을(를) 선택할 수 있습니다. 그다음 {1} 을(를) 눌러 계속 진행하세요.
python.in.place.refactoring.remark.about.application.scope=참고\: 즉시 리팩터링은 정의 위치에서만 적용될 수 있으나 이름 변경 직접 호출이나 시그니처 변경 리팩터링은 정의 및 사용 위치 모두에서 호출될 수 있습니다.

python.quick.fix.refactoring.lesson.name=빠른 수정 리팩터링
python.quick.fix.refactoring.type.new.argument=빠른 수정으로 몇몇 리팩토링을 실행할 수 있습니다. 메서드 {0} 에 매개변수를 추가하고 변수 {1} 을(를) 메소드에 전달하고자 한다고 가정해봅시다. 첫 번째 인수 뒤에 {2} 을(를) 입력해봅시다.
python.quick.fix.refactoring.close.completion.list=현재는 어떠한 코드 완성 기능도 적용하지 않으려 합니다. 목록을 닫으세요({0}).
python.quick.fix.refactoring.invoke.intentions=보이는 바와 같이 <ide/>는 이곳에 경고를 표시합니다. {0} 을(를) 눌러 인텐션을 호출하세요.
python.quick.fix.refactoring.choose.change.signature={0} 빠른 수정을 선택하세요.
python.quick.fix.refactoring.select.new.parameter=새 매개변수의 기본값을 설정해봅시다. 새 매개변수 줄을 클릭하세요. 아니면, {0} 을(를) 누른 다음 {1} 을(를) 눌러 매개변수에 포커스를 전환할 수도 있습니다.
python.quick.fix.refactoring.set.default.value={0} 을(를) 사용하여 필드(및 체크박스)를 이동할 수 있습니다. 이 체크박스를 선택하면 <ide/>는 기본값을 다른 호출자로 인라인화하거나 새로운 매개변수의 기본값으로 설정합니다. 시그니처 미리보기는 차이를 이해하는 데 도움이 됩니다. 이제 기본값을 0으로 설정하세요.
python.quick.fix.refactoring.finish.refactoring={0} 을(를) 눌러(또는 {1} 을(를) 클릭하여) 리팩터링을 종료합니다.

python.rename.press.rename={0} 을(를) 눌러 {1} 필드의 이름을 변경합니다(예\: {2} (으)로).
python.rename.expand.dynamic.references=간단한 경우에는 {0} 은(는) 확인 없이 이름 변경 리팩토링을 실행합니다. 하지만 이 샘플에서 <ide/>은(는) 유형을 알 수 없는 객체에 대한 {0} 메서드의 두 호출을 탐지합니다. {1} 항목을 확장하세요.
python.rename.find.window.closed.warning={0} 을(를) 찾기 도구 창을 다시 여세요.
python.rename.exclude.item={0} 은(는) 이름 변경 리팩터링에서 제외되어야 할 것 같습니다. 선택한 후 {1} 을(를) 누르세요.
python.rename.finish.refactoring={0} 버튼으로 이름 변경을 완료하세요.

python.editor.coding.assistance.fix.error=이 오류를 수정해봅시다\! {0} 을(를) 누른 후 {1} 또는 {2} <strong>→ math</strong>을(를) 선택하세요

python.run.configuration.lets.run={0} 을(를) 사용하여 간단한 예시를 실행해봅시다.

python.debug.workflow.rerun=프로그램을 다시 실행하세요. {0} 을(를) 다시 클릭하거나 {1} 을(를) 사용하세요.
