1.occurrence=(1 coincidencia)
abstract.member.not.have.private.modifier=Los miembros abstractos no pueden tener modificadores privados
abstract.modifier.is.not.allowed=El modificador ''abstracto'' sólo se permite en clases o definiciones que tienen un modificador ''anular''
abstract.modifier.redundant.fot.traits=El modificador ''abstracto'' es redundante con el atributo.
abstract.override.modifier.is.not.allowed=El modificador ''anulación abstracta'' solo se permite en miembros de atributos
access.modifier.is.not.allowed.here=El controlador ''{0}'' no está permitido
action.implement.method=Implementación del método
action.import.member=Obtener miembros
action.override.method=Anulación de método
add.braces.around.single.line.expression=Agregue llaves alrededor de expresiones de una sola línea
add.collection.breakout.argument=Agregue el argumento `collection.breakOut`
add.import.action=Agregar acción de importación
add.modifier.fix.without.name=Agregar controlador ''{0}''
add.override.modifier=Insertar &O “anular”
add.return.type=Agregar tipo de devolución
add.to.definition=Añadir a la definición
additional.compiler.options=Opciones adicionales del compilador (&O)\:
additional.support.has.been.found.popup=<p>Se ha encontrado soporte adicional para algunas bibliotecas.</p><p>¿Le gustaría habilitarlo? <a href\="Sí">Sí</a>/<a href\="No">No</a></p>
align.list.items.content=Ordenar el contenido de los elementos de la lista
ambiguous.artifact.resolved=Artefacto oscuro resuelto: {0}
annotation.ascriptions.in.pattern.definitions.require.scala3=La atribución de anotaciones dentro de las definiciones de patrones requiere Scala 3.0
annotation.or.type.expected=Anotación o expectativa de tipo
annotator.error.annotation.type.expected=Se requiere tipo de anotación
annotator.error.bean.property.should.not.be.private=Las propiedades de Bean no deben ser privadas.
annotator.error.cannot.apply.constructor=Constructor {0} no aplicable
annotator.error.cannot.find.constructor.for.this.call=No se encontró ningún constructor para esta llamada.
annotator.error.cannot.resolve.overloaded.constructor=No se puede resolver el constructor sobrecargado `{0}`
annotator.error.cannot.resolve.overloaded.method=No se puede resolver el método sobrecargado
annotator.error.class.type.required.but.found=Tipo de clase esperado pero ({0}) encontrado
annotator.error.constructor.has.malformed.definition=El tipo de definición del constructor no es válido
annotator.error.enum.case.must.extend.parent=Un caso de enumeración debe extender la clase de enumeración correspondiente {0}
annotator.error.enum.nonvariant.type.param,in.enum=No se puede determinar el argumento de tipo del padre {0} de la clase de enumeración. El parámetro de tipo {1} es invariante
annotator.error.enum.two.type.parameter.clauses=Tanto los casos de enumeración como las clases de enumeración contienen parámetros de tipo y, por lo tanto, requieren una cláusula de extensión explícita.
annotator.error.expansion.for.non.repeated.parameter=Expansión de parámetros no repetitivos
annotator.error.missing.argument.list.for.constructor=Falta lista de argumentos para el constructor {0}
annotator.error.missing.arguments.for.method=Falta argumento para el método {0}
annotator.error.missing.parameter.type=Tipo de parámetro faltante
annotator.error.missing.type.annotation.for.parameter=Falta anotación de tipo en el parámetro\: {0}
annotator.error.name.has.malformed.definition=''{0}'' tiene una definición incorrecta
annotator.error.no.constructor.accessible=No hay constructores accesibles aquí.
annotator.error.parameter.specified.multiple.times=Parámetro especificado varias veces
annotator.error.parameter.without.an.owner.name=Parámetro sin propietario\: {0}
annotator.error.positional.after.named.argument=Argumentos posicionales después de argumentos con nombre
annotator.error.reassignment.to.val=Asignar nuevamente a val
annotator.error.repeated.or.default=*-la sección de parámetros parametrizados no puede contener argumentos predeterminados
annotator.error.repeated.parameter.must.be.last=*-el parámetro debe ser el último
annotator.error.target.does.not.take.parameters={0} no toma parámetros
annotator.error.too.many.arguments=Demasiados argumentos
annotator.error.too.many.arguments.for.constructor=El constructor {0} tiene demasiados argumentos.
annotator.error.too.many.arguments.method=El método {0} tiene demasiados argumentos
annotator.error.too.many.parameters=Demasiados parámetros
annotator.error.trait.has.no.constructor=La propiedad {0} es una propiedad y, por lo tanto, no acepta argumentos de constructor.
annotator.error.unspecified.value.parameters=Parámetro de valor no especificado \: {0}
annotator.error.wrong.right.assignment.side=Asignación de derechos no válida
assign.expected=''\='' esperado
assignment.missing.right.side=Falta el lado derecho de la tarea
auto.import.add.unambiguous.imports.on.the.fly.for=Agregue inmediatamente una declaración de importación inequívoca en \:
auto.import.find.more.configuration.options=Encuentre más opciones de configuración en <a>Estilo de código</a>
auto.import.optimize.imports.on.the.fly=Optimización inmediata de las declaraciones de importación.
auto.import.show.import.popup.for=Mostrar ventana emergente de declaración de importación\:
auto.import.show.popup.classes=Clase
auto.import.show.popup.conversions=Conversión implícita
auto.import.show.popup.extension.methods=Método de extensión
auto.import.show.popup.implicits=Definición implícita
auto.import.show.popup.methods=Miembro estático
auxiliary.constructor.definition.expected=Se requiere una definición de constructor secundario
auxiliary.constructor.may.not.have.a.type.annotation=Los constructores auxiliares no pueden tener anotaciones de tipo.
bad.interpolated.string.injection=Inserción de cadena interpolada incorrecta
balance.header=Encabezado de saldo
base.package.help=<html>Si el paquete base es <code>org.example.application</code>, entonces el paquete <code>org.example.application.NAME</code> es<br><code>paquete org.example.application </code><br>Debe definirse como <code>NOMBRE del paquete</code></html>
better.monadic.for.invalid.pattern=Los argumentos deben tener anotaciones tipográficas explícitas.
blank.lines.panel.around.class.in.inner.scopes=Alrededor de una clase dentro de un ámbito interno
blank.lines.panel.around.field.in.inner.scopes=Alrededor del campo dentro de los límites internos.
blank.lines.panel.around.method.in.inner.scopes=Alrededor de un método dentro de un alcance interno
bold.surrounder.template.description=Atrevido\: '''' ''''
both.stub.and.name.identifier.node.are.null=Tanto el nodo de identificador de nombre como el de código auxiliar para {0} están vacíos\nNo se ha definido ningún tipo de retorno
bundled.distribution.info.name=Incluido en el paquete
by.name.parameters.cannot.be.used=Debido a que este método contiene una anulación de Java, no puede utilizar el parámetro de nombre de una clase de valor.
bytecode.indices.target.for.comprehension.method=Método de comprensión
bytecode.indices.target.implicit.definition=Definición implícita
bytecode.indices.target.sam.type=Tipo SAM
bytecode.indices.target.unapply.method=Aplicar/desaplicar métodos
call.is.recursive=Llamada recursiva
called.constructor.definition.must.precede=La definición del constructor llamado debe preceder a la llamada a la definición del constructor.
can.not.override.final={0} ''{1}'' no puede anular el miembro final
can.t.find.implicit.argument.for.this.definition=No se encontró ningún argumento implícito para esta definición.
can.t.infer.proper.types.for.type.parameters=No se puede inferir el tipo apropiado para el parámetro de tipo
can.t.resolve.type=El tipo no se puede resolver
cannot.be.a.top.level.definition.in.scala.2=No puede ser una definición de nivel superior en Scala 2
cannot.create.expression=No se puede crear expresión.
cannot.create.field.from.this.expression=No se pueden crear campos a partir de esta expresión.
cannot.define.expected.type=No se puede definir el tipo de expectativa
cannot.desugarize.typename=No se puede desazucar {0}
cannot.determine.expected.type=No se pudo determinar el tipo de expectativa
cannot.extract.empty.message=Selección incorrecta del área de refactorización. Se requieren varias expresiones o declaraciones completas.
cannot.extract.self.invocation=No se puede extraer la autoinvocación.
cannot.extract.used.function.definition=Refactorización no compatible\: La definición de función dentro de la selección se usa fuera del fragmento seleccionado
cannot.extract.used.type.definition=Refactorización no compatible\: la definición de tipo dentro de la selección se usa fuera del fragmento seleccionado
cannot.find.directory.for.package=No se pudo encontrar el siguiente directorio de paquetes\: {0}
cannot.find.enclosing.container=No puedo encontrar ese contenedor
cannot.find.method.of.stringcontext=Método {0} de StringContext no encontrado
cannot.find.package.with.name=No se puede encontrar el paquete con nombre\: {0}
cannot.find.partialfunction.class=Clase de función parcial no encontrada
cannot.find.place.for.the.new.field=Nueva ubicación de campo no encontrada
cannot.find.template.for.this.reference=Plantilla no encontrada para esta referencia
cannot.find.throwable.class=Clase arrojable no encontrada
cannot.handle.compatibility.for=No se puede procesar la compatibilidad para {0}
cannot.have.infix.type.directly.in.typed.pattern.try.to...=Los patrones tipificados no pueden tener tipos inyectivos directamente. Rodéelo entre paréntesis.
cannot.infer.type=El tipo no se puede inferir
cannot.infer.type.of.super.expression=No se puede inferir el tipo de expresión "super"
cannot.infer.type.without.an.expression=El tipo no se puede inferir sin expresión
cannot.infer.type.without.expected.type=No se puede inferir el tipo sin el tipo esperado
cannot.infer.type.without.function.expected.type=No se puede inferir el tipo sin el tipo esperado de scala.FunctionN o scala.PartialFunction
cannot.inline.different.files=El afiliado se declara en otro expediente. No se admite la inserción en línea.
cannot.inline.function.functional.parameters=No se admiten funciones en línea con parámetros de función
cannot.inline.function.implicit.parameters=La inserción en línea no es compatible con funciones con parámetros implícitos
cannot.inline.function.multiple.clauses=La inserción no es compatible con funciones con cláusulas de múltiples parámetros
cannot.inline.function.varargs=La inserción en línea no es compatible con funciones con parámetros vararg
cannot.inline.generic.function=La inserción en línea no es compatible con funciones genéricas
cannot.inline.implicit.element=La inserción en línea no es compatible con elementos implícitos
cannot.inline.never.used=La variable nunca se utiliza.
cannot.inline.not.method.call=La inserción en línea es compatible con llamadas a métodos regulares.
cannot.inline.not.simple.definition=La inserción solo se admite para definiciones {0} simples
cannot.inline.notsimple.typealias=La inserción en línea solo se admite para alias de tipo simple
cannot.inline.read.only=No se pueden insertar elementos de solo lectura
cannot.inline.recursive.function=La inserción en línea no es compatible con funciones recursivas
cannot.inline.special.function=La inserción en línea no es compatible con funciones especiales
cannot.inline.stable.reference=El valor se utiliza en una referencia estable y no se puede insertar
cannot.inline.used.outside.class=El miembro se utiliza fuera de su clase. No se admite la inserción en línea.
cannot.inline.value.functional.type=No se admite la inserción de valores con tipos de funciones
cannot.refactor.arg.in.self.invocation.of.constructor=No se admite la refactorización de argumentos de autoinvocación en el cuerpo del constructor
cannot.refactor.class.parameter.top.level=La refactorización no es compatible con parámetros en clases de nivel superior
cannot.refactor.constr.expression=El bloque seleccionado no debe aparecer como expresión de constructor.
cannot.refactor.interpolated.string.prefix=La refactorización no es compatible con prefijos de cadenas interpoladas
cannot.refactor.literal.pattern=La refactorización no es compatible con argumentos con nombre
cannot.refactor.named.arg=La refactorización no es compatible con argumentos con nombre
cannot.refactor.no.function=Función no encontrada para insertar parámetros
cannot.refactor.not.expression=La cadena seleccionada no se puede extraer mediante expresión
cannot.refactor.not.expression.nor.type=Se debe seleccionar una expresión o elemento de tipo.
cannot.refactor.not.valid.type=Se debe seleccionar el elemento tipo
cannot.refactor.scope.not.found=No se encontró ninguna clase o paquete adecuado
cannot.refactor.self.invocation=La refactorización no es compatible con llamadas al constructor en constructores secundarios
cannot.refactor.under.generic.call=La refactorización no es compatible con llamadas genéricas
cannot.resolve=El símbolo {0} no se puede resolver.
cannot.resolve.apply.method=No se pudo resolver el método {0}.apply
cannot.resolve.expression=La expresión no se puede resolver.
cannot.resolve.in.StringContext=El valor ''{0}'' no es miembro de StringContext
cannot.resolve.overloaded=El método sobrecargado ''{0}'' no se puede resolver
cannot.resolve.parent.class=No se puede resolver la clase principal
cannot.resolve.ref=No se pudo resolver la referencia
cannot.resolve.reference=No se pudo resolver la referencia
cannot.resolve.unapply.method=No se puede resolver el método {0}.unaapply
cannot.resolve.unknown.symbol=El símbolo no se pudo resolver
cannot.shape.resolve.self.invocation=No se puede resolver la autollamada
cannot.upcast.type.to.other.type=No se puede transmitir {0} a {1}
case.class.has.no.primary.constructor=La clase de caso no tiene constructor predeterminado
case.classes.without.parameter.list.deprecated=Las clases de casos sin listas de parámetros están en desuso
case.classes.without.parameter.list.not.allowed=No se permiten clases de casos sin lista de parámetros
case.clause=Cláusula de caso
case.clauses.expected=Expectativas del arco del caso
change.signature.add.parameter.clause=Agregar cláusula de parámetro
change.signature.not.supported.extractors=El extractor no admite cambios de firma
change.signature.not.supported.implicit.functions=Los cambios de firma no se admiten en funciones implícitas
change.signature.not.supported.implicit.parameters=Los cambios de firma no son compatibles con funciones con parámetros implícitos
change.signature.parameters.same.name.{0}=Los parámetros tienen el mismo nombre\: {0}
change.signature.remove.parameter.clause=Eliminar cláusula de parámetro
change.signature.specify.type.for.parameter=Especifica el parámetro de tipo ''{0}''
change.signature.vararg.should.be.last.in.clause=Los parámetros Vararg deben colocarse al final en la cláusula de parámetro.
change.type.to=Cambiar tipo ''{0}'' a ''{1}''
changes.in.scalatest.highlighting.will.be.processed...=Los cambios realizados en el resaltado de ScalaTest se manejan correctamente solo en los archivos recién resaltados. Reinicie Intellij IDEA para optimizar su experiencia
channel.early.access.program=Programa de acceso temprano
channel.nightly.builds=Construcción nocturna
channel.stable.releases=Lanzamiento estable
choose.class.for.introduce.field=Seleccionar clase para insertar campos
choose.either.a.scala.sdk.directory.or.scala.jar.files=Seleccione el directorio Scala SDK o el archivo jar de Scala (permitir\: binarios, fuente, documentación)
choose.expected=Esperando ''<-'' en la sintaxis del generador
choose.expression.for=Seleccione expresión para {0}
choose.function.for.refactoring=Seleccionar función para {0}
choose.level.for.extract.method=Seleccione el nivel del método de extracción
choose.level.popup.title=Selecciona el nivel
choose.scope.for=Seleccionar rango {0}
choose.type.element.for=Seleccione el tipo de elemento para {0}
class.already.exists.in.package=Ya existe una clase con nombre {0} en el paquete {1}
class.has.several.subclasses={0} se extiende por subclase
class.has.subclasses=Criterios ampliados
class.is.abstract.it.cannot.be.instantiated=''{0}'' es abstracto y no se puede crear una instancia
class.to.pull.up.members.to.class=Clase para elevar el miembro a {0}
click.or.press.shortcut.to.change=(Haga clic o toque {0} para cambiar)
click.to.change=(Haga clic para cambiar)
code.block=Bloque de código
codegeneration.panel.title=Codigo de GENERACION
colon.expected=''\:'' expectativa
column.enabled=Usar
column.transformation=Conversión
command.introduce.type.alias=Insertar alias de tipo
companion.class=Clase
companion.enum=Enumeración
companion.object=Objeto
companion.trait=Característica
compile.order=Orden de compilación (&O)\:
compile.order.java.then.scala=Java y luego Scala
compile.order.mixed=Mezcla
compile.order.scala.then.java=Scala y luego Java
compiler.plugins=Complemento del compilador
compound.type.expected=Expectativa de tipo complejo
condition.expected=Espera condicional booleano
configure.updates=Configurar actualizaciones...
constructor=Constructor
constructor.cannot.be.instantiated.to.expected.type=No se puede inicializar el constructor con el tipo esperado, encontrado\: {0}, requerido\: {1}
constructor.invocation.expected=''esta'' expectativa
context.bounds.not.allowed=Límites de contexto no permitidos
contravariant.type.covariant.position.of.method=El tipo covariante {0} aparece en la posición covariante en el tipo {1} del método {2}
contravariant.type.covariant.position.of.value=El tipo covariante {0} aparece en la posición covariante en el tipo {1} del valor {2}
contravariant.type.invariant.position.of.method=El tipo covariante {0} aparece en la posición no covariante en el tipo {1} del método {2}
contravariant.type.invariant.position.of.value=El tipo covariante {0} aparece en la posición no covariante en el tipo {1} del valor {2}
control.curly.braces.based.on.line.indents=Controlar las llaves según la sangría de línea\:
convert.java.to.scala.collection.hint=¿Convertir a la colección Scala usando asScala?
convert.java.to.scala.collection.name=Convertir a la colección Scala
convert.scala.to.java.collection.hint=¿Convertir a una colección Java usando asJava?
convert.scala.to.java.collection.name=Convertir a colección Java
convert.to.explicit.symbol=Convertir a símbolo ("{0}")
convert.to.explicit.symbol.family=Convertir a símbolo explícito
convert.to.hex.fix=Convertir literal octal a hexadecimal
convert.to.long.fix=Convertir a literal largo
convert.to.typed.pattern=Convertir a patrón escrito
convert.view.and.context.bounds.to.implicit.parameters=Conversión de límites de vista y contexto en parámetros implícitos
copy.link.to.clipboard=Copiar enlace al portapapeles
copy.scaladoc=Copiar y ScalaDoc
could.not.decompile.file.comment=//No se puede descompilar {0}
could.not.find.type.for.selection=Tipo de selección no encontrada
could.not.infer.type.of.underscore.section=No se puede inferir el tipo de sección de subrayado
could.not.perform.inplace.rename=No se puede realizar el cambio de nombre in situ\:\nNo se ha especificado ningún nombre
coursier.v1.cache=Caché de Courier v1
covariant.type.contravariant.position.of.method=El tipo covariante {0} aparece en la posición contravariante en el tipo {1} del método {2}
covariant.type.contravariant.position.of.value=El tipo covariante {0} aparece en la posición contravariante en el tipo {1} del valor {2}
covariant.type.invariant.position.of.method=El tipo covariante {0} aparece en la posición no covariante en el tipo {1} del método {2}
covariant.type.invariant.position.of.value=El tipo covariante {0} aparece en la posición no covariante en el tipo {1} del valor {2}
create.annotation.class.named=Crear clase de anotación ''{0}''
create.apply.method.in={0} Crear mi método ''aplicar''
create.case.class.named=Crear clase de caso ''{0}''
create.class.named=Crear clase ''{0}''
create.companion.object.for.class=Crea un objeto complementario para tu clase.
create.extractor.object.named=Crear objeto extractor ''{0}''
create.method.named=Crear método ''{0}''.
create.new.scala.class=Crear una nueva clase de Scala
create.new.scala.class.or.file=Crear una nueva clase/archivo de Scala
create.object.named=Crear objeto ''{0}''
create.parameter.named=Crear parámetro {0}
create.parameterless.method.named=Crear método sin parámetros ''{0}''
create.trait.named=Crear propiedad ''{0}''
create.unapply.method.in={0} Crear mi método ''desaplicar''
create.value.named=Crear valor ''{0}''
create.variable.named=Crear variable ''{0}''
debug.info.level.complete.no.tail.call.optimization=Optimización completa y sin colas
debug.info.level.none=Ninguno
debug.info.level.source=Propiedades del archivo fuente
debug.info.level.source.and.line.number=Información de fuente y número de línea
debug.info.level.source.line.number.and.local.variable=Fuente, número de línea e información de variable local
debugging.info.level=Nivel de información de depuración (&L)\:
def.dcl.expected=Definir o declarar expectativas
def.name=Definitivo {0}
default.init.prohibited.literal.types=Inicialización predeterminada prohibida en var de tipo literal
default.ta.settings=Configuración
default.ta.tooltip=Configurar los ajustes de anotación de tipo
default.value.is.missing.default.arguments=No existe un valor predeterminado. El argumento predeterminado contiene espacios en lugar del nuevo valor del parámetro.
default.value.is.missing.method.calls=No existe un valor predeterminado. La llamada al método contiene espacios en lugar de nuevos valores de parámetros.
default.values=Valor por defecto\:
delete.closing.brace=Elimine '{' y elimine el paréntesis de cierre.
delete.inlined.tag=Eliminar etiquetas en línea
delete.unknown.tag=Eliminar etiquetas desconocidas
dependent.function.types.are.not.yet.supported=Los tipos de funciones dependientes aún no son compatibles
deprecation.warnings=&Ruta de desaprobación
deprecation.warnings.tooltip=Enviar advertencias y ubicación del uso obsoleto de API
derives.cannot.be.unified={0} no se puede combinar con el argumento de tipo de {1}.
derives.no.member.named.derived=El valor derivado no es miembro del objeto {0}
derives.not.a.class.type={0} no es un tipo de clase y no se puede derivar
derives.scala.class.expected=Requiere clase/rasgo de Scala
derives.type.has.no.companion.object={0} no se puede derivar porque no tiene ningún objeto complementario.
derives.type.has.no.type.parameters={0} no se puede derivar porque no tiene parámetros de tipo.
descriptive.name.anonymous=Anónimo
desugar.add.explicit.override.modifier=Agregar un controlador de "anulación" explícito
desugar.append.semicolon=Agregar punto y coma
desugar.canonize.arity.0.call=Normalización de llamadas arity-0
desugar.canonize.block.argument=Normalizar argumentos de bloque vacío
desugar.canonize.infix.call=Normalizar llamadas infijas
desugar.canonize.postfix.call=Normalización de llamadas por sufijo
desugar.convert.implicit.class.to.class.and.function=Convertir clases implícitas en clases y funciones.
desugar.convert.parentheses.to.braces.in.for.comprehensions=Convertir paréntesis en llaves para anidar
desugar.enforce.parentheses.in.constructor.invocation=Forzar paréntesis al llamar al constructor
desugar.expand.apply.call=Ampliando la convocatoria "aplicar"
desugar.expand.assignment.call=Extensión de llamada de asignación
desugar.expand.auto.tupling=Extensiones de tupla automática
desugar.expand.context.bound=Extensión vinculada al contexto
desugar.expand.dynamic.call=Expansión dinámica de llamadas
desugar.expand.eta.expansion=Extensión de extensión eta
desugar.expand.for.comprehensions=Para expansión anidada
desugar.expand.function.instantiation=Extensión de creación de instancias de funciones
desugar.expand.function.type=Extensión del tipo de función
desugar.expand.implicit.conversion=Extensión de conversión implícita
desugar.expand.macro=Macroexpansión
desugar.expand.placeholder.syntax=Expansión de sintaxis de marcador de posición
desugar.expand.procedure.syntax=Extensiones de sintaxis procesal
desugar.expand.property.declaration=Ampliación de declaración de propiedad
desugar.expand.property.definition=Ampliar definiciones de propiedades
desugar.expand.property.setter.call=Ampliar las llamadas al establecimiento de propiedades
desugar.expand.single.abstract.methods=Ampliando un único método abstracto
desugar.expand.string.interpolation=Extensión de interpolación de cadenas
desugar.expand.to.equals.call=Expande "\=\=" para llamar "igual"
desugar.expand.tuple.instantiation=Extensión de creación de instancias de tupla
desugar.expand.tuple.type=Extensión de tipo tupla
desugar.expand.type.alias=Expansión de alias de tipo
desugar.expand.unary.call=Extensión de llamada unaria
desugar.expand.update.call=Ampliando la llamada de "actualización"
desugar.expand.vararg.argument=Expansión del argumento vararg
desugar.expand.view.bound=Ampliar los límites de la vista
desugar.expand.wildcard.import=Expansión de declaración de importación comodín
desugar.for.comprehension=Para desazucar anidado
desugar.fully.qualify.import.expression=Normalizar completamente las expresiones de importación
desugar.fully.qualify.reference=Normalizar completamente las referencias
desugar.function.parameter=Parámetros de función
desugar.group.declarations=Declaración
desugar.group.expressions=Expresión
desugar.group.functions=Función
desugar.group.general=Común
desugar.group.implicits=Implícito
desugar.group.method.invocations=Llamada al método
desugar.group.references=Referencia
desugar.group.type.annotations=Tipo de anotación
desugar.group.types=Categoría
desugar.inscribe.default.arguments=Insertar argumentos predeterminados
desugar.inscribe.explicit.braces=Insertar llaves explícitas
desugar.inscribe.implicit.parameters=Insertar parámetros implícitos
desugar.make.eta.expansion.explicit=Establecer explícitamente la extensión eta
desugar.make.method.return.expressions.explicit=Establecer explícitamente expresiones de retorno de métodos
desugar.method.definition=Definición del método
desugar.partially.qualify.simple.reference=Normalizar parcialmente referencias simples.
desugar.reference.pattern=Patrón de referencia
desugar.replace.underscore.section.with.default.value=Reemplace las secciones subrayadas con valores predeterminados
desugar.scala.code.action.description=Desazucarar el código Scala (área seleccionada/archivo completo)
desugar.scala.code.action.text=Desazucarando el código Scala...
desugar.scala.code.in.scope=Desazucarando el código Scala ({0})
desugar.substitute.anyref=Alternativa a AnyRef
desugar.type.parameters=Tipo de parámetro
desugar.underscore.parameter=Parámetro subrayado
desugar.value.definition=Definición de valor
desugar.variable.definition=Definición de variable
disabled.word=Deshabilitado
displayname.scala.compiler=Compilador escala
do.statement=Hacer declaración
documentation.for.project={0} documento
does.not.take.parameter.default.target=Solicitud
dot.expected=''.'' expectativa
dot.or.cq.expected=''.'' o calificador de clase requerido
downloading.scala.version=Descargando Scala {0}
downloading.url=Descargando {0}
edit.package.prefix=Editar prefijo de paquete...
else.expected=Se requiere 'más'
empty.new.expression=Nueva expresión vacía
enable.continuations=&Activación continua
enable.loading.external.extensions=Habilitar carga de extensión externa
enable.specialization=&Activar materialización
enable.specialization.tooltip=Cumple con la anotación @specialize
enable.warnings=Activar & Advertencia
enable.warnings.tooltip=Crear alerta
enabled.word=Habilitado
end.of.string.expected=Esperar el final de la cadena
enumerators.binding.case.keyword.found=Patrón esperado pero "caso" encontrado
enumerators.binding.val.keyword.deprecated=La palabra clave ''val'' en los enumeradores está obsoleta
enumerators.expected=Esperando un enumerador dentro de una declaración ''para''
enumerators.generator.val.keyword.found=Patrón esperado, pero se encontró ''val''
erasure.warning=(todavía puede coincidir con ese borrador)
error.downloading.scala.version=Error al descargar Scala {0}
error.message.title.create.entity.quickfix=Crear solución rápida de entidad
error.wrong.caret.position.method.name=El símbolo de intercalación debe colocarse en el nombre del método que se va a refactorizar.
except.for.base.package=Excluido el paquete básico
exclude.value.from.auto.import=Excluyendo ''{0}'' de la importación automática.
existential.block.expected=Espero que existas
expand.macro=Macroexpansión
expand.to.new.pattern=Extensión\: {0}
expected.another.pattern=Espere un patrón diferente
expected.at.least.one.extension.method=Se requiere al menos 1 método de extensión
expected.case.on.a.new.line=Se requiere un caso en una nueva línea
expected.do=''hacer'' es obligatorio
expected.do.or.yield=Se requiere ''hacer'' o ''ceder''
expected.more.types=Necesita más tipos
expected.new.line.after.colon=Se requiere una nueva línea después de los dos puntos
expected.then=''entonces'' es necesario
expected.type.boolean=El método {0} espera un tipo booleano como tipo de retorno
expected.type.constructor=Se requiere el constructor de tipo {0}
explain.type.errors=Tipo Descripción del error (&E)
explain.type.errors.tooltip=Tipo de error Descripción detallada
expr.type.does.not.conform.expected.type=La expresión de tipo {0} no se ajusta al tipo esperado {1}
expression.expected=Expectativa de expresión
extension.method.expected=Necesitas un método de extensión
extension.method.overrides.regular=El método {0} es un método de extensión y no se puede anular como método normal.
extensions.in.selected.library=Ampliación dentro de la biblioteca seleccionada
extract.abstracts=Extracción de elementos abstractos
extract.file.method=Método de extracción de archivo
extract.local.method={0} Extraer mi método local
extract.local.method.in.else.block=Extraer métodos locales dentro del bloque else
extract.method.cannot.find.possible.scope=Posible alcance para el método extraído no encontrado
extract.method.title=Extracción del método
extract.method.to.anonymous.class=Extraer métodos en clases anónimas
extract.method.to.class.name=Extraer método en la clase {0}
extract.method.to.object.name=Extraer método en el objeto {0}
extract.method.to.package.name=Extraer método en el paquete {0}
extract.method.to.trait.name=Método de extracción por atributo {0}
extract.trait.action.description=Extraer características de clases seleccionadas
extract.trait.action.text=Extracción de características...
extract.trait.name=Nombre del Atributo\:
extract.trait.package.label=Paquete para nueva característica\:
extract.trait.title=Extracción de características
extract.trait.top.label.text=Extraer características de\:
extraction.of.anonymous.class.with.vars.refs.unsupported=Actualmente no se admite la extracción de clases anónimas con referencias a variables fuera de alcance.
failed.to.found.corresponding.underscore.section=No se encontró la sección de subrayado correspondiente
family.name.add.braces=Agregar llaves
family.name.add.collection.breakout=Agregue `colección.breakOut`
family.name.add.empty.parentheses=Agregar paréntesis vacíos
family.name.adjust.types=Ajuste de tipo
family.name.change.type=Tipo de cambio
family.name.comparing.length=Comparando longitud
family.name.convert.from.infix.expression=Conversión de expresión infija
family.name.convert.implicit.bounds=Conversión ligada implícita
family.name.convert.parameter.to.underscore.section=Convertir parámetros a secciones subrayadas
family.name.convert.to.curly.braces=Convertir a llaves
family.name.convert.to.desugared.expression=Convertir a expresión desazucarada
family.name.convert.to.infix.expression=Convertir a expresión infija
family.name.convert.to.object=Convertir a objeto
family.name.convert.underscore.section.to.parameter=Convertir secciones subrayadas en parámetros
family.name.create.annotation.class=Crear clase de anotación
family.name.create.apply.method=Crear método ''aplicar''
family.name.create.case.class=Crear clase de caso
family.name.create.class=Crear clase
family.name.create.companion.object=Crear objeto complementario
family.name.create.extractor.object=Crear objeto extractor
family.name.create.method=Crear método
family.name.create.object=Crear objeto
family.name.create.parameter=Crear parámetros
family.name.create.parameterless.method=Crear método sin parámetros
family.name.create.trait=Crear características
family.name.create.unapply.method=Crear método ''desaplicar''
family.name.create.value=Crear valor
family.name.create.variable=Crear variable
family.name.enable.type.mismatch.hints=Habilitar sugerencia de discrepancia de tipos
family.name.expand.to.constructor.pattern=Extendiendo al patrón constructor
family.name.filter.set.contains=El conjunto contiene filtrado
family.name.give.a.name.to.anonymous.abstract.given=Nombrar el resumen anónimo proporcionado
family.name.implement.anonymous.abstract.given=Resumen anónimo dada la implementación
family.name.import.additional.identifiers=Obtener identificadores adicionales
family.name.import.all.members=Obtener todos los miembros
family.name.import.member.with.stable.path=Importar miembros por ruta estable
family.name.make.implicit.conversion.explicit=Hacer explícitas las conversiones implícitas
family.name.remove.braces=Retire los tirantes.
family.name.remove.case.from.enumerator=Eliminar ''caso'' del enumerador
family.name.remove.tailrec.annotation=Eliminar la anotación @tailrec
family.name.remove.unnecessary.apply=Eliminar aplicaciones innecesarias
family.name.replace.type.check.with.pattern.matching=Reemplazo de verificación de tipo con coincidencia de patrones
family.name.replace.type.with.type.in.vararg.pattern=Reemplace ''{0}'' con ''{1}'' en el patrón vararg
family.name.replace.with.scala3.vararg.pattern=Reemplazo de la sintaxis ':' con el patrón vararg de Scala 3.0
family.name.some.to.option=Algunos a la opción
family.name.use.infix.type.syntax=Usando sintaxis de tipo Infijo
family.name.use.prefix.type.syntax=Usar sintaxis de tipo de prefijo
feature.dynamics=Elementos dinámicos (&D)
feature.existential.types=Tipo de existencia (&E)
feature.experimental.features=Funciones experimentales (&X)
feature.higher.kinded.types=Tipo aguas arriba (&E)
feature.implicit.conversions=Conversión implícita (&I)
feature.macros=Macro
feature.postfix.notation=Usando el operador de prefijo (&P)
feature.reflective.calls=Llamada reflexiva (&R)
feature.warnings=&Alerta de función
feature.warnings.tooltip=Enviar alerta de función de idioma.
features=Detalles de la función
field.occurrences={0} Dónde se utiliza
file.is.not.writable=El archivo no se puede escribir
file.type.scala.outlines=Esquema de escala
final.modifier.is.not.allowed.here=El controlador ''final'' no está permitido
final.modifier.is.redundant.with.final.parents=El controlador ''final'' es redundante con un objeto o miembro de clase final
final.modifier.not.with.declarations=El modificador ''final'' no se puede utilizar con miembros incompletos
final.modifier.not.with.trait=Modificador ''final'' no permitido en el atributo
find.what.companion.module.checkbox=&Dónde utilizar los módulos complementarios
find.what.implementing.type.definitions.checkbox=&Implementación de definición de tipo
find.what.members.usages.checkbox=&Dónde utilizar los miembros
find.what.new.instances.usages=&Solo creación de instancias
for.pattern.bindings.require.scala3=La sintaxis ''case'' dentro del enlace del patrón ''for'' requiere Scala 3.0
for.statement=Para la sintaxis
forward.reference.detected=Referencia directa incorrecta
fruitless.type.test=Prueba de tipo sin resultado\: Los valores de tipo {0} no pueden ser simultáneamente {1}
fun.sign.expected=''\=>'' esperado
function.expression=Expresión de función
function.must.define.type.explicitly=El método {0} tiene una declaración de devolución, por lo que se requiere un tipo de resultado
function.recursive.need.result.type=El método recursivo {0} requiere un tipo de resultado
generate.scaladoc=Crear un Scaladoc
generate.scaladoc.action.description=Crear un Scaladoc
generate.scaladoc.action.text=Crear un Scaladoc
given.alias.declaration.must.be.named=Anónimo dado no puede ser abstracto
go.to.companion=Ir al compañero {0}
go.to.implementation=Ir a Implementación
go.to.super.method=Ir al miembro padre
goto.super.class.chooser.title=Seleccionar clase principal
goto.super.class.or.member.chooser.title=Seleccionar clase principal/miembro principal
goto.super.member.chooser.title=Seleccionar miembro padre
gutter.companion=Compañero
gutter.implemented=Miembros implementados
gutter.implementing=Implementación de miembros en progreso
gutter.overridden=Miembro redefinido
gutter.overriding=Redefiniendo miembro
gutter.recursion=Tipo recursivo
gutter.sam=Implementación SAM
has.companion=Incluye acompañante {0}
has.implementations=Miembro contiene implementación
has.no.reference=Sin referencia
hint.label.expected=Necesario
hint.label.non.singleton=Sin singleton
hint.label.original=Original
hint.label.simplified=Simplificado
how.to.add.custom.macro.support.help.link.title=Cómo agregar compatibilidad con macros Scala personalizadas
html.unable.to.launch.web.browser=<html><body>El navegador web no se puede iniciar, así que ábralo manualmente\:<br />{0} (<a href\="{0}">Copiar al portapapeles</a>)</body > </html>
id.is.already.defined={0} ya está definido en el alcance
idea.based.scala.project=Proyecto Scala basado en IDEA
idea.is.outdated.please.update=IDEA no está actualizada con la rama {0} del complemento Scala.<br/>Para utilizar el complemento Scala más reciente, actualice IDEA a {1} o superior.
idea.will.try.to.search.for.extra.support.for.particular.libraries=IDEA intentará encontrar soporte adicional para bibliotecas específicas en su proyecto.
identifier.expected=Expectativa del identificador
identifier.expected.but.0.found=Se requiere un identificador pero se encontró {0}.
identifier.expected.comma.found=Identificador esperado pero '''' encontrado
identifier.or.opening.brace.expected=Se requiere un identificador o llave de apertura
identifier.or.wild.sign.expected=Esperando un identificador o ''_''
if.block=Si bloque
illegal.assignment.target=Objetivo de sustitución no válido
illegal.inheritance.extends.enum=Se prohíben las ampliaciones de enumeración.
illegal.inheritance.from.final.kind=Herencia no válida del {0} ''{1}'' final
illegal.inheritance.from.sealed.kind=Herencia no válida de {0} ''{1}'' sellado
illegal.inheritance.from.value.class=Herencia no válida de la clase de valor ''{0}''
illegal.inheritance.multiple={0} ''{1}'' heredado varias veces
illegal.inheritance.self.type=Herencia no válida, el tipo propio {0} no se ajusta a {1}
illegal.instantiation={0} ''{1}'' es abstracto y no se puede crear una instancia
illegal.mixin={0} ''{1}'' debe ser una propiedad combinable
illegal.modifiers.combination=Combinación de controlador no válida\: {0} y {1}
illegal.secondary.constructors.value.class=Los constructores secundarios no están permitidos en clases de valor.
illegal.undefined.member=Los miembros declarados pero no definidos solo pueden tener clases
illegal.underscore.separator=Necesitas Scala 2.13 para usar el delimitador de guión bajo
implement.members.fix=Implementación de miembros
implements.member.from.prefix=Implementación de miembros en
implements.member.from.several.classes=Miembro de implementación en la clase {0}
implements.member.prefix=Implementación de miembros
implicit.argument.is.applicable=Se pueden aplicar argumentos implícitos.
implicit.arguments=Argumentos implícitos\:
implicit.arguments.for.implicit.conversion=Argumentos implícitos para la conversión implícita\:
implicit.class.must.have.a.primary.constructor.with.one.argument=Las clases implícitas deben tener un constructor predeterminado con exactamente un argumento en la primera lista de parámetros.
implicit.conversions.action.description=Indicación de conversión implícita
implicit.conversions.action.text=Mostrar conversión implícita
implicit.is.diverged=Implícito se ha ramificado
implicit.modifier.can.be.used.only.for=Los modificadores ''implícitos'' solo se pueden usar en valores, variables, métodos y clases.
implicit.modifier.cannot.be.used.for.top.level.objects=El modificador ''implícito'' no se puede utilizar en objetos de nivel superior
implicit.params.excepted=Una cláusula de parámetro implícita debe contener al menos un parámetro.
import.additional.identifiers.from.qualifier=Obtenga identificadores adicionales de los calificados
import.all.members.of.reference=Reúne a todos los miembros de {0}
import.as=Importar como ''{0}''
import.class=Clase de importación
import.class.chooser.title=Clase para importar
import.conversion.chooser.title=Conversión para importar
import.expr.should.be.qualified=Las expresiones de importación deben estar normalizadas.
import.extension.method=Importar método de extensión...
import.extension.method.chooser.title=Método de extensión para importar
import.global.member=Consigue miembros globales
import.hint.text={0}? Alt+Enter {1}
import.implicit=Obtener elementos implícitos...
import.implicit.chooser.title=Elemento implícito para obtener
import.implicit.conversion=Importar conversión...
import.multiple.choices=(selección múltiple...)
import.package=Paquete de importación
import.package.chooser.title=Paquete para importar
import.selector.expected=Expectativa del selector de importación
import.something=Importar...
import.something.chooser.title=Que traer
import.stable.member={0} importar
import.with=Importar ''{0}''
import.with.prefix=Importar con prefijo
import.with.prefix.ellipsis=Importar con prefijo...
imports.panel.add.fully.qualified.imports=Agregar declaraciones de importación completas
imports.panel.add.import.statement.in.closest.block=Agregar declaración de importación al bloque más cercano
imports.panel.add.import.to.always.mark.it.as.used=Agregue una declaración de importación para marcar como siempre utilizada
imports.panel.add.package.name=Agregar nombre del paquete
imports.panel.add.pattern.to.use.appropriate.classes.only.with.prefix=Agregue un patrón que use clases que contengan solo el prefijo
imports.panel.always.mark.as.used=Marcar siempre como usado
imports.panel.base.package.help=Si el paquete base es <code>org.example.application</code>, la clase <code>org.example.application.NAME</code> debe importarse con <code>import NAME</code>
imports.panel.class.count.to.use.import.with=Número de clases que utilizan importar con ''_''\:
imports.panel.classes.to.use.only.with.prefix=Clase a usar que contiene solo el prefijo
imports.panel.do.not.change.path.during.optimize.imports.for.local.imports=No cambie las rutas durante la optimización de la declaración de importación local
imports.panel.force.scala2.in.source3=Obtenga sintaxis al usar -Xsource:3:
imports.panel.honestly.mark.imports.as.unused=Marcar francamente las declaraciones de importación como obsoletas
imports.panel.import.layout=Obtener diseño
imports.panel.import.layout.manager=Administrador de diseño de importación
imports.panel.imports.always.marked.as.used=Declaración de importación marcada como siempre utilizada
imports.panel.lexicographically=Alfabéticamente
imports.panel.merge.imports.with.the.same.prefix.into.one.statement=Fusionar declaraciones de importación con el mismo prefijo en una sola declaración
imports.panel.no.imports.with.prefix=Sin declaraciones de importación con prefijo
imports.panel.scalastyle.consistent=Coincidencia de estilo escalable
imports.panel.sort.imports.for.optimize.imports=Alinear declaraciones de importación (optimizar declaraciones de importación)\:
imports.panel.title=Importar
imports.panel.use.references.with.prefix=Utilice referencias que contengan el prefijo\:
imports.panel.use.the.shortest.path.when.trying.to.import.reference.with.already.imported.name=Utilice la ruta más corta al intentar importar referencias con nombres ya importados
incompatible.plugin.detected=Se detectó un complemento incompatible
incrementality.type=Elemento incremental (&I)\:
indent.pasted.lines.at.caret=Líneas de sangría pegadas en el cursor
indented.definitions.expected=Necesito una definición sangrada
inline.local.method.elements.header=Método local para en línea
inline.local.method.label=¿Método local en línea {0}?
inline.local.type.alias.elements.header=Alias de tipo local en línea
inline.local.type.alias.label=¿Alias de tipo local en línea {0}?
inline.local.variable.elements.header=Variables locales para en línea
inline.local.variable.label=¿Variable local en línea {0}?
inline.method.elements.header=Método para en línea
inline.method.label=¿Deberíamos incorporar el método {0}?
inline.method.title=Método en línea
inline.occurrences.label=({0} {0,choice, 1\#donde se usa|2\#donde se usa})
inline.type.alias.elements.header=Escriba alias en línea
inline.type.alias.label=¿Alias de tipo en línea {0}?
inline.type.alias.title=Alias de tipo en línea
inline.variable.elements.header=Variables para en línea
inline.variable.label=¿Deberíamos incorporar la variable {0}?
inline.variable.title=Variables en línea
insert.block.braces.automatically.based.on.indentation=Agregar llaves automáticamente
insert.block.braces.automatically.based.on.indentation.tooltip=Agregue llaves al editar código para convertir un bloque de una sola línea en un bloque de varias líneas
insert.pair.multiline.quotes=Insertar comillas dobles en varias cadenas
integer.literal.is.out.of.range=El literal entero está fuera del rango para el tipo int
intention.add.explicit.unit.type.annotation=Agregar anotación de tipo de unidad implícita
intention.family.put.on.one.line=Coloque {0} en una línea
intention.family.put.on.separate.lines=Coloque {0} en una línea separada
intention.for.comprehension.convert.to.parentheses=Convertir a paréntesis
intention.type.annotation.function.add.text=Agregar anotación de tipo a la definición de función
intention.type.annotation.function.regenerate.text=Regenerar anotaciones de tipo para definiciones de funciones
intention.type.annotation.function.remove.text=Eliminar anotación de tipo de la definición de función
intention.type.annotation.parameter.add.text=Agregar anotación de tipo a los parámetros
intention.type.annotation.parameter.remove.text=Eliminar anotación de tipo de los parámetros
intention.type.annotation.pattern.add.text=Agregar anotación de tipo a la definición de patrón
intention.type.annotation.pattern.remove.text=Eliminar anotación de tipo de la definición de patrón
intention.type.annotation.regen.family=Regenerar anotaciones de tipo
intention.type.annotation.toggle.family=Anotación de tipo de interruptor
intention.type.annotation.underscore.add.text=Agregar anotación de tipo al parámetro de subrayado
intention.type.annotation.underscore.remove.text=Eliminar anotación de tipo del parámetro de guión bajo
intention.type.annotation.value.add.text=Agregar anotación de tipo a la definición de valor
intention.type.annotation.value.regenerate.text=Regenerar anotaciones de tipo para definiciones de valores
intention.type.annotation.value.remove.text=Eliminar anotación de tipo de la definición de valor
intention.type.annotation.variable.add.text=Agregar anotación de tipo a la definición de variable
intention.type.annotation.variable.regenerate.text=Regenerar anotaciones de tipo para definiciones de variables
intention.type.annotation.variable.remove.text=Eliminar anotación de tipo de la definición de variable
introduce.field.title=Extracción de campo
introduce.parameter.title=Insertar parámetro
introduce.type.alias.title=Insertar alias de tipo
introduce.variable.declare.as.var=&Variable
introduce.variable.identifier.is.not.valid=El identificador no es válido
introduce.variable.specify.type.explicitly=Tipo de designación
introduce.variable.title=Insertar valores/variables
introduced.typeAlias.will.conflict.with.class.name=El alias de tipo que insertó entra en conflicto con el nombre de clase\: {0}
introduced.typeAlias.will.conflict.with.type.name=El alias de tipo que insertó entra en conflicto con el nombre de tipo\: {0}
introduced.variable.will.conflict.with.class.parameter=La variable insertada entra en conflicto con (o está oculta por) un parámetro de clase\: {0}
introduced.variable.will.conflict.with.field=La variable insertada entra en conflicto con (o está oculta por) un campo o método sin parámetros\: {0}
introduced.variable.will.conflict.with.local=La variable insertada entra en conflicto con una variable local (o está oculta por una variable local)\: {0}
introduced.variable.will.conflict.with.parameter=La variable insertada entra en conflicto con el parámetro (o está oculta por el parámetro)\: {0}
invalid.scala.version.format=Formato de versión de Scala no válido: {0}
invalid.update.channel=Canal de actualización no válido
is.overridden.by=Miembro contiene anulación
italic.surrounder.template.description=Cursiva\: '' ''
ivy2.cache=Hiedra oculta2
ivy2.indexing.mode.classes=Clase
ivy2.indexing.mode.disabled=Deshabilitar
ivy2.indexing.mode.metadata=Metadatos
java.collection=Colección Java
java.constructors.only.have.one.parameter.section=El constructor de Java contiene solo una sección de parámetros
known.extension.libraries=Bibliotecas de extensiones conocidas
lazy.modifier.is.not.allowed.here=El modificador ''lazy'' solo se permite para definiciones de valores
lazy.modifier.is.not.allowed.with.param=El modificador ''lazy'' no está permitido; utilice en su lugar el parámetro llamada por nombre
lazy.values.may.not.be.abstract=El valor perezoso no puede ser abstracto.
lbrace.expected=''{'' se requiere
library.type.scala.sdk=Scala SDK
line.is.indented.too.far.to.the.left=La línea tiene una sangría demasiado a la izquierda
local.project.libraries=Biblioteca de proyectos locales
local.variables.must.be.initialized=Las variables locales deben inicializarse.
location.description.anonymous.class=Clase anónima
location.description.body.of.name=Cuerpo de {0}
location.description.containing.block=Bloque incluido
location.description.parameter.of.getclassnametext=Parámetros de {0}
location.description.parameter.of.name=Parámetros de {0}
long.literal.is.out.of.range=El número entero está incluso fuera del rango para el tipo largo
lower.bound.conform.to.upper=El límite inferior no respeta el límite superior.
lowercase.long.marker=Marcador literal largo escrito en minúsculas
lowercase.long.marker.fix=Convertir marcador literal largo a mayúsculas
macro.defs.must.have.explicit.return.type=Las definiciones de macro deben contener un tipo de retorno especificado explícitamente
main.method.parameters.table.column.title.name=Nombre
main.method.parameters.table.column.title.type=Categoría
main.method.parameters.table.column.title.value=Valor
make.explicit=Establecer explícitamente
make.explicit.and.import.method=Establecer explícitamente (método de importación)
make.implicit.conversion.explicit.action.description=Hacer explícitas las conversiones implícitas
make.implicit.conversion.explicit.action.text=Hacer explícitas las conversiones implícitas
make.import.fully.qualified=Normalizar declaraciones de importación
make.non.private.title=Hacer que una propiedad no sea privada
make.protected.fix=Hacer una propiedad protegida
make.public.fix=Hacer pública una propiedad
make.type.more.specific=Hacer que los tipos declarados sean más específicos
make.type.more.specific.fun=Hacer que el tipo de devolución sea más específico
match.type.cases.expected=Expectativas de la cláusula de caso de tipo de coincidencia
maven.local.repo=Repositorio local de Maven
member.cannot.override.val=El método {0} requiere un valor inmutable estable
member.implementation.required={0} ''{1}'' debe declararse abstracto o implementar el miembro abstracto ''{2}'' en ''{3}''
member.is.not.defined=El miembro {0} de {1} no está definido
member.needs.override.modifier={0} ''{1}'' requiere anular el controlador
member.of.anonymous.class.cannot.be.used.in.extracted.member=El miembro {0} de la clase anónima no se puede utilizar en el miembro extraído {1}
member.overrides.nothing={0} ''{1}'' no anula nada
members.to.extract=Miembro para extraer
method.annotated.with.tailrec.contains.no.recursive.calls=El método anotado @tailrec no contiene una llamada recursiva
method.annotated.with.tailrec.is.neither.private.nor.final=Los métodos anotados con @tailrec no son privados ni finales (pueden anularse)
method.invocation.might.produce.nullpointerexception=La llamada al método puede causar NullPointerException
method.invocation.will.produce.nullpointerexception=La llamada al método arroja NullPointerException
method.is.not.member=El método {0} no es miembro del tipo {1}
method.is.overridden.by.class.parameter.of.class=El método ha sido anulado por un parámetro de clase de {0} . No se admite la conversión de esto a una definición de función.
method.is.overridden.in.a.composite.pattern.definition=El método se ha anulado en la definición de patrón complejo de {0}. No se admite la conversión de esto a una definición de función.
method.is.overridden.in.a.composite.variable.definition=El método se ha anulado en la definición de variable compleja de {0}. No se admite la conversión de esto a una definición de función.
method.is.recursive=El método ''{0}'' es un método recursivo
method.is.tail.recursive=El método ''{0}'' es un método recursivo de cola
method.of.containingclass={0} de {1}
missing.argument.list.for.method=Falta lista de argumentos para el método {0}
missing.argument.list.for.method.with.explicit.list=Al método {1} le falta la lista de argumentos {0}
missing.char.value=Valor de carácter faltante
missing.getter.implementation=Falta implementación para getter: {0}
missing.parameter.type.name=Tipo de parámetro faltante\: {0}
missing.setter.implementation=Falta implementación para setter: {0}
missing.statement.for.annotation=Falta sintaxis para anotaciones
mixin.required=''{3}'' Mi miembro ''{2}'' está marcado como ''abstracto'' y ''override'' pero no se puede encontrar ninguna implementación concreta en la clase base, por lo que {0} ''{ 1 }'' debe ser una mezcla
modifier.is.redundant.for.this.definition=El modificador ''{0}'' no es necesario para esta definición.
modify.method.calls=Editar llamada al método
module.with.a.scala.sdk=Módulos que contienen el SDK de Scala
monospace.surrounder.template.description=Ancho fijo\: ` `
move.anonymousToInner.dialog.title=Convertir anónimo a interno
move.anonymousToInner.name=Convertir anónimo a interno…
move.members=Mover miembros
move.members.cannot.find.object=No se encontró ningún objeto con ese nombre.
move.members.not.supported.implicits=Los movimientos de refactorización no son compatibles con definiciones implícitas
move.members.not.supported.overridden=Los movimientos de refactorización no son compatibles con definiciones anuladas
move.members.object.name.or.qualified.name.expected=Esperando el nombre o el nombre completo de un objeto Scala
move.members.source.title=Mover miembro del objeto\:
move.members.supported.only.stable.objects=Los movimientos de refactorización solo se admiten para miembros de objetos estables
move.members.target.title=Al objeto\:
move.text.after.header.to.new.line=Mover texto a una nueva línea después de cerrar el encabezado
move.to.inner.is.not.supported=Scala no admite el movimiento de clases hacia adentro
move.to.inner.is.not.supported.title=La refactorización no es compatible
move.with.companion=Ir con un acompañante
multi.line.string.panel.align.dangling.closing.quotes=Asignar una comilla de cierre imaginaria (&A)
multi.line.string.panel.insert.margin.char.on.enter=Inserte un carácter de espacio (&I) en una nueva línea al escribir Enter
multi.line.string.panel.margin.char.indent=Caracteres de margen de sangría \:
multi.line.string.panel.margin.char.value=Carácter de margen\:
multi.line.string.panel.opening.quotes.on.new.line=Coloque una comilla de apertura (&O) en una nueva línea
multi.line.string.panel.place.closing.quotes.on.new.line.on.enter.press=Coloque comillas de cierre (&C) en una nueva línea al escribir Enter
multi.line.string.panel.process.margin.on.copy.paste=&Eliminar/Insertar márgenes al copiar/pegar
multi.line.string.panel.title=Cadena de varias líneas
multi.occurrences=({0} líneas coincidentes)
multiple.overriden.tooltip=Varios miembros anulados
multiple.overriding.tooltip=Múltiples miembros primordiales
name.does.not.take.type.arguments={0} no acepta argumentos de tipo
name.implements.member.of.qualname={0} implementa los miembros de {1}
name.overrides.member.of.qualname={0} redefine un miembro de {1}
navigate=Para navegar
navigation.findUsages.title.implementing.member=Miembro de implementación de {0}
navigation.findUsages.title.inheritors.class=Subclase de {0}
navigation.findUsages.title.inheritors.trait=Implementación de {0}
navigation.findUsages.title.overriding.member=Miembro primordial de {0}
navigation.findUsages.title.super.members=Miembro padre de {0}
navigation.findUsages.title.super.types=Miembro supertipo de {0}
navigation.title.implementing.member=<html>Seleccione el miembro de implementación de <b>{0}</b> (miembro {1} encontrado)</html>
navigation.title.inheritors.class=<html><b>{0}</b> Seleccionar subclase ({1} clase encontrada)</html>
navigation.title.inheritors.trait=<html><b>{0}</b> Seleccionar implementación ({1} clase encontrada)</html>
navigation.title.overriding.member=<html>Seleccione anular miembro de <b>{0}</b> (miembro {1} encontrado)</html>
navigation.title.super.members=Seleccione miembro padre de {0}
navigation.title.super.types=Seleccione el tipo de padre miembro de {0}
new.class.location.inner.in.class=Dentro de {0}
new.class.location.local.scope=Alcance local
new.class.location.new.file=Archivo nuevo
new.class.location.top.level.in.this.file=Nivel superior de este archivo
new.on.case.class.instantiation.redundant=Quitar el controlador ''nuevo''
new.packageobject.menu.action.description=Crear un nuevo objeto de paquete Scala
new.packageobject.menu.action.text=Objeto de paquete
newclass.menu.action.description=Crear una nueva clase de Scala
newclass.menu.action.text=Clases de escala
newclassorfile.menu.action.description=Crear una nueva clase o archivo de Scala
newclassorfile.menu.action.text=Clase/archivo Scala
no.alias.type=Sin tipo de alias
no.clazz.type.found=Tipo de clase no encontrado
no.containing.file=No existe el archivo
no.declared.type.found=Tipo definido no encontrado
no.defined.return.type=No se ha definido ningún tipo de devolución
no.element.found=Elemento no encontrado
no.expected.type.for.wildcard.naming=No se espera ningún tipo de denominación comodín
no.expression.in.parentheses=Sin expresión entre paréntesis
no.implicit.arguments=Sin argumentos implícitos
no.implicit.arguments.of.type=No hay argumentos de tipo implícitos. {0}
no.implicits.applicable.by.type=No hay elementos implícitos aplicables para cada tipo.
no.known.extension.libraries=No se conocen bibliotecas de extensiones
no.program.arguments=Sin argumentos de programa
no.response.status.from.connection.to.url=La conexión a {0} no tiene estado de respuesta
no.type.element.for.typed.pattern=Ningún elemento de tipo para el patrón de tipo
no.type.element.found=Escriba el elemento no encontrado en ''{0}''
no.type.inferred=No se puede inferir el tipo de expresión ''{0}''
no.type.inferred.for.unknown.expression=No se puede inferir el tipo de expresión
no.type.pattern=Sin patrón de tipo
no.versions.available.for.download=Sin versión descargable
not.a.polymorphic.lambda=No es una lambda polimórfica
not.enough.parameter.sections=La sección de parámetros no es suficiente.
not.found.scala.xml.node=No se puede encontrar scala.xml.Node
nothing.to.type=Escribe Nada que especificar
notification.navigation.to.overriding.members=No se puede navegar al miembro anulado durante la actualización del índice
nullable.to.notnull.param.always.message=Los parámetros anotados con @NotNull se pasan como nulos
nullable.to.notnull.param.sometimes.message=A los parámetros anotados con @NotNull se les pasan argumentos que pueden ser nulos.
nullable.to.unannotated.param.always.message=Null se pasa a un parámetro que tal vez no pueda manejar valores nulos. Intente anotarlo con @Nullable.
nullable.to.unannotated.param.sometimes.message=Los argumentos que pueden ser nulos se pasan a parámetros que tal vez no puedan manejar valores nulos. Intente anotarlo con @Nullable.
numeric.literal.family=Literal numérico
object.creation.impossible.since={0}, por lo tanto no se puede crear el objeto
octal.literals.removed=La sintaxis literal octal ha sido deshabilitada desde Scala 2.11
only.classes.can.be.open=Sólo se pueden abrir clases.
only.for.scala=Esto sólo funciona para archivos Scala
only.inline.methods.may.have.inline.args=El modificador 'inline' solo se puede usar para argumentos de métodos en línea
opaque.modifier.allowed.only.for.type.aliases=El modificador 'opaco' solo se permite en alias de tipo
optimise.bytecode=Optimización del curso de bytes (y úselo con cuidado*)
optimise.bytecode.tooltip=Aplique optimizaciones a sus programas para producir códigos de bytes más rápidos. Pueden ocurrir varios problemas de compilación. Úselo con precaución.
options=Opción
options.scala.display.name=Scala
other.panel.alternate.indentation.for.constructor.args.and.parameter.declarations=Sangría alternativa para declaraciones de parámetros y argumentos del constructor\:
other.panel.enforce.functional.syntax.for.methods.with.unit.return.type=Forzar la sintaxis de la función para métodos con tipo de retorno Unidad
other.panel.implicit.class.prefix.suffix=Prefijo/sufijo de clase implícito
other.panel.kind.projector.replace.lambda.with.unicode.symbol=Kind Proyector\: Convertir ''Lambda'' a símbolo Unicode
other.panel.reformat.on.compile=Reformatear en tiempo de compilación
other.panel.replace.in.for.generator.with.unicode.symbol=Reemplace ''<-'' en el generador \"for\" con un símbolo Unicode.
other.panel.replace.with.unicode.symbol=Convertir ''\=>'' a símbolo Unicode
other.panel.replace.with.unicode.symbol1=Convertir ''->'' a símbolo Unicode
other.panel.spaces=Brecha
other.panel.title=Otros
out.of.compilation.unit=Rompiendo el dispositivo de compilación
output.dir=Directorio de salida
override.modifier.is.not.allowed=El modificador ''override'' no está permitido
override.modifier.is.not.allowed.for.classes=El modificador ''override'' solo se permite en miembros de definición de tipo
override.types.not.conforming=El tipo de anulación {0} no se ajusta al tipo base {1}
overrides.member.from.prefix=Anular miembro en
overrides.member.from.several.classes=Anulando miembros en la clase {0}
overrides.type.from.super.several.classes=Tipo de anulación para la clase {0}
overrides.type.prefix=Anulación de tipo
package.prefix.example=Ejemplo\: ''org.ejemplo.aplicación''
package.prefix.help=Si el prefijo del paquete es <code>org.example.application</code>, <code>PATH</code> en el directorio fuente significa <code>org/example/application/PATH</code>, por lo que un explícito No es necesario crear los subdirectorios <code>org</code>, <code>example</code> y <code>application</code>.
package.prefix.label=Prefijo de paquete\:
package.qualID.expected=Espera un identificador completo que indique el nombre del paquete.
param.clause.expected=Expectativa de la cláusula de parámetro
parameter.could.not.be.repeated.and.by.name=El parámetro es por nombre y no se puede repetir.
parameter.expected=Parámetros requeridos
parameter.info.not.matchable=<not matchable>
parameter.label.default.value=Valor por defecto\:
parameter.label.name=Nombre\:
parameter.label.type=Categoría\:
parameter.type.expected=Expectativa de tipo de parámetro
parameterised.trait.is.implemented.indirectly=La propiedad parametrizada {0} se implementa indirectamente. Para que se pasen argumentos, deben implementarse directamente.
passed.as.by.name.parameter=Pasado como parámetro de nombre
pattern.expected=Expectativas de patrón
pattern.on.refinement.unchecked=La coincidencia de patrones del tipo de mejora no está marcada
pattern.type.incompatible.with.expected=El tipo de patrón no es compatible con el tipo esperado, encontrado\: {0}, requerido\: {1}
please.select.scala.plugin.update.channel=Seleccione un canal de actualización del complemento Scala:
poly.function.without.parameters=La función polimórfica {0} debe tener un parámetro de valor
presentable.definition.unnamed=No se ha especificado ningún nombre
presentable.type.unnamed=Tipo sin nombre
press.alt.enter=Presione Alt+Entrar
press.escape.to.remove.the.highlighting=Presione esc para eliminar el resaltado
press.hotkey.to.show.more.options=Presione ctrl + alt + v para mostrar un cuadro de diálogo con más opciones
private.member.cannot.be.used.in.extracted.member=El miembro privado {0} no se puede utilizar en el miembro extraído {1}
problem.prefix.ambiguous=(ambiguo)
problem.prefix.not.found=(extraviado)
process.duplicates=Procesamiento duplicado
processing.imports.modified.during.refactoring=Procesamiento de elementos importados modificados durante la refactorización
provide.program.arguments=Proporcionar argumentos del programa
pull.method.to=A continuación, extraiga el método ''{0}''...
pull.up.members.from=Mover al siguiente miembro hacia arriba
pull.value.to=Arrastre el valor ''{0}'' a...
pull.variable.to=A continuación, arrastre la variable ''{0}''...
rbrace.expected=''}'' se requiere
rearranger.panel.keep.java.style.getters.and.setters.together=Mantener juntos los captadores y definidores de estilo Java
rearranger.panel.keep.scala.style.getters.and.setters.together=Mantener juntos los captadores y definidores estilo cala
rearranger.panel.split.into.unarrangeable.blocks.by.expressions=Dividir en bloques que no se pueden ordenar mediante expresión
rearranger.panel.split.into.unarrangeable.blocks.by.implicits=Dividir en bloques implícitamente no alineables
reason.prefix.applicable=Aplicable\:
reason.prefix.candidate=Candidato\:
reason.prefix.cannot.infer.type=No se pudo inferir el tipo\:
reason.prefix.diverged=Ramificado\:
recursive.call.not.in.tail.position=La llamada recursiva no está en la posición final (dentro de un método anotado @tailrec)
recursive.non.value.type.of.type.element=Tipo recursivo, no el valor del elemento de tipo.
recursive.type.of.type.element=Tipo recursivo de elemento de tipo
refactoring.is.not.supported.contains.return=Refactorización no compatible\: la selección contiene una declaración de devolución
refactoring.is.not.supported.in.guard=La refactorización en guardias no es compatible y tiene el potencial de destruir la estructura del código.
refresh.roots.synchronizing.output.directories=Sincronizando directorio de salida...
regular.method.overrides.extension=El método {0} es un método normal y no se puede anular como método de extensión.
remove.all.erroneous.semicolons.from.forexpression=Eliminar todos los puntos y comas no válidos en las expresiones
remove.block.braces.automatically.based.on.indentation=Quitar brackets automáticamente
remove.block.braces.automatically.based.on.indentation.tooltip=Al editar código, elimine las llaves al cambiar un bloque de varias líneas a un bloque de una sola línea
remove.braces.from.import=Eliminar llaves de la declaración de importación
remove.case=Quitar ''caso''
remove.case.clause=Eliminar cláusula de caso
remove.catch=Quitar bloque de captura
remove.finally=Eliminar finalmente bloquear
remove.generic=Eliminar {0}
remove.named.modifier.fix=Eliminar el controlador ''{0}''
remove.return.keyword=Eliminar palabra clave de retorno
remove.unnecessary.parentheses=Elimine los paréntesis innecesarios.
remove.val=Quitar ''valor''
rename=Cambiar nombre
rename.aliased.rename.actual=Cambiar el nombre del elemento real
rename.aliased.title=No se admite el cambio de nombre de los alias de importación
rename.all.base.members=Cambiar todos los nombres de miembros predeterminados
rename.base.member=Cambiar el nombre de miembro predeterminado
rename.cancel=Cancelar
rename.companion.module=Cambiar el nombre del compañero {0}
rename.getters.and.setters.title=La función contiene un captador o definidor con el mismo nombre. ¿Le gustaría cambiar los nombres de estos también?
rename.has.multiple.base.members={0} contiene varios miembros predeterminados
rename.only.current.member=Cambiar solo el nombre del miembro actual
rename.only.in=Cambiar nombre solo dentro de {0} {1}
rename.special.method.rename.class=Cambiar el nombre de {0}
rename.special.method.title=No puedes cambiar el nombre de este método.
repeated.param.non.method=No se permiten parámetros repetidos en las firmas de métodos. Utilice `Seq` en su lugar
replace.all.occurrences=Reemplazar todos los usos
replace.all.x.occurrences=Reemplazar todos los {0} usos
replace.fun.type=Cambie la función N[A1, A1,..., AN, R] a (A1, A1,..., AN) \=> R
replace.occurrences.available.from.companion.class=Cambiar uso en clase complementaria {0}
replace.tag.with.esc.seq=Reemplazar etiquetas con secuencias de escape
replace.tuple.type=Convertir TuplaN[A1, A1,..., AN] a (A1, A1,..., AN)
replace.with.type=Reemplazar con ''{0}''
replace.with.wiki.syntax=Conversión de etiquetas en línea a sintaxis wiki de ancho fijo
report.highlighting.error.fix=Resaltar informe de errores...
resolving.compiler.bridge.progress.message=Resolviendo el puente del compilador
response.to.connection.to.url.was.code=La respuesta recibida de la conexión a {0} es ''{1}''
return.expression.is.redundant=Devolviendo {0} del método con tipo de resultado Unidad
return.outside.method.definition=Declaración de retorno fuera de la definición del método
right.brace.expected=''}'' se espera
rparenthesis.expected='')'' se requiere
rsqbracket.expected='']'' se requiere
scala.3.support.is.experimental=La compatibilidad con Scala 3 está en desarrollo.<br>Pruebe la compilación nocturna. <a href\=''{0}''>Más información</a>
scala.collection.highlighting.type.all=Cada
scala.collection.highlighting.type.none=Ninguno
scala.collection.highlighting.type.only.non.qualified=Sólo elementos no normalizados
scala.compiler.profiles.panel.create.new.profile=Crear un nuevo perfil
scala.compiler.profiles.panel.move.to=Ir al siguiente
scala.compiler.profiles.panel.profile.already.exists=El perfil {0} ya existe
scala.compiler.profiles.panel.profile.name=Nombre de perfil
scala.compiler.profiles.panel.profile.should.not.be.empty=El nombre del perfil no puede estar en blanco
scala.immutable.collection=Colección inmutable
scala.library.editor.form.compiler.bridge.jar=Puente del compilador\:
scala.library.editor.form.compiler.classpath=Ruta de clase del compilador\:
scala.library.editor.form.scala.version=Versión Scala\:
scala.library.editor.form.standard.library=Biblioteca estándar\:
scala.line.markers=Marcador de línea escala
scala.meta.mode.disabled=Deshabilitar
scala.meta.mode.enabled=Usar
scala.meta.mode.manual=Manual
scala.mutable.collection=Colección de variables
scala.notification.group.id.features.advertiser=Anunciante de funciones de Scala
scala.notification.group.id.general=Escala (general)
scala.notification.group.id.java.to.scala.converter=Convertidor de Java a Scala
scala.notification.group.id.plugin.updater=Actualizador de complementos de Scala
scala.notification.group.id.plugin.verifier=Verificador de complementos de Scala
scala.notification.group.id.sbt.project.import=Importar proyecto SBT
scala.notification.group.id.sbt.shell=Cáscara SBT
scala.notification.group.id.scala3.disclaimer=Descargo de responsabilidad de Scala 3
scala.notification.group.id.scalafmt=Scalafmt
scala.notification.group.id.scalafmt.fatal.errors=Error fatal de Scalafmt
scala.notification.group.id.scalafmt.format.errors=Error de formato de Scalafmt
scala.plugin.chanel.eap=Programa de acceso temprano
scala.plugin.chanel.nightly=Construcción nocturna
scala.plugin.chanel.release=Lanzamiento estable
scala.plugin.update=Actualizaciones del complemento Scala
scala.project.data.service.scalaLibraryNotFound=No se puede configurar el SDK de Scala para el módulo ''{0}'' (no se encontró la biblioteca de Scala del proyecto {1} para el módulo ''{0}'')
scala.project.settings=Configurar un proyecto Scala
scala.project.settings.form.add.override.keyword.to.method.implementation=Agregar palabra clave de anulación a la implementación del método
scala.project.settings.form.ahead.of.time.completion=Finalización del código AOT (nombrar parámetros y variables)
scala.project.settings.form.alias.definition=Justicia
scala.project.settings.form.alias.export=Exportar
scala.project.settings.form.alias.export.semantics=Alias para Scala y Scala.Predef\:
scala.project.settings.form.autocomplete=Autocompletar
scala.project.settings.form.automatically.convert.to.scala.code.without.dialog=No mostrar el cuadro de diálogo al pegar, convertir automáticamente a código Scala
scala.project.settings.form.base.package.custom=Usar personalizado\:
scala.project.settings.form.base.package.inherit=Heredar del prefijo del paquete en la carpeta fuente
scala.project.settings.form.check.for.updates=Revisalo ahora
scala.project.settings.form.code.conversion=Conversión de código
scala.project.settings.form.collapse.long.output.by.default=Contraer salida larga de forma predeterminada
scala.project.settings.form.collection.type.highlighting.option=Resaltar tipo de colección\:
scala.project.settings.form.convert.java.code.to.scala.on.copy.paste=Convierta el código Java a Scala al copiar y pegar
scala.project.settings.form.custom.scalatest.keywords.highlighting=Resalte las palabras clave personalizadas de scalaTest
scala.project.settings.form.delay.before.auto.run=Retraso antes de la ejecución automática\:
scala.project.settings.form.delay.before.auto.run.units=Milisegundos
scala.project.settings.form.disable.language.injection.in.scala.files=Deshabilite la inserción de idiomas dentro de los archivos Scala (los idiomas integrados pueden dejar de escribirse con la finalización automática del código emergente)
scala.project.settings.form.disable.parsing.of.documentation.comments=Deshabilita el análisis de comentarios de documentos. Esto puede mejorar el rendimiento del editor para archivos muy grandes. (SCL-2900)
scala.project.settings.form.dont.cache.compound.types=No almacene en caché tipos complejos (úselo si experimenta bloqueos graves en GC)
scala.project.settings.form.error.highlighting=Error al resaltar:
scala.project.settings.form.error.highlighting.use.compiler.ranges=Utilice rangos de texto informados por el compilador de Scala
scala.project.settings.form.group.package.object.with.package=Agrupar y agrupar objetos de paquete con paquetes.
scala.project.settings.form.highlight.arguments.to.by.name.parameters=Resaltado de argumentos de parámetros por nombre
scala.project.settings.form.highlight.implicit.conversions=Resaltado de conversión implícita
scala.project.settings.form.highlight.nodes.with.errors=Resaltar nodos con errores
scala.project.settings.form.highlighting=Destacar
scala.project.settings.form.implicit.parameters.search.depth=Profundidad de búsqueda de parámetros implícitos (-1 si no hay ninguno)\:
scala.project.settings.form.include.block.expressions=Contiene expresiones de bloque
scala.project.settings.form.include.literals=Contiene literales
scala.project.settings.form.info=Siempre puedes volver a una versión más estable seleccionando "Versión estable" o "Programa de acceso anticipado".
scala.project.settings.form.output.cutoff.limit=Límite de corte de salida\:
scala.project.settings.form.output.cutoff.limit.units=Línea
scala.project.settings.form.plugin.update.channel=Actualización del canal\:
scala.project.settings.form.run.worksheet.in.the.compiler.process=Ejecutar una hoja de trabajo en el proceso del compilador (solo modo normal)
scala.project.settings.form.sbt.index.ivy2.mode=Modo de indexación de caché local ivy2
scala.project.settings.form.sbt.index.ivy2.mode.hint=Deshabilitado: no se completó la indexación\nscala.meta hilo del programa
scala.project.settings.form.scala.meta.settings.annot212.tooltip=Debido a la compatibilidad binaria, las anotaciones en el módulo 2.12 deben utilizar serialización y análisis basados en cadenas, lo cual es muy lento. Esto puede afectar seriamente el rendimiento general.
scala.project.settings.form.scala.meta.settings.modeOptions.tooltip=Habilitado: el metaprograma se ejecuta durante la inferencia de tipos. El cuerpo del método Trim se extiende mediante scala.meta.
scala.project.settings.form.scala.meta.settings.trimBodies.tooltip=Depende del tipo de retorno explícito del método generado (el cuerpo se reemplaza por ???). Acelere la inferencia de tipos omitiendo el método de verificación del tipo de cuerpo.
scala.project.settings.form.scalatest.default.super.class=Clase principal predeterminada de ScalaTest\:
scala.project.settings.form.search.all.symbols=Buscar todos los símbolos (incluidos los símbolos locales)
scala.project.settings.form.show.hints.if.ambiguous.implicit.arguments.found=Mostrar sugerencias cuando se encuentran argumentos implícitos ambiguos
scala.project.settings.form.show.hints.if.no.implicit.arguments.found=Mostrar sugerencia si no se encuentra el argumento implícito
scala.project.settings.form.show.type.mismatch.hints=Sugerencia mostrada en caso de que el tipo no coincida
scala.project.settings.form.tabs.base.package=Paquete básico
scala.project.settings.form.tabs.base.packages=Paquete básico
scala.project.settings.form.tabs.editor=Editor
scala.project.settings.form.tabs.extensions=Expansión
scala.project.settings.form.tabs.misc=Otros
scala.project.settings.form.tabs.performance=Actuación
scala.project.settings.form.tabs.project.view=Vista del proyecto
scala.project.settings.form.tabs.updates=Actualizar
scala.project.settings.form.tabs.worksheet=Hoja de cálculo
scala.project.settings.form.tabs.xray.mode=modo de rayos X
scala.project.settings.form.trailing.commas=Coma final\:
scala.project.settings.form.treat.sc.files.as=Procesar el archivo .sc con\:
scala.project.settings.form.treat.scala.scratch.files.as.worksheet.files=Procesar el archivo temporal de Scala como archivo de hoja de trabajo
scala.project.settings.form.use.eclipse.compatibility.mode=Utilice el modo "compatibilidad con eclipse"
scala.project.settings.form.use.scala.classes.priority.over.java=Prefiere las clases de Scala a las clases de Java
scala.project.settings.form.xray.activate=Fecha de activacion:
scala.project.settings.form.xray.by-name.argument.hints=Sugerencia de argumento por nombre
scala.project.settings.form.xray.double.press.and.hold=Mantenga presionada la tecla Ctrl después de hacer doble clic
scala.project.settings.form.xray.implicit.hints=pista implícita
scala.project.settings.form.xray.indent.guides=Guía de sangría
scala.project.settings.form.xray.lambda.parameters=Parámetros lambda
scala.project.settings.form.xray.lambda.placeholders=Marcador de posición lambda
scala.project.settings.form.xray.local.variables=variable local
scala.project.settings.form.xray.member.variables=variable miembro
scala.project.settings.form.xray.method.chain.hints=Sugerencia de cadena de métodos
scala.project.settings.form.xray.method.results=resultado del método
scala.project.settings.form.xray.method.separators=separador de métodos
scala.project.settings.form.xray.parameter.name.hints=Sugerencia de nombre de parámetro
scala.project.settings.form.xray.press.and.hold=Mantenga presionada la tecla Ctrl
scala.project.settings.form.xray.show=marca\:
scala.project.settings.form.xray.type.hints=Escriba sugerencias para \:
scala.project.settings.form.xray.variable.patterns=patrón variable
scala.project.settings.form.xray.widget=Aparatos\:
scala.project.settings.form.xray.widget.display=marca\:
scala.root.code.style.panel.formatter=Herramientas de formato\:
scala.sdk.component.name.compiler.classpath=Ruta de clase del compilador
scala.sdk.component.name.library=Biblioteca
scala.sdk.component.name.library.scaladoc=Biblioteca escaladoc
scala.sdk.component.name.library.source=Fuente de la biblioteca
scala.sdk.descriptor.contains.duplicated.files=El descriptor del SDK de Scala contiene archivos {0} duplicados:
scala.sdk.selection.button.browse=Examinar...
scala.sdk.selection.button.download=Descargar...
scala.type.aware.highlighting.indicator=Indicador resaltado de reconocimiento de tipo Scala
scala3.panel.title=Scala 3
scala3.panel.use.indentation.based.syntax=Utiliza sintaxis basada en sangría
scaladoc.noon=Scaladoc
scaladoc.panel.add.additional.space.for.leading.asterisk=Agregue espacio adicional al asterisco inicial
scaladoc.panel.after.parameter.comments=Después de la descripción del parámetro
scaladoc.panel.after.tags=Después de regresar
scaladoc.panel.align.other.tags.descriptions=Otra etiqueta Descripción Ordenar
scaladoc.panel.align.parameter.descriptions=Parámetro Descripción Ordenar
scaladoc.panel.align.return.value.description=Valor de retorno Descripción Ordenar
scaladoc.panel.align.throws.exception.descriptions=La tarea genera una descripción de excepción
scaladoc.panel.before.parameter.descriptions=Antes de la descripción del parámetro
scaladoc.panel.before.tags=Delante de la etiqueta
scaladoc.panel.between.parameter.descriptions=Entre descripciones de parámetros
scaladoc.panel.blank.lines.keep=Mantener (las líneas en blanco entre etiquetas no se eliminan)
scaladoc.panel.enable.scaladoc.formatting=Habilitar el formato Scaladoc
scaladoc.panel.groups.alignment=Adaptar
scaladoc.panel.groups.blank.lines=Linea en blanco
scaladoc.panel.groups.other=Otros
scaladoc.panel.preserve.spaces.in.tags=Mantener el espacio entre etiquetas
scaladoc.panel.title=ScalaDoc
scaladoc.parsing.closing.code.tag.before.opening=Cerrar etiqueta de código antes de abrir
scaladoc.parsing.closing.link.tag.before.opening=Cerrar etiqueta de enlace antes de abrir
scaladoc.parsing.cross.tags=Etiqueta cruzada
scaladoc.parsing.error.bad.token=Error\: Token no válido\: {0}
scaladoc.parsing.header.closed.by.opening.new.one=Encabezado cerrado al abrir un nuevo elemento
scaladoc.parsing.inline.tag=Etiquetas en línea
scaladoc.parsing.missing.tag.param=Parámetro de etiqueta faltante
scaladoc.parsing.no.closing.element=Sin elementos de cierre
scaladoc.parsing.open.syntax.element=Elemento de sintaxis abierta
scaladoc.parsing.unclosed.code.tag=Etiqueta de código abierto
scaladoc.parsing.unexpected.end.of.tag.body=Final del cuerpo de la etiqueta inesperado
scaladoc.parsing.unknown.tag=Etiqueta desconocida\: {0}
scaladoc.parsing.wiki.syntax.closed.by.inner.code.tag=Etiqueta de código interno
scaladoc.parsing.wiki.syntax.closed.by.new.paragraph=Nuevo párrafo
scaladoc.parsing.wiki.syntax.closed.by.tag=Etiqueta
scaladoc.parsing.wiki.syntax.element.closed.by.message=Elemento de sintaxis wiki cerrado por {0}
scalafmt.can.not.create.config.file=No se pudo crear el archivo de configuración
scalafmt.can.not.find.config.file=Archivo de configuración no encontrado. {0}
scalafmt.can.not.find.config.file.create.new=Crea un nuevo archivo.
scalafmt.can.not.find.config.file.go.to.settings=Configuración...
scalafmt.config.load.actions.open.config.file=Abrir archivo de configuración
scalafmt.config.load.errors.cyclic.includes.detected=Incluye circular detectada
scalafmt.config.load.errors.failed.to.load.config=Error al cargar la configuración de Scalafmt
scalafmt.config.load.errors.parse.error=Error de análisis\: {0}
scalafmt.default=Por defecto
scalafmt.default.path=Valor por defecto\: {0}
scalafmt.download=Descargar
scalafmt.format.errors.failed.to.find.correct.surrounding.code=Error de Scalafmt ({0})\:<br> No se pudo encontrar el código adjunto correcto para pasar a scalafmt, no se realiza ningún formateo
scalafmt.format.errors.scala.file.parse.error=Error de análisis de Scalafmt ({0})\:<br>{1}
scalafmt.picked.new.config=Nueva configuración de estilo (v{0}) aplicada a Scalafmt
scalafmt.progress.downloading.scalafmt.version=Descargando la versión Scalafmt {0}
scalafmt.progress.downloading.scalafmt.version.cancel=Descarga detenida
scalafmt.progress.resolving.scalafmt.version=Resolviendo la versión de Scalafmt {0}
scalafmt.progress.resolving.scalafmt.version.cancel=Deja de resolver
scalafmt.progress.version.was.downloaded=Se ha descargado la versión {0} de Scalafmt
scalafmt.resolve.again=Resuelto de nuevo
scalafmt.resolve.errors.cant.resolve.scalafmt.version=No se pudo resolver la versión {0} de Scalafmt
scalafmt.resolve.errors.classpath.is.corrupted=Classpath está corrupto
scalafmt.resolve.errors.download.is.in.progress=La descarga está en curso.
scalafmt.resolve.errors.downloading.error.occurred=Error al descargar
scalafmt.resolve.errors.unknown.error=Error desconocido
scalafmt.resolve.errors.version.is.not.downloaded.yet=La versión de Scalafmt `{0}` no se ha descargado.<br>¿Le gustaría descargarla?
scalafmt.settings.panel.configuration.label=Composición
scalafmt.settings.panel.errors.cant.find.config.file=No se pudo encontrar el archivo de configuración de Scalafmt con la siguiente ruta:<br> {0}
scalafmt.settings.panel.errors.cant.resolve.version=No se pudo resolver la versión {0} de Scalafmt
scalafmt.settings.panel.errors.failed.to.parse.config=Error en la configuración del análisis\:<br> {0}
scalafmt.settings.panel.fallback.to.default.settings=Volver a la configuración predeterminada de IntelliJ
scalafmt.settings.panel.no.config.found.under.path.using.default=Archivo de configuración no encontrado en la ruta especificada
scalafmt.settings.panel.reformat.on.file.save=Reformatear archivos al guardar
scalafmt.settings.panel.reformat.on.file.save.tooltip=Sugerencia\: Utilice el código de reformateo ({0})
scalafmt.settings.panel.scalafmt.version.label=Versión escalafón
scalafmt.settings.panel.select.custom.scalafmt.configuration.file=Seleccione un archivo de configuración Scalafmt personalizado
scalafmt.settings.panel.show.warnings.when.formatting.invalid.code=Mostrar una advertencia al intentar formatear un código no válido
scalafmt.settings.panel.use.intellij.formatter.for.code.range.formatting=Utilice herramientas de formato IntelliJ para formatear rangos de códigos
scalafmt.settings.panel.use.intellij.formatter.for.code.range.formatting.warning.tooltip=El uso de Scalafmt para formatear rangos de códigos puede causar inconsistencias en el código.<br>Scalafmt solo debe usarse para formatear archivos completos que contengan código Scala.
scalafmt.suggester.detected.in.project=Configuración de Scalafmt detectada en este proyecto
scalafmt.suggester.dont.show=No mostrar
scalafmt.suggester.enable=Usar
scope.file=Archivo
scope.selection=Opcional
script.file.mode.always.ammonite=Siempre amonita
script.file.mode.always.worksheet=Siempre hojas de trabajo
script.file.mode.ammonite.in.test.sources.otherwise.worksheet=Amonita en la fuente de prueba; de lo contrario, hoja de trabajo
scrutinee.incompatible.pattern.type=El escrutador no es compatible con el tipo de patrón, encontrado\: {0}, requerido\: {1}
sdk.create.select.files=Seleccione un JAR para el nuevo SDK de Scala
sdk.notification.provider.no.scala.sdk.in.module=El módulo no tiene Scala SDK
sdk.notification.provider.setup.scala.sdk=Instalar el SDK de Scala
sdk.scan.title=Encontrar la ubicación del SDK de Scala\: {0}
sdk.table.model.docs=Documento
sdk.table.model.location=Ubicación
sdk.table.model.sources=Salsa
sdk.table.model.version=Versión
sdkman=SDKMAN\!
sealed.modifier.is.not.allowed.here=El controlador ''sellado'' no está permitido
searching.for.overriding.members=Anular la búsqueda de miembros
select.library.from.the.list.above=Seleccione una biblioteca de la lista anterior
select.method.implement=Seleccionar miembros para implementar
select.method.override=Seleccionar miembro para anular
selected.file.is.not.a.valid.jar.file=El archivo seleccionado no es un archivo jar válido
semi.expected='';'' o esperar una nueva línea
semicolon.not.allowed.here=No se permiten punto y coma
show.implicit.arguments.action.description=Mostrar argumentos implícitos
show.implicit.arguments.action.text=Mostrar argumentos implícitos
simple.pattern.expected=Inicio incorrecto de patrón simple
spaces.panel.after.colon.before.declarations.type=Después de los dos puntos, antes del tipo de declaración
spaces.panel.around.at.in.pattern.bindings=Patrón de encuadernación alrededor de mi ''@''
spaces.panel.before.colon.after.declarations.name=Antes de los dos puntos, después del nombre de la declaración
spaces.panel.before.context.bound.colon.leading=Antes (principal) de dos puntos vinculados al contexto
spaces.panel.before.context.bound.colon.leading.higher.kinded=Antes de los dos puntos vinculados al contexto (que van hacia arriba)
spaces.panel.before.context.bound.colon.rest=Antes del texto enlazado dos puntos (resto)
spaces.panel.before.opening.square.bracket=Antes del corchete de apertura
spaces.panel.constructor.parameters.with.modifiers=Parámetros del constructor con controladores.
spaces.panel.import.braces=Conseguir frenillos
spaces.panel.infix.method.call.parentheses=Paréntesis de llamada al método inflix
spaces.panel.infix.method.parentheses=Paréntesis del método inflix
spaces.panel.infix.operator.like.method.call.parentheses=Paréntesis de llamada al método de expresión del operador inflix
spaces.panel.inside.closure.braces=Dentro de los tirantes de cierre
spaces.panel.keep.one.line.comments.on.same.line=Mantenga los comentarios de una sola línea en la misma línea
spaces.panel.method.call.left.brace=Llamada al método llave izquierda
spaces.panel.newline.after.annotations=Nueva línea después de la anotación
spaces.panel.preserve.space.before.method.parentheses=Preservar espacio antes de los paréntesis del método
spaces.panel.self.type.braces=Aparatos ortopédicos de tipo propio
spaces.panel.simple.one.line.block.braces=Tirantes de bloque simples de una línea
specify.result.type=Especificar el tipo de resultado
specify.return.type.explicitly=Especificar tipo (&T)
specify.type.of.exception=Especificar tipo de excepción
stable.identifier.required=Se esperaba un identificador estable, pero se encontró {0}
string.literal.invalid.escape.character=Carácter de escape no válido
string.literal.invalid.unicode.escape=Escape Unicode incorrecto
string.literal.is.too.long=El tamaño literal de la cadena excede el límite del compilador
subscript.surrounder.template.description=Subíndice\: ,, ,,
suitable.method.not.found=No se encontró ningún método adecuado
super.reference.used.in.extracted.member=El miembro extraído {0} contiene una referencia de clase principal, pero el atributo extraído no contiene una clase base.
superscript.surrounder.template.description=Superíndice \: ^ ^
support.back.references.in.shared.sources=&Support back references in shared sources  (experimental)
support.back.references.in.shared.sources.tooltip=With this setting enabled IntelliJ will be able to handle references<br>dfrom shared sourced module to declarations in dependent modules
suspicious.forward.reference.template.body=Referencias directas sospechosas dentro de una clase
symbol.is.inaccessible.from.this.place=No se puede acceder al símbolo {0} desde esta ubicación
symbolliterals.are.deprecated=Los literales de símbolos están en desuso en Scala 2.13. Utilice Símbolo("{0}") en su lugar.
system.wide.scala=Scala en todo el sistema
target.0.already.contains.definition.of.1=<b>{0}</b> ya contiene la definición de miembro <b>{1}</b>
this.is.not.a.valid.scala.qualified.name=No es un nombre válido y completo de Scala
title.choose.implicit.conversion.method=Seleccione el método de conversión implícita\:
title.download=Descargar
title.error.downloading.scala.libraries=Error de carga redonda de la biblioteca Scala
title.expressions=Expresión
title.extensions.available=Extensiones disponibles
title.failed.to.load.extension.jar=Falló la carga del JAR de extensión
title.fetching.available.this.versions=Recuperando la versión disponible {0}
title.problem.opening.web.page=Problemas al abrir páginas web
title.scala.sdk.files=Archivo SDK de Scala
title.searching.for.library.extensions=Búsqueda de extensiones de biblioteca
to.import.method.statically.press.hotkey=Para importar el método estáticamente, presione {0}.
toggle.type.aware.highlighting.menu.action.description=Alternar resaltado con reconocimiento de tipografía
toggle.type.aware.highlighting.menu.action.text=Resaltar alterna usando información de tipo
too.many.type.arguments.for.typeparamowner=Hay demasiados argumentos de tipo para {0}. {1} necesario, {2} encontrado
topic.parameters.may.not.be.call.by.name=El parámetro {0} puede no ser llamada por nombre
trailing.comma.panel.add.when.multiline=Agregar para varias líneas
trailing.comma.panel.keep=Mantener
trailing.comma.panel.remove.when.multiline=Eliminar cuando se utilizan varias líneas
trailing.comma.panel.scope.arguments.list=Lista de argumentos
trailing.comma.panel.scope.import.selector=Selector de importación
trailing.comma.panel.scope.parameters.list=Lista de parámetros
trailing.comma.panel.scope.pattern.arguments.list=Lista de argumentos de patrón
trailing.comma.panel.scope.tuple=Doble
trailing.comma.panel.scope.tuple.type=Tipo de tupla
trailing.comma.panel.scope.type.parameters.list=Lista de parámetros de tipo
trailing.comma.panel.title=Coma final
trailing.commas.mode.auto=Automático
trailing.commas.mode.disabled=Deshabilitar
trailing.commas.mode.enabled=Usar
trailing.underscore.separator=No se permiten delimitadores de subrayado al final
trait.has.implementations=Siguiente mezcla
trait.has.several.implementations=Mezclado en la clase {0}
trait.is.already.implemented.by.superclass=No se puede volver a llamar al constructor del atributo {0} porque ya está implementado por su superclase {1}
trait.may.not.call.constructor=La propiedad {0} no puede llamar al constructor de {1}
trait.parameter.require.scala3=El uso de parámetros de rasgos requiere Scala 3.0
traits.cannot.have.type.parameters.with.context.bounds=Las propiedades no pueden tener parámetros de tipo con límites de contexto
traits.cannot.have.type.parameters.with.view.bounds=Las propiedades no pueden tener parámetros de tipo con límites de vista
transparent.method.must.be.inline=La palabra clave "transparente" solo se puede utilizar en métodos en línea
tree.mismatch.tooltip=<html><body>{0}<table><tr><td>Obligatorio:</td>{0}</tr><tr><td>Encontrado:</td>{1}</tr> </tabla></body></html>
try.block=Intentar bloquear
type.annotations.panel.accidental.structural.type=Tipo de estructura inesperado*
type.annotations.panel.accidental.structural.type.tooltip=<html>Fuerza la anotación de tipo en el valor, tiene un tipo de estructura inferido, por ejemplo\:<br>\nRunnable {\n()\n()\nExcepción si:
type.annotations.panel.annotations=Anotación
type.annotations.panel.classes=Clase
type.annotations.panel.constant.final.val=Constante (valor final)
type.annotations.panel.enforce.for=Aplicable a
type.annotations.panel.except.when=Excepción si:
type.annotations.panel.function.literal.parameter=Parámetros literales de función
type.annotations.panel.implicit.definition=Definición implícita
type.annotations.panel.in.scala.dialect.sources=En lenguaje fuente derivado de Scala*
type.annotations.panel.in.scala.dialect.sources.tooltip=*.sbt, *.sc, etc.
type.annotations.panel.in.test.sources=Mi fuente de prueba
type.annotations.panel.local.definition=Definición local
type.annotations.panel.member.of=Miembros de:
type.annotations.panel.member.of.anonymous.class=Miembro anónimo de la clase
type.annotations.panel.member.of.private.class=Miembro de la clase privada
type.annotations.panel.private.member=Miembro privado
type.annotations.panel.protected.member=Miembro protegido
type.annotations.panel.public.member=Miembro público
type.annotations.panel.title=Tipo de anotación
type.annotations.panel.type.is.stable=El tipo es estable*
type.annotations.panel.type.is.stable.tooltip=<html><body>Si el lado derecho es\:<br> literal\: <code>123</code>, <code>\"string\"</code>, etc. (incluido <code>null</code>)<br> Expresión de unidad\: <code>()</code><br> Creación de objetos\: <code>new Foo(...)</code> (Mejorado Incluir código\: <code>new Foo() {}</code>)<br> Llamar al método Factory\: <code>Foo(...)</code> (<code>apply(.. en el objeto complementario ) .)</code> call)<br> Colección vacía\: <code>Seq.empty[Int]</code>, <code>Map.empty[Int, String]</code>, etc.<br > Constantes de enumeración de Java\: <code>Enum.VALUE</code><br> Excepciones\: <code>throw Exception()</code></body></html>
type.annotations.panel.type.matches=Tipo de coincidencia\:
type.annotations.panel.type.patterns=Patrón de tipo
type.annotations.panel.underscore.parameter=Parámetro subrayado
type.annotations.panel.unit.type=Tipo de unidad
type.annotations.panel.use.for=Que usar
type.arg.does.not.conform.to.lower.bound=El tipo {0} no respeta el límite inferior {1} del parámetro de tipo {2}
type.arg.does.not.conform.to.upper.bound=El tipo {0} no respeta el límite superior {1} del parámetro de tipo {2}
type.aware.highlighting.title=Resalte el reconocimiento de tipo Scala
type.cannot.be.used.in.type.pattern=El tipo {0} no se puede utilizar en un patrón de tipo ni en una prueba isInstanceOf
type.checker.built.in=Básico
type.checker.compiler=Compilador
type.checker.help=<html><strong>Comprobador de tipo integrado:</strong> proporciona más funcionalidad, comentarios más rápidos y es liviano. En código complejo, pueden ocurrir errores falsos.<br><br><strong>Compilador:</strong> Más preciso. Es más lento, consume más recursos y no admite funciones como comparación de tipos, corrección rápida, verificación, etc.<br><br>A menos que encuentre una gran cantidad de errores falsos en su base de código particular, le recomendamos usar el verificador de tipos incorporado Recomendado.</html>
type.constructor.does.not.conform=El constructor de tipo {0} no se ajusta a {1}
type.constructor.mismatch=El constructor de tipos no coincide.
type.expected=Se requiere tipo
type.info.description=Mostrar información de tipo
type.info.text=Clasificar información
type.is.not.a.valid.result.type.of.an.unapply.method={0} no es un tipo de resultado válido para el método de no aplicar
type.is.not.a.valid.result.type.of.an.unapplyseq.method={0} no es un tipo de resultado válido para el método unaapplySeq
type.lambda.expected=''\=>>'' esperado
type.mismatch.default.args.expected.actual=Los tipos no coinciden en los argumentos predeterminados, esperado\: {0}, real\: {1}
type.mismatch.dot=El tipo no coincide.
type.mismatch.expected=Los tipos no coinciden, esperado\: {0}, real\: {1}
type.mismatch.expected.actual=Los tipos no coinciden, esperado\: {0}, real\: {1}
type.mismatch.found.required=El tipo no coincide, encontrado\: {0}, requerido\: {1}
type.mismatch.hint.context.menu.configure=Configurando sugerencia de discrepancia de tipos...
type.mismatch.message=El tipo no coincide. Requerido\: {0}, Encontrado\: {1}
type.parameter.value.class.may.not.be.specialized=Los parámetros de tipo de clases de valor no se pueden especializar
type.parameters.for.self.type.not.supported=La característica extraída contiene {0} como su propio tipo, pero no se admite la identificación del parámetro de tipo.
type.takes.type.parameters=El tipo {0} toma un parámetro de tipo
typed.statement.is.not.complete.for.underscore.section=La sintaxis escrita está incompleta para las secciones de subrayado
unbound.placeholder.parameter=Parámetros de marcador de posición independientes
unchecked.warnings=&Advertencia no reconocida
unchecked.warnings.tooltip=Habilitar advertencias adicionales en el código generado depende de sus suposiciones.
underline.surrounder.template.description=Subrayado\: __ __
unknown.exception=Excepción desconocida: {0}
unknown.extraction=Extracto desconocido
unknown.macro.in.type.position=Macro desconocida en condición de tipo
unknown.resolve.issues=Problema desconocido resuelto: {0}
unknown.type=<desconocido>
unreachable.error=Error inesperado encontrado
unresolved.artifact=Artefactos no resueltos: {0}
unspecified.type.parameters=Parámetro de valor no especificado: {0}
unwrap.case.clause=Desenvolver cláusulas del caso
unwrap.finally=Finalmente desenvolver la línea
unwrap.interpolated.string.injection=Insertar cadena interpolada Desenvolver
unwrap.try.with.finally=Intentar/finalmente desenvolver
updating.of.usages.of.generated.unapply=No se admite la actualización de las ubicaciones de uso del método "desaplicar" generadas
upgrade.to.interpolated=Actualice una cadena simple a una cadena interpolada después de escribir ''${''
usage.access.modifier=Controlador de acceso
usage.extractor=Extractor
usage.function.expression=Expresión de función
usage.implicit.conversion.parameter=Conversión implícita/parámetros
usage.interpolated.string.prefix=Prefijo de cadena interpolada
usage.method.apply=Método "aplicar"
usage.named.parameter=Parámetro con nombre
usage.package.clause=Cláusula del paquete
usage.parameter.in.pattern=Parámetros dentro del patrón.
usage.sam.interface.implementation=Implementación de la interfaz SAM
usage.secondary.constructor=Constructor secundario
usage.self.type=Propio tipo
usage.this.reference=Mira esto
usage.type.alias=Escriba alias
usage.type.bound=Tipo enlazado
usage.typed.pattern=Patrón mecanografiado
usage.typed.statement=Sintaxis escrita
usage.unresolved.implicit.conversion.parameter=Conversiones/parámetros implícitos no resueltos
use.compiler.ranges.help=<html><strong>Se aplica a proyectos de Scala 3 con resaltado de errores configurado en el compilador</strong><br><br>Cuando está habilitado, el rango de texto informado por el compilador de Scala se utiliza al resaltar el código dentro del editor. Se pueden resaltar rangos de texto grandes para errores de compilación seleccionados.<br><br>Cuando está deshabilitado, se pueden resaltar rangos de texto pequeños para errores de compilación seleccionados</html>
using.parameter.clause.expected=Se requiere la cláusula de parámetro 'usando'
val.name=Val {0}
val.on.case.class.param.redundant=Los parámetros del constructor predeterminado de la clase Case y el controlador ''val'' están duplicados
val.or.var.can.only.be.used.in.class.parameters=''{0}'' sólo se puede utilizar en parámetros de clase
val.var.expected=Esperando la palabra clave val o var
value.class.can.have.only.one.parameter=Una clase de valor puede tener solo un parámetro
value.class.can.have.only.val.parameter=Una clase de valor solo puede tener un parámetro val no privado
value.classes.can.have.only.defs=No se permiten definiciones de campos en clases de valor
value.classes.cannot.have.nested.objects=Una clase de valor no puede tener clases, objetos o propiedades anidadas.
value.classes.cannot.redefine.equals.hashcode=Las clases de valor no pueden anular iguales y hashCode
value.classes.may.not.be.member.of.another.class=Una clase de valor no puede ser miembro de otra clase.
var.cannot.be.overridden=Las variables mutables no se pueden sobrescribir.
var.cannot.override.val=La variable {0} no puede redefinir su valor inmutable
var.name=Var {0}
vararg.pattern.must.be.last.pattern=_* sólo se puede utilizar como último argumento
vararg.pattern.with.at.deprecated.since.scala3=La sintaxis ''@'' dentro del patrón vararg está obsoleta en Scala 3.0 y versiones posteriores.
vararg.pattern.with.colon.requires.scala3=La sintaxis ''\:'' dentro de los patrones vararg requiere Scala 3.0
variable.names=Nombre de variable\: {0}
variance.annotation.not.allowed=No se permiten anotaciones de cambio.
variance.bivariant=Inusual
variance.contravariant=Transformación semicolonial
variance.covariant=Covarianza
variance.invariant=No covarianza
view.bounds.not.allowed=No se permiten límites de visualización
while.expected=Esperando la palabra clave while en la declaración ''do''
while.statement=Mientras declaración
wrap.in.option.hint=Opción(...) ¿Le gustaría ajustar mi expresión?
wrap.in.option.name=Salto de línea de opción
wrap.single.expression.body=Envuelva el cuerpo de una sola expresión con una llave de cierre después de escribir ''{''
wrapping.and.braces.panel.align.if.else.statements=Alineación de sintaxis if-else
wrapping.and.braces.panel.align.in.columns.case.branches=Ordenar columna de rama ''caso''
wrapping.and.braces.panel.align.multiline.pattern.alternatives=Asignación alternativa de patrón multilínea
wrapping.and.braces.panel.align.parameter.types.in.multiline.declarations=Ordenar tipos de parámetros dentro de declaraciones de varias líneas
wrapping.and.braces.panel.align.tuple.elements=Ordenar elementos de tupla
wrapping.and.braces.panel.do.not.align.block.expression.parameters=Parámetros de expresión de bloque de desorden
wrapping.and.braces.panel.do.not.indent.case.clause.body=No sangrar el cuerpo de la cláusula del caso
wrapping.and.braces.panel.do.not.indent.tuples.closing.parenthesis=No aplicar sangría a los paréntesis de cierre de tuplas
wrapping.and.braces.panel.extends.align.to.extends=Asignar a ''extiende''
wrapping.and.braces.panel.extends.do.not.align=No ordenado
wrapping.and.braces.panel.extends.on.first.token=Primera ficha
wrapping.and.braces.panel.for.indent.yield.after.one.line.enumerators=Sangrar el rendimiento después de un enumerador de una línea
wrapping.and.braces.panel.force.braces=Tirantes de fuerza
wrapping.and.braces.panel.force.case.branch.braces=Soportes Forzar ''estuche''
wrapping.and.braces.panel.force.finally.braces=Forzar tirantes "finalmente"
wrapping.and.braces.panel.force.try.braces=Forzar "probar" brackets
wrapping.and.braces.panel.groups.anonymous.method.definition=Definición del método anónimo
wrapping.and.braces.panel.groups.class.definition=Definición de clase
wrapping.and.braces.panel.groups.method.definition=Definición del método
wrapping.and.braces.panel.groups.tuple=Doble
wrapping.and.braces.panel.groups.type.arguments=Tipo argumento
wrapping.and.braces.panel.groups.type.parameters=Tipo de parámetro
wrapping.and.braces.panel.groups.xml.formatting=Formatear XML
wrapping.and.braces.panel.indent=Sangrar
wrapping.and.braces.panel.indent.braced.arguments=Sangrar argumentos entre llaves
wrapping.and.braces.panel.indent.first.parameter.clause.if.on.new.line=Sangrar la cláusula del primer parámetro en una nueva línea
wrapping.and.braces.panel.indent.first.parameter.if.on.new.line=Sangrar el primer parámetro en una nueva línea
wrapping.and.braces.panel.keep.xml.formatting=Mantener el formato XML
wrapping.and.braces.panel.match.statement=Declaración ''coincidencia''
wrapping.and.braces.panel.new.line.options.new.line.always=Siempre salto de línea
wrapping.and.braces.panel.new.line.options.new.line.for.multiple.arguments=Saltos de línea cuando se utilizan argumentos de varias líneas
wrapping.and.braces.panel.new.line.options.no.new.line=Sin nuevas líneas
wrapping.and.braces.panel.parameters.on.new.line=Parámetros en nueva línea
wrapping.and.braces.panel.place.self.type.on.new.line=Coloque su propio tipo en una nueva línea
wrapping.and.braces.panel.renamed.extends.keyword=Expansión de palabras clave
wrapping.and.braces.panel.renamed.extends.with.list=Extiende/con lista
wrapping.and.braces.panel.renamed.force.yield.braces=Tirantes de cedencia forzada
wrapping.and.braces.panel.renamed.infix.expressions=Expresión inflix
wrapping.and.braces.panel.simple.one.line.lambdas.in.arg.list=Lambda simple de una línea dentro de la lista de argumentos
wrapping.and.braces.panel.use.normal.indent.for.parameters=Utilice sangría normal para los parámetros.
wrapping.and.braces.panel.wrap.before.with.keyword=Salto de línea antes de la palabra clave ''con''
wrong.annotation.expression=Expresión de anotación no válida
wrong.binding=Parametro invalido
wrong.case.modifier=El controlador del caso no es válido. Úselo como clase u objeto.
wrong.constr.expression=Expresión de constructor no válida
wrong.declaration.in.block=El bloque no puede contener declaraciones
wrong.existential.declaration=Esta es una declaración incorrecta de existencia. Debe ser una declaración de tipo o valor.
wrong.expression=Expresión no válida
wrong.number.arguments.extractor=Número de argumentos no válidos en el extractor, encontrado\: {0}, esperado\: {1}
wrong.number.arguments.extractor.unapplySeq=Número de argumentos no válidos en el extractor, encontrados\: {0}, esperados\: {1} o más.
wrong.parameter=Parametro invalido
wrong.pattern=Patrón equivocado
wrong.postfix.expression=Expresión de sufijo no válida
wrong.psi.for.literal.type=El elemento que obtiene el tipo literal no es válido
wrong.qual.identifier=Identificador completo no válido
wrong.string.literal=Literal de cadena no válido
wrong.stub.problem=Problema con el trozo malo
wrong.top.statement.declaration=Declaración de sintaxis superior incorrecta
wrong.type=Tipo incorrecto
wrong.type.associativity=La correlación es incorrecta. Todos los operadores deben tener la misma correlación.
wrong.type.element=Elemento de tipo no válido
wrong.type.no.literal.types=Tipo no válido `{0}`; utilice Scala 2.13 o Typelevel Scala con el indicador del compilador `-Yliteral-types` para compatibilidad con tipos lineales
wrong.val.declaration=Declaración de valor no válida
wrong.var.declaration=Declaración de variable no válida
xml.PI.end.expected=Esperando con ansias el final de las pautas de procesamiento XML
xml.attribute.end.expected=Se esperaba el delimitador final del valor del atributo XML
xml.attribute.value.expected=Se requiere valor de la propiedad
xml.cdata.end.expected=Esperando con ansias el final de XML CData
xml.comment.end.expected=Esperar el final del comentario XML (''-->'')
xml.delete.unmatched.tag=Eliminar etiquetas no coincidentes
xml.end.tag.expected=Esperando etiqueta final XML (''</'' nombre ''>'')
xml.eq.expected=''\='' esperado
xml.name.expected=Expectativas del nombre de la etiqueta XML
xml.no.closing.tag=Sin etiqueta de cierre
xml.no.opening.tag=Sin etiqueta de apertura
xml.rename.closing.tag=Cambiar el nombre de la etiqueta de cierre
xml.rename.opening.tag=Cambiar el nombre de la etiqueta de apertura
xml.scala.expression.expected=La inserción en XML requiere expresión Scala
xml.scala.injection.end.expected=Espere el final de la inserción de Scala (''}'') en XML
xml.scala.patterns.expected=La inserción de XML requiere el patrón Scala
xml.tag.end.expected=Expectativa del final de la etiqueta XML
xml.wrong.character=Cadena no válida en comentario XML
