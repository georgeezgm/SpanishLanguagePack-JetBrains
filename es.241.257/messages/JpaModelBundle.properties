AddAttributeItem.attributeAlreadyExist.description={0} 속성은 이미 {1} 엔티티에서 정의되었습니다
AddAttributeItem.attributeAlreadyExist.title={0} 속성이 이미 정의되었습니다
AddAttributeItem.idAlreadyExist=기본 키가 이미 있습니다
AddAttributeItem.idAlreadyExistDescr=ID 속성은 이미 {0} 엔티티에서 정의되었습니다
AssociationType.JoinColumnMappedBy=양방향 JoinColumn
AssociationType.JoinColumnUnidirectional=단방향 JoinColumn
AssociationType.JoinTableMappedBy=양방향 JoinTable
AssociationType.JoinTableMtM=단방향 JoinTable
AssociationType.MappedByJoinColumn=양방향 mappedBy
AssociationType.MappedByJoinTable=양방향 mappedBy
AssociationType.WithoutJoinColumnOtM=단방향 JoinTable
AttributeDeleteDialog.safeDeleteField=사용 위치 검색
AttributeOverridesValidator.emptyName.errorMessage=속성 재정의를 생성하려면 속성 이름을 입력하세요.
AttributeOverridesValidator.errorMessage=열 이름 {0}이(가) {1} 엔티티에서 중복됩니다.
AttributePropertiesPanel.TableGeneratorName=제너레이터 테이블
AttributePropertiesPanel.allocationSize=할당 크기
AttributePropertiesPanel.asc=ASC
AttributePropertiesPanel.associationType=매핑 타입
AttributePropertiesPanel.associationType.hint.joinColumnMappedByUpdater={0}\#{1}의 @JoinColumn과 {4}\#{5}의 @{2}(mappedBy\={3}
AttributePropertiesPanel.associationType.hint.joinColumnUpdater={0}\#{1}의 @JoinColumn
AttributePropertiesPanel.associationType.hint.joinTableMappedByUpdater={0}\#{1}의 @JoinTable과 {4}\#{5}의 @{2}(mappedBy\={3}
AttributePropertiesPanel.associationType.hint.joinTableUpdater={0}\#{1}의 @JoinTable
AttributePropertiesPanel.associationType.hint.mappedByJoinColumnUpdater={0}\#{1}의 @{2}(mappedBy\={3})와(과) {4}\#{3}의 @JoinColumn
AttributePropertiesPanel.associationType.hint.mappedByJoinTableUpdater={0}\#{1}의 @{2}(mappedBy\={3})와(과) {4}\#{3}의 @JoinTable
AttributePropertiesPanel.associationType.hint.oneToManyWithoutJoinColumnUpdater={0}\#{1}의 @JoinTable
AttributePropertiesPanel.attributeExists=이름이 ''{0}''인 상속된 속성이 있습니다
AttributePropertiesPanel.attributeOverrides=속성 재정의
AttributePropertiesPanel.cardinality=카디널리티
AttributePropertiesPanel.cardinality.empty=카디널리티를 선택하세요
AttributePropertiesPanel.cardinality.manyToMany=다대다
AttributePropertiesPanel.cardinality.manyToMany.hint=다수의 ''{0}'' 객체가 다수의 {1} 객체와 연결됩니다
AttributePropertiesPanel.cardinality.manyToOne=다대일
AttributePropertiesPanel.cardinality.manyToOne.mandatoryHint=다수의 ''{0}'' 객체가 하나의 {1} 객체와 연결됩니다
AttributePropertiesPanel.cardinality.manyToOne.nonMandatoryHint=다수의 ''{0}'' 객체가 0개 혹은 하나의 {1} 객체와 연결됩니다
AttributePropertiesPanel.cardinality.oneToMany=일대다
AttributePropertiesPanel.cardinality.oneToMany.hint=하나의 ''{0}'' 객체가 다수의 {1} 객체와 연결됩니다
AttributePropertiesPanel.cardinality.oneToOne=일대일
AttributePropertiesPanel.cardinality.oneToOne.mandatoryHint=하나의 ''{0}'' 객체가 하나의 {1} 객체와 연결됩니다
AttributePropertiesPanel.cardinality.oneToOne.nonMandatoryHint=하나의 ''{0}'' 객체가 0개 혹은 하나의 {1} 객체와 연결됩니다
AttributePropertiesPanel.cardinality.singleValue=단일 값
AttributePropertiesPanel.cascade=캐스케이드 타입
AttributePropertiesPanel.collection=컬렉션
AttributePropertiesPanel.collectionTable=컬렉션 테이블
AttributePropertiesPanel.collectionTableJoinColumn=열 병합
AttributePropertiesPanel.collectionType=컬렉션 타입
AttributePropertiesPanel.column=Column
AttributePropertiesPanel.columnDefinition=열 정의
AttributePropertiesPanel.conversionType=케이스 변환
AttributePropertiesPanel.converter=컨버터블
AttributePropertiesPanel.createField=필드 생성
AttributePropertiesPanel.createMappedAttribute=매핑된 속성 생성
AttributePropertiesPanel.currencyValue=통화
AttributePropertiesPanel.ddl=열 DDL
AttributePropertiesPanel.decimalSep=분수 구분자
AttributePropertiesPanel.dependsOnProperties=관련 속성
AttributePropertiesPanel.desc=DESC
AttributePropertiesPanel.disableUniqueField=엔티티가 소프트 삭제되었으나 엔티티의 테이블에 'delete_ts' 열이 없으므로 고유한 제약을 생성할 수 없습니다
AttributePropertiesPanel.elementCollection=요소 컬렉션
AttributePropertiesPanel.enterAttributeName=속성 이름 입력
AttributePropertiesPanel.enumType=열거형 타입
AttributePropertiesPanel.errorIntPositive={0}은(는) > 0이어야 합니다
AttributePropertiesPanel.errorPrecision=프로퍼티 생성
AttributePropertiesPanel.errorPrecisionBiggerScale=정확도는 스케일과 같거나 커야 합니다
AttributePropertiesPanel.errorScaleZero=스케일은 >\= 0이어야 합니다
AttributePropertiesPanel.fetchMode=가져오기 모드
AttributePropertiesPanel.fetchType=가져오기 타입
AttributePropertiesPanel.fkConstraintAction=FK 제약 액션
AttributePropertiesPanel.generateAttributeOverrides=속성 재정의 생성
AttributePropertiesPanel.generateEqualsAndHashCode=등호 및 HashCode 생성
AttributePropertiesPanel.generatedStrategy=ID generation
AttributePropertiesPanel.generatorName=제너레이터 이름
AttributePropertiesPanel.goTo=다음으로 이동
AttributePropertiesPanel.groupSep=그룹 구분자
AttributePropertiesPanel.id=ID
AttributePropertiesPanel.idAttribute=ID 속성
AttributePropertiesPanel.indexColumns=열
AttributePropertiesPanel.indexName=이름
AttributePropertiesPanel.indexUnique=고유
AttributePropertiesPanel.initialValue=초기 값
AttributePropertiesPanel.insertable=삽입 가능
AttributePropertiesPanel.inverseAttribute.msg=적절한 반전 속성을 찾을 수 없습니다. 반전 속성을 생성할까요?
AttributePropertiesPanel.inverseAttribute.title=반전 속성
AttributePropertiesPanel.inverseAttributeCreated=반전 속성이 생성되었으며 관련 엔티티가 저장되었습니다
AttributePropertiesPanel.inverseJoinColumnLengthError={0}의 <b>반전 병합 열</b> 이름은 {1}자 이하여야 합니다
AttributePropertiesPanel.inverseJoinColumnName=반전 병합 열
AttributePropertiesPanel.inverseJoinColumnReferencedColumnName=반전 참조 열
AttributePropertiesPanel.jdbcTypeCode=JDBC 타입 코드
AttributePropertiesPanel.joinColumnLengthError={0}의 <b>병합 열</b> 이름은 {1}자 이하여야 합니다
AttributePropertiesPanel.joinColumnName=병합 열
AttributePropertiesPanel.joinColumnReferencedColumnName=참조 열
AttributePropertiesPanel.joinTable=병합 테이블
AttributePropertiesPanel.joinTableLengthError={0}의 <b>병합 테이블</b> 이름은 {1}자 이하여야 합니다
AttributePropertiesPanel.joinTableName=병합 테이블
AttributePropertiesPanel.length=Length
AttributePropertiesPanel.lengthFieldUnlimited=제한 없음
AttributePropertiesPanel.lob=큰 객체
AttributePropertiesPanel.lookupActions=조회 액션
AttributePropertiesPanel.lookupType=조회 타입
AttributePropertiesPanel.mandatory=의무
AttributePropertiesPanel.mappedBy=다음으로 매핑됨
AttributePropertiesPanel.mappingType=속성 타입
AttributePropertiesPanel.mutable=가변형
AttributePropertiesPanel.name=이름
AttributePropertiesPanel.newType=타입
AttributePropertiesPanel.numberFormat=숫자 서식
AttributePropertiesPanel.numberFormatExample=예\: \#,\#\#\#,\#\#\#,\#\#\#.\#\#
AttributePropertiesPanel.numberFormatIsRequired=속성 ''{0}''에 ''숫자 서식'' 필드가 필요합니다
AttributePropertiesPanel.numberFormatStyle=숫자 서식 스타일
AttributePropertiesPanel.onDelete=삭제 시
AttributePropertiesPanel.onDelete.cascade.hint=''{0}'' 객체가 삭제될 때 자동으로 연결된 {1} 객체를 삭제합니다
AttributePropertiesPanel.onDelete.cascade.hintInverse={1} 객체가 삭제될 때 ''{0}'' 객체를 자동으로 삭제합니다
AttributePropertiesPanel.onDelete.default.hint=''{0}'' 객체가 삭제될 때 연결된 {1} 객체는 현재 상태대로 유지됩니다
AttributePropertiesPanel.onDelete.default.hintInverse=연결된 {1} 객체가 삭제될 때 ''{0}'' 객체는 현재 상태대로 유지합니다
AttributePropertiesPanel.onDelete.deny.hint=연결된 {1} 객체가 삭제되면 ''{0}'' 객체가 삭제되는 것을 막습니다
AttributePropertiesPanel.onDelete.deny.hintInverse=연결된 ''{0}'' 객체와 연결된 {1} 객체가 삭제되는 것을 막습니다
AttributePropertiesPanel.onDelete.unlink.hint=''{0}'' 객체가 삭제될 때 {1} 객체와의 연결 고리를 제거합니다
AttributePropertiesPanel.onDelete.unlink.hintInverse={1} 객체가 삭제될 때 ''{0}'' 객체와의 연결 고리를 삭제합니다
AttributePropertiesPanel.onDeleteInverse=삭제 시 반전
AttributePropertiesPanel.orderBy=다음으로 정렬
AttributePropertiesPanel.orderByExample=예\: order.date DESC, name, age DESC
AttributePropertiesPanel.orphanRemoval=고립 항목 제거
AttributePropertiesPanel.owner=소유하는 쪽
AttributePropertiesPanel.persistAttrCreated=연관된 엔티티 ID 속성이 생성되었습니다
AttributePropertiesPanel.persistRelatedId.msg=다른 데이터 스토어의 엔티티에 대한 참조를 생성하셨습니다.\n관련된 엔티티 ID를 생성하기 위해 보존되는 속성을 생성할까요?
AttributePropertiesPanel.persistRelatedId.title=관련된 엔티티 ID 속성
AttributePropertiesPanel.precision=정확도
AttributePropertiesPanel.readOnly=읽기 전용
AttributePropertiesPanel.renameAttribute=속성 이름 변경
AttributePropertiesPanel.scale=스케일
AttributePropertiesPanel.sequenceGeneratorName=시퀀스 이름
AttributePropertiesPanel.sequenceOrTableGeneratorName=시퀀스 이름
AttributePropertiesPanel.sequenceType=생성 타입
AttributePropertiesPanel.smartRefactoring=스마트 리팩터링
AttributePropertiesPanel.sort=정렬
AttributePropertiesPanel.targetEntity=타겟 엔티티
AttributePropertiesPanel.temporalType=임시
AttributePropertiesPanel.timeZoneColumn=시간대 열 타입
AttributePropertiesPanel.timeZoneStorageType=시간대 스토리지
AttributePropertiesPanel.transient=Transient
AttributePropertiesPanel.transientCardinality=카디널리티
AttributePropertiesPanel.transientWarning=속성이 transient로 변환되며 호환되지 않는 모든 어노테이션이 제거됩니다.
AttributePropertiesPanel.type=타입
AttributePropertiesPanel.unique=고유
AttributePropertiesPanel.updatable=업데이트 가능
AttributePropertiesPanel.version=버전
AttributePropertiesPanel.warning.caption=경고
AttributePropertiesPanel.warningMappedBy=''M''ANY_TO_MANY'' 연결인 속성 중 어느 것도 소유하는 쪽이 아닙니다. 속성 {0}
AttributePropertiesPanel.warningOwningSide=연결 속성의 어느 것도 소유하는 쪽이 아닙니다.\n반대쪽이 소유하도록 변경할까요?
AttributePropertiesPanel.warningRemovePropertyFromView=속성 타입을 변경한 후 엔티티를 저장하면 다음 보기에서 속성이 제거됩니다.
CollectionDatatype.Collection=컬렉션
CollectionDatatype.LinkedHashSet=LinkedHashSet
CollectionDatatype.Map=맵
CollectionDatatype.Set=세트
CreateAttributeWindow.addColumnToExistConstraintOrIndex=기존의 색인/제약에 열 ''{0}'' 추가
CreateAttributeWindow.chooseExistingIndex=기존의 색인/제약 선택
CreateAttributeWindow.createConstraintByAttribute=속성 ''{0}''(으)로 제약 생성
CreateAttributeWindow.createIndexByAttribute=속성 ''{0}''(으)로 색인 생성
CreateAttributeWindow.createIndexOrConstraintByAttribute=속성 ''{0}'' 기준의 색인/제약
CreateAttributeWindow.createInverseAttribute=반전 속성 생성
CreateAttributeWindow.createInverseAttributeWithParams=반전 속성 {0} 생성
CreateAttributeWindow.createPersistRelatedIdAttribute=보존되는 관련 ID 속성 생성
CreateAttributeWindow.indexesAndConstraints=색인 및 제약
CustomTypeEditorDialog.parametrized=매개변수화됨
DataSourceEditor.caption=DB 연결
DataSourceEditor.database.properties=데이터베이스 프로퍼티
DataStoreEditor.name=DB 연결 이름\:
DataStoreEditor.nameEmpty=DB 연결 이름을 입력하세요
Datastore.notification.provideCredentials=데이터베이스 자격 증명을 입력하세요
EntityCreator.write.command.create=생성
EntityPropertiesPanel.EmbeddedField=임베드된 클래스
EntityPropertiesPanel.IdField=ID
EntityPropertiesPanel.SequenceField=생성 타입
EntityPropertiesPanel.addPersistenceUnit=지속성에 추가
EntityPropertiesPanel.catalog=카탈로그
EntityPropertiesPanel.changePackage=패키지 변경
EntityPropertiesPanel.className=이름
EntityPropertiesPanel.createAttributeCaption=새 속성
EntityPropertiesPanel.createAttributeWithParametersCaption=새 {0} 속성
EntityPropertiesPanel.discriminator=판별자 값
EntityPropertiesPanel.discriminatorColumnName=판별자 열
EntityPropertiesPanel.discriminatorLength=판별자 길이
EntityPropertiesPanel.discriminatorType=판별자 타입
EntityPropertiesPanel.entityType=엔티티 타입
EntityPropertiesPanel.inheritanceType=상속
EntityPropertiesPanel.learnMore=자세히 알아보기…
EntityPropertiesPanel.name=엔티티 이름
EntityPropertiesPanel.optimizations=제안된 최적화
EntityPropertiesPanel.optimizations.fix.generateEqualsAndHashCodeFix=equals() 및 hashCode() 생성
EntityPropertiesPanel.optimizations.fix.makeAttributeNotOwnerFix=반대편에 OneToMany로 mappedBy 사용
EntityPropertiesPanel.optimizations.fix.setWithoutEqualsAndHashCodeInfo=컬렉션 타입은 ‘Set\\&lt;{0}\\&gt;’이나 ''{0}'' 엔티티는 equals()/hashCode() 메서드를 구현하지 않습니다. Set는 이러한 메서드를 내부에서 사용하며 기본 구현은 엔티티 비교에 문제를 일으킬 수 있습니다.\n예를 들어 서로 다른 Hibernate 세션에서 가져온 ID가 같은 엔티티는 동일하지 않게 됩니다.
EntityPropertiesPanel.optimizations.fix.useJoinColumnTypeFix=@JoinColumn 어노테이션 추가
EntityPropertiesPanel.optimizations.fix.useSetCollectionTypeFix=대신 Set<> 사용
EntityPropertiesPanel.package=패키지
EntityPropertiesPanel.packageName=패키지
EntityPropertiesPanel.packageSelector.title=엔티티 패키지 선택
EntityPropertiesPanel.parent=상위
EntityPropertiesPanel.performance.manyToManyCollectionInfo=컬렉션으로 ManyToMany 연결을 매핑할 때 Hibernate는 병합 테이블에서 이러한 연결을 효율적으로 삭제할 수 없습니다.\n대신 소유하는 엔티티와 연결된 모든 레코드를 삭제한 다음 남은 것들을 다시 삽입합니다. 컬렉션 타입을 Set로 변경하면 삭제에 필요한 쿼리의 수가 줄어듭니다.
EntityPropertiesPanel.performance.manyToManyListInfo=List로 ManyToMany 연결을 매핑할 때 Hibernate는 병합 테이블에서 이러한 연결을 효율적으로 삭제할 수 없습니다.
EntityPropertiesPanel.performance.oneToManyJoinColumnInfo=@JoinColumn이 있는 단방향 OneToMany는 추가적인 쿼리를 발생시킬 수 있습니다.\n참조된 JPA 엔티티에 병합 열이 없고 DB에만 있으므로 Hibernate는 이를 별도의 쿼리에서 업데이트합니다.\n연결을 양방향으로 만들면 문제가 해결됩니다.
EntityPropertiesPanel.performance.oneToManyJoinTableListInfo=@JoinTable이 적용된 양방향 OneToMany는 새로운 태이블을 삽입하며 이는 추가적인 insert/delete 쿼리를 필요로하고 공간을 차지합니다.\n같은 연결을 하나의 @JoinColumn으로 표현할 수 있습니다.
EntityPropertiesPanel.performanceWarning=이 매핑은 선언은 효율적이지 않으며 성능 문제를 일으킬 수 있습니다.
EntityPropertiesPanel.persistenceUnit=보존 유닛
EntityPropertiesPanel.primaryKeyJoinColumnDefinition=PK 병합 열 정의
EntityPropertiesPanel.primaryKeyJoinColumnName=PK 병합 열
EntityPropertiesPanel.referenceType=참조 타입
EntityPropertiesPanel.renameClass=클래스 이름 변경
EntityPropertiesPanel.schema=스키마
EntityPropertiesPanel.table=Tablas
EntityPropertyPathReference.inspection.unresolvedMessagePattern=프로퍼티 경로 ''{0}''은(는) 엔티티 클래스 ''{1}''에 대해 유효하지 않습니다
EntitySettingsWindow.jpb.title=새 엔티티
EntityType.EMBEDDABLE=Embeddable
EntityType.MAPPED_SUPERCLASS=매핑된 상위 클래스
EntityType.PERSISTENT=엔티티
ExistingAttributeNameValidator.errorMessage=동일한 이름의 속성이 이미 있습니다
ExistingColumnNameValidator.attributeNameEqualsDiscriminatorColumn=열 이름이 {0}인 속성이 클래스 {1}의 판별자 열 이름과 같습니다
ExistingColumnNameValidator.discriminatorNameNotUnique=판별자 열 이름 ''{0}''은(는) ''{1}'' 엔티티 내에서 고유하지 않습니다
ExistingColumnNameValidator.errorMessageEmbedded=엔티티 {1}에 열 이름이 {0}인 임베드된 속성이 있습니다
ExistingColumnNameValidator.errorMessageInherited=열 이름이 {0}인 상속된 속성이 있습니다
ExistingColumnNameValidator.errorMessageNamed=열 이름이 {0}인 속성이 이미 있습니다
ExistingSequenceNameValidator.errorMessage=동일한 이름의 시퀀스가 이미 있습니다
HibernateCustomTypeDialog.title=사용자 지정 타입 생성
HibernateCustomTypeDialog.type=유형
IndexesEditor.availableColumns.title=사용 가능한 열
IndexesEditor.selectedColumns.title=선택된 열
IndexesEditor.validation.makeManyToOneFix={0}을(를) 다대일 연결로 설정
IndexesEditor.validation.makeOneToOneFix={0}을(를) 일대일 연결로 설정
JpaConverterEditorDialog.autoApply=자동 적용
JpaConverterEditorDialog.dbType=데이터베이스 열 타입
JpaConverterEditorDialog.entityType=엔티티 속성 타입
JpaPalette.createdDate=생성 날짜
JpaPalette.equalsAndHashCode=Equals 및 HashCode
JpaPalette.toString=ToString
LombokPropertiesPanel.getter=Getter
LombokPropertiesPanel.isLombokAllArgsConstructor=AllArgsConstructor
LombokPropertiesPanel.isLombokBuilder=빌더
LombokPropertiesPanel.isLombokNoArgsConstructor=NoArgsConstructor
LombokPropertiesPanel.isLombokSuperBuilder=SuperBuilder
LombokPropertiesPanel.onlyExplicitlyIncluded=명시적으로 포함된 항목만
LombokPropertiesPanel.setter=Setter
LombokPropertiesPanel.toString=ToString
LombokPropertiesPanel.toStringInclude=ToString에 포함됨
PersistenceUnitEditor.create.title=지속성 유닛 생성
PersistenceUnitEditor.edit.title=지속성 유닛 수정
PersistenceUnitEditor.package.chooser.title=지속성 유닛 패키지 선택
PersistenceUnitEditor.select.entity=엔티티 선택
PersistenceUnitEditor.validation.indexing=색인이 진행 중일 때는 완료할 수 없습니다
PersistenceUnitEditor.validation.name.empty=이름은 공백일 수 없습니다
PersistenceUnitEditor.validation.name.unique=이름은 고유해야 합니다
PersistenceUnitValidationDialog.proceed=진행
PersistenceUnitValidationDialog.title=빈 지속성 유닛
PrimitiveTypeValidator.errorMessage=타입이 원시형일 수 없습니다
ProjectPropertiesPage.connection=연결 테스트
ProjectPropertiesPage.connectionSuccessful=''{0}''에 성공적으로 연결했습니다
ProjectPropertiesPage.connectionTestCaption=테스트
ProjectPropertiesPage.dbConnectionParams=연결 매개변수
ProjectPropertiesPage.dbPassword=비밀번호
ProjectPropertiesPage.dbPassword.showCheckBox=암호 표시
ProjectPropertiesPage.dbType=데이터베이스 타입
ProjectPropertiesPage.dbUrl=데이터베이스 URL
ProjectPropertiesPage.dbUser=데이터베이스 사용자
ProjectPropertiesPage.emptyUrl=빈 URL로 연결할 수 없습니다
ProjectPropertiesPage.incorrectDbHost=유효하지 않은 데이터베이스 호스트 값\: ''{0}''.\n호스트는 localhost[\:port]와 유사해야만 합니다.
ProjectPropertiesPage.integratedSecurity=통합 보안
ProjectPropertiesPage.integratedSecurityInstruction=<html>MSSQL 통합 보안을 구동하려면,<ol><li><a href\="{0}">Windows 인증 라이브러리 아카이브 다운로드</a></a></li><li>다운로드된 jar 파일을 "{1}" 디렉터리에 압축 해제</li><li>IDEA 재시작</li></ol>
ProjectPropertiesPage.testConnection.title=연결이 설정되는 중입니다
ProjectPropertiesPage.validation.empty=빈 값
RelatedAttributeRemover.attributeDeleted=속성 {0}.{1}이(가) 제거되었습니다
RelatedAttributeRemover.dialogMessage=<html>엔티티 <b>{0}</b>에 관련된 속성 <b>{1}</b>이 포함되어 있습니다. 제거할까요?</html>
RelatedAttributeRemover.dialogTitle=관련 속성 제거
RepositoryConditionType.EQUALS=Equals
RepositoryConditionType.ING_POSTFIX=-ing
RepositoryConditionType.IS=Is
RepositoryConditionType.IS_ING=Is  -ing
RepositoryConditionType.NONE=없음
RepositoryConditionType.SIMPLE=단순함
SerializableType.NoSerializable=시리얼화 불가
SerializableType.Serializable=시리얼화 가능
SerializableType.SerializableWithVersionUID=버전 UID로 시리얼화 가능
SubDtoType.EXIST_CLASS=기존 클래스
SubDtoType.FLAT=평평함
SubDtoType.NEW_CLASS=새 클래스
SubDtoType.NEW_NESTED_CLASS=새 중첩 클래스
Validation.blankOrEmptyClassName=클래스 이름이 비어 있습니다
Validation.converterExists=지정된 패키지에 이미 같은 이름의 {0}이(가) 있습니다
Validation.dtoExists=지정된 패키지에 이미 같은 이름의 DTO 클래스가 있습니다
Validation.embeddedRequired=필드에 임베드된 클래스가 필요합니다
Validation.entityExists=지정된 패키지에 이미 같은 이름의 엔티티가 있습니다
Validation.hibernateEventListener=지정된 패키지에 이미 같은 이름의 Hibernate 이벤트 리스너가 있습니다
Validation.indexColumns={0}은(는) 최소 하나의 열을 포함해야 합니다
Validation.indexExists=같은 이름의 {0}이(가) 이미 있습니다
Validation.invalidRepoEntityType=임베드된 엔티티의 저장소는 지원되지 않습니다
Validation.language.null=언어가 지정되지 않았습니다
Validation.mapperExists=지정된 패키지에 이미 같은 이름의 매퍼가 있습니다
Validation.notQualifiedName=정규화된 Java 이름이 유효하지 않습니다
Validation.notValidClassName=유효한 클래스 이름이 아닙니다
Validation.notValidType=유효한 타입이 아닙니다
Validation.package.empty=패키지 이름이 공백일 수 없습니다
Validation.package.invalid=패키지 이름에는 숫자, 문자 및 밑줄만 포함될 수 있으며 마침표로 끝날 수 없습니다
Validation.projectionExists=지정된 패키지에 이미 같은 이름의 프로젝션이 있습니다
Validation.repositoryExists=지정된 패키지에 이미 같은 이름의 저장소가 있습니다
Validation.repositoryExists.name=지정된 패키지에 이름이 ''{0}''(으)로 같은 저장소가 있습니다
Validation.reservedName=JPA 어노테이션의 예약된 이름입니다
Validation.select.repository=최소 하나의 저장소를 선택하세요
ViewPropertiesPanel.collapseAll=모두 접기
ViewPropertiesPanel.expandAll=모두 펼치기
ViewPropertiesPanel.selectAll=모두 선택
ViewPropertiesPanel.selectBasicAttributes=모든 기본 속성 선택
ViewPropertiesPanel.unselectAll=모두 선택 해제
action.browse.text=찾아보기
action.ddl.sql.ddl=DDL
action.editor.and.preview.text=에디터 및 미리보기
action.editor.text=에디터
action.preview.text=미리보기
action.select.action.text=액션 선택
action.text.open.settings=설정 열기
actions=액션
add=추가
add.attributes.dto=DTO에 속성 추가
add.entity.attribute=엔티티 속성 추가
add.index=색인 추가
add.lifecycle.callback.method=수명 주기 콜백 메서드 추가
add.listener=리스너 추가
add.log=로거 추가
add.named.query=기명 쿼리 추가
add.order.by.attribute=속성 기준 정렬 추가({0})
add.query.condition=쿼리 조건 추가({0})
add.spring.repos.derived.method=Spring 저장소에서 파생된 메서드 추가
add.spring.repos.query.method=Spring 저장소 쿼리 메서드 추가
add.update.value.assignment=업데이트 값 대입 추가({0})
addAllArgs.fix=@AllArgsConstructor 어노테이션 추가
addAllArgsAndNoArgs.fix=@NoArgsConstructor 및 @AllArgsConstructor 어노테이션 추가
addConstructor.family=생성자 추가
addJpaConverterAnnotation.fix=@Converter 어노테이션 추가
addModifyingAnnotation.fix=@Modifying 어노테이션 추가
addNoArgs.fix=@NoArgsConstructor 어노테이션 추가
addSimpleAllArgsConstructor.fix={0} all-args 생성자를 {1}에 추가
addSimpleConstructors.fix=all-args 및 no-args 생성자를 {0}에 추가
additional.db.drivers=추가적인 DB 드라이버
additional.part.of.method.name=메서드 삽입사
advanced=고급
all.args.constructor=모든 args 생성자
all.args.constructor.and.mutable.unselect=all-args 생성자를 갖거나 수정 가능해야 하며, 그렇지 않으면 프로퍼티를 설정할 수 없습니다
all.ignore.case=모든 무시 케이스
artifact.drivers.files.unload=드라이버 정보를 로드할 수 없습니다. 인터넷 연결을 확인하세요.
assignJpaConverter.fix=JPA 컨버터/Hibernate 타입 대입
async=Async
attribute=속성
attribute.comment.text=/*\nTODO [역공학] 필드를 생성하여 ''{0}'' 열에 매핑\n사용 가능한 액션\:
attribute.name=속성 이름
attribute.type=속성 타입
attributes.mapped.super.class=속성 추출
audit.fields=필드 감사
audit.type.validation=감사의 지정된 타입이 올바르지 않습니다
audited=감사됨
auditing.entity.listener.not.found=<html>엔티티 클래스에서 AuditingEntityListener를 감지할 수 없습니다. 해당 리스너 혹은 유사한 리스너가 지정되지 않으면 감사 필드가 채워지지 않습니다. 사용자 지정 감사 리스너를 사용하는 경우 <a href\='\#ADD_IT'>AuditingEntityListener 추가</a> 혹은 <a href\='\#HIDE_IT'>이 경고를 무시</a>하세요.</html>
auditor.aware.inheritor.not.found.info=AuditorAware{0}의 구현이 감지되지 않았습니다. 감사 타입을 수동으로 지정하고 해당하는 AuditAware 구현을 추후에 생성할 수 있습니다.
auditor.type=감사자 타입
blaze.persistence.entity.view=Blaze 지속성 엔티티 보기
cancel=취소
cancel.selection=선택 범위 취소
cancel.selection.description=선택된 테이블 범위가 비워집니다.<br>계속할까요?
caption=자막
cardinality=카디널리티
cascade.remove.warning=CascadeType.REMOVE가 기대한 것보다 더 많이 삭제할 수도 있습니다
cast.event.entity=엔티티 지원
choose.attribute=속성 선택
choose.class=클래스 선택
choose.hibernate.entity=엔티티 선택
choose.hibernate.event.listener=Hibernate 이벤트 {0} 선택
choose.table.or.view=테이블 혹은 보기 선택
class=클래스
class.name=클래스 이름
class.name.validation.error=지정된 패키지에 이미 같은 이름의 클래스가 있습니다
column.definition.not.found=열 정의를 찾을 수 없습니다
column.name.name=이름
column.name.value=값
columnWidth=필드 너비
command.name.create.entity=엔티티 생성
command.name.update.entity.attribute=엔티티 속성 업데이트\: {0}
comment.saving.strategy.annotation=@Comment 어노테이션
comment.saving.strategy.ignore=무시
comment.saving.strategy.javaDoc=Java 문서
connecting.to.dataSource=''{0}''에 연결 중…
continue=계속
creatable=생성 가능
create.blaze.persistence.entity.view=Blaze 지속성 엔티티 보기 생성
create.count.method=Count 메서드 생성
create.delete.method=Delete 메서드 생성
create.dto=DTO 생성
create.dto.action.text=DTO 생성…
create.dto.or.projection.class=DTO 혹은 Projection 클래스 생성
create.entities.and.attributes=엔티티 및 속성 생성…
create.entity.attributes=엔티티 속성 생성
create.entity.indicator=엔티티 ''{0}'' 생성
create.entity.models=엔티티 모델 생성
create.exists.method=Exists 메서드 생성
create.find.collection.method=Find Collection 메서드 생성
create.find.instance.method=Find Instance 메서드 생성
create.new.dto.class=새 DTO 클래스 생성
create.new.mapped.superclass=새 MappedSuperclass
create.new.projection.class=새 Projection 클래스 생성
create.projection=Spring 데이터 프로젝션 생성 
create.query.count.method=@Query Count 메서드 생성
create.query.delete.method=@Query Delete 메서드 생성
create.query.exists.method=@Query Exists 메서드 생성
create.query.find.collection.method=@Query Find Collection 메서드 생성
create.query.find.instance.method=@Query Find Instance 메서드 생성
create.query.repository.method=쿼리 저장소 메서드 ''{0}''
create.query.update.method=Create @Query Update 메서드 생성
create.revision.entity=리비전 엔티티 생성
create.revision.listener=리비전 리스너 생성
create.spring.data.repository=Spring 데이터 저장소 생성
create.spring.data.repository.method=Spring 데이터 저장소 메서드 생성
createDbConnection=DB 연결 생성
createJpaConverter.fix=사용자 지정 타입 생성
createPageableParameter.fix=Pageable 매개변수를 메서드 시그니처에 추가
created.by=생성자
created.date=생성 날짜
criteria.api.specification=기준 API 사양
data.source=데이터 소스
database=데이터베이스
database.driver.not.selected=데이터베이스 드라이버가 선택되지 않았습니다
database.drivers=데이터베이스 드라이버
date.type=날짜 타입
date.type.validation=지정된 날짜 타입이 올바르지 않습니다
db.connection=DB 연결
db.connection.delete=삭제
db.connection.save=Guardar
db.connection.updated=DB 연결 ''{0}''이(가) 성공적으로 업데이트되었습니다.
db.connection.was.deleted=DB 연결 ''{0}''이(가) 삭제되었습니다
db.driver.column.name.path=경로
db.driver.download.version={0} 다운로드
db.driver.switchToVersion={0}(으)로 전환
db.driver.title.downloading={0} 다운로드 중
db.driver.version=드라이버 버전
db.driver.version.not.set=설정되지 않았습니다\!
db.generated.id.description=<ul><li><b>NONE</b> - neither database nor ORM provide the ID value. Id should be explicitly assigned in the source code.</li><li><b>IDENTITY</b> - ID is managed by the database. Works for auto-incremental types and in case of using `nextval("sequence_name")` or any other function as the default value for the ID column.</li><li><b>SEQUENCE</b> - ID is managed by ORM. The strategy requires a sequence on the database side. Optimized for bulk insert.</li></ul>
db.generated.id.description.uuid=<ul><li><b>NONE</b> - neither database nor ORM provide the ID value. Id should be explicitly assigned in the source code.</li><li><b>UUID</b> - ID is managed by the client. The value can be assigned using Hibernate Generator, field initialization, or custom factories. This is the only option for distributed systems with several application and database instances deployed worldwide.</li></ul>
db.generated.id.jpa.entity=JPA 엔티티 내의 DB가 생성한 ID
db.snapshot.help.description=DB 스키마가 역공학 시 변경되지 않는 경우 DB 스키마 캐싱을 활성화하는 것이 권장됩니다. 그렇지 않으면 역공학이 매번 될 때마다 DB에서 DB 스키마가 로드됩니다. 캐싱을 활성화하면 선택된 DB의 스냅샷 파일이 임시 디렉터리에 생성됩니다 - <code>{0}</code>
db.view.without.id.columns=기본 키로 사용될 열이 선택되지 않았습니다
db.views.without.id.columns.msg=다음의 관계에 대해 기본 키로 사용될 열이 선택되지 않았습니다. <br><ul>{0}</ul>모든 JPA 엔티티는 ID가 있어야 합니다. ID가 없는 엔티티를 생성할까요?
ddl.by.entities=엔티티별 DDL
ddl.type=DDL 타입
declare.new=새로 선언
default.db.connection=기본 DB 연결
default.method.name.will.be.generated=기본 메서드 이름이 생성됩니다
define.entity.graph=엔티티 그래프 정의
defined.target.java.type=대상 Java 타입 정의
delete.db.connection=DB 연결 ''{0}''을(를) 삭제할까요?
dialog.message.attribute.name.reserved.keyword=속성 이름이 예약된 키워드입니다
dialog.message.duplicates.are.found.for.items=다음 항목과 중복되는 항목이 있습니다. {0}
dialog.message.entity.attribute.should.have.name.written.in.camelcase.naming.convention=엔티티 속성은 camelCase 이름 지정 규칙을 따라 이름이 지정되어야 합니다
dialog.message.field.required=필드 {0}은(는) 필수입니다
dialog.message.must.not.be.empty={0}은(는) 공백일 수 없습니다
dialog.message.parameters.with.blank.names.are.not.allowed=이름이 빈 매개변수는 허용되지 않습니다
dialog.message.there.inherited.attribute.with.such.name=그러한 이름을 가진 상속된 속성이 있습니다
dialog.title.choose.class=클래스 선택
dialog.title.downloading.driver.files=드라이버 파일 다운로드 중
dialog.title.params=매개변수
dialog.title.select.item=항목 선택
diff.scope.all.places=모든 위치
diff.scope.count=\ {0}/{1}
diff.scope.project=프로젝트
diff.scope.project.and.libraries=프로젝트 및 라이브러리
diff.scope.project.and.tests=프로젝트 및 테스트
diff.scope.selected.entities=선택된 엔티티
diff.scope.test=테스트만
director.of.class.not.found=''{0}'' 클래스의 디렉터리를 찾을 수 없습니다
directory=경로
distinct=고유
domain.entity=도메인 엔티티
down=Down
download.driver.files=드라이버 파일 다운로드
download.missing.driver.files=누락된 드라이버 파일 <a href\="{0}">다운로드</a>
downloading.driver.files=드라이버 파일 다운로드 중
driver.0.not.found=드라이버 {0}을(를) 찾을 수 없습니다\!
driver.class=드라이버 클래스
driver.files.not.found=드라이버 파일을 찾을 수 없습니다
driver.files.were.not.loaded=드라이버 파일이 로드되지 않았습니다
dto=DTO
dto.and.spring.data.projections=DTO 및 Spring 데이터 프로젝션
dto.class=DTO 클래스
dto.class.already.exists=<html>그런 클래스가 이미 있씁니다.<br>'기존 클래스' 타입을 선택하거나 클래스에 고유한 이름을 부여하세요.
dto.class.name=DTO 클래스 이름
dto.class.not.exists=선택된 클래스가 존재하지 않습니다
dto.type=DTO 타입
duplicate.attribute.name=중복 속성 이름 ''{0}''
duplicate.db.connection.name=DB 연결 이름 ''{0}''은(는) 프로젝트 내에서 고유해야 합니다
duplicate.query.mapping=중복되는 쿼리 매핑 이름 ''{0}''. 엔티티 - ''{1}''
dynamic.projection=동적 프로젝션
edit=편집
elementCreationDialog.scaffoldingLanguage=Lenguaje\:
empty.db.connection=DB 연결을 비워둘 수 없습니다
empty.generation.type.value=생성 타입은 공백일 수 없습니다
enable.jpa.auditing.info=<html>@EnableJpaAuditing 어노테이션이 감지되지 않았습니다. Spring 감사를 구성할 수 없습니다. Spring 감사가 애플리케이션 내에서 적절히 구성되었는지 확인하세요. <a href\='https\://docs.spring.io/spring-data/jpa/docs/current/reference/html/\#jpa.auditing.configuration'>여기서 구성에 관해 더 자세히 읽어보세요...</a></html>
enable.mongo.auditing.info=<html>@EnableMongoAuditing 어노테이션이 감지되지 않았습니다. Spring 감사를 구성할 수 없습니다. Spring 감사가 애플리케이션 내에서 적절히 구성되었는지 확인하세요. <a href\='https\://docs.spring.io/spring-data/mongodb/docs/current/reference/html/\#mongo.auditing'>여기서 구성에 관해 더 자세히 읽어보세요...</a></html>
entities=엔티티
entities.from.db=DB의 엔티티
entity=엔티티용
entity.attribute.from.db=DB의 엔티티 속성
entity.class=엔티티 클래스
entity.graph=엔티티 그래프
entity.graph.field=엔티티 그래프
entity.graph.type.fetch=<html>javax.persistence.fetchgraph 프로퍼티가 엔티티 그래프를<br>지정하기 위해 사용된 경우 엔티티 그래프의 속성 노드가 지정한 속성은<br>FetchType.EAGER로 간주되며 지정되지 않은 속성은<br>FetchType.LAZY로 간주됩니다<br><br></html>
entity.graph.type.load=<html>javax.persistence.loadgraph 프로퍼티가 엔티티 그래프를<br>지정하기 위해 사용된 경우 엔티티 그래프의 속성 노드가 지정한 속성은<br>FetchType.EAGER로 간주되며 지정되지 않은 속성은<br>지정된 혹은 기본 FetchType으로 간주됩니다<br><br></html>
entity.listener.class=엔티티 리스너 클래스
entity.package=엔티티 패키지
entity.projection.or.dto.return.type=엔티티, Spring 프로젝션 혹은 DTO 클래스
entity.view.class.name=엔티티 보기 클래스 이름
entity.view.type=엔티티 보기 타입
equals.hash.code=equals() 및 hashCode()
error=오류
excludeLazyField.fix=이 필드를 @ToString에서 제외합니다.
excludeLazyFields.fix=지연 로드된 모든 필드를 @ToString.Exclude로 제외합니다.
excludeLazyFieldsFromHeader.fix=지연 로드된 모든 필드를 제외합니다.
existing.db.upgrade=기존 DB 업데이트(Diff)
existing.parent.class=기존 상위 클래스
extract.and.configure.jpql.query=JPQL 쿼리 추출하고 구성…
extract.jpql.query=JPQL 쿼리 추출
extract.mapped.super.class=MappedSuperclass로 추출
extract.mapped.super.class.from=다음에서 추출
extract.mapped.super.class.to=다음으로 추출\:
extracting.jpql.using.limit.query=JPQL 쿼리는 메서드에서 'Top' 혹은 'First' 옵션을 사용하여 추출할 수 없습니다
extracting.warning=경고 추출 중
extracting.warning.msg=외부 메서드 중 하나에 사용된 일부 속성/메서드가 선택되지 않아 상위 클래스로 추출되지 않습니다. 이로 인해 코드가 컴파일되지 않을 수 있습니다. 계속할까요?
field.name=필드 이름
field.required=필드 ''{0}''은(는) 필수입니다
file.name=파일 이름
find=찾기
find.first=먼저 찾기
fixes.create.jpa.projection=Spring 프로젝션 생성
fluent.help.description=생성된 setter가 `void` 대신 `this`를 반환합니다. 이러한 setter는 다수의 메서드 호출로 체인을 구성할 때 유용합니다.
fluent.setters=Fluent setter
found.override.properties=이러한 프로퍼티를 재정의할까요?
from.existing.attributes=기존 속성으로부터
from.parent=상위 요소로부터
generate.columns.from.db=DB로부터 열 생성
generate.ddl.by.entities=엔티티별로 DDL 생성
generate.equals.and.hashcode.already.defined.warning=클래스 {0}의 메서드 ''boolean equals(Object)'' 혹은 ''int hashCode()''가 이미 정의되어 있습니다. 삭제하고 진행할까요?
generate.equals.and.hashcode.already.defined.warning.anonymous=이 익명 클래스의 메서드 'boolean equals(Object)' 혹은 'int hashCode()'가 이미 정의되어 있습니다. 삭제하고 진행할까요?
generate.equals.and.hashcode.composite.warning={0} {1}은(는) equals 및 hashcode 메서드를 구현합니다. 생성할까요?
generate.equals.and.hashcode.several.warning=다수의 키가 발견되었습니다. equals() 및 hashCode() 메서드에 어느것을 사용할까요?
generate.equals.and.hashcode.several.warning.title=생성 전략 선택
generate.tostring.already.defined.warning=클래스 {0} ''''String toString()''의 메서드가 이미 정의되었습니다. 삭제하고 진행할까요?
generate.tostring.composite.warning={0} 클래스 내에 toString() 메서드를 구현할까요?
generateEqualsAndHashCode.fix=equals(), hashCode() 및 toString() 생성
generateNoArgsConstructor.fix=인수가 없는 생성자를 클래스에 추가
generated.ddl=생성된 DDL
go.to.domain.entity=''{0}'' 도메인 엔티티로 이동
graph=그래프
graph.fetch.type=가져오기 타입
graph.fields.load=로드할 필드
hibernate=Hibernate
hibernate.ddl.auto=DDL 자동
hibernate.entity.field.tooltip=엔티티의 이름입니다. 다수인 경우 쉼표로 구분합니다
hibernate.event=Hibernate 이벤트
hibernate.event.listener=Hibernate 이벤트 {0}
hibernate.events.field.tooltip=Hibernate 이벤트의 이름입니다. 다수인 경우 쉼표로 구분합니다
hibernate.format.sql=SQL 서식 지정
hibernate.show.sql=SQL 표시
id=ID
id.generated.strategy=ID generation
idea.data.source.refresh.exception=IDEA 데이터 소스 새로고침 예외
incorrect.attribute.value=엔티티 속성은 camelCase 이름 지정 규칙을 따라 이름이 지정되어야 합니다
incorrect.length.value=잘못된 길이 값\: {0}
inspection.message.unknown.column=알 수 없는 열 {0}
invalid.attribute.name=열\: ''{0}''. 유효하지 않거나 예약된 Java 식별자인 속성 이름\: ''{1}''
invalid.class.name=잘못된 클래스이름
invalid.domain.entity.class=유효하지 않은 도메인 엔티티 클래스 ''{0}''
invalid.field.name=엔티티 속성의 유효하지 않은 필드 이름 ''{0}''
invalid.field.name.changed=<html>MapStruct 매퍼 생성으로 컬렉션 타입에 해당하는 속성의 프로퍼티 이름을 변경할 수 없습니다. 이러한 프로퍼티의 이름은 초기화되었습니다.</html>
invalid.or.empty.domain.entity.class=도메인 엔티티 클래스가 유효하지 않거나 비어 있음
invalid.or.empty.dto.class=DTO 클래스 값이 유효하지 않거나 비어 있음
invalid.package.name=잘못된 패키지 이름
invalid.subDto.type=<html>유효하지 않은 subDto 타입의 속성 ''{0}''.<br/>1단계 이상의 중첩 수준을 가진 플랫 컬렉션 속성이 있는 매퍼를 생성할 때는<br/>지원되지 않습니다.</html>
invalid.subEntityView.type=<html>유효하지 않은 하위 엔티티 보기 타입 속성 ''{0}''.<br/>1단계 이상의 중첩 수준을 가진 플랫 컬렉션 속성이 있는 엔티티 보기를 생성할 때는<br/>지원되지 않습니다.</html>
java.record=Java 기록
java.type.is.empty=열\: ''{0}''. Java 타입이 필요합니다
jpa.buddy.common.notifications=JPA Buddy 공통 알림
jpa.buddy.logs=JPA Buddy 로그
jpa.buddy.template.group=JPA Buddy
jpa.converter.or.hibernate.type=JPA 컨버터/Hibernate 타입
jpa.entity=JPA 엔티티
json.ignore.unknown.properties=JSON 탈시리얼화 시 알 수 없는 프로퍼티 무시
last.modified.by=마지막으로 수정한 사람\:
last.modified.date=마지막으로 수정한 날짜\:
last.update=(DB의 실제 상태를 잡은 날짜\: {0})
learn.more=자세히 알아보기
limit=제한
limit.prefix=접두사 제한
limit.size=사이즈 제한
listener.class.not.selected=엔티티 리스너 클래스가 선택되지 않았습니다. 클래스를 선택하세요.
loading.database.model=데이터베이스 모델을 로드하는 중…
loading.time=로드 시간 - {0}초
lock.mode=모드 잠금
makeCompositeClassSerializable.fix={0} 클래스가 Serializable을 구현하도록 설정
makeTransient.fix=@Transient로 표시
mandatory.attribute.not.added=필수 속성이 엔티티에 추가되지 않습니다
mapStruct.collectionMappingCollection=컬렉션의 mapper 메서드 생성
mapStruct.collectionMappingStream=stream().map(...) 사용
mapStruct.createMapStructClassCaption=MapStruct 인터페이스 생성
mapStruct.mapper=MapStruct 인터페이스
mapStruct.mapperClassName=Mapper 클래스 이름
mapStruct.mapperParentInterface=상위 인터페이스
mapStruct.packageChooserDialogCaption=MapStruct 매퍼 패키지 선택
mapped.columns=매핑된 열
mapped.relations=매핑된 관계
mapped.super.class.extract.generator=@SequenceGenerator 선언을 {0}(으)로 추출
mapped.super.class.generator.name=제너레이터 이름
mapped.super.class.name=MappedSuperclass 이름
mapper.methodName=메서드 이름
mapper.methods=매퍼 메서드
mapper.naming.options.collection=컬렉션 타입 접미사 사용
mapper.naming.options.plural=복수형 사용
mapper.naming.options.singular=단수 사용
mapping.java.type=Java 타입 매핑 중
mapping.settings=매핑 설정
mapping.types=매핑 타입
menuItem=메뉴
method=메서드
method.infix.help=''{0}'' 접미사와 ''By'' 조건 사이에 위치하는 메서드 이름 세그먼트입니다. 이를 통해 간결하게 메서드의 이름을 지정할 수 있고 같은 쿼리 조건으로도 다양한 데이터 타입을 반환하는 데 활용할 수 있습니다.
method.name=메서드 이름
method.prefix=메서드 접두사
methods.mapped.super.class=메서드 추출
microsoft.sql.server=Microsoft SQL Server
microsoft.sql.server.jtds=Microsoft SQL Server(jtds)
migrate.indexes.and.constraints=색인과 제약 마이그레이션
migrate.other.columns=엔티티에 다른 열 마이그레이션
missing.primary.key.columns=기본 키 열 누락
modifying=수정 중
module=모듈 내
mutable=가변형
name=이름
named.parameters=기명 매개변수
named.query=기명 쿼리
named.query.attr.name.empty=속성 이름이 필요합니다. 테이블 행\: {0}
named.query.creation.error=기명 쿼리 생성 오류
new.attribute=새로운 속성
new.dto=새 DTO
new.mapper.class=새 MapStruct 인터페이스
no.attributes=속성 없음
no.attributes.detected=감지된 속성이 없습니다
no.attributes.selected=선택된 속성이 없습니다
no.auditor.aware.classes.info=<html>AuditorAware 인터페이스의 구현이 감지되지 않았습니다. 감사 타입을 수동으로 지정하고 해당하는 AuditAware 구현을 추후에 생성할 수 있습니다.</html>
no.columns.for.reverse.engineering=역공학할 열이 없습니다
no.driver.files.configured=구성된 드라이버 파일이 없습니다. {1}(으)로 <a href\="{0}">전환</a>
no.entities=엔티티 없음
notification.content.exception.during.create.directory=디렉터리 생성 중 예외 발생\: {0}
notification.content.please.select.directory.for.create.action=create 액션에 사용할 디렉터리를 선택하세요
notification.title.exception.during.creation.projection=프로젝션 생성 중 예외
notification.title.exception.when.entity.column.name.calculating.column.name.template=엔티티 열 이름을 계산하는 중 예외가 발생했습니다. 열 이름 템플릿\: {0}
notification.title.exception.when.entity.name.calculating.entity.name.template=엔티티 이름을 계산하는 중 예외가 발생했습니다. 엔티티 이름 템플릿\: {0}
notification.title.exception.when.entity.table.name.calculating.table.name.template=엔티티 테이블 이름을 계산하는 중 예외가 발생했습니다. 테이블 이름 템플릿\: {0}
notification.title.project.not.contains.modules=프로젝트에 모듈이 없습니다
nullability=Null 가능성
nullable=Null 가능
open.db.connection=DB 연결 열기
order.by.attributes=속성으로 정렬
other=기타
other.settings=다른 설정
override.properties=프로퍼티 재정의
packageName=패키지
pageable=Pageable
parent=상위
persistence.unit.file=Persistence.xml 파일
persistence.unit.manuallyAdded=수동으로 추가됨
persistence.unit.scanAllPackages=모든 패키지 스캔
please.check.internet.connection=인터넷 연결을 확인하세요
pojo.class=POJO 클래스
presentation=프리젠테이션
progress.details.extracting={0} 추출 중
progress.loadDriversTitle=데이터베이스 드라이버 목록 로드 중…
progress.text.choice.downloading.resolving={1} {0, choice, 0\#다운로드 중|1\#해결 중}
project.jdk.select.title=프로젝트 SDK 선택
project.sdk.not.defined=프로젝트 JDK가 정의되지 않았습니다
projection=프로젝션
projection.class.name=프로젝션 클래스 이름
projection.type=프로젝션 타입
property.name=프로퍼티 이름
pu.without.entities.error=선택된 지속성 유닛에는 엔티티가 없습니다. 최근에 패키지 이름이 리팩터링되었거나 persistence.xml에 변경 사항이 있을 수 있습니다. 지속성 유닛에 엔티티가 포함되어야 하는 경우 이를 편집하거나 drop 구문을 생성하려면 더 진행하세요. 다른 지속성 유닛을 선택하려면 취소를 클릭하세요.
query=쿼리
query.conditions=쿼리 조건
query.options=쿼리 옵션
query.string=쿼리 문자열
radio.hibernate.custom.type=Hibernate 사용자 지정 타입
radio.jpa.converter=JPA 컨버터
references=참조
refers.to.entities=엔티티를 참조함
refresh.idea.data.source=IDEA 데이터 소스 새로고침
relation.panel.loadParents=상위 엔티티 로드 중
remove=제거
remove.column.mapping=열 매핑 제거
remove.listener=리스너 제거
removeAnnotation.fix=''@{0}'' 어노테이션 제거.
removeCascadeType.fix=인수 CascadeType.REMOVE 제거
removeLazyForOneToOneAnnotation.fix=인수 FetchType.LAZY 제거
replaceCascadeTypeAll.fix=CascadeType.REMOVE 시를 제외하고 모든 캐스케이드 타입에서 CascadeType.ALL 바꾸기
replaceData.fix=@Data를 안전한 어노테이션과 자동 생성된 equals() 및 hashCode()로 바꾸기
replaceEqualsAndHashCode.fix=@EqualsAndHashCode를 권장되는 equals() 및 hashCode() 구현으로 바꿉니다.
replacePageToList.fix={0}을(를) {1}(으)로 바꾸기
replaceToString.fix=@ToString을 권장되는 toString() 구현으로 바꿉니다.
repositories=저장소
repository.creation.dialog.entity=엔티티
repository.method.overridden=이름이 ''{0}''(으)로 동일한 메서드가 베이스 클래스에서 발견되었습니다. 메서드가 재정의되었습니다.
repository.name=저장소 이름
repository.query.method=저장소 쿼리 메서드
result=결과
return.type=반환 타입
revision.listener=리비전 리스너
revision.number=리비전 번호
revision.repository=리비전 저장소
revision.timestamp=리비전 타임스탬프
run.action=액션 실행
save.entity.indicator=엔티티 ''{0}'' 저장
scan.packages=패키지 스캔
scratch.db.initialization=DB 스키마 초기화
select.any.dto.type=DTO 선택
select.any.entity.attribute.type=엔티티 속성 타입 선택
select.any.entity.view.type=엔티티 보기 타입 선택
select.any.projection.type=프로젝션 타입 선택
select.at.least.one.entity=사용자 지정 범위를 생성하려면 최소 하나의 엔티티를 선택하세요
select.columns.for.id.attribute=기본 키로 사용할 열 선택
select.entities=사용자 지정 범위의 엔티티 선택
select.id.attributes=기본 키 속성 선택
select.id.columns=기본 키 열 선택
select.repository=저장소 선택
select.repository.method.type=저장소 메서드 타입 선택
sequence=시퀀스
sequence.field.required=필드 시퀀스가 필요합니다
serializable=시리얼화 가능
settings=설정
several.auditor.aware.classes.info=<html>AuditorAware 인터페이스의 구현이 다수 감지되었습니다. Spring 감사 구성에 사용된 구현에 대응하는 감사 타입을 선택하세요.</html>
shorten.method.name=메서드 이름 단축
show.basic.attributes=기본 속성 표시
signature=시그니처
snapshot.file.not.exists=스냅샷 파일이 없습니다
snapshot.incorrect.message=DB 스키마 캐시에서 데이터를 읽을 수 없습니다. 새로고침 하거나 꺼 보세요.
snapshot.incorrect.title=스냅샷 읽기 오류
sort.table.unavailable=<b>정렬 기준</b> 테이블을 사용할 수 없습니다. <b>먼저 찾기</b> 옵션을 먼저 선택하세요.
sortable=정렬 가능
source.class=소스 타입
source.root=소스 루트
source.scope=소스 범위
specification=사양
spring.data.repositories=Spring 데이터 저장소
start.text.todo.reverse.engineering=TODO [역공학]
start.text.todo.reverse.engineering.odd=TODO 역공학
success=표준 스크린이 성공적으로 생성되었습니다
table.name=Nombre de la tabla
table.view=테이블/뷰
tables=Tablas
target.class=대상 타입
to.string=toString()
todo.comment=TODO
todo.java.type.render=이 필드는 나중에 생성됩니다
todo.reverse.engineering=//TODO [역공학] DB에서 열 생성
transactional.read.only=Transactional readOnly
type.migration.label={0} ''{1}'' 이동 대상\:
uncomment.as.is=현재 상태대로 주석 해제
unselect.columns=열 선택 해제
unselect.table.has.usages=<html>테이블 <b>{0}</b>에 안전하게 선택 해제될 수 없는 사용위치가 있습니다. <ul>{1}</ul>
up=위로
updatable=업데이트 가능
update.re.mappings=매핑 업데이트
update.re.mappings.message=이름 규칙 및(혹은) 열과 속성 간의 타입 매핑을 변경하였습니다. 새 설정을 지금 적용할까요? 작성한 모든 매핑 설정이 초기화됩니다.
update.values=값 업데이트
update.values.attribute.is.empty='값 업데이트' 테이블에 속성이 비어 있습니다
update.values.is.empty=최소 하나의 업데이트 값을 지정하세요
usages.detected=사용 위치 탐지됨
use.named.parameters=기명 매개변수 사용
use.table.schema=테이블 스키마 사용
used.by=사용자
validation.attributes.and.order.by.empty=쿼리 조건 및 정렬 기준 속성이 비어 있습니다
validation.attributes.empty=쿼리 조건이 비어 있습니다
validation.delete.update.join=메서드는 조건에 관련 엔티티 속성을 포함할 수 없습니다
validation.delete.void.id=Void는 deleteById() 메서드가 사용할 수 있는 유일한 반환 타입입니다.
validation.duplicate.repository.method.name=<html>이름이 같은 ''{0}''이(가) 이미 있습니다.</html>
validation.duplicate.repository.method.name.action=<html><a href\=''\#ADD_IT''>반환 타입 이름을 삽입사로 적용하고 ''{0}''을(를) 메서드 이름으로 사용</a></html>
validation.incorrect.pageable.return.type=페이지가 매겨진 데이터를 반환하는 메서드는 다음 중 하나의 반환 타입을 가져야 합니다. Page<T>,  Slice<T>, List<T>
validation.incorrect.repository.return.type=올바르지 않은 저장소 반환 타입
validation.repository.method.have.pageable.and.sort=메서드가 Pageable이면서 Sortable일 수 없습니다. Pageable의 정렬 기능을 대신 사용하세요.
validation.repository.not.selected=저장소가 선택되지 않았습니다
validation.update.only.basic=메서드가 관련 엔티티 속성을 업데이트할 수 없습니다
value=값
value.type=값 타입
velocity.template=Velocity 플릿
view=Vista
views=보기
wrap.type=래핑 타입
