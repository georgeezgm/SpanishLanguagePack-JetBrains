action.Swift.DumpSwiftFormatConfiguration.commandName=Cree un archivo de configuración SwiftFormat básico
action.Swift.DumpSwiftFormatConfiguration.description=Cree un archivo de configuración '.swift-format' en el directorio del archivo actual
action.Swift.DumpSwiftFormatConfiguration.synonym1=Cree un archivo de configuración básico '.swift-format'
action.Swift.DumpSwiftFormatConfiguration.text=Cree un archivo de configuración SwiftFormat básico
action.Swift.DumpSwiftFormatConfiguration.title=Creando el archivo de configuración predeterminado '.swift-format'
action.Swift.FormatFileWithSwiftFormat.commandName=Reformatear código con SwiftFormat
action.Swift.FormatFileWithSwiftFormat.description=Reformatear código con SwiftFormat
action.Swift.FormatFileWithSwiftFormat.synonym1=Formatear código con SwiftFormat
action.Swift.FormatFileWithSwiftFormat.text=Formatear código con SwiftFormat
action.Swift.FormatFileWithSwiftFormat.title=Formatear {0} con SwiftFormat
action.Swift.Generate.DebugDescription.description=Generar descripción de depuración
action.Swift.Generate.DebugDescription.text=Descripción de depuración...
action.Swift.Generate.Description.description=Crear descripción
action.Swift.Generate.Description.text=Explicación...
action.Swift.Generate.EqualsHashValue.description=Igualdad y generación de hash
action.Swift.Generate.EqualsHashValue.text=Es igual a hash
action.Swift.Generate.Init.description=Crear un inicializador
action.Swift.Generate.Init.text=Inicializador
action.Swift.NewFile.description=Cree un nuevo archivo Swift o escriba
action.Swift.NewFile.text=Archivo/tipo Swift
action.Swift.ShowSwiftIDETest.text=Ejecutar un informe en Swift IDE
action.SwiftExtractFunction.text=Función de extracción...
action.SwiftGenerateDocComment.text=Crear comentarios de documentos
action.SwiftIntroduceClosureVariable.text=Cierre...
action.SwiftToggleErrorHints.text=Mostrar sugerencia de error
action.SwiftToggleGlobalErrorHints.text=Mostrar sugerencias de error de Swift
action.SwiftToggleGlobalTypeHints.text=Mostrar sugerencias de tipo Swift
action.SwiftToggleTypeHints.text=Mostrar sugerencias de tipo
auto.import.command.name=Módulos de importación automática
auto.import.completion.presentation.tail.from.0=({0})
auto.import.settings.checkbox.sort=Importar Ordenar
auto.import.settings.import.symbol=Importar automáticamente símbolos específicos
auto.import.settings.import.symbol.help=Al importar símbolos automáticamente, prefiero agregar una importación del símbolo en sí en lugar de importar todo el módulo que declara el símbolo.
auto.import.settings.optimize.non.module=Optimización de importación sin módulo
auto.import.settings.optimize.non.module.help=Al optimizar las importaciones, reemplace funciones, estructuras, clases y otras importaciones explícitas con importaciones del módulo principal.
call.hierarchy.usage.in=Dónde utilizar
change.info.async.throws.label=Asíncrono/Lanzar:
change.info.default.value.code.comment=Por defecto \={0}
change.info.default.value.label=Valor por defecto\:
change.info.dialog.invalid.function.name.0=Nombre de función no válido\: ''{0}''
change.info.dialog.invalid.parameter.internal.name.0=Nombre interno del parámetro no válido\: ''{0}''
change.info.dialog.invalid.parameter.name.0=Nombre de parámetro no válido\: ''{0}''
change.info.dialog.no.function.name.specified=Nombre de función no especificado
change.info.dialog.parameter.after.variadic.should.have.nonempty.name=Los parámetros que siguen a un parámetro variable deben tener un nombre que no esté en blanco
change.info.dialog.rethrows.should.have.throwing.parameter=La función ''relanzamientos'' debe tomar un parámetro de función de lanzamiento
change.info.internal.name.label=Nombre interno\:
change.info.name.label=Nombre\:
change.info.optional.label=Opcional\:
change.info.options.label=Opción
change.info.return.type.label=Tipo de retorno\:
change.info.type.label=Categoría\:
change.signature.0.1.will.no.longer.be.visible.from.overriding.0.in.2.3={0} ''{1}'' ya no aparece en {0} anulación de {2} ''{3}''
change.signature.0.1.with.2.visibility.wont.be.accessible.from.3.4={0} ''{1}'' con visibilidad {2} no es accesible desde {3} ''{4}''
change.signature.0.can.throw.but.thrown.errors.are.not.handled=''{0}'' se puede generar, pero el error generado no se manejará
change.signature.0.is.async.but.not.awaited=''{0}'' espera una llamada pero no está marcado como asíncrono
change.signature.dialog.title=Cambio de firma
change.signature.initializer.will.conflict.with.0.in.1.2=El inicializador entra en conflicto con {0} en {1} ''{2}''
change.signature.processed.elements.header=Elemento cuya firma desea cambiar
change.signature.subscript.will.conflict.with.0.in.1.2=El subíndice entra en conflicto con {0} en {1} ''{2}''
change.signature.target.not.found=El cursor debe colocarse en una función, inicializador o subíndice.
change.signature.title=Cambio de firma
code.style.blank.lines.around.class=Alrededor de la declaración de tipo\:
code.style.blank.lines.around.field=Alrededor de la propiedad\:
code.style.blank.lines.around.field.in.protocol=Alrededor de propiedades dentro del protocolo\:
code.style.blank.lines.around.method=Alrededor del método/función\:
code.style.blank.lines.around.method.in.protocol=Alrededor de métodos/funciones dentro del protocolo\:
code.style.blank.lines.before.method.body=Antes del cuerpo del método/función\:
code.style.code.generation.doc.comment.style=Prefiera comentarios de bloque (/** */) a comentarios de documentación de línea (///).
code.style.code.generation.doc.comment.tag.delimiter=Separador de elementos de lista:
code.style.code.generation.prefer.explicit.return=Prefiero devolución explícita
code.style.code.generation.prefer.void=Prefiero anular a ()
code.style.code.generation.tab.title=Codigo de GENERACION
code.style.indent.directives.as.code=Cumplir con la sangría del código
code.style.indent.directives.children=Subelementos de sangría
code.style.indent.group.title.directives=Directiva
code.style.indent.method.chain=Sangría del método de cadena:
code.style.indent.multiline.string.or.regex=Sangrar cadenas de varias líneas o expresiones regulares
code.style.spaces.after.argument.colon=Después de dos puntos dentro de la llamada a método/función
code.style.spaces.after.dictionary.literal.colon=Después de los dos puntos dentro del par literal ''clave\:valor'' del diccionario
code.style.spaces.after.dictionary.type.colon=Después de dos puntos dentro del tipo de diccionario
code.style.spaces.after.operator.in.function.declarations=Operadores en declaraciones de funciones
code.style.spaces.after.semicolon=Después del punto y coma
code.style.spaces.after.superclass.colon=Después de dos puntos en la cláusula de herencia de tipo
code.style.spaces.after.type.colon=Después de los dos puntos en la anotación de tipo
code.style.spaces.around.range.operators=Operadores de rango (..., ..<)
code.style.spaces.attribute.parameters=Parámetros de atributos
code.style.spaces.attribute.parentheses=Paréntesis de atributos
code.style.spaces.before.argument.colon=Antes de dos puntos dentro de la llamada a método/función
code.style.spaces.before.class.lbrace=La declaración de tipo está entre llaves izquierdas
code.style.spaces.before.dictionary.literal.colon=Antes de dos puntos dentro del par literal ''clave\:valor'' del diccionario
code.style.spaces.before.dictionary.type.colon=Antes de dos puntos dentro del tipo de diccionario
code.style.spaces.before.method.call.parentheses=Paréntesis de llamada a método/función
code.style.spaces.before.method.lbrace=Método/función llave izquierda
code.style.spaces.before.method.parentheses=Paréntesis de declaración de método/función
code.style.spaces.before.semicolon=Antes del punto y coma
code.style.spaces.before.superclass.colon=Antes de dos puntos en la cláusula de herencia de tipo
code.style.spaces.before.type.colon=Antes de los dos puntos en la anotación de tipo
code.style.spaces.closure.arrow=Flecha de cierre (->)
code.style.spaces.equality.operator=Operador de igualdad ''\=\=''
code.style.spaces.group.title.colon=Alrededor del colon
code.style.spaces.group.title.in.ternary=Dentro de operaciones condicionales ternarias
code.style.spaces.shift.operators=Operadores de turno (<<, >>)
code.style.spaces.within.empty.method.call.parentheses=Paréntesis de llamada de método/función vacíos
code.style.spaces.within.empty.method.parentheses=Paréntesis de declaración de método/función vacíos
code.style.spaces.within.literal.brackets=Corchetes literales de matriz y diccionario
code.style.spaces.within.method.call.parentheses=Paréntesis de llamada a método/función
code.style.spaces.within.method.parentheses=Paréntesis de declaración de método/función
code.style.spaces.within.string.interpolations=Interpolación de cadenas
code.style.wrapping.align.in.columns=Ordenar por columna
code.style.wrapping.align.when.multiline=Ordenar si hay varias líneas
code.style.wrapping.array.literal=Matrices y literales de diccionario
code.style.wrapping.array.new.line.after.left.bracket=Nueva línea después de ''[''
code.style.wrapping.array.right.bracket.on.new.line=Coloque '']'' en una nueva línea
code.style.wrapping.brace.placement.class.declaration=Dentro de la declaración de tipo
code.style.wrapping.classes.annotation=Propiedades de declaración de tipo
code.style.wrapping.closure.signature.on.next.line=Si hay varias líneas, coloque los parámetros en una nueva línea.
code.style.wrapping.fields.annotation=Atributo de propiedad
code.style.wrapping.group.title.closure=Cierre
code.style.wrapping.group.title.condition.clauses=Cláusula condicional
code.style.wrapping.group.title.do.while=''repetir... mientras'' declaración
code.style.wrapping.group.title.guard=Declaración de ''guardia''
code.style.wrapping.group.title.if=Declaración ''si''
code.style.wrapping.group.title.method.arguments=Argumentos de llamada a método/función
code.style.wrapping.group.title.method.parameters=Parámetros de declaración de método/función
code.style.wrapping.group.title.superclass.list=Lista de clases base y protocolos adoptados.
code.style.wrapping.group.title.ternary=Operaciones condicionales ternarias
code.style.wrapping.group.title.try=Declaración ''hacer''
code.style.wrapping.group.title.variable.groups=Grupo de variables
code.style.wrapping.guard.else=Else
code.style.wrapping.guard.else.always=Siempre salto de línea
code.style.wrapping.guard.else.never=Sin envolver
code.style.wrapping.guard.else.wrapped=Envolver con condiciones
code.style.wrapping.keep.control.statement.in.one.line=Declaraciones de control en una línea
code.style.wrapping.keep.simple.argument.blocks.in.one.line=Coloque los argumentos de cierre en una línea
code.style.wrapping.keep.simple.blocks.in.one.line=Bloques y cierres (finales) en una línea
code.style.wrapping.keep.simple.methods.in.one.line=Métodos y funciones en una línea.
code.style.wrapping.local.variables.annotation=Propiedades de variables locales
code.style.wrapping.method.brace.placement=Dentro de métodos y funciones
code.style.wrapping.method.chain.dot.on.new.line='.' en una nueva línea.
code.style.wrapping.methods.annotation=Propiedades del método
code.style.wrapping.parameters.annotation=Propiedades de los parámetros
code.style.wrapping.structures.in.one.line=Declaración de tipo vacía en una línea
color.conditionally.not.compiled=Código no compilado con palabras clave y directivas//condiciones
color.settings.actor=Tipo//actor
color.settings.anonymous.closure.parameter=Identificador // parámetro de cierre anónimo
color.settings.argument.label=Identificador//etiqueta de argumento
color.settings.associated.type=Tipo//Tipo relacionado
color.settings.attribute.argument=Propiedades//argumentos de propiedad
color.settings.attribute.name=Propiedades//nombre de la propiedad
color.settings.class=Tipo//clase
color.settings.colon=Paréntesis y operadores//dos puntos
color.settings.directive=Palabras clave y directivas//Directivas
color.settings.directive.condition=Palabras clave y directivas//Condiciones de la directiva
color.settings.directive.flag=Palabras clave y directivas//Marcas de directivas
color.settings.enum.case.value=Identificador//Valor de caso de enumeración
color.settings.external.parameter.name=Identificador//Nombre del parámetro externo
color.settings.function.and.method.call=Funciones//Llamadas a funciones y métodos
color.settings.function.and.method.declaration=Funciones//Declaración de funciones y métodos
color.settings.inline.closure.parameter=Identificador // parámetro de cierre en línea
color.settings.inline.hints.error.hint=Sugerencia en línea//Sugerencia de error
color.settings.inline.hints.type.hint=Sugerencias en línea // sugerencias de tipo
color.settings.keyword=Palabras clave y directivas//Palabras clave
color.settings.module.name=Tipo // nombre del módulo
color.settings.nested.function.call=Función // Llamadas a funciones anidadas
color.settings.nested.function.declaration=Función // Declaración de función anidada
color.settings.operator.sign=Paréntesis y operadores//Símbolos de operador
color.settings.property=Identificador//Propiedad
color.settings.protocol=Tipo//protocolo
color.settings.self.and.super.keywords=Palabras clave y directivas // Palabras clave ''self'' y ''super''
color.settings.struct.and.enum=Tipos//Estructuras y Enumeraciones
color.settings.tuple.label=Identificador//etiqueta de tupla
color.settings.tuple.type.label=Identificador//Etiqueta de tipo tupla
color.settings.type.alias=Tipo // escriba alias
color.settings.type.parameter=Tipo // parámetro genérico
color.settings.wildcard=Identificador//Comodín
command.name.extract.function=Extracción de funciones
context.declaration=Declaración
context.statement=Construcción
create.file.action=Crear archivo Swift {0}
create.file.description=Crea un nuevo archivo Swift.
create.file.dialog.title=Nuevo archivo Swift
create.file.kind=Tipo(&K)\:
create.file.kind.file=Archivo
create.file.title=Archivo rápido
create.file.type.description=Crea un nuevo tipo Swift.
create.file.type.dialog.title=Nuevos tipos de Swift
create.file.type.dialog.title.with.kind=Nuevo Swift {0}
create.file.type.title=Tipos veloces
create.from.usage.choose.target.type=Seleccione el tipo de destino
create.from.usage.create.function.command=Crear una función en el punto de uso.
create.from.usage.create.init.command=Cree un inicializador en su ubicación
create.from.usage.create.type.command=Crea un nuevo tipo Swift
create.from.usage.create.variable.command=Crear variable en el punto de uso
create.from.usage.location.in={0} mi
create.from.usage.location.new.file=Archivo nuevo
create.from.usage.location.this.file=Este archivo
doc.comments.enable.markdown=Para formatear claramente los comentarios de su documento, active el complemento Markdown
editor.appearance.error.hints=Mostrar sugerencias de error de Swift
editor.appearance.type.hints=Mostrar sugerencias de tipo Swift
error.cannot.perform.refactoring=No se puede realizar la refactorización
error.no.expression.found=Expresión no encontrada
extract.method.0.1.will.be.shadowed.by.2.1={0} ''{1}'' está sombreado por {2} ''{1}''.
extract.method.at.least.two.parameters.have.name.0=Hay más de dos parámetros con el nombre ''{0}''.
extract.method.cannot.extract.mutable.value=Los valores de las variables no se pueden extraer.
extract.method.error.cannot.determine.expr.type=No se puede determinar el tipo de expresión seleccionada.
extract.method.error.cannot.determine.function.result.type=No se puede determinar el tipo de resultado de la función.
extract.method.error.cannot.determine.parameters.type=No se puede determinar el tipo de parámetro.
extract.method.error.cannot.extract.expr.with.var.declarations=No se puede extraer de una expresión con declaración de variable.
extract.method.error.cannot.extract.with.returns=No se puede extraer un método con una instrucción de retorno dentro de un fragmento de código.
extract.method.error.fragment.should.be.inside.code.block=El fragmento de código seleccionado debe estar dentro de un bloque de código.
extract.method.error.multiple.exit.points=El fragmento de código seleccionado tiene múltiples puntos de salida.
extract.method.error.result.builder.block=No se puede extraer la función del cierre del generador de resultados
extract.method.error.should.represent.expr.or.statements=El bloque seleccionado debe representar una declaración o colección de expresiones.
extract.method.function.0.will.conflict.with.1.2=La función ''{0}'' entra en conflicto con {1} {2}.
extract.method.method.0.will.conflict.with.1.in.2.3=El método ''{0}'' entra en conflicto con {1} en {2} ''{3}''.
extract.method.title.closure=Extracción de cierre
extract.method.title.function=Extracción de funciones
extract.method.title.method=Extracción del método
extract.method.variable.0.will.no.longer.be.accessible=Ya no se puede acceder a la variable ''{0}'' después de la refactorización
find.usages.base.member.warning.message.default.implementation.method={0} es la implementación predeterminada del método declarado en {1}\n\n¿Le gustaría buscar el uso del protocolo {3,choice,1\#method|2\#method}?
find.usages.base.member.warning.message.default.implementation.property={0} es la implementación predeterminada de la propiedad declarada en {1}\n\n¿Le gustaría buscar ubicaciones de uso del protocolo {3,choice,1\#property|2\#property}?
find.usages.base.member.warning.message.default.implementation.subscript={0} es la implementación predeterminada del subíndice declarado en {1}\n\n¿Le gustaría buscar el uso del protocolo {3,choice,1\#subscript|2\#subscript}?
find.usages.base.member.warning.message.implements.method={0} implementa el método declarado en {1}\n\n¿Le gustaría buscar el uso del protocolo {3,choice,1\#method|2\#method}?
find.usages.base.member.warning.message.implements.property={0} implementa las propiedades declaradas en {1}\n\n¿Le gustaría buscar el uso del protocolo {3,choice,1\#property|2\#property}?
find.usages.base.member.warning.message.implements.subscript={0} implementa el subíndice declarado en {1}\n\n¿Le gustaría buscar el uso del protocolo {3,choice,1\#subscript|2\#subscript}?
find.usages.base.member.warning.message.override.implemented.method={0} anula el método declarado en {2} e implementa el método declarado en {1}\n\nUso de valores predeterminados y protocolos {3,choice,1\#method|2\#method} ¿Le gustaría buscar un ¿ubicación?
find.usages.base.member.warning.message.override.implemented.property={0} anula la propiedad declarada en {2} e implementa la propiedad declarada en {1}\n\nUso del protocolo y predeterminado {3,choice,1\#property|2\#property} ¿Le gustaría buscar una ¿ubicación?
find.usages.base.member.warning.message.override.implemented.subscript={0} anula el subíndice declarado en {2} e implementa el subíndice declarado en {1}\n\nValor predeterminado y protocolo {3,choice,1\#subscript|2\#sub ¿Le gustaría buscar el uso de {script? }?
find.usages.base.member.warning.message.override.method={0} anula un método declarado en {2}\n\n¿Le gustaría buscar el uso del {3,choice,1\#method|2\#method} predeterminado?
find.usages.base.member.warning.message.override.property={0} anula una propiedad declarada en {2}\n\n¿Le gustaría buscar el uso de la {3,choice,1\#property|2\#property} predeterminada?
find.usages.base.member.warning.message.override.subscript={0} anula el subíndice declarado en {2}\n\n¿Le gustaría buscar el uso del {3,choice,1\#subscript|2\#subscript} predeterminado?
find.usages.base.member.warning.title=Advertencia
find.usages.option.search.in.not.compiled.code=Marca condicionalmente usos potenciales dentro del código no compilado
generate.0.title=Crear {0}
generate.cannot.generate.0.for.1=No se puede generar {0} para {1}.
generate.description.multi.string.template=Cadena de varias líneas
generate.description.single.string.template=Sola cuerda
generate.description.string.concatenation.template=Varias cadenas con concatenación (+)
generate.equals.hash=Es igual a hash
generate.equals.hash.choose.in.0=Seleccione propiedades para incluir en {0}
generate.if.statements.equals.template=Múltiples declaraciones if
generate.init.choose.properties=Seleccione propiedades para inicializar
generate.init.choose.super.init=Seleccionar inicializador de clase principal
generate.init.init.already.exists=El inicializador ya existe.
generate.method.0.and.operator.function.1.are.already.defined=El método ''{0}'' y la función del operador ''{1}'' ya están definidos. ¿Le gustaría eliminar esos métodos y funciones y continuar?
generate.method.0.and.property.1.are.already.defined=El método ''{0}'' y la propiedad ''{1}'' ya están definidos. ¿Le gustaría eliminar el método y la propiedad y continuar?
generate.method.0.is.already.defined=El método ''{0}'' ya está definido. ¿Le gustaría eliminar el método y continuar?
generate.method.0.property.1.and.operator.function.2.are.already.defined=El método ''{0}'', la propiedad ''{1}'' y la función del operador ''{2}'' ya están definidos. método correspondiente. ¿Quieres eliminar propiedades y funciones y continuar?
generate.operator.function.0.is.already.defined=La función del operador ''{0}'' ya está definida. ¿Le gustaría eliminar la función y continuar?
generate.preparing.generation.title=Preparándonos para crear...
generate.property.0.and.operator.function.1.are.already.defined=La propiedad ''{0}'' y la función del operador ''{1}'' ya están definidas. ¿Le gustaría eliminar estas propiedades y funciones y continuar?
generate.property.0.is.already.defined=La propiedad ''{0}'' ya está definida. ¿Le gustaría eliminar esta propiedad y continuar?
generate.single.expression.equals.template=Expresión única
generate.template.title=Plan&tilla\:
got.it.no.refactoring.in.not.compiled.code.header=La acción de refactorización no está disponible
got.it.no.refactoring.in.not.compiled.code.message=Las acciones de refactorización no se pueden utilizar en código que no esté compilado condicionalmente. Cambie a un contexto de resolución diferente y active la rama circundante 'directiva #if'.
got.it.search.not.compiled.code.header=Dónde usarlo dentro del código que no está compilado condicionalmente
got.it.search.not.compiled.code.message=La búsqueda condicional de usos en código no compilado se puede habilitar en el cuadro de diálogo Cambiar nombre. Presione {0} nuevamente para mostrar el cuadro de diálogo de cambio de nombre.
goto.base.type=Tipo básico
goto.class.kind=Tipo
goto.class.kinds.title=Tipo
goto.super.action=Seleccione {0}
goto.super.class=Clase o protocolo
goto.super.extension.of.0={0} expansión
goto.super.location={1} mi {0}
goto.super.menu.action=Padre {0}(_U)
goto.super.typealias=Alias de tipo o tipo relacionado
inheritance.relation.implements={0} implementación
inheritance.relation.is.implemented=Implementado
inheritance.relation.is.overridden=Anulado
inheritance.relation.is.subclassed=Se convierte en una subclase
inheritance.relation.overrides={0} cancelar
inline.0.action.1={0} {1} en línea
inline.0.command.1={0} {1} en línea
inline.all.invocations.and.keep.the.0=Insertar todo en línea y mantener {0}
inline.all.invocations.and.remove.the.0=Insertar todo y eliminar {0}
inline.all.references.and.keep.the.0=Insertar todo en línea y mantener {0}
inline.all.references.and.remove.the.0=Insertar todo y eliminar {0}
inline.all.typealias.and.keep.the.0=Insertar todo en línea y mantener {0}
inline.all.typealias.and.remove.the.0=Insertar todo y eliminar {0}
inline.error.cannot.access.symbol.0=El símbolo {0} no es accesible
inline.error.cannot.resolve.symbol=No se pudo resolver el símbolo
inline.error.function.definition.contains.no.body=La definición de función no tiene cuerpo.
inline.error.function.no.return.statement=No hay declaración de devolución en la función.
inline.error.implements.function.from.0=El método incorporado implementa el método en {0}
inline.error.inline.function.has.conditionally.compiled.code=La función no está insertada correctamente porque contiene código que condicionalmente no se compila.
inline.error.inline.function.only.in.swift.code=La inserción de funciones solo se admite en código Swift
inline.error.inline.recursive.function.only.on.invocations=La incorporación de funciones recursivas solo se admite en llamadas
inline.error.inline.typealias.has.conditionally.compiled.code=Los alias de tipo no están correctamente insertados porque contienen código que no se compila condicionalmente
inline.error.inline.variable.has.conditionally.compiled.code=Las variables no están insertadas correctamente porque contienen código que no se compila condicionalmente
inline.error.inline.variable.no.single.definition=No se pudo encontrar una única definición para insertar
inline.error.inlined.expression.should.be.part.of.statement=Las expresiones insertadas deben ser parte de la sintaxis.
inline.error.invalid.function.arguments=Argumento de función no válido
inline.error.is.overridden.by.function.from.0=El método en línea es anulado por el método en {0}
inline.error.not.function.call=No es una llamada de función
inline.error.overrides.associated.type.from.0=El alias de tipo incorporado anula el tipo asociado de {0}
inline.error.overrides.function.from.0=El método incorporado anula el método en {0}
inline.error.unexpected.error=Error inesperado durante la inserción
inline.function.description=Reemplazo de llamadas a funciones con cuerpo
inline.function.label.kind.0.name.1=En línea {0} {1}:
inline.function.label.kind.0.name.1.2.occurrences={0} Llamada en línea {2} en {1}:
inline.function.label.kind.0.name.1.occurence=Insertar la llamada {0} {1}:
inline.include.doc.comments=Se aplica a los comentarios del documento.
inline.recursively=En línea recursiva
inline.this.invocation.only.and.keep.the.0=Solo en línea esta llamada y mantén {0}
inline.this.reference.only.and.keep.the.0=Insertar solo esta referencia y mantener {0}
inline.this.typealias.only.and.keep.the.0=Solo este uso en línea, pero mantén {0}
inline.title.0={0} en línea
inline.typealias.label.kind.0.name.1=En línea {0} {1}:
inline.typealias.label.kind.0.name.1.2.occurrences={0}Usos {2} en línea de {1}
inline.typealias.label.kind.0.name.1.occurence=Incorporar el uso de {0} {1}:
inline.variable.label.kind.0.name.1=En línea {0} {1}:
inline.variable.label.kind.0.name.1.2.occurrences={0} llamada en línea {2} en {1}
inline.variable.label.kind.0.name.1.occurence={0} llamada en línea de {1}
inspection.conditionally.not.compiled.code=Código no compilado con condiciones.
inspection.missing.doc.comment.parameter.item=Comentarios de documentación y firmas de funciones no coincidentes
inspection.missing.doc.comment.parameter.item.error=El parámetro {0} no se describe en los comentarios de la documentación.
inspection.missing.doc.comment.parameter.item.fix=Actualizar comentarios de documentación
inspection.missing.localization=Falta el idioma de localización
inspection.missing.localization.all.languages.only=Informar solo las localizaciones que faltan en todos los idiomas
inspection.redundant.attribute=Atributo duplicado
inspection.redundant.attribute.error=La propiedad @{0} está duplicada.
inspection.redundant.attribute.fix=Eliminar atributo duplicado @{0}
inspection.redundant.closure=Cierre innecesario
inspection.redundant.closure.error=Creando cierres innecesarios
inspection.redundant.closure.fix=En línea el texto
inspection.redundant.nullable.function.type.error=''{0}'' siempre devuelve un tipo no nulo
inspection.redundant.nullable.type=Tipos duplicados que aceptan valores NULL
inspection.redundant.nullable.type.error=''{0}'' es siempre un tipo no nulo
inspection.redundant.nullable.type.fix=Eliminar duplicado '?'
inspection.redundant.return=Declaración duplicada
inspection.redundant.return.error=Duplicado ''regreso''.
inspection.redundant.return.fix=Elimine el ''retorno'' redundante.
inspection.unnecessary.argument.list=Lista de argumentos innecesarios
inspection.unnecessary.argument.list.error=La lista de argumentos es innecesaria
inspection.unnecessary.argument.list.fix=Eliminar lista de argumentos innecesarios
inspection.unnecessary.parentheses=Paréntesis innecesarios
inspection.unnecessary.parentheses.error=Los paréntesis son innecesarios.
inspection.unnecessary.parentheses.fix=Elimine los paréntesis innecesarios.
inspection.unnecessary.self=Yo innecesario
inspection.unnecessary.self.error="yo" es innecesario
inspection.unnecessary.self.fix=Eliminar el "yo" innecesario
inspection.unnecessary.tuple.wrap=Alrededor de tuplas innecesarias
inspection.unnecessary.tuple.wrap.error=Las tuplas de un solo elemento se pueden convertir en tipos.
inspection.unnecessary.tuple.wrap.fix=Convertir tupla de un solo elemento a tipo
intention.access.control.error.access=No se puede acceder a {0}. Los elementos son del {1} al {2}.
intention.access.control.error.access.dynamic=No se puede acceder a {0}. Los subíndices de miembros dinámicos son del {1} al {2}.
intention.access.control.error.override={0} no se puede redefinir. Los elementos son del {1} al {2}.
intention.access.control.fix=Crear {0} {1} en {2}
intention.access.control.remove.setter=Eliminar {1} de {0}
intention.add.catch.clause=Añadir cláusula ''catch''
intention.add.default.catch.clause=Agregar cláusula ''catch'' predeterminada
intention.add.digit.separators=Agregar separador de números
intention.add.explicit.qualifier=Agregar calificador explícito
intention.add.explicit.type=Agregar tipos explícitos
intention.add.try.to.expression=Añadir ''try''
intention.add.try.to.iteration=Agregue 'intentar' a la iteración
intention.category.swift=Rápido
intention.convert.to.binary=Convertir a número binario
intention.convert.to.closure.argument=Convertir a argumento de cierre
intention.convert.to.decimal=Convertir a decimal
intention.convert.to.hex=Convertir a hexadecimal
intention.convert.to.multiline.string=Convertir a literal de cadena multilínea
intention.convert.to.octal=Convertir a octal
intention.convert.to.string=Convertir a literal de cadena de una línea
intention.convert.to.trailing.closure=Convertir a cierre final
intention.create.actor.0=Crear actor ''{0}''
intention.create.actor.0.in.new.file=Crear actor ''{0}'' en un archivo nuevo
intention.create.actor.0.nested.in.1=Crear actor anidado ''{0}'' en ''{1}''
intention.create.class.0=Crear clase ''{0}''
intention.create.class.0.in.new.file=Crear clase ''{0}'' en un archivo nuevo
intention.create.class.0.nested.in.1=Crear clase anidada ''{0}'' en ''{1}''
intention.create.enum.0=Crear enumeración ''{0}''
intention.create.enum.0.in.new.file=Crear enumeración ''{0}'' en un archivo nuevo
intention.create.enum.0.nested.in.1=Crear enumeración anidada ''{0}'' en ''{1}''
intention.create.enum.case.0=Crear caso de enumeración ''{0}''
intention.create.global.function.0=Crear función global ''{0}''
intention.create.global.variable.0=Crear variable global ''{0}''
intention.create.initializer=Crear un inicializador
intention.create.local.variable.0=Crear variable local ''{0}''
intention.create.method.0=Crear método ''{0}''
intention.create.method.0.in.extension=Crear método de extensión ''{0}''
intention.create.new.swift.declaration=Crear una nueva declaración Swift
intention.create.new.swift.type.in.a.new.file=Nuevo tipo Swift dentro de un archivo nuevo
intention.create.property.0=Crear propiedad ''{0}''
intention.create.property.0.in.extension=Crear propiedad extendida ''{0}''
intention.create.protocol.0=Crear protocolo ''{0}''
intention.create.protocol.0.in.new.file=Crear protocolo ''{0}'' en un archivo nuevo
intention.create.protocol.0.nested.in.1=Crear protocolo anidado ''{0}'' en ''{1}''
intention.create.struct.0=Crear estructura ''{0}''
intention.create.struct.0.in.new.file=Crear estructura ''{0}'' en un archivo nuevo
intention.create.struct.0.nested.in.1=Crear estructura anidada ''{0}'' en ''{1}''
intention.create.type.0=Crear tipo ''{0}''
intention.create.type.0.in.new.file=Crear tipo ''{0}'' en un archivo nuevo
intention.create.type.0.nested.in.1=Crear tipo anidado ''{0}'' en ''{1}''
intention.create.type.method.0=Crear método de tipo ''{0}''
intention.create.type.method.0.in.extension=Crear método de tipo de extensión ''{0}''
intention.create.type.property.0=Crear propiedad de tipo ''{0}''
intention.create.type.property.0.in.extension=Crear propiedad de tipo de extensión ''{0}''
intention.decrease.string.escape.level=Nivel de escape de cuerda inferior
intention.demorgans.law=Ley de demorgan
intention.demorgans.law.format=Reemplace ''{0}'' con ''{1}''
intention.extract.class.0.to.extension=Extraer la clase ''{0}'' como extensión
intention.extract.class.0.to.type.declaration=Extraer la clase ''{0}'' como declaración de tipo
intention.extract.conformance.to.extension.cannot.add.protocol.conformance.to.protocol=Las extensiones de protocolo no pueden seguir otros protocolos
intention.extract.conformance.to.extension.cannot.extract.class=La herencia de clases ''{0}'' no se puede extraer como una extensión
intention.extract.conformance.to.extension.familyName=Fitness cuando se extrae por expansión.
intention.extract.conformance.to.extension.type.cannot.be.local=No se puede crear una extensión en el ámbito regional
intention.extract.conformance.to.extension.type.must.be.fileprivate=El tipo debe ser al menos fileprivate
intention.extract.enum.0.to.extension=Extraer la enumeración ''{0}'' como extensión
intention.extract.enum.0.to.type.declaration=Extraer la enumeración ''{0}'' como declaración de tipo
intention.extract.from.extension.to.type.declaration.error.message.title=Extraer miembros a la declaración de tipo original
intention.extract.from.extension.to.type.declaration.familyName=Extraer miembros a la declaración de tipo original
intention.extract.from.extension.to.type.declaration.original.analysis.on.type.not.allowed=Original type declaration is out of scope
intention.extract.from.extension.to.type.declaration.original.type.not.found=Declaración de tipo original no encontrada
intention.extract.function.0.to.extension=Extraer la función ''{0}'' como extensión
intention.extract.function.0.to.type.declaration=Extraer la función ''{0}'' como declaración de tipo
intention.extract.initializer.to.extension=Extraer inicializadores como extensiones
intention.extract.initializer.to.type.declaration=Extraer inicializadores en declaraciones de tipo
intention.extract.member.to.extension.cannot.extract.from.protocol=No se puede extraer del protocolo
intention.extract.member.to.extension.type.cannot.be.local=No se puede crear una extensión en el ámbito regional
intention.extract.member.to.extension.type.must.be.fileprivate=El tipo debe ser al menos fileprivate
intention.extract.members.to.extension.error.message.title=Extraer miembros como extensiones
intention.extract.members.to.extension.familyName=Extraer miembros como extensiones
intention.extract.multiple.members.to.extension=Extraer miembros como extensiones
intention.extract.multiple.members.to.type.declaration=Extraer miembros en declaraciones de tipo
intention.extract.property.0.to.extension=Extraer la propiedad ''{0}'' como extensión
intention.extract.property.0.to.type.declaration=Extraer la propiedad ''{0}'' como declaración de tipo
intention.extract.struct.0.to.extension=Extraer la estructura ''{0}'' como extensión
intention.extract.struct.0.to.type.declaration=Extraiga la estructura ''{0}'' como declaración de tipo
intention.extract.subscript.to.extension=Extraer subíndices como extensiones
intention.extract.subscript.to.type.declaration=Extraer subíndices en declaraciones de tipo
intention.extract.typealias.0.to.extension=Extraer alias de tipo como extensiones
intention.extract.typealias.0.to.type.declaration=Extraiga el alias de tipo ''{0}'' en la declaración de tipo
intention.flip.binary.expression=Invertir expresión binaria
intention.flip.binary.expression.format=Invertir ''{0}''
intention.flip.comparison=Invertir comparación.
intention.flip.comparison.format=Invertir ''{0}'' a ''{1}''
intention.generate.documentation.comment=Agregar comentarios al documento
intention.implement.equals=Implementando ecuaciones faltantes
intention.implement.hash=Falta implementación de hash
intention.implement.members.error=El tipo {0} no se ajusta a {1}.
intention.implement.members.implement.missing={0} Implementación de {0,choice,1\#member|2\#member} faltante
intention.implement.missing.equals.hash=Falta ecuación e implementación de hash
intention.increase.string.escape.level=Aumentar el nivel de escape de la cuerda
intention.invert.if.statement=Frase inversa si
intention.join.declaration.and.assignment=Combinando declaración y cesión
intention.localize.string=Localización de cadenas
intention.localize.string.title.case=Localización de cadenas
intention.mark.the.enclosing.function.as.throws=Agregue ''lanzamientos'' a la firma de función
intention.merge.conditions=Condiciones de fusión
intention.merge.else.if=Fusionar declaraciones else if
intention.merge.nested.if=Fusionar declaraciones if anidadas
intention.negate.comparison=Negar comparación
intention.negate.comparison.format=Negar ''{0}'' como ''{1}''
intention.remove.digit.separators=Quitar separador de números
intention.remove.explicit.type=Eliminar tipos explícitos
intention.replace.guard.with.if=Reemplace ''guardia'' con ''si''
intention.replace.if.with.guard=Reemplace ''si'' con ''guardia''
intention.replace.rethrows.with.throws=Cambiar ''relanzamientos'' por ''lanzamientos''
intention.simplifyifelse.collapse.conditional.expression=Contraer expresiones condicionales
intention.simplifyifelse.collapse.guard=Colapso 'guardia'
intention.simplifyifelse.collapse.ifelse=Contraer "si no"
intention.simplifyifelse.familyName=Simplifica si no
intention.simplifyifelse.replace.guard.with.0=Reemplace ''guardia'' por ''{0}''
intention.simplifyifelse.replace.if.else.with.0=Reemplace ''si otra cosa'' con ''{0}''
intention.simplifyifelse.simplify=Arrasamiento
intention.simplifyifelse.simplify.guard=Simplificar 'guardia'
intention.simplifyifelse.simplify.if.else=Simplificando 'si no'
intention.split.condition=Dividido en condiciones individuales
intention.split.declaration.and.assignment=División de declaraciones y asignaciones
intention.split.else.if=Dividir otra declaración si
intention.split.into.separate.declarations=Dividido en declaraciones individuales.
intention.split.nested.if=Dividir en condiciones anidadas
intention.suppress.call.error.with.try=Suprime errores con ''try\!''
intention.surround.with.do.catch=Rodear con ''hacer/atrapar''
intention.swift.module.info=Mostrar información del módulo
intention.switch.resolve.configuration.specified=Cambie a ''{0}'' para activar esta rama
intention.unresolved.reference.0.1={0} importar ''{1}''
intention.unwrap.with.guard.let=Desenvolver opcional con 'guard let'
intention.unwrap.with.if.let=Desenvolver opcional con 'if let'
intention.wrong.return.type.fix=Establezca ''{0}'' para devolver ''{1}''
intention.wrong.return.type.fix.with.types=Hacer que ''{0}'' devuelva ''{1}''
introduce.variable.declare.with.var=&Declarar con var
introduce.variable.expression.will.be.ambiguous.without.explicit.type=Sin un tipo explícito, la expresión <br/> es ambigua.
introduce.variable.specify.type.explicitly=Especificar el tipo explícitamente
notification.group.plugin.errors=Fallo del servicio de lenguaje Swift
optimize.imports.rearranged.imports=Declaraciones de importación reordenadas
optimize.imports.removed.0.added.1.imports=Elimine {0} {0,choice,0#declaraciones de importación|1#declaraciones de importación|1<declaraciones de importación} y {1} {1,choice,0#declaraciones de importación|1#declaraciones de importación|1<declaraciones de importación agregadas}
optimize.imports.removed.0.imports={0} {0,choice,0#importar declaraciones|1#importar declaraciones|1<importar declaraciones} eliminado
override.implement.elements.to.implement.chooser.title=Seleccionar miembros para implementar
override.implement.elements.to.override.chooser.title=Seleccionar miembro para anular
override.implement.elements.to.override.implement.chooser.title=Seleccionar miembro para anular/implementar
override.implement.implement.not.allowed=No se puede implementar
override.implement.nothing.to.implement=Nada que implementar
override.implement.nothing.to.override=Nada que anular
override.implement.override.not.allowed=No se puede anular
override.implement.progress=Procesando miembros para anular/implementar...
override.implement.show.members.to.implement.title=Mostrar miembros para implementar
override.implement.show.no.optional.members=Mostrar miembros opcionales (nada opcional)
override.implement.show.only.optional.members=Mostrar miembros opcionales (solo elementos opcionales)
override.implement.show.optional.member=Marcar &O un miembro opcional
override.implement.show.optional.members=Marcar {0} miembros opcionales
refactor.0.overrides.associated.type.of.1={0} anula el tipo de asociación de {1}
refactor.0.overrides.declaration.in.1={0} anula mi declaración {1}
refactor.0.overrides.initializer.of.1={0} anula el inicializador de {1}
refactor.0.overrides.method.of.1={0} anula el método de {1}
refactor.0.overrides.property.of.1={0} anula las propiedades de {1}
refactor.0.overrides.subscript.of.1={0} anula el subíndice de {1}
refactor.base.declaration=Refactorizando el valor predeterminado {0,choice,1\#declaration|2\#declaration}
refactor.only.current.declaration=Refactorizar sólo la declaración actual
refactoring.option.search.in.not.compiled.code=Se aplica condicionalmente al código no compilado.
rename.containing.file.dialog.description=Cambie el nombre de los archivos incluidos con los siguientes nombres\:
rename.containing.file.dialog.title=Cambiar el nombre del archivo que lo contiene
rename.containing.file.entity.name=Archivos incluidos
rename.error.dynamic.called.values=Los nombres de los valores llamados dinámicamente no se pueden cambiar.
rename.error.message.renaming.swift.member.elements.in.objective.c.code.is.not.supported=No se admite el cambio de nombre de los elementos miembros de Swift dentro del código Objective-C.
rename.error.title=Swift - cambiar el nombre
rename.inheritor.entity.name=Heredero
rename.inheritors=Cambiar el nombre del heredero
rename.inheritors.to=Cambie el nombre del heredero a\:
rename.init.is.not.supported=No se admite el cambio de nombre de los inicializadores rápidos.
rename.related.dialog.description=Cambie el nombre de la declaración asociada con el siguiente nombre\:
rename.related.dialog.title=Cambiar el nombre de la declaración relacionada
rename.related.entity.name=Declaración relevante
rename.self.is.not.supported=No se admite cambiar el nombre del parámetro self.
rename.title=Cambio de nombre rápido
searching.for.implementations=Buscando implementación...
searching.for.overriders=Buscando anulación...
searching.for.subclasses=Buscando subclases...
sourcekit.fix.it=Aplicar Fix-it
sourcekit.inspections=Inspección del kit de origen
swift.name=Rápido
syntax.error.call.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=La llamada puede lanzarse, pero se ejecuta en un cierre automático sin lanzamiento.
syntax.error.call.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=La llamada puede lanzarse, pero no se marca como "intento" y se ejecuta en un cierre automático sin lanzamiento.
syntax.error.call.can.throw.in.default.argument=Las llamadas con argumentos predeterminados pueden generar errores, pero no.
syntax.error.call.can.throw.in.property.initializer=Los inicializadores de propiedades pueden generar llamadas, pero no pueden generar errores.
syntax.error.call.can.throw.not.marked.with.try=La llamada puede ser rechazada, pero no se marcará como un "intento".
syntax.error.call.can.throw.not.marked.with.try.not.exhaustive=La llamada puede lanzarse, pero no está marcada como un "intento" y la captura circundante está incompleta.
syntax.error.call.can.throw.not.marked.with.try.not.handled=Es posible que la llamada se produzca, pero no se marcará como un "intento" y no se gestionará ningún error.
syntax.error.call.rethrows.function.can.only.throw.parameter.call.not.handled=Es posible que se realice la llamada, pero el error no se gestionará. Una función declarada como 'relanzamiento' solo se lanzará si su parámetro lo hace.
syntax.error.call.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=Es posible que la llamada se produzca, pero no se marcará como un "intento" y no se gestionará ningún error. Una función declarada como 'relanzamiento' solo se lanzará si su parámetro lo hace.
syntax.error.duplicate.platform=La plataforma ''{0}'' ya está especificada
syntax.error.error.is.not.handled=El error no se maneja porque la función adjunta no "lanza".
syntax.error.error.is.not.handled.not.exhaustive=El error no se maneja porque la captura circundante está incompleta.
syntax.error.errors.are.not.handled=Los errores arrojados aquí no serán manejados.
syntax.error.errors.are.not.handled.not.exhaustive=Los errores arrojados aquí no se manejarán porque el mensaje adjunto está incompleto.
syntax.error.hashbang.line.is.allowed.only.in.the.first.line.of.the.file=Las líneas Hashbang solo se permiten en la primera línea del archivo.
syntax.error.hashbang.line.is.allowed.only.in.the.first.line.of.the.main.file=Las líneas Hashbang sólo se permiten en la primera línea del archivo principal.
syntax.error.hashbang.line.is.allowed.only.in.the.main.file=Las líneas Hashbang sólo se permiten en archivos principales.
syntax.error.interpolation.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=La interpolación se ejecuta en un cierre automático que puede lanzar pero no lanza.
syntax.error.interpolation.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=La interpolación puede arrojar, pero no está marcada como "intento" y se ejecuta en un cierre automático sin lanzamiento.
syntax.error.interpolation.can.throw.in.default.argument=En los argumentos predeterminados, se pueden generar interpolaciones, pero no se pueden generar errores.
syntax.error.interpolation.can.throw.in.property.initializer=Los inicializadores de propiedades pueden generar interpolaciones pero no errores
syntax.error.interpolation.can.throw.not.marked.with.try=La interpolación se puede realizar pero no marcar como "intentar"
syntax.error.interpolation.can.throw.not.marked.with.try.not.exhaustive=La interpolación puede lanzar, pero no está marcada como 'intento' y la captura circundante no está completa.
syntax.error.interpolation.can.throw.not.marked.with.try.not.handled=La interpolación puede arrojar resultados, pero no se marcará como un "intento" y no se manejará ningún error.
syntax.error.interpolation.rethrows.function.can.only.throw.parameter.call.not.handled=La interpolación puede generar errores, pero no se manejarán. Una función declarada como 'relanzamiento' solo se lanzará si su parámetro lo hace.
syntax.error.interpolation.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=La interpolación puede arrojar resultados, pero no se marcará como un "intento" y no se manejará ningún error. Una función declarada como 'relanzamiento' solo se lanzará si su parámetro lo hace.
syntax.error.iteration.can.throw.not.marked.with.try=La iteración se puede lanzar pero no marcar como 'intentar'
syntax.error.iteration.can.throw.not.marked.with.try.not.exhaustive=La iteración puede arrojar, pero no está marcada como "intento" y la captura adjunta no está completa
syntax.error.iteration.can.throw.not.marked.with.try.not.handled=La iteración puede arrojar resultados, pero no se marcará como un "intento" y no se manejará ningún error.
syntax.error.operator.can.throw.not.marked.with.try=Se pueden lanzar operadores, pero las expresiones no están marcadas como "probar".
syntax.error.property.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=Los accesos a propiedades se ejecutan en cierres automáticos que pueden generar pero no generar
syntax.error.property.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=Los accesos a la propiedad pueden generar, pero no están marcados como "intentar" y se ejecutan en un cierre automático que no permite generar
syntax.error.property.can.throw.in.default.argument=Los accesos a propiedades en argumentos predeterminados pueden generar errores, pero no pueden generarlos.
syntax.error.property.can.throw.in.property.initializer=Los inicializadores de propiedades pueden generar accesos a propiedades pero no errores
syntax.error.property.can.throw.not.marked.with.try=El acceso a la propiedad se puede descartar pero no marcar como 'probar'
syntax.error.property.can.throw.not.marked.with.try.not.exhaustive=El acceso a la propiedad puede arrojar, pero no está marcado como "intentar" y la captura circundante está incompleta
syntax.error.property.can.throw.not.marked.with.try.not.handled=El acceso a la propiedad puede generarse, pero no se marcará como un "intento" y no se manejará ningún error.
syntax.error.property.rethrows.function.can.only.throw.parameter.call.not.handled=Los accesos a la propiedad pueden generar errores, pero no se manejarán. Una función declarada como 'relanzamiento' solo se lanzará si su parámetro lo hace.
syntax.error.property.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=El acceso a la propiedad puede generarse, pero no se marcará como un "intento" y no se manejará ningún error. Una función declarada como 'relanzamiento' solo se lanzará si su parámetro lo hace.
syntax.error.rethrows.function.can.only.throw.parameter.call=Una función declarada como ''rethrows'' solo se lanzará si su parámetro lo hace.
syntax.error.rethrows.function.must.take.a.throwing.function.argument=La función ''rethrows'' debe tener un argumento de función de lanzamiento.
syntax.error.rethrows.is.not.allowed.in.closures=No se permiten ''relanzamientos'' en cierres.
syntax.error.rethrows.is.not.allowed.in.function.type.elements=Sólo las declaraciones de funciones se pueden marcar como "relanzamientos".
syntax.error.rethrows.is.not.allowed.in.subscripts=Los ''relanzamientos'' no están permitidos en los subíndices.
syntax.error.subscript.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=Los accesos a subíndices se pueden lanzar, pero se ejecutan en un cierre automático que no se lanza
syntax.error.subscript.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=Los accesos a subíndices pueden generar, pero no están marcados como 'intentar' y se ejecutan en un cierre automático que no permite generar
syntax.error.subscript.can.throw.in.default.argument=Los accesos a subíndices en argumentos predeterminados pueden generar errores, pero no
syntax.error.subscript.can.throw.in.property.initializer=Los inicializadores de propiedades pueden generar accesos de subíndice pero no errores
syntax.error.subscript.can.throw.not.marked.with.try=El acceso al subíndice se puede iniciar pero no marcar como 'intentar'
syntax.error.subscript.can.throw.not.marked.with.try.not.exhaustive=El acceso al subíndice puede generar, pero no está marcado como "intentar" y la captura circundante está incompleta
syntax.error.subscript.can.throw.not.marked.with.try.not.handled=El acceso al subíndice puede generar resultados, pero no se marcará como "intentar" y no se manejará ningún error.
syntax.error.subscript.rethrows.function.can.only.throw.parameter.call.not.handled=El acceso al subíndice puede generar resultados, pero no se manejará ningún error. Una función declarada como 'relanzamiento' solo se lanzará si su parámetro lo hace.
syntax.error.subscript.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=El acceso al subíndice puede generar resultados, pero no se marcará como un "intento" y no se manejará ningún error. Una función declarada como 'relanzamiento' solo se lanzará si su parámetro lo hace.
syntax.error.thrown.expression.type.0.does.not.conform.to.ErrorType=El tipo de expresión arrojada ''{0}'' no se ajusta a ''{1}''.
syntax.error.throws.is.not.allowed.in.subscripts=''lanzamientos'' no está permitido en los subíndices.
syntax.error.try.cannot.appear.to.the.right=''try'' no puede aparecer en el lado derecho de un operador no asignado.
syntax.error.try.cannot.appear.to.the.right.fix=Mueve ''intentar'' a la izquierda
syntax.error.typealias.without.assignment=Falta la asignación en la declaración de alias de tipo.
syntax.error.unrecognized.platform.name.0=Nombre de plataforma no reconocido ''{0}''
syntax.error.variable.declaration.with.multiple.variables.cannot.have.explicit.getters.setters=El captador/definidor explícito no se puede utilizar en la declaración ''var'' con múltiples variables
syntax.error.variable.declaration.with.multiple.variables.cannot.have.implicit.getter.clause=La cláusula getter implícita no se puede utilizar en la declaración ''var'' con múltiples variables
syntax.error.variable.declaration.with.multiple.variables.cannot.have.willset.didset.clause=Las cláusulas willSet/didSet no se pueden utilizar en declaraciones ''var'' con múltiples variables.
usage.type.argument.label=Etiqueta de argumento
usage.type.conditionally.not.compiled=Usos potenciales dentro del código no compilado condicionalmente
usage.type.extension=Expansión
usage.type.function.declaration=Declaración de función
usage.type.key.path=Expresión de ruta clave
usage.type.operator.declaration=Declaración del operador
usage.type.precedence.group.declaration=Declaración de grupo prioritario
usage.type.raw.value=Valor bruto
usage.type.requirement=Dónde usarlo en mis requisitos
usage.type.type.alias=Escriba alias
usage.type.type.parameter=Tipo de parámetro
