action.AddToISuite.text=Agregar a la herramienta de patrón JUnit
action.excludeFromSuite.text=Excluido de herramientas
action.text.test.category={0} prueba
action.text.test.tags={0} prueba
action.text.test.unknown.target=Desconocido
cannot.browse.test.inheritors.dialog.title=Heredero de TestCase no encontrado
category.interface.dialog.title=Interfaz de categoría
category.is.not.specified.error.message=Ninguna categoría especificada
category.label=Categoría
change.list.label=Lista de cambios
class.isnt.inheritor.of.testcase.error.message={0} no es heredero de TestCase
class.not.test.error.message=La clase ''{0}'' no es una prueba
combobox.changelists.all=Cada
configuration.not.specified.message=Tipo de prueba de configuración no especificado. {0}
create.setup.dialog.message=El método setUp ya existe pero no está anotado con {0}. ¿Le gustaría procesar anotaciones?
create.setup.dialog.title=Crear método de configuración
default.junit.config.empty.category=Inválido
default.junit.config.name.all.in.module=Todos en {0}
default.junit.config.name.all.in.package.in.module={0} de {1}
default.junit.config.name.category=@Category({0})
default.junit.config.name.tags=Etiqueta ({0})
default.junit.config.name.temp.suite=Herramientas temporales
default.junit.config.name.whole.project=Proyecto entero
default.junit.configuration.name=<sin nombre>
dialog.message.failed.to.resolve.maven.id={0} Error de resolución
dialog.message.no.unique.id.specified.exception=No se ha especificado ningún ID único
dialog.title.preparing.test=Preparándose para la prueba
directory.0.is.not.found.error.message=Directorio ''{0}'' no encontrado
directory.is.not.specified.error.message=No se ha especificado ningún directorio
directory.label=Ruta
directory.not.found.error.message=Directorio ''{0}'' no encontrado
expected.exception.never.thrown.display.name=Excepción requerida no lanzada en el cuerpo del método de prueba
expected.exception.never.thrown.problem.descriptor=El <code>\#ref</code> requerido no se incluye en absoluto en el cuerpo ''{0}()'' \#loc
fix.data.provider.create.method.fix.name=Crear método de proveedor de datos '@Parameters público estático Iterable<Objeto> parámetros()'
fix.data.provider.multiple.methods.problem=La clase <code>\#ref</code> tiene múltiples métodos de proveedor de datos @Parameters
fix.data.provider.signature.family.name=Modificar la firma del método del proveedor de datos
fix.data.provider.signature.fix.name=Cambiar la firma del método a ''{0}''
fix.data.provider.signature.incorrect.problem=El método del proveedor de datos <code>\#ref()</code> tiene una firma no válida
fix.data.provider.signature.missing.method.problem=La clase de prueba parametrizada <code>\#ref</code> no tiene un método de proveedor de datos anotado con '@Parameters'
fork.mode.label=Modo horquilla\:
fork.mode.name=Modo horquilla
inspection.parameterized.parameters.static.collection.display.name=Clase de prueba parametrizada sin métodos de proveedor de datos
junit.config.with.parameter.0=(incluido el parámetro ''{0}'')
junit.configuration.across.module.dependencies.radio=Todas las dependencias del módulo
junit.configuration.class.label=&Clase\:
junit.configuration.description=Configuración de prueba JUnit
junit.configuration.display.name=JUnit
junit.configuration.fork.mode.class=Clase
junit.configuration.fork.mode.method=Método
junit.configuration.fork.mode.none=Ninguno
junit.configuration.fork.mode.repeat=Repetir
junit.configuration.in.single.module.radio=En un solo módulo
junit.configuration.in.whole.project.radio=En todo el proyecto
junit.configuration.kind.all.in.directory=Todos los elementos del directorio
junit.configuration.kind.all.in.package=Todos los artículos en el paquete
junit.configuration.kind.by.pattern=Patrón
junit.configuration.kind.by.tags=Etiqueta
junit.configuration.kind.by.unique.id=UniqueId
junit.configuration.kind.category=Categoría
junit.configuration.kind.class=Clase
junit.configuration.kind.method=Método
junit.configuration.method.label=Método(&E)\:
junit.configuration.package.label=&Paquete\:
junit.configuration.repeat.mode.n.times=N veces
junit.configuration.repeat.mode.once=Una vez
junit.configuration.repeat.mode.until.failure=Hasta que falles
junit.configuration.repeat.mode.until.stopped=Until stopped
junit.configuration.repeat.mode.until.success=Hasta el éxito
junit.configuration.search.for.tests.label=Búsqueda de prueba\:
junit.entry.point.suggest.package.private.visibility.junit5=Sugerir nivel de visibilidad privado del paquete para pruebas junit 5
junit.inspections.group.name=JUnit
junit.not.found.in.module.error.message=JUnit no puede encontrar el módulo ''{0}''
junit3.style.test.method.in.junit4.class.display.name=Métodos de prueba JUnit de estilo antiguo en clases JUnit 4
junit3.style.test.method.in.junit4.class.problem.descriptor=La clase JUnit 4 tiene el método de prueba JUnit de estilo antiguo <code>\#ref()</code> \#loc
junit5.migration.description=La transferencia de anotaciones de prueba de JUnit 4 a nuevas anotaciones de Júpiter puede generar un código rojo. Las afirmaciones no se migran. Para migrar sólo pruebas que se puedan convertir de forma totalmente automática, seleccione Java | Problemas de JUnit | Consulte la verificación 'Las pruebas JUnit 4 se pueden cambiar a pruebas JUnit 5'.
jvm.inspections.junit.assertequals.may.be.assertsame.display.name='assertEquals()' puede convertirse en 'assertSame()'
jvm.inspections.junit.assertequals.may.be.assertsame.problem.descriptor=<code>\#ref</code>puede ser 'assertSame()' \#loc
jvm.inspections.junit.assertequals.on.array.display.name=Llamar a 'assertEquals()' en una matriz
jvm.inspections.junit.assertequals.on.array.problem.descriptor=<code>\#ref()</code> se llama en la matriz \#loc
jvm.inspections.junit.ignored.test.class.problem.descriptor=La clase de prueba ''{0}'' fue ignorada/deshabilitada {1,choice, 1\#|2\# sin motivo} \#loc
jvm.inspections.junit.ignored.test.display.name=Agregue anotaciones '@Ignore'/'@Disabled' a las pruebas JUnit
jvm.inspections.junit.ignored.test.ignore.reason.option=Informar únicamente de las anotaciones utilizadas sin motivo
jvm.inspections.junit.ignored.test.method.problem.descriptor=El método de prueba ''{0}()'' fue ignorado/deshabilitado {1,choice, 1\#|2\# sin motivo} \#loc
jvm.inspections.junit.malformed.annotated.double.descriptor=''@{1}'' anotado {0,choice, 0\#field|1\#method} <code>\#ref</code> debe ser {2} y {3}
jvm.inspections.junit.malformed.annotated.double.typed.descriptor=''@{1}'' anotado {0,choice, 0\#field|1\#method} <code>\#ref</code> es {2} y {3} y ' Debe ser de tipo '{ 4}''
jvm.inspections.junit.malformed.annotated.method.double.param.double.descriptor=El método anotado ''@{0}'' <code>\#ref</code> debe ser {1} y {2} y los parámetros ''{3}'' y ''{4 No debes declarar } ''
jvm.inspections.junit.malformed.annotated.method.double.param.single.descriptor=El método anotado ''@{0}'' <code>\#ref</code> debe ser {1} y {2} y declara el parámetro ''{3}''. No deberías hacerlo.
jvm.inspections.junit.malformed.annotated.method.double.typed.param.double.descriptor=El método anotado ''@{0}'' <code>\#ref</code> es {1} y {2} y debe ser del tipo ''{3}'' y el parámetro {4} y '' {5}'' no debe declararse
jvm.inspections.junit.malformed.annotated.method.double.typed.param.single.descriptor=El método anotado ''@{0}'' <code>\#ref</code> es {1} y {2} y debe ser del tipo ''{3}'' y el parámetro ''{ 4}' ' no debe ser declarado
jvm.inspections.junit.malformed.annotated.method.param.double.descriptor=El método anotado ''@{0}'' <code>\#ref</code> no debe declarar los parámetros {1} y ''{2}''
jvm.inspections.junit.malformed.annotated.method.param.single.descriptor=El método anotado ''@{0}'' <code>\#ref</code> no debe declarar el parámetro ''{1}''
jvm.inspections.junit.malformed.annotated.method.single.param.double.descriptor=El método anotado ''@{0}'' <code>\#ref</code> debe ser {1} y toma los parámetros ''{2}'' y ''{3}''.
jvm.inspections.junit.malformed.annotated.method.single.param.single.descriptor=El método anotado ''@{0}'' <code>\#ref</code> debe ser {1} y no debe declarar el parámetro ''{2}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.double.descriptor=El método anotado ''@{0}'' <code>\#ref</code> debe ser {1} y de tipo ''{2}'', con los parámetros {3} y ''{ 4}'' no debe ser declarado
jvm.inspections.junit.malformed.annotated.method.single.typed.param.single.descriptor=El método <code>\#ref</code> anotado con ''@{0}'' es {1} y debe ser del tipo ''{2}'' y el parámetro ''{3}''. no declarar
jvm.inspections.junit.malformed.annotated.method.typed.param.double.descriptor=El método anotado ''@{0}'' <code>\#ref</code> debe ser de tipo ''{1}'' y los parámetros {2} y ''{3}'' No debes declarar
jvm.inspections.junit.malformed.annotated.method.typed.param.single.descriptor=El método <code>\#ref</code> anotado con ''@{0}'' debe ser de tipo ''{1}'' y toma el parámetro ''{2}''. No debes declararlo.
jvm.inspections.junit.malformed.annotated.single.descriptor=''@{1}'' anotado {0,choice, 0\#field|1\#method} <code>\#ref</code> debe ser {2}
jvm.inspections.junit.malformed.annotated.single.typed.descriptor=El {0,choice, 0\#field|1\#method} <code>\#ref</code> anotado con ''@{1}'' es {2} y ''{3} debe ser de tipo ''
jvm.inspections.junit.malformed.annotated.suspend.function.descriptor=El método anotado ''@{0}'' <code>\#ref</code> no debe ser una función de pausa
jvm.inspections.junit.malformed.annotated.typed.descriptor={0,choice, 0\#field|1\#method} <code>\#ref</code> anotado con ''@{1}'' debe ser del tipo ''{2}''
jvm.inspections.junit.malformed.declaration.name=Declaración JUnit mal formada
jvm.inspections.junit.malformed.extension.class.level.descriptor={0} debe estar registrado a nivel de clase
jvm.inspections.junit.malformed.fix.class.signature=Modificar firma de clase
jvm.inspections.junit.malformed.fix.class.signature.descriptor=Modificar firma de clase ''{0}''
jvm.inspections.junit.malformed.fix.class.signature.multi=Modificar firma de clase
jvm.inspections.junit.malformed.fix.field.signature=Editar firma de campo
jvm.inspections.junit.malformed.fix.field.signature.descriptor=Modificar la firma del campo ''{0}''
jvm.inspections.junit.malformed.fix.method.signature=Editar firma del método
jvm.inspections.junit.malformed.fix.method.signature.descriptor=Modificar la firma del método ''{0}''
jvm.inspections.junit.malformed.missing.nested.annotation.descriptor=Las pruebas dentro de clases anidadas no se ejecutarán
jvm.inspections.junit.malformed.no.arg.descriptor=El método <code>\#ref</code> debe ser {0}, {1} y {2,choice, 0\#no parámetros|1\#, sin parámetros y de tipo void}
jvm.inspections.junit.malformed.option.ignore.test.parameter.if.annotated.by=Ignore los parámetros de prueba si se agrega la siguiente anotación\:
jvm.inspections.junit.malformed.param.duplicated.enum.descriptor=Nombre constante 'enum' duplicado
jvm.inspections.junit.malformed.param.empty.source.unsupported.descriptor=''@{0}'' no puede proporcionar argumentos al método porque el método tiene un parámetro de tipo ''{1}'', que no es compatible
jvm.inspections.junit.malformed.param.exactly.one.type.of.input.must.be.provided.descriptor=Se debe proporcionar exactamente un tipo de entrada
jvm.inspections.junit.malformed.param.file.source.descriptor=No se pudo resolver el origen del archivo. ''{0}''
jvm.inspections.junit.malformed.param.method.source.assignable.descriptor=No se encontró ninguna conversión implícita para convertir ''{0}'' a ''{1}''
jvm.inspections.junit.malformed.param.method.source.no.params.descriptor=La fuente del método ''{0}'' no puede contener parámetros
jvm.inspections.junit.malformed.param.method.source.return.type.descriptor=La fuente del método ''{0}'' debe contener uno de los siguientes tipos de devolución: ''Flujo<?>'', ''Iterador<?>'', ''Iterable<?>'' u ''Objeto[]''
jvm.inspections.junit.malformed.param.method.source.static.descriptor=La fuente del método ''{0}'' debe ser estática
jvm.inspections.junit.malformed.param.method.source.unresolved.descriptor=No se puede resolver el origen del método de destino. ''{0}''
jvm.inspections.junit.malformed.param.multiple.parameters.descriptor=Esta fuente no admite múltiples parámetros.
jvm.inspections.junit.malformed.param.no.sources.are.provided.descriptor=La suite se deja en blanco debido a que no se proporcionó ninguna fuente
jvm.inspections.junit.malformed.param.no.value.source.is.defined.descriptor=No hay fuente de valor definida
jvm.inspections.junit.malformed.param.unresolved.enum.descriptor=No se puede resolver la referencia constante 'enum'.
jvm.inspections.junit.malformed.param.wrapped.in.arguments.descriptor=Se deben incluir varios parámetros en 'Argumentos'
jvm.inspections.junit.malformed.repetition.number.descriptor=El número de iteraciones debe ser mayor que 0.
jvm.inspections.junit.malformed.source.without.params.descriptor=\n''@{0}'' no puede proporcionar argumentos al método porque el método no tiene parámetros.
jvm.inspections.junit.malformed.suspend.function.descriptor=El método <code>\#ref</code> no debe ser una función de pausa
jvm.inspections.junit.malformed.test.combination.descriptor=Combinación sospechosa de {0} y ''@{1}''
jvm.inspections.junit.mixed.annotations.junit.descriptor=Dentro de la clase, el método anotado ''@{0}'' <code>\#ref()</code> extiende JUnit {1} TestCase \#loc
jvm.inspections.junit.mixed.annotations.name=Usando múltiples versiones de JUnit API dentro de un TestCase
jvm.inspections.junit3.super.teardown.display.name=JUnit 3 'super.tearDown()' no llamado en el bloque 'finalmente'
jvm.inspections.junit3.super.teardown.problem.descriptor=<code>\#ref()</code> no se llama en el bloque 'finalmente' \#loc
jvm.inspections.junit4.converter.display.name=Las pruebas JUnit 3 pueden convertirse en JUnit 4
jvm.inspections.junit4.converter.problem.descriptor=Puede convertir <code>\#ref</code> a casos de prueba JUnit4
jvm.inspections.junit4.converter.quickfix.conflict.call.compile=La llamada al método {0} no se compila cuando {1} se convierte a JUnit 4
jvm.inspections.junit4.converter.quickfix.conflict.name=El método {0} tiene un conflicto de nombre con su método principal
jvm.inspections.junit4.converter.quickfix.conflict.semantics=La llamada al método {0} puede cambiar su significado si {1} se convierte a JUnit 4
jvm.inspections.junit4.converter.quickfix.conflict.suite=La migración del método del conjunto de {0} tiene efectos secundarios que se eliminarán
jvm.inspections.junit4.converter.quickfix.name=Convertir a casos de prueba JUnit4
jvm.inspections.junit4.inherited.runwith.display.name=La anotación '@RunWith' ya existe en la clase principal
jvm.inspections.junit4.inherited.runwith.problem.descriptor=La anotación ''@RunWith'' ya existe en la clase {0}
jvm.inspections.junit5.assertions.converter.display.name=Afirmaciones en versiones anteriores a JUnit 5
jvm.inspections.junit5.assertions.converter.familyName=Reemplazar con llamadas compatibles con JUnit 5
jvm.inspections.junit5.assertions.converter.problem.descriptor=Debe reemplazar la llamada <code>\#ref()</code> en ''{0}'' con una llamada al método en ''{1}'' \#loc
jvm.inspections.junit5.assertions.converter.quickfix=Reemplace ''{0}'' con una llamada a un método
jvm.inspections.junit5.converter.display.name=Las pruebas JUnit 4 pueden convertirse en JUnit 5
jvm.inspections.junit5.converter.problem.descriptor=\#ref puede ser una prueba JUnit 5
jvm.inspections.junit5.converter.quickfix=Migrar a JUnit 5
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=La clase {0} no se puede convertir a JUnit 5 porque tiene herederos incompatibles. {Uno}
jvm.inspections.junit5.converter.quickfix.presentation.text=Conversión de afirmaciones
jvm.inspections.migrate.assert.to.matcher.description=Assert expression <code>\#ref</code> can be replaced with ''{0}'' call \#loc
jvm.inspections.migrate.assert.to.matcher.option=Importar el método de comparación estáticamente
jvm.inspections.migrate.assertion.name=Las afirmaciones de JUnit pueden ser llamadas a 'assertThat()'
jvm.inspections.unconstructable.test.case.junit3.descriptor=La clase de prueba <code>\#ref</code> no es construible porque no tiene un constructor de parámetro 'Cadena' único o sin argumentos 'público' \#loc
jvm.inspections.unconstructable.test.case.junit4.descriptor=La clase de prueba <code>\#ref</code> no se puede construir porque debe tener solo un constructor 'público' sin argumentos \#loc
jvm.inspections.unconstructable.test.case.not.public.descriptor=La clase de prueba <code>\#ref</code> no es 'pública' y no se puede construir \#loc
method.name.not.specified.error.message=Nombre del método no especificado
module.does.not.exists=El módulo ''{0}'' no existe en el proyecto ''{1}''
module.to.choose.classpath.not.specified.error.message=El módulo seleccionado para el classpath no está especificado
multiple.exceptions.declared.on.test.method.display.name=Múltiples excepciones declaradas en el método de prueba.
multiple.exceptions.declared.on.test.method.problem.descriptor=Puede reemplazar <code>\#ref</code> con 'lanza excepción' \#loc
no.module.selected.error.message=Ningún módulo seleccionado
no.pattern.error.message=Ningún patrón seleccionado
no.test.class.specified.error.text=No se ha especificado ninguna clase de prueba
package.does.not.exist.error.message=El paquete ''{0}'' no existe
pattern.label=Patrón
progress.title.download.additional.dependencies=Descargando dependencias adicionales...
repeat.count.label=&Repetir conteo\:
repeat.label=&Repetir\:
repeat.name=Repetir
running.tests.disabled.during.index.update.error.message=La ejecución de la prueba está deshabilitada durante la actualización del índice.
search.scope.module=En un solo módulo
search.scope.module.deps=Todas las dependencias del módulo
search.scope.name=Búsqueda de prueba
search.scope.project=En todo el proyecto
tag.expression.label=Expresión de etiqueta
tag.name.0.must.be.syntactically.valid.warning=El nombre de la etiqueta[{0}] debe ser sintácticamente válido
tags.are.not.specified.error.message=No etiquetado
test.class.hint=Nombre completo de la clase que contiene la prueba.
test.discovery.by.all.changes.combo.item=Cada
test.group=Prueba
test.kind.hint=Tipo de recurso para recuperar pruebas
test.method.doesnt.exist.error.message=El método de prueba ''{0}'' no existe
test.method.hint=Nombre completo del método de prueba.
test.package.hint=Nombre del paquete que contiene la prueba.
test.pattern.hint=Expresión regular que coincide con el nombre de la clase que contiene la prueba
uniqueid.label=UniqueId
unused.declaration.junit.test.entry.point=Caso de prueba junit
usage.of.obsolete.assert.display.name=Usando el método 'junit.framework.Assert' que pronto quedará obsoleto
use.of.obsolete.assert.problem.descriptor=Debe reemplazar la llamada <code>\#ref()</code> en ''{0}'' con una llamada al método en ''org.junit.Assert'' \#loc
use.of.obsolete.assert.quickfix=Reemplácelo con un método llamado 'org.junit.Assert'.
