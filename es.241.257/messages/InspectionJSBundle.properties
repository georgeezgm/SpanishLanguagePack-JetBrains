group.path.javascript=JavaScript
result.of.assignment.used.displayName=Result of assignment used
result.of.assignment.expression.used.error.string=Result of assignment expression used #loc
assignment.to.for.loop.parameter.display.name=Assignment to 'for' loop parameter
assignment.to.for.loop.parameter.error.string=Assignment to for-loop parameter #ref #loc
assignment.to.function.parameter.display.name=Assignment to function parameter
assignment.to.function.parameter.error.string=Assignment to function parameter '#ref' #loc
nested.assignment.display.name=Nested assignment
nested.assignment.error.string=Nested assignment <code>#ref</code> #loc
assignment.replaceable.with.operator.assignment.display.name=Assignment could be replaced with operator assignment
assignment.replaceable.with.operator.assignment.error.string=#ref could be simplified to {0} #loc
silly.assignment.display.name=Variable is assigned to itself
silly.assignment.error.string=Variable is assigned to itself #loc
divide.by.zero.display.name=Division by zero
division.by.zero.error.string=Division by zero #loc
result.of.object.allocation.ignored.display.name=Result of object allocation ignored
result.of.object.allocation.ignored.error.string=Result of <code>new #ref()</code> is ignored #loc
text.label.in.switch.statement.display.name=Text label in 'switch' statement
text.label.in.switch.statement.error.string=Text label <code>#ref:</code> in 'switch' statement #loc
anonymous.function.display.name=Anonymous function
anonymous.function.error.string=Anonymous function #loc
unnecessary.block.statement.display.name=Unnecessary block statement
comma.expression.display.name=Comma expression
conditional.expression.display.name=Conditional expression
statement.with.empty.body.display.name=Statement with empty body
result.of.increment.or.decrement.used.display.name=Result of increment or decrement used
negated.conditional.expression.display.name=Negated conditional expression
negated.if.statement.display.name=Negated 'if' statement
nested.conditional.expression.display.name=Nested conditional expression
nested.function.display.name=Nested function
octal.integer.display.name=Octal integer
overly.complex.arithmetic.expression.display.name=Overly complex arithmetic expression
overly.complex.boolean.expression.display.name=Overly complex boolean expression
pointless.arithmetic.expression.display.name=Pointless arithmetic expression
pointless.boolean.expression.display.name=Pointless statement or boolean expression
void.expression.display.name='void' expression
with.statement.display.name='with' statement
break.statement.display.name='break' statement
break.statement.with.label.display.name='break' statement with label
conditional.expression.with.identical.branches.display.name=Conditional expression with identical branches
constant.conditional.expression.display.name=Constant conditional expression
continue.statement.display.name='continue' statement
continue.statement.with.label.display.name='continue' statement with label
default.not.last.case.in.switch.display.name='default' not last case in 'switch'
duplicate.condition.in.if.statement.display.name=Duplicate condition in 'if' statement
fall.through.in.switch.statement.display.name=Fallthrough in 'switch' statement
if.statement.with.identical.branches.display.name='if' statement with identical branches
if.statement.with.too.many.branches.display.name='if' statement with too many branches
typeof.using.incorrect.case.display.name='typeof' comparison with non-standard value
typeof.using.incorrect.case.error=typeof comparing with non-standard value
typeof.using.incorrect.convert=Convert to {0}
typeof.using.incorrect.family.name=Convert to standard value
infinite.loop.statement.display.name=Infinite loop statement
labeled.statement.display.name=Labeled statement
loop.statement.that.doesn.t.loop.display.name=Loop statement that doesn't loop
nested.switch.statement.display.name=Nested 'switch' statement
redundant.conditional.expression.display.name=Redundant conditional expression
redundant.if.statement.display.name=Redundant 'if' statement
unnecessary.continue.statement.display.name=Unnecessary 'continue' statement
unnecessary.label.display.name=Unnecessary label
unnecessary.label.on.break.statement.display.name=Unnecessary label on 'break' statement
unnecessary.label.on.continue.statement.display.name=Unnecessary label on 'continue' statement
unnecessary.return.statement.display.name=Unnecessary 'return' statement
call.to.document.write.display.name=Call to 'document.write()'
use.of.innerhtml.property.display.name=Use of 'innerHTML' property
platform.detection.display.name=Inaccurate platform detection
xhtml.incompatibilities.display.name=Incompatible XHTML usages
continue.or.break.inside.finally.block.display.name='continue' or 'break' inside 'finally' block
empty.catch.block.display.name=Empty 'catch' block
empty.finally.block.display.name=Empty 'finally' block
empty.try.block.display.name=Empty 'try' block
exception.used.for.local.control.flow.display.name=Exception used for local control-flow
return.inside.finally.block.display.name='return' inside 'finally' block
throw.inside.finally.block.display.name='throw' inside 'finally' block
overly.complex.function.display.name=Overly complex function
function.with.multiple.loops.display.name=Function with multiple loops
function.with.multiple.return.points.display.name=Function with multiple return points
overly.nested.function.display.name=Overly nested function
nesting.depth.limit=Nesting depth limit:
function.with.too.many.parameters.display.name=Function with too many parameters
function.parameter.limit=Function parameter limit:
overly.long.function.display.name=Overly long function
maximum.statements.per.function=Maximum statements per function:
function.with.more.than.three.negations.display.name=Function with more than three negations
function.naming.convention.display.name=Function naming convention
local.variable.naming.convention.display.name=Local variable naming convention
function.parameter.naming.convention.display.name=Function parameter naming convention
class.naming.convention.display.name=Class naming convention
expression.statement.which.is.not.assignment.or.call.display.name=Expression statement which is not assignment or call
debugger.statement.display.name='debugger' statement
duplicate.case.label.display.name=Duplicate 'case' label
function.with.inconsistent.returns.display.name=Function with inconsistent returns
reserved.word.used.as.name.display.name=Reserved word used as name
this.expression.which.references.the.global.object.display.name='this' expression which references the global object
unreachable.code.display.name=Unreachable code
chained.equality.display.name=Chained equality
constant.on.right.side.of.comparison.display.name=Constant on right side of comparison
constant.on.left.side.of.comparison.display.name=Constant on left side of comparison
non.block.statement.body.display.name=Statement body without braces
unterminated.statement.display.name=Unterminated statement
terminate.statement.fix=Terminate statement
unnecessary.block.statement.error.string=Unnecessary block statement #loc
comma.expression.error.string=Comma expression #loc
conditional.expression.error.string=Conditional expression #loc
statement.has.empty.branch.error.string=<code>#ref</code> statement has empty branch #loc
statement.has.empty.body.error.string=<code>#ref</code> statement has empty body #loc
include.statement.bodies.that.are.empty.code.blocks.parameter=Include statement bodies that are empty code blocks
result.of.increment.or.decrement.expression.used.error.string=Result of increment or decrement expression used #loc
negated.conditional.expression.error.string=Negated conditional expression #loc
invert.condition.fix=Invert condition
negated.ref.statement.error.string=Negated '#ref' statement #loc
invert.if.condition.fix=Invert 'if' condition
nested.conditional.expression.error.string=Nested conditional expression #loc
nested.function.error.string=Nested function '#ref' #loc
nested.anonymous.function.error.string=Nested #ref #loc
include.anonymous.functions.parameter=Include anonymous functions
maximum.number.of.terms.parameter=Maximum number of terms:
overly.complex.arithmetic.expression.error.string=Overly complex arithmetic expression #loc
pointless.arithmetic.error.message=#ref can be replaced with {0} #loc
simplify.fix=Simplify
pointless.boolean.error.string=Can be simplified to {0} #loc
pointless.statement.error.string={0} statement can be simplified #loc
void.expression.error.string='#ref' expression #loc
with.expression.error.string='#ref' statement #loc
break.statement.error.string='#ref' statement #loc
break.statement.with.label.error.string='#ref' statement with label #loc
conditional.expression.with.identical.branches.error.string=Conditional expression <code>#ref</code> with identical branches #loc
constant.conditional.expression.error.string=<code>#ref</code> can be simplified #loc
continue.statement.error.string='#ref' statement #loc
continue.statement.with.label.error.string='#ref' statement with label #loc
default.branch.not.last.case.in.switch.error.string=<code>#ref</code> branch not last case in 'switch' #loc
duplicate.condition.error.string=Duplicate condition <code>#ref</code> #loc
fall.through.in.switch.statement.error.string=Fallthrough in 'switch' statement #loc. Missing 'break' or 'return'
ref.statement.with.identical.branches.error.string=<code>#ref</code> statement with identical branches #loc
collapse.if.statement.fix=Collapse 'if' statement
maximum.number.of.branches.parameter=Maximum number of branches:
if.statement.with.too.many.branches.error.string=''#ref'' has too many branches ({0}) #loc
infinite.loop.error.string=<code>#ref</code> statement cannot complete without throwing an exception #loc
statement.label.error.string=Statement label '#ref' #loc
loop.statement.that.doesnt.loop.error.string=<code>#ref</code> statement doesn't loop #loc
nested.switch.statement.error.string=Nested '#ref' statement #loc
trivial.conditional.error.string=''{0}'' can be simplified to ''{1}'' #loc
trivial.if.error.string=<code>#ref</code> statement can be simplified #loc
unnecessary.continue.error.string=<code>#ref</code> is unnecessary as the last statement in a loop #loc
unnecessary.label.error.string=Unnecessary label <code>#ref</code> #loc
remove.label.fix=Remove label
unnecessary.label.on.break.error.string=<code>#ref</code> statement with unnecessary label #loc
unnecessary.label.on.continue.error.string=<code>#ref</code> statement with unnecessary label #loc
unnecessary.return.error.string=<code>#ref</code> is unnecessary as the last statement in a function with no return value #loc
document.write.error.string=Call to '#ref()' #loc
inner.html.error.string=Use of '#ref' property #loc
platform.detection.error.string='#ref' probably used for platform detection #loc
xhtml.incompatabilities.error.string='#ref' may produce inconsistent results for XHTML documents #loc
continue.or.break.inside.finally.block.error.string='#ref' inside 'finally' block #loc
empty.catch.block.error.string=Empty '#ref' block #loc
empty.finally.block.error.string=Empty 'finally' block #loc
empty.try.block.error.string=Empty '#ref' block #loc
exception.caught.locally.error.string='#ref' of exception caught locally #loc
return.inside.finally.block.error.string='#ref' inside 'finally' block #loc
throw.inside.finally.block.error.string='#ref' inside 'finally' block #loc
rename.fix=Rename
function.complexity.limit.parameter=Function complexity limit:
function.ref.is.overly.complex.cyclomatic.complexity.error.string=function ''#ref'' is overly complex (cyclomatic complexity = {0}) #loc
anonymous.function.is.overly.complex.cyclomatic.complexity.error.string=#ref  is overly complex (cyclomatic complexity = {0}) #loc
function.contains.multiple.loops.error.string=Function ''#ref'' contains {0} loops #loc
anonymous.function.contains.multiple.loops.error.string=#ref contains {0} loops #loc
function.contains.multiple.return.points.error.string=function ''#ref'' has {0} return points #loc
anonymous.function.contains.multiple.return.points.error.string=#ref has {0} return points #loc
function.is.overly.nested.error.string=function ''#ref'' is overly nested (nesting depth is {0}, but the permitted maximum is {1}) #loc
anonymous.function.is.overly.nested.error.string=#ref is overly nested (nesting depth is {0}, but the permitted maximum is {1}) #loc
function.has.too.many.parameters.error.string=function ''#ref'' has too many parameters (parameter count = {0}) #loc
anonymous.function.has.too.many.parameters.error.string=#ref has too many parameters (parameter count = {0}) #loc
function.is.overly.long.statement.error.string=function ''#ref'' is overly long (statement count = {0}) #loc
anonymous.function.is.overly.long.statement.error.string=#ref is overly long (statement count = {0}) #loc
function.contains.too.many.negation.error.string=function ''#ref'' contains {0} negations #loc
anonymous.function.contains.too.many.negation.error.string=#ref contains {0} negations #loc
function.name.is.too.short.error.string=Function name ''{0}'' is too short #loc
function.name.is.too.long.error.string=Function name ''{0}''is too long #loc
function.name.doesnt.match.regex.error.string=Function name ''{0}'' doesn''t match regex ''{1}'' #loc
class.name.is.too.short.error.string=Class name ''{0}'' is too short #loc
class.name.is.too.long.error.string=Class name ''{0}''is too long #loc
class.name.doesnt.match.regex.error.string=Class name ''{0}'' doesn''t match regex ''{1}'' #loc
constructor.name.is.too.short.error.string=Constructor name ''{0}'' is too short #loc
constructor.name.is.too.long.error.string=Constructor name ''{0}''is too long #loc
constructor.name.doesnt.match.regex.error.string=Constructor name ''{0}'' doesn''t match regex ''{1}'' #loc
variable.name.is.too.short.error.string=Variable name '#ref' is too short #loc
variable.name.is.too.long.error.string=Variable name '#ref' is too long #loc
variable.name.doesnt.match.regex.error.string=Variable name ''#ref'' doesn''t match regex ''{0}'' #loc
parameter.name.is.too.short.error.string=Parameter name '#ref' is too short #loc
parameter.name.is.too.long.error.string=Parameter name '#ref' is too long #loc
parameter.name.doesnt.match.regex.error.string=Parameter name ''#ref'' doesn''t match regex ''{0}'' #loc
chained.equality.error.string=Chained equality comparison <code>#ref</code> #loc
constant.on.left.side.of.comparison.error.string=#ref: constant on left side of comparison #loc
constant.on.right.side.of.comparison.error.string=#ref: constant on right side of comparison #loc
flip.comparison.fix=Flip comparison
non.block.branch.error.string=<code>#ref</code> statement has non-block branch #loc
non.block.body.error.string=<code>#ref</code> statement has non-block body #loc
unterminated.statement.error.string=Unterminated statement #loc
unterminated.statement.possibly.unterminated.statement.error=Possibly unterminated statement #loc
unterminated.statement.ignore.atend.of.block=Allow absence of semicolon at end of block
expression.statement.is.not.assignment.or.call.error.string=Expression statement is not assignment or call #loc
debugger.statement.error.string='#ref' statement #loc
duplicate.case.label.error.string=Duplicate case label #ref #loc
function.has.inconsistent.return.points.error.string=function '#ref' has inconsistent return points #loc
anonymous.function.has.inconsistent.return.points.error.string=#ref has inconsistent return points #loc
reserved.word.used.as.name.error.string=Reserved word '#ref' used as name
this.expression.references.global.object.error.string=Top-level '#ref' expression #loc
unreachable.code.error.string=Unreachable code #loc
replace.with.operator.assign.fix=Replace = with {0}=
overly.complex.boolean.expression.error.string=Overly complex boolean expression #loc
collapse.conditional.expression.fix=Collapse conditional expression
remove.unnecessary.continue.fix=Remove unnecessary continue
remove.unnecessary.return.fix=Remove unnecessary return
wrap.statement.body.fix=Wrap statement body
javascript.dom.issues.group.name=DOM issues
confusing.floating.point.literal.display.name=Confusing floating point literal
confusing.floating.point.literal.problem.descriptor=Confusing floating point literal <code>#ref</code> #loc
confusing.pluses.or.minuses.display.name=Confusing sequence of '+' or '-'
confusing.pluses.or.minuses.error.string=Sequence of '+' or '-' may change meaning if whitespace removed #loc
confusing.floating.point.literal.change.quickfix=Change to canonical form
string.literal.breaks.html.display.name=String literal which breaks HTML parsing
string.literal.breaks.html.error.string=String literal #ref may break HTML parsers #loc
for.loop.not.use.loop.variable.display.name='for' loop where update or condition does not use loop variable
for.loop.not.use.loop.variable.problem.descriptor.condition=<code>#ref</code> statement has condition which does not use the for loop variable #loc
for.loop.not.use.loop.variable.problem.descriptor.update=<code>#ref</code> statement has update which does not use the for loop variable #loc
for.loop.not.use.loop.variable.problem.descriptor.both.condition.and.update=<code>#ref</code> statement has condition and update which do not use the for loop variable #loc
unused.catch.parameter.display.name=Unused 'catch' parameter
unused.catch.parameter.problem.descriptor=Unused catch parameter <code>#ref</code> #loc
unused.catch.parameter.ignore.catch.option=Ignore catch blocks containing comments
tail.recursion.display.name=Tail recursion
tail.recursion.problem.descriptor=Tail recursion #loc
redundant.local.variable.display.name=Redundant local variable
redundant.local.variable.quickfix=Inline variable
redundant.local.variable.ignore.option=Ignore immediately returned or thrown variables
unnecessary.local.variable.problem.descriptor=Local variable {0} is redundant
reuse.of.local.variable.display.name=Reuse of local variable
reuse.of.local.variable.problem.descriptor=Reuse of local variable <code>#ref</code> #loc
infinite.recursion.display.name=Infinite recursion
infinite.recursion.problem.descriptor=Function <code>#ref</code> recurses infinitely, and can only end by throwing an exception #loc
statement.simplify.quickfix=Simplify statement
caller.error.string=Use of '#ref' property #loc
caller.display.name=Use of 'caller' property
dynamically.generated.code.error.string=Function '#ref' indicative of dynamically generated code #loc
dynamically.generated.code.display.name=Execution of dynamically generated code
for.loop.replaceable.by.while.problem.descriptor=<code>#ref</code> loop may be replaced by 'while' loop #loc
for.loop.replaceable.by.while.display.name='for' loop may be replaced by 'while' loop
for.loop.replaceable.by.while.replace.quickfix=Replace with 'while'
for.loop.replaceable.by.while.ignore.option=Ignore 'infinite' for loops without conditions
nested.function.call.display.name=Nested function call
nested.function.call.problem.descriptor=Nested call to function '#ref' #loc
chained.function.call.display.name=Chained function call
chained.function.call.problem.descriptor=Chained call to function '#ref' #loc
magic.number.display.name=Magic number
magic.number.problem.descriptor=Magic number '#ref' #loc
incompatible.mask.operation.display.name=Incompatible bitwise mask operation
incompatible.mask.operation.problem.descriptor.always.false=<code>#ref</code> is always false #loc
incompatible.mask.operation.problem.descriptor.always.true=<code>#ref</code> is always true #loc
pointless.bitwise.expression.display.name=Bitwise expression can be simplified
pointless.bitwise.expression.ignore.option=Ignore named constant in determining pointless expressions
pointless.bitwise.expression.problem.descriptor=''{1}'' can be replaced with ''{0}'' #loc
pointless.bitwise.expression.simplify.quickfix=Simplify
shift.operation.by.inappropriate.constant.display.name=Shift operation by possibly wrong constant
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=Shift operation <code>#ref</code> by overly large constant value #loc
shift.operation.by.inappropriate.constant.problem.descriptor.negative=Shift operation <code>#ref</code> by negative constant value #loc
add.return.statement.fix.name=Add return statement
set.return.type.to.void.fix.name=Set return type to void
missing.return.statement.error.string=Missing return statement #loc
js.inspection.switch.group.name=Switch statement issues
add.require.amd.module.fix=Add {0} module dependency
add.require.amd.module.group.name=Node.js
replace.redundant.await.family.name=Replace redundant await
shift.out.of.range.family.name=Fix shift value
js.inspection.group.path=JavaScript and TypeScript