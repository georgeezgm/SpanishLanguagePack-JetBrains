action.defaultLombokData.description=Acción para reemplazar los métodos getter/setter/equals/hashcode/toString con la anotación Lombok @Data
action.defaultLombokData.text=@Datos predeterminados
action.defaultLombokEqualsAndHashcode.description=Acción para reemplazar los métodos iguales/código hash con la anotación Lombok @EqualsAndHashcode
action.defaultLombokEqualsAndHashcode.text=Predeterminado @EqualsAndHashCode
action.defaultLombokGetter.description=Acción para reemplazar todos los métodos getter con la anotación @Getter de Lombok
action.defaultLombokGetter.text=@Getter predeterminado
action.defaultLombokLogger.description=Acción para reemplazar todos los registradores con la anotación @Log de Lombok
action.defaultLombokLogger.text=@Log (y amigos)
action.defaultLombokSetter.description=Acción para reemplazar todos los métodos de establecimiento con la anotación @Setter de Lombok
action.defaultLombokSetter.text=@Setter predeterminado
action.defaultLombokToString.description=Acción para reemplazar el método toString con la anotación @ToString de Lombok
action.defaultLombokToString.text=@ToString predeterminado
action.delombokAny.description=Acción para convertir todas las anotaciones de Lombok a métodos básicos de Java
action.delombokAny.text=Todas las anotaciones de Lombok
action.delombokBuilder.description=Acción para convertir la anotación Lombok @Builder al método Vanila Java
action.delombokBuilder.text=@Builder
action.delombokConstructor.description=Acción para convertir las anotaciones @NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor de Lombok en métodos Java básicos
action.delombokConstructor.text=@Constructors
action.delombokData.description=Acción para convertir la anotación @Data de Lombok al método Java básico
action.delombokData.text=@Data
action.delombokDelegate.description=Acción para convertir la anotación @Delegate de Lombok al método Vanila Java
action.delombokDelegate.text=@Delegate
action.delombokEqualsAndHashCode.description=Acción para convertir la anotación Lombok @EqualsAndHashCode al método Vanila Java
action.delombokEqualsAndHashCode.text=@EqualsAndHashCode
action.delombokFieldNameCostants.description=Acción para convertir la anotación @FieldNameConstants de Lombok en un campo Java básico
action.delombokFieldNameCostants.text=@FieldNameConstants
action.delombokGetter.description=Acción para convertir la anotación @Getter de Lombok al método getter de Vanila
action.delombokGetter.text=@Getter
action.delombokLogger.description=Acción para convertir las anotaciones @Log de Lombok (y otras) en campos de registro de Vanila
action.delombokLogger.text=@Log (y amigos)\n
action.delombokSetter.description=Acción para convertir la anotación @Setter de Lombok al método setter de Vanila
action.delombokSetter.text=@Setter
action.delombokStandardException.description=Acción para convertir la anotación @StandardException de Lombok al método Vanila Java
action.delombokStandardException.text=@StandardException
action.delombokSuperBuilder.description=Acción para convertir la anotación Lombok @SuperBuilder al método Vanila Java
action.delombokSuperBuilder.text=@SuperBuilder
action.delombokToString.description=Acción para convertir la anotación Lombok @ToString al método Vanila Java
action.delombokToString.text=@ToString
action.delombokUtilityClass.description=Acción para convertir la anotación @UtilityClass de Lombok al campo Vanila Java
action.delombokUtilityClass.text=@UtilityClass
action.delombokValue.description=Acción para convertir la anotación @Value de Lombok al método Java básico
action.delombokValue.text=@Value
action.delombokWither.description=Acción para convertir la anotación Lombok @Wither al método Vanila Java
action.delombokWither.text=@Wither
checkbox.settings.jps.fix=Se agregó la opción de compilación '-Djps.track.ap.dependencies=false' automáticamente para las versiones de Lombok anteriores a la 1.18.16.
checkbox.settings.version.warning=Habilitar advertencia de versión de Lombok
color.settings.clear=Claro
color.settings.comment=Comentario
color.settings.key=Llave
color.settings.separator=Separador
color.settings.value=Valor
config.warn.annotation-processing.disabled.title=El procesamiento de anotaciones debe estar habilitado para usar Lombok
config.warn.dependency.outdated.message=<br>El proyecto "{0}" y el módulo "{1}" parecen tener agregada una antigua dependencia de lombok.<br>La versión configurada es "{2}", pero ya se ha agregado una versión posterior a "{3}". ha sido lanzado Sí<br><a href="https://projectlombok.org/download">¿Quieres actualizar?</a><br>
config.warn.dependency.outdated.title=Las dependencias de Lombok pueden estar desactualizadas
configurable.name.lombok.config=Configuración de Lombok
dialog.message.logger.field.s.not.private.sfinal.field.named.s.refactor.anyway=Campo de registro: "{0}" no es un campo final privado {1,choice,0#|1 #static} con nombre "{2}". ¿Aún te gustaría refactorizarlo?
dialog.message.this.element.cannot.be.renamed=No puede cambiar el nombre de este elemento.
dialog.title.attention=¡precaución!
filetype.lombok.config.description=Archivo de configuración de Lombok
group.DelombokActionGroup.description=Refactorice su código eliminando las anotaciones de Lombok
group.DelombokActionGroup.text=Delombok
group.LombokActionGroup.description=Refactorice su código con anotaciones de Lombok
group.LombokActionGroup.text=Lombok
inspection.builder.static.import.name=Utilice la importación estática para métodos creados con Lombok
inspection.deprecated.lombok.display.name=Anotaciones de Lombok que pronto quedarán obsoletas
inspection.lombok.display.name=Anotaciones de Lombok
inspection.lombok.getter.may.be.used.display.class.message=La clase ''{0}'' puede usar Lombok @Getter
inspection.lombok.getter.may.be.used.display.field.message=El campo ''{0}'' puede tener un @Getter Lombok
inspection.lombok.getter.may.be.used.display.fix.family.name=Reemplace los métodos getter explícitos con Lombok @Getter
inspection.lombok.getter.may.be.used.display.fix.name=Usando lombok @Getter para ''{0}''
inspection.lombok.getter.may.be.used.display.name=Puedes usar Lombok @Getter
inspection.lombok.group.name.lombok=Lombok
inspection.lombok.group.name.redundant.definitions=Definición innecesaria
inspection.lombok.group.name.redundant.modifiers=Controlador innecesario
inspection.lombok.setter.may.be.used.display.class.message=La clase ''{0}'' puede usar Lombok @Setter
inspection.lombok.setter.may.be.used.display.field.message=El campo ''{0}'' puede tener un @Setter de Lombok
inspection.lombok.setter.may.be.used.display.fix.family.name=Reemplace los métodos de establecimiento explícitos con Lombok @Setter
inspection.lombok.setter.may.be.used.display.fix.name=Usando lombok @Setter para ''{0}''
inspection.lombok.setter.may.be.used.display.name=Puedes usar Lombok @Setter
inspection.message.annotation.copy.duplicate=La anotación ''{0}'' ya existe en el campo, por lo que es redundante con la configuración de onX.
inspection.message.annotation.not.lombok.copyable=Lombok no copia la anotación ''{0}'' al constructor
inspection.message.annotation.only.supported.on.class.or.enum.type=Las anotaciones solo se admiten en clases o enumeraciones.
inspection.message.builder.can.be.used.only=@Builder solo se admite en clases, registros, constructores y métodos.
inspection.message.builder.default.requires.builder.annotation=Para que @Builder.Default sea significativo, @Builder o @SuperBuilder deben estar presentes en la clase.
inspection.message.builder.default.requires.initializing.expression=@Builder.Default requiere una expresión de inicialización ('=algo;').
inspection.message.builder.default.singular.cannot.be.mixed=@Builder.Default y @Singular no se pueden usar juntos.
inspection.message.can.t.singularize.this.name=Este nombre no se puede singularizar. "%s". Especifique el tipo singular explícitamente (por ejemplo, @Singular("oveja"))
inspection.message.cleanup.legal.only.on.local.variable.declaration.inside.block='@Cleanup': sólo se puede utilizar en declaraciones de variables locales dentro de bloques
inspection.message.cleanup.legal.only.on.local.variable.declarations='@Cleanup' solo se puede utilizar en declaraciones de variables locales
inspection.message.cleanup.method.s.not.found.on.target.class='@Cleanup': método '%s()' no encontrado en la clase de destino
inspection.message.cleanup.value.cannot.be.empty.string='@Cleanup': el valor no puede ser una cadena vacía
inspection.message.cleanup.variable.declarations.need.to.be.initialized=Se debe inicializar la declaración de la variable '@Cleanup'.
inspection.message.constructor.noargs.needs.to.be.forced=La clase contiene campos obligatorios. Necesitas forzar NoArgsConstructor.
inspection.message.constructor.with.d.parameters.already.defined=El constructor con el parámetro ''{0}'' ya está definido
inspection.message.constructor.without.parameters.already.defined=Un constructor sin parámetros ya está definido.
inspection.message.custom.log.does.not.allow.topic=@CustomLog no acepta temas.
inspection.message.custom.log.not.configured.correctly=@CustomLog no está configurado correctamente. Establezca log.custom.declaration en lombok.config.
inspection.message.custom.log.requires.topic=@CustomLog necesita un tema.
inspection.message.data.only.supported.on.class.type='@Data' solo se admite en tipos de clase
inspection.message.default.constructor.doesn.t.exist=No hay un constructor predeterminado
inspection.message.delegate.can.only.use.concrete.class.types=@Delegate solo puede usar comodines, matrices, variables de tipo o tipos de clases concretos, no tipos primitivos. '%s' es un tipo de clase no válido
inspection.message.delegate.does.not.support.recursion.delegating=@Delegate no admite la recursividad (delegar a tipos que a su vez tienen miembros @Delegate). El miembro "%s" es un @Delegate de tipo "%s"
inspection.message.delegate.legal.only.on.instance.fields=@Delegate solo se puede utilizar en campos de instancia o métodos de instancia que no toman argumentos.
inspection.message.delegate.legal.only.on.no.argument.methods=@Delegate solo se puede utilizar en métodos de instancia que no toman argumentos.
inspection.message.delegate.unknown.type.method=Método de símbolo {0} no encontrado
inspection.message.equals.and.hashcode.only.supported.on.class.type=@EqualsAndHashCode solo se admite en tipos de clase
inspection.message.exclude.are.mutually.exclusive.exclude.parameter.will.be.ignored=Excluir y de son mutuamente excluyentes. El parámetro 'excluir' se ignora
inspection.message.existing.builder.must.be.abstract.static.inner.class=El constructor existente debe ser una clase interna estática abstracta.
inspection.message.field.name.constants.inner.type=El tipo interno @FieldNameConstants ya existe, pero asEnum={0} no coincide con un tipo existente
inspection.message.field.name.constants.only.supported.on.class.enum.or.field.type='@FieldNameConstants' solo se admite en clases, enumeraciones o tipos de campos
inspection.message.field.name.constants.only.supported.on.class.or.enum='@FieldNameConstants' solo se admite en clases o enumeraciones
inspection.message.field.s.does.not.exist=El campo %s no existe.
inspection.message.field.s.does.not.exist.exclude=El campo ''{0}'' no existe
inspection.message.field.s.does.not.exist.field=El campo ''{0}'' no existe
inspection.message.field.s.would.have.been.excluded.anyway=El campo ''{0}'' ha sido excluido por la fuerza
inspection.message.generating.equals.hashcode.implementation=Incluso si esta clase no extiende java.lang.Object, generará una implementación igual/hashCode sin llamar a la clase principal. Si es intencional, agregue '(call Super=false)' al tipo.
inspection.message.generating.equals.hashcode.with.super.call=Crear equals/hashCode usando una llamada principal java.lang.Object no tiene sentido.
inspection.message.getter.only.supported.on.class.enum.or.field.type='@Getter' solo se admite en clases, enumeraciones o tipos de campos
inspection.message.jacksonized.builder.on.abstract.classes=El constructor de una clase abstracta no se puede @Jacksonizar (esto provocaría que el constructor no se utilice).
inspection.message.jacksonized.cannot.process.both.builder.superbuilder=@Jacksonized no puede manejar @Builder y @SuperBuilder en la misma clase.
inspection.message.jacksonized.jsondeserialize.already.exists=Ya tienes @JsonDeseriaize en tu clase. Elimine @JsonDeserialize o elimine @Jacksonized y configure Jackson manualmente.
inspection.message.jacksonized.requires.builder.superbuilder=@Jacksonized tiene sentido solo cuando @Builder o @SuperBuilder están presentes.
inspection.message.lazy.does.not.work.with.access.level.none='Lazy' no funciona en el nivel de acceso. NINGUNO.
inspection.message.lazy.not.supported.for.getter.on.type='lazy' no es compatible con @Getter especificado en el tipo
inspection.message.lazy.requires.field.initialization='lazy' requiere inicialización del campo.
inspection.message.lazy.requires.field.to.be.private.final='perezoso' requiere que los campos sean privados y finales
inspection.message.lombok.annotation.deprecated.not.supported=La anotación de Lombok ''{0}'' está obsoleta y no es compatible con el complemento de Lombok. Utilice ''{1}'' en su lugar.
inspection.message.lombok.annotations.are.not.allowed.on.builder.class=No se permiten anotaciones de Lombok en las clases de constructor.
inspection.message.lombok.builder.needs.proper.constructor.for.this.class=Lombok @Builder requiere un constructor apropiado para esta clase
inspection.message.lombok.does.not.know=Lombok no puede crear un método de construcción singular de tipo '%s'. El método constructor no se crea.
inspection.message.lombok.needs.default.constructor.in.base.class=Lombok requiere un constructor predeterminado en la clase base
inspection.message.method.s.matched.static.constructor.name.already.defined=El método ''{0}'' que coincide con staticConstructorName ya está definido
inspection.message.method.s.with.d.parameters.matched.static.constructor.name.already.defined=El método ''{0}'' con el parámetro ''{1}'' que coincide con staticConstructorName ya está definido
inspection.message.not.allowed.in.old.style.for.loops=''{0}'' no está permitido en bucles for antiguos
inspection.message.not.allowed.with.lambda.expressions=''{0}'' no está permitido en la expresión lambda.
inspection.message.not.compatible.with.array.initializer.expressions=''{0}'' no es compatible con expresiones de inicializador de matriz. Utilice el formulario completo (nuevo int[ ] '{'... '}', no '{'... '}')
inspection.message.not.generated.s.method.with.same.name.already.exists='%s'() no fue creado. Ya existe un método con el mismo nombre.
inspection.message.not.generated.s.method.with.similar.name.s.already.exists=No genera '%s'(). Ya existe un método con nombre similar '%s'
inspection.message.not.generating.constant=No cree una constante para este campo. El nombre de la constante es el mismo que el nombre del campo.
inspection.message.not.generating.equals.hashcode=No genera iguales ni hashCode. Ya existe un método con uno de estos nombres. (Todos estos métodos se generan o no se genera ninguno).
inspection.message.not.generating.field.s.field.with.same.name.already.exists=El campo %s no se creará. Ya existe un campo con el mismo nombre.
inspection.message.not.generating.getter.for.this.field=No crea un captador para este campo. @Accessors no es adecuado para listas de prefijos.
inspection.message.not.generating.s.method.with.that.name.already.exists=No produce %s(). Ya existe un método con el mismo nombre.
inspection.message.not.generating.setter.for.this.field.it=No cree un definidor para este campo. @Accessors no es adecuado para listas de prefijos.
inspection.message.not.generating.setter.for.this.field.setters=No cree un definidor para este campo. No se puede crear un definidor para un campo final.
inspection.message.not.generating.wither=No cree un marchitamiento para este campo. La cruz no se puede crear en campos estáticos.
inspection.message.not.generating.wither.for.this.field.withers=No cree un marchitamiento para este campo. La cruz no se puede crear en campos que comiencen con $.
inspection.message.not.generating.wither.for.this.field.withers.cannot.be.generated=No cree un marchitamiento para este campo. Withers no se puede crear en campos finales inicializados.
inspection.message.obtain.via.is.static.true.not.valid.unless.method.has.been.set=@ObtainVia(isStatic=true) no es válido si no se establece el 'método'.
inspection.message.on.local.variable.requires.initializer.expression=La variable local ''{0}'' requiere una expresión inicializadora
inspection.message.s.legal.only.on.classes.enums=@%s solo se puede usar en clases y enumeraciones
inspection.message.s.not.valid.identifier=%s no es un identificador válido.
inspection.message.s.only.supported.on.class.or.field.type='@%s' solo se admite en tipos de clase o campo
inspection.message.slf4j.logger.defined.explicitly=El registrador Slf4j está definido explícitamente. Utilice la anotación Lombok @Slf4j en su lugar.
inspection.message.sneakythrows.calls.to.sibling.super.constructors.excluded=@SneakyThrows siempre excluye las llamadas al constructor hijo/padre. @SneakyThrows se ignora porque no hay otro código dentro del constructor.
inspection.message.standardexception.accesslevel.none.not.valid=AccessLevel.NONE no es válido aquí
inspection.message.standardexception.class.only.supported.on.class=@StandardException solo se admite en clases
inspection.message.standardexception.should.extend.throwable=Para usar @StandardException debes extender el tipo Throwable
inspection.message.superbuilder.can.be.used.on.classes.only=@SuperBuilder solo se admite en clases.
inspection.message.superbuilder.can.be.used.on.static.inner.classes.only=@SuperBuilder no es compatible con clases anidadas no "estáticas".
inspection.message.synchronized.field.is.not.static=El campo ''{0}'' no es estático y no se puede utilizar en este método estático
inspection.message.synchronized.legal.only.on.concrete.methods='@Synchronized' solo se puede utilizar en métodos concretos.
inspection.message.synchronized.legal.only.on.methods.in.classes.enums=@Synchronized solo se puede utilizar en métodos de clases y enumeraciones.
inspection.message.syntax.either.obtain.via.field=La sintaxis es @ObtainVia(fieldv= "fieldName") o @ObtainVia(method="methodName").
inspection.message.to.string.only.supported.on.class.or.enum.type=@ToString solo se admite en tipos de clase o enumeración
inspection.message.utility.class.already.marks.class.final=@UtilityClasss ya está marcando la clase como final.
inspection.message.utility.class.already.marks.fields.static=@UtilityClasss ya está marcando el campo como estático.
inspection.message.utility.class.already.marks.inner.classes.static=@UtilityClasss ya está marcando la clase interna como estática.
inspection.message.utility.class.already.marks.methods.static=@UtilityClasss ya está marcando el método como estático.
inspection.message.utility.class.automatically.makes.class.static=@UtilityClass configura automáticamente una clase como estática, pero esta clase no se puede configurar como estática.
inspection.message.utility.class.cannot.be.placed=@UtilityClass no se puede colocar en métodos locales ni en clases internas anónimas ni en clases anidadas dentro de dichas clases.
inspection.message.utility.class.only.supported.on.class=@UtilityClass solo se admite en clases (no en interfaces, enumeraciones o anotaciones).
inspection.message.utility.classes.cannot.have.declared.constructors=@UtilityClasses no puede tener un constructor declarado.
inspection.message.val.already.marks.variables.final='val' ya marca variable final.
inspection.message.val.works.only.on.local.variables='val' solo funciona con variables locales y bucles foreach\n
inspection.message.value.already.marks.class.final=@Value ya está marcando la final de clase.
inspection.message.value.already.marks.non.static.fields.final=@Value ya está marcando un campo no estático como final.
inspection.message.value.already.marks.non.static.package.local.fields.private=@Value ya está marcando campos no estáticos y locales del paquete como privados.
inspection.message.value.only.supported.on.class.type='@Value' solo se admite en tipos de clase
inspection.message.var.works.only.on.local.variables.on.for.foreach.loops='var' sólo funciona con variables locales y bucles for/foreach
inspection.message.wither.needs.constructor.for.all.fields.d.parameters=@Wither requiere constructor para todos los campos (parámetro %d)
inspection.message.wither.only.supported.on.class.or.field=@Wither solo se admite en clases o campos.
inspection.redundant.modifiers.utility.class.lombok.display.name=Controlador @UtilityClass
inspection.redundant.modifiers.val.lombok.display.name=Final innecesario antes de 'val'
inspection.redundant.modifiers.value.lombok.display.name=@Controlador de valor
inspection.redundant.slf.4.j.definition.display.name=@Slf4j
inspection.springqualifiercopyable.lombok.display.name=@Qualifier no se puede copiar a Lombok
inspection.static.method.import.error=Las importaciones estáticas de métodos generados con Lombok no son compatibles con javac
intention.category.lombok=Java/Lombok
intention.family.name.slf4j.annotation=Reemplazo de campos del registrador con la anotación @Slf4j
intention.name.create.new.field.s=Crear nuevo campo ''{0}''
intention.name.replace.with.lombok=Cambiar a Lombok
make.abstract.and.static.modifier.quickfix=Establecer ''{0}'' como abstracto y estático
make.abstract.and.static.modifier.quickfix.family.name=Cambiar controlador
notification.enable.annotation.processing=Habilitar el procesamiento de anotaciones
notification.group.lombok=Problemas de integración de Lombok
plugin.settings.title=Lombok
popup.content.java.annotation.processing.has.been.enabled=El procesamiento de anotaciones de Java está habilitado
replace.0.with.explicit.type.lombok=Convertir ''{0}'' a un tipo explícito (Lombok)
replace.explicit.type.with.0.lombok=Cambiar tipo explícito a ''{0}'' (Lombok)
replace.synchronized.lombok.intention=Cambiar a Lombok @Sincronizado
replace.with.annotations.lombok=Reemplazar con anotaciones (Lombok)
