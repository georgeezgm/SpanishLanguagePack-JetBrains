DFAStrings.CppDFAArrayIndexOutOfBoundsDescription=Informa una expresión de acceso a variable de puntero o matriz donde el índice puede estar fuera de los límites de la matriz o del búfer asignado.
DFAStrings.CppDFAArrayIndexOutOfBoundsTitle=Expresión de acceso a matriz donde el índice puede estar fuera de rango
DFAStrings.CppDFAConstantConditionsDescription=Informa una expresión cuya condición es siempre verdadera o falsa y cuyo valor se ha demostrado estáticamente que es una constante.
DFAStrings.CppDFAConstantConditionsTitle=Condiciones que siempre son verdaderas o falsas
DFAStrings.CppDFAConstantFunctionResultDescription=Informa una función cuyo valor de retorno es siempre la misma constante.
DFAStrings.CppDFAConstantFunctionResultTitle=Una función cuyo valor de retorno es siempre la misma constante
DFAStrings.CppDFAConstantParameterDescription=Siempre informa los parámetros de función con el mismo valor
DFAStrings.CppDFAConstantParameterTitle=Parámetros de función que siempre tienen el mismo valor.
DFAStrings.CppDFADeletedPointerDescription=Informa el uso de un puntero que hace referencia a la memoria que ya ha sido eliminada por el operador de eliminación o la función free(void* ptr)
DFAStrings.CppDFADeletedPointerTitle=Dónde utilizar punteros que hacen referencia a la memoria eliminada
DFAStrings.CppDFAEndlessLoopDescription=Informa declaraciones 'para', 'mientras', 'hacer-mientras' y 'goto' que deben finalizar lanzando una excepción.
DFAStrings.CppDFAEndlessLoopTitle=Declaración de bucle infinito
DFAStrings.CppDFAInfiniteRecursionDescription=Informa una función que se llama a sí misma infinitamente a menos que se produzca una excepción.
DFAStrings.CppDFAInfiniteRecursionTitle=Una función que se llama a sí misma infinitamente.
DFAStrings.CppDFAInvalidatedMemoryDescription=Informa una referencia al contenido de un contenedor invalidado.
DFAStrings.CppDFAInvalidatedMemoryTitle=Una referencia al contenido de un contenedor invalidado.
DFAStrings.CppDFALocalValueEscapesFunctionDescription=Informa referencias a valores locales que escapan de una función mediante retorno o asignación a una variable o campo global.
DFAStrings.CppDFALocalValueEscapesFunctionTitle=Referencia a la función de escape de variable local
DFAStrings.CppDFALocalValueEscapesScopeDescription=Informa variables que tienen una referencia a una variable local que escapa de su alcance.
DFAStrings.CppDFALocalValueEscapesScopeTitle=Una referencia a una variable local que escapa de su alcance.
DFAStrings.CppDFALoopConditionNotUpdatedDescription=Informa una condición de bucle que no se actualiza dentro del bucle
DFAStrings.CppDFALoopConditionNotUpdatedTitle=La condición del bucle no se actualiza dentro del bucle
DFAStrings.CppDFANotInitializedFieldDescription=Campos de informes que pueden no haberse inicializado antes de usarse. La inicialización y el uso pueden ocurrir en diferentes funciones.
DFAStrings.CppDFANotInitializedFieldTitle=Campos que pueden no haberse inicializado antes de su uso
DFAStrings.CppDFANullDereferenceDescription=Informa desreferencias de punteros que pueden contener nullptr
DFAStrings.CppDFANullDereferenceTitle=Desreferencia de un puntero que puede contener nullptr
DFAStrings.CppDFATimeOverDescription=La verificación del flujo de datos ha alcanzado un límite de tiempo o de memoria y no se puede evaluar en modo consciente o no consciente del contexto.
DFAStrings.CppDFATimeOverTitle=Tiempo de espera de verificación del flujo de datos
DFAStrings.CppDFAUnreachableCodeDescription=Informa fragmentos de código que no se ejecutan en ningún flujo de control y que se pueden eliminar de forma segura
DFAStrings.CppDFAUnreachableCodeTitle=Código no disponible
DFAStrings.CppDFAUnreachableFunctionCallDescription=Las llamadas informan sobre funciones que nunca se utilizan. Esa función tampoco se ejecuta en absoluto.
DFAStrings.CppDFAUnreachableFunctionCallTitle=Función cuya llamada nunca se utiliza
DFAStrings.CppDFAUnreadVariableDescription=Informa variables locales que se declaran pero a las que nunca se accede para su lectura.
DFAStrings.CppDFAUnreadVariableTitle=Variable local declarada pero nunca accedida para lectura
DFAStrings.CppDFAUnusedValueDescription=Informa valores de variables que nunca se han utilizado después de ser sustituidos.
DFAStrings.CppDFAUnusedValueTitle=Valor de variable que nunca se utiliza después de ser sustituido
Strings.AClassDefinitionCanBeMarkedAsFinalSoItCannotBeInheritedFrom=Puede marcar una definición de clase como final para que no se pueda heredar de la clase.
Strings.AClassIsNeverUsed=La clase no se utiliza en absoluto.
Strings.ACoroutineRelatedFunctionWhichIsRequiredByTheCStandardCannotBeResolved=Las funciones relacionadas con rutinas requeridas en C++ 20 no se pueden resolver
Strings.ADeclarationDoesNotDeclareAnything=Declaración no declara nada
Strings.ADeclarationSpecifierIsIgnoredWhenThereAreNoDeclarators=Los especificadores de declaración se ignoran si no hay un declarador.
Strings.ADeclaratorIsNeverUsed=El declarante no se utiliza en absoluto.
Strings.ADeclaratorIsOnlyAssignedButNeverAccessed=El declarante solo se asigna y no se accede a él en absoluto
Strings.ADeclaratorIsUsedOnlyInUnevaluatedContext=Solo se usa en contextos donde el declarador no se evalúa.
Strings.AEnumeratorIsNeverUsed=El enumerador no se utiliza en absoluto
Strings.AFormatStringOfBoostFormatContainsALegacyPrintfLikeCodeTypeSpecifierIsNotTakenIntoAccount=La cadena de formato boost\:\:format contiene código existente similar a printf. Los especificadores de tipo no se consideran
Strings.AFormatStringOfBoostFormatContainsAnErroneousFormatCode=La cadena de formato en boost\:\:format contiene una directiva de formato no válida
Strings.AFunctionDefinitionInAHeaderFileThatWillCauseMultipleDefinitionLinkageError=Hay múltiples definiciones de funciones dentro del archivo de encabezado que causarán un error de enlace de definición
Strings.AFunctionIsNotImplemented=La función no está implementada
Strings.AFunctionOrALambdaWithNonVoidReturnTypeShouldReturnAValue=Las funciones o lambdas con tipos de retorno distintos de void deben devolver un valor.
Strings.AFunctionOrALambdaWithNonVoidReturnTypeShouldReturnAValue8=Las funciones o lambdas con tipos de retorno distintos de void deben devolver un valor.
Strings.ALambdaCaptureIsNeverUsed=La captura lambda no se utiliza en absoluto
Strings.ALocalDeclarationHidesAnotherLocalDeclaration=Las declaraciones locales eclipsan otras declaraciones locales
Strings.ALocalDeclarationInsideALambdaHidesAnUncapturedLocalDeclaration=Las declaraciones locales dentro de lambda oscurecen las declaraciones locales no capturadas
Strings.ALocalVariableMightNotBeInitialized=Es posible que la variable local no se inicialice
Strings.ANonOverridingVirtualFunctionInAFinalOrSealedClassCannotBeOverriddenSoThevirtualSpecifierIsRedundant=El especificador 'virtual' es innecesario porque las funciones virtuales no anuladas dentro de una clase final o sellada no se pueden redefinir.
Strings.APolymorphicClassWithANonVirtualPublicDestructor=Clases polimórficas con destructores públicos no virtuales.
Strings.APrivateSpecialMemberFunctionShouldBeDefinedOrDeleted=Las funciones de miembros especiales privados deben definirse o eliminarse.
Strings.AStandardAlgorithmAcceptingRangeIteratorsIsUsedInsteadOfTheVariantAcceptingAnIteratorAndACount=Se utilizó el algoritmo estándar que toma un iterador de rango en lugar de la variante que toma varios iteradores.
Strings.ATemplateParameterFromAnOuterScopeIsShadowedByADeclarationWithTheSameName=Los parámetros de plantilla en el ámbito externo están ocultos por declaraciones del mismo nombre
Strings.ATypeAliasIsNeverUsed=Los alias de tipo no se utilizan en absoluto
Strings.ATypeTraitCanBeSimplifiedUsingATemplateAliasOrAVariableTemplate=Puede simplificar los atributos de tipo utilizando alias de plantilla o plantillas de variables.
Strings.AVariableDefinitionInAHeaderFileThatWillCauseMultipleDefinitionLinkageError=Hay definiciones de variables dentro del archivo de encabezado que causarán múltiples errores de enlace de definición.
Strings.AVirtualFunctionIsMarkedfinalAndDoesNotOverrideABaseFunction=La función virtual está marcada como "final" y no anula la función base.
Strings.AbstractFinalClass=Clase final abstracta
Strings.AccessSpecifierDoesNotAffectAnyDeclaration=Los especificadores de acceso no tienen efecto en las declaraciones.
Strings.AccessSpecifierDoesNotChangeAccessibilityLevel=El especificador de acceso no cambia el nivel de accesibilidad
Strings.AddingCvQualifiersToReferencesHasNoEffect=Agregar cv-qualifier a la referencia no tiene ningún efecto
Strings.AddingCvQualifiersToReferencesHasNoEffect9=Agregar cv-qualifier a la referencia no tiene ningún efecto
Strings.AlgorithmAcceptingAnIteratorAndACountCanBeUsed=Puedes escribir un algoritmo que requiera un iterador y un conteo.
Strings.AlgorithmAcceptingIteratorsIsUsedInsteadOfTheCorrespondingAlgorithmFromStdRanges=Se utilizó un algoritmo que toma un iterador distinto del algoritmo correspondiente en std\:\:ranges.
Strings.AlgorithmOperatingOnRangesCanBeUsed=Puedes utilizar algoritmos que operan en rangos.
Strings.AnAbstractFinalClassIsMarkedAsfinalOrsealed=La clase final del resumen está marcada como 'final' o 'sellada'
Strings.AnAccessSpecifierDoesNotAffectAnyDeclarationAndIsRedundant=Los especificadores de acceso no tienen efecto en las declaraciones y son innecesarios.
Strings.AnAccessSpecifierDoesNotChangeAccessibilityLevelAndIsRedundant=Los especificadores de acceso no cambian los niveles de accesibilidad y son innecesarios.
Strings.AnArgumentOfBoostFormatShouldContainEitherPositionalNNOrSerialsArgumentsNotBoth=Los argumentos para impulsar\:\:formato deben contener solo uno de los siguientes argumentos: argumentos posicionales (%N%, %|N$...|) o seriales (%|...|, %s).
Strings.AnIncompleteTypeIsUsedInsideATemplateDeclarationOrDefinition=Tipo incompleto utilizado en la declaración o definición de plantilla
Strings.AnObjectMemberMightNotBeInitialized=Es posible que los miembros del objeto no se inicialicen
Strings.AnOverrideFunctionRedefinesADefaultParameterArgumentPreviouslyDefinedInABaseFunction=Una función de anulación anula los argumentos de parámetros predeterminados definidos en la función base.
Strings.AwaiterTypeIsNotAClass=El tipo de camarero no es una clase.
Strings.BackslashAndNewlineAreSeparatedBySpace=Las barras invertidas y las nuevas líneas están separadas por espacios.
Strings.BackslashIsNotALineContinuatorBecauseThereIsASpaceBetweenItAndTheEndOfTheLine=Hay un espacio entre la barra invertida y el final de la línea, por lo que la barra invertida no continúa la línea.
Strings.BadFormatCodeForBoostFormat=Directiva de formato no válida en formato boost\:\:
Strings.BinaryOperatorActsOnEqualOperands=Los operadores binarios operan con operandos iguales
Strings.BinaryOperatorActsOnEqualOperands40=Los operadores binarios operan con operandos iguales
Strings.BinaryOperatorActsOnIdenticalOperands=Los operadores binarios operan con operandos coincidentes.
Strings.BinaryOperatorActsOnIdenticalOperands39=Los operadores binarios operan con operandos coincidentes.
Strings.BindingRValueToLValueReferenceIsNonStandardMicrosoftCExtension=Vincular un valor r mediante una referencia de valor l es una extensión no estándar de Microsoft C++
Strings.BindingRValueToLValueReferenceIsNonStandardMicrosoftCExtension2=Vincular un valor r mediante una referencia de valor l es una extensión no estándar de Microsoft C++
Strings.CStyleCastIsUsedInsteadOfACCast=Casting estilo C en lugar de casting C++
Strings.CStyleCastIsUsedInsteadOfACCast1=Casting estilo C en lugar de casting C++
Strings.CallOfDeletedCopyConstructorElidedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension=La llamada al constructor de la copia eliminada se ocultó durante la inicialización de la copia. Esta es una extensión no estándar de Microsoft C++.
Strings.CallOfDeletedCopyConstructorElidedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension5=La llamada al constructor de la copia eliminada se ocultó durante la inicialización de la copia. Esta es una extensión no estándar de Microsoft C++.
Strings.CallToAVirtualFunctionInsideAConstructorDestructorIsResolvedAtCompileTime=Las llamadas a funciones virtuales dentro de constructores/destructores se resuelven en tiempo de compilación
Strings.CallToAVirtualFunctionInsideAConstructorDestructorWillResultInAPureVirtualFunctionCall=Llamar a una función virtual dentro de un constructor/destructor da como resultado una llamada de función virtual pura.
Strings.CallsToPureVirtualFunctionsInsideConstructorsAndDestructorsAreARuntimeError=Llamar a funciones virtuales puras dentro de constructores y destructores genera un error de tiempo de ejecución
Strings.CannotResolveARequiredCoroutineFunction=No se puede resolver la función de rutina requerida
Strings.CastIsRedundantAndCanBeDeleted=El casting es innecesario y se puede eliminar.
Strings.CastingFromNullptrToPointerTypeWithReinterpretCastIsNonStandardMicrosoftCExtension=La conversión de nullptr al tipo de puntero usando reinterpret_cast es una extensión no estándar de Microsoft C++
Strings.CastingFromNullptrToPointerTypeWithReinterpretCastIsNonStandardMicrosoftCExtension1=La conversión de nullptr al tipo de puntero usando reinterpret_cast es una extensión no estándar de Microsoft C++
Strings.ClassCanBeMadeFinal=Las clases se pueden hacer definitivas.
Strings.ClassConstructorDoesntInitializeAFieldExplicitlyOrImplicitly=El constructor de clases no inicializa campos explícita o implícitamente
Strings.ClassIsAbstractButNotExplicitlyDeclaredAsSuch=Esta clase es abstracta, pero no se declara explícitamente como tal.
Strings.ClassIsNeverUsed=La clase no se utiliza en absoluto.
Strings.ClassMemberFunctionHidesANonVirtualFunctionFromABaseClass=Las funciones de los miembros de la clase ocultan funciones no virtuales de la clase base
Strings.ClassMemberFunctionHidingANonVirtualFunctionFromABaseClass=Funciones miembro de clase que ocultan funciones no virtuales de la clase base
Strings.ClassShouldHaveAUserDefinedConstructorBecauseOfAnUninitializedDataMember=Los miembros de datos no inicializados requieren un constructor personalizado en la clase.
Strings.ClassShouldHaveAUserDefinedConstructorBecauseOfAnUninitializedDataMember25=Los miembros de datos no inicializados requieren un constructor personalizado en la clase.
Strings.ComparisonOfUnsignedExpressionWith=Comparación de expresiones sin signo con ceros.
Strings.ComparisonOfUnsignedExpressionWith41=Comparación de expresiones sin signo con ceros.
Strings.CompileTimeConstantExpressionCanBeReplacedByEithertrueOrfalse=Las expresiones constantes en tiempo de compilación se pueden reemplazar por "verdadero" o "falso"
Strings.CompileTimeIntegralConstantExpressionOrNullptrIsConvertedToBoolAndCanBeReplacedBytrueOrfalse=En el momento de la compilación, las expresiones constantes que son números enteros o nullptr se convierten a booleanas y se pueden reemplazar por "verdadero" o "falso".
Strings.ConceptIsNeverUsed=El concepto no se utiliza en absoluto.
Strings.ConstQualificationOfParametersHasAnEffectOnlyInFunctionDefinitions=La calificación constante de los parámetros sólo tiene efecto en las definiciones de funciones.
Strings.ConstQualifiedParameterInAFunctionDeclaration=Parámetros normalizados constantes en declaraciones de funciones
Strings.ConstevalIfIsAlwaysConstantDescription=Consteval si es siempre una constante
Strings.ConstevalIfIsAlwaysConstantTitle=Consteval si es siempre una constante
Strings.ConstructorOfASmartPointerBoostStdSharedPtrUniquePtrIsUsedInsteadOfTheCorrespondingMakeSharedMakeUniqueMakeFunctionsAreExceptionSafeAndMoreEfficient=Se utilizaron los constructores de punteros inteligentes (boost/std\:\:shared_ptr/unique_ptr) en lugar de sus homólogos make_shared/make_unique. La función Make es segura para excepciones y es más eficiente.
Strings.ConstructorOfSmartPointerIsUsedInsteadOfItsMakeFunction=Se utiliza el constructor de puntero inteligente en lugar de la función make
Strings.CppConditionalExpressionCanBeSimplifiedDescription=Las expresiones condicionales se pueden simplificar.
Strings.CppConditionalExpressionCanBeSimplifiedTitle=Las expresiones condicionales se pueden simplificar.
Strings.CppRedundantComplexityInComparison=Las expresiones se pueden simplificar.
Strings.CppRedundantConditionalExpressionDescription=Expresión condicional duplicada
Strings.CppRedundantConditionalExpressionTitle=Expresión condicional duplicada
Strings.CppRedundantDereferencingAndTakingAddressDescription=Eliminación de referencias y adquisición de direcciones innecesarias
Strings.CppRedundantDereferencingAndTakingAddressTitle=Eliminación de referencias y adquisición de direcciones innecesarias
Strings.DeclarationAndAssignmentCanBeJoined=La declaración y la cesión se pueden combinar
Strings.DeclarationDoesNotDeclareAnything=Declaración no declara nada
Strings.DeclarationOfANonOverridingVirtualFunctionInAFinalOrSealedClass=Declaración de una función virtual que no se anula en una clase final o sellada
Strings.DeclarationOfAVariableAndAssignmentToItCanBeJoined=La declaración de variables y sus asignaciones se puede realizar por separado.
Strings.DeclarationSpecifierWithNoDeclarators=Especificador de declaración sin declarador
Strings.DeclarationSpecifierlongCanNotBeCombinedWithfloat=El especificador de declaración 'largo' no se puede combinar con 'flotante'
Strings.DeclaratorDisambiguatedAsAFunctionDeclaration=Como declaración de función, el declarador está separado.
Strings.DeclaratorIsDisambiguatedAsAFunctionDeclarationMakeSureAVariableDefinitionIsNotIntendedInstead=El declarador se separa en una declaración de función. Asegúrese de que la definición de su variable no sea la que pretendía.
Strings.DeclaratorIsNeverUsed=Declarador no utilizado en absoluto
Strings.DeclaratorIsOnlyAssignedButNeverAccessed=El declarante solo se asigna y no se accede a él en absoluto
Strings.DeclaratorIsUsedOnlyInUnevaluatedContext=El declarante solo se usa en un contexto no evaluado
Strings.DefaultCaseIsNotHandledInASwitchStatement=Caso predeterminado no manejado en la declaración de cambio
Strings.DefaultCaseIsNotHandledInASwitchStatement20=Caso predeterminado no manejado en la declaración de cambio
Strings.DefaultInitializationOfAConstQualifiedObjectOfATypeWithoutAUserProvidedDefaultConstructor=Por defecto inicializa un objeto calificado de forma constante de un tipo sin un constructor predeterminado proporcionado por el usuario.
Strings.DefaultInitializationOfAConstQualifiedObjectOfATypeWithoutAUserProvidedDefaultConstructor3=Por defecto inicializa un objeto calificado de forma constante de un tipo sin un constructor predeterminado proporcionado por el usuario.
Strings.DefaultedSpecialMemberFunctionIsImplicitlyDeleted=Las funciones de miembros especiales establecidas como predeterminadas se eliminan implícitamente
Strings.DeletingAVoidPointer=Eliminar un puntero vacío
Strings.DeletingAVoidPointerIsUndefinedBehavior=Eliminar un puntero vacío es un comportamiento indefinido
Strings.DependentTemplateWithouttemplateKeyword=Plantilla dependiente sin palabra clave 'plantilla'
Strings.DependentTemplateWithouttemplateKeyword24=Plantilla dependiente sin palabra clave 'plantilla'
Strings.DependentTypeWithouttypenameKeyword=Tipo dependiente sin palabra clave 'typename'
Strings.DependentTypeWithouttypenameKeyword23=Tipo dependiente sin palabra clave 'typename'
Strings.DeprecatedregisterStorageClassSpecifier=Especificador de clase de almacenamiento 'registro' obsoleto
Strings.DereferenceOperatorLimitIsExceeded=Se superó el límite del operador de desreferencia
Strings.DereferenceOperatorLimitIsExceeded10=Se superó el límite del operador de desreferencia
Strings.DetectsLeakProneResourceAcquisitionFreeingConstructs=Detectar construcciones de adquisición/liberación de recursos propensas a fugas
Strings.DontIntroduceANamespaceDefinitionOnlyForClassSpecializationSpecializationCanBeDefinedUsingQualifiedClassName=No inserte definiciones de espacios de nombres únicamente por motivos de especialización de clases. Las especializaciones se pueden definir utilizando nombres de clase completos.
Strings.DontIntroduceAVariableBeforeYouNeedToUseIt=No insertes variables que no necesitas
Strings.ElaboratedTypeSpecifierIsRedundantAndCanBeDeleted=El especificador de tipo detallado no es necesario y puede eliminarse
Strings.EmptyParameterListInLambdaDeclaratorCanBeDeleted=Se pueden eliminar las listas de parámetros vacías en los declaradores lambda
Strings.EntityIsDeprecated=La entidad no se utiliza
Strings.EntityIsDeprecated37=La entidad no se utiliza
Strings.EnumeratorIsNeverUsed=Emulador no usado en absoluto
Strings.ExplicitSpecializationInNonNamespaceScope=Especialización explícita en un ámbito que no es de espacio de nombres
Strings.ExplicitSpecializationsOfATemplateInNonNamespaceScope=Especialización explícita de plantillas en ámbitos que no son espacios de nombres
Strings.ExplicitlyDefaultedSpecialMemberFunctionIsImplicitlyDeleted=Las funciones miembro especiales que se establecen explícitamente en valores predeterminados se eliminan implícitamente.
Strings.ExpressionWhichEvaluatesToZeroIsUsedAsANullPointerConstant=Las expresiones que se evalúan como cero se utilizan como constantes de puntero nulo.
Strings.ExpressionWhichEvaluatesToZeroIsUsedAsANullPointerConstant27=Las expresiones que se evalúan como cero se utilizan como constantes de puntero nulo.
Strings.FinalFunctionInAFinalClass=Función final en la clase final
Strings.FinalNonOverridingVirtualFunction=Función virtual final sin anular
Strings.ForExampleWhenIteratingOnKeyValuePairsStdViewsKeysAllowsToIgnoreTheValues=Por ejemplo, al iterar sobre pares clave-valor, puede usar std\:\:views\:\:keys para ignorar los valores.
Strings.ForLoopCanBeReplacedWithWhileLoop=Puede cambiar el bucle for a un bucle while.
Strings.ForLoopWithoutInitStatementAndUpdateExpressionIsEquivalentToWhileLoop=Un bucle for sin una declaración init y una expresión de actualización es lo mismo que un bucle while.
Strings.FormatStringContainsAPotentialError=La cadena de formato contiene un posible error
Strings.FormatStringContainsAnInvalidPrintfFormatSpecifier=La cadena de formato contiene un especificador de formato printf no válido
Strings.ForwardEnumDeclarationWithoutUnderlyingTypeDescription=ISO C++ prohíbe la declaración directa de enumeraciones sin tipos primitivos
Strings.ForwardEnumDeclarationWithoutUnderlyingTypeTitle=Declaración de enumeración directa sin tipo base
Strings.FunctionIsNotImplemented=Función no implementada
Strings.FunctionParameterIsNeverUsed=No se utilizan parámetros de función en absoluto.
Strings.FunctionResultShouldBeUsedDescription=La función devuelve un valor del tipo que debe procesarse en la ubicación de la llamada.
Strings.FunctionResultShouldBeUsedTitle=Se debe utilizar el resultado de la función.
Strings.FunctionReturnsByConstValue=Retorno de función basado en valor constante
Strings.FunctionalStyleCastIsUsedInsteadOfACCast=Se utiliza la conversión de estilo de función en lugar de la conversión de C++
Strings.FunctionalStyleCastIsUsedInsteadOfACCast2=Se utiliza la conversión de estilo de función en lugar de la conversión de C++
Strings.GuardedHeaderHasAlreadyBeenIncluded=Protector de cabecera ya incluido.
Strings.GuardedHeaderHasAlreadyBeenIncluded50=Protector de cabecera ya incluido.
Strings.HidingAnUncapturedLocalDeclaration=Ocultar variables locales que no se capturan
Strings.HidingLocalDeclaration=Ocultar declaraciones locales
Strings.IfStatementWithConstantConditionCanBeReplacedByifConstexpr=Cuando las declaraciones que contienen condiciones constantes se pueden reemplazar con 'if constexpr'
Strings.IfStatementWithConstantConditionCanBeReplacedByifConstexpr14=Cuando las declaraciones que contienen condiciones constantes se pueden reemplazar con 'if constexpr'
Strings.IfStdIsConstantEvaluatedCanBeReplacedDescription=Puedes sustituir 'si' por 'si consteval'
Strings.IfStdIsConstantEvaluatedCanBeReplacedTitle=Puedes sustituir 'si' por 'si consteval'
Strings.ImplicitConversionToIncompatiblePointerType=Conversión implícita a tipo de puntero incompatible
Strings.ImplicitConversionToIncompatiblePointerType32=Conversión implícita a tipo de puntero incompatible
Strings.ImplicitConversionToLessQualifiedPointerType=Conversión implícita al tipo de puntero con pérdida de controlador
Strings.ImplicitConversionToLessQualifiedPointerType33=Conversión implícita al tipo de puntero con pérdida de controlador
Strings.ImplicitDefaultConstructorIsNotAvailable=No se puede utilizar el constructor predeterminado implícito
Strings.ImplicitDefaultConstructorIsNotAvailableBecauseABaseClassOrAClassMemberDoesNotHaveAnAccessibleDefaultConstructor=No hay ningún constructor predeterminado accesible para la clase base o los miembros de la clase, por lo que no hay disponible un constructor predeterminado implícito.
Strings.ImplicitIntegerToPointerConversion=Conversión implícita de número entero a puntero
Strings.ImplicitIntegerToPointerConversion30=Conversión implícita de número entero a puntero
Strings.ImplicitPointerToIntegerConversion=Conversión implícita de puntero a entero
Strings.ImplicitPointerToIntegerConversion31=Conversión implícita de puntero a entero
Strings.InHLSLoutParametersMustBeAssignedBeforeExitingTheFunction=En HLSL, el parámetro 'out' debe asignarse antes de salir de la función.
Strings.IncludeGuardIsNotFoundAtTheBeginningOfAHeaderFile=Falta incluir guardia al principio del archivo de encabezado
Strings.IncrementingExpressionOfTypeBool=Expresión incremental de tipo bool
Strings.IncrementingExpressionOfTypeBoolIsDeprecatedInCAndRemovedInC=Las expresiones incrementales de tipo bool están en desuso desde C++ 11 y se eliminaron en C++ 17.
Strings.InvalidPrintfFormatSpecifier=Especificador de formato printf no válido
Strings.KeyworddefaultIsUsedAsIdentifier=La palabra clave 'predeterminada' se utiliza como identificador
Strings.LambdaCanBeRewrittenToUseExplicitTemplateParameters=Puede reescribir su lambda para usar parámetros de plantilla explícitos:
Strings.LambdaCanBeRewrittenToUseExplicitTemplateParameters19=Puede reescribir su lambda para usar parámetros de plantilla explícitos:
Strings.LambdaCaptureIsNeverUsed=La captura lambda no se utiliza en absoluto
Strings.LegacyFormatCodeForBoostFormat=Boost\:\:formatear mi antigua directiva de formato
Strings.LocalVariableCanBeMadeConst=Puedes hacer que las variables locales sean constantes.
Strings.LocalVariableCanBeMadeConst8=Puedes hacer que las variables locales sean constantes.
Strings.LocalVariableIsNeverUsedButMayHaveSideEffectsInItsDestructor=Las variables locales nunca se utilizan, pero pueden afectar a sus destructores.
Strings.LocalVariableIsNeverUsedButMayHaveSideEffectsInItsDestructor4=Las variables locales nunca se utilizan, pero pueden afectar a sus destructores.
Strings.LocalVariableMightNotBeInitialized=Es posible que la variable local no se inicialice
Strings.LocalVariableUsedWithoutBeingInitialized=Variable local utilizada sin inicialización
Strings.LocalVariableUsedWithoutBeingInitialized5=Variable local utilizada sin inicialización
Strings.MayBeMissingKeywordthrow=Es posible que le falte la palabra clave "lanzar"
Strings.MemberFunctionCanBeMadeConst=Puedes hacer que las funciones miembro sean constantes.
Strings.MemberFunctionCanBeMadeConst6=Puedes hacer que las funciones miembro sean constantes.
Strings.MemberFunctionCanBeMadeStatic=Puedes hacer que las funciones miembro sean estáticas
Strings.MemberFunctionCanBeMadeStatic7=Puedes hacer que las funciones miembro sean estáticas
Strings.MethodMustBePublicAndVirtualToImplementACCLIInterfaceMember=La implementación de un miembro de interfaz C++/CLI requiere que el método sea público y virtual.
Strings.MethodMustBePublicAndVirtualToImplementACCLIInterfaceMember29=Para implementar un miembro de la interfaz C++/CLI, el método debe ser público y virtual.
Strings.MismatchedClassTags=Etiquetas de clase no coincidentes
Strings.MissingFunctionParameterDescriptionInADocumentationComment=Falta la descripción del parámetro de función en los comentarios de la documentación
Strings.MissingFunctionParameterDescriptionInADocumentationComment38=Falta la descripción del parámetro de función en los comentarios de la documentación
Strings.MissingIncludeGuard=Falta incluir guardia
Strings.MixedSerialAndPositionalArgumentsForBoostFormat=Argumentos posicionales y no posicionales en la misma llamada de formato boost\:\:
Strings.MoreThanOneImplicitConversionAppliedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension=Se aplicó una conversión implícita que excede una de las inicializaciones de copia. Esta es una extensión no estándar de Microsoft C++.
Strings.MoreThanOneImplicitConversionAppliedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension4=Se aplicó una conversión implícita que excede una de las inicializaciones de copia. Esta es una extensión no estándar de Microsoft C++.
Strings.MultiCharacterLiteralDescription=El literal de carácter contiene varios caracteres.
Strings.MultiCharacterLiteralTitle=El literal de carácter contiene varios caracteres.
Strings.MultiCharacterWideLiteralDescription=El literal de caracteres anchos contiene varios caracteres.
Strings.MultiCharacterWideLiteralTitle=El literal de caracteres anchos contiene varios caracteres.
Strings.NamespaceDefinitionContainingSingleClassSpecialization=Definición de espacio de nombres con especialización de clase única
Strings.NoCorrespondingFileWithThePrecompiledHeaderPropertySetToCreateYcIsFound=No se encontró ningún archivo correspondiente con la propiedad 'Encabezados precompilados' establecida en 'Generar' (/Yc)
Strings.NoReturnStatementInAFunctionOrALambdaReturningNonVoid=No hay declaración de retorno en una función o lambda que devuelva no nulo
Strings.NoReturnStatementInAFunctionOrALambdaWithNonVoidReturnType=No hay declaración de devolución en función o lambda con un tipo de devolución distinto de nulo
Strings.NoTypeSpecifierFoundInADeclarationDefaultsToint=No hay ningún especificador de tipo en la declaración. Acepte el valor predeterminado de 'int'.
Strings.NodiscardCannotBeAppliedToFunctionsWithoutAReturnValue=[[nodiscard]] no se puede aplicar a una función sin valor de retorno
Strings.NonExplicitConversionOperator=Operadores de conversión no explícitos
Strings.NonExplicitConversionOperator5=Operadores de conversión no explícitos
Strings.NonExplicitConvertingConstructor=Constructor de conversión no explícito
Strings.NonExplicitConvertingConstructor4=Constructor de conversión no explícito
Strings.NonInlineFunctionDefinitionInAHeaderFile=Definiciones de funciones no integradas en archivos de encabezado
Strings.NonInlineVariableDefinitionInAHeaderFile=Definiciones de variables no integradas en archivos de encabezado
Strings.NonSafeResourceAcquisition=Adquisición insegura de recursos
Strings.NonStaticDataMemberIsUninitialized=Miembro de datos no estáticos no inicializado
Strings.NonStaticDataMemberIsUninitialized26=Miembro de datos no estáticos no inicializado
Strings.NonVirtualClassMemberFunctionHiddenInADerivedClass=Funciones ocultas de miembros de clases no virtuales en clases derivadas
Strings.NonVirtualClassMemberFunctionIsHiddenInADerivedClass=Las funciones de miembros de clases no virtuales están ocultas en clases derivadas
Strings.NotAllControlPathsInsideAFunctionOrALambdaReturnAValue=Cualquier ruta de control dentro de la función o lambda no devuelve un valor
Strings.NotAllControlPathsReturnAValue=Algunas rutas de control no devuelven valores
Strings.NotEnoughArgumentsInACallToBoostFormat=La llamada al formato boost\:\:carece de argumentos
Strings.NotEnoughArgumentsInACallToBoostFormat36=La llamada al formato boost\:\:carece de argumentos
Strings.NotEnoughArgumentsInACallToPrintf=La llamada printf carece de argumentos.
Strings.NotEnoughArgumentsInACallToPrintfSomeFormatCodesDoNotHaveAMatchingArgument=La llamada printf no tiene suficientes argumentos. Falta un argumento coincidente para algunas directivas de formato.
Strings.NotInitializedStaticConstLocalVariableOfScalarTypeThisIsNonStandardMicrosoftCExtension=Una variable local constante estática de tipo escalar no se inicializa. Esta es una extensión no estándar de Microsoft C++
Strings.ObjectMemberMightNotBeInitialized=Es posible que los miembros del objeto no se inicialicen
Strings.ObjectOfExceptionTypeIsCreatedButIsNotThrown=Se crea un objeto de tipo de excepción pero no se lanza.
Strings.OverrideFunctionRedefinesADefaultParameterArgument=La función de anulación anula los argumentos de los parámetros predeterminados
Strings.ParameterCanBeMadeConst=Los parámetros se pueden hacer constantes.
Strings.ParameterCanBeMadeConst9=Los parámetros se pueden hacer constantes.
Strings.ParameterCanBeMadePointerReferenceToConst=Puede hacer que los parámetros sean punteros/referencias a constantes.
Strings.ParameterCanBeMadePointerReferenceToConst11=Los parámetros se pueden convertir en punteros/referencias a constantes.
Strings.ParameterIsNeverUsed=No se utilizan parámetros en absoluto.
Strings.ParameterNamesDifferInDifferentDeclarationsOfTheSameFunction=Los nombres de los parámetros se usan de manera diferente en diferentes declaraciones de la misma función.
Strings.ParameterNamesDoNotMatch=Los nombres de los parámetros no coinciden
Strings.ParenthesesDontChangeOrderOfOperationsAndCanBeDeleted=Los paréntesis no cambian el orden de las operaciones y se pueden eliminar.
Strings.PassValueParameterByConstReferenceDescription=Se pasa por valor un parámetro de un tipo con una alta carga de copia. Puede pasar constantes por referencia en lugar de valor
Strings.PassValueParameterByConstReferenceTitle=Pasar parámetros de valor por referencia constante
Strings.PolymorphicClassWithNonVirtualPublicDestructor=Clases polimórficas con destructores virtuales y no públicos.
Strings.PossiblyErroneousEmptyStatement=Sintaxis vacía que puede contener errores
Strings.PossiblyErroneousEmptyStatementUsedInAControlStatement=Sintaxis vacía y potencialmente propensa a errores utilizada en declaraciones de control
Strings.PossiblyErroneousExpressionWithoutSideEffects=Posibles expresiones de error (sin efectos secundarios)
Strings.PossiblyErroneousExpressionWithoutSideEffects21=Posibles expresiones de error (sin efectos secundarios)
Strings.PossiblyErroneousIncompleteSwitchStatement=Declaración de cambio incompleta con posibles errores
Strings.PossiblyInvalidPrintfFormatSpecifier=Especificador de formato printf potencialmente no válido
Strings.PossiblyUninitializedClassMember=Posibles miembros de la clase no inicializados
Strings.PossiblyUninitializedDependentBaseClass=Clase base dependiente potencialmente no inicializada
Strings.PossiblyUnintendedIncompatibleReferenceTypeInRangeDeclaration=Tipos de referencia incompatibles potencialmente no deseados en la declaración de alcance
Strings.PossiblyUnintendedObjectSlicing=Posible corte de objetos no deseado
Strings.PossiblyUnintendedObjectSlicing28=Posible corte de objetos no deseado
Strings.PossiblyUnusedIncludeDirective=Directiva \#include potencialmente obsoleta
Strings.PossiblyUnusedIncludeDirective7=Directiva \#include potencialmente obsoleta
Strings.PrecompiledHeaderIsNotFound=Encabezado precompilado no encontrado
Strings.PrecompiledHeaderIsNotIncluded=No se incluyen encabezados precompilados
Strings.PrecompiledHeaderMustBeIncludedAtTheTopOfSourceFile=Los encabezados precompilados deben incluirse en la parte superior del archivo fuente.
Strings.PrivateSpecialMemberFunctionIsNotImplemented=Las funciones especiales de miembros privados no están implementadas.
Strings.QualifierIsRedundantAndCanBeDeleted=Los calificadores son innecesarios y pueden eliminarse.
Strings.RedeclarationOfATemplateParameterFromAnOuterScope=Redeclarar parámetros de plantilla en el ámbito externo
Strings.RedundantArgumentInConditionalExpression=Argumentos duplicados en expresiones condicionales.
Strings.RedundantArgumentInConditionalExpression54=Argumentos duplicados en expresiones condicionales.
Strings.RedundantBaseClassAccessSpecifier=Especificador de acceso de clase base duplicado
Strings.RedundantBaseClassAccessSpecifier53=Especificador de acceso de clase base duplicado
Strings.RedundantBaseClassInitializerDescription=Hay un inicializador de clase base innecesario en la lista de inicializadores de miembros.
Strings.RedundantBaseClassInitializerTitle=Inicializador de clase base innecesario
Strings.RedundantCastExpression=Expresión de reparto innecesaria
Strings.RedundantControlFlowJumpStatement=Sintaxis de movimiento de flujo de control duplicado
Strings.RedundantControlFlowJumpStatement47=Sintaxis de movimiento de flujo de control duplicado
Strings.RedundantElaboratedTypeSpecifier=Especificador de tipo detallado innecesario
Strings.RedundantEmptyDeclaration=Declaración duplicada vacía
Strings.RedundantEmptyDeclaration49=Declaración duplicada vacía
Strings.RedundantEmptyStatement=Declaración duplicada vacía
Strings.RedundantEmptyStatement48=Declaración duplicada vacía
Strings.RedundantExportKeywordMessage=La palabra clave 'exportar' es innecesaria ya que se adjunta una declaración de exportación.
Strings.RedundantMemberInitializerInConstructorInitializationList=Inicializadores de miembros duplicados en la lista de inicialización del constructor
Strings.RedundantMemberInitializerInConstructorInitializationList56=Inicializadores de miembros duplicados en la lista de inicialización del constructor
Strings.RedundantParameterListInLambdaDeclarator=Lista de parámetros innecesarios en el declarador lambda
Strings.RedundantParentheses=Paréntesis innecesarios
Strings.RedundantQualifier=Calificador\n innecesario
Strings.RedundantStaticSpecifierOnThreadLocalLocalVariableDescription=Especificador 'estático' innecesario utilizado en la variable local 'thread_local'
Strings.RedundantStaticSpecifierOnThreadLocalLocalVariableTitle=Especificador 'estático' innecesario utilizado en la variable local 'thread_local'
Strings.RedundantTemplateArguments=Argumentos de plantilla duplicados
Strings.RedundantVoidArgumentList=Lista duplicada de argumentos no válidos
Strings.RedundantVoidArgumentList55=Lista duplicada de argumentos no válidos
Strings.RedundantconstSpecifier=Especificador 'const' duplicado
Strings.RedundantelseKeyword=Duplicar la palabra clave 'otra'
Strings.RedundantelseKeyword45=Duplicar palabra clave 'otra'
Strings.RedundantelseKeywordInsideCompoundStatement=Duplicar la palabra clave 'else' dentro de una frase compuesta
Strings.RedundantelseKeywordInsideCompoundStatement46=Duplicar la palabra clave 'else' dentro de una frase compuesta
Strings.RedundantfinalSpecifierOnAFunctionInAFinalClass=Especificador 'final' innecesario en funciones dentro de clases finales
Strings.RedundantinlineSpecifier=Especificador 'en línea' duplicado
Strings.RedundantstaticSpecifierOnAMemberAllocationDeallocationFunction=Especificador 'estático' redundante para funciones de asignación/desasignación de miembros
Strings.RedundantstaticSpecifierOnAnAnonymousNamespaceMember=Especificador 'estático' redundante para miembros anónimos del espacio de nombres
Strings.RedundantstaticSpecifierOnAnAnonymousNamespaceMember52=Especificador 'estático' redundante para miembros anónimos del espacio de nombres
Strings.RedundanttemplateKeyword=Palabra clave 'plantilla' duplicada
Strings.RedundanttemplateKeyword43=Palabra clave 'plantilla' duplicada
Strings.RedundanttypenameKeyword=Palabra clave duplicada 'nombre de tipo'
Strings.RedundanttypenameKeyword42=Palabra clave duplicada 'nombre de tipo'
Strings.ReferenceClassMemberWithmutableSpecifier=Miembro de clase de referencia con especificador 'mutable'
Strings.ReferenceClassMembersCannotHavemutableSpecifier=Los miembros de la clase de referencia no pueden tener el especificador 'mutable'
Strings.ReinterpretCastIsUsedInsteadOfAStaticCast=Se utiliza reinterpret_cast en lugar de static_cast
Strings.ReinterpretCastIsUsedInsteadOfAStaticCast3=Se utiliza reinterpret_cast en lugar de static_cast
Strings.ResultOfAPostfixOperatorIsDiscarded=Se ignoran los resultados de los operadores postfix.
Strings.ResultOfAPostfixOperatorIsDiscardedItMightBeMoreEfficientToUseAPrefixFormOfTheOperator=El resultado del operador postfix se descarta. Puede que sea más eficaz utilizar un operador con sufijo.
Strings.ResultOfAssignmentIsUsedAsCondition=El resultado de la asignación se utiliza como condición.
Strings.ResultOfNodiscardFunctionIsNotUsed=El resultado de la función nodiscard no se utiliza
Strings.ResultOfNodiscardFunctionIsNotUsed22=El resultado de la función nodiscard no se utiliza
Strings.ReturningFromAFunctionByConstValueIsUsuallyNotBeneficialConsiderReturningValuesAsNonConstToTakeAdvantageOfMoveSemantics=Por lo general, no resulta útil regresar de una función con un valor constante. Considere devolver un valor no constante y aproveche la sintaxis de movimiento.
Strings.SomeObjectMembersMightNotBeInitialized=Es posible que algunos miembros del objeto no se inicialicen
Strings.SpecialFunctionDoesntHaveAnyNoexceptSpecification=La función especial no tiene ninguna especificación excepto
Strings.SpecialFunctionWithoutNoexceptSpecification=Características especiales (sin excepciones a las especificaciones)
Strings.StaticAssertFailedDescription=Static_assert falló
Strings.StaticAssertFailedTitle=Static_assert falló
Strings.StaticDataMemberInAnAnonymousClassIsNotAllowedByTheCStandard=Los miembros de datos estáticos en clases anónimas no están permitidos en el estándar C++
Strings.StaticDataMembersAreNotAllowedInAnonymousClasses=Los miembros de datos estáticos no están permitidos en clases asincrónicas.
Strings.StdIsConstantEvaluatedWillAlwaysEvaluateToConstantDescription='std\:\:is_constant_evaluated' siempre se evalúa como una constante
Strings.StdIsConstantEvaluatedWillAlwaysEvaluateToConstantTitle='std\:\:is_constant_evaluated' siempre se evalúa como una constante
Strings.StdSizeCanBeUsed=Puedes usar std\:\:tamaño
Strings.StdSizeIsTypeSafeAlternativeToCIdiomForArraySizeCalculation=Al calcular el tamaño de una matriz, std\:\:size es una alternativa segura al lenguaje C.
Strings.StdViewsKeysValuesCanBeUsed=Puede utilizar std\:\:views\:\:keys/values
Strings.StringLiteralToCharPointerConversion=Conversión de literal de cadena a puntero de carácter
Strings.StringLiteralToCharPointerConversion34=Conversión de literal de cadena a puntero de carácter
Strings.StructuredBindingCanBeUsed=Puedes usar enlace estructurado.
Strings.StructuredBindingCanBeUsed15=Puedes usar enlace estructurado.
Strings.StructuredBindingCanBeUsedInsteadOfTie=En lugar de atar(..) puedes usar encuadernación estructurada
Strings.SyntaxErrorInADoxygenComment=Error de sintaxis en el comentario de doxygen
Strings.SyntaxErrorInDoxygenComment=Error de sintaxis en el comentario de doxygen
Strings.TagsOfTheDeclaredClassDoNotMatchPreviousDeclarations=Las etiquetas de la clase declarada no coinciden con la declaración anterior
Strings.TakingAnAddressOfClassRValueIsNonStandardMicrosoftCExtension=El uso de direcciones del valor de clase r es una extensión no estándar de Microsoft C++
Strings.TakingAnAddressOfClassRValueIsNonStandardMicrosoftCExtension3=El uso de direcciones de valores de clase r es una extensión no estándar de Microsoft C++
Strings.TemplateArgumentsCanBeDeduced=Se pueden inferir argumentos de plantilla
Strings.TemplateParameterIsNeverUsedDescription=Los parámetros de la plantilla nunca se utilizan
Strings.TemplateParameterIsNeverUsedTitle=Los parámetros de la plantilla nunca se utilizan
Strings.TheAwaiterTypeMustBeAAClassAccordingToTheCStandard=Según el estándar C ++ 20, el tipo de camarero debe ser una clase
Strings.TheClassIsAbstractButNotExplicitlyDeclaredAsSuch=La clase es abstracta, pero no declarada explícitamente.
Strings.TheNodiscardAttributeCannotBeAppliedToFunctionsWithoutAReturnValue=La propiedad [[nodiscard]] no se puede aplicar a una función que no tiene valor de retorno
Strings.TheSwitchStatementDoesntCoverTheWholeRangeOfTheEnumerationUsed=La declaración de cambio no cubre todos los rangos de la enumeración utilizada.
Strings.TheconstSpecifierOnAVariableDefinitionIsRedundant=El especificador 'const' no es necesario en declaraciones de variables.
Strings.TheinlineSpecifierOnAFunctionDefinitionIsRedundant=El especificador 'en línea' es innecesario en las definiciones de funciones
Strings.TheoutParameterMustBeAssigned=Se debe asignar el parámetro 'out'.
Strings.TheregisterStorageClassSpecifierIsDeprecatedInCAndRemovedInC=El especificador de clase de almacenamiento 'regitor' está en desuso desde C++11 y se eliminó en C++17.
Strings.ThestaticSpecifierIsOptionalForMemberAllocationDeallocationFunctions=El especificador 'estático' es opcional en las funciones de asignación/desasignación de miembros.
Strings.ThrowExpressionCanBeReplacedWithARethrowExpression=La expresión de lanzamiento se puede reemplazar con la expresión de volver a lanzar
Strings.ThrowExpressionCanBeReplacedWithARethrowExpression12=La expresión de lanzamiento se puede reemplazar con la expresión de volver a lanzar
Strings.TooManyArgumentsInACallToBoostFormat=La llamada al formato boost\:\:tiene demasiados argumentos
Strings.TooManyArgumentsInACallToBoostFormatSomeOfTheArgumentsAreNotUsed=Demasiados argumentos en la llamada para impulsar\:\:formato. Algunos argumentos no se utilizan.
Strings.TooManyArgumentsInACallToPrintf=Demasiados argumentos en la llamada printf
Strings.TooManyArgumentsInACallToPrintfSomeOfTheArgumentsAreNotUsed=Hay demasiados argumentos en la llamada printf. Algunos argumentos no se utilizan.
Strings.TypeAliasIsNeverUsed=Los alias de tipo no se utilizan en absoluto
Strings.TypeSpecifierMissingDefaultsToInt=Falta el calificador de tipo, int es el valor predeterminado
Strings.TypeTraitCanBeSimplifiedUsingATemplateAliasOrAVariableTemplate=Puede simplificar los atributos de tipo utilizando alias de plantilla o plantillas de variables.
Strings.UninitializedDependentBaseClass=Clase base dependiente no inicializada
Strings.UnionMemberOfReferenceType=Miembros sindicales de tipos de referencia.
Strings.UnionsCannotContainNonStaticDataMembersOfReferenceTypes=Una unión no puede contener miembros de datos que no sean estáticos y sean de tipo inferido.
Strings.UnnamedNamespaceInAHeaderFile=Espacio de nombres sin nombre en el archivo de encabezado
Strings.UnnamedNamespacesShouldNotBeUsedInHeaderFiles=Los espacios de nombres sin nombre no deben usarse en archivos de encabezado
Strings.UnresolvedReferenceInADoxygenComment=Referencia no resuelta en el comentario de doxygen
Strings.UnresolvedReferenceInDoxygenComment=Referencia no resuelta en el comentario de doxygen
Strings.UseOfAnIncompleteTypeInsideATemplate=Usar el tipo Incompleto dentro de una plantilla
Strings.UserDefinedLiteralSuffixesMustStartWithAnUnderscore=Los sufijos literales personalizados deben comenzar con un guión bajo.
Strings.UserDefinedLiteralSuffixesMustStartWithAnUnderscoreTheSuffixesThatDoNotBeginWithAnUnderscoreAreReservedForTheLiteralOperatorsProvidedByTheStandardLibrary=Los sufijos literales personalizados deben comenzar con un guión bajo. Los sufijos que no comienzan con un guión bajo solo se pueden usar con operadores literales proporcionados por la biblioteca estándar.
Strings.UsingAnIncompatibleReferenceTypeInTheRangeDeclarationIsLikelyToCauseUnwantedObjectCopying=El uso de tipos inferidos incompatibles en declaraciones de alcance puede provocar copias no deseadas de objetos.
Strings.VariableCanBeMadeConstexpr=Puedes hacer una variable constexpr.
Strings.VariableCanBeMadeConstexpr10=Puedes hacer una variable constexpr.
Strings.VariableCanBeMovedToInitStatement=Puede mover la variable a la declaración de inicio
Strings.VariableCanBeMovedToInnerScope=Puede mover variables al alcance interno
Strings.VolatileQualificationOfParametersHasAnEffectOnlyInFunctionDefinitions=La calificación volátil de un parámetro tiene efecto sólo en las definiciones de funciones.
Strings.VolatileQualifiedParameterInAFunctionDeclaration=Parámetro de normalización volátil en la declaración de función
Strings.WarningDirectiveDescription=\#advertencia directiva de preprocesador
Strings.WarningDirectiveTitle=\#directiva de advertencia
Strings.ZeroConstantCanBeReplacedWithNullptr=0 Las constantes se pueden reemplazar por nullptr
Strings.ZeroConstantCanBeReplacedWithNullptr13=0 constantes se pueden reemplazar con nullptr
Strings.ZeroInitializationCanBeUsedInsteadOfMemset=Puedes usar inicialización cero en lugar de memset
Strings.ZeroInitializationCanBeUsedInsteadOfMemset16=Puedes usar inicialización cero en lugar de memset
Strings.containsMemberFunctionCanBeUsed=La función miembro 'contiene' se puede utilizar
Strings.containsMemberFunctionCanBeUsed17=La función miembro 'contiene' se puede utilizar
Strings.defaultIsAKeywordInTheCStandardAndCannotBeUsedAsAnIdentifier='predeterminado' es una palabra clave en el estándar C++ y no se puede utilizar como identificador.
Strings.longFloatsAreNotAllowedByTheCStandard=El valor flotante "largo" no está permitido en el estándar C++
Strings.stdErasestdEraseIfCanBeUsedInsteadOfTheRemoveEraseIdiom='std\:\:erase'/'std\:\:erase_if' se puede utilizar en lugar del modismo remove-erase
Strings.stdErasestdEraseIfCanBeUsedInsteadOfTheRemoveEraseIdiom18='std\:\:erase'/'std\:\:erase_if' se puede utilizar en lugar del modismo remove-erase
