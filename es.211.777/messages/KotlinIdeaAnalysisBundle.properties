found.space=Artículos encontrados\:
html.0.has.no.corresponding.expected.declaration.1.html=No hay declaración requerida correspondiente a {0}{1}
html.0.is.not.abstract.and.does.not.implement.abstract.base.class.member.br.1.html={0} no es abstracto y no implementa ningún miembro de clase base abstracto<br/>{1}
html.0.is.not.abstract.and.does.not.implement.abstract.member.br.1.html={0} no es abstracto y no implementa ningún miembro abstracto<br/>{1}
html.0.method.may.be.missing.none.of.the.following.functions.will.be.called.ul.1.ul.html=El método ''{0}'' no parece existir. No se llama a ninguna de las siguientes funciones: <ul>{1}</ul>
html.candidate.resolution.will.be.changed.soon.please.use.fully.qualified.name.to.invoke.the.following.closer.candidate.explicitly.ul.0.ul.html=La resolución del candidato cambiará pronto. Utilice el nombre completo para llamar explícitamente al siguiente candidato más cercano. <ul>{0}</ul>
html.expected.0.has.no.actual.declaration.in.module.1.2.html=El {0} obligatorio no tiene una declaración real en el módulo {1}{2}
html.accidental.override.0.html=Anulación accidental\: {0}
html.method.contains.from.concurrenthashmap.may.have.unexpected.semantics.it.calls.containsvalue.instead.of.containskey.br.use.explicit.form.of.the.call.to.containskey.containsvalue.contains.or.cast.the.value.to.kotlin.collections.map.instead.br.see.https.youtrack.jetbrains.com.issue.kt.18053.for.more.details.html=El método "contiene" de ConcurrentHashMap puede tener un significado inesperado. Este método llama a ''containsValue'' en lugar de ''containsKey''.<br/>Utilice una forma explícita de la llamada ''containsKey''/''containsValue''/''contains'', o kotlin.collections Cast el valor a .Map.<br/>Para obtener más información, consulte https\://youtrack.jetbrains.com/issue/KT-18053
html.javascript.0.html=JavaScript\: {0}
html.platform.declaration.clash.0.html=Conflicto de declaración de plataforma\: {0}
html.internal.error.occurred.while.analyzing.this.expression.br.table.cellspacing.0.cellpadding.0.tr.td.strong.please.use.the.strong.td.td.img.src.0.td.td.strong.icon.in.the.bottom.right.corner.to.report.this.error.strong.td.tr.table.br.pre.0.pre.html=Se produjo un error interno al analizar esta expresión <br/><table cellspaces\="0" cellpadding\="0"><tr><td> (el <strong>"</strong> en la esquina inferior derecha </ td><td>Informe este error utilizando el icono <img src\="{0}"/></td><td><strong>")\:</td </tr></table> <br/>><pre>{0}</pre>
html.property.delegate.must.have.a.0.method.none.of.the.following.functions.are.suitable.ul.1.ul.html=La delegación de propiedad debe tener el método ''{0}''. Ninguna de las siguientes funciones es adecuada: <ul>{1}</ul>
html.overload.resolution.ambiguity.on.method.0.all.these.functions.match.ul.1.ul.html=La resolución de sobrecarga para el método ''{0}'' es ambigua. Todas estas funciones coinciden. <ul>{1}</ul>
html.unresolved.reference.br.none.of.the.following.candidates.is.applicable.because.of.receiver.type.mismatch.ul.0.ul.html=Referencia no resuelta. <br/> Ninguno de los siguientes candidatos es aplicable porque sus tipos de receptores no coinciden. <ul>{0}</ul>
html.cannot.choose.among.the.following.candidates.without.completing.type.inference.ul.0.ul.html=Si no completa la inferencia de tipos, no podrá elegir entre los siguientes candidatos: <ul>{0}</ul>
html.none.of.the.following.functions.can.be.called.with.the.arguments.supplied.ul.0.ul.html=Ninguna de las siguientes funciones se puede llamar con los argumentos proporcionados: <ul>{0}</ul>
html.overload.resolution.ambiguity.all.these.functions.match.ul.0.ul.html=La resolución de sobrecarga es ambigua. Todas estas funciones coinciden. <ul>{0}</ul>
html.function.return.type.mismatch.table.tr.td.expected.td.td.1.td.tr.tr.td.found.td.td.2.td.tr.table.html=El tipo de retorno de la función no coincide.<table><tr><td>Obligatorio\:</td><td>{1}</td></tr><tr><td>Encontrado\: </td><td >{2}</td></tr></table>
html.0.must.override.1.br.because.it.inherits.many.implementations.of.it.html=Dado que {0} hereda muchas implementaciones de {1}, debemos<br />anularlas.
html.types.of.inherited.var.properties.do.not.match.br.0.br.1.html=Los tipos de propiedades var heredadas no coinciden<br/>{0},<br/>{1}
html.types.of.inherited.properties.are.incompatible.br.0.br.1.html=Los tipos de propiedad heredados son incompatibles.<br/>{0},<br/>{1}
html.actual.class.0.has.no.corresponding.members.for.expected.class.members.1.html=El miembro correspondiente al miembro de clase requerido no existe en la clase real ''{0}''.{1}
html.val.property.cannot.override.var.property.br.1.html=Las propiedades Val no pueden anular las propiedades var<br />{1}
html.var.property.type.is.0.which.is.not.a.type.of.overridden.br.1.html=La propiedad Var tiene el tipo {0}, que no es el tipo del elemento redefinido<br/>{1}
required.space=necesario\:
type.inference.failed.expected.type.mismatch=La inferencia de tipos falló. Los tipos requeridos no coinciden.
html.setter.parameter.type.must.be.equal.to.the.type.of.the.property.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=El tipo de parámetro de establecimiento debe ser el mismo que el tipo de propiedad.<table><tr><td>Obligatorio\:</td><td>{0}</td></tr><tr><td>Encontrado Artículo\:</td><td>{1}</td></tr></table>
html.property.type.is.0.which.is.not.a.subtype.type.of.overridden.br.1.html=El tipo de propiedad es {0}, que no es un subtipo del elemento redefinido<br/>{1}
html.return.types.of.inherited.members.are.incompatible.br.0.br.1.html=Los tipos de devolución de miembros heredados son incompatibles.<br/>{0},<br/>{1}
html.return.type.is.0.which.is.not.a.subtype.of.overridden.br.1.html=El tipo de devolución es ''{0}'', que no es un subtipo del elemento redefinido<br/>{1}
html.loop.parameter.type.mismatch.table.tr.td.iterated.values.td.td.0.td.tr.tr.td.parameter.td.td.1.td.tr.table.html=Los tipos de parámetros de bucle no coinciden<table><tr><td>valor repetido\:</td><td>{0}</td></tr><tr><td>parámetro\::</td ><td>{1}</td></tr></table>
html.type.argument.is.not.within.its.bounds.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=El argumento de tipo no está dentro de sus límites.<table><tr><td>Obligatorio\:</td><td>{0}</td></tr><tr><td>Elemento encontrado\: < /td><td>{1}</td></tr></table>
html.method.iterator.is.ambiguous.for.this.expression.ul.0.ul.html=El método ''iterator()'' es ambiguo en esta expresión.<ul>{0}</ul>
html.getter.return.type.must.be.equal.to.the.type.of.the.property.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=El tipo de retorno del captador debe ser el mismo que el tipo de propiedad.<table><tr><td>Obligatorio\:</td><td>{0}</td></tr><tr><td>encontrado Artículo\:</td><td>{1}</td></tr></table>
html.type.inference.failed.0.html=La inferencia de tipos falló. {0}
html.assignment.operators.ambiguity.all.these.functions.match.ul.0.ul.table.html=El operador de asignación es ambiguo. Todas estas funciones coinciden. <ul>{0}</ul></table>
html.type.mismatch.table.tr.td.required.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.br.projected.type.2.restricts.use.of.br.3.html=El tipo no coincide<table><tr><td>Elemento requerido\:</td><td>{0}</td></tr><tr><td>Elemento encontrado\:</ td><td> {1}</td></tr></table><br />\nEl tipo proyectado {2} restringe el uso de {3} \n
html.type.mismatch.table.tr.td.required.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=El tipo no coincide<table><tr><td>Elemento requerido\:</td><td>{0}</td></tr><tr><td>Elemento encontrado\:</ td><td> {1}</td></tr></table>
intention.suppress.family=supresión de advertencia
intention.suppress.text=Suprimir ''{0}'' para {1} {2}
intention.calculating.text=Solución rápida Calculando...
special.module.for.files.not.under.source.root=<special module for files not under source root>
sdk.0=<sdk {0}>
sources.for.library.0=<Fuente de la biblioteca {0}>
library.0=<library {0}>
source.for.script.dependencies=<Source for script dependencies>
script.dependencies=<Script dependencies>
script.0.1=<Secuencia de comandos {0} {1}>
module.name.0.test={0}(prueba)
platform.module.0.including.1=<Módulo de plataforma {0} que contiene {1}>
the.following.declarations.have.the.same.jvm.signature.code.0.1.code.br.ul.2.ul=La siguiente declaración tiene la misma firma JVM (<code>{0}{1}</code>):<br/>\n<ul>\n{2}</ul>
declaration.kind.object=objeto
declaration.kind.companion.object=objeto compañero
declaration.kind.initializer=iniciador
declaration.kind.statement=construcción
declaration.kind.file=Archivo
declaration.name.0.of.1={0} de {1}
declaration.kind.secondary.constructor.of=constructor secundario
declaration.kind.enum.entry=elemento de enumeración
declaration.kind.type.parameter=tipo de parámetro
declaration.kind.class=clase
declaration.kind.interface=interfaz
declaration.kind.fun=fun
declaration.kind.parameter=parámetro
type.parameters.where=where
cannot.be.inferred=no se puede inferir
i.for.i.br.0=<i> for</i><br/>{0}
defined.in=Definido en
root.package=paquete raíz
automatically.declared.based.on.the.expected.type=Declarado automáticamente dependiendo del tipo requerido
0.smart.cast.to.1=Reparto inteligente de {0} a {1}
unknown.receiver=receptor desconocido
implicit.receiver=receptor implícito
extension.implicit.receiver=receptor implícito extendido
always.null=Siempre nulo
value.captured.in.a.closure=Valores captados en cierre
wrapped.into.a.reference.object.to.be.modified.when.captured.in.a.closure=Envuelto en un objeto de referencia que se modificará si se captura en un cierre
smart.cast.to.0.for.1.call=Transmisión inteligente a {0} (al llamar a {1})
smart.cast.to.0=Transmisión inteligente a {0}
replace.overloaded.operator.with.function.call=Reemplazo de operadores sobrecargados con llamadas a funciones
class.initializer=<inicializador de clase>
object.0=objeto{0}
show.non.public=Marcar como no público
show.properties=Mostrar propiedades
klib.metadata.short=Metadatos de Klib
function.arguments=tomar el control\:
function.receiver.0=Receptor\: {0}
kotlin.built.in.declarations=Declaraciones integradas de Kotlin
kotlin.javascript.meta.file=Metarchivo JavaScript de Kotlin
kotlin.suppress.options=Opciones de supresión de Kotlin
