cannot.perform.the.refactoring=No se puede realizar la refactorización.
extract.class.title=Extraer al delegado
extract.class.from.label=Extracción de delegados en {0}
name.for.new.class.label=Nuevo nombre de clase (&N)\:
choose.destination.package.label=Seleccionar paquete de destino
package.for.new.class.label=&Nombre del paquete\:
members.to.extract.label=Miembros a extraer (&B)
there.already.exists.a.class.with.the.chosen.name=Ya existe una clase con el nombre que seleccionaste.
introduce.parameter.object=Introducción a los objetos de parámetros
the.caret.should.be.positioned.within.a.class.to.be.refactored=El cursor debe estar ubicado dentro de la clase que se va a refactorizar.
the.selected.class.is.an.enumeration=La clase que seleccionó es una enumeración.
remove.middleman=Eliminar intermediario
the.caret.should.be.positioned.at.the.name.of.the.field.to.be.refactored=El cursor debe colocarse en el nombre del campo que se va a refactorizar.
field.selected.is.not.used.as.a.delegate=El campo seleccionado no se utilizará como delegado.
wrap.return.value=Salto de línea del valor de retorno
the.caret.should.be.positioned.at.the.name.of.the.method.to.be.refactored=El símbolo de intercalación debe colocarse dentro del nombre del método que se va a refactorizar, dentro de la lista de parámetros o dentro de la llamada al método.
method.selected.returns.void=El método seleccionado devuelve ''void''.
constructor.returns.can.not.be.wrapped=Las devoluciones del constructor no se pueden empaquetar.
wrap.return.value.title=Salto de línea del valor de retorno
method.to.wrap.returns.from.label=Método\: para envolver la devolución:
method.whose.return.are.to.wrapped=Método para envolver la devolución interna
references.to.be.modified.usage.view=Referencias para modificar {1,choice, 0\#|1\#en {1} archivos|2\#en {1} archivos} {0,choice, 0\# (no encontrado)|1\#{0 } referencias |2\#{0} referencias}
reference=referencia
remove.middleman.field.header=Eliminar campo intermediario\:
references.to.expose.usage.view=Referencias para exponer {1,choice, 0\#|1\#de {1} archivos|2\#de {1} archivos} {0,choice, 0\# (no encontrado)|1\#{ 0} referencias |2\#{0} referencias}
remove.middleman.title=Eliminar intermediario
refactor=Refactorizar
preview=Avance
wrapped.return.command.name=\ return envuelto en {0} para {1}()
exposed.delegation.command.name=Delegación expuesta en {0}
annotation=anotación
the.selected.class.is.an.interface=La clase que elijas es una interfaz.
the.selected.class.is.an.annotation.type=La clase seleccionada es un tipo de anotación.
the.refactoring.is.not.supported.on.non.static.inner.classes=La refactorización no se admite en clases internas no "estáticas".
the.selected.class.has.no.members.to.extract=La clase seleccionada no tiene miembros para extraer.
the.selected.class.should.belong.to.project.sources=La clase seleccionada debe pertenecer a la fuente del proyecto.
references.to.extract=Referencias para extraer {1,choice, 0\#|1\#de {1} archivos|2\#de {1} archivos} {0,choice, 0\# (no encontrado)|1\#{ 0} referencias |2\#{0} referencias})
extract.class.as.enum.column.title=en enumeración
extract.class.depends.on.0.from.1.tooltip=Dependiente de {0} en {1}
extract.class.depends.on.0.from.new.class=Dependiente de {0} en la nueva clase {1}
extracting.from.class=Extracto de clase\:
extracted.class.command.name=Clase extraída {0}
extracted.class.not.accessible.in.0=No se puede acceder a la clase extraída desde {0}
method.selected.has.no.parameters=El método seleccionado no tiene parámetros.
parameter=parámetro
the.selected.method.cannot.be.wrapped.because.it.is.defined.in.a.non.project.class=El método seleccionado no se puede empaquetar porque está declarado en una clase que no pertenece al proyecto.
select.wrapper.class=Seleccionar clase de parámetro
could.not.find.selected.wrapping.class=No se pudo encontrar la clase de embalaje seleccionada.
there.already.exists.a.class.with.the.selected.name=Ya existe una clase con el nombre que seleccionaste.
dialog.message.invalid.inner.class.name=''{0}'' es un nombre de clase interna no válido
dialog.message.inner.class.with.name.already.exist=Ya existe una clase interna con el nombre ''{0}''
dialog.message.invalid.qualified.wrapper.class.name=''{0}'' es un nombre de clase contenedor completamente calificado no válido
dialog.message.invalid.wrapper.class.name=''{0}'' es un nombre de clase contenedor no válido
dialog.message.wrapper.field.not.found=Campo contenedor no encontrado
dialog.message.invalid.wrapper.class.package.name=''{0}'' es un nombre de paquete de clase contenedora no válido
popup.title.effective.visibility=visibilidad válida
field.needs.getter=El campo ''{0}'' requiere un captador
field.needs.setter=El campo ''{0}'' requiere un configurador
initializer.requires.moved.members=El inicializador de clase requiere un miembro movido
constructor.requires.moved.members=El constructor requiere miembro movido
case.value.can.not.be.replaced.with.enum={0} no se puede convertir en una enumeración
referenced.element.out.of.project={0} está fuera del proyecto
unable.to.migrate.statement.to.enum=La sintaxis no se puede migrar a constantes de enumeración. {0}
codestyle.settings.extractor.command.name=Configuración de estilo de código
