# File Types
javascript.filetype.description=JavaScript
actionscript.filetype.description=ActionScript
typescript.filetype.description=TypeScript
typescript.jsx.filetype.description=TypeScript JSX
ecmascript6.filetype.description=ECMAScript 6
jsx.filetype.description=React JSX
flow.filetype.description=Flow JS
javascript.file=JavaScript 파일
typescript.file=TypeScript 파일
label.typescript.config=TypeScript 구성

# Languages
javascript.language.simple.name=JavaScript
typescript.language.simple.name=TypeScript

# Language terms
javascript.language.term.function=함수
javascript.language.term.inner.function=내부 함수
javascript.language.term.method=메서드
javascript.language.term.constructor=생성자
javascript.language.term.class=클래스
javascript.language.term.inner.class=내부 클래스
javascript.language.term.interface=인터페이스
javascript.language.term.inner.interface=중첩 인터페이스
javascript.language.term.enum=enum
javascript.language.term.type.alias=타입 별칭
javascript.language.term.definition=정의
javascript.language.term.namespace=이름 공간
javascript.language.term.parameter=매개변수
javascript.language.term.property=프로퍼티
javascript.language.term.variable=변수
javascript.language.term.const=상수
javascript.language.term.const.field=상수 필드
javascript.language.term.readonly.field=readonly 필드
javascript.language.term.local.variable=지역 변수
javascript.language.term.local.const=지역 상수
javascript.language.term.field=필드
javascript.language.term.tag=꼬리표
javascript.language.term.label=라벨
javascript.language.term.attribute=속성
javascript.language.term.decorator=데코레이터
javascript.language.term.attribute.value=속성 값
javascript.language.term.package=패키지
javascript.language.term.module=모듈
javascript.language.term.external.module.reference=외부 모듈 참조
javascript.language.term.import.specifier=import 지정자
javascript.language.term.export.specifier=export 지정자
javascript.language.term.entity.name=개체 이름
javascript.language.term.jsdoc.tag=JSDoc 태그
javascript.language.term.imported.default.binding=가져온 디폴트 바인딩
javascript.language.term.exported.default.binding=내보낸 디폴트 바인딩
javascript.language.term.namespace.import=네임스페이스 가져오기
javascript.language.term.namespace.export=네임스페이스 내보내기
javascript.language.term.import.statement=import 문
javascript.language.term.type.parameter=타입 매개변수
javascript.language.term.destructuring.property=프로퍼티 구조 분해
javascript.language.term.default.export=디폴트 내보내기
javascript.language.term.file=파일
javascript.language.term.global=글로벌
javascript.language.term.xml.tag=xml 태그

# Parser error messages
javascript.parser.message.expected.expression=표현식이 필요합니다
javascript.parser.message.expected.xml.element=XML 요소가 필요합니다
javascript.parser.property.expected=프로퍼티가 필요합니다
javascript.parser.message.expected.lbrace={ 필요
javascript.parser.message.expected.at=@ 필요
javascript.parser.message.expected.rbrace=} 필요
javascript.parser.message.expected.identifier.string.literal.or.numeric.literal=식별자 또는 문자열 리터럴 또는 숫자 리터럴이 필요합니다
javascript.parser.message.expected.colon=\: 필요
javascript.parser.message.expected.colon.or.comma=\: 또는 , 필요
javascript.parser.message.expected.semicolon=; 필요
javascript.parser.message.expected.lbrace.or.semicolon={ 또는 ; 필요
javascript.parser.message.expected.rbracket=] 필요
javascript.parser.message.expected.lparen=( 필요
javascript.parser.message.expected.rparen=) 필요
javascript.parser.message.expected.name=이름이 필요합니다
javascript.parser.message.expected.comma.or.rparen=, 또는 ) 필요
javascript.parser.message.expected.function.name=함수 이름이 필요합니다
javascript.parser.message.expected.formal.parameter.name=형식 매개변수 이름이 필요합니다
javascript.parser.message.expected.statement=구문이 필요합니다
javascript.parser.message.expected.parameter.name=매개변수 이름이 필요합니다
javascript.parser.message.expected.property.name=프로퍼티 이름이 필요합니다
javascript.parser.message.expected.case.or.default=''catch'' 또는 ''default'' 필요
javascript.parser.message.expected.forloop.left.hand.side.expression.or.variable.declaration=''in'' 앞에 왼쪽 표현식 또는 변수 선언이 필요합니다
javascript.parser.message.expected.forloop.in.or.semicolon=''in'' 또는 ; 필요
javascript.parser.message.expected.while.keyword=''while''이 필요합니다
javascript.parser.message.expected.comma=, 필요
javascript.parser.message.expected.comma.or.rbrace=, 또는 } 필요
javascript.parser.message.expected.variable.name=변수 이름이 필요합니다
javascript.parser.message.expected.mult.or.lbrace=* 또는 { 필요
javascript.parser.message.missing.rbrace=} 누락
javascript.parser.message.missing.or_rbrace=|} 누락
javascript.parser.message.missing.backquote='' 누락
javascript.parser.message.missing.attribute.name=속성 이름 누락
javascript.parser.message.unexpected.end.of.file=예기치 않은 파일의 끝
javascript.parser.message.expected.type.name=타입 이름이 필요합니다
javascript.parser.message.unclosed.string.literal=닫히지 않은 문자열 리터럴
javascript.parser.message.unclosed.comment=닫히지 않은 주석
javascript.parser.message.are.not.supported.by.dialect={0}는 현재 JavaScript 버전에서 지원하지 않습니다
javascript.parser.message.expected.from=''from'' 필요
javascript.parser.message.expected.typename=타입 이름이 필요합니다
javascript.parser.message.expected.typename.or.*=* 또는 타입 이름 필요
javascript.parser.message.expected.name.or.lbrace=패키지 이름 또는 { 가 필요합니다
javascript.parser.message.expected.declaration=선언이 필요합니다
javascript.parser.message.expected.namespace=''namespace'' 필요
javascript.parser.message.expected.string.literal=문자열 리터럴이 필요합니다
javascript.parser.message.expected.xml=XML 컨텍스트 키워드가 필요합니다
javascript.parser.message.expected.equal=\= 가 필요합니다
javascript.parser.message.expected.identifier.lbrace.or.lbracket=식별자, { 또는 [ 가 필요합니다
javascript.parser.message.expected.eqgt=\=> 가 필요합니다
javascript.parser.message.expected.identifier=식별자가 필요합니다
javascript.parser.message.expected.instanceof=''instanceof'' 필요
javascript.parser.message.expected.in=''in''이 필요합니다
javascript.parser.message.expected.value=값이 필요합니다
javascript.parser.message.expected.identifier.or.value=식별자 또는 값이 필요합니다
javascript.parser.message.expected.as=''as'' 필요
javascript.parser.message.expected.identifier.string.literal.or.lbrace=식별자, 문자열 리터럴 또는 { 가 필요합니다
javascript.parser.message.expected.import.value=Import 바인딩 또는 지정자가 필요합니다
javascript.parser.message.expected.import.specifier=Import 지정자가 필요합니다
javascript.parser.message.expected.heredoc.closing.identifier=Heredoc 닫는 식별자가 필요합니다
javascript.parser.message.expected.type.member=타입 멤버가 필요합니다
javascript.parser.message.expected.tuple.comma.or.rbracket=, 또는 ] 필요
javascript.parser.message.expected.target=New의 메타 프로퍼티로 ''target''만 허용됩니다
javascript.parser.message.expected.meta=import의 메타 프로퍼티로 ''meta''만 허용됩니다
javascript.parser.message.expected.declare=''declare'' 필요
javascript.parser.message.expected.exports=''exports'' 필요
javascript.parser.message.expected.checks=''checks''가 필요합니다
javascript.parser.message.expected.type.keyword=''type'' 필요
javascript.parser.message.expected.type=타입이 필요합니다
javascript.parser.message.expected.question=? 필요
javascript.parser.message.expected.class=''class''가 필요합니다

# Validation messages
javascript.validation.message.conflicting.definition.was.found.with.the.same.name=상속된 선언 {0}의 충돌이 네임스페이스에 {1}에서 발견되었습니다
javascript.validation.message.duplicate.declaration=중복 선언
javascript.validation.message.duplicate.declaration.fix.remove=제거 타입(들)
javascript.validation.message.redundant.type=명시적 타입 인수 {0}을(를) {1}(으)로 바꿀수 있습니다
javascript.validation.message.redundant.type.remove=명시적 타입 인수 {0}을(를) 제거할 수 있습니다
javascript.validation.message.duplicate.export.declaration=내보내기 선언이 내보낸 선언 ''{0}''와(과) 충돌합니다
javascript.validation.message.duplicate.default.export.declaration=모듈 하나에 디폴트 내보내기 여러 개를 사용할 수 없습니다
javascript.validation.message.duplicate.default.export.in.module=디폴트 내보내기는 ECMAScript 스타일 모듈에서만 사용할 수 있습니다
javascript.validation.message.duplicate.declaration.fix.text=이전 선언 ''{0}''(으)로 이동
javascript.validation.message.duplicate.declaration.fix.text.no.name=이전 선언으로 이동
javascript.validation.message.redeclaration.of.block.scope=블록 범위 변수를 다시 선언할 수 없습니다
javascript.validation.message.redeclaration.of.block.scope.in.scope.of.var=블록 범위 변수는 동일한 블록 범위 안에서 ''var'' 변수 또는 매개변수와 이름을 공유할 수 없습니다
javascript.validation.message.redeclaration.of.var.in.scope.of.block.scope=''var'' 변수는 가시성 범위 안에서 블록 범위 변수와 이름을 공유할 수 없습니다
javascript.validation.message.assignment.to.const=const 또는 readonly 변수에 할당시도
javascript.validation.message.assignment.to.const.fix.replace=let으로 바꾸기
javascript.validation.message.assignment.to.const.fix.remove.readonly=readonly 제어자 제거
javascript.validation.message.must.be.lvalue=유효하지 않은 {0} 왼쪽
javascript.validation.message.const.variable.without.initializer=''const'' 변수에 이니셜라이저가 없습니다. 의미 있는 값을 나중에 할당할 수 없습니다.
javascript.validation.message.constructor.field.not.allowed=클래스는 ''constructor''라는 이름의 비정적 필드를 가질 수 없습니다
es6.validation.message.const.variable.without.initializer=이니셜라이저가 없는 ''const'' 변수는 허용되지 않습니다
javascript.validation.message.continue.without.target=''continue''의 대상을 지정할 수 없습니다
javascript.validation.message.break.without.target=''break''의 대상을 지정할 수 없습니다
javascript.validation.message.continue.outside.loop=루프 문 외부의 ''continue''
javascript.validation.message.return.outside.function.definition=함수 정의 외부의 ''return''
javascript.validation.message.duplicate.label=라벨 중복
javascript.validation.message.extend.multiple.classes=클래스는 여러 클래스를 확장할 수 없습니다
javascript.validation.message.extend.final.class=최종 클래스 ''{0}''을(를) 확장할 수 없습니다
javascript.validation.message.identifier.not.allowed.in.strict.mode={0}은(는) 엄격 모드에서 식별자로 허용되지 않습니다
javascript.validation.message.for.await.top.level=최상위 ''for await''가 사용되었습니다.
javascript.validation.message.for.await.no.async.context=''for await''는 ''async'' 함수 외부에서만 사용할 수 있습니다.
typescript.validation.message.invalid.modifier.cannot.be.here=제어자 {0}을(를) 여기에 표시할 수 없습니다
typescript.validation.message.duplicate.modifier=제어자 {0}이(가) 이미 있습니다
typescript.validation.message.duplicate.modifier2=접근 제어자가 이미 있습니다
typescript.validation.message.abstract.cannot.be.used=''{0}'' 제어자는 ''abstract'' 제어자와 함께 사용할 수 없습니다
typescript.validation.message.abstract.class.be.created=추상 클래스 ''{0}''의 인스턴스를 생성할 수 없습니다
typescript.validation.message.abstract.member.access.super=추상 메서드 ''{0}''은(는) super 표현식을 통해 액세스할 수 없습니다.
typescript.validation.message.abstract.cannot.have.body=메서드는 ''abstract''으로 표시되어 있으므로 구현을 가질 수 없습니다
typescript.validation.message.abstract.overload=오버로드 시그니처는 모두 추상이거나 추상이 아니어야 합니다.
typescript.validation.message.constructor.cannot.be.abstract=생성자는 ''abstract''일 수 없습니다
typescript.validation.message.function.implementation.missing=함수 구현이 누락되었거나 선언 직후가 아닙니다
typescript.validation.message.abstract.class.should.be=추상 메서드는 추상 클래스 안에서만 표시될 수 있습니다
typescript.validation.module.reference.with.extension=외부 모듈 참조가 확장자로 끝날 수 없습니다
typescript.validation.class.extend.not.constructor.type=타입 ''{0}''은(는) 생성자 함수 타입이 아닙니다
typescript.validation.class.extend.no.type.arguments.type=기본 생성자에 지정된 수의 타입 인수가 없습니다
typescript.validation.class.extend.many.constructors=기본 생성자의 반환 타입은 모두 동일해야 합니다
typescript.validation.class.extend.cycled.definition=순환적 클래스 정의
typescript.validation.class.extend.constructor.return.not.class=기본 생성자 반환 타입 ''{0}''은(는) 클래스 또는 인터페이스 타입이 아닙니다.
javascript.validation.generators.yield.not.iterable=표현식 타입에 [Symbol.iterator] 또는 [Symbol.asyncIterator]가 정의되어 있지 않습니다
javascript.validation.generators.yield.not.assignable.to.return=타입 ''{1}''을(를) 타입 ''{0}''에 할당할 수 없습니다
typescript.validation.generators.incorrect.type.annotation=제너레이터는 ''{0}'' 타입 어노테이션을 가질 수 없습니다
typescript.validation.async.incorrect.type.annotation=비동기 함수에 ''{0}'' 타입 어노테이션을 사용할 수 없습니다
typescript.validation.generators.incorrect.type.annotation.iterable=타입 ''{0}''을(를) 타입 ''{1}''에 할당할 수 없습니다.
typescript.validation.generators.overload=오버로드 시그니처를 제너레이터로 선언할 수 없습니다
typescript.validation.generators.ambient=제너레이터는 주변 컨텍스트에서 허용되지 않습니다.
typescript.validation.generators.no.yield=제너레이터는 어떤 값도 반환하지 않으므로 묵시적으로 ''IterableIterator<any>'' 타입을 가지고 있습니다. 반환 타입을 제공하는 것이 좋습니다.
typescript.validation.generators.async.no.yield=제너레이터는 어떤 값도 반환하지 않으므로 묵시적으로 ''AsyncIterableIterator<any>'' 타입을 가지고 있습니다. 반환 타입을 제공하는 것이 좋습니다.
typescript.validation.cannot.find.best.common.type=타입 인수를 사용 위치에서 추론할 수 없습니다.


# Surround with names
javascript.surround.with.do.while=do/while
javascript.surround.with.for=for
javascript.surround.with.if=if
javascript.surround.with.if.else=if/else
javascript.surround.with.if.cond=if (cond)
javascript.surround.with.if.else.cond=if (cond)/else
javascript.surround.with.parenthesis=(expr)
javascript.surround.with.not.parenthesis=\!(expr)
javascript.surround.with.cast=Type(expr)
javascript.surround.with.try.catch=try/catch
javascript.surround.with.try.finally=try/finally
javascript.surround.with.try.catch.finally=try/catch/finally
javascript.surround.with.while=while
javascript.surround.with.with=다음으로
javascript.surround.with.function=함수
javascript.surround.with.function.expression=함수 표현식
javascript.surround.with.object.literal=상수 객체

# Introduce variable
javascript.introduce.variable.title=변수 추출
javascript.introduce.variable.title.local=지역 변수 삽입
javascript.introduce.variable.error.no.expression.selected=변수를 삽입할 수 없습니다.\n선택 영역이 표현식을 형성하지 않습니다.
javascript.introduce.variable.error.expression.has.void.type=변수를 삽입할 수 없습니다.\n선택한 표현식 타입이 void입니다.
javascript.introduce.variable.name.prompt=이름(&N)\:
javascript.introduce.variable.replace.all.occurrences=모든 사용 위치 바꾸기({0}개 위치 발견)(&A)
javascript.introduce.variable.invalid.name=유효한 이름을 입력하세요.
javascript.introduce.element.already.exists=같은 이름의 {0}이(가) 범위 안에 이미 존재합니다.
javascript.introduce.variable.arrow.function.parameter.referenced=삽입할 수 없습니다.\n선택 영역이 화살표 함수 매개변수에 대한 참조를 포함합니다
javascript.introduce.variable.arrow.await.referenced=삽입할 수 없습니다.\n선택 영역이 await 표현식을 포함합니다
javascript.introduce.variable.xml.embedded=포함된 표현식에 변수를 삽입할 수 없습니다
javascript.introduce.incorrect.context=변수를 삽입할 수 없습니다.\n선택 영역이 ''this''에 대한 참조를 포함합니다
javascript.introduce.field.title=필드 삽입
javascript.introduce.field.error.no.expression.selected=변수를 삽입할 수 없습니다.\n선택 영역이 표현식을 형성하지 않습니다.
javascript.introduce.field.error.expression.has.void.type=변수를 삽입할 수 없습니다.\n선택한 표현식 타입이 void입니다.
javascript.introduce.field.error.no.enclosing.class=필드를 삽입할 수 없습니다.\n둘러싸는 클래스가 없습니다.
javascript.introduce.field.make.readonly=readonly로 설정(&R)
javascript.introduce.field.initialize.in.scope=다음에서 초기화(&I)
javascript.introduce.field.visibility=가시성(&V)\:
javascript.introduce.field.keyboard.hint={0}을(를) 눌러 키보드 단축키 보기
javascript.introduce.field.before.super.call=필드를 삽입할 수 없습니다.\n''super'' 호출 전에 ''this''에 액세스할 수 없습니다.
javascript.introduce.field.current.method=현재 메서드
javascript.introduce.field.field.declaration=필드 선언
javascript.introduce.field.constructor=생성자
javascript.introduce.constant.title=상수 삽입
javascript.introduce.constant.error.no.expression.selected=상수를 삽입할 수 없습니다.\n선택 영역이 표현식을 형성하지 않습니다.
javascript.introduce.constant.error.expression.has.void.type=상수를 삽입할 수 없습니다.\n선택한 표현식 타입이 void입니다.
javascript.introduce.constant.error.not.constant.expression.selected=상수를 삽입할 수 없습니다.\n선택 영역이 상수 표현식이 아닙니다.
javascript.introduce.parameter.title=매개변수 추출
javascript.introduce.parameter.error.no.expression.selected=매개변수를 삽입할 수 없습니다.\n선택 영역이 표현식을 형성하지 않습니다.
javascript.introduce.parameter.error.no.containing.function=매개변수를 삽입할 수 없습니다.\n사용할 포함 함수를 찾을 수 없습니다.
javascript.introduce.parameter.error.expression.has.void.type=매개변수를 삽입할 수 없습니다.\n선택한 표현식 타입이 void입니다.
javascript.introduce.parameter.error.not.async.context=''await''를 포함하는 표현식에 대한 매개변수를 삽입할 수 없습니다.\n모든 사용 위치가 비동기 함수 내에 있는 것은 아닙니다.
javascript.introduce.parameter.error.target.not.async=''await''를 포함하는 표현식에 대한 매개변수를 삽입할 수 없습니다.\n대상 함수가 비동기 함수가 아닙니다.
javascript.introduce.parameter.error.yield=''yield''를 포함하는 표현식에 대한 매개변수를 삽입할 수 없습니다.
javascript.introduce.parameter.generate.jsdoc=JSDoc 생성
javascript.introduce.parameter.optional.parameter=선택적 매개변수
javascript.introduce.throw.expressions.unsupported=리팩터링을 호출할 수 없습니다.\nthrow 표현식은 현재 ''추출'' 리팩터링에서 지원하지 않습니다.
javascript.introduce.breaks.operator.precedence=리팩터링을 호출할 수 없습니다.\n삽입은 표현식에서 연산자 우선 순위를 변경합니다.
javascript.introduce.constant.in.es5=리팩터링을 호출할 수 없습니다.\nECMAScript 3 또는 ECMAScript 5 코드에 상수를 삽입할 수 없습니다.
javascript.introduce.in.embedded.expression=리팩터링을 호출할 수 없습니다.\n포함된 표현식에 삽입할 수 없습니다.
javascript.introduce.variable.make.constant=상수 생성
list.item.class.field=클래스 필드
list.item.global.or.module.constant=전역 또는 모듈 상수
list.item.local.constant=지역 상수

# Highlighting categories
javascript.keyword=키워드
javascript.string=문자열
javascript.number=숫자
javascript.linecomment=줄 주석
javascript.doccomment=문서 주석
javascript.blockcomment=블록 주석
javascript.regexp=정규 표현식
javascript.operation=연산
javascript.parens=소괄호
javascript.brackets=대괄호
javascript.braces=중괄호
javascript.semicolon=세미콜론
javascript.badcharacter=잘못된 문자
jsdoc.text=JSDoc 텍스트
jsdoc.tag=JSDoc 태그
jsdoc.tag.value=JSDoc 태그 값
jsdoc.type=JSDoc 타입
javascript.doctag=문서 태그
javascript.doctagvalue=문서 태그 값
javascript.valid.string.escape=유효한 문자열 이스케이프
javascript.invalid.string.escape=잘못된 문자열 이스케이프
javascript.comma=쉼표
javascript.dot=점

# Errors with intentions
javascript.unresolved.function.name.message=미해결 함수 또는 메서드 {0}() \#loc
javascript.unresolved.variable.name.message=미해결 변수 {0} \#loc
javascript.unresolved.variable.null.qualifier.message={0}의 한정자가 null일 수 있습니다 \#loc
javascript.unresolved.variable.undefined.qualifier.message={0}의 한정자가 undefined일 수 있습니다 \#loc
javascript.unresolved.variable.null.or.undefined.qualifier.message={0}의 한정자가 null 또는 undefined일 수 있습니다 \#loc
javascript.unresolved.type.name.message=미해결 타입 {0} \#loc
javascript.unresolved.circle.definition=순환 가져오기 정의
javascript.missing.read.property=미해결 읽기 프로퍼티 \#loc
javascript.missing.write.property=미해결 쓰기 프로퍼티 \#loc
javascript.unresolved.variable.or.type.name.message=미해결 변수 또는 타입 {0} \#loc
javascript.unresolved.variable.or.type.name.message2=미해결 변수 또는 타입 {0}
javascript.unresolved.symbol.message=미해결 심볼
javascript.unresolved.file=파일 {0}을(를) 찾을 수 없습니다
javascript.unknown.metadata.tag=알 수 없는 메타데이터 태그
javascript.unknown.metadata.attribute=알 수 없는 메타데이터 속성
javascript.undeclared.variable.name.message=암시적으로 선언된 변수 {0} \#loc
javascript.create.function.intention.name=''{0}''함수 생성
javascript.create.variable.intention.name=변수 ''{0}'' 생성
javascript.create.constant.intention.name=상수 ''{0}'' 생성''
javascript.declare.variable.intention.name=''{1}''에 대한 {0} 선언 삽입
javascript.declare.variable.intention.family.name=var 선언 삽입
javascript.declare.variable.in.previous.var.statement.intention.name=이전 var 문에 ''{0}''에 대한 var 선언 삽입
javascript.declare.variable.in.previous.var.statement.intention.family=이전 var 문에 var 선언 삽입
javascript.create.field.intention.name=필드 ''{0}'' 생성
javascript.create.constant.field.intention.name=상수 필드 ''{0}'' 생성
javascript.create.method.intention.name=메서드 ''{0}''을(를) 생성합니다.
javascript.create.property.intention.name=프로퍼티 ''{0}'' 생성
javascript.create.function.property.intention.name=함수 프로퍼티 ''{0}'' 생성
javascript.create.constructor.intention.name=클래스 ''{0}''에서 생성자 생성
javascript.create.get.property.intention.name=''get'' 프로퍼티 ''{0}'' 생성
javascript.create.set.property.intention.name=''set'' 프로퍼티 ''{0}'' 생성
javascript.create.function.intention.family=JavaScript 함수 또는 메서드 생성
javascript.create.variable.intention.family=JavaScript 변수 또는 프로퍼티 생성
javascript.intention.create.getter.setter=''{0}''의 getter 및 setter 생성
javascript.intention.create.getter.setter.desc=getter 및 setter 생성
javascript.intention.create.setter=''{0}''의 setter 생성
javascript.intention.create.setter.desc=setter 생성
javascript.intention.create.getter=''{0}''의 getter 생성
javascript.intention.create.getter.desc=getter 생성
create.mobile.view=뷰 ''{0}'' 생성
javascript.rename.reference.intention.name=참조 이름을 변경합니다.
typescript.rename.javascript.references=JavaScript 파일에서 검색(&J)
typescript.rename.dynamic.references=동적 참조 검색(&D)
js.usage.type.string=문자열 리터럴에서 사용 위치
js.usage.type.call=함수 호출에서 사용 위치
js.anonymous.to.named.function=익명 함수를 명명된 함수로 변환
js.convert.to.named.function=명명된 함수로 변환
js.convert.to.named.function.to.class.method=클래스 메서드로 변환
js.convert.to.arrow.function=화살표 함수로 변환
js.add.braces.to.arrow.function=화살표 함수에 중괄호 추가
js.inspection.function.expression.is.used.instead.of.arrow=화살표 함수 대신 함수 표현식이 사용됩니다
js.arrow.function.braces.can.be.removed.key=화살표 함수 본문 주변의 중괄호를 제거할 수 있습니다.
js.arrow.function.braces.can.be.removed.problem.description=화살표 함수 본문 주변의 중괄호를 제거할 수 있습니다.
js.arrow.function.braces.can.be.removed.fix.family.name=화살표 함수 본문 주변 중괄호 제거
js.convert.to.anonymous.function.family.name=화살표 함수를 익명 함수로 변환
js.convert.to.anonymous.function=익명 함수로 변환
js.named.to.anonymous.family.name=함수 표현식으로 변환
js.named.to.function.expression.text=함수 표현식을 담은 변수로 변환
js.named.to.function.hoisting.conflict.text=함수는 선언 전에 사용됩니다. 변수로 변환 한 후 사용 위치가 끊어집니다
js.named.to.arrow.text=화살표 함수를 담은 {0}(으)로 변환
js.split.into.multiple.declarations=여러 선언으로 분할
js.remove.digit.separators=숫자 구분 기호 제거
js.copy.qualified.to.clipboard=클립보드에 정규화된 이름 복사
js.iterate=for..of로 반복
js.iterate.async=await..of로 반복
js.separate.digits=숫자 분리
js.separate.nibbles=니블 분리
js.separate.bytes=바이트 분리
js.separate.words=16비트 단어 분리
js.separate.thousands=천 단위 분리
js.separate.thousands.in.integer.part=정수 부분에서 천 단위 분리
js.split.declarations=선언 분할
js.replace.string.with.es6.template=템플릿 문자열로 바꾸기
js.replace.string.concatenation.with.es6.template.inspection.name=문자열 템플릿 대신 문자열 연결이 사용됩니다
js.replace.string.concatenation.with.es6.template.fix.text=템플릿 문자열로 바꾸기
js.string.template.line.separators.visible=가시선 구분 기호로 변환
js.string.template.line.separators.multispan=여러 줄 문자열 템플릿으로 변환
js.string.template.line.separators.visible.family.name=가시선 구분 기호를 사용하도록 템플릿 문자열 변환
js.string.template.line.separators.multispan.family.name=여러 줄 문자열 템플릿으로 변환
js.convert.var.to.let.text=let으로 변환
js.convert.var.to.const.text=const로 변환
js.convert.var.to.let.or.const=let/const로 변환
js.convert.var.to.let.or.const.family.name=var을 let/const로 변환
js.convert.var.to.let.or.const.inspection.text=''let'' 또는 ''const'' 대신 ''var''이 사용되었습니다
js.convert.let.to.const.inspection.text=''const''를 사용할 수 있는 곳에서 ''let''이 사용됩니다
js.convert.var.to.let.or.const.inspection.conservative.option=모든 작업 수정을 통해 var을 보수적으로 변환
js.convert.var.to.let.or.const.inspection.conservative.option.description=선언은 변수를 처음 사용하기 전에 함수의 맨 위로 이동할 수 있습니다.\n모든 작업 수정을 사용할 때 이 동작을 비활성화하려면 ''var을 보수적으로 변환'' 옵션을 확인하세요.
js.convert.require.into.es6.import.text=require()를 import로 변환
js.convert.require.into.es6.import.family.name=require()를 import로 변환
js.convert.require.into.es6.import.inspection.text=''import'' 대신 ''require()''이 사용됩니다
js.convert.require.into.es6.import.inspection.withConditional.option=모든 작업 수정을 통해 내부 범위 안에서 require() 변환
js.convert.require.into.es6.import.inspection.withConditional.option.description=내부 범위 안에서 require() 변환 (예\: ''if'' 문 또는 내부 함수)
js.convert.module.exports.into.es6.export.text=export로 변환
js.convert.module.exports.into.es6.export.family.name=export로 변환
js.convert.module.exports.into.es6.export.inspection.text=\ ''export'' 대신 ''module.export''가 사용됩니다
js.convert.for.in.to.for.of.text=''for..in''을 ''for..of''로 변환
js.convert.for.in.to.for.of.family.name=''for..in''을 ''for..of''로 변환
js.convert.for.in.to.for.of.inspection.text=''for..of'' 대신 ''for..in''이 사용됩니다
js.convert.indexed.for.to.for.of.text=색인 생성된 ''for''를 ''for..of''로 변환
js.convert.indexed.for.to.for.of.family.name=색인 생성된 ''for''를 ''for..of''로 변환
js.convert.indexed.for.to.for.of.inspection.text=색인 생성된 ''for'' 루프를 ''for..of''로 바꿀 수 있습니다
js.convert.for.each.to.for.of.intention.family=''forEach''를 ''for..of'' 루프로 바꾸기
js.convert.for.each.to.indexed.intention.family=''forEach''를 색인 생성된 ''for'' 루프로 바꾸기
js.convert.for.of.to.indexed.intention.family=''for..of''를 색인 생성된 ''for'' 루프로 바꾸기
js.convert.map.to.for.of.intention.family=''map'' 배열 호출을 ''for..of'' 루프로 바꾸기
js.convert.indexed.for.to.foreach.intention.family=색인 생성된 ''for''을 ''forEach'' 배열 호출로 변환
js.add.then.fix=''.then()'' 추가
js.quote.unquote.intention.plural={0} 프로퍼티 이름
js.quote.unquote.intention.singular={0} 프로퍼티 이름
js.quote.unquote.intention.quote=따옴표
js.quote.unquote.intention.unquote=따옴표 해제
js.property.to.indexer.intention=인덱서 액세스로 바꾸기
js.indexer.to.property.intention=프로퍼티 액세스로 바꾸기
js.join.vars.intention=후속 변수 선언 결합
js.infer.parameter.types.intention=사용 위치에서 매개변수 타입 추론
js.infer.parameter.types.intention.jsdoc=사용 위치에서 JSDoc 매개변수 타입 추론
js.infer.parameter.types.intention.failure.title=타입을 추론할 수 없습니다
js.infer.parameter.types.intention.progress.text=타입 추론
js.infer.parameter.types.intention.failure.text=사용 위치에서 타입을 추론할 수 없습니다
js.infer.parameter.types.intention.failure.readonly.text=사용 위치에서 타입을 추론할 수 없습니다. 파일이 읽기 전용입니다

# Move module members
es6.move.module.members.refactoring.name=모듈 멤버 이동
es6.move.module.members.table.title=이동할 멤버
es6.move.module.members.refactoring.create.file=파일 생성
es6.move.module.members.refactoring.file.does.not.exist=파일 {0}이(가) 없습니다
es6.move.module.members.refactoring.create.file.message=파일 {0}이(가) 없습니다.\n생성하시겠어요?
es6.move.module.members.refactoring.dialog.error.no.script.tag=대상 파일에 스크립트 태그가 없습니다
es6.move.module.members.refactoring.dialog.error.invalid.file.name=대상 파일 이름이 이 운영 체제에서 유효하지 않습니다
es6.move.module.members.refactoring.dialog.error.no.selected.items=선택된 이동할 멤버가 없습니다
es6.move.module.members.refactoring.dialog.error.incorrect.module=대상 모듈이 올바르지 않습니다
es6.move.module.members.refactoring.dialog.error.modules.same=소스와 대상 모듈은 달라야 합니다
es6.move.module.members.refactoring.dialog.move.member.to=멤버 이동
es6.move.module.members.refactoring.dialog.field.from=From\:
es6.move.module.members.refactoring.dialog.field.to=To\:
es6.move.module.members.references.unresolved.import.message=선택한 {0}이(가) 해결되지 않은 import {1}을(를) 참조합니다
es6.move.module.members.references.local.message=선택한 {0}이(가) 내보내기되지 않은 {1}을(를) 참조합니다
es6.move.module.members.has.local.usage.message=내보내기 하지 않은 {0}이(가) 파일 {1}에서 사용됩니다
es6.move.module.members.non.es6.module.usage={0}은(는) ES6 모듈이 아닌 파일 {1}에서 사용됩니다
es6.move.module.members.destination.not.es6=대상 파일 {0}은(는) ES6 모듈이 아닙니다
es6.move.module.members.cannot.detect.js.language=대상 파일이 JS 파일이 아닙니다.
es6.move.module.members.destination.contains.default.export=대상 모듈이 디폴트 내보내기를 포함합니다
es6.move.module.members.destination.does.not.support.jsx={0}은(는) JSX 태그를 포함하지만 대상 언어는 이를 지원하지 않습니다
es6.move.module.members.syntax.errors=대상 언어가 소스와 다르므로 {0}을(를) 이동하면 구문 오류가 발생합니다
es6.move.module.members.incompatible.language=대상 모듈에 호환되지 않는 언어가 있습니다
dialog.title.move.members=멤버 이동

js.pull.up.will.be.made.abstract=추상이 아닌 {0}이(가) 추상으로 설정됩니다
es6.extract.super.destination.label=대상 파일(&D)\:
es6.extract.super.members.in.interface=새 인터페이스의 멤버
es6.extract.super.members.in.superclass=새로운 상위 클래스의 멤버
es6.extract.super.overload.declaration.without.implementation.conflict=구현하지 않은 오버로드 선언 {0}은(는) 클래스에서 허용되지 않습니다
es6.extract.super.different.name.expected=다른 이름이 필요합니다

# Unit testing
js.testing.inspection.group.name=유닛 테스트
js.testing.highlight.line=테스트 코드에서 실패 줄 강조 표시
rc.environmentVariables.label=환경 변수(&E)\:
rc.testRunScope.all=모든 테스트(&L)
rc.testRunScope.testFile=테스트 파일(&F)
rc.testRunScope.suite=도구
rc.testRunScope.test=테스트(&T)
rc.nodeOptions.label=노드 옵션(&O)\:
rc.workingDirectory.label=작업 디렉터리(&W)\:
rc.workingDirectory.browseDialogTitle=작업 디렉터리 선택
rc.testOrSuiteScope.suite.title=도구 이름 편집
rc.testOrSuiteScope.suite.label=도구 이름\:
rc.testOrSuiteScope.test.title=테스트 이름 편집
rc.testOrSuiteScope.test.label=테스트 이름\:
rc.testOrSuiteScope.emptyTest=빈 테스트 이름
rc.testRunScope.testFile.label=테스트 파일\:
rc.testRunScope.testFile.browseTitle=테스트 파일 선택

# Unit testing: Jest
jest.snapshot.update.rc.name={0}에 대한 스냅샷 업데이트
jest.snapshot.update.single.test.text=''{0}''의 <link>스냅샷을 업데이트하려면 클릭</link>하세요
jest.snapshot.update.test.file.text={0}에서 <link>실패한 스냅샷을 업데이트하려면 클릭하세요</link>
jest.snapshot.update.all.tests.text=<link>실패한 스냅샷을 모두 업데이트하려면 클릭하세요</link>
jest.rc.configurationFile.label=구성 파일(&C)\:
jest.rc.configurationFile.title=Jest 설정 파일 선택
jest.rc.jestPackageField.label=Jest 패키지(&J)\:
jest.rc.jestOptions.label=Jest 옵션\:
jest.rc.jestOptions.emptyText=CLI 옵션(예\: --watch 또는 --env\=jsdom)
jest.coverage.notification.title=Jest 커버리지
jest.coverage.directory.not.found.notification.content=Jest 구성에서 coverageDirectory 옵션을 읽을 수 없습니다
jest.coverage.cannot.find.lcov.info.notification.content=Jest 커버리지를 표시할 수 없습니다. {0}을(를) 찾을 수 없습니다.

# Unit testing: Protractor
protractor.rc.configurationFile.label=구성 파일(&C)\:
protractor.rc.configurationFile.title=Protractor 설정 파일 선택
protractor.rc.protractorPackage.label=Protractor 패키지(&P)\:
protractor.rc.protractorOptions.label=Protractor 옵션(&O)\:
protractor.rc.protractorOptions.emptyText=CLI 옵션(예\: --browser 또는 --rootElement)

# Node.js
node.js.inspection.group.name=Node.js
node.js.missing.require=require() 문 누락
node.js.unresolved.api=미해결 Node.js API
node.js.invalid.node=프로젝트에서 Node.js에 대한 유효하지 않은 경로를 사용했습니다.<br>{0}의Node.js를 사용하도록 업데이트되였습니다.
node.js.configure=Node.js 설정
node.js.downloading=Node.js {0} 다운로드
node.js.interpreters=Node.js 인터프리터
node.js.set.project.interpreter.action=프로젝트 인터프리터로 설정
node.js.add.interpreter.action={0} 추가...
notification.title.cannot.enable.node.js.coding.assistance=Node.js 코딩 지원을 활성화할 수 없음
notification.title.cannot.download.types.node=@types/node를 다운로드할 수 없음
status.text.add.interpreter.with={0}(으)로 인터프리터 추가
status.text.no.interpreters.added=추가할 인터프리터가 없습니다
popup.content.cannot.edit.selected.node.js.interpreter=선택한 Node.js 인터프리터를 편집할 수 없습니다
node.no.interpreter=인터프리터가 없습니다
node.interpreter.not.found={0}(을)를 찾을 수 없습니다
no.executable.found.in.path={0, choice, 0\#%PATH%|1\#$PATH}에서 실행 파일을 찾을 수 없습니다
merged.process.output.text={0}{2, choice, 0\#\n\n표준 오류\:\n{1}|1\#}{4, choice, 0\#\n\n표준 출력\:\n{3}|1\#}\n\n{5}
node.interpreter.download=Node.js 다운로드
node.interpreter.project_node.reference.name=프로젝트
node.interpreter.node_from_path.reference.name=노드

# Inspections
js.inspection.group.name=일반
typescript.inspection.group.name=TypeScript
js.inspection.bitwise.group.name=비트 연산 이슈
js.code.style.issues.group.name=코드 스타일 이슈
js.probable.bugs.group.name=발생할 수 있는 버그
js.annotator.inspection.name=JavaScript 일반 오류
js.inspection.convert.to.es6.group.name=ECMAScript 6 마이그레이션 지원
js.inspection.switch.group.name=switch 문제 이슈
js.inspection.async.group.name=비동기 코드 및 프로미스
js.function.metrics.group.name=함수 메트릭
js.validity.issues.group.name=유효성 이슈
js.imports.dependencies.group.name=import 문 및 종속성
js.unused.symbols.group.name=사용하지 않는 심볼
js.unwanted.symbols.group.name=코드 구문이 바람직하지 않을 수 있습니다
js.assignment.issues.group.name=할당 이슈
js.potentially.invalid.usage.of.this.inspection.name=클로저에서 ''this''에 대한 참조가 유효하지 않을 수 있습니다
js.potentially.invalid.usage.of.class.this.inspection.name=클로저에서 클래스의 ''this''에 대한 참조가 유효하지 않을 수 있습니다
js.potentially.invalid.target.of.indexed.property.access.inspection.name=색인 생성된 프로퍼티 액세스 대상이 잘못되었을 수 있습니다
javascript.potentially.invalid.usage.of.this=this의 사용 위치가 유효하지 않을 수 있습니다
javascript.potentially.invalid.usage.of.class.this=중첩 함수의 ''this.''를 통해 클래스 필드에 대한 참조 액세스가 유효하지 않을 수 있습니다
javascript.potentially.invalid.target.of.indexed.property.access=색인 생성된 프로퍼티 액세스 대상이 유효하지 않을 수 있습니다
js.unfiltered.for.in.loop.inspection.name=필터링되지 않은 for..in 루프
javascript.unfiltered.for.in.loop=예기치 않은 (사용자 지정/상속된) 멤버에 대한 반복이 있을 수 있습니다, hasOwnProperty 검사가 누락되었을 수 있습니다
js.unfiltered.for.in.loop.skip.primitives=배열 또는 객체 이니셜라이저를 사용한 참조를 통해 반복 건너뛰기
js.unfiltered.for.in.loop.skip.primitives.tooltip=Object. prototype 및 Array.prototype이 수정되지 않은 경우 활성화
js.referencing.mutable.variable.from.closure.inspection.name=클로저에서 가변 변수 참조
javascript.mutable.variable.accessible.from.closure=가변 변수는 클로저에서 액세스할 수 있습니다
js.unresolved.variable.inspection.name=미해결 JavaScript 변수
ts.unresolved.variable.inspection.name=해결되지 않은 TypeScript 변수
js.undeclared.variable.inspection.name=암시적으로 선언된 전역 JavaScript 변수
js.duplicate.declaration.inspection.name=JavaScript 선언 중복
# WI-11522 only the first word should start with uppercase letter
js.linters.inspection.group.name=코드 품질 도구
js.linters.detect.automatically.caption=가장 가까운 package.json에서 패키지 및 설정 파일 탐지
js.unused.local.symbol.inspection.name=사용하지 않는 지역 심볼
js.unused.es6.import.inspection.name=사용하지 않는 ES6/TypeScript import 문
js.unused.assignment.inspection.name=사용하지 않는 할당
js.join.declaration.assignment.inspection.name=변수 선언을 변수에 대한 첫 번째 할당과 병합할 수 있습니다
js.join.declaration.assignment.inspection.fix=변수 선언 및 할당 결합
js.unused.global.symbol.inspection.name=사용하지 않는 전역 심볼
js.missing.await.symbol.inspection.name=비동기 함수 호출을 위한 await 누락
js.missing.await.symbol.inspection.for.returns=실수를 방지하고 V8 비동기 스택 추적을 위해 항상 비동기 함수 호출에 ''await''를 사용합니다
js.missing.await.symbol.inspection.for.generator.name=for-await 루프를 사용하여 비동기 제너레이터를 반복해야 합니다
jsx.missing.namespace.inspection.name=JSX로 React 가져오기 누락
jsx.missing.namespace.inspection.text=JSX는 {0} 가져오기 없이 사용됩니다
tsx.missing.name.quick.fix.name="{0} import 문 추가 
js.destructuring.merge.inspection=동일한 키로 구조 분해 프로퍼티를 병합할 수 있습니다
js.destructuring.merge.inspection.text=동일한 키로 구조 분해 프로퍼티를 병합할 수 있습니다
js.destructuring.merge.inspection.fix=구조 분해 프로퍼티 병합
js.nested.template.literal.inspection=템플릿 리터럴 내 불필요한 중첩
js.nested.template.literal.fix=인라인 중첩 리터럴
js.redundant.await.inspection=불필요한 ''await'' 표현식
js.await.promise.resolve.inspection=불필요한 ''await Promise.resolve()''
js.await.promise.reject.inspection=불필요한 ''await Promise. reject()''
js.await.promise.double.await.inspection=불필요한 ''await await''
js.await.promise.return.await.inspection=불필요한 ''return await''
js.await.promise.trivial.await.inspection=프로미스가 아닌 타입에 대한 불필요한 ''await''
js.await.promise.resolve.fix=''{0}''(으)로 바꾸기
js.top.level.await.expression.inspection= 최상위 ''await'' 표현식
js.top.level.await.expression.inspection.description= 최상위 ''await'' 표현식이 사용되었습니다.
js.possibly.async.function.inspection=비동기 함수가 있을 가능성이 있습니다
js.await.in.synchronous.function=''await'' 연산자는 ''async'' 함수에서만 사용할 수 있습니다
js.possibly.async.function.quick.fix=함수 {0} 비동기화
js.possibly.async.function.quick.fix.family.name=함수 비동기화
js.property.can.be.replaced.with.shorthand=프로퍼티를 약어로 바꿀수 있습니다
js.property.can.be.replaced.with.shorthand.method=프로퍼티를 축약 메서드로 바꿀수 있습니다
js.replace.with.shorthand.property.quick.fix=축약 프로퍼티로 바꾸기
js.replace.with.shorthand.method.quick.fix=축약 메서드로 바꾸기
js.expand.shorthand.property.quick.fix=축약 프로퍼티 확장
js.unresolved.function.inspection.name=미해결 JavaScript 함수
ts.unresolved.function.inspection.name=해결되지 않은 TypeScript 함수
js.unresolved.react.component.name=해결되지 않은 React 구성 요소
js.deprecated.symbols.inspection.name=곧 사용할 수 없게 될 JavaScript 심볼
js.suspicious.eq.plus.inspection.name=의심스러운 ''\=+'' 할당
js.suspicious.eq.plus.inspection.desc=의심스러운 ''\=+'' 할당\: ''+\=''의 맞춤법이 잘못되었을 수 있습니다
js.suspicious.eq.plus.fix.name=''+\=''로 바꾸기
js.suspicious.name.combination.inspection.name=의심스러운 이름 조합
js.bitwise.operator.usage.name=비트 연산 사용 위치
js.bitwise.operator.usage.popup=비트 연산자가 사용되었습니다
js.bitwise.operator.usage.quickfix={0}(으)로 바꾸기
js.potentially.invalid.constructor.usages.inspection.name=생성자 사용 위치가 유효하지 않을 수 있습니다
js.mismatched.update.collection.inspection.name=일치하지 않는 쿼리 및 컬렉션 업데이트
js.mismatched.update.collection.update.method.names=메서드 이름 업데이트
js.closure.compiler.syntax.inspection.name=클로저 컴파일러 구문
js.closure.compiler.syntax.implements.not.interface={0}에 @interface 어노테이션이 없습니다
js.closure.compiler.syntax.cyclic.inheritance={0} 관련 순환 상속
js.closure.compiler.syntax.empty.type=빈 타입을 사용할 수 없습니다
js.closure.compiler.syntax.invalid.type=유효하지 않은 타입 구문
collection.updated.but.not.queried=컬렉션 <code>\#ref</code>의 내용은 업데이트되지만 쿼리되지 않습니다
collection.queried.but.not.update=컬렉션 <code>\#ref</code>의 내용이 쿼리되지만 쓰기가 되지 않습니다
javascript.constructor.with.lower.case.name.used.message=생성자 이름은 일반적으로 대문자로 시작합니다. 오타인가요?
interface.function.declaration.should.have.no.body=인터페이스 함수 선언은 본문을 가질 수 없습니다
javascript.ambient.declaration.should.have.no.body=주변 선언은 본문을 가질 수 없습니다
javascript.ambient.declaration.should.have.no.initializer=앰비언트 선언은 이니셜라이저를 가질 수 없습니다
javascript.ambient.declaration.const.should.be.primitive=주변 컨텍스트의 ''const'' 이니셜라이저는 기본 리터럴 또는 리터럴 열거형 참조여야 합니다
javascript.deprecated.symbol.used.name.message=곧 사용할 수 없게 될 심볼이 사용되었습니다, 더 나은 심볼로 대체하려면 문서를 참조하세요 \#loc
javascript.deprecated.symbol.used.name.message2=버전 {0} 심볼이 deprecated(더 이상 사용되지 않음)로 표시되어 있으므로, {1}을(를) 대신 사용하세요 \#loc
js.unused.symbol=사용하지 않는 {0} \#ref
js.unused.symbol.full=사용하지 않는 {0}
js.unused.symbol.remove=사용하지 않는 {0} 제거
js.suspicious.name.assignment=''{0}''을(를) {1}''에 할당할 수 없습니다
js.suspicious.name.parameter=''{0}''을(를) 매개변수 ''{1}''로 전달할 수 없습니다
js.suspicious.name.return=''{0}''을(를) 메서드 ''{1}''에서 반환할 수 없습니다
js.constructor.cant.have.return.type=생성자는 반환 타입을 가질 수 없습니다
invalid.identifier.value.0=유효하지 않은 식별자\: ''{0}''
js.suspicious.bind.with.arrow.function=의심스러운 화살표 함수와 ''bind'' 사용 위치
javascript.change.signature.invalid.parameter.declaration=유효하지 않은 매개변수\: ''{0}''
javascript.change.signature.invalid.function.name.0=유효하지 않은 함수 이름\: ''{0}''
javascript.validation.generators.yield.not.in.generator=''yield'' 표현식은 제너레이터 본문에서만 허용됩니다.
javascript.validation.new.target.not.in.function=메타 프로퍼티 ''new.target''은 함수 선언, 함수 표현식 또는 생성자의 본문에만 허용됩니다
javascript.validation.message.this.referenced.from.static.context=정적 컨텍스트에서 참조된 ''this''
javascript.validation.message.super.referenced.without.class.instance.context=클래스 인스턴스 컨텍스트 없이 참조된 ''super''
javascript.validation.message.super.referenced.from.static.context=정적 컨텍스트에서 참조된 ''super''
javascript.validation.message.function.override.without.override.modifier=메서드가 키워드를 재정의하지 않고 상위 클래스 {0}의 메서드를 재정의합니다
javascript.validation.multiple.var.in.for.loop=''{0}'' 루프에 단일 변수만 허용됩니다
javascript.validation.initialized.var.in.for.loop=변수 이니셜라이저는 ''{0}'' 루프에서 허용되지 않습니다
javascript.fix.add.override.modifier=재정의 제어자 추가
javascript.fix.property.spelling.family=프로퍼티 이름에 가능한 오타 수정
javascript.fix.property.spelling.text=''{0}'' 맞춤법 조정
js.code.style.tab.name=JavaScript
js.code.style.file.name.relaxed.style=현재 파일의 대/소문자 재사용
js.code.style.file.name.camel.style=낙타 표기법(appComponent)
js.code.style.file.name.pascal.style=파스칼 표기법(AppComponent)
js.code.style.file.name.snake.style=스네이크 표기법(app_component)
js.code.style.file.name.lisp.style=대시 표기법(app-component)
js.code.style.file.name.mixed.style=접미사가 있는 대시 표기법(my-app.component)
es6.code.style.path.mapping.always=항상
es6.code.style.path.mapping.never=안 함
es6.code.style.path.mapping.different.paths=지정된 경로 외부의 파일에서만
typescript.code.style.tab.name=TypeScript
jsx.code.style.attribute.default.value=JSX 속성에 추가\:
jsx.code.style.attribute.default.value.braces=중괄호
jsx.code.style.attribute.default.value.quotes=따옴표
jsx.code.style.attribute.default.value.none=없음
jsx.code.style.attribute.default.value.typebased=타입 기반
javascript.formatting.options.panel.naming.conventions=이름 지정 규칙
javascript.formatting.options.panel.comments=주석
js.convert.parameters.to.object.intention.name=매개변수를 객체로 변환
js.convert.parameters.to.object.with.interface.intention.name=매개변수 객체 변환 및 인터페이스 삽입
js.convert.parameters.to.object.non.call.usage.will.not.be.updated=비호출 사용 위치는 업데이트되지 않습니다
js.convert.parameters.to.object.usage.will.not.be.updated.for.contextual.type=메서드는 인터페이스 메서드를 구현합니다. 기본 메서드가 업데이트되지 않습니다.
js.convert.parameters.to.object.usage.will.not.be.updated.for.spread=비종단 전개 인수를 사용한 호출은 업데이트되지 않습니다
js.undefined.property.assignment.inspection.name=정의되지 않은 프로퍼티 할당
js.undefined.property.assignment.inspection.message=프로퍼티 {0}이(가) 타입 {1}(으)로 정의되지 않았습니다
js.jquery.efficiency.inspection.name=JQuery 사용 위치 효율성
js.jquery.efficiency.inspection.allow.attribute.and.pseudo.selectors=속성 및 의사 선택자 허용
js.jquery.efficiency.inspection.attribute.used.message=jQuery 속성 선택자는 비효율적일 수 있습니다
js.jquery.efficiency.inspection.pseudoselector.used.message=jQuery 의사 선택자는 비효율적일 수 있습니다
js.jquery.efficiency.inspection.duplicated.selector=jQuery 선택자 중복
js.accessibility.check.inspection.name=@private 및 @protected 멤버 접근성
js.convert.to.foreach.intention.name=배열에서 forEach 호출로 변환
js.consecutive.commas.in.array.literal.inspection.name=배열 리터럴의 연속 쉼표
js.consecutive.commas.in.array.literal.inspection.message=배열 리터럴의 연속 쉼표
js.consecutive.commas.in.array.literal.inspection.insert.undefined=''undefined'' 삽입
js.check.function.signature.guess.optionality=매개변수 선택성 추측
js.check.function.signature.guess.optionality.hint=비활성화하면 타입이 지정되지 않은 모든 매개변수가 선택 사항으로 간주됩니다
es6.redundant.await.report.for.promises=프로미스 보고
es6.redundant.await.report.for.promises.hint=항상 ''return await''은 항상 필요없는 것으로 보고되지만 V8의 비동기 스택 추적 기능을 무효화합니다
es6.missing.await.report.for.promises=return 문의 프로미스 보고
es6.missing.await.report.for.promises.hint=비동기 함수 호출 전에 ''await''를 사용하면 V8이 비동기 스택 추적을 제공하는 데 도움이 됩니다
js.file.references.inspection.name=파일 참조 유효성 검사
js.file.references.inspection.ignore.complex.cases=복잡한 사례 무시
js.inspection.es6.modules.dependencies.family.name=import 문 누락
js.inspection.amd.modules.dependencies.family.name=AMD 모듈 종속성 누락
js.inspection.promise.ignored.display.name=프로미스를 반환 하는 메서드 호출의 결과는 무시됩니다
js.inspection.promise.ignored.problem.descriptor={0}에서 반환되는 프로미스는 무시됩니다
js.inspection.promise.value.expected.problem.descriptor={0}에서 반환되는 프로미스는 값이 기대되는 위치에서 사용됩니다
js.flowjs.group.name=Flow 타입 검사기
js.flowjs.config.inspection.name=.flowconfig 누락
js.flowjs.config.inspection.message=관련 .flowconfig가 없습니다
js.flowjs.coverage.inspection.name=코드는 Flow에서 다루지 않습니다.
js.flowjs.coverage.inspection.error.text=이 요소는 Flow에서 다루지 않습니다
js.flowjs.config.inspection.to.project.path.name=프로젝트 루트에 .flowconfig 추가
js.flowjs.config.inspection.to.module.path.name=모듈 콘텐츠 루트에 .flowconfig 추가
js.flowjs.config.inspection.to.current.path.name=현재 디렉터리에 .flowconfig 추가
js.flowjs.annotation.inspection.name=Flow 오류
js.flowjs.flag.comment.placement.inspection.name=Flow 플래그가 잘못 배치되었습니다
js.flowjs.flag.comment.placement.inspection.error=Flow 플래그 주석이 파일 시작에 있지 않습니다
js.flowjs.flag.comment.placement.inspection.fix=Flow 플래그 주석을 파일 시작으로 이동
js.flowjs.flag.without.language.version=Flow 언어 버전이 없는 Flow 플래그
js.extjs.unresolved.ext.xtype.inspection.name=미해결 Flow JS xtype
js.frameworks.sencha.xtype.not.found=xtype ''{0}''에 대한 Ext JS 클래스를 찾을 수 없습니다
javascript.equality.comparison.with.coercion.family.name=타입 강제 변환 없이 바꾸기
javascript.equality.comparison.with.coercion.display.name=동치 연산자는 타입 강제 변환을 일으킬 수 있습니다
javascript.equality.comparison.with.coercion.error.string=비교 \#ref이(가) 예기치 않은 타입 강제 변환을 일으킬 수 있습니다 \#loc
javascript.equality.comparison.with.coercion.fix=''{0}''(으)로 바꾸기
javascript.equality.comparison.with.coercion.options.label=''\=\='' 및 ''\!\='' 사용 위치 강조 표시\:
javascript.equality.comparison.with.coercion.option.always=모두
javascript.equality.comparison.with.coercion.option.always.except.null=null 또는 typeof와 비교하는 경우를 제외한 모두
javascript.equality.comparison.with.coercion.option.only.suspicious=의심스러운 표현식만
js.strict.mode.inspection.name=비엄격 모드가 사용되었습니다
js.strict.mode.inspection.error={0}이(가) 엄격 모드가 아닙니다
js.strict.mode.inspection.fix="use strict" 프라그마 추가
js.strict.mode.inspection.redundant.pragma="use strict" 프라그마가 불필요합니다
js.strict.mode.remove.pragma="use strict" 프라그마 제거
js.class.member.initialization.inspection.name=정적 이니셜라이저에서 할당되지 않은 프로퍼티가 사용될 가능성이 있습니다
js.class.member.initialization.inspection.text=필드 ''{1}''이(가) ''{0}'' 이후 선언되었으며 아직 할당되지 않았을 수 있습니다
js.class.member.initialization.inspection.text.id=필드 ''{0}''이(가) 자신을 참조합니다
js.assignment.used.as.condition.name=할당이 조건으로 사용되었습니다
js.assignment.used.as.condition.text=<code>\#ref</code>가 조건으로 사용되었습니다
js.assignment.used.as.condition.fix=''\=''을(를) ''{0}''(으)로 바꾸기
js.missing.switch.branches.inspection.name=''switch'' 문에 분기가 누락되었습니다
js.missing.switch.branches.inspection.desc=''switch'' 문이 case를 누락합니다. {0}
js.missing.switch.branches.ignore.with.default=디폴트 분기가 있는 switch 문 무시
js.unreachable.switch.branches.inspection.name=도달할 수 없는 ''switch'' 문의 ''case'' 분기
js.unreachable.switch.branches.inspection.desc=도달할 수 없는 ''case'' 분기
js.unreachable.switch.branches.ignore.with.dynamic=동적 타입의 컨텍스트에서 이 경고를 표시하지 마세요
js.unreachable.switch.branches.remove=도달할 수 없는 ''case'' 분기 제거
js.redundant.switch.problems.inspection.name=''switch'' 문은 중복이며 바꿀 수 있습니다
js.redundant.switch.problems.inspection.empty=''switch'' 문이 비어 있습니다
js.redundant.switch.problems.inspection.empty.remove=빈 ''switch'' 문 제거
js.redundant.switch.problems.inspection.default=''switch'' 문이 단일 ''default'' 절만 포함합니다
js.redundant.switch.problems.inspection.default.unwrap=''switch'' 문 줄바꿈 해제
js.redundant.switch.problems.inspection.side.effects=및 부작용 추출
js.redundant.switch.problems.inspection.single=''switch'' 문이 default가 아닌 단일 절만 포함합니다
js.redundant.switch.problems.inspection.single.replace=''switch''를 ''if''로 바꾸기
js.switch.no.default=''switch'' 문에 ''default'' 분기가 없습니다
js.switch.no.default.add=누락된 디폴트 분기 생성
js.variable.problems.inspection.name=변수가 선언되고 다른 ''case'' 절에서 사용됩니다
js.variable.problems.inspection.desc=변수 ''{0}''이(가)  절 ''{1}''에서 선언되었지만 에서 절 ''{2}''에서 사용됩니다
js.variable.problems.inspection.desc.ref.error=액세스 시 참조 오류
js.variable.problems.ignore.desc=var-변수 무시
js.inspection.package.json.dependencies=package.json에서 일치하지 않는 종속성
js.inspection.missing.amd.dependency=AMD 모듈 종속성 누락
js.inspection.missing.import=import 문 누락
js.inspection.missing.module.dependency=모듈 종속성 누락
typescript.narrowed.to=''{0}''(으)로 좁혀졌습니다
label.exclude.methods.classes=클래스의 메서드 제외\:
dialog.title.add.classes=클래스 추가
typescript.suspicious.constructor.parameter.assignment=생성자에서 의심스러운 매개변수 할당이 있습니다. ''this.'' 추가를 잊으셨나요?
typescript.suspicious.constructor.parameter.assignment.desc=생성자에서 의심스러운 매개변수 할당
typescript.abstract.class.constructor.can.be.made.protected=추상 클래스 생성자를 protected로 만들 수 있습니다
typescript.make.constructor.protected=생성자를 protected로 설정
typescript.private.field.modifiers.mix=전용 이름 필드는 ''public'', ''private'' 또는 ''protected'' 접근 제어자 가질 수 없습니다
javascript.validation.message.flowjs.path=Flow 경로가 잘못되었습니다
javascript.validation.message.interface.members.cannot.have.access.modifiers=인터페이스 멤버는 접근 제어자를 가질 수 없습니다
javascript.validation.message.interface.members.cannot.have.namespace.attributes=인터페이스 멤버는 네임스페이스 속성을 가질 수 없습니다
javascript.validation.message.interface.members.cannot.be.final.modifiers=인터페이스 멤버는 final일 수 없습니다.
javascript.validation.message.static.modifier.is.allowed.only.for.class.members=static 제어자는 클래스 멤버에만 허용됩니다
javascript.validation.message.interface.cannot.be.final.modifiers=인터페이스는 final일 수 없습니다
javascript.template.context.type=JavaScript 및 TypeScript(&R)
interface.should.have.no.variable.declarations=인터페이스는 변수 선언을 가질 수 없습니다
javascript.validation.message.implements.for.interface.not.allowed=인터페이스에 대한 구현 목록이 허용되지 않습니다
javascript.validation.message.interface.name.expected.here=인터페이스 이름 필요
javascript.validation.message.class.name.expected.here=클래스 이름이 필요합니다
javascript.validation.message.circular.dependency=순환 종속성
javascript.validation.message.index.no.type=색인 시그니처 매개변수는 타입 어노테이션이 필요합니다
javascript.validation.message.index.wrong.type=색인 시그니처 매개변수 타입은 ''string | number | symbol''에 할당이 가능해야 합니다
javascript.fix.remove.circular.dependency=순환 종속성 제거
react.jsx.syntax.used.name=사용된 React JSX 구문
react.jsx.syntax.used.description=React JSX 구문이 사용되었습니다
js.void.function.result.used.name=void 함수 반환 값이 사용됨
js.void.function.result.used.description=void 함수 반환 값이 사용되었습니다

# JSDoc validation
javascript.validation.message.interface.method.not.implemented=인터페이스 {1}에서 메서드 {0}이(가) 구현되지 않습니다
javascript.validation.message.abstract.method.not.implemented=클래스 {1}에서 추상 메서드 {0}이(가) 구현되어 있지 않습니다
javascript.validation.message.abstract.get.accessor.not.implemented=클래스 {1}에서 추상 get 접근자 {0}이(가) 구현되어 있지 않습니다
javascript.validation.message.abstract.set.accessor.not.implemented=클래스 {1}에서 추상 set 접근자 {0}이(가) 구현되어 있지 않습니다
javascript.validation.message.interface.property.not.implemented=인터페이스 {1}에서 프로퍼티 {0}이(가) 구현되지 않습니다
javascript.validation.message.interface.get.accessor.not.implemented=클래스 {1}에서 프로퍼티 get 접근자 {0}이(가) 구현되지 않습니다
javascript.validation.message.interface.set.accessor.not.implemented=인터페이스 {1}에서 프로퍼티 set 접근자 {0}이(가) 구현되지 않습니다

javascript.validation.message.class.method.incompatible= 클래스 ''{1}''의 메서드 ''{0}''을(를) 기본 {2}''에서 동일한 메서드에 할당할 수 없습니다
javascript.validation.message.class.property.incompatible= 클래스 ''{1}''의 프로퍼티 ''{0}''을(를)  기본 ''{2}''에서 동일한 프로퍼티에 할당할 수 없습니다
javascript.validation.message.class.method.not.implemented=클래스 {1}에서 메서드 {0}이(가) 구현되지 않습니다
javascript.validation.message.class.property.not.implemented=클래스 {1}에서 프로퍼티 {0}이(가) 구현되지 않습니다
javascript.validation.message.interface.call.signature.not.implemented=인터페이스 {0}에서 호출 시그니처가 구현되지 않습니다
javascript.validation.message.interface.index.signature.not.implemented=인터페이스 {0}에서 색인 시그니처가 구현되지 않습니다
javascript.validation.message.class.setter.cannot.have.return.type=''set'' 접근자는 반환 타입을 가질 수 없습니다
javascript.fix.remove.externally.visible.symbol=외부에서 볼 수 있는 심볼 제거
javascript.fix.remove.abstract.keyword=''abstract'' 제어자 제거
javascript.fix.remove.modifier=제어자 제거
javascript.fix.implement.members=멤버 구현
javascript.fix.implement.methods=메서드 구현
javascript.implement.all.interfaces=모든 멤버 구현
javascript.implement.required.interfaces=필요한 모든 멤버 구현
javascript.implement.members.abstract=멤버를 추상으로 구현

# Symbols
javascript.parameter=매개변수
javascript.local.variable=지역 변수
javascript.global.variable=전역 변수
javascript.global.function=전역 함수
javascript.local.function=지역 함수
javascript.global.decorator=데코레이터
javascript.static.member.function=정적 멤버 함수
javascript.static.member.variable=정적 멤버 변수
javascript.instance.member.variable=인스턴스 멤버 변수
javascript.instance.member.function=인스턴스 멤버 함수
javascript.create.class.intention.name=클래스 ''{0}'' 생성
javascript.create.interface.intention.name=인터페이스 ''{0}'' 생성
choose.class.to.import.title=가져올 클래스
javascript.fix.remove.override.modifier=재정의 제어자 제거
javascript.fix.remove.virtual.modifier=가상 제어자 제거
javascript.validation.message.attribute.was.specified.multiple.times=제어자 {0}이(가) 여러 번 지정되었습니다
javascript.fix.remove.dynamic.modifier=동적 제어자 제거
javascript.validation.message.function.override.for.object.method=Object에서 상속된 메서드는 재정의할 필요가 없습니다
javascript.validation.message.function.override.without.parent.method=메서드가 상위 클래스의 메서드를 재정의하지 않습니다
javascript.parser.message.expected.gt=필요 >
javascript.parser.message.expected.lbracket=필요 [
javascript.parser.message.expected.readonly=''readonly'' 필요
javascript.module.name=모듈 이름
javascript.exported.variable=내보낸 변수
javascript.exported.function=내보낸 함수
javascript.exported.class=내보낸 클래스
javascript.fix.create.function.component.jsx.name=함수 구성 요소 ''{0}'' 생성
javascript.fix.create.function.component.jsx.family=함수 구성 요소 생성
javascript.fix.create.class.component.jsx.name=클래스 구성 요소 ''{0}'' 생성
javascript.fix.create.class.component.jsx.family=클래스 구성 요소 생성
typescript.module.name=모듈 이름
typescript.type.alias.name=타입 별칭
typescript.type.guard.name=변수 타입이 타입 가드에 의해 좁혀졌습니다
typescript.type.guard.name.disable=타입 가드로 좁혀진 타입 컬러링 비활성화
typescript.primitive.types.name=기본 타입
typescript.type.parameter=타입 매개변수
typescript.remove.type.declaration=타입 선언 제거

generate.constructor.overloads.and.fields.chooser.title=사용할 오버로드 및 초기화할 필드 선택
generate.to.string.chooser.title=toString 함수에서 사용할 필드 선택
members.to.implement.chooser.title=구현할 멤버 선택
members.to.override.chooser.title=재정의할 멤버 선택
no.candidates=후보가 없습니다
no.methods.to.implement=구현할 메서드를 찾을 수 없습니다
no.members.to.implement=구현할 멤버를 찾을 수 없습니다
implement.members.abstract=멤버를 추상으로 구현
no.methods.to.override=재정의할 메서드를 찾을 수 없습니다
no.members.to.override=재정의할 멤버를 찾을 수 없습니다
no.variables.for.getter=getter가 없는 필드를 찾을 수 없습니다
no.variables.for.setter=setter가 없는 필드를 찾을 수 없습니다
no.variables.for.getter.setter=getter와 setter가 없는 필드를 찾을 수 없습니다
javascript.validation.unused.import=사용하지 않는 import
javascript.validation.fqn.to.replace.with.import=정규화된 이름을 import 문으로 바꿀수 있습니다
javascript.fix.optimize.imports=import 문 최적화
javascript.parser.message.expected.doc.tag.value=태그 값 필요
javascript.parser.message.expected.doc.tag.name=문서 태그 이름 필요
javascript.invalid.number.of.parameters=유효하지 않은 인수 수, {0} 필요
javascript.expression.type.implicitly.coerced.to.unrelated.type=표현식 타입 {1}은(는) 관련없는 타입 {0}으로 암시적으로 강제 변환됩니다
javascript.argument.type.mismatch=인수 타입 {1}을(를) 매개변수 타입 {0}에 할당할 수 없습니다
javascript.initializer.type.mismatch=이니셜라이저 타입 {1}을(를) 변수 타입 {0}에 할당할 수 없습니다
javascript.incorrect.variable.type.mismatch=변수 타입 {1}을(를) 타입 {0}에 할당할 수 없습니다
javascript.term.does.not.evaluate.to.function=메서드 표현식이 함수 타입이 아닙니다
javascript.term.does.not.evaluate.to.function.nullable=메서드 표현식이 null이거나 undefined일 수 있습니다
javascript.term.does.not.evaluate.to.function2=프로퍼티는 함수로 호출할 수 없습니다
javascript.term.does.not.evaluate.to.function.line.break=표현식은 호출할 수 없습니다. 호출이 아닌 경우 누락된 세미콜론을 확인하세요.
javascript.term.does.not.evaluate.to.function2.fix=인수 목록 제거
javascript.term.nullable.indexer.qualifier=색인 생성된 표현식이 null이거나 undefined일 수 있습니다
javascript.unused.import.remove=사용하지 않는 ''import'' 제거
javascript.unused.import.remove.specifier=사용하지 않는 요소 제거
javascript.assigned.expression.type.mismatch=할당된 표현식 타입 {1}을(를) 타입 {0}에 할당할 수 없습니다
javascript.vector.literal.element.type.mismatch=벡터 리터럴 요소 타입 {1}을(를) 타입 {0}에 할당할 수 없습니다
javascript.type.is.not.assignable.to.type=타입 {1}을(를) 타입 {0}에 할당할 수 없습니다
javascript.no.call.signatures=할당된 타입이 호출 시그니처를 포함하지 않습니다
javascript.known.props.only=객체 리터럴은 알려진 프로퍼티만 지정할 수 있지만 추가 프로퍼티는 다음과 같습니다. {0}
javascript.returned.expression.type.mismatch=반환된 표현식 타입 {1}을(를) 타입 {0}에 할당할 수 없습니다
javascript.insert.cast.fix=형 변환 삽입
javascript.insert.primitive.wrapper.fix.family.name=기본 타입으로 래핑
javascript.insert.generic.wrapper.fix.family.name=제네릭 타입으로 래핑
javascript.insert.wrapper.fix.text=''{0}''(으)로 래핑
typescript.insert.cast.fix=타입 어설션 삽입
es6.insert.await.fix=await 삽입
es6.change.to.default.fix=''{0}''의 디폴트 가져오기 사용
es6.change.to.named.import.fix=''{0}''의 명명된 가져오기 사용
typescript.insert.type.guard.fix.family=타입 가드 삽입
typescript.insert.type.guard.surround=''{0}''(으)로 둘러싸기
typescript.insert.type.guard.prefix=접두사 ''{0}'' 사용
typescript.insert.type.guard.postfix=''{0}''(으)로 선택적 쿼리
typescript.insert.type.guard.nc=한정자를 ''{0}''(으)로 바꾸기
typescript.insert.type.guard.nc.self=''{0}''(으)로 바꾸기
error.not.available.in.javascript.code={0}을(를) JavaScript 코드에서 사용할 수 없습니다
cannot.modify.library.code=라이브러리 또는 SDK 코드를 수정할 수 없습니다
javascript.extract.method.title=함수 추출
javascript.validation.message.function.override.incompatible.signature.generic=호환되지 않는 재정의
javascript.validation.message.function.override.incompatible.access.modifier=호환되지 않는 재정의, ''{0}'' 접근 제어자가 있어야 함
javascript.validation.message.function.override.incompatible.signature=호환되지 않는 재정의, 시그니처 ''{0}''이(가) 있어야 함
javascript.validation.message.function.override.incompatible.signature2=호환되지 않는 재정의, 반환 타입 ''{0}''이(가) 있어야 함
javascript.validation.message.function.override.incompatible.signature3=호환되지 않는 재정의, 종류 ''{0}''이(가) 있어야 함
javascript.validation.message.function.method.invalid.overridden.parameter.type=호환되지 않는 재정의, 타입 ''{0}''이(가) 있어야 함
javascript.validation.message.interface.method.invalid.access.modifier=호환되지 않는 구현, ''public'' 접근 제어자가 있어야 함
javascript.validation.message.interface.method.invalid.signature=호환되지 않는 구현, 시그니처 ''{0}''이(가) 있어야 함
javascript.validation.message.interface.method.invalid.signature2=호환되지 않는 구현, 반환 타입 ''{0}''이(가) 있어야 함
javascript.validation.message.interface.method.invalid.signature3=호환되지 않는 구현, get /set ''{0}''이(가) 있어야 함
javascript.validation.message.duplicate.catch.block=캐치 블록 중복 \#loc
javascript.validation.message.duplicate.catch.block.fix=캐치 블록 중복 제거
javascript.validation.message.missing.catch.or.finally=catch 또는 finally 절 누락
javascript.validation.message.return.value.of.type.is.required=타입 {0}의 반환 값이 필요합니다
javascript.validation.message.return.statement.required=void가 아닌 반환 타입에 return 문이 필요합니다
typescript.validation.message.invalid.module.member.modifier=''{0}''은(는) 모듈 멤버에 유효한 제어자가 아닙니다
javascript.validation.message.unresolved.component=해결되지 않은 구성 요소 {0}
javascript.validation.message.super.constructor.call.should.be.in.constructor=수퍼클래스 생성자 호출이 생성자 본문에 있어야 합니다
javascript.fix.remove.constructor=생성자 제거
javascript.metadata=메타데이터
javascript.class=클래스
javascript.interface=인터페이스
javascript.label=라벨
javascript.function.arrow=화살표 함수
javascript.validation.message.unneeded.comma=불필요한 쉼표
javascript.validation.message.remove.unneeded.comma.fix=불필요한 쉼표 제거
javascript.validation.message.constructor.cannot.be.static=생성자는 정적일 수 없습니다
javascript.create.event.handler.intention.name=이벤트 핸들러 ''{0}'' 생성
javascript.validation.message.missed.super.constructor.call=상위 클래스 생성자 호출 누락
javascript.validation.message.this.before.super.call=상위 클래스 생성자 호출 전에는 ''this''가 허용되지 않습니다
javascript.validation.message.baseMethod.before.super.call=''super''는 상위 클래스 생성자 호출 전에 허용되지 않습니다
javascript.validation.message.base.constructor.in.not.derived=기본 생성자 호출은 파생된 생성자에서만 허용 됩니다
typescript.validation.message.base.constructor.must.be.first.statement=클래스에 초기화된 프로퍼티가 포함되어 있거나 매개변수 프로퍼티가 있는 경우 base 생성자 호출이 생성자의 첫 번째 명령문이어야 합니다
javascript.fix.create.constructor.invoke.super=super와 일치하는 생성자 생성
javascript.fix.create.invoke.super=상위 클래스 생성자 호출 삽입
javascript.interface.can.not.be.instantiated.message=인터페이스는 인스턴스화할 수 없습니다
javascript.abstract.class.can.not.be.instantiated.message=추상 클래스는 인스턴스화할 수 없습니다
javascript.validation.message.set.method.should.be.void.or.without.type=setter 정의의 반환 타입은 지정하지 않거나 void여야 합니다
javascript.validation.message.set.method.should.have.one.parameter=setter 정의는 정확히 하나의 매개변수가 필요합니다
javascript.validation.message.get.method.should.have.no.parameter=getter 정의는 매개변수를 가질 수 없습니다
javascript.validation.message.get.method.should.be.valid.type=getter 정의의 반환 타입이 {0} 일 수 없습니다
javascript.validation.message.use.namespace.reference.or.access.modifier=네임스페이스 또는 접근 제어자 사용
javascript.validation.message.one.visibility.modifier.allowed=하나의 가시성 제어자(public, protected, internal, private)만 허용됩니다
javascript.validation.destructuring.without.initializer=구조 분해 선언은 이니셜라이저가 필요합니다
javascript.fix.remove.access.modifier=접근 제어자 제거
javascript.fix.remove.final.modifier=final 제어자 제거
javascript.validation.message.final.modifier.allowed.only.for.methods=final 제어자는 클래스 및 클래스 메서드에만 적용할 수 있습니다
javascript.fix.remove.namespace.reference=네임스페이스 참조 제거
javascript.fix.remove.visibility.modifier=가시성 제어자 제거
javascript.incorrect.array.type.in.for-in=배열 키 타입이 String이어야 합니다
javascript.validation.message.unexpected.type.for.rest.parameter=나머지 매개변수는 타입을 가질 수 없습니다
typescript.validation.message.unexpected.type.for.rest.parameter=Rest 매개변수는 배열 타입이거나 배열 제약 조건이 있는 제네릭이어야 합니다
typescript.validation.message.unexpected.type.for.rest.parameter.fix=배열 타입으로 바꾸기
javascript.fix.remove.type.reference=타입 참조 제거
javascript.validation.message.parameter.is.not.allowed.after.rest.parameter=매개변수는 rest 매개변수 이후 허용되지 않습니다
javascript.validation.message.comma.is.not.allowed.after.rest.element=쉼표는 나머지 요소 이후 허용되지 않습니다
javascript.validation.message.comma.is.not.allowed.after.last.parameter=쉼표는 마지막 매개변수 뒤에 허용되지 않습니다.
javascript.fix.remove.comma=쉼표 제거
javascript.fix.remove.parameter=매개변수 제거
javascript.fix.remove.parameters=매개변수 제거
javascript.fix.remove.initializer=이니셜라이저 제거
javascript.validation.message.parameter.should.be.initialized=매개변수를 초기화해야 합니다
javascript.validation.message.parameter.non.optional.after.optional=필수 매개변수 이후 선택적 매개변수를 사용할 수 없습니다
javascript.validation.message.parameter.rest.optional=나머지 매개변수는 선택 사항일 수 없습니다
javascript.fix.initialize.parameter=매개변수 초기화
javascript.validation.message.rest.parameter.should.not.be.initialized=rest 매개변수를 초기화할 수 없습니다
javascript.validation.message.nested.classes.are.not.allowed=중첩 클래스는 허용되지 않습니다
javascript.validation.message.implements.is.not.allowed=구현 절은 표준 ECMAScript에서 허용되지 않습니다
javascript.validation.message.arguments.with.rest.parameter=''arguments'' 객체는 나머지 매개변수 사용 시 사용할 수 없습니다
js.validate.types.inspection.name=타입 불일치
typescript.validate.optional.parameter.inspection.error=매개변수로 물음표와 이니셜라이저를 사용할 수 없습니다
typescript.validate.optional.parameter.inspection.fix.question=물음표 제거
typescript.validate.generic.types.inspection.name=제네릭 타입 불일치
typescript.redundant.typescript.type.argument.inspection.name=제네릭 타입에 대한 불필요한 타입 인수
typescript.duplicate.typescript.union.inspection.name=공용체 또는 교차 타입 구성 요소 중복
typescript.validate.generic.types.fix.delete=제네릭 인수 제거
typescript.validate.generic.types.fix.add=제네릭 인수 추가
typescript.validate.generic.types.inspection.error.argument.number=제네릭 타입 ''{0}''이(가) ''{1}'' 타입 인수를 필요로 합니다
typescript.validate.generic.types.inspection.error.argument.number.between=제네릭 타입 ''{0}''이 {1}에서 {2} 사이 타입의 인수를 필요로 합니다
typescript.validate.generic.types.inspection.error.not.empty.argument=타입 인수 목록이 공백일 수 없습니다
typescript.validate.generic.types.inspection.error.not.empty.parameter=타입 매개변수가 공백일 수 없습니다
typescript.validate.types.any.inspection.name=''any'' 타입 컨텍스트에서 타입 불일치
typescript.validate.template.literal.types=템플릿 타입 {1}을(를) 제약 타입 {0}에 대입할 수 없습니다
js.incompatible.types.comparison.inspection.name=호환되지 않는 타입이 있는 표현식 비교
js.incompatible.types.comparison.message=타입 ''{1}'' 및 ''{2}''가 겹치지 않으므로 조건은 항상 {0, choice, 0\#false|1\#true}입니다
javascript.validate.imports.name=import 문 유효성 검사
es6.validate.import.error=심볼 ''{0}''을(를) 해결할 수 없습니다.
es6.prefer.short.import.name=가져오기를 단축할 수 있습니다
typescript.reference.to.umd.global=UMD 전역으로 참조
typescript.field.can.be.made.readonly=필드가 생성자에만 할당되어 있으며 readonly로 설정될 수 있습니다
javascript.suspicious.type.guard.desc=소리 없는 타입 가드 검사
javascript.object.null.or.undefined.desc=객체가 ''null'' 또는 ''undefined''입니다
javascript.suspicious.typeof.guard=유효하지 않은 ''typeof'' 검사\: ''{0}''이(가) 타입 ''{1}''을(를) 가질 수 없습니다
javascript.redundant.typeof.guard=불필요한 ''typeof'' 검사\: ''{0}''이(가) 항상 타입 ''{1}''을(를) 가집니다
javascript.falsy.typeof.guard=''typeof'' 검사가 항상 false입니다. ''{0}''이(가) 항상 타입 ''{1}''을(를) 가집니다 
typescript.suspicious.instanceof.guard=유효하지 않은 ''instanceof'' 검사\: ''{0}''이(가) ''{1}''과 관련 없는 타입을 가집니다
typescript.redundant.instanceof.guard=불필요한 ''instanceof'' 검사\: ''{0}''이(가) 타입 ''{1}'' 또는 ''{1}''의 하위 타입을 가집니다
typescript.redundant.instanceof.inheritor.guard=불필요한 ''instanceof'' 검사\: ''{0}''이(가) 타입 ''{1}'' 또는 ''{1}''의 상속자를 가집니다
javascript.object.is.null={0}이(가) null입니다
javascript.object.is.possibly.null={0}이(가) null일 수 있습니다
javascript.object.is.undefined={0}이(가) undefined입니다
javascript.object.is.possibly.undefined={0}이(가) undefined일 수 있습니다
javascript.object.is.null.or.undefined={0}이(가) null 또는 undefined입니다
javascript.object.is.possibly.null.or.undefined={0}이(가) null 또는 undefined일 수 있습니다
typescript.smart.cast=변수 타입이 타입 가드로 좁혀졌습니다
typescript.smart.cast.hyperlink=글꼴 및 배경 설정
typescript.missing.augmentation.import=증강 가져오기 누락
typescript.explicit.member.type.inspection.name=명시적 멤버 타입
typescript.config.inspection=tsconfig.json 유효성 검사
typescript.config.inspection.libs=필수 TypeScript 라이브러리가 tsconfig.json에 포함되어 있지 않습니다
typescript.config.inspection.missing.option=tsconfig.json의 옵션 누락
typescript.config.inspection.libs.fix=tsconfig.json의 라이브러리 ''{0}'' 활성화 
typescript.config.inspection.config.options.fix=''{0}''을(를) tsconfig.json에 추가
typescript.config.inspection.fix.pattern=''{0}'' 프로퍼티 추가
typescript.config.inspection.path.mapping.info=경로 매핑은 baseUrl 프로퍼티가 필요합니다
typescript.config.inspection.checkjs.info=프로퍼티 checkJs가 allowJs 프로퍼티를 필요로 합니다
typescript.redundant.declaration=타입 선언이 추론된 타입과 일치하며 제거될 수 있습니다
unnecessary.parentheses.display.name=불필요한 소괄호
unnecessary.parentheses.problem.descriptor=<code>\#ref</code> 주변의 소괄호가 불필요합니다 \#loc
remove.unnecessary.parentheses.fix.text=불필요한 소괄호 제거
typescript.specify.type.explicitly=타입을 명시적으로 지정합니다.
typescript.specify.type.explicitly.from.hint=명시적 타입 어노테이션 추가
typescript.specify.all.param.types.explicitly=모든 매개변수 타입을 명시적으로 지정하세요
typescript.specify.all.param.types.explicitly.from.hint=모든 매개변수에 명시적 타입 어노테이션 추가
typescript.make.field.readonly=필드를 readonly로 설정
es6.replace.import.action.name={0}(으)로 바꾸기
es6.replace.import.family.name=더 짧은 경로로 바꾸기
js.validate.signature.inspection.name=시그니처 불일치
find.usages.of.base.interface={1}의 메서드 {0}이(가) \n{2}의 메서드를 구현합니다.\n기본 메서드를 {3}하시겠어요?
find.usages.of.base.class={1}의 메서드 {0}이(가) \n{2}의 메서드를 재정의합니다.\n기본 메서드를 {3}하시겠어요?
javascript.fix.visibility.family=가시성 문제 해결
javascript.fix.set.element.visibility={0}을(를) {1}(으)로 만들기
javascript.fix.add.sharp=참조 액세스에 \# 추가
javascript.fix.remove.sharp=참조 액세스에서 \# 제거
javascript.fix.set.method.return.type=''{0}''이(가) ''{1}''을(를) 반환하도록 만듭니다.
javascript.fix.generate.argument.stubs=인수 스텁 생성
javascript.deprecated.symbol.replace.fix=곧 사용할 수 없게 될 코드를 {0}(으)로 바꾸기
javascript.deprecated.symbol.replace.fix.family=곧 사용할 수 없게 될 코드를 권장 대체 코드로 대체
javascript.label.visibility.public=공개(&B)
javascript.label.visibility.package_local=Internal(&I)
javascript.label.visibility.private=비공개(&V)
javascript.label.visibility.protected=보호됨(&O)
move.members.refactoring.name=멤버 이동
move.members.dialog.title=멤버 이동
class.0.cannot.be.created=이름이 같은 정규화된 요소가 존재하므로 대상 클래스 {0}을(를) 생성할 수 없습니다
# Used in JSFormatUtil.formatVisibility
javascript.visibility.public=public
javascript.visibility.internal=internal
javascript.visibility.private=private
javascript.visibility.protected=protected
entity.in.parent.description={1}의 {0}
package.description=패키지 {0}
0.with.1.visibility.in.the.target.class.is.not.accessible.from.2=대상 클래스에서 {1} 표시가 있는 {0}은(는) {2}에서 액세스할 수 없습니다
0.with.1.visibility.is.not.accessible.from.2={1} 표시가 있는 {0}은(는) {2}에서 액세스할 수 없습니다

# Refactoring
javascript.refactoring.variable.used.as.lvalue=인라인화할 변수가 할당의 왼쪽에 사용됩니다
javascript.refactoring.variable.value.is.changed.when.accessed.from.closure=변숫값이 클로저로부터 액세스될 때 변경됩니다
javascript.refactoring.inline.variable.title=변수 인라인화
javascript.refactoring.inline.function.title=인라인 함수
javascript.refactoring.cannot.find.usages.of.definition.to.inline=인라인화할 정의의 사용 위치를 찾을 수 없습니다
javascript.refactoring.searching.usages=사용 찾기
javascript.refactoring.cannot.inline.not.initialized.variable=초기화되지 않은 변수를 인라인화할 수 없습니다
javascript.refactoring.cannot.inline.destructuring.variable.with.default=디폴트 값으로 구조 분해 변수를 인라인화할 수 없습니다
javascript.refactoring.cannot.inline.destructuring.rest.variable=구조 분해 나머지 변수를 인라인화할 수 없습니다
javascript.inline.element.is.not.used={0}이(가) 한번도 사용되지 않습니다
javascript.refactoring.inline.dialog.title={0} 인라인화
javascript.refactoring.inline.all.message=모든 참조 인라인화 및 {0} ({1}) 제거(&A)
javascript.refactoring.inline.this.only=이 참조만 인라인화 및 {0} 유지(&K)
javascript.refactoring.cannot.inline.function.defined.in.library=외부 라이브러리에 정의된 함수를 인라인화할 수 없습니다
javascript.refactoring.cannot.inline.function.referencing.arguments=인수를 참조하는 함수를 인라인화할 수 없습니다
javascript.refactoring.cannot.inline.interface.method=인터페이스 메서드를 인라인화할 수 없습니다
javascript.refactoring.cannot.inline.function.referencing.rest.parameter=나머지 매개변수를 참조하는 함수를 인라인화할 수 없습니다
javascript.refactoring.cannot.inline.overrided.or.overridden.method=계층 구조에 참여하는 메서드를 인라인화할 수 없습니다
javascript.refactoring.cannot.inline.recursive.function=재귀 함수를 인라인화할 수 없습니다
javascript.refactoring.cannot.inline.function.with.multiple.returns=여러 개의 종료점이 있는 인라인 함수를 인라인화할 수 없습니다
javascript.refactoring.cannot.inline.complex.expression.evaluation=복잡한 표현식 평가를 인라인화할 수 없습니다
javascript.refactoring.cannot.inline.constructor=인라인 생성자를 인라인화할 수 없습니다
javascript.refactoring.cannot.inline.jsx.usage=JSX 태그 사용을 인라인화할 수 없습니다
javascript.refactoring.cannot.inline.ambient.function=구현 없이 선언을 인라인화할 수 없습니다
javascript.refactoring.function.to.es6.class.command=함수 {0}을(를) 클래스로 변환
js.convert.to.es6.class=클래스로 변환
js.convert.to.es6.class.family.name=함수 및 해당 멤버 선언을 클래스로 변환
js.move.type.to.file.family=일치하는 이름이 있는 파일로 이동
js.create.derived.type.family=파생 클래스 생성/인터페이스 구현
js.create.derived.type.class=파생 클래스 생성
js.create.switch.cases=누락된 ''switch'' 분기 생성
js.create.switch.cases.fix=누락된 분기 생성\: {0}
js.edit.object.literal=객체 리터럴 프로퍼티 값 편집
js.create.derived.type.interface=인터페이스 구현
js.create.derived.type.abstract.class=추상 클래스 구현
js.rename.file.to.match.type.name.family=타입 이름과 일치하도록 파일 이름 변경
js.rename.file.to.match.type.name={1} 이름과 일치하도록 파일 이름을 {0}(으)로 변경
js.move.type.to.file.text={0}을(를) 파일 {1}(으)로 이동
javascript.refactoring.function.to.es6.class.defineProperty.warning.text=경고\: "Object.defineProperty", "Object.defineProperties" 또는 "Object.create"를 ES6 구문으로 변환하면 열거성 및 설성 가능성에 영향을 줄 수 있습니다
rename.destructuring.property.title=구조 분해 프로퍼티 이름 변경
rename.destructuring.property.description=구조 분해 프로퍼티가 여러 멤버를 참조합니다. 관련 프로퍼티의 이름을 변경해야 하며, 그렇지 않으면 코드가 일치하지 않을 수 있습니다.
rename.type.members.title=타입 멤버 이름 변경
rename.type.members.union.intersection.mapped.description=공용체, 교차 또는 매핑된 타입 사용 위치가 탐지되었습니다. 관련 프로퍼티의 이름을 변경해야 하며, 그렇지 않으면 코드가 일치하지 않을 수 있습니다.
rename.type.members.destructuring.description=구조 분해 프로퍼티 사용 위치가 탐지되었습니다. 관련 프로퍼티의 이름을 변경해야 하며, 그렇지 않으면 코드가 일치하지 않을 수 있습니다.
make.private=private으로 만들기
choose.destination.scope=대상 범위 선택
list.item.function.to.be.converted.to.class=클래스로 변환할 함수
list.item.declarations.function.members.to.be.converted.to.class.members=클래스 멤버로 변환할 함수 멤버 선언
tab.title.convert.to.class=클래스로 변환
tab.title.refactoring.preview=리팩터링 미리보기
list.item.function.converted.to.class=클래스로 변환된 함수
list.item.declarations.that.were.not.converted=변환되지 않은 선언
tab.title.refactoring.result=리팩터링 결과
extract.method.declare.static=static 선언(&S)
extract.function.declare.functional.expression=함수 표현식 선언(&F)
extract.function.return.type=반환 타입(&T)\:
extract.function.parameters=매개변수
extract.function.signature.preview=시그니처 미리보기
extract.function.function=함수
extract.function.name=이름(&N)\:
extract.constant.type=타입(&T)\:
introduce.constant.target.class=대상 클래스(&A)\:
introduce.field.type=타입(&T)\:
introduce.field.initialize.in=다음에서 초기화
introduce.field.declaration=필드 선언(&D)
introduce.field.current.method=현재 메서드(&M)
introduce.field.class.constructor=클래스 생성자(&C)
introduce.parameter.type=타입(&T)\:
introduce.parameter.optional=선택적 매개변수(&O)
introduce.variable.declaration=변수 선언
introduce.variable.const=const(&C)
introduce.variable.let=let(&L)
introduce.variable.var=var(&V)
introduce.variable.var.of.type=타입의 변수(&T)\:
introduce.variable.make.constant=상수 생성(&C)
custom.template.variables=사용자 지정 템플릿 변수(&C)\:

# Destructuring
javascript.find.usages.destructuring.target.dialog=축약 구조 분해 변수가 {0}(으)로 초기화되었습니다.\n어떤 사용 위치를 찾으시겠어요?
javascript.destructuring.initializer=이니셜라이저 {0}
javascript.destructuring.variable.only=구조 분해 변수만
javascript.rename.destructuring.target.dialog.title=축약 구조 분해 변수가 {0}(으)로 초기화되었습니다
javascript.rename.choose.target.message=무엇의 이름을 변경하시겠어요?
javascript.rename.shorthand.target.dialog.title=축약 프로퍼티가 {0}(으)로 초기화되었습니다
javascript.rename.shorthand.property.description=프로퍼티
javascript.rename.file.with.related.title=파일 이름 변경
javascript.rename.containing.file.message=파일 및 해당 사용 위치의 이름을 {0}(으)로 변경하시겠어요?
javascript.rename.related.declaration.message={0} 및 해당 사용 위치의 이름을 {1}(으)로 변경하시겠어요?
dialog.message.some.usages.cannot.be.updated.properly=일부 사용 위치를 제대로 업데이트할 수 없습니다.\nimport 문 및 export 문 내 사용 위치, 문자열 사용 위치 또는 동적 참조는 구조 분해로 바꿀 수 없습니다.
dialog.message.cannot.propagate.when.having.usages.declarations.in.different.files=다른 파일에 사용 위치 및 선언이 있는 경우 전달할 수 없습니다
dialog.message.write.usages.cannot.be.updated.with.destructuring=쓰기 사용 위치는 구조 분해로 업데이트할 수 없습니다
dialog.message.expression.indexed.by.non.numeric.value=표현식이 숫자가 아닌 값으로 색인 생성되어 있습니다
dialog.message.incomplete.destructuring.pattern.encountered.in.code=코드에 불완전한 구조 분해 패턴이 있습니다
dialog.message.unsupported.destructuring.container=지원되지 않는 구조 분해 컨테이너\: {0}
dialog.message.some.usages.cannot.be.updated.properly.wrong.access=일부 사용 위치를 제대로 업데이트할 수 없습니다.\n이름으로 프로퍼티에 액세스하지 않거나 색인으로 요소에 액세스하지 않는 사용 위치는 바꿀 수 없습니다.
dialog.message.cannot.transform.object.array.destructuring.patterns.for.same.element=동일한 요소에 대한 객체 및 배열 구조 분해 패턴을 변환할 수 없습니다
dialog.message.transforming.multiple.nested.patterns.not.supported=여러 중첩 패턴의 변환은 배열 구조 분해에서 지원되지 않습니다

javascript.refactoring.asdoc.for.abstracts=추상에 대한 ASDoc
0.is.not.allowed.in.interface={0}은(는) 인터페이스에서 허용되지 않습니다
javascript.fix.remove.static.modifier=static 제어자 제거
javascript.validation.message.override.can.be.applied.to.method=재정의는 함수 선언에만 적용할 수 있습니다
javascript.validation.message.dynamic.can.be.applied.to.class=동적 속성은 클래스 선언에만 적용할 수 있습니다
javascript.illegal.variable.type.void=올바르지 않은 변수 타입\: ''void''
javascript.cannot.return.expression.from.function.with.void.result.type=결과 타입이 void인 함수에서 값을 반환할 수 없습니다
javascript.cannot.return.expression.from.function.with.void.result.type.fix=반환 값 제거
javascript.validation.message.function.override.for.interface={0}의 메서드와 호환되지 않는 재정의
javascript.validation.message.incompatible.override={0}의 멤버와 호환되지 않는 재정의
class.does.not.have.inheritors.in.current.project=현재 프로젝트에 {0}의 상속자가 없습니다
javascript.kind.unknown=알 수 없는 요소
js.unnecessary.semicolon.inspection.name=불필요한 세미콜론
js.unnecessary.semicolon.problem=불필요한 세미콜론 \#loc
js.unnecessary.semicolon.fix.name=불필요한 세미콜론 제거
javascript.refactoring.extract.function.title=함수 추출
javascript.refactoring.extract.function.bad.selection=선택한 블록이 명령문 또는 표현식의 집합을 나타내야 합니다
javascript.refactoring.extract.function.multiple.exit.points=선택한 조각에 종료점이 여러 개 있습니다
javascript.refactoring.extract.function.yield.and.return=선택한 조각이 yield 표현식과 return 문을 동시에 포함합니다
javascript.refactoring.extract.function.no.loop.for.continue=코드 조각 내부의 continue 문에 해당하는 루프가 없습니다
javascript.refactoring.extract.function.no.loop.for.break=코드 조각 내부의 break 문에 해당하는 루프가 없습니다
javascript.refactoring.extract.function.no.switch.for.break=코드 조각 내부의 break 문에 해당하는 ''switch''가 없습니다
javascript.refactoring.extract.function.function.used.before.declaring=선택 영역이 선언 전에 사용되는 함수를 포함합니다
javascript.refactoring.extract.function.already.exists.in.this.scope={0}이(가) 이 범위에 이미 있습니다
javascript.validation.message.constructor.cannot.have.custom.visibility=생성자는 public이거나 가시성이 지정되어 있지 않아야 합니다
javascript.validation.message.can.not.override.final.method={0} 에서 최종 메서드를 재정의할 수 없습니다
top.level.package=최상위 패키지
javascript.parser.message.expected.dot=. 필요
js.comparison.with.nan.inspection.name=NaN과 비교
js.comparison.with.nan.inspection.problem=NaN과 동치 비교는 항상 false으로 평가됩니다
js.comparison.with.nan.inspection.problem2=NaN과의 비동치 비교는 항상 true로 평가됩니다
js.comparison.with.nan.inspection.quickfix={0}isNaN(...)으로 바꾸기
js.constructor.returns.primitive.inspection.name=생성자가 기본 값을 반환합니다
js.constructor.returns.primitive.inspection.problem=생성자에서 반환된 기본 값이 ''new''로 호출 될 때 손실됩니다
js.constructor.returns.primitive.inspection.quickfix=반환 형식을 {0}(으)로 명시적으로 설정
js.comment.matches.signature.inspection.name=JSDoc 주석이 함수 시그니처와 일치합니다
js.comment.matches.signature.inspection.problem1=매개변수 {0}이(가) JSDoc에 설명되어 있지 않습니다
js.comment.matches.signature.inspection.problem2=JSDoc에 설명된 매개변수 {0}이(가) 함수 시그니처에 나타나지 않습니다
js.comment.matches.signature.inspection.quickfix=JSDoc 주석 업데이트

livetemplate.description.fori=반복 루프 생성
livetemplate.description.iter=반복 (for..of)
livetemplate.description.itera=반복 (for await..of)
livetemplate.description.itin=반복 (for..in)
livetemplate.description.itar=배열의 요소를 반복합니다.
livetemplate.description.ritar=배열의 요소를 역순서로 반복합니다.
livetemplate.description.us=''use strict'' 문 삽입
livetemplate.description.ref=참조 경로 주석 삽입
livetemplate.description.defi=define() 식 삽입
livetemplate.description.flow=@flow 어노테이션 삽입
livetemplate.description.importfrom=import 문 - ''a''에서 {b} 가져오기
livetemplate.description.importns=import 문 - ''a''에서 b로 * 가져오기
livetemplate.description.importdefault=import 문 - ''a''에서 b 가져오기
livetemplate.description.exportall=export 문 - ''a''에서 * 내보내기
livetemplate.description.exportfrom=export 문 - ''a''에서 {b} 내보내기 
livetemplate.description.exportitems=export 문 - {b} 내보내기
livetemplate.description.moduleexports=export 문 - module.exports \= a

livetemplate.description.console.log=console.log()
livetemplate.description.console.warn=console.warn()
livetemplate.description.console.error=console.error()
livetemplate.description.console.info=console.info()
livetemplate.description.console.trace=console.trace()
livetemplate.description.console.assert=console.assert()

postfix.template.provider.name=JavaScript 및 TypeScript
postfix.template.condition.non.void.name=비 Void
postfix.template.condition.array.name=배열

macro.js.component.type.of=jsComponentTypeOf(Array)
macro.js.suggest.default.variable.kind=jsSuggestDefaultVariableKind(Boolean)

# Line markers
linemarker.implements.invalid=<올바르지 않음>
linemarker.implements.text={1}에서 {0} 구현
linemarker.overrides.text={1}에서 {0} 재정의
linemarker.implements.several=여러 인터페이스 메서드 구현
linemarker.overridden=재정의된
linemarker.implemented=구현된
linemarker.overriding=재정의
linemarker.implementing=구현
linemarker.javascript.typescript=JavaScript/TypeScript 줄 마커

js.validate.jsdoc.inspection.name=JSDoc의 구문 오류 및 해결되지 않은 참조
javascript.expected.class.or.descendant=클래스 {0} 또는 하위 항목 필요
javascript.qualified.class.name.expected=정규화된 클래스 이름 필요
javascript.validation.message.unknown.metadata.annotation.used=알 수 없는 메타데이터 속성 사용
javascript.validation.message.set.method.type.is.different.from.getter=Set 접근자 메서드에 get 접근자 타입과 호환 되지 않는 타입이 있습니다, ''{0}''이(가) 필요합니다
javascript.validation.message.get.method.type.is.different.from.setter=get 접근자 메서드에는 set 접근자 타입과 호환 되지 않는 타입이 있습니다, ''{0}''이(가) 필요합니다
typescript.validation.message.getter.and.setter.must.have.same.access.type=getter와 setter는 엑세스 타입이 동일해야 합니다
actionscript.validation.message.set.method.access.type.is.different.from.getter=플래시 컴파일러 버그 174646\: set 접근자 메서드 액세스 타입이 get 접근자 액세스 타입과 다릅니다, ''{0}''이(가) 필요합니다
actionscript.validation.message.get.method.access.type.is.different.from.setter=플래시 컴파일러 버그 174646\: Get 접근자 메서드 액세스 타입이 set 접근자 액세스 타입과 다릅니다, ''{0}''이(가) 필요합니다
javascript.validation.message.static.method.cannot.be.final=Static 메서드는 final일 수 없습니다
javascript.assign.parameter.to.field.intention.name=매개변수 ''{0}''을(를) 필드에 할당
javascript.fix.create.parameter=매개변수 ''{0}'' 생성
javascript.introduce.parameter.introduced.variable.value=값(&V)\:
0.is.not.a.legal.name=''{0}''은(는) 올바른 클래스 이름이 아닙니다
item.already.exists={0} {1}이(가) 이미 존재합니다
directory.already.contains.file=디렉터리 ''{0}''이(가) 파일 ''{1}''을(를) 이미 포함합니다
extract.subclass.command.name={1}에서 상위 클래스 {0} 추출
extract.interface.command.name=인터페이스 추출
extract.type.alias.command.name=타입 별칭 추출
new.actionscript.class.dialog.title=새 ActionScript 클래스
new.actionscript.interface.dialog.title=새 ActionScript 인터페이스
class.template.title=클래스
class.with.supers.template.title=상위 클래스가 있는 클래스
interface.template.title=인터페이스
extract.0.turn.refs={0}을(를) 추출하여 가능한 곳에 사용(&T)
superclass.cannot.be.extracted.from.mxml.component=상위 클래스를 MXML 구성 요소에서 추출할 수 없습니다.
superclass.cannot.be.extracted.from.type.alias=상위 클래스를 타입 별칭에서 추출할 수 없습니다
superclass.cannot.be.extracted.from.enum=상위 클래스는 열거형에서 추출할 수 없습니다.
interface.cannot.be.extracted.from.type.alias=인터페이스를 타입 별칭에서 추출할 수 없습니다
interface.cannot.be.extracted.from.enum=인터페이스를 열거형에서 추출할 수 없습니다
javascript.fix.message.change.parameters.to.expected=매개변수를 필요 매개변수로 변경
javascript.fix.message.change.return.type.to.expected=반환 타입을 필요 타입으로 변경
js.last.comma.in.array.literal.inspection.name=배열 문자열의 불필요한 마지막 쉼표
js.last.comma.in.object.literal.inspection.name=객체 문자열의 불필요한 마지막 쉼표
error.wrong.caret.position.method.name=캐럿이 리팩터링할 메서드 이름에 있어야 합니다.
changeSignature.vararg.not.last=나머지 매개변수는 메서드 시그니처의 마지막 매개변수여야 합니다
parameter.type.is.not.specified=매개변수 ''{0}''의 타입이 지정되지 않았습니다.\n계속하시겠어요?
return.type.is.not.resolved=반환 타입 ''{0}''이(가) 해결되지 않았습니다.\n계속하시겠어요?
change.signature.column.name.initializer=이니셜라이저
change.signature.column.name.default.parameter=디폴트 매개변수
change.signature.column.name.call.value=호출 값
change.signature.parameter.table.empty.message=''+'' 버튼으로 새 매개변수 추가
required.parameters.are.not.permitted.after.optional.parameters=필수 매개변수가 선택적 매개변수 이후 허용되지 않습니다
javascript.fix.remove.setter.parameter.initializer=매개변수 디폴트 값 제거
javascript.validation.message.setter.parameter.cannot.have.initializer=setter 정의에 선택적 매개변수를 사용할 수 없습니다
javascript.changeSignature.no.call.value=새 필수 매개변수 ''{0}''이(가) 추가되었습니다.\n이 메서드의 모든 기존 호출에 사용할 디폴트 값을 지정하세요.
es6.changeSignature.no.call.value=새 매개변수 ''{0}''이(가) 추가 되었습니다.\n이 메서드의 모든 기존 호출에 사용할 디폴트 값 또는 값을 지정하세요.
javascript.changeSignature.call.value.not.allowed=디폴트 값이 이전 매개변수에 대해 지정되지 않았으므로 매개변수 ''{0}''(으)로 허용되지 않습니다.
es6.changeSignature.call.value.not.allowed=호출의 값이 이전 매개변수로 지정되지 않았기 때문에 매개변수 ''{0}''(으)로 허용되지 않습니다.
change.signature.usage.view.declarations.header=리팩터링할 메서드
{0}.visibility.will.break.methods.hierarchy={1} 가시성을 가진 {0}이(가) 계층 구조에 참여할 수 없습니다
generate.delegate.method.conflict.message=고유한 프로퍼티를 통해 동일한 이름의 멤버에 대한 위임자를 생성할 수 없습니다
generate.delegate.method.conflict.message.title=위임자를 생성할 수 없습니다
invalid.return.type.expression=반환 타입 ''{0}'' 이 유효하지 않습니다
invalid.parameter.type.expression=매개변수 타입 ''{0}''이 유효하지 않습니다
type.is.not.resolved=타입 ''{0}''이 해결되지 않습니다\n계속하시겠어요?
invalid.field.type.expression=유효하지 않은 필드 타입\: ''{0}''
choose.field.type=필드 타입 선택
new.field.action.text=필드
new.field.action.description=클래스에 새 필드 생성
create.field.dialog.title=필드 생성
field.initializer.is.not.specified=필드 초기화가 지정되지 않았습니다
new.method.action.text=메서드
new.method.action.description=클래스에 새 메서드 생성
create.method.dialog.title=메서드 생성
create.button.text=생성(&C)
class.already.contains.method.warning=클래스 ''{0}''에 메서드 ''{2}()''이(가) 이미 {1, choice,1\#포함|2\#상속} 되어 있습니다.\n계속 하시겠어요?
class.already.contains.field.warning=클래스 ''{0}''이(가) 이미 필드 ''{1}''을(를) 이미 포함합니다.\n계속하시겠어요?
declare.static=static 선언(&S)
new.constructor.action.text=생성자
new.constructor.action.description=클래스 생성자 생성
create.constructor.dialog.title=생성자 생성
change.method.signature.fix.text={0} 시그니처 변경
change.method.signature.and.update.delegating.call.fix.text={0} 시그니처를 {1} 호출과 일치하도록 변경 및 호출 업데이트
change.method.signature.and.update.delegating.call.noname.fix.text=시그니처를 {0} 호출과 일치하도록 변경 및 호출 업데이트
change.method.signature.delegating.default.text=위임
change.method.signature.fix.family.name=메서드 시그니처 변경
change.method.signature.and.update.delegating.call.fix.family.name=메서드 시그니처 변경 및 위임 호출 업데이트

# Settings
settings.javascript.root.configurable.name=JavaScript
settings.typescript.root.configurable.name=TypeScript
settings.javascript.linters.configurable.name=코드 품질 도구
settings.javascript.linters.autodetect.disabled={0} 비활성화(&D)
settings.javascript.linters.autodetect.configure.automatically=자동 {0} 설정(&A)
settings.javascript.linters.autodetect.configure.automatically.help.text={0}이(가) 현재 파일 또는 상위 폴더와 동일한 폴더에 있는 node_modules 디렉터리와 {2} 구성 파일에서 {1} 패키지를 사용할 것입니다.
settings.javascript.linters.autodetect.configure.manually=수동 {0} 설정(&M)
settings.javascript.linters.jshint.configurable.name=JSHint
settings.javascript.only.type.based.completion=타입 기반 코드 완성만(&C)
settings.javascript.opt.chain.completion=nullable 타입에 대한 선택적 체인이 있는 항목 제안(&O)
settings.javascript.overrides.completion=재정의 완료 시 메서드 본문 확장
settings.javascript.var.names.completion=변수 및 매개변수 이름 제안(&V)
settings.javascript.field.names.completion=클래스 필드 이름 제안(&F)
settings.javascript.var.names.completion.desc=이름 완성 기능
settings.javascript.var.names.completion.types=제안된 매개변수 이름에 대한 형식 어노테이션 추가(&T)
settings.javascript.var.names.completion.names.only=타입 없이
settings.javascript.var.names.completion.types.for.params=함수 매개변수에 대한 타입 사용
settings.javascript.var.names.completion.types.for.params.fields=매개변수 및 필드에 대한 타입 사용
settings.javascript.var.names.completion.types.except.fields=필드를 제외한 모든 곳의 타입 사용
settings.javascript.var.names.completion.types.everywhere=모든 곳의 타입 사용
settings.javascript.only.type.based.completion.tooltip=타입 정보에 따라 코드 완성 제안을 적게 표시합니다. 성능이 크게 향상될 수 있습니다.
settings.javascript.lang.templates.configurable.name=템플릿
es6.auto.import.options.completion.add.imports=코드 완성 시 ES6 import 문 추가
es6.auto.import.options.title=TypeScript/JavaScript
typescript.auto.import.options.add.imports=TypeScript import 문 자동으로 추가
typescript.auto.import.options.add.imports.on.the.fly=모호하지 않은 import 문 즉시 사용
typescript.auto.import.options.add.on.code.completion=코드 완성 시
typescript.auto.import.options.show.popup=자동 가져오기 툴팁 포함
js.import.options.merge.import=동일한 모듈의 멤버에 대한 import 문 병합
js.import.options.use.node.resolution=index.js를 사용할 수 있을 때 디렉터리 가져오기 사용(노드 스타일 모듈 해석)
js.import.options.use.explicit.js.extension=모듈 이름에 파일 확장자 사용
ts.import.options.use.explicit.js.extension=모듈 이름에 .js 파일 확장자 사용
js.add.members.to.type.desc=클래스 또는 인터페이스에 멤버 추가
js.add.members.to.type=''{1}''에 멤버 {0} 추가
js.import.options.sort.members=가져온 멤버 정렬
js.import.options.sort.module.name=모듈별 import 문 정렬
es6.import.options.paths=경로 별칭 사용\:
es6.import.options.paths.help=이 옵션은 import 문에 사용되는 경로 스타일을 설정합니다.<br><br>"항상"을 선택하면 IDE는 가져오기를 추가할 때 항상 webpack, system.js 또는 jsconfig.json 설정의 별칭을 사용합니다.<br><br>"지정된 경로 외부의 파일에만"을 성택하면 IDE는 별칭이 정의된 파일 간의 가져오기에 대한 상대 경로를 사용합니다. 다른 모든 파일에서는 경로 매핑이 사용됩니다.<br><br>"사용 안함"을 선택하면 별칭이 사용되지 않습니다.
typescipt.import.options.paths.help=이 옵션은 import 문에 사용되는 경로 스타일을 설정합니다.<br><br>"항상"을 선택하면 IDE는 가져오기를 추가할 때 항상 tsconfig.json의 경로 매핑을 사용합니다.<br><br>"지정된 경로 외부의 파일에만"을 성택하면 IDE는 매핑이 정의된 파일 간의 가져오기에 대한 상대 경로를 사용합니다. 다른 모든 파일에서는 경로 매핑이 사용됩니다.<br><br>"사용 안함"을 선택하면 경로 매핑이 사용되지 않습니다.
typescript.import.options.paths=tsconfig.json의 경로 매핑 사용\:
typescript.import.options.use.config=tsconfig.json에 대한 상대 경로 사용
javascript.import.options.use.resource.root=프로젝트, 리소스 또는 소스 루트에 대한 상대 경로 사용
typescript.import.options.blacklist.title=다음에서 가져오지 마세요\:
js.flow.settings.executable.label=Flow 패키지 또는 실행 파일(&F)\:
js.flow.settings.executable.dialog.title=Flow 패키지 또는 실행 파일 선택
js.flow.services.label=Flow 서버를 다음 용도로 사용\:
js.flow.enable.type.checking=타입 검사
js.flow.enable.other.services=탐색, 코드 완성 및 타입 힌트 표시
js.flow.enable.flow.service.error=잘못된 Flow 경로
js.flow.enable.flow.service.error.empty=Flow 실행 파일 경로가 비어 있습니다
js.flow.enable.flow.service.error.on.checking=Flow 경로 확인 중 오류\: {0}
js.flow.enable.flow.service.error.message={0}. 모든 Flow 서비스를 비활성화하거나 실행 파일에 대한 유효한 경로를 제공하세요
js.flow.settings.auto.save=수정된 파일 자동으로 모두 저장
js.flow.settings.auto.save.warning=Flow는 다른 수정된 파일이 모두 저장된 경우에만 현재 파일을 검사합니다
js.flow.settings.auto.save.warning.lsp=이렇게 하면 Flow에서 항상 최신 오류 상태를 표시합니다.
js.dialect.settings.dialog.title=JavaScript 언어 버전
js.dialect.settings.caption=
js.dialect.settings.tableTitle=언어
js.dialect.settings.override.question=하위 디렉터리 및 파일의 언어 버전을 재정의하시겠어요?
js.dialect.settings.override.title=언어 버전 설정 재정의
js.dialect.settings.empty.text=+ 버튼으로 디렉터리를 추가하고 JavaScript 버전을 선택하세요
js.dialects.customized.label=디렉터리별 사용자 정의
configure.code.completion.settings=코드 완성 설정

# Bower
settings.javascript.bower.configurable.name=Bower
bower.packages.view.dependencies=종속성\:
bower.package=Bower 패키지(&B)\:
bower.json=bower.json(&O)\:
bower.correct.path=경로를 {0}(으)로 수정하세요
bower.package.name=Bower 패키지
bower.dialog.message.specify.package=올바른 bower 패키지를 지정하세요\: "{0}" 파일을 찾을 수 없습니다
bower.required.version.notification.content=bower 패키지를 보려면 bower@1.0.0 이상이 필요합니다
bower.no_description_available.text=사용할 수 있는 설명이 없습니다
dialog.message.command.timed.out=명령어 ''{0}''이(가) 시간 초과되었습니다
dialog.message.command.cancelled=명령어 ''{0}''이(가) 취소되었습니다
dialog.message.command.finished.with.exit.code=명령어 ''{0}''이(가) 종료 코드 {1}(으)로 완료되었습니다. 표준 출력\:\n{2}\n\n표준 오류\:\n{3}

# JS language version management
js.language.version.combo.es5=ECMAScript 5.1
js.language.version.combo.js185=JavaScript 1.8.5
js.language.version.combo.js185.description=Firefox 전용 ECMAScript 구현은 더 이상 사용되지 않습니다. 전환을 고려하세요.
js.language.version.combo.es6=ECMAScript 6+
js.language.version.combo.es6.description=ECMAScript 2015~2020, 일부 제안 및 JSX
js.language.version.combo.nashorn=Nashorn JS
js.language.version.combo.nashorn.description=Java의 JavaScript 구현
js.language.version.combo.flow=Flow
js.language.version.combo.flow.description=Flow 및 ECMAScript 6의 JSX 
js.language.version.label=JavaScript 언어 버전
js.switch.to.jsx.inspection.dismiss=닫기
ts.switch.to.jsx.inspection.name=파일 확장자를 .tsx로 변경
javascript.change.language.level.message=JavaScript 언어 버전을 {0}(으)로 변경
javascript.change.language.level.family=JavaScript 언어 버전 변경

# JS library management
js.library.attach.debug=디버그 버전 첨부(&D)...
js.library.attach.release=릴리스 버전 첨부(&R)...
js.library.unresolved.url.inspection.name=HTTP 링크에 대한 로컬에 저장된 라이브러리가 없습니다
js.library.download.fix=라이브러리 다운로드
js.library.downloading.library=라이브러리 다운로드
js.library.documentation=문서
js.library.configurable.name=라이브러리
js.library.download.stubs.label=TypeScript 커뮤니티 스텁
js.library.successfully.downloaded={0}이(가) 성공적으로 다운로드되었습니다

choose.super.method=<html><body><b>{0}</b>의 상위 메서드 선택 ({1}개 발견)</body></html>
choose.super.function=<html><body><b>{0}</b>의 상위 함수 선택 ({1}개 발견)</body></html>
choose.super.field=<html><body><b>{0}</b>의 상위 필드 선택 ({1}개 발견)</body></html>
choose.super.classifier=<html><body><b>{0}</b>의 상위 인터페이스 선택 ({1}개 발견)</body></html>
choose.subclass=<html><body><b>{0}</b>의 하위 클래스 선택({1}개 발견)</body></html>
choose.implementing.class=<html><body><b>{0}</b>의 구현 선택({1}개 발견)</body></html>
choose.overridden.method=<html><body><b>{0}</b>의 재정의된 메서드 선택 ({1}개 발견)</body></html>
choose.overridden.function=<html><body><b>{0}</b>의 재정의된 함수 선택 ({1}개 발견)</body></html>
choose.implementing.method=<html><body><b>{0}</b>의 구현 선택({1}개 발견)</body></html>
javascript.parser.message.expected.newline.or.semicolon=줄 바꿈 또는 세미콜론 필요
javascript.invalid.delete.target.message=유효하지 않은 삭제 연산자 대상, 필드 참조 필요
javascript.with.statement.is.not.allowed.in.strict.mode.message=with 문은 엄격 모드에서 허용되지 않습니다
javascript.validation.message.redefining.is.not.allowed={0} 재정의가 허용되지 않습니다
javascript.validation.message.referencing.arguments.caller.callee.is.not.allowed=인수에서 ''caller'' 및 ''callee''을 참조할 수 없습니다
javascript.validation.message.referencing.function.arguments.property.is.not.allowed=''arguments'' 함수 프로퍼티를 참조할 수 없습니다
javascript.validation.message.arguments.is.readonly=''arguments''는 읽기 전용입니다
javascript.validation.message.eval.cannot.be.assigned=''eval''은 엄격 모드에서 할당할 수 없습니다
javascript.octal.literals.are.not.allowed.es6.message=접두사 ''0''이 있는 9진수 리터럴은 허용되지 않습니다. 대신 ''0o'' 접두사를 사용하세요.
javascript.octal.literals.are.not.allowed.es5.message=접두사 ''0''이 있는 8진수 리터럴은 사용되지 않으며 사용하지 않는 것을 권장합니다
javascript.octal.sequences.are.not.allowed.message=8진수 이스케이프 시퀀스는 허용되지 않습니다
javascript.invalid.extended.unicode.escape=확장된 유니코드 이스케이프는 0x0 및 0x10FFFF FF 사이의 값만 허용합니다
javascript.octal.literals.are.not.allowed.in.strict.mode=8진수 리터럴은 엄격 모드에서 허용되지 않습니다
javascript.octal.literals.warn.always=ES5- 코드에서 오래된 8진수 리터럴 사용에 대한 경고
javascript.validation.message.only.one.default.is.allowed=하나의 디폴트 절만 switch에서 허용됩니다
javascript.fix.remove.default=default 절 제거
javascript.validation.message.accessor.could.not.be.nested.under.other.function=접근자 메서드는 다른 함수 안에 중첩될 수 없습니다
javascript.validation.message.es5.function.declarations.allowed.on.top.level.or.function=프로그램 또는 함수의 최상위 수준에 있지 않은 함수 명령문은 금지됩니다
class.chooser.not.available.in.dumb.mode=선택기는 색인 업데이트가 진행 중일 때 사용할 수 없습니다.
choose.super.class.title=상위 클래스 선택
choose.base.component.title=상위 클래스 선택
choose.super.interface.title=상위 인터페이스 선택
0.is.not.accessible.from.1={0}을(를) {1}에서 액세스할 수 없습니다
javascript.constructor.call.without.new.message=new 없이 생성자 호출
javascript.qualified.name.is.not.imported.message=정규화된 이름을 가져올 수 없습니다 \#loc
javascript.element.is.not.accessible.message=요소에 액세스할 수 없습니다 \#loc
javascript.protected.member.is.not.accessible.message=protected 멤버는 액세스할 수 없습니다 \#loc
javascript.protected.constructor.is.not.accessible.message=protected 생성자는 액세스할 수 없습니다 \#loc
javascript.private.member.is.not.accessible.message=private 멤버는 액세스할 수 없습니다 \#loc
javascript.export.only.member=요소는 내보내기 전용입니다.
javascript.private.constructor.is.not.accessible.message=private 생성자는 액세스할 수 없습니다 \#loc
javascript.public.member.is.not.accessible.via.sharp.message=공용 멤버를 \#-구문을  통해 참조할 수 없습니다 \#loc
javascript.private.member.is.not.accessible.via.sharp.message=private \#가 아닌 멤버를 \#-구문을 통해 참조할 수 없습니다 \#loc
javascript.private.member.is.not.accessible.without.sharp.message=private 멤버를 \#-구문 없이 참조할 수 없습니다 \#loc
javascript.private.member.obsolete.syntax.name=명시적 ''this''없이 \#-private 필드에 액세스합니다
javascript.private.member.obsolete.syntax=\#-private 필드는 명시적 ''this.'' 한정자 없이 액세스할 수 없습니다
javascript.jsdoc.protected.member.is.not.accessible.message=protected 멤버에 액세스할 수 없습니다 \#loc
javascript.jsdoc.private.member.is.not.accessible.message=private 멤버에 액세스할 수 없습니다 \#loc
javascript.static.member.is.not.accessible.message=static 멤버는 액세스할 수 없습니다 \#loc
javascript.instance.member.is.not.accessible.message=인스턴스 멤버에 액세스할 수 없습니다 \#loc
javascript.element.need.to.be.exported=요소를 내보내지 않습니다
javascript.element.need.to.be.imported=요소를 가져오지 않습니다
javascript.element.default.instead.named=디폴트 가져오기가 명명된 가져오기 대신 사용됩니다
javascript.element.need.to.be.included.to.config=해당 파일이 tsconfig.json에 포함되어 있지 않습니다
javascript.argument.types.mismatch=인수 타입이 매개변수와 일치하지 않습니다
javascript.member.from.unopened.namespace.message=열지 않은 네임스페이스의 멤버 \#loc 
javascript.property.is.read.only.message=프로퍼티가 읽기 전용입니다 \#loc
javascript.property.is.write.only.message=프로퍼티가 쓰기 전용입니다 \#loc
javascript.assume.uppercase.functions.to.be.constructors=대문자의 함수만 생성자라고 가정합니다
javascript.not.a.constructor.call.message=생성자 호출이 아닙니다
cannot.refactor.anonymous.function=호출 사이트 분석은 기존 비호출 사용 위치에 의해 방지됩니다.
change.signature.method.references.arguments=함수 참조 인수, 코드가 시그니처 변경 후 중단될 수 있습니다
change.signature.call.expression.contains.spreads=함수 호출이 전개 인수를 포함합니다. 사용 위치는 바뀌지 않습니다.
change.signature.tagged.template.issue=태그가 지정된 템플릿 호출을 업데이트할 수 없습니다. 사용 위치는 변경되지 않습니다.
change.signature.conflict.incompatible.override=재정의 {0}이(가) 리팩터링된 {1}와(과) 다른 수의 매개변수를 가집니다. 리팩터링하는 동안 {2}이(가) 무시됩니다.
change.signature.conflict.incompatible.implementation=구현 {0}이(가) 리팩터링된 {1}와(과) 다른 수의 매개변수를 가집니다. 리팩터링하는 동안 {2}이(가) 무시됩니다.
change.signature.conflict.eliminating.parameter.property.breaks.usages=매개변수-프로퍼티를 간단한 매개변수로 전환하면 {0} 필드 사용 위치가 중단됩니다
change.signature.conflict.readonly.parameter.property.write.usage={0}을(를) 읽기 전용으로 만들면 읽지 않은 사용 위치가 중단됩니다
javascript.missed.argument.for.parameter=매개변수 {0}에 대한 인수가 누락되었습니다

# Code folding settings
checkbox.collapse.object.literals=객체 리터럴
checkbox.collapse.one.line.function.literals=JavaScript 및 TypeScript의 인라인 함수
checkbox.collapse.array.literals=배열 리터럴
checkbox.collapse.xml.literals=XML 리터럴
change.signature.value.column.title=값
change.signature.column.name.optional.flag=선택적
change.signature.column.name.modifier=제어자

# Flow general
javascript.flow.error.panel.all.errors=모든 오류 표시
js.flow.all.servers.action.restart=모든 Flow 서버 다시 시작
js.flow.has.unsaved.files=일부 파일이 수정되어 강조 표시가 수행되지 않았습니다
js.flow.tool.window.name=Flow
flow.js.get.type=Flow JS\:타입 받기
flow.show.error.details=오류 세부 정보 표시
can.t.find.flow.executable=Flow 실행 파일을 찾을 수 없습니다
process.terminated=프로세스가 종료되었습니다
progress.text.modifying={0} 수정 중
progress.text.initializing.opened.files=열려 있는 파일 초기화 중

# Code style settings
js.code.style.punctuation.tab.title=문장 부호
space.before.name.value.separator=프로퍼티 이름-값 구분 기호 ''\:'' 이전
space.after.name.value.separator=프로퍼티 이름-값 구분 기호 ''\:'' 이후
space.before.function.left.parenth=함수 표현식에서
actionscript.space.after.dots.in.rest.parameter=나머지 매개변수의 ''...'' 이후
space.after.dots.in.rest.spread=rest/spread의 ''...'' 이후
space.before.generator.mult=제너레이터의 ''*'' 이전
space.after.generator.mult=제너레이터의 ''*'' 이후
spaces.within.object.type.braces=객체 리터럴 타입 중괄호
space.before.type.colon=타입 참조 콜론 ''\:'' 이전
space.after.type.colon=타입 참조 콜론 ''\:'' 이후
space.before.class.lbrace=클래스 왼쪽 중괄호
space.before.class.interface.module.lbrace=클래스/인터페이스/모듈 왼쪽 중괄호
spaces.within.object.literal.braces=객체 리터럴 중괄호
spaces.within.import.braces=ES6 import/export 중괄호
spaces.within.indexer.brackets=색인 액세스 대괄호
spaces.within.array.initializer=배열 대괄호
spaces.within.union.and.intersection=공용체 및 교차 타입
spaces.within.type.assertion=타입 어설션
spaces.arrow.function=화살표 함수(\=>)
spaces.async.arrow.function=비동기 화살표 함수에서
spaces.within.interpolation.expressions=보간 표현식
spaces.within.unary.additive=단항 가감 연산자(+,-,++,--)
spaces.after.unary.not=단항 ''not'' (\!) 및 ''\!\!'' 이후
spaces.before.unary.not=단항 ''not'' (\!) 및 ''\!\!'' 이전
js.blank.lines.around.method=주변 함수\:
js.blank.lines.around.function=반올림 함수\:
js.spaces.in.flow.category=Flow에서
js.wrap.settings.import=ES6 import/export
js.align.properties.none=정렬하지 않음
js.align.properties.on.colon=콜론을 기준으로 정령
js.align.properties.on.value=값을 기준으로 정령
js.function.call.parentheses=함수 호출 소괄호
js.function.declaration.parentheses=함수 선언 소괄호
js.function.brace.style=함수 선언에서
js.function.expression.brace.style=함수 표현식에서
js.function.parameters.wrap=함수 선언 매개변수
js.function.call.wrap=함수 호출 인수
js.space.before.function.left.brace=함수 왼쪽 중괄호
js.format.cstyle.comments=여러 줄 정렬
js.chained.call.dot.on.next.line=새 줄의 ''.''
js.generated.use.public.modifier=''public'' 제어자 사용
js.generated.use.as.cast=''as'' 형 변환 선호
js.generated.types=타입
js.generated.types.settings.link=명시적 타입에 대한 코드 스타일 설정
js.generated.explicit.types=다음에 대한 명시적 타입 선호\:
js.generated.explicit.var.types=변수 및 필드
js.generated.explicit.return.types=함수 선언 반환
js.generated.explicit.return.expression.types=함수 표현식 반환
js.trailing.comma.keep=유지
js.trailing.comma.remove=제거
js.trailing.comma.whenMultiline=여러 줄일 경우 추가
js.extends.list.wrap=확장 목록
js.align.multiline.extends.list=여러 줄일 경우 정렬
js.extends.keyword.wrap=키워드 확장
js.wrap.settings.union.and.intersection.types=공용체 및 교차 타입
js.code.style.object.literals.category.name=객체
js.code.style.align.caption=정렬
js.code.style.align.from.clause.caption=''from'' 절 정렬
js.wrap.settings.var.group.name=변수 선언
js.code.style.do.not.align.var.statement=정렬하지 않음
js.code.style.align.var.statements=여러 줄일 경우
js.code.style.align.var.statements.and.assignments=그룹화된 경우
js.code.style.array.group.name=배열
js.array.new.line.after.left.bracket=''['' 뒤에 새 줄
js.array.new.line.before.right.bracket=새 줄에 '']'' 배치

js.method.can.be.static=메서드가 static일 수 있습니다
js.method.can.be.static.option=''private'' 메서드만 검사
make.method.static=''static''으로 설정
typescript.fix.change.member.access=''{0}''(으)로 만들기
js.fix.change.member.access.to.sharp=''\#''을 사용하여 private으로 만들기
declare.event.0=이벤트 ''{0}'' 선언
js.variable.might.not.been.initialized=변수가 초기화되지 않았을 수 있습니다 \#loc
js.variable.initializer.is.redundant=변수 초기화가 불필요합니다 \#loc
js.value.assigned.is.never.used=할당된 값이 사용되지 않습니다 \#loc
js.value.assigned.to.is.never.used=''{0}''에 대입된 값이 사용되지 않습니다 \#loc
javascript.fix.change.type=''{0}'' 타입을 ''{1}''(으)로 변경
javascript.fix.change.parameter.type=매개변수 ''{0}'' 타입을 ''{1}''(으)로 변경
javascript.change.jsdoc.type.family.name=JSDoc의 요소 타입 변경
change.signature.dialog.title={0}의 시그니처 변경
javascript.fix.add.enum.values=명시적 열거형 값 추가
javascript.fix.add.string.enum.values=필드 이름과 일치하는 문자열 열거형 값 추가
javascript.fix.create.implements=''{0}''이(가) ''{1}''을(를) 구현하도록 설정
javascript.fix.create.inheritor.family=super 타입으로부터 상속
javascript.fix.implement.family=파생 클래스에서 구현
javascript.fix.implement.chooser.title=다음에서 멤버 구현
javascript.fix.implement.chooser.all=모든 클래스
javascript.fix.implement={0} 구현
javascript.fix.create.extends=''{0}''이(가) ''{1}''을(를) 확장하도록 설정
javascript.report.unused.properties=사용하지 않는 프로퍼티 보고
javascript.report.unused.definitions=사용하지 않는 정의 보고
javascript.check.global.definitions=전역 범위 안에서 할당 검사
javascript.strictly.check.global.vars=선언되지 않은 전역 변수를 오류로 보고
javascript.strictly.check.object.properties=선언되지 않은 프로퍼티를 오류로 보고
javascript.strictly.check.global.functions=선언되지 않은 전역 함수를 오류로 보고
change.signature.column.type=타입
change.signature.column.name=이름
javascript.invalid.invoker.target=유효하지 않은 호출 대상
js.declarations.at.scope.start.inspection=변수 선언이 범위 시작에 없습니다.
js.make.single.var.statement=단일 var 문으로 만들기
js.declaration.is.not.at.scope.start=var 문이 범위 시작에 없습니다
js.move.to.scope.start=var 문을 범위 시작으로 이동
js.primitive.type.wrapper.usage.inspection=기본 타입 객체 래퍼가 사용되었습니다
js.replace.with.type.cast.to.primitive={0}(으)로 형 변환하여 바꾸기
js.assigning.to.primitive.type.property=디폴트 값에 할당된 값이 손실됩니다
js.primitive.type.improper.instantiation.inspection={0} 인스턴스화를 단순화할 수 있습니다
js.replace.with.literal={0} 리터럴로 바꾸기
non.ascii.identifiers.inspection.name=비 ASCII 심볼이 있는 식별자
non.ascii.identifiers.only.ascii=ASCII 이름만 허용
non.ascii.identifiers.non.ascii.found=<html>이름이 ASCII 심볼을 포함합니다. {0}</html>
non.ascii.identifiers.mixed.set=<html>이름이 ASCII 및 비 ASCII 기호를 모두 포함합니다. {0}</html>

element.name.anonymous=<anonymous>
element.name.default=<디폴트값>
duplicate.parameter.name=매개변수 이름 중복\: {0}
rename.accessors.dialog.title=필드 이름 변경
rename.accessors.dialog.text=프로퍼티 접근자 이름도 역시 ''{0}''(으)로 변경하시겠어요?
insert.new.keyword.fix.name=새 키워드 삽입
insert.this.keyword.fix.name=this 한정자 추가
insert.class.fix.name=클래스 이름 한정자 추가
replace.implements.keyword.fix.name=''implements''을 ''extends''으로 변경
superclass.label.text=상위 클래스(&S)\:
varible.name.column.title=이름
varible.value.column.title=값
custom.variables.step.title.label.text=템플릿 ''{0}'' 의 사용자 정의 변수(&C)\:
create.class.ok.button.text=생성
create.class.name.label=이름(&N)\:
create.class.package.label=패키지\:
create.class.template.label=템플릿(&T)\:
create.class.superclass.label=상위 클래스(&S)\:
create.class.interfaces.label=인터페이스(&I)\:
action.structureview.show.object.inherited=객체로부터 상속

# JSHint
jshint.option.edit.dialog.title=''{0}'' 옵션 설정
jshint.clear.field.to.disable=비활성화할 필드 삭제
jshint.illegal.integer=올바르지 않은 정수
jshint.use.config.files=구성 파일 사용
jshint.version.label=버전(&V)\:
jshint.label.bundled.suffix=(번들)
jshint.tree.link.set=Ajustes
jshint.label.no.version=버전 없음
jshint.exception.balloon.action.retry=<a href\=''{0}''>다시 시도</a>
jshint.exception.balloon.action.configure.proxy.or.retry=<a href\=''{0}''>HTTP 프록시 구성</a> 또는 <a href\=''{1}''>다시 시도</a>
jshint.config.file.type.description=JSHint 구성
jshint.suppress.text.suppress.for.line=줄 억제
jshint.options.tree.tooltip.set.a.new.value=새 값 설정
jshint.config.option.default.name=디폴트
jshint.config.default.description=<div style\="padding-bottom\:10px"><div><b>.jshintrc</b></div><div style\="padding-left\:10px; padding-top\:4px;">JavaScript 파일을 린팅할 때 IDE는 파일의 폴더에서 시작하여 파일 시스템 루트로 이동하며 .jshintrc를 찾습니다.</div></div><div><div><b>package.json</b></div><div style\="padding-left\:10px; padding-top\:4px;"> 프로젝트의 package.json 파일 내 <code>jshintConfig</code> 프로퍼티 아래에 설정을 추가합니다.
jshint.config.option.custom.name=사용자 지정 설정 파일
jshint.config.option.custom.browser.title=JSHint 설정 파일 선택(*.jshintrc)
jshint.config.failed.to.read=JSHint config 읽기 실패
jshint.config.extends.cyclically=JSHint 설정이 순환 확장합니다
jshint.config.error.failed.to.read.property=package.json에서 ''{0}'' 프로퍼티를 읽지 못했습니다
jshint.config.error.cannot.locate.ext.config=JSHint\: 확장된 구성을 찾을 수 없습니다
jshint.config.error.cannot.parse.ext.config=JSHint\: 확장된 구성을 분석할 수 없습니다
jshint.latedef.false.text=경고 안 함
jshint.latedef.true.text=변수가 정의되기 전에 사용되는 것 금지
jshint.latedef.nofunc.text=<html><body>정의되기 전에 변수 사용은 금지하고 <br>함수 선언은 허용합니다.</body></html>
jshint.unused.false.text=아무것도 검사 안 함
jshint.unused.true.text=<html><body>모든 변수 및 매개변수를 검사하되 사용된 매개변수 <br>다음에 사용되지 않는 매개변수를 허용합니다.</body></html>
jshint.unused.vars.text=함수 매개변수가 아닌 변수 검사
jshint.unused.strict.text=모든 변수 및 매개변수 검사
jshint.progress.title.updating.jshint=JSHint에서 {0} (으)로 업데이트 중
jshint.progress.title.downloading={0} 다운로드 중
jshint.progress.title=JSHint {0}
jshint.quotmark.false.text=두 따옴표 모두 허용됨
jshint.quotmark.true.text=작은 따옴표만 또는 큰따옴표만 허용됨
jshint.quotmark.single.text=작은따옴표만 허용됨
jshint.quotmark.double.text=큰따옴표만 허용됨
jshint.inspection.message.duplicate.options=JSHint 옵션 {0}, {1}이(가) 중복됩니다.
jshint.inspection.message.unexpected.jshint.option.name=예기치 않은 JSHint 옵션 이름
jshint.inspection.message.unexpected.value=예기치 않은 값
jshint.inspection.message.expected.values.x.or.y=필요한 값\: {0} 또는 {1}
jshint.inspection.message.expected.value=필요한 값\: {0}
jshint.inspection.message.object.or.array.expected=객체 또는 배열이 필요합니다
jshint.inspection.message.not.loaded=JSHint {0}이(가) 로드되지 않았습니다
jshint.inspection.message.config.not.found=JSHint 구성을 찾을 수 없습니다
jshint.inspection.message.malformed.config=형식이 잘못된 JSHint 구성
jshint.inspection.message.prefix=JSHint\:

jshint.option.esversion.description.short=지정된 ECMAScript 버전과의 비호환성 경고
jshint.option.latedef.description.short=변수가 정의되기 전에 사용되는 경우 경고
jshint.option.unused.description.short=사용되지 않는 변수에 대해 경고
jshint.option.indent.description.short=들여쓰기
jshint.option.quotmark.description.short=따옴표 표시
jshint.option.predef.details=전역 변수 및 해당 변수의 대입 가능한 상태를 지정합니다.\n<pre>DISQUS\:true, jQuery\:false</pre>\n<p/>여기에서 JSHint를 사용하면 DISQUS를 재정의할 수 있지만\n jQuery를 재정의하려고 하면 오류가 표시됩니다.
jshint.option.bitwise.description.short=비트 연산자 사용 시 경고
jshint.option.camelcase.description.short=변수 이름 지정 시 경고
jshint.option.curly.description.short=블록에서 <code>{}</code>가 생략될 시 경고
jshint.option.enforceall.description.short=코드가 가장 엄격한 구성을 준수하지 않을 시 경고
jshint.option.eqeqeq.description.short=안전하지 않은 비교 시 경고
jshint.option.es3.description.short=ES3 사양과의 비호환성 경고
jshint.option.es5.description.short=ES5 사양과의 비호환성 경고
jshint.option.forin.description.short=안전하지 않은 <code>for..in</code>에 대해 경고
jshint.option.freeze.description.short=네이티브 객체의 프로토타입을 덮어쓸 시 경고
jshint.option.immed.description.short=괄호로 묶지 않은 채 즉시 함수 호출을 사용하는 경우 경고
jshint.option.newcap.description.short=대문자가 없는 생성자의 사용에 대해 경고
jshint.option.noarg.description.short=<code>arguments.caller</code> 및 <code>.callee</code>에 대해 경고
jshint.option.nocomma.description.short=쉼표 연산자 사용 시 경고
jshint.option.noempty.description.short=빈 블록에 대해 경고
jshint.option.nonbsp.description.short="줄 바꿈 없는 공백" 문자에 대해 경고
jshint.option.nonew.description.short=부작용 관련 <code>new</code>의 사용에 대해 경고
jshint.option.plusplus.description.short=단항 증가 및 감소 연산자 사용에 대해 경고
jshint.option.undef.description.short=변수가 정의되지 않은 경우 경고
jshint.option.varstmt.description.short=VariableStatements의 사용에 대해 경고
jshint.option.strict.description.short=코드가 엄격 모드에 있지 않은 경우 경고
jshint.option.trailing.description.short=후행 공백에 대해 경고
jshint.option.maxparams.description.short=함수 내 형식 매개변수의 최대 수
jshint.option.maxdepth.description.short=블록의 최대 깊이
jshint.option.maxstatements.description.short=함수 내 구문의 최대 수
jshint.option.maxcomplexity.description.short=코드 내 최대 순환 복잡성
jshint.option.maxlen.description.short=줄의 최대 길이
jshint.option.asi.description.short=세미콜론 누락에 대한 경고 억제
jshint.option.boss.description.short=<code>if/for/...</code> 내 대입에 대한 경고 억제
jshint.option.debug.description.short=코드 디버그에 대한 경고 억제
jshint.option.elision.description.short=ES3 배열 제거 요소에 대한 경고 표시 억제
jshint.option.eqnull.description.short=<code>\=\= null</code>에 대한 경고 억제
jshint.option.esnext.description.short=EcmaScript.next
jshint.option.evil.description.short=<code>eval</code>에 대한 경고 억제
jshint.option.expr.description.short=표현식을 구문으로서 사용하는 것에 대한 경고 억제
jshint.option.funcscope.description.short=선언된 블록 외부에서의 변수 사용에 대한 경고 억제
jshint.option.futurehostile.description.short=향후 JavaScript 버전에서 정의된 식별자 사용 시 경고
jshint.option.gcl.description.short=JSHint를 Google Closure Compiler와 호환되도록 설정
jshint.option.globalstrict.description.short=전역 엄격 모드 사용에 대한 경고 억제
jshint.option.iterator.description.short=<code>__iterator__</code> 프로퍼티에 대한 경고 억제
jshint.option.lastsemic.description.short=한 줄 블록의 마지막 구문에서 세미콜론이 생략된 경우에만 세미콜론 누락에 대한 경고를 억제
jshint.option.laxbreak.description.short=안전하지 않은 줄 바꿈에 대한 경고 억제
jshint.option.laxcomma.description.short=쉼표 우선 코딩 스타일에 대한 경고 억제
jshint.option.loopfunc.description.short=루프 내 함수에 대한 경고 억제
jshint.option.moz.description.short=코드에서 Mozilla JavaScript 확장 프로그램을 사용하는지 확인
jshint.option.multistr.description.short=여러 줄 문자열에 대한 경고 억제
jshint.option.notypeof.description.short=잘못된 <code>typeof</code> 연산자 값에 대한 경고 억제
jshint.option.proto.description.short=<code>__proto__</code> 프로퍼티에 대한 경고 억제
jshint.option.scripturl.description.short=스크립트 대상 URL 사용에 대한 경고 억제
jshint.option.smarttabs.description.short=공백이 정렬에만 사용되고 탭과 공백이 혼재되어 있는 경우에 대한 경고 억제
jshint.option.shadow.description.short=변수 그림자화에 대한 경고 억제
jshint.option.singlegroups.description.short=엄밀히 필요하지 않은 경우 그룹화 연산자의 사용 금지
jshint.option.sub.description.short=점 표기로 표현할 수 있는 경우 <code>[]</code> 표기를 사용하는 것에 대한 경고 억제
jshint.option.supernew.description.short="이상한" 생성에 대한 경고 억제
jshint.option.validthis.description.short=가능한 엄격한 위반에 대한 경고 억제
jshint.option.withstmt.description.short=with 문 사용에 대한 경고 억제
jshint.option.noyield.description.short=yield 문이 없는 제너레이터 함수에 대한 경고 억제
jshint.option.browser.description.short=브라우저
jshint.option.devel.description.short=개발
jshint.option.nonstandard.description.short=이스케이프 및 이스케이프 해제
jshint.option.typed.description.short=타입 지정된 배열
jshint.option.worker.description.short=Web Worker
jshint.option.wsh.description.short=Windows Script Host
jshint.option.module.description.short=ECMAScript 6 모듈
jshint.option.nomen.description.short=변수 내에서 _ 사용 허용 안 함
jshint.option.onevar.description.short=함수당 var 문 1개
jshint.option.passfail.description.short=첫 오류 시 중지
jshint.option.white.description.short=지저분한 공백 허용 안 함
jshint.option.maxerr.description.short=최대 오류 수
jshint.option.predef.description.short=사전 정의됨( , 구분)

#common linters
javascript.linter.import.error.timeout.processing.configuration.file=구성 파일 처리가 시간 초과되었습니다
javascript.linter.import.error.generic=구성 파일의 코드 스타일 규칙을 적용하는 동안 오류가 발생했습니다. 이는 구성 파일이 올바르지 않기 때문일 수 있습니다.
javascript.linter.import.error.package.not.found=''{0}'' 패키지를 찾을 수 없습니다
javascript.linter.import.error.entry.point.not.found=''{0}'' 패키지에서 진입점을 찾을 수 없습니다
javascript.linter.import.error.bin.file.not.found=''{1}'' 패키지에서 ''{0}''을(를) 찾을 수 없습니다
javascript.linter.import.notification={0}\: 프로젝트 코드 스타일 및 에디터 설정이 ''{1}''을(를) 기반으로 업데이트되었습니다.
javascript.linter.import.notification.edit=''{0}'' 편집
javascript.linter.import.notification.rules.applied=다음 {0} 적용\: {1}
javascript.linter.import.notification.reset=재설정
javascript.linter.import.notification.restored=디폴트 코드 스타일 및 에디터 설정이 복원되었습니다
javascript.linter.import.translate.config.title=ESLint 코드 스타일 규칙 적용
javascript.linter.import.translate.config.description=ESLint 코드 스타일 규칙 적용
javascript.linter.import.translate.config.progress.title={0} 코드 스타일 규칙 적용 중
javascript.linter.import.translate.config.file.error=코드 스타일 규칙을 적용할 수 없습니다
javascript.linter.import.nothing.to.import={0}\: 알려진 모든 규칙이 이미 적용되었습니다
javascript.linter.use.severity.from.config.label=설정 파일에서 규칙 중요도 사용
javascript.linter.configuration.file.title=구성 파일
javascript.linter.radio.button.configuration.file=구성 파일(&C)\:
javascript.linter.error.empty.path=빈 경로
javascript.linter.error.no.such.file=해당 파일 없음
javascript.linter.error.specify.correct.path.to=올바른 {0} 경로를 지정하세요
javascript.linter.error.failed.to.lint={0} Lint에 실패했습니다
javascript.linter.error.can.not.find.psi.file={0}에 대한 PSI 파일을 찾을 수 없습니다
javascript.linter.error.can.not.find.document={0}에 대한 문서를 찾을 수 없습니다
javascript.linter.error.notification.problem.with.reformatting={0}의 서식을 다시 지정하는 데 문제가 발생했습니다.<br/>{1}
javascript.linter.error.no.path.to.package=''{0}'' 패키지 경로를 지정하세요
javascript.linter.error.package.not.installed=''{0}'' 패키지를 설치하세요
javascript.linter.error.invalid.path.to.package=올바른 ''{0}'' 패키지 경로를 지정하세요
dialog.message.please.specify.stylelint.package.correctly=Stylelint 패키지를 올바르게 지정하세요. stylelint 바이너리를 찾을 수 없습니다
stylelint.action.fix.problems.description=''stylelint --fix''를 호출하여 Stylelint 문제 수정
stylelint.action.modal.title=Stylelint 수정
stylelint.action.background.title=Stylelint --fix 실행 중...

javascript.linter.action.edit.config={0} 편집
javascript.linter.action.edit.property={1} 내 {0} 편집
javascript.linter.action.edit.settings.text={0} 설정...
javascript.linter.action.fix.prompt={0}(으)로 선택한 파일의 서식을 다시 지정하시겠어요?
javascript.linter.action.fix.problems.file.text={0}\: 현재 파일 수정
javascript.linter.action.fix.problems.name={0} 문제 해결
javascript.linter.action.fix.problems.name.start={0} 문제 해결이 시작되었습니다
javascript.linter.action.fix.problems.name.finish={0} 문제 해결이 완료되었습니다
javascript.linter.configurable.config.autoSearch.title=자동 검색(&S)
javascript.linter.suppress.rules.for.line.family.name=현재 줄 억제
javascript.linter.suppress.rule.for.line.description=현재 줄의 ''{0}'' 억제
javascript.linter.suppress.all.rules.for.line.description=현재 줄의 모든 {0} 규칙 억제
javascript.linter.suppress.rules.for.file.family.name=현재 파일 억제
javascript.linter.suppress.rule.for.file.description=현재 파일의 ''{0}'' 억제
javascript.linter.suppress.all.rules.for.file.description=현재 파일의 모든 {0} 규칙 억제
javascript.linter.progress.reformatting.with={0}을(를) 사용해 서식 다시 지정 중...

javascript.linter.intention.name.details=세부 정보
javascript.linter.intention.family.name.show.details={0}\: 세부 정보 표시

# eslint
settings.javascript.linters.eslint.configurable.name=ESLint
eslint.configurable.eslintPackage.label=ESLint 패키지(&E)\:
eslint.configurable.config.autoSearch.description.bodyInnerHtml=ESLint는 린팅할 파일이 위치한 파일 디렉터리에서와 파일 시스템의 루트 디렉터리까지 모든 상위 디렉터리에서 .eslintrc.* 및 package.json 파일을 자동으로 찾습니다. <div style\="padding-top\:8px">package.json을 사용하려면 <code>eslintConfig</code> 프로퍼티 아래에 설정을 추가하세요. 
eslint.configurable.label.working.directories=작업 디렉터리(&W)\:
eslint.configurable.working.dir.field.empty.text=가장 가까운 .eslintrc 또는 .eslintignore로 탐지
eslint.configurable.working.directories.comment=<html>경로 또는 <a href\=''https\://github.com/isaacs/node-glob\#glob-primer''>glob 패턴</a>을 세미콜론으로 구분합니다. 자동 탐지를 위해 비워두세요.</html>
eslint.configurable.config.select.config.text=ESLint 설정 파일 선택(*.eslintrc.*)
eslint.configurable.additionalRulesDir.label=추가 규칙 디렉터리(&R)\:
eslint.configurable.additionalRulesDir.browseDialogTitle=ESLint 추가 규칙 디렉터리 선택
eslint.configurable.extraOptions.label=추가 eslint 옵션(&O)\:
eslint.run.for.files.label=다음 파일에 대해 실행(&F)\:
eslint.files.pattern.comment=<html><a href\=''https\://github.com/isaacs/node-glob\#glob-primer''>glob 패턴</a>을 사용하세요(예\: <code>{**/*,*}.{js,ts}</code>)</html>
eslint.run.on.save=저장 시 eslint --fix 실행(&U)
eslint.action.fix.problems.description=''eslint --fix''를 호출하여 ESLint 문제를 해결합니다
eslint.fix.problems.text.with.error.code={0}\: ''{1}'' 수정
eslint.fix.problems.text.current={0}\: 현재 오류 수정
eslint.fix.problems.family.name={0}\: 현재 오류 수정
eslint.error.package.directory.expected=패키지 디렉터리 필요
eslint.code.style.apply.message=ESLint에 코드 스타일을 적용하시겠어요?
eslint.code.style.dismiss.text=아니오
eslint.code.style.apply.text=예
eslint.version.0.is.not.supported.please.upgrade.eslint=ESLint {0} 버전은 지원되지 않습니다. ESLint를 업그레이드하세요.
eslint.additional.rules.directory.field.name=추가 규칙 디렉터리
eslint.configuration.file.field.name=ESLint 구성 파일
eslint.inspections.error.can.not.parse.message=메시지를 분석할 수 없습니다. JSON 객체가 필요하나 {0}을(를) 얻었습니다
eslint.inspections.error.messages.not.array=메시지가 배열이 아닙니다. {0}
eslint.inspections.error.unexpected.language.service.response=예기치 않은 언어 서비스 응답\: {0}
eslint.inspections.error.unknown.message.severity=알 수 없는 메시지 심각도\: {0}\n본문\:\n{1}

#standardJS
standardjs.name=표준 코드 스타일
standardjs.editor.notification.can.be.enabled.text=이 프로젝트에 JavaScript 표준 코드 스타일을 사용하시겠어요?
standardjs.editor.notification.action=예
standardjs.editor.notification.do.not.show.text=아니오
standardjs.edit.settings.caption=ESlint/표준 코드 스타일
standardjs.action.fix.problems.description=표준 코드 스타일 문제 해결
standardjs.error.unsupported.package=지원되지 않는 패키지 버전입니다. ''표준'' 패키지를 최소 버전 {0}(으)로 업그레이드하세요.
standardjs.codestyle.updated={0}\: 프로젝트 코드 스타일 설정이 업데이트되었습니다
standardjs.codestyle.updated.config.section={0}\: 프로젝트 코드 스타일 설정이 package.json의 ''standard'' 섹션을 기반으로 업데이트되었습니다
standardjs.codestyle.updated.dependency={0}\: 프로젝트 코드 스타일 설정이 package.json의 ''standard'' 종속 요소를 기반으로 업데이트되었습니다

# Actions
js.show.type.info.action.error=표현식을 찾을 수 없습니다
javascript.ignore.unused.function.parameters=사용하지 않는 매개변수 무시\:
javascript.ignore.unused.catch.parameters=사용하지 않는 catch 매개변수 무시
complete.import.binding=가져오기 바인딩 완료
complete.import.name=이름 가져오기 완료
remove.type.prefix=타입 접두사 제거
add.import.binding.to.import=가져오기에 가져오기 바인딩 추가
add.import.specifier.to.import=가져오기 가져오기 지정자 추가
create.js.file.description=지정된 템플릿에서 JavaScript 파일 생성
create.ts.file.description=새 TypeScript 파일 생성
create.file.name=파일 ''{0}'' 생성
create.file.name.with={1}이(가) 있는 파일 ''{0}'' 생성
create.file.name.with.and={1} 및 {2}이(가) 있는 파일 ''{0}'' 생성
class.names={0,choice,1\#클래스|2\#클래스} {1}
function.names={0,choice,1\#함수|2\#함수} {1}

# todo remove, has external usages
javascript.completion.several.definitions=(여러 정의)

# File watchers
js.file.watcher.6to5.description=Babel을 사용하여 ECMAScript 6 코드를 ECMAScript 5 코드로 변환
editor.notification.label.enable.babel.file.watcher.question=파일 감시기가 Babel을 사용하여 ECMAScript 6을 ECMAScript 5로 변환하도록 설정하시겠어요?

# Annotator
typescript.export.assignment.cannot.be.used.in.internal.modules=내부 모듈에서 내보내기 할당을 사용할 수 없습니다
typescript.type.predicate.not.return=타입 술부는 함수 및 메서드의 반환 타입 위치에서만 허용됩니다
typescript.type.this.predicate.not.return=''this'' 기반 타입 술부는 클래스나 인터페이스의 멤버, 또는 get 접근자나 함수 및 메서드의 반환 타입 위치 안에서만 허용됩니다.
typescript.type.predicate.not.match.name=매개변수 {0}을(를) 찾을 수 없습니다
typescript.type.predicate.rest=타입 술부가 나머지 매개변수를 참조할 수 없습니다
typescript.type.predicate.destructuring=타입 술부 바인딩 패턴의 요소를 참조할 수 없습니다
typescript.type.predicate.incompatible.types=타입 술부를 {0}에 할당할 수 없습니다
typescript.generics.should.not.be=타입 ''{0}''이(가) 제네릭이 아닙니다
es6.default.export.not.declared=가져온 모듈에서 디폴트 내보내기가 선언되지 않습니다
js.annotator.assignment.pattern.rhs=할당 패턴은 할당의 왼쪽에 있어야 합니다
es6.generate.index.action=index.js/index.ts 생성
es6.generate.index.action.description=index.js/index.ts 생성
js.annotator.thin.arrow.used=얇은 화살표가 사용되었습니다
js.annotator.newline.before.arrow=화살표 앞에 줄 바꿈이 허용되지 않습니다
js.annotator.replace.with.fat.arrow=굵은 화살표로 바꾸기
js.annotator.unary.operator.within.exponential=지수식 바로 앞에서 단항 연산자 ''{0}''이(가) 허용되지 않습니다. 모호성 해결을 위해 소괄호를 추가하세요.

# Live templates
jsx.html.context.type=JSX HTML
js.expression.context.type=표현식
js.statement.context.type=구문
js.top.level.statement.context.type=최상위 구문
js.class.context.type=클래스/인터페이스
ecmascript.6.or.higher=ECMAScript 6 이상

# Gulp
gulp.rc.gulpfile.label=Gulp 파일(&F)\:
gulp.rc.gulpfile.browseDialogTitle=gulpfile.js 선택
gulp.rc.tasks.label=작업(&T)\:
gulp.rc.arguments.label=인수(&R)\:
gulp.rc.nodeInterpreter.label=노드 인터프리터(&I)\:
gulp.rc.nodeOptions.label=노드 옵션(&O)\:
gulp.rc.gulpPackage.label=Gulp 패키지(&G)\:
gulp.rc.environmentVariables.label=환경(&E)\:
gulp.task.title=Gulp 작업
gulp.before.run.task=Gulp 작업 실행
gulp.before.run.task.descr=gulp {0, choice, 0\#작업|1\#작업|2\#작업 }{1} [{2}] 실행
gulp.gulpfile.unspecified=Gulpfile이 지정되지 않았습니다
gulp.gulpfile.not.found=Gulpfile을 찾을 수 없습니다

# Grunt
grunt.rc.gruntfile.label=Grunt 파일(&F)\:
grunt.rc.gruntfile.browseDialogTitle=Grunt 파일 선택
grunt.rc.tasks.label=작업(&T)\:
grunt.rc.arguments.label=인수(&R)\:
grunt.rc.nodeInterpreter.label=노드 인터프리터(&I)\:
grunt.rc.nodeOptions.label=노드 옵션(&O)\:
grunt.rc.gruntCliPackage.label=grunt-cli 패키지(&P)\:
grunt.rc.environmentVariables.label=환경(&E)\:
grunt.task.title=Grunt 작업
grunt.before.run.task=Grunt 작업 실행
grunt.before.run.task.descr=Grunt {0, choice, 0\#작업|1\#작업|2\#작업 }{1} [{2}] 실행
grunt.unspecified.gruntfile=지정되지 않은 Gruntfile
grunt.gruntfile.not.found=Gruntfile을 찾을 수 없습니다

#node
settings.nodejs.name=Node.js 및 NPM
settings.nodejs.coding.assistance.label=Node.js에 대한 코딩 지원(&A)
settings.nodejs.coding.assistance.manage.scopes.label=범위 관리...

node.interpreter.label=노드 인터프리터(&I)\:
node.interpreter.unspecified.error.text=Node.js 인터프리터를 지정하세요
node.package.manager.label=패키지 관리자(&M)\:
node.package.empty.hint={0} 패키지 디렉터리 경로
node.package.empty.hint.pkg1.or.pkg2={0} 또는 {1}
node.package.selector.single.package.title={0} 패키지 디렉터리 선택
node.package.selector.multiple.packages.title=패키지 디렉터리 선택
node.package.selector.multiple.packages.description={0} 선택
node.package.none=패키지가 없습니다
node.package.dropDownList.select=선택...

node.js.modules.dependencies.missing.family.name=require() 호출이 누락되었습니다
inspection.NodeCoreCodingAssistanceInspection.no.coding.assistance.message=Node.js에 대한 코딩 지원이 비활성화되었습니다
action.ToggleNodeCoreCodingAssistanceAction.toggle.coding.assistance.for.node.js.text=Node.js에 대한 코딩 지원 전환

# npm
npm.rc.packageJson.label=package.json(&P)\:
npm.rc.packageJson.browseDialogTitle=package.json 파일 선택
npm.rc.command.label=명령어(&C)\:
npm.rc.scripts.label=스크립트(&T)\:
npm.rc.scriptsArguments.label=인수(&R)\:
npm.rc.nodeInterpreter.label=노드 인터프리터(&I)\:
npm.rc.nodeOptions.label=노드 옵션\:
npm.rc.environmentVariables.label=환경\:
npm.task.title=NPM 스크립트
npm.before.run.task=npm 스크립트 실행
npm.before.run.task.descr=npm {0, choice, 0\#스크립트|1\#스크립트|2\#스크립트 }{1} [{2}] 실행 
npm.dialog.message.cannot.resolve.package.manager=''{0}'' 패키지 관리자를 해결할 수 없습니다
npm.no.scripts.found=스크립트를 찾을 수 없습니다
dialog.message.unspecified.package=지정되지 않은 {0} 패키지
dialog.message.invalid.package.file.specified.but.directory.with.package.json.expected=잘못된 {0} 패키지\: 파일이 지정되었지만 package.json이 있는 디렉터리가 필요합니다
dialog.message.invalid.package.no.such.directory=잘못된 {0} 패키지\: 해당 디렉터리가 없습니다
dialog.message.invalid.npx.command=잘못된 npx 명령어
dialog.message.package.yarn.installed.package.format.yarn.relative.path.to.package.json.package.name={0} 패키지\: Yarn 설치 패키지 형식은 ''yarn\:[package.json의 상대 경로]\:[패키지 이름]''입니다.
dialog.message.no.path.to.package.json.found=package.json 경로를 찾을 수 없습니다.
dialog.message.unspecified.package.name=패키지 이름이 지정되지 않았습니다.
dialog.message.invalid.package.no.such.file=잘못된 {0} 패키지\: 해당 파일이 없습니다
enable.notifications.about.installing.dependencies.from.package.json=package.json으로부터 종속성 설치 시 알림 활성화
notification.content.notifications.are.enabled.for.current.package.json=현재 package.json에 대한 알림이 활성화됩니다
notification.content.notifications.are.enabled.for.all.package.json.files=모든 package.json 파일에 대한 알림이 활성화됩니다
dialog.message.please.specify.npm.or.yarn.package.cannot.find.inside.directory=npm 또는 yarn 패키지를 지정하세요. "{1}" 디렉터리에서 "{0}"을(를) 찾을 수 없습니다
dialog.message.please.correct.path.to.npm.or.yarn.package.no.such.directory=npm 또는 yarn 패키지의 경로를 수정하세요. "{0}" 디렉터리가 없습니다

# Build tools
buildTools.JsbtRunTaskAction.text=Gulp/Grunt/npm 작업 실행
buildTools.JsbtAddBuildfileAction.text={0} 추가
buildTools.choose_buildfile.text={0} 선택 
buildTools.JsbtRemoveBuildfileAction.text={0} 제거
buildTools.JsbtReloadTasksAction.text=작업 다시 불러오기
buildTools.JsbtReloadTasksAction.npm.text=스크립트 다시 불러오기
buildTools.JsbtShowTasksAction.text={0} 작업 표시
buildTools.JsbtShowTasksAction.npm.text=npm 스크립트 표시
buildTools.searchEverywhere.text=''{0}'' 작업 실행
buildTools.searchEverywhere.npm.text=''{0}'' npm 스크립트 실행
buildTools.ShowSettingsAction.text={0} 설정...
buildTools.ShowSettingsAction.npm.text=npm 구성 편집(&E)...
buildTools.EditRunSettingsAction.text=''{0}'' 설정 편집(&E)...
buildTools.tree.sortBy.text=정렬
buildTools.tree.sortBy.definitionOrder.text=정의 순서
buildTools.tree.sortBy.name.text=이름
buildTools.no.tasks.found=작업을 찾을 수 없습니다
buildTools.edit.run.configuration=실행 구성 편집
buildTools.no.files.added=추가된 파일이 없습니다
buildTools.add.with={1}(으)로 {0} 추가
buildTools.no.such.file=해당 파일 없음
buildTools.failed.to.list.tasks=작업을 나열하지 못했습니다
buildTools.failed.to.list.tasks.details.reference=세부 정보
buildTools.tooltip.click.to.show.error.details=클릭하여 오류 세부 정보 표시

#npm modules
npm.modules.inspection.content.of.require.not.in.dependencies.warning=모듈이 package.json 종속에 포함되어 있지 않습니다
npm.modules.inspection.content.of.require.module.not.installed.warning=모듈이 설치되어 있지 않습니다
npm.modules.install.global.types.fix.name=더 나은 타입 정보를 위해 TypeScript 정의 설치
package.json.install.types.fix.family.name=패키지에 @types 설치
node.js.quickfix.install.node.module.with.dev.dependencies.text=''{0}'' 개발 종속으로 설치
node.js.quickfix.install.node.module.text=''{0}'' 설치
node.js.quickfix.install.node.module.family.name=모듈 설치
node.js.quickfix.install.node.module.devDependencies.family.name=''{0}'' 개발 종속으로 모듈 설치
node.js.quickfix.install.node.module.update.modules.family.name=''npm install'' 실행
node.js.quickfix.run.command=''{0}'' 실행
node.js.quickfix.install.node.module.error.prefix.text=Node.js 모듈을 설치할 수 없습니다. {0}
node.js.quickfix.install.node.module.error.no.interpreter.text=Node.js 모듈을 설치할 수 없습니댜\: 디폴트 Node.js 인터프리터를 지정하세요.
node.js.quickfix.install.node.module.error.no.interpreter.title=Node.js 모듈 설치
node.js.select.file={0} 파일 선택
dialog.message.cannot.determine.package.json.directory=package.json 디렉터리를 확인할 수 없습니다
action.InstallNodeLocalDependencies.text=Node.js 종속성 설치
action.InstallNodeLocalDependencies$Root.text={1}에 대한 ''{0}'' 실행

typescript.types.module.not.installed.warning=모듈 ''{0}''에 대한 정의를 해결할 수 없습니다
npm.modules.install.global.types.directory.error=필요한 디렉터리를 생성할 수 없습니다
npm.modules.install.global.types.dialog.title=TypeScript 정의 설치

typescript.types.union=공용체
typescript.types.intersection=교차
typescript.types.mapped=매핑된
typescript.types.key=다음에 대한 키 참조
typescript.types.merged=병합됨
typescript.types.merged.accessor=병합된 접근자
typescript.types.type.member={0} 타입 지정된 프로퍼티
typescript.types.merged.parts=참조된 프로퍼티\:

# Intentions
ts.generate.reference.path.name=참조 경로 주석 생성
ts.add.import.statement.family.name=import 문추가
ts.add.import.statement.dialog.title=import 문 추가
ts.add.import.all.family.name=모호하지 않은 import 문 모두 추가
ts.add.import.hint.text={1}(으)로 {0} 추가
ts.add.import.hint.multiple.text={1}(으)로 {0} import 문 추가
ts.add.import.hint.all.part=또는 {0}이(가) 있는 모든 import 문
ts.change.import.action.one.title={0}로 변경
ts.change.import.action.many.title=가져오기 변경...
ts.change.import.action.command=가져오기 변경
ts.change.import.action.family.name=ES6 가져오기 변경
ts.change.import.action.dialog.title=...으로부터 가져오기
ts.convert.alias.to.interface.action.title=별칭을 인터페이스로 변환
ts.convert.alias.to.interface.action.family.name=타입 별칭을 인터페이스로 변환
ts.convert.alias.to.enum.action.title=별칭을 열거형으로 변환
ts.convert.alias.to.enum.action.family.name=타입 별칭을 열거형으로 변환
ts.convert.parameter.property.to.field=매개변수 프로퍼티를 클래스 필드로 변환
ts.convert.field.to.parameter.property=필드를 매개변수 프로퍼티로 변환
anonymous.to.named.intention.function.name=함수 이름\:
initialize.fields.intention.visibility=가시성\:
command.name.import={0} 가져오기
please.specify.package.manager=<a href\="">패키지 관리자</a>를 지정하세요.
please.specify.local.node.js.interpreter.in.node.js.and.npm={0}에서 로컬 Node.js 인터프리터를 지정하세요
intention.name.add.file.to.tsconfig=파일 ''{0}''을(를) tsconfig.json에 추가
intention.name.import.augmentation=증강 {0} 가져오기

# Language Service
javascript.language.service.default.empty.text=오류가 없습니다
javascript.language.service.tracking.disabled=오류 추적이 활성화되어있지 않습니다
javascript.language.service.tracking.is.not.started=서비스가 시작되어있지 않습니다
javascript.language.service.default.project.errors=프로젝트 오류 표시
javascript.service.node.error=노드 인터프리터 경로가 올바르지 않습니다. 인터프리터 설정을 확인하세요
javascript.starting.service={0} 서비스 시작
javascript.language.service.cannot.get.results=언어 서비스에서 결과를 얻을 수 없습니다.
javascript.language.service.start.timeout=언어 서비스 프로세스 시작 시 시간 초과
javascript.language.service.cannot.start=언어 서비스 프로세스를 시작할 수 없습니다.
cannot.parse.service.initialization.answer.0=서비스 초기화 응답 {0}을(를) 분석할 수 없습니다\n
tab.title.errors=오류
tab.title.project.errors=프로젝트 오류
tab.title.compile.errors=컴파일 오류
dialog.message.no.results.for.after={1} 후에 {0}의 결과가 없습니다
intention.name.loading.service.fixes=서비스 수정 로드 중...

# TypeScript Compiler
typescript.compiler.notification.editor.configure=TypeScript 구성...
typescript.compiler.configurable.name=TypeScript
typescript.use.service.configurable.options.enable=TypeScript 언어 서비스
typescript.compiler.configurable.options.output.path=출력 경로 사용\:
typescript.compiler.configurable.options.compile.main=main 파일만 컴파일\:
typescript.compiler.configurable.options.compile.main.error=main 파일에 대한 잘못된 경로
typescript.compiler.configurable.options.version=TypeScript\:
typescript.compiler.configurable.options.generate.source.map=소스 맵 생성
typescript.compiler.configurable.options.enable.no.config=tsconfig.json이 없는 프로젝트인 경우도
typescript.compiler.configurable.options.track.file.system=변경 시 다시 컴파일
typescript.compiler.configurable.options.scope=컴파일 범위\:
typescript.compiler.configurable.options.command.line=옵션\:
dialog.message.cannot.compile.typescript.config.file.incorrect=TypeScript를 컴파일할 수 없습니다. 구성 파일이 잘못되었습니다.
intention.family.name.suppress.with.ts.ignore=@ts-ignore로 억제
typescript.compiler.structure.tab.title=구조
typescript.compiler.starting=TypeScript 시작 중...

typescript.service.no.config=파일이 tsconfig.json에 포함되어 있지 않습니다.
typescript.service.no.main.reference=파일이 main 파일에서 참조되지 않아 처리되지 않았습니다


js.tool.window.limit=첫 {0}개의 오류가 표시됩니다.
js.tool.window.limit.all=모든 {0} 오류 표시
typescript.compiler.action.compile.all=모두 컴파일
typescript.compiler.action.compile.toolbar=컴파일
typescript.compiler.action.compile.all.description=모든 프로젝트 파일 컴파일
typescript.service.action.restart=TypeScript 서비스 다시 시작
typescript.compiler.action.compile.all.compile.config=구성 {0}을 위한 파일 컴파일
typescript.compiler.action.compile.current=현재 파일 컴파일
typescript.compiler.action.compile.simple=TypeScript 컴파일
typescript.compiler.action.compile.description=현재 프로젝트 컴파일
typescript.compiler.action.no.compile.message=파일이 main 파일에서 참조되지 않아 컴파일되지 않았습니다
typescript.compiler.before.run=TypeScript 컴파일

typescript.language.service.clean=캐시 재설정 중...
typescript.language.service.compile.file=파일 컴파일 중... {0}
typescript.language.service.compile.project=프로젝트 컴파일 중... {0}
typescript.language.service.compile.file.errors=오류 계산 중... {0}
typescript.language.service.compile.project.errors=프로젝트 오류 계산 중... {0}
typescript.language.service.compile.project.open.file=파일 열기... {0}

typescript.before.task.check.errors=오류 검사
typescript.before.task.config.path=설정 파일\:
typescript.before.task.title=TypeScript 컴파일 설정
typescript.before.task.config.dialog.title=tsconfig.json 선택

# Documentation
js.documentation.fires=발화\:
js.documentation.more.overload=+{0} 추가 오버로드
js.documentation.more.overloads=+{0} 추가 오버로드

node.js.remote.interpreters.plugin.missing=Node.js 원격 인터프리터 플러그인이 없습니다. {0} 플러그인을 활성화하세요.

# Module Dependencies
javascript.module.dependencies.got.it.title=모듈 종속성 다이어그램
javascript.module.dependencies.got.it.text=<div align\=''left''>이 다이어그램은 선택한 파일 또는 디렉터리가 지닌 모듈 종속 요소를 시각화합니다.<br/>여러 파일 또는 디렉터리에 대한 종속 요소를 보려면 선택 영역의 컨텍스트 메뉴에서 <i>프로젝트 뷰</i><br/>및 <i>다이어그램 - 다이어그램 표시</i>를 선택하세요.</div>
javascript.module.dependencies.empty.got.it.text=<div align\=''left''>현재 파일 또는 폴더에 종속성이 없습니다.<br/>다른 파일 또는 폴더로 시도하세요.</div>
modules.selected=선택됨

js.remove.redundant.initializer.fix=불필요한 이니셜라이저 제거
js.remove.unused.assignment=사용하지 않는 할당 제거
js.inject.with.comment.intention.family.name=어노테이션으로 어노테이션 삽입
js.inject.dont.format.intention.text=삽입된 콘텐츠의 서식을 지정하지 마세요

js.webpack.config.highlighting.name=webpack 설정 유효성 검사

js.linter.guesser.linter.enabled.because.of.dependency={0}이(가) 활성화되어 있습니다. ''{1}''이(가) package.json에 포함되어 있습니다.
js.linter.guesser.linter.enabled.because.of.package.json.section={0}이(가) 활성화되어 있습니다. ''{1}''이(가) package.json에 포함되어 있습니다.
js.linter.guesser.linter.enabled.because.of.config.file={0} 활성화되어 있습니다. 설정 파일이 프로젝트에 있습니다.
js.linter.guesser.linter.disabled={0}이(가) 비활성화되어 있습니다.

# Breadcrumbs
js.breadcrumbs.callback.for={0}()에 대한 콜백 

typescript.extract.type.alias.name=타입 별칭...
typescript.include.js.sources.element=JavaScript 선언 검색
typescript.include.js.sources.dialog.title=패키지 {0} 포함
typescript.include.js.sources.dialog.message=''{0}''의 JavaScript 파일을 프로젝트에 포함하시겠어요?
start.template.string.interpolation.on.typing=''$'' 입력시 템플릿 문자열 보간 시작
typescript.include.js.sources.action=JavaScript 파일 포함
escape.pasted.text=문자열 리터럴에 붙여넣기 시 텍스트 이스케이프
jsx.convert.html.attributes.to.jsx=HTML을 JSX 파일에 붙여넣기 시 속성 변환

# Rename member
rename.prompt.do.you.want.to.rename.base.method=기본 메서드의 이름을 변경하시겠어요?
js.rename.base.member=기본 {0}의 이름 변경
js.rename.current.member=현재 {0}의 이름 변경
js.rename.member.title={3}의 {0} {1} {2}
js.rename.member.title.implements=구현
js.rename.member.title.overrides=재정의

# Generate dialog
generate.filter.indexers=인덱서
generate.filter.methods=메서드
generate.filter.fields=필드 및 프로퍼티
generate.filter.button.tooltip={0} 표시
generate.filter.button.description=목록에 {0} 표시
codestyle.ui.field.prefix=필드 접두사(&F)\:
codestyle.ui.property.prefix=프로퍼티 접두사(&P)\:
codestyle.ui.file.name.style=파일 이름 생성 규칙(&N)\:
codestyle.ui.generated.jsdoc.use.types.checkbox=JSDoc에 타입 포함(&T)
inline.type.used.in.reference.list=''{0}'' 목록에서 사용을 인라인화할 수 없습니다
inline.cannot.inline.references.this.type=''this'' 타입을 참조하는 인터페이스를 인라인화할 수 없습니다
inline.cannot.inline.has.supers=다른 타입을 확장하는 {0}을(를) 인라인화할 수 없습니다
generation.bindable.event=바인드 가능한 이벤트(&B)\:
generation.event.constant=이벤트 상수(&E)\:

refactoring.extract.react.component.component.for.refactor.this=구성 요소 추출...
refactoring.extract.react.component.title=구성 요소 추출
refactoring.extract.react.component.no.expression=선택 영역이 JSX 식을 형성하지 않습니다
refactoring.extract.react.component.no.scope=생성된 구성 요소를 배치할 범위를 찾을 수 없습니다
refactoring.create.react.component.title=구성 요소 생성
refactoring.react.function.to.class.refactoring.title=클래스 구성 요소로 변환
refactoring.react.function.to.class.intention.title=클래스 구성 요소로 변환
refactoring.react.function.to.class.used.in.new.conflict={0}이(가) ''new'' 표현식에 사용됩니다
refactoring.react.function.to.class.used.in.call.conflict={0}이(가) 호출 표현식에 사용됩니다
refactoring.react.class.to.function.conflict.used.with.ref={0}이(가) ''ref'' 속성과 함께 사용됩니다. 무상태 함수 구성 요소는 참조를 지정할 수 없습니다
refactoring.react.class.to.function.refactoring.title=함수 구성 요소로 변환
refactoring.react.class.to.function.intention.title=함수 구성 요소로 변환
refactoring.react.could.not.find.in.template=리팩터링에 실패했습니다. 이름 {0}(으)로 요소를 찾을 수 없습니다. 코드 템플릿 {1}이(가) 유효하지 않습니까?
react.function.to.class.caret.at.function=캐럿은 변환할 함수에 있어야 합니다
react.class.to.function.caret.at.class=캐럿이 변환할 클래스에 있어야 합니다
react.class.component.type.class=클래스
react.class.component.type.function=함수

js.arrangement.group.arrow.fields.with.methods=메서드를 사용하여 화살표 함수로 초기화된 필드 그룹화
intellilang.tagged.literal.injection.name.label=패턴\:
intellilang.tagged.literal.expression.border.title=템플릿 태그

refactoring.destructuring.vars.for.refactor.this=객체 또는 배열 구조 분해...
refactoring.destructuring.vars.intention.name=객체 또는 배열 구조 분해 삽입
refactoring.destructuring.vars.intention.name.object=객체 구조 분해 삽입
refactoring.destructuring.vars.intention.name.array=배열 구조 분해 삽입
refactoring.destructuring.vars.intention.replace.object=객체 구조 분해로 바꾸기
refactoring.destructuring.vars.intention.replace.array=배열 구조 분해로 바꾸기
refactoring.destructuring.vars.intention.replace.promise=''await Promise.all''로 바꾸기
refactoring.destructuring.vars.intention.propagate=구조 분해 선언에 전달
refactoring.destructuring.vars.intention.depropagate=구조 분해를 프로퍼티 및 색인 액세스로 바꾸기
refactoring.destructuring.vars.intention.deconstruct=구조 분해 패턴 생성
refactoring.destructuring.vars.intention.replace.shorthand=구조 분해 및 축약 프로퍼티로 바꾸기
refactoring.destructuring.vars.intention.const.to.var.warning=변환 중에 강조 표시된 const 변수가 변수를 허용하도록 변환됩니다.\n계속하시겠어요?
refactoring.destructuring.vars.intention.const.to.var.warning.title=변수 키워드 변경
refactoring.destructuring.vars.intention.guard.conflict=표현식 타입이 리팩터링 후 아무런 영향을 주지 않는 타입 가드에 의해 ''{0}''(으)로 좁혀졌습니다
javascript.intention.add.export.family.name=내보내기 추가
javascript.intention.add.export.fix.text=파일 {1}에서 {0} 내보내기
javascript.intention.add.default.export.family.name=디폴트 내보내기 추가
javascript.intention.remove.export.family.name=export 제거
javascript.intention.remove.export.inaccessible.conflict.text={0}이(가) {1}에서 사용됩니다
javascript.intention.promise.to.async.name=비동기 함수로 변환
javascript.intention.code.optimizations.text=생성된 코드 최적화
javascript.intention.add.template.argument=템플릿 문자열 인수 삽입
javascript.intention.call.chain.to.pipe=중첩 호출을 파이프라인 표현식으로 대체
javascript.intention.pipe.to.call.chain=파이프 표현식을 중첩 호출로 바꾸기
javascript.intention.opt.chain.family=선택적 체인 또는 null 병합 사용
javascript.intention.opt.chain.chain.only=선택적 체인 사용
javascript.intention.opt.chain.coalesce.only=null 병합 사용
javascript.intention.opt.chain.conditional.only=사용 ''||''
javascript.intention.opt.chain.chain.and.coalesce=선택적 체인 및 null 병합 사용
javascript.intention.expand.opt.chain.family=선택적 체이닝 또는 nullish 병합을 명시적 확인으로 확장
javascript.intention.expand.opt.chain=선택적 체인 확장
javascript.intention.expand.nullish.coalescing=nullish 병합 확장
javascript.intention.expand.or.coalescing=?\: 연산자 사용
javascript.intention.expand.opt.chain.and.nullish.coalescing=선택적 체이닝 및 nullish 병합 확장
javascript.intention.expand.opt.chain.and.or.coalescing=선택적 체인 확장 및 ?\: 연산자 사용
javascript.intention.explicit.fields=명시적 클래스 필드 선언
javascript.intention.explicit.fields.single=명시적 클래스 필드 선언
javascript.intention.explicit.fields.dialog.title=명시적으로 선언할 필드 선택
javascript.intention.init.fields=매개변수에서 새 필드 초기화
javascript.intention.init.fields.dialog.title=필드를 초기화할 매개변수 선택

js.param.hints.show.names.for.all.args=리터럴이 아닌 인수인 경우
js.param.hints.show.names.for.tagged=태그가 지정된 템플릿 인수인 경우
js.param.hints.show.names.for.pipes=파이프라인 연산자인 경우
js.param.hints.blacklist.pattern.explanation=<html>메서드 또는 함수에 대한 힌트를 비활성화하려면, 다음 패턴 중 하나를 사용하세요\: <p style\="margin-left\: 5px"><code><b>(*info)</b></code> - 매개변수 이름이 <em>info</em>로 끝나는 모든 단일 매개변수 메서드<br><code><b>(key, value)</b></code> - <em>key</em> 및 <em>value</em>를 매개변수로 가진 모든 메서드<br><code><b>*.put(key, value)</b></code> - <em>key</em> 및 <em>value</em> 매개변수를 가진 모든 <em>put</em> 메서드<br><code><b>Console.log(*, *)</b></code> - 정확히 두 개의 매개변수를 가진 <em>Console</em> 타입의 <em>log</em> 메서드</p><br><p>선택적 매개변수를 포함하여 모든 매개변수에 대해 이름 또는 자리표시자를 제공해야 합니다.<br>정규화된 메서드 이름에는 클래스 또는 인터페이스 이름을 포함해야 합니다.<br>"현재 메서드에 대한 힌트 표시 안함" {0} 액션을 사용하여 코드를 편집할 때 패턴을 추가할 수 있습니다.</p></html>

js.checkbox.make.readonly=readonly로 만들기(&R)

action.JavaScriptGenerateDictionaries.text=JavaScript 맞춤법 검사기 사전 생성
action.ReactClassToFunctionComponentAction.description=함수 구성 요소로 변환
action.ReactFunctionToClassComponentAction.description=클래스 구성 요소로 변환
action.ReactExtractComponentAction.description=구성 요소 추출
action.EslintImportCodeStyle.description=ESLint 코드 스타일 적용
action.TypeScriptExtractTypeAlias.description=타입 별칭 추출
action.JS.TypeScript.Include.Generated.Declarations.text=하위 ''.d.ts'' 파일 포함
action.JS.TypeScript.Include.Generated.Declarations.description=프로젝트에 하위 .d.ts 파일 포함
action.Generate.GetSetAccessor.JavaScript.text=Getter 및 Setter
action.Generate.SetAccessor.JavaScript.text=Setter
action.Generate.GetAccessor.JavaScript.text=Getter
action.Generate.Constructor.JavaScript.text=생성자
action.Generate.Missing.Members.ES6.text=메서드 구현...
action.Generate.Missing.Members.TypeScript.text=멤버 구현...
group.Editor.JSLibrariesMenu.LibraryList.text=라이브러리 사용
group.Editor.JSLibrariesMenu.LibraryList.description=사용된 JS 라이브러리 설정
group.Editor.JSLibrariesMenu.text=JavaScript 라이브러리 사용
group.Editor.JSLibrariesMenu.description=현재 파일과 함께 사용할 JavaScript 라이브러리 선택
configurable.JSTemplateLangConfigurable.display.name=템플릿
configurable.JSCodeCompletionConfigurable.display.name=JavaScript
configurable.JSSmartKeysConfigurable.display.name=JavaScript
configurable.MyConfigurable.display.name=JSX
import.options.find.more.configuration.options=다음에서 더 많은 구성 옵션 찾기
import.options.find.more.configuration.options.code.style=코드 스타일
settings.code.style.indent.chained.methods=체인 메서드 들여쓰기
settings.code.style.indent.all.chained.calls.in.a.group=그룹 내 모든 체인 호출 들여쓰기
settings.code.style.semicolon.to.terminate.statements=명령문을 종료하는 세미콜론(&S)
settings.code.style.use=사용
settings.code.style.quotes=따옴표(&Q)
settings.code.style.Trailing.comma=후행 쉼표(&T)\:
settings.code.style.single=단일
settings.code.style.double=더블
settings.code.style.in.new.code=새 코드에서
settings.code.style.always=항상
settings.code.style.option.use=사용
settings.code.style.dont.use=사용 불가
checkbox.enable=활성화
webpack.configuration.title=webpack
webpack.configuration.detect.description=모듈 확인을 위한 webpack 구성 파일 탐지
webpack.configuration.manual=수동
webpack.configuration.automatic=자동
webpack.configuration.disabled=비활성화됨
webpack.configuration.automatic.how.it.works=작동 원리
webpack.configuration.automatic.hint={0}은(는) 현재 파일과 동일한 폴더 또는 상위 폴더에 있는 webpack 구성 파일의 모듈 해결 규칙을 사용합니다.
webpack.configuration.field=구성 파일\:
webpack.configuration.field.required.error=수동 모드에서는 구성 파일 경로가 필요합니다
create.react.app.name=React
create.react.app.description=<a href\="https\://github.com/facebookincubator/create-react-app"> React 앱 생성</a> 은 공식적으로 새로 지원하는 방법으로 단일 페이지 React 애플리케이션을 만들 수 있습니다. 설정 없이 최신 빌드 설정을 제공합니다.
create.react.app.scripts.version=스크립트 버전(&V)
create.react.app.typescript.checkbox=TypeScript 프로젝트 생성(&T)
dialog.title.new.javascript.file=새 JavaScript 파일
list.item.javascript.file=JavaScript 파일
dialog.title.new.typescript.file=새 TypeScript 파일
list.item.typescript.file=TypeScript 파일
list.item.typescript.jsx.file=TypeScript JSX 파일
dialog.kind.0.file=Archivo {0}
action.creates.new.file.description=새 {0} 파일 생성
build.event.title.failed.to.list.tasks={0} 작업 나열 실패
action.show.error.details.text=오류 세부 정보 표시
dialog.title.grunt.settings=Grunt 설정
dialog.title.gulp.settings=Gulp 설정
dialog.title.error.details=오류 세부 정보
dialog.message.failed.to.download.0.1={0}을(를) 다운로드하지 못했습니다. {1}
dialog.title.download.error=다운로드 오류
label.import.popup=자동 가져오기 툴팁\:
label.namespace=네임스페이스\:
dialog.message.cannot.infer.type.new.parameter=새 매개변수 타입을 추론할 수 없습니다
dialog.title.cannot.introduce.new.interface=새 인터페이스를 삽입할 수 없음
notification.title.coloring.types.narrowed.by.type.guard.was.disabled=타입 가드로 좁혀진 타입 컬러링이 비활성화됨
notification.content.html.href.settings.show.inspection.settings.or.href.undo.undo.html=<html><a href\=''settings''>검사 설정 표시</a> or <a href\=''undo''>실행 취소</a></html>
dialog.message.cannot.propagate.variable=변수를 전달할 수 없습니다. {0}
dialog.title.cannot.propagate=전달할 수 없음
dialog.message.usages.search.was.interrupted=사용 위치 검색이 중지되었습니다
dialog.title.cannot.convert=변환할 수 없음
dialog.message.cannot.proceed.when.having.non.read.usages.in.embedded.expressions=포함된 표현식에 읽기가 아닌 사용 위치가 있는 경우 진행할 수 없습니다
dialog.message.variables.from.destructuring.pattern.have.no.usages=구조 분해 패턴 변수의 사용 위치가 없습니다
button.continue=계속
button.abort=중단
action.don.t.use.library.description=라이브러리 사용 안 함
action.already.set.for.containing.folder.or.project.description=포함하는 폴더 또는 프로젝트에 대해 이미 설정되어 있습니다.
action.use.library.description=라이브러리 사용
text.cannot.download={0}을(를) 다운로드할 수 없습니다. {1}
notification.content.show.details=세부 정보 표시
action.name.disable.category={0} 비활성화
progress.text.processing={0}{1} 처리 중
label.path=경로(&P)\:
border.title.inspection.export.results.capitalized.location=위치
border.title.inspection.description.title=설명
progress.title.install.npm.module=npm 모듈 ''{0}'' 설치
dialog.message.cannot.find.module.types=모듈 @types/{0}을(를) 찾을 수 없습니다
action.jump.to.text=다음으로 이동...
dialog.title.select.navigation.target=이동 대상 선택
dialog.title.select.targets.to.convert.to.class=클래스로 변환할 대상 선택
dialog.message.component.name=구성 요소 이름\:
label.name=이름\: 
label.type=타입\: 
label.minimum.language.level=최소 언어 수준\:
dialog.message.cannot.create.argument.stubs.invoked.method.function=인수 스텁을 생성할 수 없습니다. 호출된 메서드가 함수가 아닙니다
action.show.structure.text=구조 표시
status.text.no.errors.in.current.file=현재 파일에 오류가 없습니다. 
status.text.javascript.language.service.default.project.errors=프로젝트 오류 표시
progress.title.compiling.typescript.files=TypeScript 파일 컴파일링 중
dialog.message.cannot.find.file=파일 {0}을(를) 찾을 수 없습니다
radio.set.options.manually=수동으로 옵션 설정
radio.use.tsconfig.json=tsconfig.json 사용
separator.deprecated.settings=곧 사용할 수 없게 될 설정
dialog.title.main.file=메인 파일
label.choose.main.file=메인 파일 선택
dialog.title.output.directory=출력 디렉터리
label.choose.output.directory=출력 디렉터리 선택
dialog.message.incorrect.path.to.typescript.package=잘못된 typescript 패키지 경로
status.text.project.structure.isn.t.available=프로젝트 구조를 사용할 수 없습니다
status.text.service.doesn.t.contain.open.projects=서비스가 열려 있는 프로젝트를 포함하지 않습니다
status.text.refresh.required=새로고침 필요
dialog.message.cannot.find.module.for.import=가져올 모듈을 찾을 수 없습니다
action.js.tagged.literal.injection.text=JS 태그가 있는 리터럴 삽입
dialog.title.wsl.node.interpreter={0} WSL 노드 인터프리터
dialog.title.wsl.node.interpreter.edit=편집
dialog.title.wsl.node.interpreter.edit.add=추가
label.wsl.node.interpreter=WSL Node.js 인터프리터(&N)\:
dialog.message.please.select.distribution=배포를 선택하세요
dialog.message.please.specify.wsl.path.to.node.js.interpreter=WSL에 설치된 Node.js 인터프리터 경로를 지정하세요
status.text.running.which.node=''which node'' 실행 중...
progress.title.configuring.node.js.coding.assistance=Node.js 코딩 지원 구성 중...
action.PackageJsonNewFile.text=Archivo {0}
action.PackageJsonNewFile.description={0} 파일 생성
progress.title.install={0} 설치
progress.subtitle.install={1}을(를) 사용해 {0} 설치 중...
inspection.message.package.installed={0} 패키지가 설치되지 않았습니다
inspection.message.package.version.specified=패키지 버전이 지정되지 않았습니다
inspection.message.installed.version.doesn.t.match.version.range=설치된 버전 {0}이(가) 버전 범위 {1}와(과) 일치하지 않습니다
dialog.title.missing.dependencies=누락된 종속 요소
button.install.update=설치/업데이트
action.view.install.text=보기 및 설치...
action.don.t.ask.again.text=다시 묻지 않음
dialog.title.configure.coding.assistance.for.node.js.api=Node.js API에 대한 코딩 지원 구성
action.Anonymous.text.configure=구성
inspection.message.sm.test.runner.magnitude.assertion.failed.title=어설션 실패
text.html.front.end.template.a.href.http.html5boilerplate.com=<html>프런트엔드 템플릿 <a href\="http\://html5boilerplate.com">http\://html5boilerplate.com</a></html>
dialog.message.node.interpreter.unspecified.error.text=Node.js 인터프리터를 지정하세요
text.html.sleek.intuitive.and.powerful.front.end.framework=<html>더 빠르고 쉬운 웹 개발을 도와주는 원활하고 직관적이며 강력한 프런트엔드 프레임워크 <a href\="http\://getbootstrap.com">http\://getbootstrap.com</a></html>
popup.title.target.function=대상 함수
popup.title.select.destructuring.assignment.target=구조 분해 대입 대상 선택
visibility.level.overview=개요
visibility.level.details=세부 정보
js.module.uml.presentable.name=JavaScript 모듈 종속 요소
intention.family.name.run.npm.install=''npm install'' 실행
intention.name.run.npm=''{0}'' 실행
intention.family.name.navigate.to.package.json=package.json으로 이동
intention.name.navigate.to.0.package.json={0}/package.json으로 이동
popup.advertisement.start.typing.package.name=공식 공개 npm 레지스트리에서 더 구체적인 결과를 얻으려면 패키지 이름 입력을 시작하세요
popup.advertisement.latest.available.versions.for.all.distribution.tags=모든 배포 태그에서 사용 가능한 최신 버전
intention.family.name.select.in.test.tree=테스트 트리에서 선택
intention.family.name.introduce.parameter.properties.for.unused.parameters=사용되지 않은 매개변수에 매개변수-프로퍼티 삽입
dialog.title.select.parameters.to.convert.to.parameter.properties=매개변수-프로퍼티로 변환할 매개변수 선택
intention.family.name.add.required.property=필수 프로퍼티 추가
intention.name.create.library.with.files.outside.project=프로젝트 외부의 파일을 포함하는 라이브러리 생성
dialog.message.unspecified.suite.name=지정되지 않은 도구 이름
dialog.message.unspecified.test.name=지정되지 않은 테스트 이름
dialog.message.unspecified=지정되지 않은 {0}
dialog.message.no.such=해당 {0} 없음
dialog.message.please.specify.package.json=package.json을 지정하세요
dialog.message.please.specify.package.json.correctly=package.json을 올바르게 지정하세요
dialog.message.please.specify.npm.scripts.to.run=실행할 npm 스크립트를 지정하세요
dialog.message.command.supported.by={1}이(가) 명령어 ''{0}''을(를) 지원하지 않습니다
dialog.message.no.npm.script=''{0}'' npm 스크립트 없음
titled.separator.predefined=사전 정의
label.compiles.js.files=.js 파일 컴파일
label.compress.js.files=.js 파일 압축
dialog.title.edit.run.debug.configuration=실행/디버그 구성 편집\: ''{0}''
js.commandline.configure.language.version=프로젝트의 JavaScript 언어 버전 구성
js.commandline.configure.nodejs=NodeJS 인터프리터를 구성하고 package.json 파일용 패키지를 설치합니다.

# Language features
js.language.feature.xml.tags=XML 태그
js.language.feature.for.each.statements=For each 문
js.language.feature.for.of.loops=for..of 루프
js.language.feature.let.definitions=let 정의
js.language.feature.const.definitions=상수 정의
js.language.feature.generators=제너레이터
js.language.feature.destructuring.assignments=대입 구조 분해
js.language.feature.let.statements=let 문
js.language.feature.array.comprehensions=배열 내포
js.language.feature.top.level.yield.expressions=최상위 yield 표현식
js.language.feature.reference.namespace=참조 네임스페이스
js.language.feature.default.parameter.values=디폴트 매개변숫값
js.language.feature.pipe.expressions=파이프 표현식
js.language.feature.decorator.declarations=데코레이터 선언
js.language.feature.throw.expressions=throw 표현식
js.language.feature.ecmascript.syntax.for.private.members=private 멤버에 대한 ECMAScript \#-구문
js.language.feature.class.member.visibility.modifiers=클래스 멤버 가시성 제어자
js.language.feature.optional.chaining.operator=optional 체인 연산자
js.language.feature.arbitrary.precision.integers=임의의 정밀도 정수
js.language.feature.trailing.commas.in.function.parameter.lists.and.calls=함수 매개변수 목록 및 호출 내 후행 쉼표
js.language.feature.unicode.escapes.with.braces=괄호가 있는 유니코드 이스케이프
js.language.feature.bind.expressions=바인드 표현식
js.language.feature.optional.catch.bindings=선택적 catch 바인딩
js.language.feature.string.templates=문자열 템플릿
js.language.feature.method.definition.shorthands=메서드 정의 축약
js.language.feature.computed.property.names=계산된 프로퍼티 이름
js.language.feature.shorthand.property.names=축약형 프로퍼티 이름
js.language.feature.binary.0b.and.new.octal.0o.literals=2진(0b) 및 새로운 8진(0o) 리터럴
js.language.feature.async.await=async/await
js.language.feature.types=타입
js.language.feature.annotations=어노테이션
js.language.feature.interfaces=인터페이스
js.language.feature.classes=클래스
js.language.feature.es6.export.declarations=ES6 export 선언
js.language.feature.es6.import.declarations=ES6 import 선언
js.language.feature.generics=제네릭
js.language.feature.rest.parameters=Rest 매개변수
js.language.feature.arrow.functions=화살표 함수
js.language.feature.getters.and.setters=getter 및 setter
js.language.feature.generator.expressions=제너레이터 표현식
js.language.feature.expression.closures=표현식 클로저
js.language.feature.destructuring.parameters=매개변수 구조 분해

# Webpack
webpack.failed.to.load={0}을(를) 로드하지 못했습니다
webpack.analyzing.configs.progress=webpack 구성 분석 중
webpack.cannot.analyze={0}을(를) 분석할 수 없습니다. 코딩 지원이 이 파일의 모듈 해결 규칙을 무시합니다.\n가능한 이유\: 이 파일이 올바른 webpack 구성 파일이 아니거나 해당 형식이 현재 IDE에서 지원되지 않습니다.
file.name.masks.to.skip.from.analysis=분석에서 건너뛸 파일 이름 마스크\:
webpack.trusted.project.title=webpack 구성을 실행하시겠어요?
webpack.trusted.project.message=webpack 구성을 실행하면 코딩 지원이 향상되지만 잠재적 악성 코드가 실행될 수 있습니다. 소스를 신뢰할 수 없는 경우 실행을 건너뛰세요.
webpack.trusted.project.message.allow=프로젝트 신뢰 및 실행
webpack.trusted.project.message.skip=건너뛰기

# Node
node.core.enable_coding_assistance_intention.name=Node.js에 대한 코딩 지원 활성화
node.interpreter.unresolved_reference.error.message=해결되지 않은 인터프리터 ''{0}''
node.interpreter.invalid_interpreter.error.message=잘못된 ''{0}''
node.interpreter.no_local_interpreter.error.message=로컬 Node.js 인터프리터가 없습니다
node.debug.cannot_connect_to_vm.error.message=VM {0}에 연결할 수 없습니다
node.debug.cannot_get_localhost_IPv4.error.message=127.0.0.1 IPv4를 받을 수 없습니다
node.core.make.sure.javascript.debugger.plugin.enabled.dialog.message=''JavaScript Debugger'' 플러그인이 활성화되었는지 확인하세요
node.core.failed_to_fetch_node_core_modules.dialog.message=노드 코어 모듈을 가져오지 못했습니다
node.core.core_modules_fetch_timed_out.dialog.message=시간이 초과되어 코어 모듈을 가져올 수 없습니다
node.core.not_ready_for_core_modules_configuration.dialog.message=코어 모듈 구성 준비가 되지 않았습니다
node.core.navigate_action_text.text=Node.js 및 NPM 구성...
node.core.failed_to_install.title.message={0} 설치 실패
node.interpreter.field.add.item.text=추가...
node.interpreter.field.unexpected_value.text=예기치 않은 값 {0}
node.interpreter.unspecified_interpreter.dialog.message=Node.js 인터프리터 지정
node.interpreter.unspecified_local_interpreter.dialog.message=로컬 Node.js 인터프리터를 지정하세요
node.interpreter.specified_interpreter_correctly.dialog.message=Node.js 인터프리터를 올바르게 지정하세요
configure.node.interpreter.path=Node.js 경로 구성...
node.interpreter.reference_not_found.text=찾을 수 없음
node.interpreter.command_timed_out.dialog.message=''{0}'' 명령어 실행이 시간 초과되었습니다(>{1}밀리초)
node.package_documentation.installed_version.text=설치된 버전\: {0}
node.package_documentation.latest_version.text=최신 버전\: {0}
node.packages.cannot_find_working_directory.text={0}의 작업 디렉터리를 파악할 수 없습니다. {1}
node.package.field.not_found.text=찾을 수 없음
node.npm.cannot_find_package_by_reference.dialog.message=패키지 관리자 ''{0}''을(를) 찾을 수 없습니다
node.npm.specify_npm_or_yarn_package.dialog.message=npm 또는 yarn 패키지를 지정하세요
node.npm.correct_path_to_npm_or_yarn_package.dialog.message=npm 또는 yarn 패키지의 올바른 경로를 지정하세요. "{0}" 디렉터리가 없습니다
node.npm.invalid_package_manager.binary_file_not_found.dialog.message=올바른 패키지 관리자를 지정하세요. ''{0}'' 디렉터리에서 바이너리 파일을 찾을 수 없습니다
node.npm.project_package_manager_disallowed_here.dialog.message=프로젝트 npm 패키지는 여기에서 참조할 수 없습니다
node.npm.unspecified_package_manager.dialog.message=패키지 관리자가 지정되지 않았습니다
node.npm.cannot_resolve_package_manager.dialog.message=''{0}'' 패키지 관리자를 해결할 수 없습니다
node.npm.no_bundled_npm_detected.dialog.message={0}에 대해 번들로 포함된 npm을 탐지할 수 없습니다
package_json.install_dependencies.notification.title=종속성 설치
package_json.install_dependencies_multiple.notification.content={0} 및 그 외 {1}개에서
package_json.install_dependencies.notification.content={0}에서
package_json.update_dependencies.notification.title=종속성 업데이트
package_json.update_dependencies.notification.content={0}에서
package_json.notifications_are_disabled.notification.content={0}의 종속성 설치에 대한 알림이 비활성화되었습니다.<p>"{1}" 액션을 사용하여 다시 활성화하세요.
node.wsl.unavailable.dialog.message=WSL을 사용할 수 없습니다
node.wsl.unavailable_distribution.dialog.message=WSL {0}을(를) 사용할 수 없습니다
node.npm.cannot_find_project_package_manager.dialog.message=프로젝트 Node.js 패키지 관리자를 찾을 수 없습니다
node.npm.package_manager_link.text=패키지 관리자
yarn.package_requires_yarn.dialog.message=패키지 "{0}"에 Yarn {1}이(가) 필요합니다.

# Jest
jest.package.placeholder.text=jest 경로, react-scripts(또는 그 대체 항목) 패키지 디렉터리
jest.coverage.cannot.create.temporary.directory.dialog.message=임시 디렉터리를 생성할 수 없습니다
jest.snapshot.label=Jest 스냅샷
jest.go.to.snapshot.text=''{0}'' 스냅샷으로 이동
jest.cannot.find.bin.file.for.package.dialog.message=''{0}'' 패키지의 bin 파일을 찾을 수 없습니다

# Protractor
dialog.message.cannot.locate.wrapper.config.file=래퍼 구성 파일을 찾을 수 없습니다

# Style guides
list.item.google.javascript.style.guide=Google JavaScript 스타일 가이드
list.item.javascript.standard.style=JavaScript 표준 스타일

# Inlay hints
method.return.types.in.call.chains=호출 체인 내 메서드 반환 타입
type.annotations=타입 어노테이션
parameters.in.parentheses=소괄호로 묶인 매개변수
non.parenthesized.single.parameter=소괄호로 묶이지 않은 단일 매개변수
function.returns=함수 반환
variables.and.fields=변수 및 필드
command.name.add.explicit.value=명시적 값 ''{0}'' 추가
numeric.enum.values=숫자 열거형 값 추가

# Libraries
progress.title.downloading.library=라이브러리 다운로드 중
progress.title.downloading.documentation=문서 다운로드 중
successfully.downloaded=성공적으로 다운로드되었습니다
failed.to.download=다운로드하지 못했습니다
progress.title.downloading.typings=typings 다운로드 중
notify.urls.more=... 및 그 외 {0,number}개

# Structural Search
structural.search.anonymous.functions=익명 함수
structural.search.functions=함수
structural.search.variables=변수
structural.search.function.calls=함수 호출
structural.search.while.loops=While 루프
structural.search.constants=상수
structural.search.classes=클래스
structural.search.empty.functions=빈 함수
structural.search.console.log.calls=console.log() 호출
structural.search.with.statements=With 문
structural.search.var.statements=Var 문
structural.search.functions.with.boolean.parameters=부울 매개변수가 있는 함수
structural.search.comparison.to.self=자신과 비교

# Project Generators
copying.files=파일 복사 중
project.generation=프로젝트 생성
notification.title.cannot.generate={0}을(를) 생성할 수 없습니다
dialog.message.cannot.find.npx.bundled.with={0}에 번들로 포함된 npx를 찾을 수 없습니다
generating.0={0} 생성 중

# Find Usages
js.show.dynamic.usages=동적 사용 위치 표시

# Test Runners
action.JasmineGenerateNewSuiteAction.text=Jasmine Suite
action.JasmineGenerateNewSpecAction.text=Jasmine Spec
action.JasmineGenerateBeforeEachMethodAction.text=Jasmine beforeEach
action.JasmineGenerateAfterEachMethodAction.text=Jasmine afterEach
action.QUnitGenerateNewTestAction.text=QUnit Test
action.QUnitGenerateSetupAction.text=QUnit Setup
action.QUnitGenerateTearDownAction.text=QUnit TearDown

# Diagrams
diagram.element.not.found={0}(찾을 수 없음)

# Other
command.name.create.javascript.file=JavaScript 파일 {0} 생성
command.name.create.typescript.file=TypeScript 파일 {0} 생성
checkbox.move.simple.expressions.to.field.initializer=단순 표현식을 필드 이니셜라이저로 이동
popup.title.choose.class=클래스 선택
multiple.inheritance=다중 상속
label.method.should.be.defined=메서드가 정의되어야 합니다
recursive.call=재귀 호출
command.name.extract.named.type=이름 지정된 타입 추출
inspection.message.reference.includes.files.outside.project=프로젝트 외부에 있는 파일이 참조에 있습니다
progress.title.executing.performance.task.on.files=파일에서 성능 작업 실행 중
terminal.add_node_modules_bin_to_path.label=프로젝트 루트를 ''node_modules/.bin''을 {0}에 추가
label.name.injection=이름(&N)\:
reg.exp.tagged.template=''{1}'' 태그 지정된 템플릿 내 {0}
unwrap.with.kind=''{0}...'' 래핑 해제
header.declarations.to.be.refactored=리팩터링할 선언


