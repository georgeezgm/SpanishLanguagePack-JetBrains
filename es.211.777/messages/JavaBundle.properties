abstract.class.not.allowed=추상 클래스는 허용되지 않습니다
access.static.via.instance=인스턴스 참조를 통해 정적 멤버 액세스
action.AnActionButton.text.select.annotation.used.for.code.generation=코드 생성에 사용되는 어노테이션 선택
action.analyzing.cyclic.dependencies.in.scope={0}의 순환적 종속성
action.create.new.class=새 Java 클래스
action.create.new.class.description=새 Java 클래스를 생성합니다
action.create.new.module-info.description=새로운 module-info.java 생성
action.create.new.module-info.title=module-info.java
action.create.new.package-info.description=새로운 package-info.java 생성
action.create.new.package-info.title=package-info.java
action.cyclic.dependency.title=순환 종속성 분석
action.description.copy.whole.thread.dump.to.clipboard=전체 스레드 덤프를 클립보드에 복사
action.description.group.by.scope=Group by Scope Type (production,test,libraries)
action.description.group.threads.with.identical.stacktraces=동일한 스택 추적의 스레드 그룹화
action.description.mark.directory.as.a.0.for.generated.files=생성된 파일의 디렉터리를 {0}(으)로 표시
action.description.mark.directory.as.an.ordinary.0=디렉터리를 일반 {0}(으)로 표시
action.description.show.only.threads.containing.a.specific.string=특정 문자열을 포함하는 스레드만 표시
action.group.by.package=패키지
action.group.by.scope.type=범위 타입별로 그룹화
action.implement.method=메서드 구현
action.implement.methods=메서드 구현
action.override.method=메서드 재정의
action.override.methods=메서드 재정의
action.text.0.on.parameter.1=매개변수 ''{1}''의 {0}
action.text.choose.class.in.0={0}에서 클래스 선택...
action.text.copy.to.clipboard=클립보드에 복사
action.text.edit.template=템플릿 편집
action.text.enter.class.name=클래스 이름 입력...
action.text.generated.root.0=생성된 {0}
action.text.merge.identical.stacktraces=동일한 스택 추적 병합
action.text.show.methods.to.implement=구현할 메서드 표시
action.text.show.quick.list=빠른 목록 표시
action.text.unmark.generated.0=생성된 {0} 표시 해제
action.GotoSuperClass.text=상위 클래스로 이동(_U)
action.GotoSuperClass.MainMenu.text=상위 클래스(_U)
action.GotoSuperClass.description=현재 클래스가 확장하거나 구현하는 클래스의 선언으로 이동합니다
add.to.permits.list=''{0}''을(를) 봉인된 클래스 ''{1}''의 permits 목록에 추가
annotate.intention.chooser.title=추가할 어노테이션 선택
assignment.to.declared.variable.problem.descriptor=''{0}'' 변수는 자체 할당을 통해 초기화됩니다
assignment.to.itself.problem.descriptor=''{0}'' 변수는 자체 할당됩니다
assignment.to.itself.quickfix.name=자체 할당 제거
bean.property=Bean 프로퍼티
boolean.method.is.always.inverted.display.name=부울 메서드는 항상 반전됩니다
boolean.method.is.always.inverted.problem.descriptor=부울 메서드 <code>\#ref</code>이(가) 항상 반전됩니다.
button.add.blank=공백 추가
button.add.class=클래스 추가하기...
button.add=추가...
button.add.package=패키지 추가...
button.add.pattern=패턴 추가하기...
button.annotations=어노테이션...
button.base.method=기본 메서드(&B)
button.code.patterns=코드 패턴...
button.current.method=현재 메서드(&C)
button.text.settings=Ajustes...
cast.expression=표현식 변환
cast.to.0=''{0}''(으)로 형 변환
change.color.command.text=색상 변경
change.uid.action.name=''serialVersionUID'' 이니셜라이저 임의 변경
checkbox.after.description=설명 뒤
checkbox.after.parameter.descriptions=매개변수 설명 뒤
checkbox.after.return.tag=반환 태그 뒤
checkbox.align.parameter.descriptions=매개변수 설명 정렬
checkbox.align.thrown.exception.descriptions=던져진 예외 설명 정렬
checkbox.annotate.local.variables=지역 변수에 어노테이션 추가
checkbox.collapse.annotations=<html>어노테이션</html>
checkbox.collapse.anonymous.classes=<html>Anonymous classes</html>
checkbox.collapse.closures=<html>"Closures" (anonymous classes implementing one method,before Java 8)</html>
checkbox.collapse.end.of.line.comments=<html>End of line comments sequence</html>
checkbox.collapse.generic.constructor.parameters=제네릭 생성자 및 메서드 매개변수
checkbox.collapse.i18n.messages=<html>I18n strings</html>
checkbox.collapse.inferred.type=''var''을 유추된 타입으로 바꾸기
checkbox.collapse.inner.classes=내부 클래스
checkbox.collapse.multiline.comments=여러 줄 주석
checkbox.collapse.one.line.methods=<html>One-line methods<html>
checkbox.collapse.simple.property.accessors=<html>Simple property accessors<html>
checkbox.collapse.suppress.warnings=<html>@SuppressWarnings</html>
checkbox.comments.and.javadoc.count.as.content=주석 및 javadoc은 콘텐츠로 계산됩니다
checkbox.deprecated.members=곧 사용할 수 없게 될 멤버
checkbox.do.not.indent.top.level.class.members=최상위 클래스 멤버는 들여쓰기 안 함
checkbox.do.not.wrap.after.single.annotation=단일 어노테이션 뒤에서 줄 바꿈하지 마세요
checkbox.do.not.wrap.one.line.comments=한 줄 주석은 줄 바꿈 안 함
checkbox.enable.javadoc.formatting=JavaDoc 서식 지정 사용
checkbox.enable.leading.asterisks=선행 별표 사용
checkbox.generate.p.on.empty.lines=빈 줄에 "<p>" 생성
checkbox.html.report.inaccessible.symbols=<html>액세스할 수 없는 심볼 보고<br>(javadoc 도구로 하이퍼링크 생성이 불가할 수 있음)
disable.report.inaccessible.symbols.fix=액세스할 수 없는 심볼 보고 안 함
checkbox.ignore.fields.used.in.multiple.methods=여러 메서드에 사용되는 필드 무시
checkbox.ignore.simple.setters=간단한 setter 무시
checkbox.insert.imports.for.inner.classes=내부 클래스에 대한 import 문 삽입
checkbox.iterate.unknown.stream.sources.via.stream.iterator=Stream.iterator()를 통해 알 수 없는 Stream 소스 반복
checkbox.keep.empty.lines=빈 줄 유지
checkbox.keep.empty.param.tags=빈 @param 태그 유지
checkbox.keep.empty.return.tags=빈 @return 태그 유지
checkbox.keep.empty.throws.tags=빈 @throws 태그 유지
checkbox.keep.invalid.tags=잘못된 태그 유지
checkbox.make.generated.local.variables.final=생성된 지역 변수를 final로 만들기
checkbox.make.generated.parameters.final=생성된 매개변수를 final로 만들기
checkbox.param.description.on.new.line=새 줄의 매개변수 설명
checkbox.param.indent.on.continuation=연속 줄 들여쓰기
checkbox.prefer.longer.names=더 긴 이름 선호
checkbox.preserve.line.feeds=줄 피드 보존
checkbox.spaces.record.header=기록 헤더
checkbox.spaces.before.colon.in.foreach=Space before colon in foreach
checkbox.spaces.inside.one.line.enum=한 줄 열거형 중괄호 내
checkbox.suggest.conversion.to.map.computeifabsent=Map.computeIfAbsent로 변환 제안
checkbox.suggest.conversion.to.map.getordefault=Map.getOrDefault로 변환 제안
checkbox.suggest.conversion.to.map.merge=Map.merge로 변환 제안
checkbox.suggest.conversion.to.map.putifabsent=Map.putIfAbsent로 변환 제안
checkbox.suggest.conversion.to.map.replaceall=Map.replaceAll로 변환 제안
checkbox.suggest.replacement.even.if.lambda.may.have.side.effects=람다에 부작용이 있더라도 바꾸기 제안
checkbox.suppress.with.suppresswarnings=@SuppressWarnings를 사용해 억제
checkbox.treat.get.k.null.the.same.as.containskey.k.may.change.semantics=''get(k) \!\= null''을 '' ''containsKey(k)''와 동일하게 처리(의미가 변경될 수 있음).
checkbox.use.fully.qualified.class.names=정규화된 클래스 이름 사용
checkbox.use.single.class.import=단일 클래스 import 문 사용
checkbox.use.throws.rather.than.exception=@exception 대신 @throws 사용
checkbox.warn.if.only.foreach.replacement.is.available=''forEach'' 바꾸기만 사용 가능한 경우 경고
checkbox.warn.if.the.loop.is.trivial=루프가 자명한 경우 경고
checkbox.wrap.at.right.margin=오른쪽 여백에서 줄 바꿈
choose.class=클래스 선택
chooser.text.choose.where.to.save.0=''{0}''의 저장 위치 선택
chooser.title.select.path.to.save.jar=Jar 저장 경로 선택
class.decorator.or.has.default.constructor=''{0}''에 디폴트 생성자가 있거나 ''Decorator'' 패턴이 구현되어야 합니다
class.filter.editor.add.dialog.title=새로운 필터 추가
class.filter.editor.choose.class.title=클래스 선택
class.has.no.default.constructor=''{0}''에 디폴트 생성자가 없습니다
class.is.not.a.subclass=''{0}''을(를) ''{1}''에 대입할 수 없습니다
class.is.not.concrete=''{0}''은(는) 구체 클래스가 아닙니다
class.is.not.public=''{0}''은(는) public이 아닙니다
class.not.found.error.message=클래스 ''{0}''을(를) 찾을 수 없습니다
code.style.generation.override.method.signature=메서드 시그니처 재정의
code.style.generation.repeat.synchronized.modifier=동기화된 제어자 반복(&S)
code.style.generation.replace.null.check=null 검사를 Objects\:\:nonNull 또는 Objects\:\:isNull로 바꾸기
code.style.generation.use.class.isInstance=가능할 경우 Class\:\:isInstance 및 Class\:\:cast 사용 
code.style.generation.use.integer.sum=가능한 경우 Integer\:\:sum 등 사용
combobox.paste.insert.imports=붙여넣기 시 import 문 삽입(&I)\:
command.create.class.from.template=템플릿에서 클래스 생성
command.create.new.subdirectory=새 하위 디렉터리 생성
command.name.insert.block.statement=블록문 삽입
command.name.updating.package.statement=package 문 업데이트 중
comment.the.class.will.be.created.in.the.package.0=클래스가 ''{0}'' 패키지에 생성됩니다
completion.class.name.hint.2=검색 중 모듈 종속 요소를 무시하려면 {0}}을(를) 한 번 더 누릅니다
completion.no.suggestions.of.type=타입 {0} 제안 없음
completion.smart.aslist.hint={1} 배열을 검색하려면 {0}}을(를) 한 번 더 누릅니다
completion.smart.chain.hint=체인 메서드 호출에서 검색하려면 {0}}을(를) 한 번 더 누릅니다
completion.smart.hint=타입별로 적합한 변형만 표시하려면 0}}을(를) 누릅니다
completion.smart.toar.hint={1} 컬렉션을 검색하려면 {0}}을(를) 한 번 더 누릅니다
completion.smart.type.generate.anonymous.body=익명의 본문 생성
completion.unknown.type=알 수 없는 타입 {0}
configurable.EqualsHashCodeTemplatesPanel.display.name=템플릿
configurable.GenerateToStringConfigurable.display.name=설정
configurable.TemplatesPanel.display.name=템플릿
label.new.template.name=새 템플릿 이름\:
dialog.title.create.new.template=새 템플릿 생성
dialog.title.copy.template=템플릿 복사
configure.annotations.option=Configure annotations
convert.compareto.expression.to.equals.call=''compareTo()'' 식을 ''equals()'' 호출로 변환
convert.compareto.expression.to.equals.call.may.change.semantics=''compareTo()'' 식을 ''equals()'' 호출로 변환(의미가 변경될 수 있음)
copy.abstract.method.intention.name=''{0}''의 기존 구현 사용
copy.abstract.method.no.existing.implementations.found=기존 구현을 찾을 수 없습니다
copy.abstract.method.popup.title=복사할 구현 선택
copy.abstract.method.title=추상 메서드 구현 사용
copy.paste.reference.notification=<html>{0} {0, choice, 1\#가져오기가 |2\#가져오기가} 추가되었습니다.<p><span><a href\=''show''>추가된 가져오기 검토...</a></span></html>
cyclic.dependencies.progress.text=종속성 그래프 빌드 중
cyclic.dependencies.scope.dialog.module.button=모듈 ''{1}'' {0}(&M)
cyclic.dependencies.scope.dialog.project.button=전체 프로젝트 {0}(&P)
cyclic.dependencies.scope.dialog.title={0} 범위 지정
cyclic.dependencies.scope.include.test.sources.option=테스트 소스 포함(&T)
cyclic.dependencies.tree.cycle.node.text=순환
cyclic.dependencies.usage.view.initial.text=왼쪽 트리에서 분석할 패키지 선택
cyclic.dependencies.usage.view.root.node.text=패키지 ''{1}''에 있는 패키지 ''{0}''의 사용
dataflow.from.here=여기에서 유입되는 데이터 흐름
dataflow.to.here=여기로 유입되는 데이터 흐름
deannotate.intention.action.text={0}의 어노테이션 삭제
deannotate.intention.action.several.text=어노테이션 삭제...
deannotate.intention.action.family.name=어노테이션 삭제
deannotate.intention.chooser.title=삭제할 어노테이션 선택
default.file.template.description=디폴트 파일 템플릿
default.file.template.display.name=디폴트 파일 템플릿 사용
default.file.template.edit.template=템플릿 편집...
default.file.template.replace.with.actual.file.template=실제 파일 템플릿으로 바꾸기
default.package.presentable.name=<디폴트>
dependencies.libraries.node.text=라이브러리
dependencies.tree.node.default.package.abbreviation=<디폴트 패키지>
dialog.create.class.destination.package.label=대상 패키지\:
dialog.create.class.label={0} 생성\:
dialog.create.class.name={0} {1} 생성
dialog.create.class.package.chooser.title=대상 패키지 선택
dialog.create.field.from.parameter.already.exists.text=기존 필드 ''{0}''을(를) 사용하시겠어요?
dialog.create.field.from.parameter.already.exists.use.existing.button=기존 필드 사용
dialog.create.field.from.parameter.already.exists.title=필드가 이미 존재합니다
dialog.create.field.from.parameter.declare.final.checkbox=final 선언(&F)
dialog.create.field.from.parameter.field.name.label=이름\:
dialog.create.field.from.parameter.field.type.label=타입 필드\:
dialog.create.field.from.parameter.title=필드 생성
dialog.edit.template.checkbox.smart.type.completion=타입 일치 코드 완성(&O)
dialog.edit.template.checkbox.use.static.import=가능한 경우 정적 import 문 사용(&I)
dialog.import.on.paste.title=가져올 클래스 선택
dialog.import.on.paste.title2=가져올 요소 선택
dialog.import.on.paste.title3=제거할 import 문 선택
dialog.message.0.update.existing.class={0}. 기존 클래스를 업데이트하시겠어요?
dialog.message.create.test.in.the.same.source.root=동일한 소스 루트에서 테스트를 생성하시겠어요?
dialog.message.infer.nullity.annotations.requires.the.project.language.level=Infer Nullity 어노테이션을 사용하려면 1.5 이상의 프로젝트 언어 수준이 필요합니다.
dialog.message.jetbrains.annotations.library.is.missing=JetBrains 어노테이션 라이브러리가 없습니다.\n라이브러리가 없으면 IntelliJ IDEA에서 분석을 실행할 수 없습니다. 추가하시겠어요?
dialog.message.no.places.found.to.infer.nullable.notnull=@Nullable/@NotNull 을 추론할 수 있는 공간이 없습니다
dialog.paste.on.import.text=<html>붙여넣은 코드 조각은 새 컨텍스트에서 import 문이 액세스할 수 없는 클래스를 사용합니다.<br/>새 파일로 가져올 클래스를 선택하세요.</html>
dialog.paste.on.import.text2=<html>붙여넣은 코드 조각은 새 컨텍스트에서 import 문이 액세스할 수 없는 요소를 사용합니다.<br/>새 파일로 가져올 요소를 선택하세요.</html>
dialog.paste.on.import.text3=<html>붙여넣은 코드 조각은 현재 컨텍스트에서 새로운 import 문을 도입했습니다.<br/>제거할 import 문을 선택하세요.</html>
dialog.title.choose.0.parameters={0} 매개변수 선택
dialog.title.choose.class=클래스 선택
dialog.title.configure.annotations=Configure annotations
dialog.title.configure.code.patterns=코드 패턴 구성
dialog.title.create.class.in.package=패키지에서 클래스 생성
dialog.title.create.missed.tests=누락된 테스트 생성
dialog.title.edit.method.contract=메서드 컨트랙트 편집
dialog.title.edit.range=범위 편집
dialog.title.infer.nullity=Infer Nullity
action.description.infer.nullity.annotations=nullability 어노테이션 추론
dialog.title.infer.nullity.results=Infer Nullity 결과
dialog.title.no.test.roots.found=테스트 루트를 찾을 수 없음
dialog.title.process.duplicates=프로세스 중복
dialog.title.super.method.found=상위 메서드 발견
do.not.import.inner.classes.for=내부 클래스를 짧은 이름으로 제외\:
do.not.import.inner.classes.no.classes=정의된 내부 클래스가 없습니다
editbox.blanklines.around.initializer=이니셜라이저 주위\:
editbox.class.count.to.use.import.with.star=''*''가 포함된 import 문을 사용하는 클래스 수\:
editbox.names.count.to.use.static.import.with.star=''*''가 포함된 정적 import 문을 사용하는 이름 수\:
enum.not.allowed=열거형은 허용되지 않습니다
error.attempt.to.generate.constructor.for.anonymous.class=익명 클래스에 생성자를 추가할 수 없습니다
error.hint.no.expression.found=표현식을 찾을 수 없습니다
error.package.already.contains.package-info=패키지 ''{0}''에 ''package-info.java''가 이미 있습니다
error.package.already.contains.package.html=패키지 ''{0}''에 ''package.html'' 파일이 이미 있습니다. 그래도 ''package-info.java''를 생성하시겠어요?
error.package.html.found.title=''package.html'' 발견
error.text.this.is.not.a.valid.java.class.name=올바른 Java 클래스 이름이 아닙니다
exclude.0.from.completion=코드 완성에서 ''{0}'' 제외
exclude.accessors=접근자 제외(&E)
exclude.from.completion.group=자동 가져오기 및 코드 완성에서 제외\:
exclude.from.imports.no.exclusions=클래스, 패키지, 멤버 추가
exclude.from.imports.no.exclusions.2=가져오기 및 코드 완성에서 제외
exclude.table.mask=클래스, 패키지 또는 멤버
exclude.table.scope.column=범위
export.to.html.generate.hyperlinks.checkbox=클래스에 대한 하이퍼링크 생성(&H)
external.annotation.prompt=외부 어노테이션 표시
external.annotations.external.option=외부적으로 추가(&E)
external.annotations.in.code.option=코드에 추가(&C)
external.annotations.root.chooser.description=외부 어노테이션이 적절한 폴더에 저장됩니다
external.annotations.root.chooser.title=Select external annotations root for {0}
external.annotations.suggestion.message=<html><body>코드에 어노테이션을 추가하지 않으려면 외부 저장소를 사용할 수 있습니다.<br> 외부 어노테이션을 구성하려면 어노테이션이 추가된 파일을 배치할 루트 디렉터리를 지정하세요.</body></html>
find.field.accessors.prompt=필드 ''{0}''의 접근자를 검색하시겠어요?
find.field.accessors.title=필드 접근자 발견
find.options.include.overloaded.methods.checkbox=오버로드된 메서드 포함(&V)
find.parameter.usages.in.overriding.methods.prompt=메서드를 재정의할 때 매개변수 ''{0}''의 사용 위치를 검색하시겠어요?
find.parameter.usages.in.overriding.methods.title=재정의 메서드 내에서 검색
find.what.derived.classes.checkbox=파생 클래스(&D)
find.what.derived.interfaces.checkbox=파생 인터페이스(&D)
find.what.fields.usages.checkbox=필드의 사용 위치(&F)
find.what.group=찾기
find.what.implementing.classes.checkbox=클래스 구현(&I)
find.what.implementing.methods.checkbox=메서드 구현(&I)
find.what.implicit.to.string.checkbox=묵시적 호출(&M)
find.what.methods.usages.checkbox=메서드 사용 위치(&M)
find.what.overriding.methods.checkbox=메서드 재정의(&R)
find.what.usages.checkbox=사용 위치(&U)
find.what.usages.of.classes.and.interfaces=클래스 및 인터페이스의 사용 위치(&C)
generate.button.title=\ 생성
generate.constructor.fields.chooser.title=생성자별로 초기화할 필드 선택
generate.constructor.super.constructor.chooser.title=상위 클래스 생성자 선택
generate.delegate.target.chooser.title=위임자를 생성할 대상 선택
generate.equals.and.hashcode.already.defined.title=equals() 및 hashCode() 생성
generate.equals.and.hashcode.already.defined.warning=메서드 ''boolean equals(Object)'' 및 ''int hashCode()''가 클래스 {0}에 대해\n이미 정의되어 있습니다. 기존 메서드를 삭제하고 계속 진행하시겠어요?
generate.equals.and.hashcode.already.defined.warning.anonymous=메서드 ''boolean equals(Object)'' 및 ''int hashCode()''가 이 익명의 클래스에 대해\n이미 정의되어 있습니다. 기존 메서드를 삭제하고 계속 진행하시겠어요?
generate.equals.hashcode.accept.sublcasses=equals() 메서드의 매개변수로서 하위 클래스 허용(&S)
generate.equals.hashcode.accept.sublcasses.explanation=<html><body>While generally incompliant to Object.equals() specification accepting<br>subclasses might be necessary for generated method to work correctly<br>with frameworks,which generate Proxy subclasses like Hibernate.</body></html>
generate.equals.hashcode.equals.fields.chooser.title=equals()에 포함할 필드 선택(&F)
generate.equals.hashcode.hashcode.fields.chooser.title=hashCode()에 포함할 필드 선택(&F)
generate.equals.hashcode.internal.error=내부 오류
generate.equals.hashcode.non.null.fields.chooser.title=null이 아닌 모든 필드 선택(&F)
generate.equals.hashcode.template=템플릿(&T)\:
generate.equals.hashcode.use.getters=코드 생성 중 getter 사용(&G)
generate.equals.hashcode.warning.hashcode.for.arrays.is.not.supported=중첩된 배열에 대한 hashCode ()는 지원되지 않습니다
generate.equals.hashcode.wizard.title=equals() 및 hashCode() 생성
generate.equals.template.title=Equals 템플릿\:
generate.equals.warning.equals.for.nested.arrays.not.supported=중첩된 배열에 대한 equals()는 지원되지 않습니다
generate.equals.warning.generated.equals.could.be.incorrect=Object[]에 대해 생성된 equals()가 올바르지 않을 수 있습니다
generate.getter.fields.chooser.title=getter를 생성할 필드 선택
generate.getter.setter.title=getter 및 setter를 생성할 필드 선택
generate.getter.template=Getter 템플릿(&G)\:
generate.hashcode.template.title=HashCode 템플릿\:
generate.record.constructor.title=기록 생성자 생성
generate.setter.fields.chooser.title=setter를 생성할 필드 선택
generate.setter.template=Setter 템플릿(&S)\:
generate.tostring.already.exist.border=메서드가 이미 존재할 경우
generate.tostring.available.implicit.variables.label=사용 가능한 묵시적 변수\:<br/>{0}
generate.tostring.exclude..transient=transient 필드 제외
generate.tostring.exclude.by.field.name=이름별로 필드 제외(정규 표현식)
generate.tostring.exclude.by.field.type=타입 이름별로 필드 제외(정규 표현식)
generate.tostring.exclude.by.name=이름별로 메서드 제외(정규 표현식)
generate.tostring.exclude.by.return.type=반환 타입 이름별로 메서드 제외(정규 표현식)
generate.tostring.exclude.constant.fields=상수 필드 제외
generate.tostring.exclude.enum.fields=열거형 필드 제외
generate.tostring.exclude.logger=로거 필드 제외(Log4j, JDK Logging, Jakarta Commons Logging)
generate.tostring.exclude.static.fields=정적 필드 제외
generate.tostring.fully.qualified.class.name=코드 생성에서 정규화된 클래스 이름 사용($classname)
generate.tostring.getters.in.generated.code=코드 생성에서 getter 사용($methods)
generate.tostring.handle.exception.error.message=작업 수행 중 복구할 수 없는 예외가 던져졌습니다. 자세한 내용은 IDEA 로그를 참조하세요(스택 추적은 dea.log에 포함되어 있습니다)\:\n{0}
generate.tostring.handle.exception.plugin.warning.message=작업 수행 중 복구할 수 없는 PluginException가 던져졌습니다. 자세한 내용은 IDEA 로그를 참조하세요(스택 추적은 dea.log에 포함되어 있습니다)\:\n{0}
generate.tostring.handle.exception.velocity.error.message=코드 생성 속도 오류 - 자세한 내용은 IDEA 로그를 참조하세요(스택 추적은 dea.log에 포함되어 있습니다)\:\n{0}
generate.tostring.insert.border=삽입할 위치?
generate.tostring.method.already.exists.dialog.me\=ssage=기존 {0} 메서드 바꾸기
generate.tostring.method.already.exists.dialog.title=메서드가 이미 존재합니다
generate.tostring.move.to.generated.checkbox=캐럿을 생성된 메서드로 이동
generate.tostring.settings=Ajustes
generate.tostring.sort.ascending=오름차순
generate.tostring.sort.checkbox=요소 정렬
generate.tostring.sort.descending=내림차순
generate.tostring.sort.super=상위 클래스 멤버 우선
generate.tostring.tab.title=toString() 생성 설정
generate.tostring.template.label=템플릿\:
generate.tostring.title=toString() 생성
goto.super.class.chooser.title=상위 클래스 또는 인터페이스 선택
group.javadoc.alignment=맞추기
group.javadoc.blank.lines=빈 줄
group.javadoc.invalid.tags=잘못된 태그
group.javadoc.other=기타
gutter.implemented.method=구현된 메서드
gutter.implementing.method=메서드 구현 중
gutter.overridden.method=재정의된 메서드
gutter.overriding.method=메서드 재정의
gutter.service=서비스
gutter.sibling.inherited.method=상속된 형제 메서드
highlight.exceptions.thrown.chooser.title=강조 표시할 예외 클래스 선택
highlight.imported.classes.chooser.title=강조 표시할 가져온 클래스 선택
highlight.imported.members.chooser.title=강조 표시할 가져온 멤버 선택
highlight.overridden.classes.chooser.title=다음에서 재정의된 메서드를 강조 표시할 클래스 선택
icon.preview=아이콘 미리보기
ignore.imports.and.formatting=import 문 및 서식 지정 무시
illegal.name.validation.info=잘못된 이름\: {0}
import.layout.static.imports.separately=정적 import문 개별적으로 배치
import.statically=정적으로 가져오기
include.accessors=접근자 포함(&I)
infer.nullity.progress=처리 후 결과...
insert.override.annotation=@Override 어노테이션 삽입(&O)
inspection.1.5.display.name=구성된 언어 수준에서 지원되지 않는 API 사용
inspection.1.5.problem.descriptor=@since {0}+로 기록된 API 사용
inspection.1.7.problem.descriptor=JDK {0}에 컴파일 문제를 유발할 수 있는 1.6 API 이후의 일반화된 API 사용
inspection.1.8.problem.descriptor=디폴트 {0, choice, 0\#|1\#메서드가|2\#메서드가} 재정의되지 않았습니다. JDK {1) 에 컴파일 문제를 유발할 수 있습니다.
inspection.1.8.problem.single.descriptor=디폴트 메서드 ''{0}''(이)가 재정의되지 않았습니다. JDK {1}에 컴파일 문제를 유발할 수 있습니다.
inspection.assert.quickfix=어설션 ''{0}''
inspection.capturing.cleaner=Cleaner.register()로 전달된 실행 가능한 파일이 ''{0}'' 참조를 캡처합니다
inspection.capturing.cleaner.description=Cleaner는 객체 참조를 캡처합니다
inspection.cast.can.be.removed.narrowing.variable.type.fix.family.name=변수 타입 변경 및 형 변환 제거
inspection.cast.can.be.removed.narrowing.variable.type.fix.name=''{0}'' 타입을 ''{1}''(으)로 변경 및 형 변환 제거
inspection.cast.can.be.removed.narrowing.variable.type.message=''{0}'' 타입을 ''{1}''(으)로 변경하면 형 변환이 제거될 수 있습니다
inspection.cast.can.be.removed.narrowing.variable.type.name=취약한 변수 타입은 불필요한 형 변환을 유발합니다
inspection.charset.object.can.be.used.display.name=표준 Charset 객체 사용 가능
inspection.charset.object.can.be.used.fix.family.name=Charset 상수 사용
inspection.charset.object.can.be.used.fix.name=''{0}''(으)로 바꾸기
inspection.charset.object.can.be.used.message={0}을(를) 대신 사용 가능
inspection.collection.factories.fix.family.name=컬렉션 팩토리 호출로 바꾸기
inspection.collection.factories.fix.name=''{0}.{1}'' 호출로 바꾸기
inspection.collection.factories.message=''{0}.{1}'' 호출로 바꾸기 가능
inspection.collection.factories.option.ignore.non.constant=비상수 콘텐츠를 경고하지 않음
inspection.collection.factories.option.suggest.ofentries=''Map.ofEntries'' 제안
inspection.collection.used.as.vararg.display.name=Iterable 객체는 vararg로 사용됩니다
inspection.collection.used.as.vararg.message=Iterable 객체는 vararg로 간주됩니다. 배열이 의도되었을 가능성이 있습니다.
inspection.comparator.result.comparison.display.name=compare 메서드의 의심스러운 사용 위치
inspection.comparator.result.comparison.fix.family.name=비교자 결과 비교 수정
inspection.comparator.result.comparison.problem.display.name=compare 메서드 결과와 특정 상수 비교
inspection.conditional.break.in.infinite.loop=조건을 루프로 이동
inspection.conditional.break.in.infinite.loop.description=무한 루프 내부의 조건 줄 바꿈
inspection.conditional.break.in.infinite.loop.no.conversion.with.do.while=\ ''do while''로 바꾸기를 제안하지 않음
inspection.convert.to.basic.latin=Basic Latin으로 변환
inspection.convert.to.local.quickfix=로컬로 변환
inspection.data.flow.display.name=상수 조건 및 예외
inspection.data.flow.filter.notnull.quickfix=''filter(Objects\:\:nonNull)'' 단계 삽입
inspection.data.flow.nullable.quickfix.option=null 가능 값이 사용되는 메서드/필드/매개변수에 대한 @Nullable 어노테이션 제안
inspection.data.flow.true.asserts.option=항상 <code>true</code>임이 정적으로 입증된 조건이 포함된 어설션을 보고하지 않음
inspection.data.flow.ignore.assert.statements=assert 문 무시
inspection.data.flow.warn.when.reading.a.value.guaranteed.to.be.constant=상수인 것으로 보장된 값을 읽을 시 경고
inspection.data.flow.treat.non.annotated.members.and.parameters.as.nullable=어노테이션이 없는 멤버 및 매개변수를 @Nullable로 취급
inspection.data.flow.report.not.null.required.parameter.with.null.literal.argument.usages=null 리터럴 인수가 사용되고 null이 아니여야 하는 매개변수 보고
inspection.data.flow.report.nullable.methods.that.always.return.a.non.null.value=null이 아닌 값을 항상 반환하는 null 가능한 메서드 보고
inspection.data.flow.report.problems.that.happen.only.on.some.code.paths=일부 코드 경로에서만 발생하는 문제 보고
inspection.data.flow.use.computeifpresent.quickfix=''compute'' 문을 ''computeIfPresent''로 바꾸기
inspection.dead.code.option.applet=Applets
inspection.dead.code.option.external=비 Java 파일에서 사용되는 클래스
inspection.dead.code.option.main=<html><code>void main(문자열 인수[])</code> 메서드</html>
inspection.dead.code.option.servlet=Servlets
inspection.default.annotation.param=디폴트 어노테이션 매개변숫값
inspection.duplicate.branches.in.switch.default.message=''switch'' 브랜치는 디폴트 브랜치의 중복입니다
inspection.duplicate.branches.in.switch.delete.fix.family.name=불필요한 ''switch'' 브랜치 삭제
inspection.duplicate.branches.in.switch.delete.fix.name=불필요한 ''switch'' 브랜치 삭제
inspection.duplicate.branches.in.switch.display.name=''switch''의 중복 브랜치
inspection.duplicate.branches.in.switch.merge.fix.family.name=''switch''의 중복 브랜치 병합
inspection.duplicate.branches.in.switch.merge.fix.name=''{0}''에 병합
inspection.duplicate.branches.in.switch.merge.with.default.fix.name=디폴트 ''switch'' 브랜치에 병합
inspection.duplicate.branches.in.switch.message=''switch''의 중복 브랜치
inspection.duplicate.expressions.complexity.threshold=표현식 복잡성 임계값
inspection.duplicate.expressions.display.name=동일한 표현식의 여러 찾은 항목
inspection.duplicate.expressions.introduce.variable.fix.family.name=변수 소개
inspection.duplicate.expressions.introduce.variable.fix.name=\ ''{0}'' 변수 삽입
inspection.duplicate.expressions.message=<code>\#ref</code> \#loc의 여러 찾은 항목
inspection.duplicate.expressions.replace.other.occurrences.fix.family.name=표현식 찾은 항목가 다른 변수로 바꾸기
inspection.duplicate.expressions.replace.other.occurrences.fix.name=''{1}'' 사용 위치가 다른 ''{0}''(으)로 바꾸기
inspection.duplicate.expressions.reuse.variable.fix.family.name=변수 재사용
inspection.duplicate.expressions.reuse.variable.fix.name=''{1}''의 ''{0}'' 변수 재사용
inspection.empty.method.delete.quickfix=불필요한 메서드 삭제
inspection.empty.method.problem.descriptor=메서드는 상위 메서드만 호출
inspection.empty.method.problem.descriptor1=빈 메서드가 빈 메서드를 재정의
inspection.empty.method.problem.descriptor2=빈 메서드입니다
inspection.empty.method.problem.descriptor3=메서드 및 모든 파생 항목이 비어 있습니다
inspection.empty.method.problem.descriptor4=이 메서드의 모든 구현은 비어 있습니다
inspection.endless.stream.description=Non-short-circuit operation consumes the infinite stream
inspection.equals.hashcode.display.name=equals() and hashCode() not paired
inspection.equals.hashcode.generate.equals.quickfix=''equals()'' 생성
inspection.equals.hashcode.generate.hashcode.quickfix=''hashCode()'' 생성
inspection.excessive.lambda.fix.family.name=람다를 상수로 바꾸기
inspection.excessive.lambda.fix.name=람다 없이 ''{0}'' 메서드 사용
inspection.excessive.lambda.message=과도한 람다 사용
inspection.explicit.argument.can.be.lambda.fix.family.name=묵시적 인수를 함수로 바꾸기
inspection.explicit.argument.can.be.lambda.fix.name=함수 인수가 포함된 ''{0}'' 메서드 사용
inspection.explicit.argument.can.be.lambda.message=묵시적 인수를 람다로 변환할 수 있습니다
inspection.explicit.array.filling.description=단일 ''Array.{0}()'' 메서드 호출로 바꿀수 있습니다
inspection.explicit.array.filling.fix.family.name=루프를 ''Array.{0}()'' 메서드 호출로 바꿀수 있습니다
inspection.explicit.array.filling.no.suggestion.for.set.all=''Arrays.setAll()'' 사용을 제안하지 않음
inspection.explicit.array.filling.redundant.loop.description=새로 생성된 배열의 불필요한 초기화
inspection.explicit.array.filling.suggest.set.all=''Arrays.setAll()'' 제안
inspection.export.results.callees=호출 체인
inspection.export.results.implicit.constructor=묵시적 생성자
inspection.export.results.overrides.library.methods=라이브러리 메서드 재정의
inspection.export.results.package=패키지
inspection.export.results.type.references=다음은 이 타입을 사용합니다
inspection.field.can.be.local.display.name=필드는 로컬일 수 있습니다
inspection.field.can.be.local.problem.descriptor=필드는 지역 변수로 변환될 수 있습니다
inspection.field.can.be.local.quickfix.constructor=생성자에서 필드를 지역 변수로 변환
inspection.field.can.be.local.quickfix.initializer=이니셜라이저 섹션에서 필드를 지역 변수로 변환
inspection.field.can.be.local.quickfix.one.method=''{0}'' 메서드에서 필드를 지역 변수로 변환
inspection.fold.expression.fix.family.name=표현식 접기
inspection.fold.expression.into.stream.display.name=표현식을 Stream 체인으로 접을 수 있습니다
inspection.fold.expression.into.stream.fix.name=표현식을 Stream 체인으로 접기
inspection.fold.expression.into.string.display.name=표현식을 ''String.join''으로 접을 수 있습니다
inspection.fold.expression.into.string.fix.name=표현식을 ''String.join''으로 접기''
inspection.forward.compatibility.name=상위 호환성
inspection.fuse.stream.operations.display.name=후속 단계는 Stream API 체인으로 결합될 수 있습니다
inspection.fuse.stream.operations.fix.family.name=Stream API 체인에 추가 구문 결합
inspection.fuse.stream.operations.fix.name={0}(을)를 Stream API 체인으로 결합
inspection.fuse.stream.operations.message=Stream은 확장되어 {0}(을)를 바꿀수 있습니다
inspection.fuse.stream.operations.option.strict.mode=''toList()'' 또는 ''toSet()'' 컬렉터를 제안하지 않음
inspection.handle.signature.change.type.fix.name=타입을 ''{0}''(으)로 변경
inspection.handle.signature.field.cannot.resolve=필드 ''{0}''을(를) 해결할 수 없습니다
inspection.handle.signature.field.not.static=''{0}'' 필드는 정적이지 않습니다
inspection.handle.signature.field.static=''{0}'' 필드는 정적입니다
inspection.handle.signature.field.type=''{0}'' 필드 타입은 ''{1}''입니다
inspection.handle.signature.method.abstract=''{1}''에서 ''{0}'' 메서드는 추상 메서드입니다
inspection.handle.signature.method.not.static=''{0}'' 메서드는 정적이지 않습니다
inspection.handle.signature.method.static=''{0}'' 메서드는 정적입니다
inspection.handle.signature.name=MethodHandle/VarHandle 타입 불일치
inspection.handle.signature.not.subclass=호출자 클래스 ''{0}''은(는) ''{1}''의 하위 클래스여야 합니다
inspection.handle.signature.replace.with.fix.name=''{0}''(으)로 바꾸기
inspection.handle.signature.use.constructor.fix.family.name=생성자 오버로드 중 하나를 사용
inspection.handle.signature.use.constructor.fix.name=생성자 ''{0}'' 사용
inspection.handle.signature.use.method.fix.family.name=메서드 오버로드 중 하나를 사용
inspection.handle.signature.use.method.fix.name=메서드 ''{0}'' 사용
inspection.idempotent.loop.body=멱등 루프 본문
inspection.illegal.character=잘못된 문자
inspection.suspicious.ternary.in.varargs.display.name=vararg 메서드 호출 내 의심스러운 삼항 연산자
inspection.suspicious.ternary.in.varargs.description=vararg 호출 내 삼항 연산자에 배열 및 배열이 아닌 브랜치가 포함되어 있습니다
inspection.suspicious.ternary.in.varargs.quickfix=배열 이니셜라이저 줄 바꿈
inspection.insert.literal.underscores.display.name=판독 불가한 숫자 리터럴
inspection.insert.literal.underscores.family.name=숫자 리터럴에 밑줄 삽입
inspection.javadoc.dialog.title=추가 Javadoc 태그 편집
inspection.javadoc.display.name=선언에 Javadoc 문제가 있습니다
inspection.javadoc.label.text=추가 Javadoc 태그\:
inspection.javadoc.lint.display.name=Javadoc(DocLint)의 HTML 문제
inspection.javadoc.method.problem.missing.param.tag=필수 태그 <code>@param</code>에 매개변수 {0}(이)가 누락되었습니다
inspection.javadoc.method.problem.missing.tag.description={0} 태그 설명이 없습니다
inspection.javadoc.option.ignore.deprecated=@deprecated로 표시된 요소 무시
inspection.javadoc.option.ignore.period=기간 문제 무시
inspection.javadoc.option.ignore.self.ref=자체를 가리키는 Javadoc 무시
inspection.javadoc.option.ignore.simple=간단한 프로퍼티 접근자 무시
inspection.javadoc.option.ignore.throws=중복 ''throws'' 태그 무시
inspection.javadoc.option.tab.title=클래스
inspection.javadoc.option.tab.title.field=필드
inspection.javadoc.option.tab.title.inner.class=내부 클래스
inspection.javadoc.option.tab.title.method=메서드
inspection.javadoc.option.tab.title.module=모듈
inspection.javadoc.option.tab.title.package=패키지
inspection.javadoc.problem.add.param.tag=매개변수 ''{0}''에 대한 @param 태그 추가
inspection.javadoc.problem.add.param.tag.family=누락된 Javadoc param 태그 추가
inspection.javadoc.problem.add.tag=@{0} {1} 태그 추가
inspection.javadoc.problem.add.tag.family=누락된 Javadoc 태그 추가
inspection.javadoc.problem.cannot.resolve=심볼 {0}을(를) 해결할 수 없습니다
inspection.javadoc.problem.descriptor=필요한 Javadoc이 없습니다
inspection.javadoc.problem.descriptor1=문서의 기간이 누락되었습니다. 이 기간은 Javadoc 도구에서 개요 페이지 주석을 생성하는 데 사용됩니다.
inspection.javadoc.problem.disallowed.tag={0} 태그는 허용되지 않습니다
inspection.javadoc.problem.duplicate.param=매개변수 ''{0}''에 대한 @param 태그 복제
inspection.javadoc.problem.duplicate.tag=@{0} 태그 복제
inspection.javadoc.problem.duplicate.throws=예외 ''{0}''에 대한 @throws 또는 @exception 태그 복제
inspection.javadoc.problem.inaccessible=심볼 {0}에 액세스할 수 없습니다
inspection.javadoc.problem.missing.tag=필수 태그 {0}(이)가 누락되었습니다
inspection.javadoc.problem.missing.tag.description=@{1} 태그 뒤에 {0}(이)가 누락되었습니다
inspection.javadoc.problem.name.expected=이름 필요
inspection.javadoc.problem.pointing.to.itself=자체를 가리키는 Javadoc
inspection.javadoc.problem.see.tag.expecting.ref=Class/method reference,quoted text,or HTML link are expected after @see tag
inspection.javadoc.problem.wrong.tag=잘못된 태그\: {0}
inspection.javadoc.ref.display.name=선언에 Javadoc 참조 문제가 있습니다
inspection.javadoc.required.tags.option.title=필수 태그
inspection.javadoc.throws.or.exception.option=@throws 또는 @exception
inspection.join.declaration.and.assignment.display.name=할당은 선언과 결합될 수 있습니다
inspection.join.declaration.and.assignment.fix.family.name=선언 및 할당 결합
inspection.join.declaration.and.assignment.message=할당은 ''{0}'' 선언과 결합될 수 있습니다
inspection.labeled.switch.rule.redundant.code.block.display.name=라벨 지정된 switch 식 규칙에 중복 코드 블록이 있습니다
inspection.labeled.switch.rule.redundant.code.block.message=라벨 지정된 규칙의 코드 블록이 중복됩니다
inspection.labeled.switch.rule.redundant.code.fix.name=라벨 지정된 규칙의 코드 블록 줄 바꿈 해제
inspection.lambda.to.method.call.fix.family.name=람다 표현식을 메서드 호출로 바꾸기
inspection.lambda.to.method.call.fix.name=람다 표현식을 ''{0}''(으)로 바꾸기
inspection.manual.min.max.calculation.description=''Math.{0}'' 호출로 바꾸기 가능
inspection.manual.min.max.calculation.disable.for.non.integral=float 및 double 비활성화
inspection.map.foreach.display.name=Map.forEach() 사용 가능
inspection.map.foreach.option.no.loops=루프를 보고하지 않음
inspection.message.anonymous.ref.loc.can.be.replaced.with.method.reference=익명 \#ref \#loc는 메서드 참조로 바꿀수 있습니다
inspection.message.can.be.replaced.with.0.constructor=\ ''{0}'' 생성자로 바꾸기 가능
inspection.message.can.be.replaced.with.files.readstring=''Files.readString()''으로 바꾸기 가능
inspection.message.can.be.replaced.with.optional.of.nullable=Optional.ofNullable()로 바꾸기 가능
inspection.message.can.be.replaced.with.single.expression.in.functional.style=함수 스타일의 단일 식으로 바꿀수 있습니다
inspection.message.can.be.replaced.with.string.repeat=''String.repeat()''으로 바꾸기 가능
inspection.message.lambda.parameter.type.is.redundant=람다 매개변수 타입이 중복됩니다
inspection.message.pseudo.functional.style.code=의사 함수 스타일 코드
inspection.message.redundant.default.parameter.value.assignment=중복된 디폴트 매개변숫값 대입
inspection.message.replace.optional.with.if.statements=Optional을 if 문으로 바꾸기
inspection.no.jdk.error.message=이 프로젝트에 대해 JDK가 제대로 구성되지 않았습니다. 검사를 진행할 수 없습니다.
inspection.no.modules.error.message=이 프로젝트에 모듈이 없습니다. 검사를 진행할 수 없습니다.
inspection.notnull.field.not.initialized.display.name=@NotNull 필드가 초기화되지 않았습니다
inspection.notnull.field.not.initialized.option.implicit=암시적으로 초기화될 수 있는 필드 무시
inspection.notnull.field.not.initialized.option.setup=setup() 메서드에서 초기화된 필드 무시
inspection.null.value.for.optional.assigned.ignore.fix.name=Optional과 null 비교 시 경고하지 않음
inspection.null.value.for.optional.assigned.message=Optional 값은 null과 비교됩니다
inspection.null.value.for.optional.context.assignment=대입
inspection.null.value.for.optional.context.declaration=선언
inspection.null.value.for.optional.context.lambda=람다 식
inspection.null.value.for.optional.context.parameter=매개변수
inspection.null.value.for.optional.context.return=return 문
inspection.null.value.for.optional.fix.family.name=빈 Optional 메서드로 바꾸기
inspection.null.value.for.optional.message=Null은 {0}의 ''Optional'' 타입에서 사용됩니다
inspection.null.value.for.optional.option.comparisons=Optional과 null 비교 결과 보고
inspection.nullable.problems.display.name=@NotNull/@Nullable 문제
inspection.nullable.problems.ignore.external.notnull=외부 @NotNull 무시(&I)
inspection.nullable.problems.method.overrides.notnull.option=<html>@Nullable을 재정의하는 @NotNull 및 매개변수및 <br>@NotNull을 재정의하는 @Nullable 메서드 보고(&P)</html>
inspection.nullable.problems.method.overrides.option=어노테이션이 추가되지 않은 매개변수 또는 @NotNull을 재정의하는 메서드 보고(&A)
inspection.nullable.problems.not.annotated.getters.for.annotated.fields=어노테이션이 추가되지 않은 setter 매개변수 또는 어노테이션이 추가된 필드의 getter 보고(&S)
inspection.nullable.problems.notnull.overrides.option=어노테이션이 추가되지 않은 매개변수를 재정의하는 @NotNull 매개변수 보고(&P)
inspection.nullable.problems.notnull.parameters.with.null.literal.option=null 리터럴 인수가 사용된 @NotNull 매개변수 보고
inspection.optional.get.without.is.present.message=''isPresent()'' 검사가 없는 <code>{0}.\#ref()</code>
inspection.overflowing.loop.index.inspection.description=루프가 0번 또는 수십억 번 실행됩니다
inspection.overflowing.loop.index.inspection.name=루프가 0번 또는 수십억 번 실행됩니다
inspection.overwritten.key.map.message=Map 키 복제
inspection.overwritten.key.set.message=Set 요소 복제
inspection.parameter.can.be.local.display.name=매개변수로 전달된 값이 한 번도 읽히지 않음
inspection.parameter.can.be.local.problem.descriptor=매개변수는 지역 변수로 변환될 수 있습니다
inspection.pseudo.functional.style.add.methods.after.quick.fix=빠른 수정 후\:
inspection.pseudo.functional.style.add.methods.before.quick.fix=빠른 수정 전\:
inspection.pseudo.functional.style.add.methods.fully.qualified.class.name=정규화된 클래스 이름\:
inspection.pseudo.functional.style.add.methods.method.name=메서드 이름\:
inspection.pseudo.functional.style.add.methods.stream.api.replacement=Stream API 바꾸기
inspection.quickfix.assert.family=어설션
inspection.raw.use.of.parameterized.type.problem.descriptor=매개변수화된 클래스 <code>\#ref</code>의 원시 사용 \#loc
raw.variable.type.can.be.generic.family.quickfix=타입에 제네릭 매개변수 추가
raw.variable.type.can.be.generic.quickfix={0} 타입을 {1}(으)로 변경
raw.use.of.parameterized.type.ignore.new.objects.option=새 객체 생성 무시
raw.use.of.parameterized.type.ignore.type.casts.option=형 변환 무시
raw.use.of.parameterized.type.ignore.uncompilable.option=타입 매개변수가 컴파일되지 않는 위치 무시
raw.use.of.parameterized.type.ignore.overridden.parameter.option=재정의 메서드의 매개변수 타입 무시
raw.use.of.parameterized.type.ignore.quickfix.not.available.option=자동 빠른 수정을 사용할 수 없는 경우 경고 안 함
inspection.redundant.array.creation.display.name=중복 배열 생성
inspection.redundant.array.creation.for.varargs.call.descriptor=varargs 메서드 호출을 위한 중복 배열 생성
inspection.redundant.array.creation.quickfix=묵시적 배열 생성 제거
inspection.redundant.explicit.close=Redundant close
inspection.redundant.file.creation.display.name=중복 파일 객체 생성
inspection.redundant.file.creation.description=<code>\#ref</code>이(가) 중복됩니다 \#loc
inspection.redundant.file.creation.quickfix=파일 이름으로 바꾸기
inspection.redundant.null.check.always.fail.message=Null 검사가 항상 실패합니다. {0}(은)는 null이 아닙니다.
inspection.redundant.null.check.fix.family.name=중복 null 검사 제거
inspection.redundant.null.check.fix.notnull.family.name=잘못된 ''\!\= null'' 제거
inspection.redundant.null.check.message=중복 null 검사\: {0}(은)는 null이 아닙니다
inspection.redundant.operation.on.empty.array.message=배열 <code>\#ref</code>는 항상 공백입니다
inspection.redundant.operation.on.empty.collection.message=컬렉션 <code>\#ref</code>는 항상 공백입니다
inspection.redundant.operation.on.empty.container.display.name=빈 컨테이너에서 중복 작업
inspection.redundant.operation.on.empty.map.message=맵 <code>\#ref</code>는 항상 공백입니다
inspection.redundant.record.constructor.can.be.compact.message=표준 생성자는 압축 양식으로 변환될 수 있습니다
inspection.redundant.record.constructor.canonical.message=중복 표준 생성자
inspection.redundant.record.constructor.compact.message=중복 압축 생성자
inspection.redundant.record.constructor.description=중복 기록 생성자
inspection.redundant.record.constructor.fix.family.name=표준 생성자를 압축 양식으로 변환
inspection.redundant.record.constructor.statement.message=압축 생성자의 중복 필드 할당
inspection.redundant.stream.optional.call.explanation.at.most.one=스트림은 최대 하나의 요소를 포함합니다
inspection.redundant.stream.optional.call.explanation.distinct=체인에 이미 ''distinct'' 호출이 포함되어 있습니다
inspection.redundant.stream.optional.call.explanation.distinct.set=요소는 Set에 수집될 때 구별됩니다
inspection.redundant.stream.optional.call.explanation.filter=술부가 항상 true입니다
inspection.redundant.stream.optional.call.explanation.map.flatMap=이전 ''map'' 호출은 ''flatMap'' 단계를 바꿀수 있습니다
inspection.redundant.stream.optional.call.explanation.parallel=이 호출을 재정의하는 후속 ''{0}'' 호출이 있습니다
inspection.redundant.stream.optional.call.explanation.parallel.single=단일 요소에서 생성된 스트림은 병렬 처리되지 않습니다
inspection.redundant.stream.optional.call.explanation.sorted=후속 ''{0}'' 호출은 정렬 순서에 의존하지 않습니다
inspection.redundant.stream.optional.call.explanation.sorted.twice=스트림 콘텐츠는 그 뒤로 다시 정렬됩니다
inspection.redundant.stream.optional.call.explanation.unordered=체인에 이미 ''unordered'' 호출이 포함되어 있습니다
inspection.redundant.stream.optional.call.fix.collect.to.ordered.family.name=''LinkedHashSet''에 수집
inspection.redundant.stream.optional.call.fix.family.name=중복 체인 호출 제거
inspection.redundant.stream.optional.call.fix.name=''{0}'' 호출 제거
inspection.redundant.stream.optional.call.message=중복 ''{0}'' 호출
inspection.redundant.stream.optional.call.message.with.explanation=중복 ''{0}'' 호출\: {1}
inspection.redundant.stream.optional.call.option.streamboxing=Stream.map의 중복 박싱 보고
inspection.reflect.handle.invocation.argument.not.array=인수가 배열 타입이 아닙니다
inspection.reflect.handle.invocation.argument.not.exact=인수 타입은 정확히 ''{0}'' 타입이어야 합니다
inspection.reflect.handle.invocation.primitive.argument.null=''{0}'' 타입의 인수는 ''null''이 될 수 없습니다
inspection.reflect.handle.invocation.receiver.incompatible=호출 리시버 타입이 호환되지 않습니다. ''{0}'' 필요
inspection.reflect.handle.invocation.receiver.null=호출 리시버가 ''null''입니다
inspection.reflect.handle.invocation.result.not.assignable=''{0}'' 또는 상위 클래스로 형 변환되어야 합니다
inspection.reflect.handle.invocation.result.not.exact=''{0}''(으)로 형 변환되어야 합니다
inspection.reflect.handle.invocation.result.null=반환 값은 항상 ''null''입니다
inspection.reflect.handle.invocation.result.void=반환 타입이 ''void''입니다
inspection.reflection.invocation.argument.count={0,choice,0\#0개의 인수가 |1\#1개의 인수가|1<{0}개의 인수가} 필요합니다
inspection.reflection.invocation.argument.not.assignable=인수를 ''{0}''에 대입할 수 없습니다
inspection.reflection.invocation.array.not.assignable=배열 {0,choice,1\#항목은|1<항목은} {0,choice,1\#타입|1<타입}과 호환되지 않습니다
inspection.reflection.invocation.item.count={0,choice,0\#비어 있는 배열이|1\#단일 배열 항목이|1<{0}개의 배열 항목이} 필요합니다
inspection.reflection.invocation.item.not.assignable=배열 항목을 ''{0}''에 대입할 수 없습니다
inspection.reflection.invocation.name=리플렉티브 호출 인수 불일치
inspection.reflection.member.access.cannot.resolve.constructor.arguments=지정된 인수 타입의 생성자를 해결할 수 없습니다
inspection.reflection.member.access.cannot.resolve.field=''{0}'' 필드를 해결할 수 없습니다
inspection.reflection.member.access.cannot.resolve.method=메서드 ''{0}''을(를) 해결할 수 없습니다
inspection.reflection.member.access.cannot.resolve.method.arguments=지정된 인수 타입의 ''{0}'' 메서드를 해결할 수 없습니다
inspection.reflection.member.access.check.exists=비 final 클래스에 필드/메서드가 있는지 확인
inspection.reflection.member.access.check.exists.exclude=클래스 제외
inspection.reflection.member.access.check.exists.exclude.chooser=제외할 클래스
inspection.reflection.member.access.constructor.not.public=생성자가 public이 아닙니다
inspection.reflection.member.access.field.not.in.class=''{0}'' 필드는 ''{1}'' 클래스에서 선언되지 않습니다
inspection.reflection.member.access.field.not.public=''{0}'' 필드는 public이 아닙니다
inspection.reflection.member.access.fix.family.name=적절한 리플렉션 메서드 사용
inspection.reflection.member.access.method.not.in.class=''{0}'' 메서드는 ''{1}'' 클래스에서 선언되지 않습니다
inspection.reflection.member.access.method.not.public=''{0}'' 메서드는 public이 아닙니다
inspection.reflection.member.access.name=존재하지 않거나 보이지 않는 클래스 멤버에 대한 리플렉티브 액세스
inspection.reflection.visibility.name=모듈 문제 전체에 리플렉티브 액세스
inspection.remove.literal.underscores.display.name=숫자 리터럴의 밑줄
inspection.remove.literal.underscores.family.name=숫자 리터럴에서 밑줄 제거
inspection.replace.methodref.ternary.quickfix=null 검사 람다로 바꾸기
inspection.replace.ternary.quickfix=\ ''{0} \!\= null ?\:''로 바꾸기
inspection.replace.with.bulk.fix.family.name=대량 메서드 호출로 바꾸기
inspection.replace.with.bulk.fix.name=반복을 대량 ''{0}'' 호출로 바꾸기
inspection.replace.with.bulk.message=반복은 대량 ''{0}'' 호출로 대체될 수 있습니다
inspection.replace.with.bulk.wrap.arrays=Arrays.asList()를 사용해 배열 줄 바꿈
inspection.replace.with.enhanced.switch.statement.fix.name=향상된 ''switch'' 문으로 바꾸기
inspection.replace.with.old.style.switch.statement.fix.name=이전 스타일의 ''switch'' 문으로 바꾸기
inspection.replace.with.regular.string.literal.fix=일반 문자열 리터럴로 바꾸기
inspection.replace.with.switch.expression.fix.name=''switch'' 식으로 바꾸기
inspection.replace.with.text.block.fix=텍스트 블록으로 바꾸기
inspection.replace.with.trivial.lambda.fix.family.name=자명한 람다로 바꾸기
inspection.replace.with.trivial.lambda.fix.name=람다 반환 ''{0}''로 바꾸기
inspection.require.non.null=null 검사를 Objects/Stream 정적 호출로 바꾸기
inspection.require.non.null.description=Null 검사를 메서드 호출로 바꿀 수 있습니다
inspection.require.non.null.message=조건을 ''{0}''(으)로 바꿉니다
inspection.require.non.null.no.warning.replacement.bigger=기존 조건보다 대체 조건의 길이가 더 길더라도 경고하지 않음
inspection.return.separated.from.computation.descriptor=''{0}'' 값 계산에서 분리된 반환
inspection.return.separated.from.computation.family.quickfix=''return'' 값을 결과 값 계산에 가깝게 이동
inspection.return.separated.from.computation.name=Return separated from computation of result
inspection.return.separated.from.computation.quickfix=''return'' 값을 ''{0}'' 값 계산에 가깝게 이동
inspection.same.parameter.display.name=실제 메서드 매개변수는 동일한 상수입니다
inspection.same.parameter.fix.family.name=상수 값으로 매개변수 인라인화
inspection.same.parameter.fix.name=\ ''{0}'' 매개변수로 ''{1}'' 값 인라인화
inspection.same.parameter.problem.descriptor=''{0}'' 매개변수의 실제 값은 항상 ''{1}''입니다
inspection.scope.for.title=범위
inspection.simplifiable.comparator.comparing.message=불필요한 ''{0}()'' 호출
inspection.simplifiable.comparator.display.name=비교자를 단순화할 수 있습니다.
inspection.simplifiable.comparator.entry.comparator.message=''{0}''을(를) 대신 사용 가능
inspection.simplifiable.comparator.fix.comparing.family.name=중복 호출 제거
inspection.simplifiable.comparator.fix.entry.comparator.family.name=사전 정의된 Map.Entry 비교자
inspection.simplifiable.comparator.fix.remove.name=''{0}()'' 호출 제거
inspection.simplifiable.comparator.fix.replace.name=''{0}()'' 호출을 제거하고 ''{1}()'' 사용
inspection.simplifiable.comparator.fix.reversed.family.name=''최대''를 ''최소''로 대체하는 비교자 단순화
inspection.simplifiable.comparator.fix.reversed.name=비교자를 단순화하는 ''{0}''(으)로 바꾸기 
inspection.simplifiable.comparator.reversed.message=''{0}()'' 호출이 ''{1}()''(으) 대체된 경우 비교자를 단순화할 수 있습니다.
inspection.simplify.collector.fix.family.name=캐스케이드 컬렉터 단순화
inspection.simplify.collector.fix.name=''Collectors.{0}'' 컬렉터 사용
inspection.simplify.collector.message=''{0}'' 컬렉터를 사용하여 단순화할 수 있습니다
inspection.simplify.foreach.display.name=단순화 가능한 forEach() 호출
inspection.sorted.collection.with.non.comparable.keys.display.name=비교 불가능한 요소가 있는 정렬된 컬렉션
inspection.sorted.collection.with.non.comparable.keys.message=비교 불가능한 요소가 있는 정렬된 컬렉션 생성
inspection.sorted.collection.with.non.comparable.keys.option.type.parameters=비교 불가능한 타입 매개변수를 보고하지 않음
inspection.surround.if.family=if 문으로 둘러싸기
inspection.surround.if.quickfix=Surround with ''if ({0} \!\= null)''
inspection.suspicious.list.remove.display.name=루프 내 의심스러운 ''List.remove()''
inspection.switch.expression.backward.expression.migration.inspection.name=''switch'' 식을 이전 스타일의 ''switch'' 문으로 바꿀수 있습니다
inspection.switch.expression.backward.migration.inspection.name=새로운 스타일의 ''switch'' 문을 이전 스타일의 ''switch'' 문으로 바꿀수 있습니다.
inspection.switch.expression.backward.statement.migration.inspection.name=''switch'' 문을 이전 스타일의 ''switch'' 문으로 바꿀수 있습니다
inspection.switch.expression.migration.inspection.name=구문을 향상된 ''switch'' 문으로 바꿀수 있습니다
inspection.switch.expression.migration.inspection.switch.description=switch 문을 향상된 ''switch'' 문으로 바꿀수 있습니다
inspection.switch.expression.migration.warn.only.on.expression=식으로 변환이 가능한 경우에만 경고 표시
inspection.switch.labeled.rule.can.be.code.block.display.name=라벨 지정된 switch 식 규칙에 코드 블록이 포함될 수 있습니다
inspection.switch.labeled.rule.can.be.code.block.expression.message=코드 블록을 사용해 라벨 지정된 규칙의 결과 식을 줄 바꿈할 수 있습니다
inspection.switch.labeled.rule.can.be.code.block.fix.expression.name=코드 블록을 사용해 라벨 지정된 규칙의 결과 식 줄 바꿈
inspection.switch.labeled.rule.can.be.code.block.fix.statement.name=코드 블록을 사용해 라벨 지정된 규칙의 구문 줄 바꿈
inspection.switch.labeled.rule.can.be.code.block.statement.message=코드 블록을 사용해 라벨 지정된 규칙의 구문을 줄 바꿈할 수 있습니다
inspection.text.block.backward.migration.message=텍스트 블록을 일반 문자열 리터럴로 변환할 수 있습니다
inspection.text.block.backward.migration.name=텍스트 블록을 일반 문자열 리터럴로 바꿀수 있습니다
inspection.text.block.migration.string.message=문자열을 텍스트 블록으로 바꿀 수 있습니다
inspection.text.block.migration.concatenation.message=연결을 텍스트 블록으로 바꿀 수 있습니다
inspection.text.block.migration.name=텍스트 블록 사용 가능
inspection.text.block.migration.suggest.literal.replacement=단일 문자열 리터럴에 적용
inspection.inconsistent.text.block.indent.name=일관되지 않은 공백 들여쓰기
inspection.inconsistent.text.block.indent.message=텍스트 블록 들여쓰기는 탭과 공백으로 구성됩니다
inspection.inconsistent.text.block.indent.spaces.to.tabs.one.to.one.fix=공백을 탭으로 바꾸기(1 공백 \= 1 탭)
inspection.inconsistent.text.block.indent.spaces.to.tabs.many.to.one.fix=공백을 탭으로 바꾸기({0} 공백 \= 1 탭)
inspection.inconsistent.text.block.indent.tabs.to.spaces.one.to.one.fix=탭을 공백으로 바꾸기(1 탭 \= 1 공백)
inspection.inconsistent.text.block.indent.tabs.to.spaces.one.to.many.fix=탭을 공백으로 바꾸기(1 탭 \= {0} 공백)
inspection.trailing.whitespaces.in.text.block.name=텍스트 블록 내 후행 공백
inspection.trailing.whitespaces.in.text.block.message=텍스트 블록 끝의 후행 공백
inspection.trailing.whitespaces.in.text.block.remove.whitespaces=후행 공백 제거
inspection.trailing.whitespaces.in.text.block.replaces.whitespaces.with.escapes=후행 공백 이스케이프
inspection.undeclared.service.usage.message=서비스 ''{0}''의 사용 위치는 module-info에서 선언되지 않습니다
inspection.undeclared.service.usage.name=''module-info''에서 서비스의 사용위치가 선언되지 않았습니다
inspection.unused.assignment.option=\ (i + 1)로 대체 가능할 시 ++i 보고
inspection.unused.assignment.option1=추후 변경된 값이 사용되지 않을 때 i++를 보고.
inspection.unused.assignment.option2=불필요한 이니셜라이저 제거
inspection.unused.assignment.problem.descriptor1=변수 {0}은(는) 전혀 사용되지 않습니다
inspection.unused.assignment.problem.descriptor2={0} 변수의 {1} 이니셜라이저는 불필요합니다
inspection.unused.assignment.problem.descriptor3={1}에 할당된 {0} 값은 사용되지 않습니다
inspection.unused.assignment.problem.descriptor4={0}에서 변경된 값은 사용되지 않습니다
inspection.unused.assignment.remove.assignment.quickfix=중복 할당 제거
inspection.unused.assignment.remove.quickfix=불필요한 이니셜라이저 제거
inspection.unused.parameter.composer=매개변수 <code>\#ref</code>는 어떤 구현에서도 사용되지 않습니다
inspection.unused.parameter.composer1=매개변수 <code>\#ref</code>는 이 메서드 또는 파생된 메서드에 사용되지 않습니다
inspection.unused.parameter.delete.quickfix=사용되지 않는 매개변수 삭제
inspection.unused.return.value.display.name=메서드가 void일 수 있습니다
inspection.unused.return.value.make.void.quickfix=메서드를 ''void''로 작성
inspection.unused.return.value.problem.descriptor=메서드의 반환 값은 사용되지 않습니다
inspection.unused.symbol.check.accessors=Getters/setters
inspection.unused.symbol.check.classes=클래스\:
inspection.unused.symbol.check.fields=필드\:
inspection.unused.symbol.check.inner.classes=내부 클래스\:
inspection.unused.symbol.check.localvars=지역 변수
inspection.unused.symbol.check.methods=메서드\:
inspection.unused.symbol.check.parameters=매개변수\:
inspection.value.based.warnings=값 기준 경고
inspection.preview.feature=테스트 버전 기능 경고
inspection.value.based.warnings.synchronization=값 기준 클래스 인스턴스에서 동기화 시도
inspection.variable.assigned.to.itself.display.name=변수는 자체 할당됩니다
inspection.wrapper.type.may.be.primitive.fix.name=래퍼 타입을 기본으로 변환
inspection.wrapper.type.may.be.primitive.name=타입은 기본일 수 있습니다
intention.add.explicit.type.arguments.family=명시적 타입 인수 추가
intention.add.on.demand.static.import.family=Add On Demand Static Import
intention.add.on.demand.static.import.text=Add on demand static import for ''{0}''
intention.add.single.member.import.text=''{0}''의 import 문 추가
intention.add.single.member.static.import.family=Add Single-Member Static Import
intention.add.single.member.static.import.text=''{0}''의 정적 import 문 추가
intention.assign.field.from.parameter.family=Assign Parameter to Field
intention.assign.field.from.parameter.text=Assign Parameter to Field ''{0}''
intention.bind.fields.from.parameters.family=매개변수를 필드에 바인딩
intention.bind.fields.from.parameters.text={0} 매개변수를 필드에 바인딩
intention.break.string.on.line.breaks.text=''\\n''에서 문자열 줄 바꿈
intention.compose.function.family=중첩 함수 호출을 구성으로 바꾸기
intention.compose.function.text=중첩 함수 호출을 andThen 호출로 바꾸기
intention.convert.color.representation.family=Color 표현 변환
intention.convert.color.representation.text=''새 색상 {0}''(으)로 변환
intention.convert.compact.constructor.to.canonical=압축 생성자를 표준으로 변환
intention.convert.to.single.return.name=본문을 단일 종료점 형식으로 변환
intention.convert.to.single.return.progress.title=본문을 단일 종료점 형식으로 변환
intention.convert.to.single.return.command.text=본문을 단일 종료점 형식으로 변환
intention.create.field.from.parameter.family=매개변수 필드 생성
intention.create.field.from.parameter.text=매개변수 ''{0}''의 필드 생성
intention.create.test.dialog.choose.super.class=상위 클래스 선택
intention.create.test.dialog.class.name=클래스 이름\:
intention.create.test.dialog.fix.library=수정
intention.create.test.dialog.generate=\ 생성\:
intention.create.test.dialog.java=Java
intention.create.test.dialog.library.not.found=모듈에서 {0} 라이브러리를 찾을 수 없습니다
intention.create.test.dialog.select.methods=다음에 대한 테스트 메서드 생성(&M)\:
intention.create.test.dialog.setUp=setUp(&U)/@Before
intention.create.test.dialog.show.inherited=상속된 메서드 표시(&I)
intention.create.test.dialog.super.class=상위 클래스\:
intention.create.test.dialog.tearDown=tearDown(&D)/@After
intention.create.test.dialog.testing.library=라이브러리 테스트(&L)\:
intention.encapsulate.field.text=필드 캡슐화
intention.error.cannot.create.class.message=클래스 ''{0}''을(를) 생성할 수 없습니다
intention.error.cannot.create.class.title=클래스 생성 실패
intention.extract.if.condition.family=if 조건 추출
intention.extract.if.condition.text=if ({0}) 추출
intention.extract.map.step.family=별도의 매핑 메서드로 추출
intention.extract.map.step.text=변수 ''{0}''을(를) ''{1}'' 작업으로 추출
intention.extract.method.text=메서드 추출
intention.extract.set.from.comparison.chain.duplicates={0}이(가) 이 클래스에서 {1} 개 코드 {1,choice,1\#조각 |2\#조각} 을 탐지했습니다. 이 코드 조각은 새로 만든 세트를 사용하여 바꿀수 있습니다. {1,choice,1\#코드 조각|2\#코드 조각}을 바꾸시겠어요?
intention.extract.set.from.comparison.chain.family=비교 체인에서 Set 추출
intention.family.add.javadoc=Javadoc 추가
intention.family.convert.0.path.to.1={0} 경로를 {1}(으)로 변환
intention.family.copy.abstract.method.implementation=추상 메서드 구현 복사
intention.family.create.a.class.in.package=패키지에서 클래스 생성
intention.family.edit.method.contract=메서드 컨트랙트 편집
intention.family.edit.range=범위 편집
intention.family.expand.static.import=정적 import 문 확장
intention.family.fix.bounded.wildcards=제한된 와일드카드 수정
intention.family.make.external.annotations.explicit=외부 어노테이션을 명시적으로 작성
intention.family.make.inferred.annotations.explicit=추론된 어노테이션을 명시적으로 작성
intention.family.move.it=이동
intention.family.put.arguments.on.one.line=인수를 한 줄에 배치
intention.family.put.arguments.on.separate.lines=인수를 별도의 줄에 배치
intention.family.put.parameters.on.one.line=매개변수를 한 줄에 배치
intention.family.put.parameters.on.separate.lines=매개변수를 별도의 줄에 배치
intention.family.replace.optional.ispresent.condition.with.functional.style.expression=Optional.isPresent() 조건을 함수 스타일 표현식으로 바꾸기
intention.family.sort.content=콘텐츠 정렬
intention.family.swap.if.statements=''if'' 문 대체
intention.family.unimplement.interface.class=인터페이스/클래스 구현 취소
intention.family.variable.access.from.inner.class=accessFromInnerClass 변수
intention.implement.abstract.class.default.text=추상 클래스 구현
intention.implement.abstract.class.family=추상 클래스 또는 인터페이스 구현
intention.implement.abstract.method.command.name=메서드 구현
intention.implement.abstract.method.error.no.classes.message=이 메서드를 구현할 수 있는 클래스가 없습니다
intention.implement.abstract.method.error.no.classes.title=클래스를 찾을 수 없습니다
intention.implement.abstract.method.family=추상 메서드 구현
intention.implement.abstract.method.searching.for.descendants.progress=하위 항목 검색 중...
intention.implement.abstract.method.text=메서드 ''{0}'' 구현
intention.inline.map.family=스트림 매핑 메서드 인라인화
intention.inline.map.inline.text=''{0}'' 본문을 다음 ''{1}'' 호출로 인라인화
intention.inline.map.merge.text=''{0}'' 호출 및 ''{1}'' 호출 병합
intention.introduce.variable.text=지역 변수 삽입
intention.invert.if.condition=''if'' 조건을 반전시킵니다
intention.merge.filter.family=필터 병합
intention.merge.filter.text=필터 체인 병합
intention.move.field.assignment.to.declaration=할당을 필드 선언으로 이동
intention.move.initializer.to.constructor=이니셜라이저를 생성자로 이동
intention.move.initializer.to.set.up=이니셜라이저를 setUp 메서드로 이동
intention.override.method.text=메서드 ''{0}'' 재정의
intention.replace.cast.with.var.family=형 변환을 변수로 바꾸기
intention.replace.cast.with.var.text=''{0}''을(를) ''{1}''(으)로 바꾸기
intention.replace.concatenation.with.formatted.output.family=Replace Concatenation with Formatted Output
intention.replace.concatenation.with.formatted.output.text=\ ''+''를 ''java.text.MessageFormat.format()''으로 바꾸기
intention.split.declaration.assignment.text=선언 및 할당 분할
intention.split.declaration.family=Split Declaration
intention.split.filter.family=필터 분할
intention.split.filter.text=필터 체인으로 분할
intention.split.if.family=Split If
intention.split.if.text=''if'' 문 2개로 분할
intention.split.switch.branch.with.several.case.values.copy.text=\ ''switch'' 브랜치 복사
intention.split.switch.branch.with.several.case.values.family=여러 대/소문자 값이 있는 switch 브랜치를 개별 ''switch'' 브랜치로 분할
intention.split.switch.branch.with.several.case.values.split.text=''switch'' 브랜치 값 분할
intention.surround.resource.with.ARM.block=try-with-resource 블록으로 둘러싸기
intention.surround.with.ARM.block.template=try-with-resources
intention.text.add.method.contract.to.0=메서드 컨트랙트 ''{0}''에 추가
intention.text.add.range.to.0=범위를 ''{0}''에 추가
intention.text.annotate.externally=외부에 어노테이션 추가
intention.text.collapse.repeating.annotations=반복되는 어노테이션 접기
intention.text.convert.path.to.0=경로를 {0}(으)로 변환
intention.text.create.a.class.in.0=''{0}''에 클래스 생성
intention.text.edit.method.contract.of.0=''{0}'' 메서드 컨트랙트 편집
intention.text.edit.range.of.0=''{0}'' 범위 편집
intention.text.fix.method.0.parameters.with.bounded.wildcards=제한된 와일드 카드가 있는 메서드 ''{0}'' 매개변수 수정
intention.text.generate.missed.test.methods=누락된 테스트 메서드 생성
intention.text.insert.0.annotation=''{0}''을(를) 삽입합니다
intention.text.replace.implements.with.static.import=구현을 정적 import 문으로 바꾸기
intention.text.replace.static.import.with.qualified.access.to.0=정규화된 액세스가 있는 정적 import 문을 {0}로 바꾸기
intention.text.unimplement.0={0} 구현 취소
intention.unroll.loop.family=루프 언롤링
intention.unwrap.else.branch=''else'' 브랜치 줄 바꿈 해제
intention.unwrap.else.branch.changes.semantics=''else'' 브랜치 줄 바꿈 해제(의미 변경)
intention.use.single.member.static.import.text=''{0}''의 정적 import 문 사용
intention.wrap.with.unmodifiable=수정 불가한 컬렉션 또는 맵으로 래핑
intention.wrap.with.unmodifiable.list=수정 불가한 목록으로 래핑
intention.wrap.with.unmodifiable.map=수정 불가한 맵으로 래핑
intention.wrap.with.unmodifiable.set=수정 불가한 세트로 래핑
interface.not.allowed=인터페이스는 허용되지 않습니다
java.line.markers=Java 줄 마커
java.preview.features.accept.notification.link=동의
java.preview.features.alert.title=실험적 기능 경고
java.preview.features.legal.notice="{0}" 지원을 사용하려면 베타 Java 사양의 법적 고지 약관에 동의해야 합니다.<br/><br/><b>Java 커뮤니티 프로세스(JCP)에서 개발된 초안의 구현은 테스트 및 평가 목적으로만 제공되며 JCP 사양과 호환되지 않습니다.</b>{1}
java.preview.features.notification.title=Java 테스트 버전 기능
java.preview.features.warning=최신 IDE 버전에서는 테스트 버전 기능에 대한 지원이 중단될 수 있습니다. Java {0}이(가) 출시되면 {1}(테스트 버전) 언어 수준에 대한 지원이 중단될 수 있습니다
java.terms.exception=예외
java.terms.instance.initializer=인스턴스 이니셜라이저
java.terms.of.annotation.type=어노테이션 타입 {1}의 {0}
java.terms.of.anonymous.class=익명 클래스의 {0}
java.terms.of.class=클래스 {1}의 {0}
java.terms.of.enum=열거형 {1}의 {0}
java.terms.of.interface=인터페이스 {1}의 {0}
java.terms.static.initializer=정적 이니셜라이저
java.terms.type.parameter=타입 매개변수
java.terms.variable.of.method={1}의 {0}
javadoc.candidates.not.found=<html>메서드 호출 <b>{0}</b>의 후보를 찾을 수 없습니다.</html>
javadoc.constructor.candidates=<html>to <b>{0}</b>()의 후보\:<br>{1}</html>
javadoc.deprecated=중단된 기능
javadoc.description.copied.from.class=클래스에서 복사된 설명\:
javadoc.description.copied.from.field=필드에서 복사된 설명\:
javadoc.description.copied.from.interface=인터페이스에서 복사된 설명\:
javadoc.generate.arguments=기타 명령줄 인수(&O)\:
javadoc.generate.exited=$EXIT_CODE$ 종료 코드로 완료된 "javadoc"
javadoc.generate.heap.size=최대 힙 크기(Mb)(&M)\:
javadoc.generate.include.jdk.library.sources.in.sourcepath.option=\ -sourcepath의 JDK 및 라이브러리 소스 포함
javadoc.generate.link.to.jdk.documentation.option=JDK 문서에 링크(-link 옵션 사용)
javadoc.generate.locale=로케일(&L)\:
javadoc.generate.no.classes.in.selected.packages.error=선택한 범위에 포함된 Java 클래스가 없습니다
javadoc.generate.no.jdk=프로젝트에 대해 구성된 Java SDK가 없어 JavaDoc을 생성할 수 없습니다. ''설정 | 프로젝트 구조''에서 Java SDK를 지정하세요.
javadoc.generate.no.javadoc.tool={0} 또는 {1}에 javadoc 도구가 없어 JavaDoc을 생성할 수 없습니다. ''설정 | 프로젝트 구조''에서 올바른 Java SDK를 지정하세요.
javadoc.generate.open.in.browser=브라우저에서 생성된 문서 열기(&G)
javadoc.generate.options.hierarchy=계층 구조 트리 생성
javadoc.generate.options.index=색인 생성
javadoc.generate.options.index.per.letter=문자별 색인 분리
javadoc.generate.options.navigator=내비게이션 바 생성
javadoc.generate.output.directory=출력 디렉터리(&D)\:
javadoc.generate.output.directory.browse=출력 디렉터리 찾아보기
javadoc.generate.sources.progress=Javadoc을 생성할 소스 검색
javadoc.generate.tag.list.deprecated=곧 사용할 수 없게 될 목록
javadoc.generate.temp.file.error=임시 파일을 생성할 수 없습니다
javadoc.generate.temp.file.does.not.exist=임시 파일이 없거나 해당 파일을 열 수 없습니다
javadoc.generate.title=JavaDoc 생성
javadoc.method.in.class=클래스 {1}의 {0}
javadoc.method.in.interface=인터페이스 {1}의 {0}
javadoc.method.overrides=재정의\:
javadoc.method.specified.by=다음에 따라 지정\:
javadoc.option.automatically.insert.closing.tag.javadoc=JavaDoc에서 닫는 태그를 자동으로 삽입
javadoc.option.javadoc.title=JavaDoc
javadoc.see.also=관련 주제\:
javadoc.settings.title=Javadoc
javadoc.since=시작 시간\:
javadoc.author=작성자\:
javadoc.version=버전\:
javadoc.apiNote=API 참고 사항\:
javadoc.implNote=구현 참고 사항\:
javadoc.implSpec=구현 요건\:
javadoc.type.parameters=타입 매개변수\:
jrt.node.short=[JRT]
label.add.math.max.0.count.to.avoid.possible.semantics.change=가능한 의미 변경을 피하려면 Math.max(0, count)를 추가합니다
label.class.filter.editor.add.dialog.filter.pattern=필터 패턴을 입력하세요\:
label.contract=컨트랙트\:
label.enter.fully.qualified.class.name=정규화된 클래스 이름 입력
label.entry.points=진입점\:
label.forbid.api.usages=API 사용 금지\:
label.from.inclusive=출처(포괄적)\:
label.implementation=구현\:
label.implements.method.of_class_or_interface.name={0, choice, 0\#인터페이스|1\#클래스} ''{1}''의 메서드를 구현합니다.
label.implements.method.of_interfaces=다음 클래스/인터페이스의 메서드를 구현합니다.
label.maximal.reported.method.visibility=보고된 메서드의 최대 가시성\:
label.method=메서드 ''{0}''
label.minimal.reported.method.usage.count=보고된 메서드의 최소 사용 횟수\:
label.minimal.reported.method.visibility=보고된 메서드의 최소 가시성\:
label.mutates=변이\:
label.name.prefix=이름 접두사\:
label.name.suffix=이름 접미사\:
label.naming.field=필드\:
label.naming.local.variable=지역 변수\:
label.naming.parameter=매개변수\:
label.naming.static.field=정적 필드\:
label.naming.subclass=하위 클래스\:
label.naming.test.class=테스트 클래스\:
label.overrides.method.of_class_or_interface.name={0, choice, 0\#인터페이스|1\#클래스} ''{1}''의 메서드를 재정의합니다.
label.show.import.popup.for=다음에 대한 자동 가져오기 툴팁 표시\:
label.to.inclusive=대상(포괄적)\:
label.unused.declaration.reachable.from.tests.option=진입점이 테스트 소스에 있는 경우 피호출자를 다음으로 표시\:
line.marker.recursive.call=재귀적 호출
line.marker.type.external.annotations=외부 어노테이션
line.marker.type.inferred.contract.annotations=추론된 컨트랙트 어노테이션
line.marker.type.inferred.nullability.annotations=추론된 nullability 어노테이션
listbox.import.package=패키지
listbox.import.static=정적
listbox.import.with.subpackages=하위 패키지 포함
# suppress inspection "UnusedProperty"
macro.array.variable=arrayVariable()
macro.class.name=클래스 이름
macro.classpath.entry=요소가 속한 클래스 경로의 항목
macro.component.type.of.array=componentTypeOf(Array)
macro.descendant.classes.enum=descendantClassesEnum(문자열)
macro.expression.type=expressionType(Expression)
macro.file.fully.qualified.package=정규화된 패키지 보관
macro.file.package=패키지 보관
macro.guess.element.type.of.container=guessElementType(Container)
macro.iterable.component.type=iterableComponentType(ArrayOrIterable)
# suppress inspection "UnusedProperty"
macro.iterable.variable=iterableVariable()
macro.javadoc.output.directory=JavaDoc 출력 디렉터리
macro.project.classpath=프로젝트의 클래스 경로
macro.variable.of.type=variableOfType(타입)
methods.to.implement.chooser.title=구현할 메서드 선택
methods.to.override.chooser.title=재정의할 메서드 선택
methods.to.override.implement.chooser.title=재정의/구현할 메서드 선택
module.not.in.requirements=''{0}'' 모듈의 요구 사항에 ''{1}'' 모듈이 포함되지 않습니다
module.package.not.exported=''{0}'' 모듈은 ''{1}'' 패키지를 ''{2}'' 모듈로 내보내지 않습니다
module.package.not.open=''{0}'' 모듈은 ''{1}'' 패키지를 ''{2}'' 모듈로 열지 않습니다
module.type.java.description=Java 모듈은 <b>Java EE</b> 및 기타 엔터프라이즈 개발 프레임워크를 사용하는 애플리케이션을 포함하여 <b>JVM 기반</b> 데스크톱 및 웹 애플리케이션 개발에도 사용할 수 있습니다.
module.type.java.name=Java 모듈
navigate.to.duplicate.fix=중복으로 이동
no.methods.overriding.0.are.found={0,choice,0\#|1\#"{1}"을(를)|2\#이 클래스를} 재정의하는 메서드를 찾을 수 없습니다
no.patterns=클래스 패턴이 구성되지 않았습니다
node.call.hierarchy.unknown.jsp=알 수 없는 JSP
node.hierarchy.java.lang.object=모든 클래스는 java.lang.Object에서 파생됩니다
notification.navigation.to.overriding.classes=색인 업데이트 중에는 클래스를 재정의하는 탐색이 불가능합니다
notification.navigation.to.overriding.methods=색인 업데이트 중에는 메서드를 재정의하는 탐색이 불가능합니다
notification.text.full.thread.dump.was.successfully.copied.to.clipboard=전체 스레드 덤프가 클립보드에 복사됨
nullable.notnull.annotations.panel.title={0} 어노테이션
nullable.notnull.annotations.runtime.instrumentation.tooltip=notnull 어노테이션이 추가된 메서드 및 매개변수에 대한 런타임 어설션 추가
nullable.notnull.configuration.dialog.title=Null/NotNull 구성
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.name=''null'' 인수 사용 위치로 이동
nullable.stuff.inspection.navigate.null.argument.usages.view.name=매개변수 {0}에 대한 ''null'' 인수 사용 위치
offline.inspections.jdk.not.found={0}(을)를 찾을 수 없음
offline.inspections.library.urls.were.not.resolved=모듈 ''{2}''에서 라이브러리 ''{1}''의 루트 {0}(이)가 해결되지 않음
offline.inspections.library.was.not.resolved=모듈 ''{1}''에 사용되는 라이브러리 ''{0}''(을)를 구성하세요.
offline.inspections.no.source.roots=모듈 ''{0}''에 대해 검색된 소스 루트가 없습니다
options.java.attribute.descriptor.abstract.class=클래스 및 인터페이스//추상 클래스
options.java.attribute.descriptor.abstract.method=메서드//Abstract method
options.java.attribute.descriptor.annotation.attribute.name=어노테이션//Annotation attribute name
options.java.attribute.descriptor.annotation.name=어노테이션//Annotation name
options.java.attribute.descriptor.anonymous.class=클래스 및 인터페이스//익명 클래스
options.java.attribute.descriptor.class=Classes and Interfaces//클래스
options.java.attribute.descriptor.constructor.call=메서드//Constructor call
options.java.attribute.descriptor.constructor.declaration=메서드//Constructor declaration
options.java.attribute.descriptor.enum=클래스 및 인터페이스//열거형
options.java.attribute.descriptor.implicit.anonymous.parameter=매개변수//Implicit anonymous class parameter
options.java.attribute.descriptor.inherited.method=메서드//Inherited method
options.java.attribute.descriptor.instance.field=클래스 필드//인스턴스 필드
options.java.attribute.descriptor.instance.final.field=클래스 필드//인스턴스 최종 필드
options.java.attribute.descriptor.interface=Classes and Interfaces//인터페이스
options.java.attribute.descriptor.javadoc.comment=주석//JavaDoc//텍스트
options.java.attribute.descriptor.javadoc.markup=주석//JavaDoc//Markup
options.java.attribute.descriptor.javadoc.tag=주석//JavaDoc//꼬리표
options.java.attribute.descriptor.javadoc.tag.value=주석//JavaDoc//Tag value
options.java.attribute.descriptor.lambda.parameter=매개변수//Lambda parameter
options.java.attribute.descriptor.method.call=메서드//Method call
options.java.attribute.descriptor.method.declaration=메서드//Method declaration
options.java.attribute.descriptor.method.imported.call=메서드//Static imported method call
options.java.attribute.descriptor.reassigned.local.variable=변수//Reassigned local variable
options.java.attribute.descriptor.reassigned.parameter=매개변수//Reassigned parameter
options.java.attribute.descriptor.static.field=클래스 필드//정적 필드
options.java.attribute.descriptor.static.final.field=Class Fields//상수 (static final field)
options.java.attribute.descriptor.static.final.imported.field=Class Fields//상수 (static final imported field)
options.java.attribute.descriptor.static.imported.field=클래스 필드//가져온 정적 필드
options.java.attribute.descriptor.static.method=메서드//Static method
options.java.attribute.descriptor.type.parameter=매개변수//Type parameter
options.java.display.name=Java
override.implement.broken.file.template.message="재정의/구현된 메서드 본문" 템플릿을 수정하세요.
override.implement.broken.file.template.title=파일 템플릿 오류
package.dependencies.production.node.text=프로덕션 클래스
package.dependencies.test.node.text=테스트 클래스
paste.class.command.name=클래스 ''{0}'' 붙여넣기
please.report.a.bug=버그를 신고해 주세요.
popup.title.choose.framework=프레임워크 선택
popup.title.choose.test=테스트 선택
popup.title.select.a.jar.file=JAR 파일 선택
popup.title.select.qualified.name=정규화된 이름 선택
postfix.template.language.level.title=최소 언어 수준\:
press.0.to.see.inheritors.of.1={1}의 상속자를 확인하려면 {0}(을)를 누릅니다
press.0.to.see.non.imported.classes=가져오지 않은 클래스를 확인하려면 {0}(을)를 누릅니다
pressing.0.twice.without.a.class.qualifier=클래스 한정자 없이 {0}(을)를 2회 누르면 액세스 가능한 모든 정적 메서드가 표시됩니다
project.problems.hint.text={0}개의 관련 {0, choice, 0\#문제|2\#문제}
project.problems.window.title={0} 관련 문제
project.problems.fix.text=관련 문제 표시
project.problems.fix.description={0} 관련 문제 발견
project.problems.title=관련 문제
project.problems.settings=Ajustes...
progress.creating.class=클래스 {0} 생성 중
progress.title.check.applicability=적용 가능성 확인...
progress.title.download.library.descriptor=라이브러리 설명자 다운로드
progress.title.find.references.in.implement.extends.lists=목록 구현/확장에서 참조 찾기...
progress.title.finding.cause=원인 찾는 중
progress.title.looking.for.jdk.locations=JDK 위치 검색 중...
progress.title.looking.for.libraries=라이브러리 검색 중
progress.title.optimize.imports=import 문 최적화...
progress.title.preprocess.usages=사용 위치 전처리
progress.title.search.for.overriding.methods=재정의 메서드 검색...
progress.title.searching.for.sub.classes=하위 클래스 검색 중
prompt.choose.base.class.of.the.hierarchy=검색할 계층 구조의 기본 클래스를 선택하세요.
prompt.create.non.existing.package=패키지 {0}이(가) 없습니다.\n생성하시겠어요?
prompt.delete.class={0,choice,1\#클래스|2\#클래스}
prompt.delete.field={0,choice,1\#필드|2\#필드}
prompt.delete.interface={0,choice,1\#인터페이스|2\#인터페이스}
prompt.delete.method={0,choice,1\#메서드|2\#메서드}
prompt.delete.package={0,choice,1\#패키지|2\#패키지}
prompt.delete.type.parameter={0,choice,1\#타입 매개변수|2\#타입 매개변수}
prompt.do.you.want.to.action_verb.the.method.from_class=대신 기본 {0,choice,1\#메서드|2\#메서드}를 리팩터링하시겠어요?
psi.search.overriding.progress=Search for Overriding Methods
quickfix.add.variable.family.name=변수 초기화
quickfix.add.variable.text=변수 ''{0}'' 초기화
quickfix.family.avoid.mutation.using.stream.api=Stream API를 사용한 변이 방지
quickfix.family.change.javadoc.to=다음으로 변경...
quickfix.family.find.cause=원인 찾기
quickfix.family.remove.javadoc.tag=태그 제거
quickfix.family.remove.redundant.parameter=중복 매개변수 제거
quickfix.family.remove.redundant.parameter.types=중복 매개변수 타입 제거
quickfix.family.replace.cast.type=형 변환 타입 바꾸기
quickfix.family.replace.inefficient.stream.count=비효율적인 Stream.count() 바꾸기
quickfix.family.replace.optional.chain.with.if.statements=Optional 체인을 if 문으로 바꾸기
quickfix.family.replace.stream.api.chain.with.loop=스트림 API 체인을 루프로 바꾸기
quickfix.family.replace.with.java.stream.api.pipeline=Java Stream API 파이프라인으로 바꾸기
quickfix.family.replace.with.magic.constant=매직 상수로 바꾸기
quickfix.family.replace.with.method.reference=메서드 참조로 바꾸기
quickfix.family.replace.with.optional.of.nullable.chain=Optional.ofNullable() 체인으로 교
quickfix.family.replace.with.stream.api.equivalent=Stream API와 동등한 기능으로 바꾸기
quickfix.family.simplify.foreach.lambda=forEach 람다 단순화
quickfix.family.simplify.stream.call.chain=스트림 통화 체인 단순화
quickfix.family.use.flatmap=''flatMap'' 사용
quickfix.family.wrap.with.mutable.collection=변이 가능한 컬렉션으로 래핑
quickfix.name.find.jar.on.web=웹에서 JAR 찾기
quickfix.text.0.may.not.work.before.jdk.11.0.2={0}(JDK 11.0.2 이전 버전에서 작동하지 않을 수 있습니다 .)
quickfix.text.avoid.mutation.using.stream.api.0.operation=Stream API ''{0}'' 연산자를 사용하여 변이 방지
quickfix.text.remove.javadoc.0=''@{0}'' 태그 제거
quickfix.text.remove.javadoc.0.1=@{0} {1} 제거
quickfix.text.remove.not.null.annotation=not-null 어노테이션 제거
quickfix.text.replace.0.stream.with.1.2={0}.stream()을 {1}.{2}()(으)로 바꾸기
quickfix.text.replace.collect.0.with.1.2=''collect({0}())''를 ''{1}''{2}(으)로 바꾸기
quickfix.text.replace.filter.0.is.present.with.any.match=''filter().{0}().isPresent()''를 ''anyMatch()''로 바꾸기
quickfix.text.replace.stream.0.with.1.2=''stream().{0}()''을 ''{1}()''{2}(으)로 바꾸기
quickfix.text.suffix.may.change.semantics=\ (의미가 변경될 수 있습니다)
quickfix.text.wrap.0.with.1=''{0}''을(를) ''{1}''(으)로 래핑
radio.button.higher.than=다음 값 초과\:
radio.button.respecting.to.project.language.level.settings=프로젝트 언어 수준 설정을 준수
radio.button.subclass.of.0=''{0}''의 하위 클래스
radio.button.unused.declaration.unused.option=사용하지 않는
radio.button.unused.declaration.used.option=사용
radio.button.with.provider.method=\ ''provider()'' 메서드로
radio.use.fully.qualified.class.names.in.javadoc=JavaDoc에서 정규화된 클래스 이름 사용\:
radio.use.fully.qualified.class.names.in.javadoc.always=항상
radio.use.fully.qualified.class.names.in.javadoc.if.not.imported=아직 가져오지 않은 경우
radio.use.fully.qualified.class.names.in.javadoc.never=사용 안함, 단축이름을 사용하고 import를 추가합니다
scope.hierarchy={0}의 계층 구조
sdk.cannot.create=SDK를 생성할 수 없습니다
sdk.java.no.classes=''{0}''에서 JDK 클래스를 찾을 수 없음
section.title.inspection.suspicious.names.ignore.methods=메서드 무시
set.language.level=언어 수준 설정
set.language.level.to.0=언어 수준을 {0}(으)로 설정
settings.completion.ml.java.display.name=Java
settings.inlay.java.annotations=어노테이션
settings.inlay.java.builder.like.methods=빌더와 같은 메서드
settings.inlay.java.complex.expressions.binary.functional.array.access.and.other=복잡한 표현식\: 이항, 함수, 배열 액세스 및 기타
settings.inlay.java.enum.constants=열거형 상수
settings.inlay.java.external.annotations=외부 어노테이션
settings.inlay.java.inferred.annotations=추론된 어노테이션
settings.inlay.java.inheritors=상속자
settings.inlay.java.insert.annotation=어노테이션 삽입
settings.inlay.java.method.chains=메서드 체인
settings.inlay.java.implicit.types=묵시적 타입
settings.inlay.java.methods.with.same.named.numbered.parameters=동일한 이름 및 숫자의 매개변수가 포함된 메서드
settings.inlay.java.minimal.unique.type.count.to.show.hints=힌트를 표시하는 고유한 타입의 최소 개수
settings.inlay.java.new.expressions=''New'' 표현식
settings.inlay.java.non.literals.in.case.of.multiple.parameters.with.the.same.type=동일한 타입의 매개변수가 여러 개일 경우의 비 리터럴
settings.inlay.java.parameters.with.names.that.are.contained.in.the.method.name=메서드 이름에 포함된 이름이 있는 매개변수
settings.inlay.java.show.hints.for=다음에 대한 힌트 표시\:
settings.inlay.java.show.parameter.hints.for=다음에 대한 매개변수 힌트 표시\:
settings.inlay.java.show.parameter.hints.when.expression.type.is.clear.description=배열 이니셜라이저, 전환, 조건, 참조, 인스턴스, 할당, 호출, 정규화된, 타입 형 변환, 클래스 객체 액세스 식.
settings.inlay.java.turn.off.external.annotations=외부 어노테이션 사용 해제
settings.inlay.java.turn.off.inferred.annotations=추론된 어노테이션 사용 해제
settings.inlay.java.usages=사용 위치
show.import.popup.for.classes=클래스(&C)\:
show.import.popup.for.static.methods.and.fields=정적 메서드 및 필드(&S)
exclude.import.wildcard.comment=지정된 클래스나 패키지의 모든 멤버를 제외하려면 * 와일드카드를 사용하세요.
special.annotations.annotations.list=추가 특수 어노테이션
special.annotations.list.add.annotation.class=어노테이션 클래스 추가
special.annotations.list.annotation.class=어노테이션 클래스
special.annotations.list.annotation.pattern.message=어노테이션 패턴 추가
special.annotations.list.annotation.pattern=어노테이션 패턴 추가
special.annotations.list.remove.pattern=제거
spi.extension.error.message=등록된 확장자는 {0}(을)를 구현해야 합니다
spi.file.type.description=서비스 공급자 인터페이스
spi.no.provider.error.message=서비스 공급자 "{0}"(을)를 찾을 수 없습니다
status.bar.overridden.methods.highlighted.message={0} 개의 재정의된 {0, choice, 1\#메서드|2\#메서드}가 발견되었습니다 (강조 표시를 제거하려면 {1}을(를) 다시 누르고, 모든 강조 표시를 제거하려면 이스케이프하세요)
surround.with.dowhile.template=do / while
surround.with.for.template=for
surround.with.ifelse.expression.template=if (expr) {...} else {...}
surround.with.not.instanceof.template=\!(expr instanceof 타입)
surround.with.runnable.template=Runnable
surround.with.synchronized.template=synchronized
surround.with.try.catch.finally.template=try / catch / finally
surround.with.try.catch.incorrect.template.message=Catch Body\!에 대한 잘못된 파일 템플릿
surround.with.try.catch.incorrect.template.title=Try / Catch로 둘러싸기
surround.with.try.catch.template=try / catch
tab.title.entry.points=진입점
tab.title.members.to.report=보고할 멤버
table.cell.constructors=생성자
title.cannot.create.class=클래스를 생성할 수 없음
title.import.layout=레이아웃 가져오기
title.javadoc=JavaDoc
title.naming=이름 지정
title.naming.final.modifier=Final 제어자
title.naming.functional.expressions=람다 본문
title.package.not.found=패키지를 찾을 수 없음
title.packages=패키지
title.packages.to.use.import.with=''*''가 포함된 import 문을 사용하는 패키지
to.import.a.method.statically.press.0=메서드를 정적으로 가져오려면 {0}(을)를 누릅니다
unscramble.detect.analyze.threaddump.from.clipboard.item=IntelliJ IDEA 외부의 클립보드에 복사된 스레드 덤프를 자동으로 감지하고 분석합니다
unscramble.log.path.label=로그 파일(&L)\:
unscramble.no.unscrambler.item=<해독기 설치 안 됨>
unscramble.normalize.button=정규화(&N)
unscramble.stacktrace.caption=여기에 스택 추적 또는 전체 스레드 덤프 넣기\:
unscramble.unscrambled.deadlock.tab=<교착상태>
unscramble.unscrambled.stacktrace.tab=<스택추적>
unscramble.unscrambled.threaddump.tab=<스레드>
unscramble.unscrambler.combobox=해독기(&S)\:
unscramble.use.unscrambler.checkbox=스택 추적 해독(&U)
unwrap.anonymous=''anonymous...'' 줄 바꿈 해제
unwrap.array.initializer=배열 이니셜라이저 줄 바꿈 해제
unwrap.conditional=''f ? a \: b'' 줄 바꿈 해제
unwrap.lambda=''람다...'' 줄 바꿈 해제
unwrap.synchronized=''synchronized...'' 줄 바꿈 해제
unwrap.switch.expression=''switch'' 식 줄 바꿈 해제
unwrap.switch.statement=''switch'' 문 줄 바꿈 해제
usage.target.exception=예외
usage.target.package.in.directory=({1}의) {0}
use.external.annotations=외부 어노테이션 사용(&E)
wrapping.annotation.parameters=어노테이션 매개변수
wrapping.record.components=구성 요소 기록
wrapping.text.blocks=텍스트 블록
wrong.package.statement=잘못된 package 문
title.code.vision=Code Vision
highlight.throws.popup.throwing.places={0}을(를) 던지는 위치
highlight.throws.popup.usages=\ {0} 사용 위치
psi.error.incorrect.class.template.message={0} 생성 불가 - 잘못된 {1} 템플릿
presentable.text.anonymous.class=익명 클래스
presentable.text.code.from.context={0}의 코드
presentable.text.code.display=코드
presentable.text.invalid.element.name=유효하지 않음
inspection.simplify.for.each.replace={0}(으)로 바꾸기
inspection.simplify.for.each.extract.intermediate.operations=중간 연산 추출
inspection.message.can.be.replaced.with.files.writestring=''Files.writeString()''으로 바꾸기 가능
inspection.notnull.field.not.initialized.message={0} 필드는 초기화되어야 합니다
highlight.throws.class.name={0} throw 강조 표시
class.patterns.panel.add.class=클래스 추가하기
multiple.usages.of.static.import.found=발견된 정적 import 문의 여러 사용 위치
external.annotations.roots=어노테이션 루트
inspection.stream.api.migration.can.be.replaced.with.call=''{0}'' 호출로 바꾸기 가능
highlight.suppressed.warnings.choose.inspections=다음에서 억제된 문제를 강조 표시할 검사를 선택\:
inspection.magic.constants.should.be.one.of.values=다음 중 하나입니다. {0}{1,choice,0\#|1\# 또는 그 조합}
live.template.context.consumer.function=consumer 함수
live.template.context.statement=구문
live.template.context.expression=표현식
live.template.context.declaration=선언
inspection.unused.display.name=사용되지 않는 선언
inspection.empty.method.display.name=빈 메서드
inspection.unused.assignment.display.name=사용하지 않는 할당
inspection.unchecked.warning.display.name=검증되지 않은 경고
inspection.convert.2.streamapi.display.name=Stream API를 사용하면 루프를 접을 수 있습니다
inspection.optional.to.if.display.name=Optional은 if 문 시퀀스로 바꿀 수 있습니다.
inspection.stream.to.loop.display.name=Stream API 호출 체인은 루프로 바꿀 수 있습니다
inspection.anonymous.2.method.ref.display.name=익명 타입은 메서드 참조로 바꿀 수 있습니다
inspection.convert.2.method.ref.display.name=람다는 메서드 참조로 바꿀 수 있습니다
inspection.lambda.can.be.method.call.display.name=람다는 메서드 호출로 바꿀 수 있습니다
inspection.functional.expression.can.be.folded.display.name=함수식은 접을 수 있습니다
inspection.trivial.functional.expression.usage.display.name=함수식의 자명한 사용 위치
inspection.magic.constant.display.name=매직 상수
inspection.static.pseudo.functional.style.method.display.name=static 클래스를 사용하는 의사 함수식
inspection.overwritten.key.display.name=덮어쓰기한 Map 키 또는 Set 요소
inspection.collection.add.all.can.be.replaced.with.constructor.display.name=중복 ''Collection.addAll()'' 호출
inspection.manual.min.max.calculation.display.name=최소/최대 수동 계산
inspection.explicit.array.filling.display.name=명시적 배열 채우기
inspection.java.8.collection.remove.if.display.name=루프는 Collection.removeIf()로 바꿀 수 있습니다.
inspection.java.8.map.api.display.name=단일 Map 메서드를 사용할 수 있습니다.
inspection.string.repeat.can.be.used.display.name=String.repeat()을 사용할 수 있습니다
inspection.read.write.string.can.be.used.display.name=''Files.readString()'' 또는 ''Files.writeString()''을 사용할 수 있습니다
inspection.java.9.collection.factory.display.name=불변 컬렉션 생성을 컬렉션 팩토리 호출로 바꿀 수 있습니다
inspection.explicit.argument.can.be.lambda.display.name=묵시적 인수가 람다일 수 있습니다
inspection.excessive.lambda.usage.display.name=과도한 람다 사용
inspection.redundant.stream.optional.call.display.name=Stream 또는 Optional 호출 체인의 중복 단계
inspection.obvious.null.check.display.name=null 검사 메서드는 명백히 null이 아닌 인수로 호출됩니다
inspection.simplify.stream.api.call.chains.display.name=Stream API 호출 체인을 간소화할 수 있습니다
inspection.simplify.optional.call.chains.display.name=Optional API 호출 체인을 간소화할 수 있습니다
inspection.simplify.collector.display.name=컬렉터를 간소화할 수 있습니다.
inspection.use.bulk.operation.display.name=반복 대신 대량 연산을 사용할 수 있습니다
inspection.comparator.combinators.display.name=비교자 조합기를 사용할 수 있습니다.
inspection.replace.inefficient.stream.count.display.name=count()로 끝나는 비효율적 Stream API 호출 체인
inspection.redundant.lambda.parameter.type.display.name=중복 람다 매개변수 타입
inspection.wrapper.type.may.be.primitive.display.name=래퍼 타입은 기본일 수 있습니다
inspection.optional.get.without.is.present.display.name=isPresent() 검사 없이 Optional.get()이 호출됩니다
inspection.optional.is.present.display.name=Optional.isPresent()는 functional-style 식으로 바꿀 수 있습니다
inspection.conditional.can.be.optional.display.name=조건은 Optional로 바꿀 수 있습니다
inspection.optional.assigned.to.null.display.name=Optional 타입의 null 값
inspection.excessive.range.check.display.name=과도한 범위 검사
inspection.condition.covered.by.further.condition.display.name=조건은 추가 조건으로 수행됩니다
inspection.move.field.assignment.to.initializer.display.name=필드 할당을 이니셜라이저로 이동할 수 있습니다
inspection.test.failed.line.display.name=테스트에서 문제 줄 강조 표시
inspection.frequently.used.inheritor.inspection.display.name=클래스는 일반적으로 사용되는 기본 클래스를 확장할 수 있습니다
inspection.slow.abstract.set.remove.all.description=''set.removeAll(list)'' 호출은 느리게 작동할 수 있습니다
inspection.slow.abstract.set.remove.all.fix.family.name=''Set.removeAll'' 대신 ''Set.remove'' 사용
slice.filter.parse.error.null.filter.not.applicable.for.primitive.type=''null'' 필터를 기본 타입 {0}에 적용할 수 없습니다
slice.filter.parse.error.not.null.filter.not.applicable.for.primitive.type=''\!null'' 필터를 기본 타입 {0}에 적용할 수 없습니다
slice.filter.parse.error.enum.constant.not.found=열거형 상수를 찾을 수 없습니다 {0}
slice.filter.parse.error.incorrect.expression=잘못된 표현식\: {0}
slice.filter.parse.error.incorrect.constant.type=잘못된 상수 타입(필수\: {0})
slice.filter.parse.error.expression.must.evaluate.to.constant=표현식이 상수로 평가되어야 합니다. {0}
slice.filter.parse.error.incorrect.constant.expected.number=잘못된 상수(필요 숫자)\: {0}
action.dfa.from.stacktrace.text=''{0}''이(가) {1}일 수 있는 이유 찾기
slice.usage.message.assertion.violated=(어설션 위반\!)
slice.usage.message.in.file.stopped.here=({0} 파일 내, 여기에서 정지됨)
slice.usage.message.tracking.container.contents=(컨테이너 ''{0}{1}''의 내용 추적)
slice.usage.message.location={0} 내부
intention.name.move.into.if.branches=''if'' 문 브랜치로 이동
intention.name.collapse.into.loop=루프로 축소
intention.family.name.make.sealed=클래스 봉인
intention.error.make.sealed.class.is.used.in.functional.expression=클래스가 함수 표현식에서 사용되었습니다
intention.make.sealed.class.hint.title=sealed로 설정
intention.error.make.sealed.class.has.anonymous.or.local.inheritors=일부 상속자가 익명이거나 로컬입니다
intention.error.make.sealed.class.different.packages=모듈 이름이 지정되지 않았으며 상속자 일부가 다른 패키지에 있습니다
intention.error.make.sealed.class.inheritors.not.in.java.file=일부 상속자가 Java 파일에 없습니다
intention.error.make.sealed.class.different.modules=일부 상속자가 다른 모듈에 있습니다
intention.error.make.sealed.class.interface.has.no.inheritors=인터페이스에 상속자가 없습니다
intention.make.sealed.class.task.title.set.inheritors.modifiers=상속자 제어자 설정 중
inspection.fill.permits.list.no.missing.inheritors=봉인된 클래스에 누락된 상속자가 없습니다
inspection.fill.permits.list.display.name=봉인된 클래스의 permits 절에서 동일한 파일 하위 클래스가 누락되었습니다
inspection.fill.permits.list.fix.name=누락된 하위 클래스를 permits 절에 추가
update.external.annotations=외부 어노테이션 업데이트
intention.create.switch.statement=switch 문 생성
sort.threads.by.type=스레드를 타입별로 정렬
sort.threads.by.name=스레드를 이름별로 정렬
inspection.message.record.can.be.converted.to.class=레코드를 클래스로 변환할 수 있습니다
intention.family.name.convert.record.to.class=레코드를 클래스로 변환
class.can.be.record.display.name=클래스는 레코드가 될 수 있습니다
class.can.be.record.quick.fix=레코드로 변환
class.can.be.record.suggest.renaming.accessors=get/is 접근자의 이름 변경 제안
class.can.be.record.conversion.weakens.member=변환으로 멤버 액세스 수준이 약화되는 경우\:
class.can.be.record.conversion.strategy.do.not.convert=레코드로의 변환을 제안하지 않음
class.can.be.record.conversion.strategy.show.members=영향을 받은 멤버를 충돌 뷰에 표시
class.can.be.record.conversion.strategy.convert.silently=확인 없이 변환
extracted.class.should.have.unique.name=추출된 클래스에는 고유한 이름이 있어야 합니다. 이름 ''{0}''은(는) 이미 내부 클래스 중 하나에서 사용되고 있습니다
invalid.extracted.class.name=''{0}''은(는) 잘못된 추출된 클래스 이름입니다
caller.chooser.referenced.code.title=참조된 코드
dialog.title.choose.annotation={0} 어노테이션 선택
unchecked.warning.inspection.settings.ignore.unchecked.assignment=확인되지 않은 대입 무시
unchecked.warning.inspection.settings.ignore.unchecked.generics.array.creation.for.vararg.parameter=vararg 매개변수에 대해 확인되지 않은 제네릭 배열 생성 무시
unchecked.warning.inspection.settings.ignore.unchecked.call.as.member.of.raw.type=확인되지 않은 호출을 원시 타입의 멤버로서 무시
unchecked.warning.inspection.settings.ignore.unchecked.cast=확인되지 않은 형 변환 무시
unchecked.warning.inspection.settings.ignore.unchecked.overriding=확인되지 않은 재정의 무시
unchecked.warning.inspection.reason.expr.has.raw.type.so.result.erased=. 이유\: ''{0}''에 원시 타입이 있으므로 {1}의 결과가 지워집니다
unchecked.warning.inspection.message.unchecked.generics.array.creation.for.varargs.parameter=vararg 매개변수에 대해 확인되지 않은 제네릭 배열 생성
type.migration.dialog.message.invalid.type=''{0}''은(는) 잘못된 타입입니다
type.migration.dialog.message.void.not.applicable=''void''를 적용할 수 없습니다
stream.to.loop.inspection.message.replace.stream.api.chain.with.loop=스트림 API 체인을 루프로 바꾸기
stream.to.loop.inspection.message.replace.foreach.call.with.loop=''forEach'' 호출을 루프로 바꾸기
todo.index.not.available=해당사항 없음
simplify.stream.inspection.message.can.be.replaced=''{0}''을(를) ''{1}''(으)로 바꿀수 있습니다
simplify.stream.inspection.message.can.be.replaced.may.change.semantics=''{0}''을(를) ''{1}''(으)로 바꿀수 있습니다(의미가 변경될 수 있음)
inspection.message.filter.is.present.chain.can.be.replaced.with.anymatch=''filter().{0}().isPresent()'' 체인을 ''anyMatch()''로 바꿀수 있습니다
simplify.stream.match.negation.fix.name={0}을(를) {1}(...)(으)로 바꾸기
simplify.stream.collection.creation.fix.name=''{0}'' 생성자로 바꾸기
simplify.stream.simple.stream.of.fix.name.use.stream.element.explicitly=Stream 요소를 명시적으로 사용
simplify.stream.simple.stream.of.message=불필요한 단일 요소 Stream
simplify.stream.replace.with.element.iteration.fix.message=요소 반복으로 바꿀수 있습니다
simplify.stream.remove.boolean.identity.fix.name=이전 ''map'' 호출과 병합
simplify.stream.remove.boolean.identity.fix.message=이전 ''map'' 호출과 병합할 수 있습니다
simplify.stream.replace.support.with.collection.fix.name=''{0}.{1}'' 호출로 바꾸기
simplify.stream.replace.support.with.collection.fix.message=''{0}.{1}'' 호출로 바꾸기 가능
simplify.stream.swap.filter.and.map.fix.name=''filter()''와 ''map()'' 교체
simplify.stream.swap.filter.and.map.fix.message=''filter()''와 ''map()''을 서로 교체할 수 있습니다
simplify.stream.inspection.iterate.take.while.fix.name=3개의 인수 ''iterate()''로 바꾸기
simplify.stream.inspection.iterate.take.while.fix.message=3개의 인수 ''iterate()''로 바꿀수 있습니다
side.effects.pattern.message=<html>\n<body>\n{0}에서 가능한 부작용이 발견되었습니다<br>\n해결 방법\:\n<br>\n-\\&nbsp;관련된 모든 표현식과 함께 변수 사용 위치 <b>제거</b> 또는<br>\n-\\&nbsp;변수에 대입된 표현식을 독립적으로 구문으로 <b>변환</b><br>\n<div style\="padding-left\: 0.6cm;">\n  즉,<br>\n  <table border\="0">\n    <tr>\n      <td><code>{1};</code></td>\n    </tr>\n  </table>\n  결과\: <br>\n  <table border\="0">\n    <tr>\n      <td><code>{2};</code></td>\n    </tr>\n  </table>\n</div>\n</body>\n</html>
side.effects.non.fixable.message=<html><body>표현식 ''{0}''에서 가능한 부작용이 발견되었습니다<br>해결 방법\: 관련된 모든 표현식과 함께 클래스 참조를 <b>제거</b></body></html>
side.effects.expression.presentation=표현식 ''{0}''
change.signature.from.usage.short.name=<html> {0}({1})의 시그니처 변경</html>
default.param.value.warning=선택한 시그니처를 가진 {0, choice, 0\#생성자|1\#메서드}가 이미 있습니다
qualify.static.constant.access=static 상수 액세스를 정규화
qualify.static.access.command.name=static 액세스 정규화
qualify.static.call.fix.text=static 호출 정규화
side.effects.expressions.assigned.to.the.variable=변수 ''{0}''에 대입된 표현식
pull.members.up.fix.name=멤버를 위로 이동
extract.superclass.command.name=상위 클래스 추출
extract.interface.command.name=인터페이스 추출
choose.super.class.popup.title=상위 클래스 선택
intention.name.pull.method.up.and.make.it.abstract.conditionally=메서드 ''{0}''을(를) ''{1}''(으)로 이동{2, choice, 0\#후 추상으로 설정|1\#}
intention.name.extract.method.to.new.interface=메서드 ''{0}''을(를) 새 인터페이스로 추출
intention.name.pull.method.up.make.it.abstract=메서드 ''{0}''을(를) 위로 이동 후 추상으로 설정
intention.name.pull.method.up=메서드 ''{0}''을(를) 위로 이동
intention.name.copy.to.final.temp.variable=''{0}''을(를) {1, choice, 0\#|1\#실질적 }final 임시 변수로 복사
intention.name.make.variable.final={1, choice, 0\#''{0}''을(를)|1\#변수를} final로 설정
intention.name.transform.variables.into.final.one.element.array={1, choice, 0\#''{0}''을(를)|1\#변수를} 단일 요소의 final 배열로 변환
type.information.value=값
type.information.not.equal.to=다음과 동일하지 않음
type.information.range=범위
type.information.nullability=null 값 가능성
type.information.constraints=제약 조건
type.information.mutability=가변성
type.information.locality=지역성
type.information.local.object=지역 객체
type.information.type=타입
simplify.optional.chain.inspection.remove.redundant.steps.from.optional.chain=optional 체인에서 중복 단계 제거
simplify.optional.chain.inspection.to.x=optional 체인을 ''{0}''(으)로 단순화
simplify.optional.chain.inspection.map.or.else.description=optional 체인을 단순화할 수 있습니다
simplify.optional.chain.inspection.optional.rewrapping.name=래핑 해제
simplify.optional.chain.inspection.optional.rewrapping.description=불필요한 optional 다시 래핑
simplify.optional.chain.inspection.or.else.return.fix.name=null 검사를 {0}({1})(으)로 바꾸기
simplify.optional.chain.inspection.or.else.return.fix.description=null 검사를 제거할 수 있습니다
simplify.optional.chain.inspection.or.else.non.null.fix.name=null 검사를 ifPresent()로 바꾸기
simplify.optional.chain.inspection.or.else.non.null.fix.description=null 검사를 ''ifPresent''로 제거할 수 있습니다
generate.test.support.method.error.no.template.found.for.framework={0}에 대한 템플릿을 찾을 수 없습니다. {1}
generate.test.support.method.error.method.already.exists=메서드 {0}이(가) 이미 있습니다
generate.test.support.method.error.cannot.generate.method=메서드를 생성할 수 없습니다. {0}
base.package.project.wizard.error.x.not.valid.package={0}은(는) 올바른 패키지 이름이 아닙니다
class.patterns.separator.mark.code.as.entry.point.if.qualified.name.matches=정규화된 이름이 일치하는 경우 코드를 진입점으로 표시
class.patterns.error.method.pattern.0.must.be.a.valid.java.identifier=메서드 패턴 ''{0}''은(는) 유효한 Java 식별자여야 하며, ''*''만 자리표시자로 허용됩니다
class.patterns.error.class.pattern.0.must.be.a.valid.java.qualifier=패턴은 유효한 Java 정규화된 이름이어야 하며, ''*''만 자리표시자로 허용됩니다
code.style.generation.settings.error.not.valid.identifier.part.in.prefix=접두사 ''{0}''에 유효하지 않은 Java 식별자 부분이 있습니다
code.style.generation.settings.error.not.valid.identifier.part.in.suffix=접미사 ''{0}''에 유효하지 않은 Java 식별자 부분이 있습니다
hide.out.of.cyclic.packages.action.text=순환 종속성이 없는 패키지 숨기기
hide.out.of.cyclic.packages.action.description=순환 종속성이 없는 패키지를 숨깁니다
generate.missed.tests.action.error.no.tests.found=테스트를 찾을 수 없습니다.
generate.missed.tests.action.failed.to.detect.framework={0}의 테스트 프레임워크를 탐지하지 못했습니다
pull.up.accessible.conflict={0}을(를) 액세스할 수 없습니다
pull.up.accessible.conflict.1={0}을(를) {1}에서 액세스할 수 없습니다
pull.up.concrete.inherit.abstract.method.conflict=구체 ''{0}''은(는) 새로운 추상 메서드를 상속합니다
pull.up.members.usage.view.description.code.references.node=멤버를 "{0}"(으)로 올릴 클래스
pull.up.members.usage.view.description.processed.elements.node=클래스 {0}의 멤버를 위로 이동
refactoring.method.reference.to.lambda.conflict=메서드 참조가 람다로 변환됩니다
introduce.variable.change.semantics.warning=선택한 표현식을 추출하면 전체 표현식의 의미가 변경됩니다.
introduce.variable.change.type.adv={0}을(를) 눌러 타입 변경
introduce.variable.reassign.adv={0}을(를) 눌러 기존 변수 재대입
introduce.functional.variable.accessibility.conflict=변수 {0}은(는) 실질적으로 final이 아니므로 함수 표현식 내에서 액세스할 수 없습니다
introduce.functional.variable.interface.chooser.title=적용 가능한 함수 인터페이스 선택\: {0} -> {1}
introduce.functional.variable.nothing.found.message=적용 가능한 함수 인터페이스를 찾을 수 없습니다
introduce.parameter.object.no.accessor.conflict.message=필드 ''{1}''의 {0, choice, 0\#getter|1\#setter}가 필요합니다
push.down.anonymous.conflict=구현을 익명 클래스로 푸시할 수 없습니다
push.down.static.nonstatic.conflict=static {0}을(를) 비 static {1}(으)로 푸시할 수 없습니다
push.down.missed.implementation.conflict=추상이 아닌 {0}에는 {1}의 구현이 누락됩니다
push.down.super.method.call.changed.conflict=상위 메서드 호출은 다른 메서드로 해결됩니다
move.classes.invalid.destination.package.name.message=''{0}''은(는) 잘못된 대상 패키지 이름입니다
move.classes.destination.class.not.found.message=대상 클래스를 찾을 수 없습니다
move.class.import.from.default.package.conflict=디폴트 패키지에서 {0}에 액세스할 수 없습니다
destination.combo.test.root.not.expected.conflict=소스 루트가 필요하지만 테스트 루트가 선택되었습니다
destination.combo.source.root.not.expected.conflict=테스트 루트가 필요하지만 소스 루트가 선택되었습니다
leave.in.same.source.root.item=동일한 소스 루트에 남겨두기
move.inner.select.target.package.title=대상 패키지 선택
move.member.enum.conflict=현재 컨텍스트에서는 열거형을 적용할 수 없습니다
move.member.final.initializer.conflict=final 가변 이니셜라이저는 이동 후에 사용할 수 없습니다.
rename.package.invalid.name.error=올바른 패키지 이름이 아닙니다
rename.package.ignored.name.warning=무시된 이름으로 패키지를 생성하려고 합니다. 이렇게 하면 결과가 표시되지 않습니다
rename.package.class.already.exist.conflict=정규화된 이름이 ''{0}''인 클래스가 이미 있습니다
rename.package.command.name=패키지 이름 변경
class.filter.editor.table.model.column.name.pattern=패턴
class.filter.editor.table.model.column.name.isActive=활성 상태
create.class.mapping.dialog.title={0} 클래스 선택
import.layout.panel.up.button=위로
import.layout.panel.down.button=아래로
import.layout.panel.blank.line.entry=<빈 줄>
import.layout.panel.all.other.imports=기타 모든 import 문
edit.contract.dialog.hint=<html>컨트랙트 텍스트를 지정하세요<p>예\: <code>_, null -> false</code><br><small>자세한 내용은 인텐션 액션 설멍을 참조하세요</small></html>
edit.range.dialog.message=<html>값의 범위를 지정하세요<p>제한이 없다면 ''from'' 또는 ''to''를 비어 있는 상태로 남겨두세요</html>
edit.range.error.invalid.value=잘못된 값
edit.range.value.should.be.less.than={0}보다 작으면 안 됩니다
edit.range.value.should.be.bigger.than={0}보다 크면 안 됩니다
edit.range.should.not.be.less.than.from=''from''보다 작으면 안 됩니다
generate.constructor.already.exists=생성자가 이미 있습니다
generate.equals.no.fields.for.generation=equals/hashCode에 포함할 필드를 찾을 수 없습니다
generate.getter.and.setter.error.setters.for.read.only.not.generated=읽기 전용 필드에 대한 setter가 생성되지 않았습니다
generate.getter.and.setter.error.no.fields=getter/setter를 생성할 필드를 찾을 수 없습니다
generate.getter.and.setter.error.no.fields.without.getters.and.setters=getter/setter가 없는 필드를 찾을 수 없습니다
generate.getter.error.no.fields=getter를 생성할 필드를 찾을 수 없습니다
generate.getter.error.no.fields.without.getters=getter가 없는 필드를 찾을 수 없습니다
generate.getter.setter.header.visibility.hint.=가시성은 ''파일 | 설정 | 에디터 | 코드 스타일 | Java | 코드 생성''에 따라 적용됩니다
generate.members.nothing.to.insert=삽입할 항목이 없습니다
generate.setters.no.fields=setter를 생성할 필드를 찾을 수 없습니다
generate.setters.no.fields.without.setters=setter가 없는 필드를 찾을 수 없습니다
implement.abstract.method.potential.implementations.with.weaker.access=액세스 권한이 약한 잠재적 구현이 발견되었습니다. {0}
implement.method.no.methods.to.implement=구현할 메서드를 찾을 수 없습니다
action.sort.by.percent.classes.which.overrides.method.text=메서드를 재정의하는 클래스 비율로 정렬
action.sort.by.percent.classes.which.overrides.method.description=메서드를 재정의하는 클래스 비율로 정렬합니다
override.methods.error.no.methods=재정의할 메서드를 찾을 수 없습니다
base.package.parameter.wizard.label=기본 패키지(&P)\:
type.migration.multi.root.toolwindow.title={0}의 타입 마이그레이션
type.migration.single.root.toolwindow.title={0}의 타입을 ''{1}''에서 ''{2}''(으)로 마이그레이션
type.migration.processed.elements.header=타입 마이그레이션의 루트
type.migration.cannon.convert.tooltip=표현식 <b>{0}</b>의 타입을{3, choice, 0\#|1\# '<'b'>'{1}'<'/b'>'에서 '<'b'>'{2}''<''/b''>''(으)로} 변환할 수 없습니다<br>
type.migration.replaced.notification={0}(으)로 바꾸기
type.migration.cannot.convert.tooltip=표현식의 타입을 {0}에서 {1}(으)로 변환할 수 없습니다
type.migration.getter.rename.suggestion.text=반환 타입이 ''{2}''(으)로 마이그레이션된 후에 getter 이름을 ''{0}''에서 ''{1}''(으)로 마이그레이션할까요?
type.migration.getter.rename.suggestion.never.migrate.method.names=메서드 이름을 마이그레이션 안 함
type.migration.getter.rename.suggestion.always.migrate.method.names=메서드 이름을 항상 마이그레이션
hint.text.press.to.go.through.inlined.occurrences={0}을(를) 눌러 {1}개의 인라인화된 찾은 항목을 탐색
hint.text.occurrences.were.inlined={1}개의 찾은 항목이 인라인화되었습니다
action.expand.static.import.text=static import 문 확장
class.cannot.be.inlined.because.a.call.to.its.constructor.is.unresolved=클래스의 생성자에 대한 호출이 해결되지 않았으므로 클래스를 인라인화할 수 없습니다
class.cannot.be.inlined.because.it.is.used.as.a.this.qualifier=클래스가 ''this'' 한정자로 사용되므로 인라인화될 수 없습니다
class.cannot.be.inlined.because.it.is.used.in.a.throws.clause=클래스가 ''throws'' 절에서 사용되므로 인라인화될 수 없습니다
class.cannot.be.inlined.because.it.is.used.in.a.catch.clause=클래스가 ''catch'' 절에서 사용되므로 인라인화될 수 없습니다
class.cannot.be.inlined.because.it.has.usages.of.its.class.literal=클래스 리터럴이 사용되므로 클래스를 인라인화할 수 없습니다
class.cannot.be.inlined.because.it.has.static.initializers=클래스에 static 이니셜라이저가 있으므로 클래스를 인라인화할 수 없습니다
class.cannot.be.inlined.because.it.has.usages.of.fields.not.inherited.from.its.superclass=클래스가 상위 클래스에서 상속되지 않은 필드를 사용하므로 인라인화될 수 없습니다
class.cannot.be.inlined.because.it.has.static.fields.with.non.constant.initializers=클래스에 비 상수 이니셜라이저가 있는 static 필드가 있으므로 클래스를 인라인화할 수 없습니다
class.cannot.be.inlined.because.it.has.static.non.final.fields=클래스에 final이 아닌 static 필드가 있으므로 클래스를 인라인화할 수 없습니다
class.cannot.be.inlined.because.it.has.usages.of.its.inner.classes=내부 클래스가 사용되므로 클래스를 인라인화할 수 없습니다
class.cannot.be.inlined.because.it.has.static.inner.classes=클래스에 static 내부 클래스가 있으므로 클래스를 인라인화할 수 없습니다
class.cannot.be.inlined.because.it.has.static.methods=클래스에 static 메서드가 있으므로 클래스를 인라인화할 수 없습니다
class.cannot.be.inlined.because.there.are.usages.of.its.methods.not.inherited.from.its.superclass.or.interface=클래스가 상위 클래스나 인터페이스에서 상속되지 않은 메서드를 사용하므로 인라인화될 수 없습니다
class.cannot.be.inlined.because.its.constructor.contains.return.statements=클래스의 생성자에 ''return'' 문이 있으므로 클래스를 인라인화할 수 없습니다
class.cannot.be.inlined.because.an.interface.implemented.by.it.cannot.be.resolved=클래스로 구현된 인터페이스를 해결할 수 없으므로 클래스를 인라인할 수 없습니다
class.cannot.be.inlined.because.its.superclass.cannot.be.resolved=해당 상위 클래스를 해결할 수 없으므로 클래스를 인라인할 수 없습니다
library.classes.cannot.be.inlined=라이브러리 클래스는 인라인화할 수 없습니다
enums.cannot.be.inlined=열거형은 인라인화할 수 없습니다
interfaces.cannot.be.inlined=인터페이스는 인라인화할 수 없습니다
annotation.types.cannot.be.inlined=어노테이션 타입은 인라인화할 수 없습니다
type.parameters.cannot.be.inlined=타입 매개변수는 인라인화할 수 없습니다
postfix.template.editor.choose.class.title=클래스 선택
null.check.surrounder.description=if (expr \!\= null) {...}
push.method.down.command.name=메서드를 아래로 이동...
replace.implements.with.static.import.field.usages.progress=상수 필드의 사용 위치 찾기...
show.siblings.choose.super.class.title=상위 클래스 또는 인터페이스 선택
show.siblings.find.usages.method.title=상위 메서드
show.siblings.find.usages.class.title=상위 클래스/인터페이스
switch.stmt.template.description=switch (expr) {...}
wrap.return.value.created.class.not.accessible.conflict=생성된 클래스는 호출 위치에서 액세스할 수 없습니다
wrap.return.value.existing.class.does.not.have.getter.conflict=선택한 필드에 대한 getter가 기존 클래스에 없습니다
wrap.return.value.existing.class.does.not.have.appropriate.constructor.conflict=기존 클래스에 적절한 생성자가 없습니다
wrap.return.value.anonymous.class.presentation=익명 {0}
empty.title=비어 있음
separator.annotations.to.copy=복사할 어노테이션
action.go.to.implementation.text=구현으로 이동
action.go.to.subclass.text=하위 클래스로 이동
action.go.to.overriding.methods.text=재정의 메서드로 이동
action.go.to.super.method.text=상위 메서드로 이동
tooltip.recursive.call=재귀적 호출
label.compact.constructor=압축 생성자
label.canonical.constructor=표준 생성자
edit.contract.dialog.checkbox.pure.method=메서드가 순수합니다(부작용 없음)
separator.mark.as.entry.point.if.annotated.by=다음으로 어노테이션이 추가된 경우 진입점으로 표시\:
separator.mark.field.as.implicitly.written.if.annotated.by=다음으로 어노테이션이 추가된 경우 필드를 명시적으로 작성된 것으로 표시\:
rename.super.methods.chooser.popup.title={0}에 상위 메서드가 있음
rename.super.base.chooser.popup.title={0}이(가) {2}의 메서드를{1, choice, 0\# 구현|1\# 재정의}
add.methods.dialog.or=\ 또는
command.name.delegate.detected.change=위임
encapsulate.fields.dialog.javadoc.title=Javadoc
find.jar.hint.text.no.libraries.found.for.fqn=''{0}''에 대한 라이브러리를 찾을 수 없습니다
dependant.sdk.unsatisfied.dependency.message=먼저 Java SDK를 구성해야 합니다
javadoc.gen.error.modules.without.module.info=모듈 {0}에 module-info.java 파일이 없으므로 IDEA에서 Javadoc을 생성할 수 없습니다
javadoc.gen.error.module.source.path.is.not.evaluated=module-source-path를 평가할 수 없으므로 IDEA에서 Javadoc을 생성할 수 없습니다
generate.members.implement.command=구현
code.style.settings.angle.spacing.brackets=대괄호
code.style.settings.spacing.after.closing.angle.bracket=닫는 대괄호 뒤
code.style.settings.spacing.around.type.bounds=타입 바운드 주위
non.code.annotations.explanation.external.and.inferred=외부 및 <i>추론된</i> 어노테이션
non.code.annotations.explanation.external.and.inferred.available=외부 및 <i>추론된</i> 어노테이션을 사용할 수 있습니다.
non.code.annotations.explanation.external=외부 어노테이션
non.code.annotations.explanation.external.available=외부 어노테이션을 사용할 수 있습니다.
non.code.annotations.explanation.inferred=<i>추론된</i> 어노테이션
non.code.annotations.explanation.inferred.available=<i>추론된</i> 어노테이션을 사용할 수 있습니다.
non.code.annotations.explanation.full.signature=전체 시그니처\:
type.migration.command.name=TypeMigration
dfa.constraint.not.null=null이 아님
dfa.constraint.0.not.null={0}(null이 아님)
dfa.constraint.null.or.0=null 또는 {0}
label.class.pattern.syntax.explanation=생성자를 표시하려면 메서드를 공백으로 남겨두세요\n임의의 *가 정규화된 이름 내 1개 이상의 문자와 일치하게 됩니다(마침표 포함)
dialog.message.modules.dont.refer.to.existing.annotations.library={0, choice, 0\#모듈|2\#모듈} {1}이(가) IntelliJ IDEA nullity 어노테이션이 있는 기존 ''{2}'' 라이브러리를 참조하지 {0, choice, 0\#않습니다|2\#않습니다}. 지금 {0, choice, 0\#종속성|2\#종속성}을 추가하시겠어요?
tab.title.slices.grouped.by.nullness=\ (Nullness별로 그룹화)
exclude.0.from.auto.import=자동 가져오기에서 ''{0}''을(를) 제외
column.name.method.entry.point=메서드
column.name.class.entry.point=클래스
column.name.with.subclasses.entry.point=하위 클래스 포함
code.vision.implementations.hint={0, choice, 1\#1개 구현|2\#{0,number}개 구현}
code.vision.inheritors.hint={0, choice, 1\#1개 상속자|2\#{0,number}개 상속자}
code.vision.overrides.hint={0, choice, 1\#1개 재정의|2\#{0,number}개 재정의}
hint.text.tostring.method.could.not.be.created.from.template=''toString()'' 메서드는 템플릿 ''{0}''에서 생성할 수 없습니다
hint.text.tostring.template.invalid=toString() 템플릿 ''{0}''이(가) 잘못되었습니다
command.name.generate.tostring=toString() 생성
column.name.ignore.suppressions=억제 무시
hint.text.removed.imports={0}개의 {0,choice,1\#import 문|2\#import 문} 제거
hint.text.added.imports=, {0}개의 {0,choice,1\#import 문|2\#import 문} 추가
hint.text.rearranged.imports=재정렬된 import 문
enum.constant.ordinal=열거형 상수 서수\: 
tab.title.infer.nullity.preview=nullity 추론 미리보기
inspection.message.full.description=전체 설명
popup.title.debug.recent.tests=최근 테스트 디버그
list.item.suite=[도구] {0}
list.item.configuration=[구성] {0}
no.jre.description=<JRE 없음>
popup.content.tests.were.not.found.in.module.use.instead=모듈 ''{0}''에서 테스트를 찾을 수 없습니다.\n대신 {1, choice, 0\#모듈 {2} | 1\#{3} 중\n하나\n}를 사용하세요
postfix.template.provider.name=Java
postfix.template.condition.void.name=void
postfix.template.condition.non.void.name=비 void
postfix.template.condition.boolean.name=부울
postfix.template.condition.number.name=숫자
postfix.template.condition.not.primitive.type.name=기본 타입이 아님
postfix.template.condition.array.name=배열
inspection.redundant.unmodifiable.call.display.name=''{0}'' 래퍼의 중복 사용
inspection.redundant.unmodifiable.call.description=수정할 수 없는 컬렉션 래퍼의 중복 사용
inspection.redundant.unmodifiable.call.unwrap.argument.quickfix=인수 줄 바꿈 해제
completion.override.implement.methods=메서드 재정의/구현...
lambda.tree.node.presentation=람다
column.assertion.class.name=어설션 클래스 이름
inspection.meaningless.record.annotation.description=의미 없는 레코드 어노테이션
inspection.meaningless.record.annotation.message.method.and.parameter=어노테이션이 효과가 없습니다. 어노테이션의 대상은 METHOD 및 PARAMETER이지만 접근자와 표준 생성자 모두 명시적으로 선언되어 있습니다
inspection.meaningless.record.annotation.message.method=어노테이션이 효과가 없습니다. 어노테이션의 대상은 METHOD이지만 해당 접근자가 명시적으로 선언되어 있습니다
inspection.meaningless.record.annotation.message.parameter=어노테이션이 효과가 없습니다. 어노테이션의 대상은 PARAMETER이지만 표준 생성자가 명시적으로 선언되어 있습니다
header.method.to.be.converted=변환할 메서드
accessible.name.change.modifier=제어자 변경
usages.telescope={0,choice, 0\#0개의 사용위치|1\#1개 사용 위치|2\#{0,number}개 사용 위치}
press.to.navigate={0}을(를) 눌러 이동
label.jvm.method.name=JVM 메서드 이름
link.configure.classes.excluded.from.completion=코드 완성에서 제외된 클래스 구성
exception.navigation.fetching.target.position=대상 위치 가져오는 중
inspection.preview.feature.0.is.preview.api.message={0}은(는) 테스트 버전 API이며 향후 릴리즈 버전에서 제거될 수 있습니다
