language.groovy=Groovy
file.type.dgm=Groovy 확장 모듈 설명자 파일
file.type.logback=Groovy Logback DSL 구성
file.type.gdsl=IntelliJ Groovy DSL 구성
title.groovy.shell=Groovy 셸
action.Groovy.Shell.text=Groovy 셸...
action.Groovy.Shell.description=Groovy 셸 시작
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.text=propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.description=액션이 propertyMissing()을 생성합니다
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.text=methodMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.description=액션이 propertyMissing()을 생성합니다
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.text=equals() 및 hashCode()
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.description=액션이 이제 equals와 hashCode를 생성합니다.
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.text=Getter 및 Setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.description=getter 생성
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.text=Setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.description=setter 생성
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.text=Getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.description=getter 생성
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.text=생성자
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.description=생성자 생성
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.text=to_String()
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.description=toString() 메서드 생성
action.ExcludeFromStubGeneration.text=스텁 생성에서 제외
action.ExcludeFromStubGeneration.description=컴파일 시 이 Groovy 파일에 대한 Java 스텁을 생성하지 않습니다
action.DumpGroovyControlFlowAction.text=Groovy 제어 흐름 덤프
action.ConvertToCompileStatic.text=Convertir a @CompileStatic
action.ConvertToCompileStatic.description=Groovy 파일을 @CompileStatic으로 변환
action.ConvertGroovyToJava.text=Convertir a Java
action.ConvertGroovyToJava.description=그루비 파일을 Java로 변환
action.Groovy.NewScript.text=Groovy 스크립트
action.Groovy.NewScript.description=새 Groovy 스크립트 생성
action.Groovy.NewClass.text=Groovy 클래스
action.Groovy.NewClass.description=새 Groovy 클래스 생성
action.Groovy.CheckResources.Rebuild.text=리소스 다시 빌드(_R)
action.Groovy.CheckResources.Rebuild.description=컴파일 문제 확인을 위해 리소스 루트의 모든 Groovy 파일에 대해 컴파일러 실행
action.Groovy.CheckResources.Make.text=리소스 빌드(_B)
action.Groovy.CheckResources.Make.description=컴파일 문제 확인을 위해 리소스 루트의 Groovy 파일에 대해 증분 컴파일러를 실행합니다
group.Groovy.CheckResources.text=Groovy 리소스(_O)
group.Groovy.CheckResources.description=컴파일 문제 확인을 위해 리소스 루트의 모든 Groovy 파일에 대해 컴파일러 실행
action.Groovy.Shell.Execute.text=Groovy 코드 실행
action.Groovy.Shell.Execute.description=콘솔에서 Groovy 코드 실행
file.template.group.title.groovy=Groovy
groovy.term.class=클래스
groovy.term.interface=인터페이스
groovy.term.trait=특성
groovy.term.enum=열거형
groovy.term.annotation=어노테이션
groovy.term.method=메서드
groovy.term.field=필드
groovy.term.property=프로퍼티
groovy.term.parameter=매개변수
groovy.term.variable=지역 변수
groovy.term.binding=스크립트 바인딩 변수
groovy.term.label=라벨
groovy.term.closure=클로저
groovy.term.expression=표현식
new.class.action.text=Groovy 클래스
new.class.action.description=새 Groovy 클래스 생성
new.class.dialog.title=새 Groovy 클래스
new.class.list.item.class=클래스
new.class.list.item.interface=인터페이스
new.class.list.item.trait=특성
new.class.list.item.enum=열거형
new.class.list.item.annotation=어노테이션
invalid.qualified.name=올바른 Groovy 정규화된 이름이 아닙니다
new.script.action.text=Groovy 스크립트
new.script.action.description=새 Groovy 스크립트 생성
new.script.dialog.title=새 Groovy 스크립트 이름 입력
new.script.list.item.script=Groovy 스크립트
new.script.list.item.script.dsl=GroovyDSL 스크립트
new.gant.script.dialog.title=새 Gant 스크립트
new.gant.script.dialog.message=새 Gant 스크립트 이름을 입력하세요
debug.option=디버그 스택 트레이스 활성화(&D)
groovy.debug.disable.specific.methods=특정 Groovy 클래스로 스텝인투 안 함(&I)
groovy.debug.caption=Groovy
########################################################################################################################
# Parser error messages
########################################################################################################################
identifier.expected=식별자가 필요합니다
identifier.or.block.expected=식별자 또는 코드 블록이 필요합니다.
string.end.expected=문자열 끝부분이 필요합니다.
try.without.catch.finally=''try''에 ''catch'' 또는 ''finally''가 없습니다.
expression.expected=표현식이 필요합니다
duplicate.modifier=중복 제어자 ''{0}''
########################################################################################################################
# Intentions & error messages
########################################################################################################################
cannot.resolve=심볼 ''{0}''을(를) 해결할 수 없습니다
cannot.access=''{0}''에 대한 액세스는 해당 액세스 권한을 초과합니다.
cannot.reference.non.static=정적 컨텍스트에서 정적이 아닌 심볼 ''{0}''을(를) 참조할 수 없습니다.
cannot.return.from.constructor=생성자에서 객체를 반환할 수 없습니다.
cannot.return.from.void.method=''void''를 반환하는 메서드에서 객체를 반환할 수 없습니다.
cannot.return.type=''{1}''을(를) 반환하는 메서드에서 ''{0}''을(를) 반환할 수 없습니다
cannot.apply.method.or.closure=''{0}''을(를) ''{1}''에 적용할 수 없습니다
cannot.apply.method1=''{1}''의 ''{0}''을(를) ''{2}''에 적용할 수 없습니다
cannot.apply.constructor=''{1}''의 생성자 ''{0}''을(를) ''{2}''에 적용할 수 없습니다.
cannot.apply.default.constructor=클래스''{0}''에 대한 디폴트 생성자를 적용할 수 없습니다.
cannot.instantiate.abstract.class=추상 클래스 ''{0}''을(를) 인스턴스화할 수 없습니다.
cannot.instantiate.interface=인터페이스 ''{0}''을(를) 인스턴스화할 수 없습니다.
missing.required.named.parameter=이름 지정된 필수 매개변수 ''{0}''이(가) 없습니다.
loss.of.precision=정확도가 ''{0}''에서 ''{1}''(으)로 손실될 수 있습니다.
cannot.assign=''{0}''을(를) ''{1}''에 대입할 수 없습니다.
cannot.cast=''{0}''을(를) ''{1}''(으)로 형 변환할 수 없습니다.
multiple.assignments.without.list.expr=정적 타입 검사 모드에서는 오른쪽에 list 표현식이 없는 여러 개의 대입이 지원되지 않습니다.
spread.operator.is.not.available=정적 타입 검사에서는 스프레드 연산자를 인수로서 사용할 수 없습니다.
replace.with.list.literal=list 리터럴로 바꿉니다.
replace.with.get.at=색인 액세스로 바꿉니다.
incorrect.number.of.values=값의 수가 올바르지 않습니다. 기댓값\: {0}, 현재 값\: {1}
invalid.lvalue=대입할 값이 올바르지 않습니다.
duplicate.class=클래스 ''{0}''이(가) ''{1}''에 이미 있습니다.
duplicate.inner.class=클래스 중복\: ''{0}''
script.generated.with.same.name=스크립트 코드에 대해 생성된 통합 클래스 ''{0}''이(가) 있습니다.
variable.already.defined=변수 ''{0}''은(는) 이미 정의되어 있습니다.
field.already.defined=필드 ''{0}''은(는) 이미 정의되어 있습니다.
create.class.family.name=클래스 생성
create.class.text=클래스 {0} 생성
create.interface.text=인터페이스 {0} 생성
create.annotation.text=어노테이션 {0} 생성
constructors.are.not.allowed.in.anonymous.class=생성자는 익명 클래스에서 허용되지 않습니다.
no.such.property=프로퍼티 ''{0}''이(가) 없습니다.
change.modifier=''{0}''을(를) {1}(으)로 만들기
change.modifier.not=''{0}''을(를) 비 {1}(으)로 만들기
change.modifier.family.name=제어자 변경
parameter.cast.fix={0,number,ordinal}번째 매개변수를 {1}(으)로 형 변환합니다.
action.convert.lambda.to.closure=람다를 클로저로 변환
add.parenthesis.to.lambda.parameter.list=소괄호를 매개변수 목록에 추가
# suppress inspection "UnusedProperty"
packageLocal.visibility.presentation=디폴트 가시성
# suppress inspection "UnusedProperty"
protected.visibility.presentation=protected
# suppress inspection "UnusedProperty"
private.visibility.presentation=private
# suppress inspection "UnusedProperty"
public.visibility.presentation=public
# suppress inspection "UnusedProperty"
abstract.visibility.presentation=abstract
# suppress inspection "UnusedProperty"
static.visibility.presentation=static
# suppress inspection "UnusedProperty"
final.visibility.presentation=final
# suppress inspection "UnusedProperty"
native.visibility.presentation=native
# suppress inspection "UnusedProperty"
synchronized.visibility.presentation=synchronized
# suppress inspection "UnusedProperty"
strictfp.visibility.presentation=strictfp
# suppress inspection "UnusedProperty"
transient.visibility.presentation=transient
# suppress inspection "UnusedProperty"
volatile.visibility.presentation=volatile
# suppress inspection "UnusedProperty"
def.visibility.presentation=def
intention.family.name.convert.conditional.expression.to.elvis=조건식을 Elvis로 변환
intention.family.name.replace.with.keyed.access=키 액세스로 바꾸기
intention.family.name.fix.range.class=range 클래스 수정
intention.family.name.make.return.implicit=반환을 묵시적으로 만들기
intention.family.name.simplify=단순화
intention.family.name.remove.unnecessary.continue=불필요한 continue 제거
intention.family.name.remove.unnecessary.return=불필요한 return 제거
intention.family.name.add.parameter.cast=매개변수 형 변환 추가
intention.family.name.replace.for.each.operator=''for-each'' 연산자 바꾸기
intention.family.name.add.cast=형 변환 추가
intention.family.name.change.variable.type=변수 타입 변경
intention.family.name.replace.with.conditional.call=조건 호출로 바꾸기
intention.family.name.collapse.conditional.expressions=조건식 접기
intention.family.name.remove.double.negation=이중 부정 제거
intention.family.name.activate.dsl.descriptor=DSL 설명자 활성화
intention.family.name.collapse.if.statement=''if'' 문 접기
intention.family.name.replace.with.short.circuit.expression=단락 표현식으로 바꾸기
intention.family.name.replace.something.with=''{0}''을(를) ''{1}''(으)로 바꾸기
intention.family.name.add.attributes.to.annotation=어노테이션에 속성 추가
intention.family.name.fix.quotation=따옴표 수정
illegal.combination.of.modifiers=제어자 조합이 올바르지 않습니다
illegal.combination.of.modifiers.abstract.and.final=제어자 ''abstract'' 및 ''final''의 조합이 올바르지 않습니다
modifier.volatile.not.allowed.here=제어자 ''volatile''은 여기에서 허용되지 않습니다.
modifier.transient.not.allowed.here=제어자 ''transient''는 여기에서 허용되지 않습니다
modifier.0.not.allowed=제어자 ''{0}''은(는) 여기에서 허용되지 않습니다
interface.cannot.have.modifier.final=인터페이스는 제어자 ''final''을 가질 수 없습니다
script.method.cannot.have.modifier.abstract=스크립트 메서드는 제어자 ''abstract''를 가질 수 없습니다
script.cannot.have.modifier.native=스크립트 메서드는 제어자 ''native''를 가질 수 없습니다
interface.must.have.no.static.method=인터페이스는 정적 메서드를 가질 수 없습니다.
only.abstract.class.can.have.abstract.method=추상 클래스만이 추상 메서드를 가질 수 있습니다.
anonymous.class.cannot.have.abstract.method=익명 클래스는 추상 메서드를 가질 수 없습니다.
illegal.combination.of.modifiers.volatile.and.final=제어자 ''abstract'' 및 ''final''의 조합이 올바르지 않습니다
variable.cannot.be=변수는 제어자 ''{0}''을(를) 가질 수 없습니다
remove.modifier=''{0}'' 제거
not.abstract.method.should.have.body=추상 메서드에 본문이 있어서는 안 됩니다.
cannot.create.class.error.text=클래스 ''{0}''을(를) 생성할 수 없습니다. {1}
cannot.create.class.error.title=클래스를 생성할 수 없음
no.class.in.file.template=파일 템플릿에서 클래스를 찾을 수 없습니다.
Inner.methods.are.not.supported=내부 메서드가 지원되지 않습니다.
final.class.cannot.be.extended=final 클래스는 확장할 수 없습니다.
# Groovy 1.7 checks
unsupported.inner.class.0=내부 클래스는 Groovy {0}에서 지원되지 않습니다.
unsupported.anonymous.class.0=익명 클래스는 Groovy {0}에서 지원되지 않습니다.
# Groovy 1.8 checks
unsupported.diamonds.0=다이아몬드는 Groovy {0}에서 지원되지 않습니다.
unsupported.command.syntax.0=명령어 표현식 구문은 Groovy {0}에서 지원되지 않습니다.
unsupported.dollar.slashy.string.0=달러 슬래시 문자열은 Groovy {0}에서 지원되지 않습니다.
unsupported.multiline.slashy.string.0=여러 줄 슬래시 문자열은 Groovy {0}에서 지원되지 않습니다.
#Groovy 2.3 checks
unsupported.traits.0=특성은 Groovy {0}에서 지원되지 않습니다.
#Groovy 2.5 checks
duplicating.named.parameter=매개변수에 이름이 중복된 매개변수 ''{0}''이(가) 있습니다. {1}
field.should.be.immutable=필드 ''{0}''에 불변 타입이 있어야 하거나 @ImmutableOptions를 사용해 불변 타입으로 선언되어야 합니다.
immutable.options.property.not.exist=프로퍼티 ''{0}''이(가) 없습니다.
explicit.includes.and.excludes=''includes'' 및 ''excludes'' 중 하나만 제공해야 합니다
require.closure.as.attribute.value=속성 값으로 클로저가 필요합니다
initializers.are.forbidden.with.defaults=@TupleConstructor에서 ''defaults''를 비활성화하면 디폴트 값이 금지됩니다
super.is.not.allowed.in.pre.with.call.super=super 호출은 ''callSuper''가 활성화된 ''pre''에서 허용되지 않습니다
#Groovy 3.0 checks
illegal.default.modifier=제어자 ''default''는 인터페이스 메서드 내에서만 의미가 있습니다
illegal.default.modifier.fix=''default'' 제어자 제거
default.modifier.in.old.versions=제어자 ''default''는 Groovy 3.0 이후 버전에서 이용할 수 있습니다
unsupported.do.while.statement=''do while''은 현재 버전에서 지원되지 않습니다.
unsupported.tuple.declaration.in.for=''for'' 초기화 내 튜플 선언은 현재 버전에서 지원되지 않습니다
unsupported.multiple.variables.in.for=''for'' 초기화 내 여러 변수는 현재 버전에서 지원되지 않습니다.
unsupported.expression.list.in.for.update=''for'' 업데이트 내 여러 표현식은 현재 버전에서 지원되지 않습니다.
unsupported.resource.list=''try''는 현재 버전에서 지원되지 않습니다.
unsupported.array.initializers=배열 이니셜라이저는 현재 버전에서 지원되지 않습니다.
operator.is.not.supported.in=연산자 ''{0}''은(는) 현재 버전에서 지원되지 않습니다.
unsupported.negated.in=부정된 ''in''은 현재 버전에서 지원되지 않습니다.
unsupported.negated.instanceof=부정된 ''instanceof''는 현재 버전에서 지원되지 않습니다.
unsupported.elvis.assignment=elvis 대입은 현재 버전에서 지원되지 않습니다.
unsupported.safe.index.access=안전한 색인 액세스는 현재 버전에서 지원되지 않습니다.
unsupported.lambda=람다는 현재 버전에서 지원되지 않습니다.
unsupported.type.annotations=타입 어노테이션은 현재 버전에서 지원되지 않습니다.
unsupported.tuple.application.initializer=애플리케이션 이니셜라이저는 현재 버전에서 지원되지 않습니다
illegal.single.argument.lambda=단일 인수는 대입 표현식의 오른쪽 부분에 또는 메서드 호출 내에 인수로서 사용할 수 있습니다.
method.is.not.implemented=메서드 ''{0}''이(가) 구현되어 있지 않습니다.
change.implements.and.extends.classes=extends 및 implements 목록을 정규화
fix.package.name=패키지 이름 수정
checkbox.delegate.via.overloading.method=오버로드 메서드를 통한 위임
checkbox.ignore.conditional.operators=조건 연산자 무시
checkbox.ignore.obscure.operators=모호한 연산자 무시
checkbox.ignore.double.checked.locking.on.volatile.fields=volatile 필드에서 이중 검사된 잠금 무시
checkbox.inspect.anonymous.closures=익명 클로저 검사
checkbox.only.warn.if.loop.empty=루프가 비어 있는 경우에만 경고
add.dynamic.property=동적 프로퍼티 ''{0}'' 추가
duplicate.element.in.the.map=맵 내 중복 요소 ''{0}''
dynamic.tool.window.id=동적 숫자
create.field.from.usage.family.name=사용 위치에서 필드 생성
create.field.from.usage=필드 ''{0}'' 생성
create.method.from.usage.family.name=사용 위치에서 메서드 생성
create.method.from.usage=메서드 ''{0}'' 생성
create.variable.from.usage.family.name=사용 위치에서 변수 생성
create.variable.from.usage=변수 ''{0}'' 생성
create.parameter.from.usage.family.name=사용 위치에서 매개변수 생성
create.parameter.from.usage=매개변수 ''{0}'' 생성
add.dynamic.element=동적 요소 추가
add.dynamic.method=동적 메서드 추가
add.dynamic.method.0=동적 메서드 ''{0}'' 추가
dynamic.type=타입
dynamic.name=이름
dynamic.properties.table.name=메서드 인수
dynamic.method.return.type=반환 타입(&T)\:
dynamic.method.property.type=프로퍼티 타입(&T)\:
are.you.sure.to.delete.dynamic.property=''{0}''을(를) 삭제하시겠어요?
dynamic.property.deletion=동적 프로퍼티 삭제
are.you.sure.to.delete.elements=''{0}'' 요소를 삭제하시겠어요''?
dynamic.element.deletion=동적 요소 삭제
tuple.cant.be.placed.in.class=필드에 대한 여러 대입이 허용되지 않습니다
is.not.enclosing.class=''{0}''이(가) 둘러싸는 클래스가 아닙니다
package.definition.cannot.have.modifiers=패키지 정의는 제어자를 가질 수 없습니다
import.statement.cannot.have.modifiers=import 문은 제어자를 가질 수 없습니다
undefined.label=정의되지 않은 라벨 ''{0}''
continue.outside.loop=continue 문은 루프 내에서만 허용됩니다.
break.outside.loop.or.switch=break 문은 루프 또는 switch 내에서만 허용됩니다.
label.already.used=라벨 ''{0}''은(는) 이미 사용 중입니다.
break.outside.loop=이름 지정된 라벨이 있는 break 문은 루프 내에서만 허용됩니다.
Constructor=생성자
Getter=Getter
Setter=Setter
not.allowed.modifier.in.for.in=제어자 ''{0}''은(는) 여기에서 허용되지 않습니다
property.name.expected=프로퍼티 이름이 필요합니다
wildcards.are.not.allowed.in.extends.list=super 타입은 wildcard 타입을 지정할 수 없습니다.
method.does.not.override.super=메서드가 상위 클래스의 메서드를 재정의하지 않습니다.
method.duplicate=시그니처 {0}이(가) 포함된 메서드는 클래스 ''{1}''에 이미 정의되어 있습니다
ambiguous.code.block=모호한 코드 블록
cyclic.inheritance.involving.0=''{0}'' 관련 순환 상속
there.is.no.default.constructor.available.in.class.0=''{0}''에서 사용할 수 있는 디폴트 생성자가 없습니다.
groovy.library.is.not.configured.for.module=Groovy SDK가 모듈 ''{0}''에 대해 구성되지 않았습니다
configure.groovy.library=Groovy SDK 구성...
create.instance.of.built-in.type=기본 타입의 인스턴스화
incorrect.variable.name=잘못된 변수 이름
no.interface.expected.here=여기에서는 인터페이스가 필요하지 않습니다
no.class.expected.here=여기에서는 클래스가 필요하지 않습니다
invoke.completion.second.time.to.show.skipped.methods=코드 완성을 2번째 호출하여 건너뛴 메서드 표시
groovy.file.extension.is.not.mapped.to.groovy.file.type=*.groovy 파일이 ''{0}''(으)로 매핑되었습니다.\n해당 파일은 설정 | 파일 타입에서 Groovy로 매핑할 수 있습니다.
class.is.not.annotation=''{0}''이(가) 어노테이션이 아닙니다
method.call.is.ambiguous=메서드 호출이 모호합니다.
operator.call.is.ambiguous=연산자 호출이 모호합니다.
duplicated.named.parameter=이름이 중복된 매개변수 ''{0}''이(가) 발견되었습니다.
no.super.classes.found=상위 클래스를 찾을 수 없습니다.
no.super.method.found=상위 메서드를 찾을 수 없습니다.
cannot.assign.string.to.enum.0=문자열을 열거형 ''{0}''에 대입할 수 없습니다.
cannot.find.enum.constant.0.in.enum.1=열거형 ''{1}''에서 열거형 상수 ''{0}''을(를) 찾을 수 없습니다.
recursive.constructor.invocation=재귀 생성자 호출
the.usage.of.a.map.entry.expression.to.initialize.an.enum.is.currently.not.supported=열거형을 초기화하는 맵 항목 표현식의 사용은 현재 지원되지 않습니다.
class.definition.is.not.expected.here=여기에서는 클래스 정의가 필요하지 않습니다.
move.class.0.from.method=올바른 위치로 ''{0}'' 이동
move.class.from.method.family.name=올바른 위치로 이동하는 빠른 수정
cannot.infer.argument.types=인수 타입을 추론할 수 없습니다.
Equals=상등
default.initializers.are.not.allowed.in.abstract.method=기본 이니셜라이저는 추상 메서드에서 허용되지 않습니다
groovy.does.not.support.constructor.type.arguments=Groovy는 생성자 타입 인수를 지원하지 않습니다.
illegal.escape.character.in.string.literal=문자열 리터럴의 올바르지 않은 이스케이프 문자
method.with.type.parameters.should.have.return.type=타입 매개변수가 있는 메서드에는 반환 타입이 있어야 합니다
primitive.type.parameters.are.not.allowed=기본 타입 매개변수는 타입 매개변수 목록에서 허용되지 않습니다.
primitive.bound.types.are.not.allowed=기본 바운드 타입은 허용되지 않습니다.
ellipsis.type.is.not.allowed.here=여기에서는 ellipsis 타입이 허용되지 않습니다.
method.0.is.too.complex.too.analyze=메서드 ''{0}''이(가) 너무 복잡하여 분석할 수 없습니다.\n지역 변수 타입이 추론되지 않았습니다.
closure.is.too.complex.to.analyze=클로저가 너무 복잡하여 분석할 수 없습니다.\n지역 변수 타입이 추론되지 않았습니다.
0.is.deprecated=''{0}''은(는) 곧 사용할 수 없게 됩니다
wrong.number.of.type.arguments=타입 인수의 개수가 잘못되었습니다({0}). 필요\: {1}개
type.argument.0.is.not.in.its.bound.should.extend.1=타입 매개변수 ''{0}''이(가) 해당 바운드 내에 없으며, ''{1}''을(를) 확장해야 합니다.
catch.statement.parameter.type.should.be.a.subclass.of.throwable=catch 문 매개변수 타입은 Throwable의 하위 클래스여야 합니다.
exception.0.has.already.been.caught=예외 ''{0}''이(가) 이미 포착되었습니다
unnecessary.type=예외 ''{0}''은(는) 필요하지 않습니다. ''{1}''은(는) 이미 선언되었습니다.
create.enum=열거형 {0} 생성
create.trait=특성 {0} 생성
annotation.field.can.only.be.used.within.a.script.body=어노테이션 @Field는 스크립트 본문 내에서만 사용할 수 있습니다.
annotation.field.can.only.be.used.within.a.script=어노테이션 @Field는 스크립트 내에서만 사용할 수 있습니다.
return.type.is.incompatible={1} 내 {0}의 반환 타입이 {3} 내 {2}와(과) 호환되지 않습니다
anonymous.class.derived.from.0={0}에서 파생된 익명 클래스
throws.clause.is.not.allowed.in.at.interface=''throws'' 절은 @interface 멤버에서 허용되지 않습니다.
at.interface.0.does.not.contain.attribute=@interface ''{0}''에 속성 ''{1}''이(가) 없습니다.
duplicate.attribute=중복 속성
missed.attributes=누락된 속성\: {0}
unexpected.attribute.type.0=예기치 않은 속성 타입\: ''{0}''
annotation.field.should.have.type.declaration=어노테이션 내 필드에는 타입 선언이 있어야 합니다.
interface.members.are.not.allowed.to.be=인터페이스 멤버는 {0}이(가) 될 수 없습니다.
abstract.methods.must.not.have.body=추상 메서드에 본문이 있어서는 안 됩니다.
method.has.incorrect.modifier.volatile=메서드에 있는 제어자 ''volatile''이 올바르지 않습니다
native.methods.cannot.have.body=네이티브 메서드는 본문을 가질 수 없습니다.
top.level.class.may.not.have.private.modifier=최상위 클래스는 ''private'' 제어자를 가질 수 없습니다
top.level.class.may.not.have.protected.modifier=최상위 클래스는 ''protected'' 제어자를 가질 수 없습니다
property.missing=propertyMissing
attribute.name.expected=속성 이름이 필요합니다.
java.style.for.each.statement.requires.a.type.declaration=Java 스타일의 for-each 문에는 타입 선언이 필요합니다.
super.cannot.be.used.in.static.context=''super''는 정적 컨텍스트에서 사용할 수 없습니다.
qualified.0.is.allowed.only.in.nested.or.inner.classes=한정된 {0}은(는) 중첩/내부 클래스에서만 허용됩니다.
groovy.file.0=Groovy 파일 ''{0}''
type.argument.list.is.not.allowed.here=타입 인수 목록은 여기에서 허용되지 않습니다.
initializers.are.not.allowed.in.interface=이니셜라이저가 인터페이스에서 허용되지 않습니다.
initializer.cannot.have.annotations=이니셜라이저는 어노테이션을 가질 수 없습니다.
initializer.cannot.be.0=이니셜라이저는 {0}이(가) 될 수 없습니다.
constructors.are.not.allowed.in.interface=생성자가 인터페이스에서 허용되지 않습니다.
type.parameters.are.unexpected=예기치 않은 타입 매개변수 입니다
constructors.cannot.have.return.type=''return'' 타입 요소는 생성자에서 허용되지 않습니다.
constructor.cannot.have.static.modifier=생성자는 정적일 수 없습니다.
annotation.types.may.not.have.extends.clause=어노테이션 타입은 ''extends'' 절을 가질 수 없습니다.
annotation.types.may.not.have.implements.clause=어노테이션 타입은 ''implements'' 절을 가질 수 없습니다.
no.implements.clause.allowed.for.interface=인터페이스는 ''implements'' 절을 가질 수 없습니다.
enums.may.not.have.extends.clause=열거형은 ''extends'' 절을 가질 수 없습니다.
method.0.cannot.override.method.1.in.2.overridden.method.is.final=메서드 ''{0}''은(는) ''{2}''에서 메서드 ''{1}''을(를) 재정의할 수 없으며, 재정의된 메서드는 final입니다.
method.0.cannot.have.weaker.access.privileges.1.than.2.in.3.4=메서드 ''{0}''은(는) ''{3}''(''{4}'')에서 ''{2}''보다 약한 액세스 권한(''{1}'')을 가질 수 없습니다.
tuple.declaration.should.end.with.def.modifier=튜플 선언은 ''def'' 제어자로 끝나야 합니다
injection.should.not.contain.line.feeds=GString 삽입에 줄 피드가 포함되면 안 됩니다.
collection.literal.contains.named.argument.and.expression.items=컬렉션 리터럴에는 이름 지정된 인수 및 표현식 인수가 동시에 포함됩니다.
annotation.collector.cannot.have.attributes=@AnnotationCollector로 추가된 어노테이션 타입은 속성을 가질 수 없습니다
annotation.type.cannot.be.inner=어노테이션 타입은 내부형일 수 없습니다.
named.arguments.are.not.allowed.inside.index.operations=이름 지정된 인수는 색인 연산 내에서 허용되지 않습니다.
expected.0.to.be.inline.constant=''{0}''은(는) 인라인 상수여야 합니다.
cannot.assign.a.value.to.final.field.0=final 필드 ''{0}''에 값을 대입할 수 없습니다.
cannot.assign.a.value.to.final.parameter.0=final 매개변수 ''{0}''에 값을 대입할 수 없습니다.
variable.0.might.not.have.been.initialized=변수 ''{0}''이(가) 초기화되지 않았을 수 있습니다
doc.end.expected=''*/''이(가) 필요합니다
mixing.private.and.public.protected.methods.of.the.same.name=이름이 같은 private 및 public/protected 메서드가 혼재되어 있습니다.
explicit.constructors.are.not.allowed.in.immutable.class=명시적 생성자는 @Immutable 클래스에서 허용되지 않습니다.
repetitive.method.name.0=메서드 이름 ''{0}''이 반복됩니다.
declared.type.0.have.to.extend.script=선언된 타입 ''{0}''이(가) ''groovy.lang.Script'' 클래스를 확장하지 않습니다.
base.script.annotation.is.allowed.only.inside.scripts=어노테이션 @BaseScript는 스크립트 내에서만 사용할 수 있습니다.
delegate.annotation.is.only.for.methods.without.arguments=어노테이션 @Delegate는 인수를 가진 메서드에 적용할 수 있습니다.
builder.annotation.not.support.super.for.simple.strategy=어노테이션 속성 ''includeSuperProperties''는 groovy.transform.builder.SimpleStrategy에서 지원되지 않습니다.
0.expressions.on.trait.fields.properties.are.not.supported.in.traits=특성 필드/프로퍼티에 있는 {0} 표현식은 특성에서 지원되지 않습니다.
only.traits.expected.here=여기에는 특성만이 필요합니다.
anonymous.classes.cannot.be.created.from.traits=익명 클래스는 특성에서 생성할 수 없습니다.
trait.method.cannot.be.protected=특성 메서드는 protected가 될 수 없습니다.
non.static.classes.not.allowed=비정적 내부 클래스는 특성에서 허용되지 않습니다.
selfType.class.does.not.inherit=@SelfType\: 클래스 ''{0}''은(는) ''{1}''을(를) 상속해 있지 않습니다.
illegal.type.void=올바르지 않은 타입\: ''void''
illegal.method.name=메서드 이름에 잘못된 문자가 있습니다. {0}
indexed.property.is.applicable.to.properties.only=@IndexedProperty는 프로퍼티에만 적용할 수 없습니다
listener.list.field.must.have.a.generic.collection.type=@ListenerList 필드는 제네릭 Collection 타입이 필요합니다
listener.list.field.with.generic.wildcards.not.supported=제네릭 와일드카드가 있는 @ListenerList 필드는 지원되지 않습니다
synchronized.not.allowed.on.abstract.method=@Synchronized는 추상 메서드에서 허용되지 않습니다
lock.field.0.must.be.static=잠금 필드 ''{0}''은(는) static이어야 합니다
lock.field.0.must.not.be.static=잠금 필드 ''{0}''은(는) static일 수 없습니다
lock.field.0.not.found=잠금 필드 ''{0}''을(를) 찾을 수 없습니다
select.module.action.text=모듈 선택...
select.module.action.description=클래스 경로를 사용할 모듈 선택
select.module.popup.title=모듈 클래스 경로 사용
### Inspection groups ###
inspection.annotations=어노테이션 검증
inspection.assignments=대입 이슈
inspection.bugs=발생할 수 있는 버그
inspection.confusing=코드 구문이 혼동될 수 있습니다.
inspection.control.flow=제어 흐름 이슈
inspection.data.flow=데이터 흐름
inspection.error.handling=오류 처리
inspection.gpath=GPath
inspection.naming=이름 지정 규칙
inspection.method.metrics=메서드 메트릭
inspection.redundancy=선언 중복성
inspection.threading=스레딩 문제
inspection.validity=유효성 이슈
inspection.style=스타일
inspection.other=기타
### Inspections ###
inspection.display.name.result.of.assignment.used=대입 결과 사용
inspection.display.name.assignment.can.be.operator.assignment=연산자 대입으로 대체 가능한 대입
inspection.display.name.delegates.to=@DelegatesTo 검사
inspection.display.name.unresolved.access=해결되지 않은 표현식에 액세스
inspection.display.name.untyped.access=타입이 지정되지 않은 표현식에 액세스
inspection.display.name.list.set.can.be.keyed.access=List.set 호출이 키 액세스일 수 있습니다
inspection.display.name.list.get.can.be.keyed.access=List.get 호출이 키 액세스일 수 있습니다
inspection.display.name.map.put.can.be.keyed.access=Map.put 호출이 키 액세스일 수 있습니다
inspection.display.name.map.get.can.be.keyed.access=Map.get 호출이 키 액세스일 수 있습니다
inspection.display.name.parameter.naming.convention=메서드 매개변수 이름 지정 규칙
inspection.display.name.constant.naming.convention=상수 이름 지정 규칙
inspection.display.name.instance.variable.naming.convention=인스턴스 변수 이름 지정 규칙
inspection.display.name.instance.method.naming.convention=인스턴스 메서드 이름 지정 규칙
inspection.display.name.static.variable.naming.convention=static 변수 이름 지정 규칙
inspection.display.name.static.method.naming.convention=static 메서드 이름 지정 규칙
inspection.display.name.local.variable.naming.convention=지역 변수 이름 지정 규칙
inspection.display.name.class.naming.convention=클래스 이름 지정 규칙
inspection.display.name.groovydoc.check=GroovyDoc 이슈
inspection.display.name.constructor.named.arguments=생성자 호출의 이름 지정된 인수
inspection.display.name.result.of.object.allocation.ignored=객체 대입의 결과가 무시됨
inspection.display.name.divide.by.zero=0으로 나누기
inspection.display.name.infinite.recursion=무한 재귀
inspection.display.name.infinite.loop.statement=무한 루프 문
inspection.display.name.non.short.circuit.boolean=비단락 회로 부울
inspection.display.name.duplicate.switch.branch=switch case 중복
inspection.display.name.gstring.key=GString 맵 키
inspection.display.name.octal.integer=8진 정수
inspection.display.name.overly.complex.boolean.expression=지나치게 복잡한 부울 표현식
inspection.display.name.clashing.trait.methods=특성 메서드 충돌
inspection.display.name.overly.complex.arithmetic.expression=지나치게 복잡한 산술 표현식
inspection.display.name.double.negation=이중 부정
inspection.display.name.pointless.arithmetic=무의미한 산술 표현식
inspection.display.name.empty.statement.body=본문이 비어 있는 구문
inspection.display.name.reassigned.in.closure.local.var=지역 변수가 클로저 또는 익명 클래스에 다시 대입됨
inspection.display.name.result.of.increment.or.decrement.used=사용된 증분 또는 감소의 결과
inspection.display.name.negated.if=부정된 if 조건식
inspection.display.name.in.argument.check=호환되지 않는 ''in'' 인수 타입
inspection.display.name.negated.conditional=부정된 조건식
inspection.display.name.nested.conditional=중첩된 조건식
inspection.display.name.conditional=조건식
inspection.display.name.nested.switch=부정된 switch 문
inspection.display.name.multiple.return.points.per.method=여러 반환점이 있는 메서드
inspection.display.name.method.with.more.than.three.negations=4개 이상의 부정이 있는 메서드
inspection.display.name.overly.nested.method=지나치게 중첩된 메서드
inspection.display.name.overly.long.method=지나치게 긴 메서드
inspection.display.name.overly.complex.method=지나치게 복잡한 메서드
inspection.display.name.method.parameter.count=매개변수가 너무 많은 메서드
inspection.display.name.while.loop.spins.on.field=while 루프가 필드에서 스핀
inspection.display.name.unsynchronized.method.overrides.synchronized.method=비동기화된 메서드가 동기화된 메서드를 재정의
inspection.display.name.synchronization.on.variable.initialized.with.literal=리터럴로 초기화된 변수 동기화
inspection.display.name.synchronization.on.non.final.field=비 final 필드 동기화
inspection.display.name.wait.while.not.synchronized=동기화되지 않은 ''wait()''
inspection.display.name.wait.call.not.in.loop=''wait()''가 루프에 없음
inspection.display.name.notify.while.not.synchronized=동기화되지 않은 ''wait()'' 또는 ''notify()''
inspection.display.name.system.run.finalizers.on.exit=System.runFinalizersOnExit() 호출
inspection.display.name.thread.stop.suspend.resume=Thread.stop(), Thread.suspend() 또는 Thread.resume() 호출
inspection.display.name.nested.synchronized.statement=중첩된 ''synchronized'' 문
inspection.display.name.synchronized.method=동기화된 메서드
inspection.display.name.synchronization.on.this=''this'' 동기화
inspection.display.name.empty.sync.block=빈 ''synchronized'' 블록
inspection.display.name.busy.wait=바쁜 대기
inspection.display.name.public.field.accessed.in.synchronized.context=동기화된 컨텍스트에서 비 private 필드 액세스
inspection.display.name.unconditional.wait=조건 없는 ''wait'' 호출
inspection.display.name.double.checked.locking=이중 검사된 잠금
inspection.display.name.access.to.static.field.locked.on.instance=static 필드에 대한 액세스가 인스턴스 데이터에서 잠겨 있음
inspection.display.name.change.to.method=메서드로 변경
inspection.display.name.change.to.operator=연산자로 변경
inspection.display.name.unnecessary.alias=불필요한 import 별칭
inspection.display.name.unnecessary.semicolon=불필요한 세미콜론
inspection.display.name.unnecessary.public.modifier=불필요한 ''public''
inspection.display.name.unnecessary.def.modifier=불필요한 ''def''
inspection.display.name.java.style.properties.invocation=Java 스타일 프로퍼티 액세스
inspection.display.name.trivial.if=중복 ''if'' 문
inspection.display.name.constant.if.statement=상수 if 문
inspection.display.name.constant.conditional=상수 조건식
inspection.display.name.trivial.conditional=중복 조건식
inspection.display.name.return.from.closure.can.be.implicit=''return'' 문이 묵시적일 수 있음
inspection.display.name.switch.statement.with.no.default=default case가 없는 switch 문
inspection.display.name.final.variable.access=final 변수 액세스
inspection.display.name.unnecessary.return=불필요한 ''return'' 문
inspection.display.name.unnecessary.continue=불필요한 ''continue'' 문
inspection.display.name.fallthrough=''switch'' 문의 폴스루
inspection.display.name.if.statement.with.too.many.branches=브랜치가 너무 많은 if 문
inspection.display.name.if.statement.with.identical.branches=브랜치가 동일한 if 문
inspection.display.name.conditional.can.be.conditional.call=조건식이 조건 호출일 수 있습니다
inspection.display.name.conditional.can.be.elvis=조건식이 elvis일 수 있습니다
inspection.display.name.conditional.with.identical.branches=동일한 브랜치가 있는 조건식
inspection.display.name.loop.statement.that.doesnt.loop=루프를 실행하지 않는 루프 문
inspection.display.name.unreachable.statement=도달할 수 없는 구문
inspection.display.name.continue=continue 문
inspection.display.name.break=break 문
inspection.display.name.unused.catch.parameter=사용되지 않는 catch 매개변수
inspection.display.name.empty.try.block=빈 ''try'' 블록
inspection.display.name.annotation.references.unknown.identifier=''includes'' 및 ''excludes'' 속성 내 알 수 없는 식별자
inspection.display.name.unresolved.labels.in.named.variant=@NamedVariant/@NamedParam/@NamedDelegate 변환 뒤 해결되지 않은 라벨
inspection.display.name.empty.finally.block=빈 ''finally'' 블록
inspection.display.name.empty.catch.block=빈 ''catch'' 블록
inspection.display.name.throw.from.finally.block=''finally'' 블록 내 ''throw''
inspection.display.name.return.from.finally.block=''finally'' 블록 내 ''return''
inspection.display.name.method.may.be.static=메서드가 static일 수 있습니다
inspection.display.name.continue.or.break.from.finally.block=''finally'' 블록 내 ''continue'' 또는 ''break''
inspection.display.name.unchecked.assignment.of.member.of.raw.type=원시 타입 멤버에서 검사되지 않은 대입
inspection.display.name.silly.assignment=잘못된 대입
inspection.display.name.nested.assignment=중첩된 대입
inspection.display.name.assignment.to.method.parameter=메서드 매개변수에 대입
inspection.display.name.assignment.to.for.loop.parameter=for-loop 매개변수에 대입
inspection.display.name.assignability.check=호환되지 않는 타입 대입
inspection.display.name.type.customizer=타입 커스터마이저 검사
inspection.display.name.unused.declaration=사용되지 않는 선언
inspection.display.name.second.unsafe.call=두 번째 안전하지 않은 호출
inspection.display.name.unused.assignment=사용되지 않는 대입
inspection.display.name.unused.inc.dec=사용되지 않는 증분 또는 감소
inspection.display.name.unassigned.access=변수가 대입되지 않음
inspection.display.name.no.return=return 문 누락
inspection.display.name.clashing.getters=getter 충돌
inspection.display.name.package.mismatch=패키지 불일치
inspection.display.name.deprecated.api.usage=곧 사용할 수 없게 될 API 검사
inspection.display.name.unnecessary.qualified.reference=불필요한 정규화된 참조
inspection.display.name.pointless.boolean=무의미한 부울 표현식
inspection.display.name.access.to.inaccessible.element=액세스할 수 없는 요소에 액세스
inspection.display.name.incorrect.range.argument=올바르지 않은 범위 인수
inspection.display.name.new.instance.of.singleton=@groovy.lang.Singleton 어노테이션이 추가된 클래스의 새 인스턴스
inspection.display.name.check.labeled.statement=라벨 지정된 구문 검사
inspection.display.name.variable.can.be.final=변수가 final일 수 있음
inspection.display.name.equals.between.inconvertible.types=변환할 수 없는 타입의 객체 간의 ''equals()''
inspection.display.name.singleton.constructor=@Singleton 생성자
inspection.display.name.implicit.null.argument=묵시적 null 인수
inspection.display.name.string.style.violation=문자열 스타일 위반
inspection.message.access.to.static.field.locked.on.instance.data=static 필드 <code>\#ref</code>에 대한 액세스가 인스턴스 데이터에서 잠김 \#loc
inspection.message.assignment.replaceable.with.operator.assignment=<code>\#ref</code>을(를) ''{0}''(으)로 단순화할 수 있습니다 \#loc
inspection.message.assignment.to.for.loop.parameter=for 루프 매개변수 ''\#ref''에 대입 \#loc
inspection.message.assignment.to.method.parameter=메서드 매개변수 ''\#ref''에 대입 \#loc
inspection.message.ref.statement=\#ref 문 \#loc
inspection.message.call.to.thread.ref.in.a.loop=루프 내 <code>Thread.\#ref()</code> 호출이 바쁜 대기 중일 수 있습니다 \#loc
inspection.message.conditional.expression.can.be.call=조건식이 호출일 수 있습니다 \#loc
inspection.message.conditional.expression.can.be.elvis=조건식이 elvis일 수 있습니다 \#loc
inspection.message.conditional.expression=조건식 \#loc
inspection.message.conditional.expression.with.identical.branches=동일한 브랜치가 있는 조건식 \#loc
inspection.message.ref.can.be.simplified=''\#ref''을(를) 단순화할 수 있습니다 \#loc
inspection.message.ref.statement.can.be.simplified=\#ref 문을 단순화할 수 있습니다 \#loc
inspection.message.constant.name.ref.too.short=상수 이름 ''\#ref''이(가) 너무 짧습니다
inspection.message.constant.name.ref.too.long=상수 이름 ''\#ref''이(가) 너무 깁니다
inspection.message.constant.name.ref.doesnt.match.regex=상수 이름 ''\#ref''이(가) 정규식 ''{0}''와(과) 일치하지 않습니다 \#loc
inspection.message.ref.inside.finally.block=''finally'' 블록 내 ''\#ref'' \#loc
inspection.message.divide.by.zero=0으로 나누기 \#loc
inspection.message.double.checked.locking=이중 검사된 잠금 \#loc
inspection.message.double.negation.ref=이중 부정 \#ref \#loc
inspection.message.duplicate.switch.case.ref=중복 switch case ''\#ref'' \#loc
inspection.message.empty.ref.block=빈 ''\#ref'' 블록 \#loc
inspection.message.ref.statement.has.empty.branch=''\#ref'' 문의 브랜치가 비어 있습니다
inspection.message.ref.statement.has.empty.body=''\#ref'' 문의 본문이 비어 있습니다
inspection.message.fallthrough.in.switch.statement=''switch'' 문의 폴스루 \#loc
inspection.message.gstring.used.as.maps.key=GString이 맵 키로 사용되었습니다 \#loc
inspection.message.ref.statement.cannot.complete.without.throwing.exception=<code>\#ref</code> 문은 예외를 던지지 않으면 완료되지 않습니다 \#loc
inspection.message.code.ref.code.recurses.infinitely.can.only.complete.by.throwing.exception=<code>\#ref</code>이(가) 무한 반복되며 예외를 던져야 완료됩니다 \#loc
inspection.message.instance.method.name.ref.too.short=인스턴스 메서드 이름 ''\#ref''이(가) 너무 짧습니다
inspection.message.instance.method.name.ref.too.long=인스턴스 메서드 이름 ''\#ref''이(가) 너무 깁니다
inspection.message.instance.method.name.ref.doesnt.match.regex=인스턴스 메서드 이름 ''\#ref''이(가) 정규식 ''{0}''와(과) 일치하지 않습니다 \#loc
inspection.message.instance.variable.name.ref.too.short=인스턴스 변수 이름 ''\#ref''이(가) 너무 짧습니다
inspection.message.instance.variable.name.ref.too.long=인스턴스 변수 이름 ''\#ref''이(가) 너무 깁니다
inspection.message.couldnt.find.property.field.with.this.name=이 이름을 가진 프로퍼티 또는 필드를 프레임을 찾을 수 없습니다 \#loc
inspection.message.instance.variable.name.ref.doesn.t.match.regex=인스턴스 변수 이름 ''\#ref''이(가) 정규식 ''{0}''와(과) 일치하지 않습니다 \#loc
inspection.message.call.to.ref.can.be.keyed.access=''\#ref'' 호출이 키 액세스일 수 있습니다 \#loc
inspection.message.ref.statement.with.identical.branches=동일한 브랜치가 있는 ''\#ref'' 문 \#loc
inspection.message.ref.statement.with.too.many.branches=''\#ref'' 문에 브랜치가 너무 많습니다({0}) \#loc
inspection.message.local.variable.name.ref.too.short=지역 변수 이름 ''\#ref''이(가) 너무 짧습니다
inspection.message.local.variable.name.ref.too.long=지역 변수 이름 ''\#ref''이(가) 너무 깁니다
inspection.message.local.variable.name.ref.doesnt.match.regex=지역 변수 이름 ''\#ref''이(가) 정규식 ''{0}''와(과) 일치하지 않습니다 \#loc
inspection.message.code.ref.code.statement.doesnt.loop=<code>\#ref</code> 문이 루프되지 않습니다 \#loc
inspection.message.method.ref.contains.too.many.parameters.0.1=모듈 ''\#ref''에 매개변수가 너무 많습니다({0}>{1})
inspection.message.method.ref.has.too.many.negations=메서드 ''\#ref''에 부정이 너무 많습니다({0}>3)
inspection.message.ref.has.0.return.points=<code>\#ref</code>에 {0}개의 반환점이 있습니다 \#loc
inspection.message.negated.conditional.expression=부정된 조건식 \#loc
inspection.message.negated.if.condition.expression=부정된 if 조건식 \#loc
inspection.message.nested.assignment.expression=중첩된 대입식 \#loc
inspection.message.nested.conditional.expression=중첩된 조건식 \#loc
inspection.message.nested.ref.statement=중첩된 ''\#ref'' 문 \#loc
inspection.message.non.short.circuit.boolean.expression=비단락 회로 부울 표현식 \#loc
inspection.message.call.to.ref.outside.synchronized.context=동기화된 컨텍스트 외부의 ''\#ref'' 호출 \#loc
inspection.message.octal.integer.ref=8진 정수 \#ref \#loc
inspection.message.overly.complex.arithmetic.expression=지나치게 복잡한 산술 표현식 \#loc
inspection.message.overly.complex.boolean.expression=지나치게 복잡한 부울 표현식 \#loc
inspection.message.method.ref.overly.complex.cyclomatic.complexity=메서드 ''\#ref''이(가) 지나치게 복잡합니다(순환 복잡도 \= {0}>{1})
inspection.message.method.ref.too.long.statement.count=메서드 ''\#ref''이(가) 지나치게 깁니다(구문 수 \= {0}>{1}})
inspection.message.method.ref.overly.nested.nesting.depth=메서드 ''\#ref''이(가) 지나치게 중첩되어 있습니다(중첩 깊이 \= {0}>{1})
inspection.message.method.parameter.name.ref.too.short=메서드 매개변수 이름 ''\#ref''이(가) 너무 짧습니다
inspection.message.method.parameter.name.ref.too.long=메서드 매개변수 이름 ''\#ref''이(가) 너무 깁니다
inspection.message.method.parameter.name.ref.doesnt.match.regex=메서드 매개변수 이름 ''\#ref''이(가) 정규식 ''{0}''와(과) 일치하지 않습니다 \#loc
inspection.message.non.private.field.accessed.in.synchronized.context=동기화된 컨텍스트에서 비 private 필드 <code>\#ref</code>이(가) 액세스됩니다 \#loc
inspection.message.nested.assignment=대입 표현식의 결과가 사용되었습니다 \#loc
inspection.message.result.increment.or.decrement.expression.used=사용된 증분 또는 감소 표현식의 결과 \#loc
inspection.message.result.of.new.ref.is.ignored=<code>새 \#ref{0}</code>의 결과가 무시되었습니다 \#loc
inspection.message.ref.statement.at.end.closure.can.be.made.implicit=클로저 끝의 \#ref 문을 묵시적으로 만들 수 있습니다 \#loc
inspection.message.silly.assignment=잘못된 대입 \#loc
inspection.message.static.method.name.ref.too.short=정적 메서드 이름 ''\#ref''이(가) 너무 짧습니다
inspection.message.static.method.name.ref.too.long=정적 메서드 이름 ''\#ref''이(가) 너무 깁니다
inspection.message.static.method.name.ref.doesnt.match.regex=정적 메서드 이름 ''\#ref''이(가) 정규식 ''{0}''와(과) 일치하지 않습니다 \#loc
inspection.message.static.variable.name.ref.too.short=정적 변수 이름 ''\#ref''이(가) 너무 짧습니다
inspection.message.label.name.ref.not.supported.by.0={0}은(는) 라벨 이름 ''\#ref''을(를) 지원하지 않습니다
inspection.message.static.variable.name.ref.too.long=정적 변수 이름 ''\#ref''이(가) 너무 깁니다
inspection.message.static.variable.name.ref.doesnt.match.regex=정적 변수 이름 ''\#ref''이(가) 정규식 ''{0}''와(과) 일치하지 않습니다 \#loc
inspection.message.property.0.is.final=프로퍼티 ''{0}''이(가) final입니다 \#loc
inspection.message.ref.statement.with.no.default.branch=default 브랜치가 없는 \#ref 문 \#loc
inspection.message.synchronization.on.non.final.field.ref=비 final 필드 ''\#ref'' 동기화 \#loc
inspection.message.synchronization.on.ref=\ ''\#ref'' 동기화 \#loc
inspection.message.synchronization.on.variable.ref.which.was.initialized.with.literal=리터럴로 초기화된 변수 ''\#ref'' 동기화 \#loc
inspection.message.synchronized.method.ref=동기화된 메서드 ''\#ref'' \#loc
inspection.message.call.to.system.ref=''System.\#ref'' 호출 \#loc
inspection.message.call.to.thread.ref=''스레드.\#ref'' 호출 \#loc
inspection.message.0.can.be.simplified.to.1=''{0}''을(를) ''{1}''(으)로 단순화할 수 있습니다 \#loc
inspection.message.property.0.is.ignored.by.map.constructor=프로퍼티 ''{0}''이(가) @MapConstructor에 의해 무시되었습니다 \#loc
inspection.message.unconditional.call.to.ref=<code>\#ref()</code>을(를) 조건 없이 호출합니다 \#loc
inspection.message.ref.is.unnecessary.as.last.statement.in.loop=루프의 마지막 구문으로서 \#ref 은(는) 불필요합니다 \#loc
inspection.message.ref.is.unnecessary.as.last.statement.in.method.with.no.return.value=반환값이 없는 메서드의 마지막 구문으로서 \#ref 은(는) 불필요합니다 \#loc
inspection.message.unreachable.statement=도달할 수 없는 명령문 \#loc
inspection.message.unsynchronized.method.ref.overrides.synchronized.method=비동기화된 메서드 ''\#ref''이(가) 동기화된 메서드를 재정의합니다 \#loc
inspection.message.cannot.determine.type.ref=''\#ref''의 타입을 파악할 수 없습니다
inspection.message.call.to.ref.outside.of.loop=루프 외부에서 ''\#ref'' 호출 \#loc
inspection.message.call.to.ref.outside.of.synchronized.context=동기화된 컨텍스트 외부에서 ''\#ref'' 호출 \#loc
inspection.message.ref.loop.spins.on.field=<code>\#ref</code> 루프가 필드에서 스핀합니다 \#loc
inspection.message.package.name.mismatch=패키지 이름 불일치
inspection.message.dsl.descriptor.file.has.been.changed.and.isnt.currently.executed=DSL 설명자 파일이 변경되어 현재 실행되지 않습니다
inspection.message.dsl.descriptor.file.has.been.disabled.due.to.processing.error=처리 오류로 인해 DSL 설명자 파일이 비활성화되었습니다
inspection.message.traits.0.contain.clashing.methods.with.signature.1=시그니처 {1}이(가) 포함된 충돌 메서드가 특성 {0}에 있습니다
inspection.message.unused.catch.parameter.ref=사용되지 않는 catch 매개변수 ''\#ref'' \#loc
inspection.message.package.name.mismatch.actual.0.expected.1=패키지 이름 불일치. 실제\: ''{0}'', 필요\: ''{1}''
inspection.message.property.not.indexable.type.must.be.array.or.list.but.found.0=프로퍼티는 색인 생성할 수 없습니다. 타입은 배열 또는 목록이어야 하나 {0}이(가) 발견됩니다
inspection.message.type.argument.0.can.not.be.1=인수 ''{0}''의 타입은 ''{1}''일 수 없습니다
inspection.message.method.called.with.implicit.null.argument=메서드는 묵시적 null 인수로 호출됩니다
inspection.message.plain.string.should.be.double.quoted=일반 문자열은 큰따옴표로 묶어야 합니다
inspection.message.plain.string.should.be.single.quoted=일반 문자열은 작은따옴표로 묶어야 합니다
inspection.message.plain.string.should.be.slashy.quoted=일반 문자열은 슬래시로 묶어야 합니다
inspection.message.plain.string.should.be.dollar.slashy.quoted=일반 문자열은 달러 슬래시로 묶어야 합니다
inspection.message.plain.string.should.be.quoted.with.triple.quotes=일반 문자열은 ''''로 묶어야 합니다
inspection.message.plain.string.should.be.quoted.with.triple.double.quotes=일반 문자열은 ''"""로 묶어야 합니다
inspection.message.multiline.string.should.be.quoted.with.triple.quotes=여러 줄 문자열은 ''''로 묶어야 합니다
inspection.message.multiline.string.should.be.quoted.with.triple.double.quotes=여러 줄 문자열은 """로 묶어야 합니다
inspection.message.multiline.string.should.be.slashy.quoted=여러 줄 문자열은 슬래시로 묶어야 합니다
inspection.message.multiline.string.should.be.dollar.slashy.quoted=여러 줄 문자열은 달러 슬래시로 묶어야 합니다
inspection.message.string.escaping.could.be.minimized=이스케이프를 최소화할 수 있습니다
inspection.message.interpolated.string.should.be.double.quoted=보간된 문자열은 큰따옴표로 묶어야 합니다
inspection.message.interpolated.string.should.be.dollar.slashy.quoted=보간된 문자열은 달러 슬래시로 묶어야 합니다
inspection.message.interpolated.string.should.be.slashy.quoted=보간된 문자열은 슬래시로 묶어야 합니다
inspection.message.interpolated.string.should.be.quoted.with.triple.double.quotes=보간된 문자열은 ''"""로 묶어야 합니다
text.class.0.is.unused=클래스 {0}이(가) 사용되지 않습니다
text.constructor.0.is.unused=생성자 {0}이(가) 사용되지 않습니다
text.method.0.is.unused=메서드 {0}이(가) 사용되지 않습니다
text.property.0.is.unused=프로퍼티 {0}이(가) 사용되지 않습니다
text.parameter.0.is.unused=매개변수 {0}이(가) 사용되지 않습니다
### Intention groups ###
intention.category.groovy=Groovy
intention.category.conversions=Groovy/표현식 변환
intention.category.closures=Groovy/클로저
intention.category.comments=Groovy/주석
intention.category.groovy.style=Groovy/Groovy 스타일
intention.category.control.flow=Groovy/제어 흐름
intention.category.groovy.declaration=Groovy/선언
intention.category.groovy.other=Groovy/기타
configurable.GroovyCompilerConfigurable.display.name=Groovy 컴파일러
configurable.GantConfigurable.display.name=Gant
settings.compiler.alternative=다른 방법으로, <a href\="\#">Java 컴파일러 페이지</a>에서 Groovy-Eclipse 컴파일러를 지정할 수 있습니다.
settings.compiler.select.path.to.groovy.compiler.configscript=Groovy 컴파일러의 구성 스크립트 경로 선택
settings.compiler.path.to.configscript=구성 스크립트 경로(&C)\:
settings.compiler.invoke.dynamic.support=동적 지원 실행(&D)
settings.compiler.exclude.from.stub.generation=스텁 생성에서 제외\:
settings.code.style.label.indent.style=라벨 들여쓰기 스타일\:
settings.code.style.label.indent.size=라벨 들여쓰기 크기\:
settings.code.style.indent.statements.after.label=라벨 다음 구문 들여쓰기
settings.code.style.absolute=절대
settings.code.style.indent.labels=라벨 들여쓰기
settings.inlay.parameter.types=매개변수 타입
settings.inlay.inferred.parameter.types=추론된 매개변수 타입
settings.inlay.type.parameter.list=타입 매개변수 목록
settings.inlay.show.type.hints.for=다음에 대한 타입 힌트 표시\:
intention.name.replace.with.in=''\:''을 ''in''으로 바꾸기
intention.name.activate.back=다시 활성화
intention.name.cast.to.0={0}(으)로 형 변환
intention.name.replace.eq.with.0.eq=''\=''를 ''{0}\=''로 바꾸기
intention.name.cast.operand.to.0=피연산자를 {0}(으)로 형 변환
intention.name.add.required.attributes.to.map.constructor=@MapConstructor에 필수 속성 추가
intention.name.convert.to.single.quoted.string=작은따옴표로 묶인 문자열로 변환
intention.name.change.quotes.to.triple.single.quotes=따옴표를 "로 변경
intention.name.convert.to.double.quoted.string=큰따옴표로 묶인 문자열로 변환
intention.name.change.quotes.to.triple.double.quotes=따옴표를 """로 변경
intention.name.convert.to.slashy.string=슬래시 문자열로 변환
intention.name.convert.to.dollar.slashy.string=달러 슬래시 문자열로 변환
intention.family.name.create.field=필드 생성
action.remove.dynamic.member.text=제거
action.remove.dynamic.member.description=동적 멤버 제거
action.collapse.all.text=모두 접기
action.collapse.all.description=모두 접기
action.expand.all.text=모두 펼치기
action.expand.all.description=모두 펼치기
dynamic.members.column.name.element=동적 요소
dynamic.members.column.name.type=타입
command.name.add.dynamic.member=동적 멤버 추가
popup.content.navigation.to.overriding.classes.unavailable=색인 업데이트 중에는 재정의하는 클래스로 이동할 수 없습니다
overriding.methods.of.0=''{0}''의 재정의하는 메서드
expression.type.no.expression=표현식을 찾을 수 없습니다
expression.type.unknown=<알 수 없음>
add.class.to.extends.family.name=구현
intention.family.name.rename=이름 변경
generated.stub.message=이 스텁은 Groovy 클래스가 Groovy-Java 크로스 컴파일할 수 있도록 하기 위해 생성됩니다
generated.stub.navigate.link.label=Groovy 클래스로 이동
generated.stub.exclude.link.label=스텁 생성에서 제외
module.with.groovy=Groovy 라이브러리가 연결된 간단한 모듈
action.build.restart.text=빌드 후 다시 시작
action.build.module.restart.description=모듈 ''{0}'' 빌드 후 다시 시작
gdsl.investigate.link.label=여기를 클릭하여 조사
gdsl.error.notification.title=DSL 스크립트 실행 오류
dialog.message.gant.not.configured=Gant가 구성되지 않았습니다
investigate.gdsl.error.intention.name=세부 정보 표시
investigate.gdsl.error.family.name=DSL 설명자 프로세스 오류 조사
grab.intention.name=아티팩트 Grab
grab.family.name=Grab
grab.progress.title=@Grab 어노테이션 처리 중
grab.result.title={0}개의 Grape 종속 요소 {0, choice, 0\#jar|1\#jar|2\#jar}이 추가됨
grab.jar.count=<b>{0}</b>\: {1}개의 {1, choice, 0\#jar|1\#jar|2\#jar}
grab.error.ivy.missing.title=Ivy 누락
grab.error.ivy.missing.message=IDEA는 Apache Ivy 없이 종속 요소를 @Grab할 수 없습니다. Apache Ivy를 모듈 종속 요소에 추가한 후 액션을 재실행하세요.
grab.error.0.title=@Grab을 실행할 수 없음\: {0}
this.super.completion.advertisement=클래스 한정자 없이 {0}을(를) 두 번 누르면 액세스 가능한 모든 정적 메서드가 표시됩니다
optimize.imports.progress.title=Groovy 파일에서 import 문 최적화 중...
groovy.library.label=Groovy 라이브러리
replace.all.occurrences.and.remove.variable.0=모든 찾은 항목 바꾸기 및 변수 ''{0}'' 제거
introduce.variable.declare.final.label=final 선언(&F)
introduce.variable.replace.all.occurrences=모든 찾은 항목 바꾸기(&A)
introduce.variable.replace.all.0.occurrences=모든 찾은 항목 바꾸기({0}개의 찾은 항목)(&A)
introduce.parameter.delegate.via.overload=오버로드 메서드를 통한 위임(&L)
introduce.parameter.replace.fields.border.title=표현식에 사용된 필드를 getter로 바꾸기
introduce.parameter.do.not.replace.option.label=바꾸기 안 함(&O)
introduce.parameter.replace.inaccessible.fields.option.label=사용 컨텍스트에서 액세스할 수 없는 필드 바꾸기(&I)
introduce.parameter.replace.all.fields.option.label=모든 필드 바꾸기(&R)
introduce.variable.type.label=타입(&T)\:
introduce.variable.name.label=이름(&N)\:
introduce.parameter.explicit.return.statement.option.label=명시적 return 문 사용(&X)
introduce.parameter.delegating.unavailable.tooltip=위임은 클로저 컨텍스트에서 허용되지 않습니다
introduce.variable.change.type.advertisement={0}을(를) 눌러 타입 변경
framework.0.home.label={0} 홈\:
select.framework.0.home.title={0} 홈 선택
framework.0.sdk.chooser.title={0} SDK
framework.0.sdk.chooser.description={0} 배포판이 있는 디렉터리 선택
framework.0.sdk.chooser.error.message=지정된 경로의 {0} 배포판이 손상된 것 같습니다. 버전을 파악할 수 없습니다.
framework.0.sdk.chooser.error.title=클래스 생성 실패
framework.0.library={0} 라이브러리
framework.0.library.version.1={0} 라이브러리 버전 {1}
framework.gant=Gant
script.runner.display.name=Groovy
script.runner.description=Groovy 클래스 또는 스크립트
script.runner.chooser.title=스크립트 경로
script.runner.chooser.description=스크립트 경로 지정\:
script.runner.module.not.specified.message=모듈이 지정되지 않았습니다
script.runner.no.groovy.for.module=Groovy가 모듈 ''{0}''에 대해 구성되지 않았습니다
script.runner.cant.find.script=스크립트 ''{0}''을(를) 찾을 수 없습니다
script.runner.unknown.script.type=알 수 없는 스크립트 타입 ''{0}''
script.runner.file.is.not.groovy.file=스크립트 파일이 Groovy 파일이 아닙니다
script.runner.class.does.not.exist=클래스가 없습니다.
script.runner.class.cannot.be.executed=클래스를 실행할 수 없습니다
shell.cannot.run.title=실행할 수 없음
dialog.title.refactoring.unavailable.in.current.scope=현재 범위에서는 리팩터링을 사용할 수 없음
parameter.list.owner.chooser.title=다음으로 매개변수 삽입
extract.closure.command.name=클로저 추출
introduce.constant.title=상수 삽입
undefined.library.version=정의되지 않음
method.parameters.count.max.parameters.option=최대 매개변수 개수\:
method.returns.max.returns.option=반환점 제한\:
overly.complex.method.complexity.limit.option=메서드 복잡도 제한\:
overly.long.method.statements.limit.option=메서드당 최대 구문 수\:
overly.nested.method.nesting.limit.option=최대 중첩 깊이\:
add.method.family=메서드 추가
change.base.method.label=기본 메서드 변경
change.usages.label=사용 위치 변경
convert.parameter.to.map.entry.title=매개변수를 맵 항목으로 변환
live.template.context.declaration=선언
live.template.context.expression=표현식
live.template.context.statement=구문
find.usages.method.0.of.class.1={1} 내 {0}
change.signature.type.column=타입
change.signature.default.initializer.column=디폴트 이니셜라이저
static.import.method.fix=static import 메서드...
static.import.method.0.fix=static import 메서드 ''{0}''
groovy.consoles.type=Consola Groovy
getter.kind.gdk.method.0=GDK 메서드 {0}
getter.kind.method.0=메서드 {0}
getter.kind.getter.0=getter {0}
parameter.hint.number.of.arguments={0, choice, 0\#|1\#{0}개의 인수|2\#{0}개의 인수}
surround.with.for=for
surround.with.if=if
surround.with.if.else=if / else
surround.with.if.expr=if (expr)
surround.with.if.else.expr=if (expr) / else
surround.with.parentheses=(expr)
surround.with.closure={ -> ... }.call()
surround.with.try=try
surround.with.try.catch=try / catch
surround.with.try.finally=try / finally
surround.with.try.catch.finally=try / catch / finally
surround.with.while=while
surround.with.while.expr=while (expr)
surround.with.cast=((Type) expr)
surround.with.with=with () {...}
surround.with.with.expr=with (expr)
surround.with.shouldFail=shouldFail () {...}
code.style.group.list.map.literals=List 및 Map 리터럴
code.style.option.align.when.multiple=여러 개일 경우 정렬
code.style.option.align.multiline.named.arguments=여러 줄의 이름 지정된 인수 정렬
code.style.option.use.flying.geese.braces=닫는 중괄호를 한 줄에 입력
code.style.option.import.annotations=어노테이션 가져오기
code.style.option.simple.lambdas.closures.in.one.line=한 줄의 간단한 람다/클로저
code.style.option.relational.operators=관계 연산자(<, >, <\=, >\=, <\=>)
code.style.option.unary.operators=단항 연산자(\!, -, +, ++, --, *)
code.style.option.in.named.argument.before.colon=''\:'' 앞 이름 지정된 인수 내
code.style.option.in.named.argument.after.colon=''\:'' 뒤 이름 지정된 인수 내
code.style.option.list.maps.literals=List 및 Map 리터럴
code.style.option.closure.left.brace.in.method.calls=메서드 호출 내 왼쪽 중괄호 클로저
code.style.option.gstring.injection.braces=GString 삽입 중괄호
code.style.option.tuple.assignment.expression=튜플 대입 표현식
code.style.option.regexp.expression=정규 표현식 (\=\=~, \=~)
code.style.option.before.assert.separator=''assert'' 구분 기호 앞
code.style.option.after.assert.separator=''assert'' 구분 기호 뒤
# @Singleton
singleton.constructor.found=@Singleton 클래스는 생성자를 포함할 수 없습니다
singleton.constructor.remove=생성자 제거
singleton.constructor.makeNonStrict=@Singleton을 비 strict로 만들기
########################################################################################################################
# Unused imports
########################################################################################################################
unused.import=사용되지 않는 import 문
optimize.imports=import 문 최적화
optimize.all.imports=사용되지 않는 import 문 최적화
########################################################################################################################
# Create class fix
########################################################################################################################
dialog.create.class.package.chooser.title=대상 패키지 선택
create.directory.command=디렉터리  생성
destination.package=대상 패키지\:
second.unsafe.call=두 번째 안전하지 않은 호출
call.can.throw.npe=호출 체인이 NullPointerException을 던질 수 있습니다
unused.default.parameter.message=디폴트 매개변수가 사용되지 않습니다
unused.default.parameter.fix=이니셜라이저 제거
unused.assignment.tooltip=대입이 사용되지 않습니다
unused.variable=변수가 사용되지 않습니다
variable.can.be.final.tooltip=변수 ''{0}''은(는) final이 될 수 있습니다
parameter.can.be.final.tooltip=매개변수 ''{0}''은(는) final이 될 수 있습니다
equals.between.inconvertible.types.tooltip=<code>{0}</code>이(가) 변환할 수 없는 타입인 ''{1}'' 및 ''{2}''의 객체 사이에 있습니다
replace.with.operator.message=''{0}''을(를) 연산자로 바꿀 수 있습니다
replace.with.operator.fix=''{0}''을(를) 연산자로 바꾸기
replace.with.operator.double.negation.option=이중 부정 사용(예\: \!\!)
replace.with.operator.compareTo.equality.option=''compareTo'' 등식을 equals(예\: \=\=)로 바꾸기
replace.with.operator.parentheses=추가 소괄호가 필요한 경우 연산자로 바꾸도록 제안 안 함
replace.with.method.message=''{0}'' 메서드 호출로 바꿀 수 있습니다
replace.with.method.fix=''{0}'' 메서드로 바꾸기
unassigned.access.tooltip=변수 ''{0}''은(는) 대입되지 않을 수 있습니다
no.return.message=일부 실행 경로가 값을 반환하지 않습니다
unresolved.type.status=타입 ''{0}''이(가) 해결되지 않았습니다
no.type.specified=지정된 타입이 없습니다
dynamic.element=동적 요소
pointless.boolean.problem.descriptor=\#ref을(를) ''{0}''(으)로 단순화할 수 있습니다 \#loc
pointless.arithmetic.error.message=\#ref을(를) ''{0}''(으)로 바꿀수 있습니다 \#loc
pointless.boolean.quickfix=단순화
Cannot.perform.undo.operation=연산을 실행 취소할 수 없습니다
Undo.disable=비활성화 실행 취소
type.doesnt.contain.method=타입 ''{0}''에 메서드 ''{1}''이(가) 없으므로 해당 타입을 범위 내에서 반복할 수 없습니다
type.doesnt.implement.comparable=타입 ''{0}''이(가) Comparable을 구현하지 않습니다
add.method=메서드 ''{0}()''을(를) ''{1}''에 추가
implement.class={0} 구현
fix.class=클래스 {0} 수정
rtype.cannot.contain.ltype=''{1}''은(는) ''{0}''을(를) 포함할 수 없습니다
new.instance.of.singleton=@groovy.lang.Singleton 어노테이션이 추가된 클래스의 새 인스턴스
replace.new.expression.with.instance.access=인스턴스 액세스로 바꾸기
getter.0.clashes.with.getter.1=충돌 발생\: ''{0}'' 및 ''{1}''
unused.0=사용하지 않는 {0}
remove.0={0} 제거
replace.postfix.0.with.prefix.0=접미사 {0}을(를) 접두사 {0}(으)로 바꾸기
replace.0.with.1={0}을(를) 이항 {1}(으)로 바꾸기
local.var.0.is.reassigned=지역 변수 ''{0}''이(가) 다시 대입되었습니다
anonymous.class=익명 클래스
closure=클로저
other.scope=기타 범위
method.may.be.static=메서드가 static일 수 있습니다
method.may.be.static.option.ignore.trait.methods=특성 메서드 무시
method.may.be.static.only.private.or.final.option=final 또는 private 메서드만 검사
method.may.be.static.ignore.empty.method.option=빈 메서드 무시
ignore.boolean.expressions=부울 검사 시 대입되지 않은 변수 무시
highlight.if.groovy.object.methods.overridden=invokeMethod(), getProperty() 또는 setProperty()를 재정의하는 클래스의 참조를 강조 표시
highlight.if.missing.methods.declared=missingMethod() 또는 missingProperty()를 선언하는 클래스의 참조를 강조 표시
gr.package.inspection.check.scripts=스크립트 검사
java.style.property.access=Java 스타일 접근자 호출
type.customizer.is.not.marked.as.a.resource.file=타입 커스터마이저 스크립트가 컴파일러 리소스로 표시되지 않았습니다
add.to.resources=리소스에 추가
add.type.customizer.to.resources=타입 커스터마이저 스크립트를 리소스에 추가
target.0.does.not.exist=대상 ''{0}''이(가) 없습니다
target.annotation.is.unused=@Target은 사용되지 않습니다
change.lvalue.type=변수 ''{0}'' 타입을 ''{1}''(으)로 변경
replace.qualified.name.with.import=정규화된 이름을 import 문으로 바꾸기
comments.count.as.content=주석을 내용으로 계산
ignore.when.catch.parameter.is.named.ignore.or.ignored=catch 매개변수의 이름이 ignore 또는 ignored로 지정된 경우 무시
no.applicable.signature.found=적용 가능한 시그니처를 찾을 수 없습니다
expected.type.0=''{0}''이(가) 필요하나 ''{1}''이(가) 발견되었습니다
declare.explicit.implementations.of.trait=특성의 명시적 구현 선언
unnecessary.modifier.description=제어자 ''{0}''은(는) 필요하지 않습니다
unnecessary.modifier.remove=불필요한 ''{0}'' 제거
unnecessary.def.explicitly.typed.only=명시적으로 타입 지정된 선언에서만 보고
unnecessary.alias.fix=불필요한 별칭 제거
unnecessary.alias.description=별칭이 필요하지 않습니다
unnecessary.semicolon.description=세미콜론이 필요하지 않습니다
unnecessary.semicolon.fix=세미콜론 제거
dynamic.dialog.class.label=클래스(&C)\:
dynamic.dialog.type.label=타입(&T)\:
dynamic.dialog.static.checkbox=정적(&S)
find.method.ro.method.usages=프로젝트 파일 내 둘러싸는 메서드의 사용 위치 검색 중
find.method.ro.closure.usages=프로젝트 파일 내 둘러싸는 클로저의 사용 위치 검색 중
conversion.method.not.allowed.in.non.groovy.files=Groovy가 아닌 파일에서 사용되는 메서드에는 리팩터링을 사용할 수 없습니다.
conversion.closure.not.allowed.in.non.groovy.files=Groovy가 아닌 파일에서 사용되는 클로저에는 리팩터링을 사용할 수 없습니다.
wrong.method.first.parameter.type=메서드 ''{0}''은(는) 이름 지정된 인수와 함께 사용되지만 내부의 첫 번째 인수 ''{1}''이(가) Map 타입을 준수하지 않습니다.
wrong.closure.first.parameter.type=클로저 ''{0}''은(는) 이름 지정된 인수와 함께 사용되지만 내부의 첫 번째 인수 ''{1}''이(가) Map 타입을 준수하지 않습니다.
map.parameter.dialog.create.new.checkbox=이름 지정된 인수의 새 매개변수 생성(&C)
map.parameter.dialog.explicit.type.checkbox=명시적으로 타입 지정
convert.cannot.itself=리팩터링은 맵 매개변수 자체에 사용할 수 없습니다
map.param.name=맵 매개변수 이름(&N)\:
convert.param.to.map.entry=매개변수를 맵 항목으로 변환
closure.used.as.variable=클로저가 인수로서 전달되었습니다. 리팩터링을 하면 의미가 변경될 수 있습니다.
do.you.want.to.change.method.return.type=''{0}'' 메서드의 반환 타입을 변경하시겠어요?
do.you.want.to.change.variable.type=''{0}''의 타입을 변경하시겠어요?
closure.is.accessed.outside.of.groovy=필드 <b>{0}</b>이(가) Groovy 외부에서 액세스됩니다
write.access.to.closure.variable=필드 <b>{0}</b>에 대한 쓰기 액세스
field.is.used.in.argument.label=필드 <b>{0}</b>이(가) 인수 라벨에서 사용됩니다
method.with.signature.already.exists=시그니처 {0}이(가) 포함된 메서드가 이미 있습니다
field.already.exists=필드 <b>{0}</b>이(가) 이미 있습니다
method.is.used.outside.of.groovy=메서드가 Groovy 외부에서 사용됩니다
do.you.want.to.change.type.of.parameter.in.method=메서드 ''{1}''에서 매개변수 ''{0}''의 타입을 변경하시겠어요?
file.exists=파일 ''{0}''이(가) 디렉터리 ''{1}''에 이미 있습니다
move.to.correct.dir.family.name=올바른 패키지로 파일 이동
move.to.correct.dir=''{0}''(으)로 이동
add.return.type=반환 타입 추가
add.return.type.to.method.declaration=반환 타입을 메서드 선언에 추가
infer.method.parameters.types=명시적 타입을 매개변수에 추가
infer.method.parameters.types.for.method.declaration=메서드 선언 내 모든 매개변수의 명시적 타입을 추가
replace.with.wrapper={0}(으)로 바꾸기
replace.primitive.type.with.wrapper=기본 타입을 래퍼로 바꾸기
remove.parameter.0=매개변수 ''{0}'' 제거
remove.unused.parameter=사용되지 않은 매개변수 제거
remove.exception=예외 제거
remove.catch.block=catch 블록 제거
try.catch.fix=try-catch 수정
cannot.create.class=클래스를 생성할 수 없음
rename.file.to.0=파일 이름을 ''{0}''(으)로 변경
java.style.properties.invocation.intention.family.name=Java 스타일 접근자 호출을 Groovy 스타일 프로퍼티 참조로 변경
java.style.properties.invocation.intention.name=Groovy 스타일 프로퍼티 참조로 변경
generate.equals.and.hashcode.already.defined.warning.anonymous=equals() 및 hashCode()가 이미 정의되어 있음
generate.equals.and.hashcode.already.defined.warning=equals() 및 hashCode()가 이미 정의되어 있음
generate.equals.and.hashcode.already.defined.title=equals() 및 hashCode()가 이미 정의되어 있음
generate.equals.compare.nested.arrays.comment= // 여기 {0}의 중첩된 배열 - 값 비교
generate.equals.compare.arrays.comment= // Object[] 배열을 Arrays.equals와 비교하면 올바르지 않을 수 있음
generate.property.missing.already.defined.warning=propertyMissing()이 이미 정의되어 있음
generate.property.missing.already.defined.title=propertyMissing()이 이미 정의되어 있음
generate.method.missing.already.defined.warning=methodMissing()이 이미 정의되어 있음
generate.method.missing.already.defined.title=methodMissing()이 이미 정의되어 있음
action.Gant.NewScript.text=Gant 스크립트
action.Gant.NewScript.description=새 Gant 스크립트 생성
action.Groovy.Console.text=Consola Groovy
action.Groovy.Console.description=Inicia la consola Groovy
module.name.0.and.groovy.version.1={0}({1})
groovy.version.0=Groovy {0}
groovy.version.bundled.0=번들 Groovy {0}
configurable.greclipse.border.title=Groovy-Eclipse 옵션
configurable.greclipse.path.label=groovy-eclipse-batch jar 경로\:
configurable.greclipse.path.chooser.description=Groovy 배포판과 일치하는 버전의 groovy-eclipse-batch-*.jar 경로 선택
configurable.greclipse.command.line.params.label=추가 명령줄 매개변수\:
configurable.greclipse.debug.checkbox=디버그 정보 생성
configurable.hotswap.checkbox=Groovy 코드의 핫스왑 에이전트 활성화
configurable.hotswap.checkbox.description=디버그된 애플리케이션에서 직렬화 문제가 발생할 수 있습니다
run.configuration.script.path.label=스크립트 경로\:
run.configuration.vm.options.label=VM 옵션(&V)\:
run.configuration.module.chooser.label=모듈(&M)\:
run.configuration.module.classpath.checkbox=러너에 모듈 클래스 경로 추가(&C)
pull.up.wont.be.accessible.from={1}에서 {0}에 액세스할 수 없습니다
pull.up.wont.be.accessible.from.the.subclass={0}이(가) 하위 클래스에서 액세스할 수 없는 {1}을(를) 사용합니다.
pull.up.abstract.wont.be.accessible.from={0}은(는) 하위 클래스에서 액세스할 수 없으므로 추상으로 만들 수 없습니다.
settings.inlay.implicit.null.argument=묵시적 null 인수
settings.inlay.show.hints.for.implicit.null.argument=묵시적 null 인수에 관한 힌트 표시
header.extract.closure=클로저 추출
string.sort.default=디폴트
string.sort.strings.with.escaping=이스케이프 문자를 포함하는 문자열
string.sort.strings.with.interpolation=보간 표현식을 포함하는 문자열
string.sort.multiline.string=여러 줄 문자열
separator.preferable.string.kind=선호 종류
separator.domain.of.inspection.usage=사용 위치 도메인
checkbox.inspect.gradle.files=Gradle 파일 검사
string.option.do.not.handle.specifically=특별히 처리 안 함
string.option.double.quoted.string=큰따옴표로 묶인 문자열
string.option.single.quoted.string=작은따옴표로 묶인 문자열
string.option.slashy.string=슬래시 문자열
string.option.triple.quoted.string=삼중 작은따옴표로 묶인 문자열
string.option.triple.double.quoted.string=삼중 큰따옴표로 묶인 문자열
string.option.dollar.slashy.string=달러 슬래시 문자열
gdsl.trusted.project.message=이 프로젝트는 Groovy DSL(GDSL) 스크립트를 포함하여 Groovy 코드 편집 시 코드 분석 경험을 향상합니다. GDSL 스크립트는 잠재적 악성 코드를 포함할 수 있으며 이 코드는 IDE 내에서 실행됩니다. 이 스크립트를 실행하시겠습니까?
gdsl.trusted.project.answer.trust=예
gdsl.trusted.project.answer.dont.trust=아니요
