swift.name=Swift
code.style.indent.group.title.directives=지시문
code.style.indent.multiline.strings=여러 줄의 문자열 들여쓰기
code.style.indent.directives.as.code=코드 들여쓰기 준수
code.style.indent.directives.children=하위 항목 들여쓰기
code.style.spaces.group.title.colon=콜론 주위
code.style.spaces.group.title.in.ternary=삼항 조건 연산 내
code.style.spaces.before.method.parentheses=메서드/함수 선언 소괄호
code.style.spaces.after.operator.in.function.declarations=함수 선언 내 연산자
code.style.spaces.before.method.call.parentheses=메서드/함수 호출 소괄호
code.style.spaces.equality.operator=상등 연산자 ''\=\=''
code.style.spaces.shift.operators=시프트 연산자(<<, >>)
code.style.spaces.around.range.operators=범위 연산자 (..., ..<)
code.style.spaces.closure.arrow=클로저 화살표(->)
code.style.spaces.attribute.parameters=속성 매개변수
code.style.spaces.within.literal.brackets=배열 및 사전 리터럴 대괄호
code.style.spaces.within.method.parentheses=메서드/함수 선언 소괄호
code.style.spaces.within.empty.method.parentheses=빈 메서드/함수 선언 소괄호
code.style.spaces.within.method.call.parentheses=메서드/함수 호출 소괄호
code.style.spaces.within.empty.method.call.parentheses=빈 메서드/함수 호출 소괄호
code.style.spaces.attribute.parentheses=속성 소괄호
code.style.spaces.before.argument.colon=메서드/함수 호출 내 콜론 앞
code.style.spaces.after.argument.colon=메서드/함수 호출 내 콜론 뒤
code.style.spaces.before.type.colon=유형 어노테이션 내 콜론 앞
code.style.spaces.after.type.colon=유형 어노테이션 내 콜론 뒤
code.style.spaces.before.superclass.colon=유형 상속 절 내 콜론 앞
code.style.spaces.after.superclass.colon=유형 상속 절 내 콜론 뒤
code.style.spaces.before.dictionary.type.colon=사전 유형 내 콜론 앞
code.style.spaces.after.dictionary.type.colon=사전 유형 내 콜론 뒤
code.style.spaces.before.dictionary.literal.colon=사전 리터럴 ''key\:value'' 쌍 내 콜론 앞
code.style.spaces.after.dictionary.literal.colon=사전 리터럴 ''key\:value'' 쌍 내 콜론 뒤
code.style.spaces.within.string.interpolations=문자열 보간
code.style.spaces.before.class.lbrace=유형 선언이 왼쪽 중괄호
code.style.spaces.before.method.lbrace=메서드/함수 왼쪽 중괄호
code.style.spaces.before.semicolon=세미콜론 앞
code.style.spaces.after.semicolon=세미콜론 뒤
code.style.wrapping.group.title.method.parameters=메서드/함수 선언 매개변수
code.style.wrapping.group.title.method.arguments=메서드/함수 호출 인수
code.style.wrapping.group.title.closure=클로저
code.style.wrapping.group.title.condition.clauses=조건 절
code.style.wrapping.group.title.if=''if'' 문
code.style.wrapping.group.title.guard=''guard'' 문
code.style.wrapping.group.title.do.while=''repeat … while'' 문
code.style.wrapping.group.title.try=''do'' 문
code.style.wrapping.group.title.superclass.list=기본 클래스 및 채택된 프로토콜 목록
code.style.wrapping.group.title.ternary=삼항 조건 연산
code.style.wrapping.group.title.variable.groups=변수 그룹
code.style.wrapping.align.when.multiline=여러 줄일 경우 정렬
code.style.wrapping.align.in.columns=열에 정렬
code.style.wrapping.else.on.new.line=새 줄에 ''else''
code.style.wrapping.keep.control.statement.in.one.line=제어문을 한 줄로
code.style.wrapping.keep.simple.methods.in.one.line=메서드 및 함수를 한 줄로
code.style.wrapping.keep.simple.blocks.in.one.line=블록 및 (후미) 클로저를 한 줄로
code.style.wrapping.keep.simple.argument.blocks.in.one.line=클로저 인수를 한 줄에 배치
code.style.wrapping.structures.in.one.line=빈 유형 선언을 한 줄로
code.style.wrapping.method.brace.placement=메서드 및 함수 내
code.style.wrapping.array.literal=배열 및 사전 리터럴
code.style.wrapping.array.new.line.after.left.bracket=''['' 뒤에 새 줄
code.style.wrapping.array.right.bracket.on.new.line=새 줄에 '']'' 배치
code.style.wrapping.classes.annotation=유형 선언 속성
code.style.wrapping.methods.annotation=메서드 속성
code.style.wrapping.fields.annotation=프로퍼티 속성
code.style.wrapping.parameters.annotation=매개변수 속성
code.style.wrapping.local.variables.annotation=지역 변수 속성
code.style.wrapping.closure.signature.on.next.line=여러 줄일 경우 매개변수를 새 줄에
code.style.wrapping.brace.placement.class.declaration=유형 선언 내
code.style.blank.lines.around.class=유형 선언 주위\:
code.style.blank.lines.around.field.in.protocol=프로토콜 내 프로퍼티 주위\:
code.style.blank.lines.around.field=Around 프로퍼티\:
code.style.blank.lines.around.method.in.protocol=프로토콜 내 메서드/함수 주위\:
code.style.blank.lines.around.method=메서드/함수 주위\:
code.style.blank.lines.before.method.body=메서드/함수 본문 앞\:
code.style.code.generation.tab.title=코드 생성
code.style.code.generation.prefer.void=()보다 Void 선호(&V)
code.style.code.generation.prefer.explicit.return=명시적 반환 선호(&R)
color.settings.keyword=키워드 및 지시문//키워드
color.settings.property=식별자//프로퍼티
color.settings.colon=괄호 및 연산자//콜론
color.settings.module.name=유형//모듈 이름
color.settings.protocol=유형//프로토콜
color.settings.class=유형//클래스
color.settings.type.alias=유형//유형 별칭
color.settings.struct.and.enum=유형//구조체 및 열거형
color.settings.operator.sign=괄호 및 연산자//연산자 기호
color.settings.enum.case.value=식별자//열거형 case 값
color.settings.self.and.super.keywords=키워드 및 지시문//''self'' 및 ''super'' 키워드
color.settings.function.and.method.declaration=함수//함수 및 메서드 선언
color.settings.function.and.method.call=함수//함수 및 메서드 호출
color.settings.nested.function.declaration=함수//중첩된 함수 선언
color.settings.nested.function.call=함수//중첩된 함수 호출
color.settings.external.parameter.name=식별자//외부 매개변수 이름
color.settings.inline.closure.parameter=식별자//인라인 클로저 매개변수
color.settings.anonymous.closure.parameter=식별자//익명의 클로저 매개변수
color.settings.wildcard=식별자//와일드카드
color.settings.type.parameter=유형//제네릭 매개변수
color.settings.attribute.name=속성//속성 이름
color.settings.attribute.argument=속성//속성 인수
color.settings.inline.hints.type.hint=인라인 힌트//유형 힌트
color.settings.inline.hints.error.hint=인라인 힌트//오류 힌트
color.conditionally.non.compiled=키워드 및 지시문//조건으로 컴파일되지 않은 코드
color.settings.directive=키워드 및 지시문//지시문
goto.super.action={0} 선택
goto.super.menu.action=상위 {0}(_U)
goto.super.location={1} 내 {0}
goto.super.typealias=유형 별칭 또는 관련 유형
goto.super.class=클래스 또는 프로토콜
goto.base.type=기본 유형
goto.super.extension.of.0={0} 확장
inheritance.relation.overrides={0} 재정의
inheritance.relation.implements={0} 구현
inheritance.relation.is.implemented=구현됨
inheritance.relation.is.subclassed=하위 클래스가 됨
inheritance.relation.is.overridden=재정의됨
find.usages.base.member.warning.title=경고
find.usages.base.member.warning.message.implements.method={0} 은(는) {1}에 선언된 메서드를 구현합니다\n\n프로토콜 {3,choice,1\#메서드|2\#메서드}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.message.implements.subscript={0} 은(는) {1}에 선언된 서브스크립트를 구현합니다\n\n프로토콜 {3,choice,1\#서브스크립트|2\#서브스크립트}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.message.implements.property={0} 은(는) {1}에 선언된 프로퍼티를 구현합니다\n\n프로토콜 {3,choice,1\#프로퍼티|2\#프로퍼티}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.message.override.method={0} 은(는) {2}에 선언된 메서드를 재정의합니다\n\n기본 {3,choice,1\#메서드|2\#메서드}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.message.override.subscript={0} 은(는) {2}에 선언된 서브스크립트를 재정의합니다\n\n기본 {3,choice,1\#서브스크립트|2\#서브스크립트}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.message.override.property={0} 은(는) {2}에 선언된 프로퍼티를 재정의합니다\n\n기본 {3,choice,1\#프로퍼티|2\#프로퍼티}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.message.override.implemented.method={0} 은(는) {2}에 선언된 메서드를 재정의하고 {1} 선언된 메서드를 구현합니다\n\n기본 및 프로토콜 {3,choice,1\#메서드|2\#메서드}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.message.override.implemented.subscript={0} 은(는) {2}에 선언된 서브스크립트를 재정의하고 {1} 선언된 서브스크립트를 구현합니다\n\n기본 및 프로토콜 {3,choice,1\#서브스크립트|2\#서브스크립트}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.message.override.implemented.property={0} 은(는) {2}에 선언된 프로퍼티를 재정의하고 {1} 선언된 프로퍼티를 구현합니다\n\n기본 및 프로토콜 {3,choice,1\#프로퍼티|2\#프로퍼티}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.message.default.implementation.method={0} 은(는) {1}에 선언된 메서드의 기본 구현체입니다\n\n프로토콜 {3,choice,1\#메서드|2\#메서드}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.message.default.implementation.subscript={0} 은(는) {1}에 선언된 서브스크립트의 기본 구현체입니다\n\n프로토콜 {3,choice,1\#서브스크립트|2\#서브스크립트}의 사용 위치를 검색하시겠어요?
find.usages.base.member.warning.message.default.implementation.property={0} 은(는) {1}에 선언된 프로퍼티의 기본 구현체입니다\n\n프로토콜 {3,choice,1\#프로퍼티|2\#프로퍼티}의 사용 위치를 검색하시겠어요?
usage.type.type.parameter=유형 매개변수
usage.type.extension=확장
usage.type.requirement=요구 사항 내 사용 위치
usage.type.type.alias=유형 별칭
usage.type.argument.label=인수 라벨
usage.type.key.path=키 경로 표현식
usage.type.function.declaration=함수 선언
usage.type.operator.declaration=연산자 선언
usage.type.precedence.group.declaration=우선순위 그룹 선언
usage.type.raw.value=원시 값
action.SwiftToggleGlobalTypeHints.text=Swift 유형 힌트 표시
action.SwiftToggleTypeHints.text=유형 힌트 표시
action.SwiftToggleGlobalErrorHints.text=Swift 오류 힌트 표시
action.SwiftToggleErrorHints.text=오류 힌트 표시
action.SwiftIntroduceClosureVariable.text=클로저...
action.SwiftExtractFunction.text=함수 추출...
action.Swift.Generate.Init.text=이니셜라이저
action.Swift.Generate.Init.description=이니셜라이저 생성
action.Swift.Generate.Description.text=설명...
action.Swift.Generate.Description.description=설명 생성
action.Swift.Generate.DebugDescription.text=debugDescription...
action.Swift.Generate.DebugDescription.description=디버그 설명 생성
action.Swift.Generate.EqualsHashValue.text=equals 및 hash
action.Swift.Generate.EqualsHashValue.description=equals 및 hash 생성
create.file.title=Swift 파일
create.file.dialog.title=새 Swift 파일
create.file.description=새 Swift 파일을 생성합니다.
create.file.action=Swift 파일 {0} 생성
create.file.or.type.title=Swift 파일/유형
create.file.or.type.description=새 Swift 파일 또는 유형 생성
create.file.type.title=Swift 유형
create.file.type.dialog.title=새 Swift 유형
create.file.type.dialog.title.with.kind=새 Swift {0}
create.file.type.description=새 Swift 유형을 생성합니다.
create.file.kind=종류(&K)\:
create.file.kind.file=Archivo
create.file.kind.class=클래스
create.file.kind.protocol=프로토콜
create.file.kind.struct=구조체
create.file.kind.enum=열거형
override.implement.nothing.to.override=재정의할 항목 없음
override.implement.nothing.to.implement=구현할 항목 없음
override.implement.override.not.allowed=재정의할 수 없음
override.implement.implement.not.allowed=구현할 수 없음
override.implement.show.members.to.implement.title=구현할 멤버 표시
override.implement.elements.to.implement.chooser.title=구현할 멤버 선택
override.implement.elements.to.override.chooser.title=재정의할 멤버 선택
override.implement.elements.to.override.implement.chooser.title=재정의/구현할 멤버 선택
override.implement.progress=재정의/구현할 멤버 처리 중…
override.implement.show.optional.member=1개의 선택적 멤버 표시(&O)
override.implement.show.optional.members={0}개의 선택적 멤버 표시(&O)
override.implement.show.no.optional.members=선택적 멤버 표시(선택적 항목 없음)
override.implement.show.only.optional.members=선택적 멤버 표시(선택적 항목만)
generate.init.init.already.exists=이니셜라이저가 이미 있습니다.
generate.init.choose.super.init=상위 클래스 이니셜라이저 선택
generate.init.choose.properties=초기화할 프로퍼티 선택
generate.0.title={0} 생성
generate.description.single.string.template=단일 문자열
generate.description.string.concatenation.template=연결이 있는 여러 문자열 (+)
generate.description.multi.string.template=다중 줄 문자열
generate.template.title=Plan&tilla\:
generate.property.0.is.already.defined=프로퍼티 ''{0}'' 이(가) 이미 정의되어 있습니다. 해당 프로퍼티를 삭제하고 계속 진행하시겠어요?
generate.method.0.is.already.defined=메서드 ''{0}'' 이(가) 이미 정의되어 있습니다. 해당 메서드를 삭제하고 계속 진행하시겠어요?
generate.operator.function.0.is.already.defined=연산자 함수 ''{0}'' 이(가) 이미 정의되어 있습니다. 해당 함수를 삭제하고 계속 진행하시겠어요?
generate.method.0.and.property.1.are.already.defined=메서드 ''{0}'' 및 프로퍼티 ''{1}'' 이(가) 이미 정의되어 있습니다. 해당 메서드 및 프로퍼티를 삭제하고 계속 진행하시겠어요?
generate.method.0.and.operator.function.1.are.already.defined=메서드 ''{0}'' 및 연산자 함수 ''{1}'' 이(가) 이미 정의되어 있습니다. 해당 메서드 및 함수를 삭제하고 계속 진행하시겠어요?
generate.property.0.and.operator.function.1.are.already.defined=프로퍼티 ''{0}'' 및 연산자 함수 ''{1}'' 이(가) 이미 정의되어 있습니다. 해당 프로퍼티 및 함수를 삭제하고 계속 진행하시겠어요?
generate.method.0.property.1.and.operator.function.2.are.already.defined=메서드 ''{0}'', 프로퍼티 ''{1}'' 및 연산자 함수 ''{2}'' 이(가) 이미 정의되어 있습니다. 해당 메서드. 프로퍼티 및 함수를 삭제하고 계속 진행하시겠어요?
generate.equals.hash=equals 및 hash
generate.equals.hash.choose.in.0={0}에 포함할 프로퍼티 선택
generate.single.expression.equals.template=단일 표현식
generate.if.statements.equals.template=여러 개의 if 문
generate.cannot.generate.0.for.1={1}에 대한 {0}을(를) 생성할 수 없습니다.
generate.preparing.generation.title=생성 준비 중…
create.from.usage.create.function.command=사용 위치에서 함수 생성
create.from.usage.create.init.command=사용 위치에서 이니셜라이저 생성
create.from.usage.create.variable.command=사용 위치에서 변수 생성
create.from.usage.create.type.command=새 Swift 유형 생성
create.from.usage.choose.target.type=대상 유형 선택
create.from.usage.location.new.file=새 파일
create.from.usage.location.this.file=이 파일
create.from.usage.location.in={0} 내
sourcekit.fix.it=Fix-it 적용
sourcekit.inspections=SourceKit 검사
syntax.error.hashbang.line.is.allowed.only.in.the.first.line.of.the.main.file=Hashbang 줄은 기본 파일의 첫 번째 줄에서만 허용됩니다.
syntax.error.hashbang.line.is.allowed.only.in.the.first.line.of.the.file=Hashbang 줄은 파일의 첫 번째 줄에서만 허용됩니다.
syntax.error.hashbang.line.is.allowed.only.in.the.main.file=Hashbang 줄은 기본 파일에서만 허용됩니다.
syntax.error.unrecognized.platform.name.0=인지되지 않은 플랫폼 이름 ''{0}''
syntax.error.missing.asterisk=향후 나올 수 있는 플랫폼을 ''*''로 처리해야 합니다.
syntax.error.missing.asterisk.fix=Añadir ''*''
syntax.error.duplicate.platform=플랫폼 ''{0}''은(는) 이미 지정되어 있습니다
syntax.error.typealias.without.assignment=유형 별칭 선언에서 대입이 누락되어 있습니다.
syntax.error.variable.declaration.with.multiple.variables.cannot.have.explicit.getters.setters=여러 변수를 가진 ''var'' 선언에는 명시적 getter/setter를 사용할 수 없습니다
syntax.error.variable.declaration.with.multiple.variables.cannot.have.implicit.getter.clause=여러 변수를 가진 ''var'' 선언에는 묵시적 getter 절을 사용할 수 없습니다
syntax.error.variable.declaration.with.multiple.variables.cannot.have.willset.didset.clause=여러 변수를 가진 ''var'' 선언에는 willSet/didSet 절을 사용할 수 없습니다.
syntax.error.rethrows.is.not.allowed.in.function.type.elements=함수 선언만 ''rethrows''로 표시될 수 있습니다
syntax.error.rethrows.is.not.allowed.in.subscripts=하위 스크립트에서는 ''rethrows''가 허용되지 않습니다.
syntax.error.rethrows.is.not.allowed.in.closures=클로저에서는 ''rethrows''가 허용되지 않습니다.
syntax.error.rethrows.function.must.take.a.throwing.function.argument=''rethrows'' 함수에는 던지는 함수 인수가 있어야 합니다.
syntax.error.throws.is.not.allowed.in.subscripts=하위 스크립트에서는 ''throws''가 허용되지 않습니다.
syntax.error.thrown.expression.type.0.does.not.conform.to.ErrorType=던져진 표현식 유형 ''{0}''이(가) ''{1}''을(를) 준수하지 않습니다.
syntax.error.try.cannot.appear.to.the.right=''try''는 대입되지 않은 연산자의 오른쪽에 표시될 수 없습니다.
syntax.error.try.cannot.appear.to.the.right.fix=''try''를 왼쪽으로 이동
syntax.error.call.can.throw.in.property.initializer=프로퍼티 이니셜라이저에서 호출은 던질 수 있지만 오류는 던질 수 없습니다.
syntax.error.call.can.throw.in.default.argument=디폴트 인수에서 호출은 던질 수 있지만 오류는 던질 수 없습니다.
syntax.error.call.can.throw.not.marked.with.try=호출은 던질 수 있지만 ''try''로 표시되지 않습니다.
syntax.error.call.can.throw.not.marked.with.try.not.handled=호출은 던질 수 있지만 ''try''로 표시되지 않으며 오류가 처리되지 않습니다.
syntax.error.call.can.throw.not.marked.with.try.not.exhaustive=호출은 던질 수 있지만 ''try''로 표시되지 않으며 둘러싼 catch가 완전하지 않습니다.
syntax.error.call.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=호출은 던질 수 있지만 던지지 않는 autoclosure에서 실행됩니다.
syntax.error.call.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=호출은 던질 수 있지만 ''try''로 표시되지 않으며 던지지 않는 autoclosure에서 실행됩니다.
syntax.error.operator.can.throw.not.marked.with.try=연산자는 던질 수 있지만 표현식은 ''try''로 표시되지 않습니다.
syntax.error.errors.are.not.handled=여기에서 던져진 오류는 처리되지 않습니다.
syntax.error.errors.are.not.handled.not.exhaustive=둘러싼 catch가 완전하지 않기 때문에 여기에서 던져진 오류는 처리되지 않습니다.
syntax.error.error.is.not.handled=둘러싼 함수가 ''throws''로 던져지지 않기 때문에 오류가 처리되지 않습니다.
syntax.error.error.is.not.handled.not.exhaustive=둘러싼 catch가 완전하지 않기 때문에 오류가 처리되지 않습니다.
syntax.error.rethrows.function.can.only.throw.parameter.call=''rethrows''로 선언된 함수는 해당 매개변수가 던질 경우에만 던집니다.
syntax.error.rethrows.function.can.only.throw.parameter.call.not.handled=호출은 던질 수 있지만 오류는 처리되지 않습니다. ''rethrows''로 선언된 함수는 해당 매개변수가 던질 경우에만 던집니다.
syntax.error.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=호출은 던질 수 있지만 ''try''로 표시되지 않으며 오류가 처리되지 않습니다. ''rethrows''로 선언된 함수는 해당 매개변수가 던질 경우에만 던집니다.
intention.mark.the.enclosing.function.as.throws=''throws''를 함수 시그니처에 추가
intention.add.try.to.expression=Añadir ''try''
intention.suppress.call.error.with.try=''try\!''로 오류 억제
intention.surround.with.do.catch=''do/catch''로 둘러싸기
intention.add.default.catch.clause=디폴트 ''catch'' 절 추가
intention.add.catch.clause=''catch'' 절 추가
intention.replace.rethrows.with.throws=''rethrows''를 ''throws''로 바꾸기
intention.create.new.swift.type.in.a.new.file=새 파일 내 새 Swift 유형
intention.create.new.swift.declaration=새 Swift 선언 생성
intention.create.kind.{0}.from.usage.{1}={0} ''{1}'' 생성
intention.create.type.from.usage.{0}=유형 ''{0}'' 생성
intention.create.initializer=이니셜라이저 생성
intention.create.location.in=''{0}'' 내
intention.create.location.in.a.new.file=새 파일 내
intention.create.location.in.type={0} ''{1}'' 내
intention.create.location.nested.in.type={0} ''{1}'' 에 중첩됨
intention.implement.members.error=유형 {0}이(가) {1}을(를) 준수하지 않습니다.
intention.implement.members.implement.missing={0} 누락된 {0,choice,1\#멤버|2\#멤버} 구현
intention.access.control.error.access={0}에 액세스할 수 없습니다. 해당 항목은 {2}에서 {1}입니다.
intention.access.control.error.access.dynamic={0}에 액세스할 수 없습니다. 동적 멤버 서브스크립트는 {2}에서 {1}입니다.
intention.access.control.error.override={0}을(를) 재정의할 수 없습니다. 해당 항목은 {2}에서 {1}입니다.
intention.access.control.fix={2} 내 {0} {1} 생성
intention.access.control.remove.setter={0}에서 {1} 제거
intention.wrong.return.type.error.void=void 함수에 void가 아닌 반환값이 불필요하게 있습니다
intention.wrong.return.type.fix=''{0}''이(가) ''{1}''을(를) 반환하도록 설정
inspection.redundant.attribute=중복 속성
inspection.redundant.attribute.error=속성 @{0}이(가) 중복되었습니다.
inspection.redundant.attribute.fix=중복 속성 @{0} 제거
inspection.redundant.return=중복 반환
inspection.redundant.return.error=''return''이 중복되었습니다.
inspection.redundant.return.fix=중복 ''return''을 제거합니다.
inspection.unnecessary.argument.list=불필요한 인수 목록
inspection.unnecessary.argument.list.error=인수 목록이 불필요합니다
inspection.unnecessary.argument.list.fix=불필요한 인수 목록 제거
inspection.unnecessary.parentheses=불필요한 소괄호
inspection.unnecessary.parentheses.error=소괄호는 불필요합니다.
inspection.unnecessary.parentheses.fix=불필요한 소괄호를 제거합니다.
inspection.unnecessary.self=불필요한 self
inspection.unnecessary.self.error=''self''가 불필요합니다
inspection.unnecessary.self.fix=불필요한 ''self'' 제거
inspection.unnecessary.tuple.wrap=불필요한 튜플 둘러싸기
inspection.unnecessary.tuple.wrap.error=단일 요소 튜플을 유형으로 바꿀수 있습니다
inspection.unnecessary.tuple.wrap.fix=단일 요소 튜플을 유형으로 바꾸기
inspection.missing.localization=로컬라이제이션 언어 누락
inspection.missing.localization.all.languages.only=모든 언어에서 누락된 현지화만 보고
error.cannot.perform.refactoring=리팩터링을 수행할 수 없습니다
error.no.expression.found=표현식을 찾을 수 없습니다
intention.replace.if.with.guard=''if''를 ''guard''로 바꾸기
intention.replace.guard.with.if=''guard''를 ''if''로 바꾸기
intention.add.explicit.type=명시적 유형 추가
intention.remove.explicit.type=명시적 유형 제거
intention.add.explicit.qualifier=명시적 한정자 추가
intention.convert.to.multiline.string=여러 줄 문자열 리터럴로 변환
intention.convert.to.string=한 줄 문자열 리터럴로 변환
intention.convert.to.decimal=10진수로 변환
intention.convert.to.hex=16진수로 변환
intention.convert.to.octal=8진수로 변환
intention.convert.to.binary=2진수로 변환
intention.convert.to.trailing.closure=후행 클로저로 변환
intention.convert.to.closure.argument=클로저 인수로 변환
intention.increase.string.escape.level=문자열 이스케이프 수준 높이기
intention.decrease.string.escape.level=문자열 이스케이프 수준 낮추기
intention.add.digit.separators=숫자 구분 기호 추가
intention.remove.digit.separators=숫자 구분 기호 제거
intention.split.into.separate.declarations=개별 선언으로 분할합니다.
intention.split.declaration.and.assignment=선언 및 할당 분할
intention.join.declaration.and.assignment=선언 및 할당 결합
intention.merge.else.if=else if 문 병합
intention.split.else.if=else if 문 분할
intention.invert.if.statement=구문인 경우 반전
intention.demorganslaw=드모르간 법칙
intention.demorganslaw.format=''{0}''을(를) ''{1}''(으)로 바꾸기
intention.merge.nested.if=중첩된 if 문 병합
intention.split.nested.if=중첩된 if로 분할
intention.merge.conditions=조건 병합
intention.split.condition=개별 조건으로 분할
intention.negate.comparison=Negar comparación
intention.negate.comparison.format=Negar ''{0}'' como ''{1}''
intention.flip.binary.expression=이진 표현식 반전
intention.flip.binary.expression.format=Invertir ''{0}''
intention.flip.comparison=Invertir comparación.
intention.flip.comparison.format=Invertir ''{0}'' a ''{1}''
intention.localize.string=문자열 로컬화
intention.localize.string.title.case=문자열 현지화
extract.method.title.method=메서드 추출
extract.method.title.function=함수 추출
extract.method.title.closure=클로저 추출
extract.method.error.should.represent.expr.or.statements=선택한 블록은 구문 또는 표현식 모음을 나타내야 합니다.
extract.method.error.cannot.determine.expr.type=선택한 표현식의 유형을 파악할 수 없습니다.
extract.method.error.cannot.extract.expr.with.var.declarations=변수 선언이 있는 표현식에서 추출할 수 없습니다.
extract.method.error.cannot.determine.function.result.type=함수 결과의 유형을 파악할 수 없습니다.
extract.method.error.multiple.exit.points=선택한 코드 조각에 여러 종료점이 있습니다.
extract.method.error.cannot.extract.with.returns=코드 조각 내부에 반환 명령이 있는 메서드를 추출할 수 없습니다.
extract.method.error.cannot.determine.parameters.type=매개변수의 유형을 파악할 수 없습니다.
extract.method.error.fragment.should.be.inside.code.block=선택된 코드 조각은 코드 블록 안에 있어야 합니다.
extract.method.function.0.will.conflict.with.1.2=함수 ''{0}''이(가) {1} {2}와(과) 충돌합니다.
extract.method.method.0.will.conflict.with.1.in.2.3=메서드 ''{0}''이(가) {2} ''{3}''에서 {1}와(과) 충돌합니다.
extract.method.at.least.two.parameters.have.name.0=이름이 ''{0}''인 매개변수가 2개 이상입니다.
extract.method.variable.0.will.no.longer.be.accessible=리팩터링 후 변수 ''{0}'' 에 더 이상 액세스할 수 없습니다
extract.method.cannot.extract.mutable.value=가변 값을 추출할 수 없습니다.
extract.method.0.1.will.be.shadowed.by.2.1={0} ''{1}''이(가) {2} ''{1}''으로 그림자화됩니다.
introduce.variable.declare.with.var=var로 선언(&V)
introduce.variable.specify.type.explicitly=명시적으로 유형 지정(&T)
introduce.variable.expression.will.be.ambiguous.without.explicit.type=명시적 유형  없이는<br/>  표현식이 모호합니다.
rename.inheritors=상속자 이름 변경
rename.inheritors.to=상속자 이름을 다음으로 변경\:
rename.inheritor.entity.name=상속자
rename.init.is.not.supported=swift 이니셜라이저의 이름 변경은 지원되지 않습니다.
rename.self.is.not.supported=self 매개변수의 이름 변경은 지원되지 않습니다.
rename.title=Swift 이름 변경
rename.related.dialog.title=관련 선언의 이름 변경
rename.related.dialog.description=다음 이름을 가진 관련 선언의 이름을 변경\:
rename.related.entity.name=관련 선언
rename.containing.file.dialog.title=포함하는 파일 이름 변경
rename.containing.file.dialog.description=다음 이름을 가진 포함 파일의 이름 변경\:
rename.containing.file.entity.name=포함 파일
rename.error.message.renaming.swift.member.elements.in.objective.c.code.is.not.supported=Objective-C 코드 내 Swift 멤버 요소의 이름 변경은 지원되지 않습니다.
rename.error.title=Swift - 이름 변경
rename.error.dynamic.called.values=동적으로 호출된 값의 이름은 변경할 수 없습니다.
change.signature.initializer.will.conflict.with.0.in.1.2=이니셜라이저는 {1} ''{2}'' 에서 {0} 와(과) 충돌합니다
change.signature.subscript.will.conflict.with.0.in.1.2=서브스크립트는 {1} ''{2}'' 에서 {0} 와(과) 충돌합니다
change.signature.dialog.title=시그니처 변경
change.info.return.type.label=반환 유형\:
change.info.name.label=이름\:
change.info.internal.name.label=내부 이름\:
change.info.type.label=유형\:
change.info.optional.label=선택적\:
change.info.default.value.label=Valor por defecto\:
change.signature.target.not.found=캐럿은 함수, 이니셜라이저 또는 서브스크립트에 위치해야 합니다
change.signature.processed.elements.header=시그니처를 변경할 요소
change.signature.title=시그니처 변경
change.signature.0.1.will.no.longer.be.visible.from.overriding.0.in.2.3={0} ''{1}''이(가) {2} ''{3}''의 재정의 {0}에서 더 이상 표시되지 않습니다
change.signature.0.1.with.2.visibility.wont.be.accessible.from.3.4={2} 가시성을 가진 {0} ''{1}''은(는) {3} ''{4}''에서 액세스할 수 없습니다
change.info.throw.kind.label=던지기 종류\:
change.signature.0.can.throw.but.thrown.errors.are.not.handled=''{0}'' 은(는) 던질 수 있으나 던져진 에러는 처리되지 않습니다
change.info.dialog.invalid.function.name.0=유효하지 않은 함수 이름\: ''{0}''
change.info.dialog.invalid.parameter.name.0=유효하지 않은 매개변수 이름\: ''{0}''
change.info.dialog.invalid.parameter.internal.name.0=유효하지 않은 매개변수 내부 이름\: ''{0}''
change.info.dialog.no.function.name.specified=함수 이름이 지정되지 않았습니다
change.info.dialog.parameter.after.variadic.should.have.nonempty.name=가변 매개변수 다음에 오는 매개변수는 공백이 아닌 이름을 가져야 합니다
change.info.dialog.rethrows.should.have.throwing.parameter=''rethrows'' 함수는 던지는 함수 매개변수를 취해야 합니다
change.info.default.value.code.comment=기본값 \={0}
refactor.base.declaration=기본 {0,choice,1\#선언|2\#선언} 리팩터링
refactor.only.current.declaration=현재 선언만 리팩터링
refactor.0.overrides.method.of.1={0} 이(가) {1} 의 메서드를 재정의합니다
refactor.0.overrides.property.of.1={0} 이(가) {1} 의 프로퍼티를 재정의합니다
refactor.0.overrides.initializer.of.1={0} 이(가) {1} 의 이니셜라이저를 재정의합니다
refactor.0.overrides.subscript.of.1={0} 이(가) {1} 의 서브스크립트를 재정의합니다
refactor.0.overrides.associated.type.of.1={0} 이(가) {1} 의 연관 유형을 재정의합니다
refactor.0.overrides.declaration.in.1={0} 이(가) {1} 내 선언을 재정의합니다
editor.appearance.type.hints=Swift 유형 힌트 표시
editor.appearance.error.hints=Swift 오류 힌트 표시
action.Swift.ShowSwiftIDETest.text=Swift IDE 보고서 실행
converter.dialog.message=클립보드에 Objective-C 코드가 포함되어 있습니다. Swift로 변환하시겠어요?
converter.dialog.title=Objective-C를 Swift로 변환
context.declaration=선언
context.statement=구문
