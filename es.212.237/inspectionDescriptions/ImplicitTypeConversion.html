<html>
<head>
  <style type="text/css">
    body, table {
      font-family: Verdana, sans-serif;
      font-size: 100%;
      padding-left: 2mm;
    }

    #footer {
      font-size: 95%;
      padding-top: 10px;
    }
 </style>
</head>

<body>
<p>
  사전정의된 XPath-타입 <code>STRING</code>, <code>NUMBER</code>, <code>BOOLEAN</code> 및 <code>NODESET</code> 간 묵시적 변환을 보고합니다. 타입을 더 명확히하며 감지하기 어려운 버그를 방지하는 XSLT 스크립트 작성을 돕습니다:
</p>
<p>예:</p>
<p>
  <code>&lt;xsl:if test="<b>foo</b>" /></code> 은 <code>&lt;xsl:if test="<b>string(foo)</b>" /></code> 와 동일하지 않습니다.
</p>

<p>
첫 번째 테스트는 "foo" 요소가 있는지 확인합니다 (<code>count(foo) > 0)</code>. 그러나 두 번째 테스트는 요소가 텍스트를 실제로 포함하고 있을 때에만 true를 나타냅니다 (<code>string-length(foo) > 0</code>). 타입 변환을 더 명시적으로 만드는 것을 제안합니다.
</p>

<p>
검사를 사용자 지정하려면 다음 동작을 사용하세요.
</p>
<ul><li>특정 타입간 묵시적 변환을 활성화 또는 비활성화</li>
<li>예를 들어 <code>&lt;xsl:if test="number(foo)" /></code>와 같이, 실제 예상 타입으로 귀결되지 않는 명시적 변환을 항상 보고</li> 
<li><code>string()</code> 함수를 <code>string-length() > 0</code> 작성을 위한 단축키로 사용하여  <code>NODESET</code> 에서  <code>BOOLEAN</code> 으로의 변환을 무시합니다.</li></ul>
</p>
<p id="footer">XPathView + XSLT-Support에 의해 지원됩니다.</p>
</body>
</html>
