go.feature.trainer.specify.sdk.to.continue.learning.title=학습을 계속하려면 Go SDK 지정
go.feature.trainer.too.old.go.sdk.notification.title=<b>{0}</b> 이후 버전으로 Go SDK 업데이트
go.feature.trainer.too.old.go.sdk.notification.text=튜토리얼에서는 Go 모듈을 사용한 종속성 관리에 GoSDK <b>{1}</b> 이후 버전이 필요합니다. 현재의 GoSDK 버전은 <b>{0}</b>입니다.
go.onboarding.module.name=온보딩 투어
go.onboarding.module.description={0} 주요 기능 미리보기입니다.
go.onboarding.lesson.name={0} 알아보기
go.onboarding.project.view.description=<strong>프로젝트</strong> 뷰는 주요 도구 창 중 하나입니다. 이 뷰는 프로젝트 디렉터리, SDK 전용 패키지, 스크래치 파일을 포함합니다. 줄무늬 버튼을 사용해 열면 간단한 데모 프로젝트가 표시됩니다. {0}을(를) 눌러 뷰를 열 수도 있습니다.
go.onboarding.balloon.project.view=클릭하여 <strong>프로젝트</strong> 뷰를 열세요
go.onboarding.balloon.project.directory=프로젝트 디렉터리를 두 번 클릭하여 확장하면 프로젝트 파일을 확인할 수 있습니다
go.onboarding.balloon.open.file=두 번 클릭하여 {0}을(를) 여세요
go.onboarding.balloon.open.learn.toolbar={0} 도구 창으로 전환하여 이 수업을 계속 진행하세요
go.onboarding.context.menu=코드를 실행하는 방법에는 여러 가지가 있습니다. 그중 하나는 컨텍스트 메뉴를 이용하는 것입니다.\n\
go.onboarding.run.sample={0}을(를) 선택하거나 {1}을(를) 사용해보세요.
go.onboarding.temporary.configuration.description=<ide/>이(가) 임시 실행 구성을 생성했습니다. 이 구성은 실행 툴바에서 찾을 수 있습니다. 이 툴바를 사용하면 {0} 실행, {1} 디버그, {2} 코드 프로파일링, 커버리지 {3}(으)로 코드 실행 등 선택한 구성에 대한 인기 있는 실행 액션을 실행할 수 있습니다.
go.onboarding.balloon.click.here=여기를 클릭하여 중단점을 설정하세요
go.onboarding.toggle.breakpoint.1={1} 메서드가 필요한 값인 {0} 대신 {2}을(를) 반환하는 것을 눈치채셨을 것입니다. return 문으로 가서 문제 코드를 디버그해봅시다.
go.onboarding.toggle.breakpoint.2=강조 표시된 영역에서 여백을 클릭하여 중단점을 설정하세요.
go.onboarding.balloon.start.debugging=아이콘을 클릭하여 디버그를 시작하세요
go.onboarding.start.debugging={0} 아이콘을 클릭하여 디버그 프로세스를 시작하세요
go.onboarding.balloon.about.debug.panel={0} 도구 창은 다양한 디버그 액션을 갖춘 툴바를 제공합니다. 나중에 {1} 수업을 수강하여 이 액션을 사용해보세요.
go.onboarding.balloon.stop.debugging=아이콘을 클릭하여 디버그를 시작하세요
go.onboarding.stop.debugging=디버그를 시작해봅시다. {0} 아이콘을 클릭하세요.
go.onboarding.close.debug.tool.window={0} 도구 창을 닫고 {1}을(를) 누르세요.
go.onboarding.type.division=코드에서 문제를 발견했으니 수정해봅시다. 결과 합을 값의 길이로 나누세요. {0}을(를) 입력하세요.
go.onboarding.choose.len.item=입력과 동시에 <ide/>이(가) 코드 완성 옵션이 자동으로 표시됩니다. 키보드 화살표를 사용하여 {0} 항목을 선택한 다음 {1}을(를) 누르세요.
go.onboarding.invoke.completion=이제 코드 완성을 호출하여 괄호 {1} 안에 {0}을(를) 삽입해봅시다. {2}을(를) 눌러 코드 완성 목록을 여세요.
go.onboarding.choose.values.item={0}을(를) 입력하여 제안한 항목 수를 줄일 수 있습니다. {1}을(를) 선택한 다음 {2}을(를) 누르세요.
go.onboarding.invoke.intention.for.warning.1=방금 버그를 수정했지만 이 코드를 더욱 깔끔해 보이도록 만들 수 있습니다. <ide/>는 향상될 여지가 있는 코드 줄을 강조 표시하고 노란색 전구를 추가합니다.
go.onboarding.invoke.intention.for.warning.2={0}을(를) 눌러 경고를 미리 보고 빠른 수정을 적용하세요.
go.onboarding.select.fix=첫 번째 항목을 적용하세요: {0}. 이 수정을 적응하면 불필요한 괄호가 삭제됩니다.
go.onboarding.reformat.code=코드를 계속 정리해 봅시다. {0} 을(를) 눌러 서식을 다시 지정하세요.
go.onboarding.invoke.intention.for.code=또한, 인텐션을 사용하면 시간을 절약하고 코드를 더 쉽게 작성할 수 있습니다. 인텐션을 사용해 {0} 함수를 내보낸 함수로 빠르게 변환해 봅시다. {1} 을(를) 누르세요.
go.onboarding.apply.intention={0}을(를) 선택한 후 {1}을(를) 누르세요.
go.onboarding.invoke.search.everywhere.1=<ide/>에서 작업할 때 프로젝트, 심볼, 타입 또는 IDE 액션 내의 파일을 검색하고자 하는 경우가 있습니다. 이번 수업에서는 {0} 액션을 검색하여 {1} 문자열을 소문자로 만들어 봅시다.
go.onboarding.invoke.search.everywhere.2={0}을(를) 두 번 눌러 {1} 대화상자를 여세요.
go.onboarding.search.everywhere.description=보시다시피 선택한 텍스트, {0}이(가) 자동으로 입력 문자열에 복사되었습니다. {0} 대신 {1}을(를) 입력해봅시다.
go.onboarding.apply.action={0} 액션을 선택하고 {1}을(를) 누르세요.
go.onboarding.case.changed=대/소문자가 변경되었습니다.
go.onboarding.epilog=축하합니다. 온보딩 투어를 마쳤습니다. 이제 다음을 진행할 수 있습니다.\n\
-학습 프로젝트{1} <callback id="{0}">닫기</callback>\n\
-더 많은 수업 <callback id="{2}">보기</callback>
go.onboarding.return.to.welcome=\ 및 시작 화면으로 돌아가기
go.onboarding.finish.title=축하합니다
go.onboarding.finish.text=<ide/> 온보딩 투어를 막 완료했습니다.\n\
go.onboarding.finish.exit=데모 프로젝트 닫기
go.onboarding.finish.modules=수업 더보기
toggle.case.part=case
go.working.with.json.name=JSON 작업 중
go.working.with.json.copy=<ide/>에는 JSON 코드를 더 효과적으로 처리하는 데 도움이 되는 여러 가지 도구가 있습니다.\n\
go.working.with.json.replace={0}을(를) 눌러 주석 섹션을 교체합니다. {1} 대화상자가 나타나면 <strong>예</strong>를 클릭하세요.\n\
go.working.with.json.name.struct=구조체 이름을 변경하고 {0}을(를) 입력한 후 {1}을(를) 눌러 편집을 종료하세요. IDE에서 서식을 자동으로 수정합니다.
go.working.with.json.introduce.type={1} 구조체 내부에 포함된 {0} 구조체를 추출해봅시다.\n\
go.working.with.json.change.style=태그 내 필드 이름에 다른 코드 스타일을 적용할 수 있습니다. 예를 들어, 낙타 표기법(camelCase)으로 변경해보세요. {0}을(를) 누르고 {1}을(를) 클릭한 다음 {2}을(를) 선택하세요.
go.working.with.json.update.value.in.tags=태그 값 배치 업데이트에 대해서도 마찬가지입니다. 현재 구조체의 모든 태그에 {0}을(를) 추가한다고 가정해봅시다.\n\
go.working.with.json.add.key.to.tags=XML 태그와 ASN1 태그를 추가하려면 인텐션 액션을 사용할 수도 있습니다.\n\
go.quick.fixes.create.type.type.incompatibility.name=타입 생성 및 타입 비호환성 수정
go.quick.fixes.create.type=예시에서는 필드를 가진 구조체 타입을 사용했으나 정의하지 않았습니다.\n\
go.quick.fixes.navigate.to.error={0}을(를) 눌러 다음 오류로 이동하세요.
go.quick.fixes.type.incompatibility=여기서 <ide/>에는 {0} 타입이 필요하지만 {1} 슬라이스가 전달되어 있습니다.\n\
go.generate.getters.and.setters.name=getter 및 setter 생성
go.generate.getters.and.setters.action=구조체 필드의 getter와 setter를 생성해야 하는 상황에서는 인텐션 액션을 사용하세요.\n\
go.handling.unhandled.errors.name=처리되지 않는 오류 처리 중
go.handling.unhandled.errors.handle.error={0} 코드 검사는 오류 값을 반환하는 함수 또는 메서드에 대해 경고하지만 이러한 오류 값은 검사되지 않습니다. 이를 처리하려면 다음의 빠른 수정을 사용할 수 있습니다.\n\
go.handling.unhandled.errors.handle.error.var.name=변수 이름으로 {0}을(를) 입력하고 {1}을(를) 누르세요.
go.handling.unhandled.errors.wrap.in.closure=또 다른 빠른 수정은 {0} 및 {1} 문에 사용됩니다. {2} 빠른 수정과 비슷하게 작동하지만 코드를 클로저 안에 감쌉니다.\n\
go.support.of.go.embed.name=//go:embed 지원
go.support.of.go.embed.string={0} 지시문을 사용하여 빌드 시간 동안 파일 및 디렉터리를 Go 바이너리에 포함할 수 있습니다.\n\
go.support.of.go.embed.note={0}: {1} 지시문을 사용하려면 Go 1.16 이후 버전이 설치되어 있는지 확인하세요. Go SDK 설치에 관한 자세한 내용은 <a href="{2}">문서에서 Go SDK 다운로드</a>를 참조하세요.
go.support.of.go.embed.navigate=파일에 여전히 이슈가 있습니다. {0}을(를) 눌러 다른 이슈로 이동하세요.
go.support.of.go.embed.fs=검사에 따르면 지정된 디렉터리가 없습니다. 이 디렉터리를 기존 디렉터리로 교체할 수 있습니다.\n\
go.var.check.error.postfix.template.name=varCheckError 접미사 템플릿
go.var.check.error.postfix.template.call=오류 처리 논의를 계속해봅시다. 이번에는 {0} 접미사 템플릿입니다. 오류를 반환하는 식별자 뒤에 입력하는 경우, <ide/>에서 디폴트 변수 이름을 자동으로 추가하고 함수에서 발생한 오류를 반환합니다.\n\
go.var.check.error.postfix.template.anonymous.variable={0}을(를) 입력하여 빈 식별자를 사용한 다음 {1}을(를) 누르세요.
go.var.check.error.postfix.template.quick.fix=Go 1.16에는 {0}에 관한 새로운 검사가 도입되었습니다. 이 검사는 바이트 슬라이스가 마샬링되지 않은 값이 {1}이(가) 아닌지 확인합니다. <ide/>은(는) 그러한 경우를 탐지하고 이슈를 해결하는 빠른 수정 기능을 갖추고 있습니다. {2}을(를) 누른 다음 {3}을(를) 선택하세요.
go.wrapping.lesson.name=긴 줄 줄 바꿈
go.wrapping.put.arguments.on.separate.lines={0} 함수에 상당히 많은 인수가 전달됩니다. 문제는 첫 번째 인수가 매우 길고 그 뒤의 내용을 확인할 수 없다는 것입니다. 이 문제를 수정할 수 있습니다. 여는 대괄호 뒤에 캐럿이 배치되었으므로 이제 {1} 을(를) 누르고 {2} 을(를) 선택해야 합니다.
go.wrapping.enable.soft.wrap=첫 번째 인수가 여전히 가시 영역 밖에 있습니다. 긴 줄에 소프트 랩을 활성화하는 것이 좋습니다. {0}을(를) 누르고 {1}을(를) 입력한 다음, {2} 스위치를 전환하세요. 나중에 {3}을(를) 눌러 검색을 닫을 수 있습니다.
go.wrapping.put.parameters.on.same.lines={0} 함수의 인수는 한 줄로 처리하면 더 보기 좋을 것 같습니다. 병합하려면 여는 대괄호 뒤에 캐럿을 배치하고 {1}을(를) 눌러 인텐션 액션을 호출한 다음, {2}을(를) 선택하세요.
go.struct.inspections.lesson.name=구조체 검사
go.struct.inspections.jump.to.warning=Go에는 구조체 태그 프로그래밍에 관한 규칙이 있습니다. 이 규칙에 대한 자세한 내용은 <a href\="{0}">golang.org의 이 도움말</a>에서 확인할 수 있습니다.\n\
go.struct.inspections.delete.line=경고에서는 두 개의 구조체 필드({0} 및 {1})를 동일한 JSON 필드 이름에 매핑하려는 시도가 좋지 않다는 것을 나타냅니다. 이 오류가 발생하면 프로그램은 실행되지만 출력에서 하나의 키가 누락됩니다.\n\
go.comment.navigation.lesson.name=주석에서 이동
go.comment.navigation.task={0} 패키지는 별로 크지 않으므로 쉽게 탐색할 수 있습니다. 그러나 일부 패키지는 수백 개의 코드와 주석 줄이 포함되어 거대할 수 있습니다.\n\
go.inspection.unsafe.context.cancellation.name=안전하지 않은 컨텍스트 취소
go.inspection.unsafe.context.cancellation.go.to.error={0} 코드 검사는 {2} 이(가) 반환하는 {1} 함수와 그와 유사한 함수가 모든 실행 경로에서 호출되는지 확인합니다. 컨텍스트 패키지에 관해 더 자세히 알아보려면 <a href\="{3}">golang.org의 패키지 컨텍스트</a>를 참조하세요.\n\
go.inspection.unsafe.context.cancellation.add.defer={1} 실행 경로에서 {0} 을(를) 호출하지 않으므로 {2} 을(를) 입력하여 경고를 수정해야 합니다.
go.formatting.lesson.name=코드 스타일을 코드에 적용
go.formatting.reformat.selection=<ide/>은(는) 코드 서식 지정을 지원합니다. 선택한 코드 블록의 서식을 다시 지정하려면 {0}을(를) 누르세요.
go.formatting.clear.selection=선택 범위를 정리하려면 {0}을(를) 누르세요.
go.formatting.whole.file=줄이 선택되지 않은 경우 전체 소스 파일의 서식을 다시 지정하려면, {0}을(를) 사용하세요.
go.fmt.lesson.name=go fmt 실행
go.fmt.task=코드 서식을 {0} (으)로 지정하고 싶은 경우 {1} 을(를) 눌러 실행할 수 있습니다.
go.comments.lesson.name=주석 추가 및 제거
go.comments.comment.one.line={0} (으)로 어느 줄이든 주석 처리하세요.
go.comments.uncomment.line=같은 단축키 {0}(으)로 주석이 추가된 줄에서 주석 제거
go.comments.comment.block=코드 블록에서 주석을 제거할 수 있습니다. 예를 들어 선택한 블록에서 주석을 제거하려면 {0}을(를) 눌러봅시다.
go.code.completion.for.time.package.name=시간 패키지 코드 완성
go.code.completion.for.time.package.year=날짜 및 시간 요소의 서식을 지정하기 위해 {0} 패키지는 이미 정의된 레이아웃인 {1} 을(를) 사용합니다. 그렇기 때문에 참조 시간 요소를 자리표시자로 사용해 서식을 정의하게 됩니다.\n\
go.code.completion.for.time.package.month=다시 {0} 을(를) 누르고 달로 {1} 을(를) 선택하세요.
go.code.completion.for.time.package.hour=제안 목록에서 {0} 을(를) 선택해 시간에 대해서도 동일한 작업을 하세요.
go.code.completion.for.time.package.minute=분으로 {0} 을(를) 선택하여 템플릿을 완료하세요.
go.basic.completion.lesson.name=기본 코드 완성
go.basic.completion.complete.again=조회 메뉴 내에서 {0} 을(를) 선택한 후 {1} 을(를) 누르세요.
go.basic.completion.complete.statement={0}을(를) 눌러 이 구문을 완성한 후 새 줄로 이동하세요.
go.basic.completion.invoke.completion=<ide/>은(는) 새 import 문을 자동으로 삽입합니다. 이제 ''기본 완성''을 활성화하기 위해 {0}을(를) 누르면 조회 메뉴가 다시 표시됩니다.
go.basic.completion.type.and.choose=기본적으로 <ide/>은(는) 코드 완성을 즉시 제안합니다. 캐럿이 있는 곳에서 {0}을(를) 입력하기 시작하면 그에 대응하는 제안 항목이 포함된 조회 메뉴가 표시됩니다. {2}을(를) 누르면 조회 메뉴에서 {1}을(를) 선택할 수 있습니다.
go.smart.type.completion.lesson.name=스마트 유형 완성
go.smart.type.completion.task=스마트 유형 완성은 제안 목록을 필터링하여 현재 컨텍스트에서 적용 가능한 유형만을 포함합니다. {0}을(를) 눌러 대응하는 제안 목록을 확인하세요. 첫 번째 항목을 선택하려면 {1}을(를) 누르세요.
go.smart.type.completion.special.cases.lesson.name=유형 어설션 및 switch 생성
go.smart.type.completion.special.cases.number=변수 유형의 유효성을 검사하거나 확인해야 하는 경우, 유형 어설션이나 switch 구문을 사용할 수 있습니다. <ide/>은(는) 제안 목록의 시작 부분에 그러한 유형을 표시합니다. 제안 개수를 줄이려면 유형 이름을 계속 입력하세요.\n\
go.smart.type.completion.special.cases.line={0} 함수에 문자열을 전달하기로 했다면 {1} 오류가 표시될 것입니다. 값의 유형을 확인하려는 경우 유형 switch 구문을 사용할 수 있습니다. {2}을(를) 눌러 {3}을(를) 선택하세요.
go.smart.type.completion.and.pointers.lesson.name=스마트 유형 완성 및 포인터
go.smart.type.completion.and.pointers.first.task=<ide/>은(는) 가능한 포인터 및 변수 주소 목록을 제안할 수 있습니다.\n\
go.smart.type.completion.and.pointers.second.task=스마트 유형 완성은 포인터에서도 작동합니다. 포인터를 반환하려면 {0}을(를) 눌러 {1}을(를) 선택하세요.
go.postfix.templates.lesson.name=접미사 템플릿(nn, panic, rr, return)
go.postfix.templates.nn=접미사 템플릿을 사용하면 점 뒤의 접미사, 표현식 유형, 해당 컨텍스트를 기반으로 이미 입력된 표현식을 다른 표현식으로 변환할 수 있습니다. 사전 정의된 접미사 완성 템플릿 세트를 사용하거나 새 템플릿을 생성할 수 있습니다. 사용자 지정 접미사 템플릿에 관한 자세한 내용은 <a href \= "{0}">이 문서 자료</a>를 참조하세요.\n\
go.postfix.templates.choose.item={0}을(를) 입력하고 <action>EditorEnter</action>를 누르세요. 제안 목록에서 {1}을(를) 선택하세요.
go.postfix.templates.rr={0} 접미사 완성 템플릿은 오류 변수가 {1}이(가) 아닌지 확인하는 코드를 생성합니다. 오류 처리를 위해 {0} 접미사 완성 템플릿을 사용할 수 있습니다.\n\
go.postfix.templates.return={0}을(를) 입력하고 {1} 접미사 템플릿을 적용하세요.
go.postfix.completion.lesson.name=접미사 완성 및 정렬
go.postfix.completion.task=알파벳 슬라이스가 무질서한 상태입니다. 문자열 슬라이스를 올바르게 정렬하기 위해 {1} 패키지의 {0} 함수를 슬라이스에 적용할 수 있습니다.\n\
go.completion.for.functions.lesson.name=함수의 코드 완성
go.completion.for.functions.choose.item=목록에서 {0}을(를) 선택하고 {1}을(를) 누르세요. 제안 목록이 표시되면 입력을 시작하여 결과 수를 줄일 수 있습니다.
go.completion.for.functions.press.twice=요소를 첫 번째 인수로 허용하는 모든 함수를 찾으려면 {0}을(를) <strong>두 번</strong> 누르세요. 요소는 메서드가 아니지만 점 때문에 그렇게 보이니 유의하세요.
go.debug.function.calls.lesson.name=함수 호출 디버그
go.debug.function.calls.version.warning=<strong>참고</strong>\: 이 기능을 사용하려면 Go 1.11 또는 이후 버전을 설치해야 합니다.
go.debug.function.calls.toggle.breakpoint=디버그 모드에서 함수에 다른 값을 전달하고 함수가 반환하는 결과를 확인할 수 있습니다. 표현식 평가 기능에 관한 자세한 내용은 <a href\="{0}">문서</a>를 참조하세요.\n\
go.debug.function.calls.mac.note=디버그 서버를 시작하기 위해 운영 체제에서 비밀번호를 요청할 수 있습니다.
go.debug.function.calls.start.debug={0}을(를) 눌러 디버그 세션을 실행하세요.
go.debug.function.calls.run.to.cursor=이제 캐럿은 15행의 끝에 있습니다. {1} 액션의 작동 방식을 확인하려면 {0}을(를) 누르세요.
go.debug.function.calls.step.over={1}을(를) 사용하여 {0} 구문을 스텝오버해 보세요.
go.debug.function.calls.evaluate.expression={1}을(를) 눌러 {0} 액션을 호출하세요.
go.debug.function.calls.enter.expression.to.evaluate={0} 필드에 {1}을(를) 입력하기 시작한 다음 제안 목록에서 {2}을(를) 선택하세요.
go.debug.function.calls.add.arguments.for.evaluation=소괄호 안에 {0}을(를) 입력하세요. 필드에 {1}이(가) 표시되어야 합니다.
go.debug.function.calls.click.evaluate={0}을(를) 클릭하거나 {1}을(를) 누르세요. 그 후에 대화상자를 닫을 수 있습니다.
go.debug.function.calls.stop.debug=디버그를 중지하고 강의를 마치려면 {0}을(를) 누르세요.
go.better.variable.names.in.templates.lesson.name=라이브 및 접미사 템플릿의 변수 이름 개선
go.better.variable.names.in.templates.description=<ide/>은(는) {0} 및 {1} 라이브 템플릿으로 생성된 변수의 이름을 지정할 수 있도록 도와줍니다. 예를 들어 다음 제안 중에서 색인의 경우 {2} 또는 {3}, 값의 경우 {4}, {5}, {6} 을(를) 선택할 수 있습니다.
go.better.variable.names.in.templates.use.forr={0}을(를) 입력하고 완성 목록에서 {1} 접미사 템플릿을 선택하세요.
go.better.variable.names.in.templates.finish=<ide/>에서 색인에 대해 {0} 을(를), 값에 대해 {1} 을(를) 제안하는 것을 확인해 보세요. 이 강의를 마치려면 {2} 을(를) 누르세요.
go.dump.goroutines.name=Goroutines 덤프
go.dump.goroutines.toggle.breakpoint={4} 섹션에서는 <ide/>에 추가된 기능 몇 가지를 설명합니다. 다른 기능은 <a href\="{0}">새로운 기능 페이지</a>에서 확인하세요.\n\
go.dump.goroutines.click.button.DlvDumpAction={0} 도구 창에서 {1} 버튼을 클릭하세요.
go.dump.goroutines.click.button.DlvFilterGoroutinesAction=열린 {0} 탭에서 {1} 버튼을 클릭하세요.
go.dump.goroutines.filter.goroutines={0} 검색 필드에서 {1} 을(를) 입력해 목록을 필터링하세요. 이 필터는 이름에 {1} 이(가) 있는 goroutines를 가진 실행 스택만 남깁니다.
go.general.templates.lesson.name=라이브 및 접미사 템플릿\: else, fori, var
go.general.templates.else=라이브 템플릿은 루프, 조건, 다양한 선언 또는 print 문과 같은 일반적인 구문을 코드에 삽입합니다. 이는 접미사 템플릿과 함께 코드를 더 빠르게 작성하는 데 도움이 됩니다.\n\
go.general.templates.fori=이제 {0}을(를) 입력하고 제안 목록에서 이 라이브 템플릿을 선택하세요. 루프에서 다음 조건을 설정하세요. {1}.
go.general.templates.type.iteration=각 반복에서 {0} 루프는 {1}을(를) 실행해야 합니다
go.general.templates.vars=현재 프로그램은 사용자가 키보드로 입력한 숫자를 읽고 {0} 루프에서 사용합니다. 그러나 <ide/> 2020.1부터는 템플릿을 사용하여(상수에는 {1}, 변수에는 {2}, 유형에는 {3}, import 문에는 {4}) 구문 그룹을 더 빠르게 코딩할 수 있습니다.\n\
go.handling.errors.with.templates.lesson.name=라이브 및 접미사 템플릿의 오류 처리\: if 및 rr
go.handling.errors.with.templates.if.not.null=일부 함수는 두 개의 값을 반환합니다. 예를 들어 {0}은(는) {1}에 대한 포인터와 오류 값을 반환합니다. 오류 값이 {2}이면 파일이 성공적으로 열립니다. 오류가 {3}이 아니면 오류가 발생한 것입니다. <ide/>에서 라이브 및 접미사 템플릿을 사용하면 오류 값 처리를 훨씬 빠르게 작성할 수 있습니다.\n\
go.handling.errors.with.templates.return.nil.err=파일을 여는 동안 오류가 발생하면 슬라이스와 오류를 반환해야 합니다. 여기서는 {0} 및 {1}을(를) 반환할 수 있습니다. {2}을(를) 입력하기 시작하고 {3} 라이브 템플릿을 선택하세요.
go.handling.errors.with.templates.error.case=접미사 코드 완성은 코드를 작성할 때 역방향 캐럿 이동을 줄이는 데 도움이 됩니다. 이러한 템플릿을 사용하면 이미 입력한 표현식을 다른 표현식으로 변환할 수 있습니다. 접미사 완성에 관한 더 많은 강의는 {0} 섹션에서 찾을 수 있습니다.\n\
go.live.templates.with.types.lesson.name=라이브 템플릿 및 유형 사용
go.live.templates.with.types.struct.template=구조체는 이름이 지정된 필드가 포함된 유형입니다. 구조체는 데이터를 그룹화하여 레코드를 형성하는 데 유용합니다. 이 코드용으로 하나 만들어 보겠습니다.\n\
go.live.templates.with.types.type.fields={1} 구조체의 필드로 {0}을(를) 추가하세요.
go.live.templates.with.types.interface.template=Go에서 인터페이스는 메서드 시그너처 세트를 지정할 수 있는 사용자 지정 유형입니다. 하나 추가해 봅시다\!\n\
go.live.templates.with.types.add.method={1} 인터페이스에 대한 메서드 시그니처로 {0}을(를) 추가하세요.
go.live.templates.with.types.complete.in.comment=주석은 프로그램 작동 방식과 거기에 내포된 사용자의 의도를 설명합니다. 주석에서 코드 완성을 사용하여 매개변수, 함수, 메서드의 이름을 완성할 수 있습니다.\n\
go.live.templates.with.types.add.second.return.value=현재 {0} 메서드는 문자열 매개변수만 반환합니다. 면적 값을 가진 {1} 반환 값을 추가해야 합니다. <ide/>은(는) 여러 반환 유형 주위에 소괄호를 자동으로 추가합니다.\n\
go.live.templates.with.types.complete.return=캐럿이 함수 내에서 {0} 키워드 뒤에 있으면, 코드 완성은 오류가 발생해도 지역 변수와 제로 값을 제안합니다. 면적을 계산하는 {1} 메서드를 완성해 보겠습니다.\n\
go.live.templates.with.types.fill.all.fields=마지막으로 사각형의 새 인스턴스를 만들고 {0} 및 {1}에 대한 값을 전달해 보겠습니다.\n\
go.generate.missing.methods.lesson.name=누락된 메서드 생성
go.generate.missing.methods.task={0} 액션을 사용하면 메서드나 매개변수 이름이 인터페이스 정의에서 생략된 경우에도 누락된 메서드를 생성하고 매개변수 이름을 지정할 수 있습니다.\n\
go.fixing.test.lesson.name=테스트 파일 수정
go.fixing.test.open.problems.toolwindow={0} 도구 창은 현재 파일의 경고 및 오류 목록을 표시하고 해당 문제에 대한 설명을 제시합니다.\n\
go.fixing.test.close.problems=주의해야 할 몇가지 문제가 있습니다. 일부 문제는 {0} 도구 창 자체에서 수정할 수 있습니다. 그러나 일부 문제는 에디터에서 특정 액션이 필요합니다. 에디터에서 모든 수정을 적용해 보겠습니다\!\n\
go.fixing.test.fix.string.conversion=이 {0} 변환은 필요한 10진수 문자열 표현이 아닌 유니코드 코드 포인트의 UTF-8 표현을 반환합니다.\n\
go.fixing.test.use.multicursors=다음 오류는 매우 명백하게도 익명 구조체에 닫는 중괄호와 쉼표가 없습니다. 그렇다고 각 줄에 반복해서 입력하고 싶지는 않습니다. 이럴 때 다중 커서가 도움이 될 수 있습니다.\n\
go.fixing.test.fix.camelcase={1} 패키지에 관한 <a href\="{0}">Go 문서</a>에는 함수 이름을 낙타 표기법(예\: {2})으로 작성해야 한다고 나와 있습니다. 여기서 {3} 함수는 이 규칙을 준수하지 않습니다.\n\
go.fixing.test.negate=마지막은 실제로 오류가 아니라 코드를 단순화하는 간단한 리팩터링입니다. {0} 함수의 부정을 확인하세요. 여기서 무엇을 할 수 있는지 살펴보겠습니다.\n\
go.quick.fix.refactorings.lesson.name=빠른 수정, 리팩터링, 외부 문서
go.quick.fix.refactorings.change.to.formatting={0} 함수는 디폴트 형식으로 변수 목록을 인쇄합니다. 한편 {1} 함수를 사용하면 출력 형식을 지정할 수 있습니다. 이 예시에서는 부동 소수점 숫자에 대해 형식화 동사({2})를 사용합니다. 하지만 {1} 대신 {0}을 사용합니다.\n\
go.quick.fix.refactorings.create.variable=변수를 선언하는 방법에는 여러 가지가 있습니다. 변수가 선언되면 등호({0})를 사용하여 값을 대입할 수 있습니다.\n\
go.quick.fix.refactorings.rename=<ide/>에서 요소의 이름을 변경하면 해당 변경 내용을 적용할 수 있습니다. <ide/>은(는) 코드 요소의 이름을 변경하고 그에 따라 사용 위치를 업데이트합니다.\n\
go.quick.fix.refactorings.extract.method=메서드 추출 리팩터링을 사용하면 코드 조각을 취해 분리된 함수로 이동하고 이전 코드를 함수 호출로 바꿀수 있습니다. 모든 인쇄를 별도의 함수로 이동해 보겠습니다.\n\
go.quick.fix.refactorings.external.doc=외부 문서는 웹 브라우저에서 필요한 정보를 열어 주기 때문에 관련 심볼을 탐색하는 동시에 추가 참조를 위해 정보를 보관할 수 있습니다.\n\
go.apply.fix={0} 을(를) 선택하고 {1} 을(를) 누르세요.
go.introduce.function.lesson.name=함수 유형에서 함수 생성
go.introduce.function.intro=<ide/>은(는) 호출에서 함수와 메서드를 생성할 수 있습니다. 이제 함수나 메서드가 누락된 경우 해당 유형에서 생성할 수도 있습니다.
go.introduce.function.invoke.intentions=캐럿이 함수 참조로 사용되는 {0} 식별자의 위치에 있는지 확인하세요. {1}을(를) 눌러 인텐션 액션을 호출하세요.
go.introduce.function.final.propose=그런 다음, 이제 필요에 따라 매개변수를 조정할 수 있습니다.
go.delete.parameter.names.lesson.name=매개변수 이름 삭제
go.delete.parameter.names.intro=<ide/>은(는) 사용되지 않는 매개변수의 유형이 메서드 사양을 구현하는 데 사용되는 경우 해당 매개변수의 이름만 강조 표시합니다. 이 경우 이 매개변수의 이름을 {0}(으)로 변경하거나 완전히 제거할 수 있습니다.
go.delete.parameter.names.invoke.intentions=인터페이스를 구현하는 메서드에 매개변수가 필요한 경우, 이러한 매개변수를 제거하는 것은 안전하지 않습니다. {0}을(를) 눌러 가능한 옵션 목록을 확인하세요.
go.delete.unused.parameters.lesson.name=사용되지 않는 매개변수 삭제
go.delete.unused.parameters.intro=<ide/>은(는) 메서드 또는 함수의 본문에서 사용되지 않는 시그니처의 매개변수를 탐지할 수 있습니다. 해당 매개변수가 사용되지 않는 경우 {0} 빠른 수정을 사용하여 삭제할 수 있습니다.
go.delete.unused.parameters.invoke.intentions=에디터에서 {0} 메서드를 확인하세요. 캐럿은 첫 번째 매개변수의 위치에 있습니다. {1}을(를) 눌러 인텐션 액션을 호출하세요.
go.fill.struct.fields.lesson.name=구조체 필드 입력
go.fill.struct.fields.intro=새 구조체를 생성할 때 해당 구조체의 필드 이름을 자동으로 생성할 수 있습니다. {0} 인텐션 액션에 관한 자료는 <a href\="{1}">GoLand 문서</a>에서 확인하세요.
go.fill.struct.fields.invoke.intentions=캐럿이 {0} 구조체의 중괄호 사이에 배치된 것을 확인하세요. {1}을(를) 눌러 인텐션 액션을 호출하세요.
go.implement.missing.methods.lesson.name=누락된 메서드 구현
go.implement.missing.methods.goto.next.error={0} 을(를) 눌러 파일 내 강조 표시된 다음 오류로 이동합니다.
go.delete.conversion.lesson.name=중복된 유형 변환
go.delete.conversion.intro=<strong>중복된 유형 변환</strong> 검사는 생략 가능한 중복된 유형 변환을 경고합니다(예\: 문자열 리터럴을 문자열로 변환하는 경우). 이 검사에 관한 자세한 내용은 <a href\="{0}">중복된 유형 변환</a>을 참조하세요.
go.delete.conversion.invoke.intentions=에디터에서 {0} 함수를 확인하세요. 캐럿은 {2}에서 {1} 유형으로의 형 변환의 위치에 있습니다. {3}을(를) 눌러 인텐션 액션을 호출하세요.
go.parameters.specification.lesson.name=매개변수에 대한 짧은 유형 및 긴 유형 사양
go.parameters.specification.intro=함수 또는 메서드 시그니처에 단일 유형의 여러 매개변수가 있는 경우 이러한 매개변수에 대해 짧은 유형 사양({0})을 사용하거나 각 매개변수에 대해 별도의 유형 사양({1})을 사용할 수 있습니다.
go.parameters.specification.invoke.intentions=캐럿이 {0} 메서드의 첫 번째 매개변수의 위치에 있는 것을 확인하세요. {1}을(를) 눌러 인텐션 액션을 호출하세요.
go.parameters.specification.notice.signature.combined=시그니처 유형이 결합된 방식을 확인하세요.
go.parameters.specification.press.again={0}을(를) 다시 누르세요.
go.parameters.specification.notice.signature.expanded=시그니처가 초기 상태로 돌아갔습니다.
go.variadic.functions.lesson.name=가변 함수 처리
go.variadic.functions.unpack.slice=가변 함수는 {0} 등 다양한 수의 인수를 사용하여 호출할 수 있는 함수입니다.\n\
go.variadic.functions.inline=슬라이스를 슬라이스의 가변 인수로 바꿀수 있습니다. {0}을(를) 눌러 {1} 리팩터링을 호출하세요.
go.variadic.functions.introduce.variable={0} 리팩터링을 되돌리려면 {1} 리팩터링을 사용하세요. {2}을(를) 누르고 제안 목록에서 {3}을(를) 선택하세요.
go.improve.names.lesson.name=오류 변수의 이름 개선
go.improve.names.intro=<ide/>은(는) 오류({0}) 및 컨텍스트({1}) 변수의 가장 인기 있는 이름 변형을 제안합니다.
go.improve.names.introduce.variable=캐럿이 {0} 호출의 위치에 있는지 확인하세요. {1}을(를) 눌러 변수를 추출하세요.
go.improve.names.apply.fix=목록에서 전체 호출을 선택하고 {0}을(를) 누르세요. {1}은(는) 가장 일반적인 오류 이름이므로 <ide/>에서 변수 이름으로 제안했습니다.
go.extract.method.lesson.name=함수 및 메서드 추출
go.extract.method.task={0} 리팩터링을 사용하면 사용자 지정 가능한 매개변수 및 반환 유형을 가진 새 함수 또는 메서드로 코드를 캡슐화할 수 있습니다. 일부 코드 줄을 새 함수로 추출해 보겠습니다. {1}을(를) 누르세요.
go.extract.methods.with.returns.lesson.name=return이 포함된 메서드 추출
go.extract.methods.with.returns.intro={0} 리팩터링을 사용하면 코드 조각을 취해 분리된 메서드로 이동하고 이전 코드를 새 메서드 호출로 바꿀수 있습니다. 코드가 return 문에서 종료되면 그대로 추출됩니다. {0} 리팩터링에 관한 자세한 내용은 <a href\="{1}">함수 및 메서드 추출</a> 자료를 참조하세요.
go.extract.methods.with.returns.invoke.refactoring=추출할 수 있는 {0} 절 앞에 캐럿이 있는지 확인하세요. {1}을(를) 누르세요.
go.extract.methods.with.returns.complete.refactoring={0}을(를) 입력하고 {1}을(를) 누르세요.
go.extract.variable.lesson.name=변수 추출
go.extract.variable.task={0}을(를) 눌러 변수를 추출하고 문자열 표현식을 선택한 다음, 새 이름을 입력하고 {1}을(를) 눌러 리팩터링을 완료하세요.
go.inline.variable.lesson.name=추출된 변수 인라인화
go.inline.variable.task={0} 리팩터링과 반대로 {1}은(는) 중복 변수의 제거를 돕습니다. {2}을(를) 눌러 {3} 변수를 단일 사용 위치로 인라인화하세요.
go.rename.lesson.name=이름 변경
go.rename.invoke.intentions=심볼에 캐럿을 배치하고 {0} 리팩터링을 사용하여 이름을 변경할 수 있습니다. 코드의 {1} 필드에 캐럿을 배치하고 {2}을(를) 누르세요.
go.rename.apply.intention=이 필드의 새 이름을 입력하세요. 예를 들어 {0}을(를) 입력한 다음, {1}을(를) 눌러 결과를 저장합니다.
go.what.s.new.module.name=GoLand 2020.3의 새로운 기능
go.what.s.new.module.description=GoLand 2020.3(2020년 12월)의 새로운 기능입니다.
go.basic.editing.module.name=기본 편집
go.basic.editing.module.description=코드 편집에 도움이 될 수 있는 기본 액션입니다.
go.code.completion.module.name=코드 완성
go.code.completion.module.description=컨텍스트를 인식하는 코드 완성은 코딩 프로세스의 속도를 높이고 오타를 줄입니다.
go.debugging.module.name=디버그
go.debugging.module.description=디버그는 애플리케이션 내 문제를 찾고 해결하는 데 도움이 될 수 있습니다.
go.testing.module.name=테스트하기
go.testing.module.description=테스트는 코드가 기대한 대로 올바르게 작동하도록 합니다.
go.generating.code.module.name=코드 생성
go.generating.code.module.description=코드 청크를 생성하는 액션 및 템플릿입니다.
go.intention.actions.module.name=인텐션 액션
go.intention.actions.module.description=인텐션 액션은 코드에 대한 대체 변형은 물론, 탐지된 문제에 대한 해결 방법까지 제안할 수 있습니다.
go.refactorings.module.name=리팩터링
go.refactorings.module.description=리팩터링은 코드를 빈틈이나 중복 코드 없이 관리하기 쉽게 유지하는 데 도움이 됩니다.
go.support.for.table.tests.name=테이블 테스트 지원
go.support.for.table.tests.call.context.menu=테스트를 실행할 때 <ide/>는 캐럿의 위치를 고려합니다.\n\
go.support.for.table.tests.run.subtest=같은 방법을 사용해 각각의 하위 테스트를 실행할 수 있습니다. 현재 캐럿이 {2} 하위 테스트에 있습니다. {0} 을(를) 눌러 실행하세요. \n\
현재 이 방법에는 몇가지 제약이 있습니다. 자세한 내용은 <a href="{1}">GoLand 문서</a>에서 확인할 수 있습니다.
go.code.completion.for.benchmarks.bn.name=벤치마크 잋 테스르 코드 완성
go.code.completion.for.benchmarks.bn.for.loop=벤치마크 내에서 {0} 을(를) 입력하면 <ide/>이(가) {0} 루프의 조건식으로 {1} 을(를) 제안합니다.\n\
go.code.completion.for.benchmarks.bn.create.bench=새 벤치마크를 생성하려면 {0} 을(를) 입력하기 시작한 다음 제안 목록에서 {0} 을(를) 선택하세요.
go.support.of.testify.framework.completion.and.subtests.name=코드 완성 및 testify 프레임워크 내 하위 테스트
go.support.of.testify.framework.completion.and.subtests.assert=<strong>전제 조건</strong>\: 이 수업을 종료하려면 <a href\="{0}">GOPATH 전체의 색인화를 활성화</a>하고 <a href\="{1}">{2} 패키지</a>를 설치하세요.\n\
go.support.of.testify.framework.completion.and.subtests.run.subtest=게다가 하위 테스트 이름이 문자열 상수라면 {0} 및 {1} 하위 테스트를 실행할 수 있습니다.\n\
go.to.internal.directory.name=탐색, 빌드 제약, 코드 서식 지정
go.to.internal.directory.build.constraints=<a href="{0}">버그 방지 빌드 제약 제안</a>에 따라 {1}이(가) {2}(으)로 바뀝니다. {1}~{2}의 전환 기간 동안 구문은 Go 1.16~1.18 버전에서 유지됩니다. Go 1.16 버전에서는 예전 구문을 사용하거나 두 가지 구문을 동시에 사용할 수 있습니다.\n\
go.to.internal.directory={0} 2021.2부터 {1} 폴더에 저장된 인터페이스로 이동할 수 있습니다.\n\
go.to.internal.directory.hover.over.tab=파일 위치를 확인하려면 에디터의 탭을 마우스로 가리키면 됩니다. 예를 들어, {0} 탭을 마우스로 가리켜 보세요.
go.to.internal.directory.reformat.gofmt.on.save={0} 파일의 코드 서식을 다시 지정해야 합니다. {1}을(를) 눌러 파일의 서식을 다시 지정하세요.\n\
go.enable.generics.in.go.files.name=타입 매개변수 사용
go.enable.generics.in.go.files.enable.quick.fix=기본적으로 타입 매개변수(또는 제네릭)에 대한 지원은 비활성화되어 있습니다. 2021.2 전에는 타입 매개변수를 {1} 파일에서만 실험해볼 수 있었으나 이제 {0} 파일에서도 지원됩니다.\n\
go.enable.generics.in.go.files.use.rename.file=코드를 실행하는 가장 쉬운 방법은 {0}을(를) 사용하는 것입니다. 이를 사용하려면 파일을 {3} 확장으로 변환해야 합니다. 이 작업은 {1} 액션으로 수행할 수 있습니다.\n\
go.enable.generics.in.go.files.change.extension=파일 확장자를 변경합니다. 전체 파일 이름은 {0}이어야(여야) 합니다.
go.enable.generics.in.go.files.run.in.playground={0}에서 결과 파일을 실행하려면 {1}을(를) 누르세요.\n\
go.enable.generics.in.go.files.click.link=이제 결과 링크를 클릭하여 브라우저에서 코드를 엽니다.\n\
