sh.code.style.binary.ops.like.and.may.start.a.line=\\& 및 | 같은 2진 연산자로 줄이 시작될 수 있습니다.
sh.code.style.choose.path=Shfmt 서식 지정 도구 경로 선택\:
sh.code.style.download.link=Shfmt 서식 지정 도구 다운로드
sh.code.style.keep.column.alignment.padding=열 정렬 패딩 유지
sh.code.style.minify.program.to.reduce.its.size=크기를 줄이도록 프로그램 최소화
sh.code.style.unix.line.separator=Unix 줄 구분 기호 사용(\\n)
sh.code.style.redirect.operators.will.be.followed.by.a.space=리디렉션 연산자 뒤에 공백이 표시됩니다
sh.code.style.switch.cases.will.be.indented=스위치 케이스가 들여쓰기됩니다
sh.disable.inspection.text=검사 {0} 비활성화
sh.explain.command.to.explain=설명할 명령어
sh.explain.inspection.text=셸 설명
sh.explain.message.nothing.to.explain=설명할 항목이 없음
sh.explain.title.nothing.to.explain=설명할 항목이 없음
sh.fmt.cannot.download=sh shfmt 서식 지정 도구을 다운로드할 수 없습니다. 수동으로 설치하세요.
sh.fmt.cannot.update=sh shfmt 서식 지정 도구를 업데이트할 수 없습니다. 이전 버전으로 롤백되었습니다.
sh.fmt.formatter=Shfmt 서식 지정 도구
sh.fmt.indent.label=Sangrar
sh.fmt.update.question=셸 서식 지정 도구를 업데이트하시겠어요?
sh.fmt.install.question=셸 스크립트 서식 지정 도구를 설치하시겠어요?
sh.fmt.success.update=셸 스크립트 서식 지정 도구가 성공적으로 업데이트되었습니다.
sh.fmt.success.install=셸 스크립트 서식 지정 도구가 성공적으로 설치되었습니다.
sh.fmt.missing.formatter=누락된 서식 지정 도구
sh.parser.expected.similar.close.bracket=유사한 닫는 대괄호가 필요합니다.
sh.path.label=경로\:
sh.rename.all.occurrences=모든 사용 위치의 이름 변경
sh.rename.occurence={0} 이름 변경
sh.shell.script=Script de shell
filetype.sh.shell.script.description=Script de shell
sh.shellcheck.download.label.text=shellcheck 다운로드
sh.shellcheck.cannot.download=Shellcheck를 다운로드할 수 없습니다. 수동으로 설치하세요.
sh.shellcheck.cannot.update=Shellcheck를 업데이트할 수 없습니다. 이전 버전으로 롤백되었습니다.
sh.shellcheck.path.label=Shellcheck 서식 지정 도구 경로 선택\:
sh.shellcheck.install.question=Shellcheck 설치하여 셸 스크립트의 유효성을 검증하시겠어요?
sh.shellcheck.update.question=Shellcheck를 업데이트하시겠어요?
sh.shellcheck.success.install=Shellcheck가 성공적으로 설치되었습니다.
sh.shellcheck.success.update=Shellcheck가 성공적으로 업데이트되었습니다.
sh.shellcheck.missing=\ 누락된 Shellcheck
sh.suppress.inspection={0} 억제
sh.unnamed.element.presentable.name=<unnamed>
sh.label.download.shfmt.formatter=shfmt 서식 지정 도구 다운로드
sh.label.choose.interpreter=인터프리터 선택
sh.label.choose.script.working.directory=스크립트 작업 디렉터리 선택
sh.label.choose.shell.script=셸 스크립트 선택
action.ShGenerateUntilLoop.text=until 루프
action.ShGenerateUntilLoop.description=until 루프 생성
action.ShGenerateWhileLoop.text=while 루프
action.ShGenerateWhileLoop.description=while 루프 생성
action.ShGenerateForLoop.text=for 루프
action.ShGenerateForLoop.description=for 루프 생성
action.runShellFileAction.text=Ejecutar archivo
action.runShellFileAction.description=터미널에서 현재 셸 파일 실행
sh.color.function.declaration=함수 선언
sh.color.conditional.operators=조건 연산자
sh.color.commands.subshell.command=명령어//하위 셸 명령어
sh.color.commands.generic.command=명령어//제네릭 명령어
sh.color.redirection=리디렉션
sh.color.backquotes=역따옴표
sh.color.braces.square.brackets=괄호//대괄호
sh.color.braces.curly.brackets=괄호//중괄호
sh.color.braces.parentheses=중괄호//소괄호
sh.color.here.documents.end=Fin de documento Here
sh.color.here.documents.start=Inicio de documento Here
sh.color.here.documents=Documento Here
sh.color.shebang.comment=Shebang 주석
sh.color.line.comment=줄 주석
sh.color.raw.string=원시 문자열
sh.color.string=문자열
sh.color.variables.composed.variable=변수//합성 변수
sh.color.variables.variable.declaration=변수//변수 선언
sh.color.variables.variable.usage=변수//변수 사용 위치
sh.color.keyword=키워드
sh.color.number=숫자
sh.run.interpreter.options=인터프리터 옵션\:
sh.run.interpreter.path=인터프리터 경로\:
sh.run.interpreter=인터프리터
sh.run.interpreter.not.found=인터프리터를 찾을 수 없습니다
sh.run.interpreter.should.be.executable=인터프리터가 실행 파일이어야 합니다
sh.run.working.dir=작업 디렉터리\:
sh.run.working.dir.not.found=작업 디렉터리를 찾을 수 없음
sh.run.script.options=스크립트 옵션\:
sh.run.script.path=스크립트 경로\:
sh.run.script.not.found=셸 스크립트를 찾을 수 없음
sh.run.execute.terminal=터미널에서 실행
sh.run.environment.variables=환경 변수\:
sh.run.execute.script.text=스크립트 텍스트
sh.run.execute.script.text.title=스크립트 텍스트:
sh.run.execute.script.file=스크립트 파일
sh.run.execute=Ejecutar:
sh.update=업데이트
sh.install=Instalar
sh.no.thanks=아니요
sh.skip.version=이 버전 건너뛰기
sh.download=Descargar
sh.invalid.path=경로가 올바르지 않습니다.
find.usages.type.function=함수
sh.run.configuration.description.0.configuration={0} 구성
error.message.cannot.determine.shell.script.parent.directory=셸 스크립트 상위 디렉터리를 확인할 수 없습니다
check1000.is.not.used.specially.and.should.therefore.be.escaped=$는 특별히 사용되지 않으므로 이스케이프해야 합니다.
check1001.this.o.will.be.a.regular.o.in.this.context=이 \\o는 이 컨텍스트에서 일반적인 ''o''입니다.
check1003.want.to.escape.a.single.quote.echo.this.is.how.it.s.done=작은따옴표를 이스케이프하시겠어요? ''This is how it''\''s done''이 echo로 출력됩니다.
check1004.this.backslash.linefeed.is.literal.break.outside.single.quotes.if.you.just.want.to.break.the.line=이 백슬래시+라인피드는 리터럴입니다. 줄을 바꾸려면 작은따옴표 바깥에서 바꾸세요.
check1007.remove.space.after.if.trying.to.assign.a.value.or.for.empty.string.use.var=값을 대입하려는 경우 \= 뒤의 공백을 제거하세요(또는 빈 문자열의 경우 var\=''... 사용).
check.1008.this.shebang.was.unrecognized.shellcheck.only.supports.sh.bash.dash.ksh.add.a.shell.directive.to.specify=이 shebang은 인식되지 않았습니다. ShellCheck은 sh/bash/dash/ksh만 지원합니다. 지정할 ''shell'' 지시문을 추가하세요.
check.1009.the.mentioned.parser.error.was.in=언급된 파서 오류는...에 있습니다
check.1010.use.semicolon.or.linefeed.before.done.or.quote.to.make.it.literal=''done'' 앞에 세미콜론 또는 라인피드를 사용하세요(또는 리터럴로 만들려면 따옴표).
check.1011.this.apostrophe.terminated.the.single.quoted.string=이 아포스트로피가 작은따옴표로 묶인 문자열을 종료했습니다\!
check.1012.is.just.literal.t.here.for.tab.use.printf.instead=`\t`는 여기에서 단순히 리터럴 `t`입니다. 탭의 경우 "$(printf ''\t'')"를 대신 사용하세요.
check.1014.use.if.cmd.then.to.check.exit.code.or.if.cmd.to.check.output=종료 코드를 확인하려면 ''if cmd; then ..''을 사용하고 출력을 확인하려면 ''if [ "$(cmd)" \= .. ]''를 사용하세요.
check.1015.this.is.a.unicode.double.quote.delete.and.retype.it=이것은 유니코드 큰따옴표입니다. 삭제하고 다시 입력하세요.
check.1016.this.is.a.unicode.single.quote.delete.and.retype.it=이것은 유니코드 작은따옴표입니다. 삭제하고 다시 입력하세요.
check.1017.literal.carriage.return.run.script.through.tr.d=리터럴 캐리지 리턴입니다. `tr -d ''\n''`를 통해 스크립트를 실행하세요.
check.1018.this.is.a.unicode.non.breaking.space.delete.it.and.retype.as.space=이것은 유니코드 비 분리 공백입니다. 삭제하고 다시 입력하세요.
check.1019.expected.this.to.be.an.argument.to.the.unary.condition=이것은 단항 조건의 인수여야 합니다.
check.1020.you.need.a.space.before.the.if.single.then.else=if single then "]" else "]]" 앞에 공백이 필요합니다
check.1026.if.grouping.expressions.inside.use=[[..]] 내 표현식을 그룹화하려는 경우 ( .. )를 사용하세요.
check.1028.in.you.have.to.escape.or.preferably.combine.expressions=[..]에서 \\(\\)를 이스케이프하거나 되도록 [..] 표현식을 결합해야 합니다.
check.1029.in.you.shouldn.t.escape.or=`[[..]]`에서 `(` 또는 `)`를 이스케이프하면 안 됩니다.
check.1035.you.need.a.space.here=여기에 공백이 필요합니다
check.1036.is.invalid.here.did.you.forget.to.escape.it=`(`는 여기에서 올바르지 않습니다. 이스케이프하는 것을 잊으셨나요?
check.1037.braces.are.required.for.positionals.over.9.e.g.10=9가 넘는 위치(예\: 10)에는 중괄호가 필요합니다.
check.1038.shells.are.space.sensitive.use.cmd.not.cmd=셸은 공백을 구분합니다. ''< <(cmd)''가 아닌 ''<<(cmd)''를 사용하세요.
check.1039.remove.indentation.before.end.token.or.use.and.indent.with.tabs=종료 토큰 앞의 들여쓰기를 제거하세요(또는`<<-`를 사용하고 탭으로 들여쓰기).
check.1040.when.using.you.can.only.indent.with.tabs=<<-를 사용하면 탭으로만 들여쓰기할 수 있습니다.
check.1041.found.eof.further.down.but.not.on.a.separate.line=더 아래에서 ''eof''를 찾았지만 별도의 줄에는 없습니다.
check.1042.found.eof.further.down.but.not.on.a.separate.line=더 아래에서 ''eof''를 찾았지만 별도의 줄에는 없습니다.
check.1044.couldn.t.find.end.token.eof.in.the.here.document=El token de terminación "EOF" no se puede encontrar en el documento Here.
check.1045.it.s.not.foo.bar.just.foo.bar=''foo \\&; bar''가 아니라 ''foo \\& bar''입니다.
check.1046.couldn.t.find.fi.for.this.if=이 ''if''에 대한 ''fi''를 찾을 수 없습니다.
check.1047.expected.fi.matching.previously.mentioned.if=이전에 언급된 ''if''에 대응하는 ''fi''가 필요합니다.
check.1048.can.t.have.empty.then.clauses.use.true.as.a.no.op=then 절을 비워두면 안 됩니다( ''true''를 no-op로 사용).
check.1049.did.you.forget.the.then.for.this.if=이 ''if''에 대한 ''then''을 잊으셨나요?
check.1045.expected.then=''then''이 필요합니다.
check.1051.semicolons.directly.after.then.are.not.allowed.just.remove.it=''then'' 바로 뒤에 오는 세미콜론은 허용되지 않습니다. 제거하세요.
check.1052.semicolons.directly.after.then.are.not.allowed.just.remove.it=''then'' 바로 뒤에 오는 세미콜론은 허용되지 않습니다. 제거하세요.
check.1053.semicolons.directly.after.else.are.not.allowed.just.remove.it=''else'' 바로 뒤에 오는 세미콜론은 허용되지 않습니다. 제거하세요.
check.1054.you.need.a.space.after.the=''{'' 뒤에 공백이 필요합니다.
check.1058.expected.do=`do`가 필요합니다.
check.1061.couldn.t.find.done.for.this.do=이 ''do''에 대한 ''done''을 찾을 수 없습니다.
check.1062.expected.done.matching.previously.mentioned.do=이전에 언급된 ''do''에 대응하는 ''done''이 필요합니다.
check.1064.expected.a.to.open.the.function.definition=함수 정의를 여는 {가 필요합니다.
check.1065.trying.to.declare.parameters.don.t.use.and.refer.to.params.as.1.2=매개변수를 선언하려고 하시나요? 멈춰 주세요. ()를 사용해 매개변수를 $1, $2로 참조하세요.
check.1066.don.t.use.on.the.left.side.of.assignments=대입의 왼쪽에 $를 사용하면 안 됩니다.
check.1068.don.t.put.spaces.around.the.in.assignments=대입 내 \= 주위에 공백을 두면 안 됩니다.
check.1069.you.need.a.space.before.the=[ 앞에 공백이 필요합니다.
check.1071.shellcheck.only.supports.sh.bash.dash.ksh.scripts.sorry=ShellCheck은 sh/bash/dash/ksh 스크립트만 지원합니다. 죄송합니다\!
check.1072.unexpected=예기치 않은 항목 ..
check.1073.couldn.t.parse.this.thing.fix.to.allow.more.checks=이 항목을 분석할 수 없습니다. 검사를 더 진행하려면 수정하세요.
check.1075.use.elif.instead.of.else.if=''else if'' 대신 ''elif''를 사용하세요.
check.1077.for.command.expansion.the.tick.should.slant.left.vs=명령어 확장의 경우 틱 표시가 왼쪽으로 기울어야 합니다(` 대비 ´).
check.1078.did.you.forget.to.close.this.double.quoted.string=이 큰따옴표가 붙은 문자열을 닫는 것을 잊으셨나요?
check.1079.this.is.actually.an.end.quote.but.due.to.next.char.it.looks.suspect=이것은 실제로 종료 따옴표이지만 그 다음 문자로 인해 의심스러워 보입니다.
check.1081.scripts.are.case.sensitive.use.if.not.if=스크립트는 대소문자를 구분합니다. ''If''가 아닌 ''if''를 사용하세요.
check.1082.this.file.has.a.utf.8.bom.remove.it.with.lc.ctype.c.sed.1s.yourscript=이 파일에는 UTF-8 BOM이 있습니다. LC_CTYPE\=C sed ''1s/^...//'' < yourscript를 사용하여 제거하세요.
check.1083.this.is.literal.check.expression.missing.or.quote.it=이 `{`/`}`는 리터럴입니다. 표현식을 확인하거나(`;/\n?` 누락) 따옴표로 묶으세요.
check.1084.use.not.for.the.shebang=shebang에는 \!\#이 아닌 \#\!를 사용하세요.
check.1086.don.t.use.on.the.iterator.name.in.for.loops=for 루프 내 iterator 이름에 $를 사용하면 안 됩니다.
check.1087.use.braces.when.expanding.arrays.e.g.array.idx.or.var.to.quiet=배열을 확장할 경우 ${array[idx]}와 같이 중괄호를 사용하세요(경고를 표시하지 않으려면 ${var}[..).
check.1088.parsing.stopped.here.invalid.use.of.parentheses=분석이 여기에서 중지되었습니다. 소괄호가 잘못 사용되었나요?
check.1089.parsing.stopped.here.is.this.keyword.correctly.matched.up=분석이 여기에서 중지되었습니다. 이 키워드가 올바르게 대응하나요?
check.1090.can.t.follow.non.constant.source.use.a.directive.to.specify.location=상수가 아닌 소스는 따를 수 없습니다. 지시문을 사용하여 위치를 지정하세요.
check.1091.not.following.error.message.here=따를 수 없습니다. (여기에 오류 메시지)
check.1094.parsing.of.sourced.file.failed.ignoring.it=소스로 참조된 파일을 분석하지 못했습니다. 해당 파일을 무시합니다.
check.1095.you.need.a.space.or.linefeed.between.the.function.name.and.body=함수 이름과 본문 사이에 공백이나 라인피드가 필요합니다.
check.1097.unexpected.for.assignment.use.for.comparison.use=예기치 않은 \=\=입니다. 대입의 경우 \=을 사용하세요. 비교의 경우 [/[[를 사용하세요.
check.1098.quote.escape.special.characters.when.using.eval.e.g.eval.a.b=eval을 사용할 때 특수 문자를 따옴표로 묶거나 이스케이프하세요(예\: eval "a\=(b)").
check.1099.you.need.a.space.before.the=\# 앞에 공백이 필요합니다.
check.1100.this.is.a.unicode.dash.delete.and.retype.as.ascii.minus=이것은 유니코드 대시입니다. 삭제하고 ASCII 마이너스로서 다시 입력하세요.
check.1101.delete.trailing.spaces.after.to.break.line.or.use.quotes.for.literal.space=\\ 뒤의 후행 공백을 삭제하여 줄을 바꾸세요(또는 리터럴 공백에 따옴표 사용).
check.1102.shells.disambiguate.differently.or.not.at.all.if.the.first.should.start.command.substitution.add.a.space.after.it=셸이 $((를 다르게 명확히 하거나 전혀 명확히 하고 있지 않습니다. 첫 번째 $(가 명령어 대체를 시작해야 하는 경우 그 뒤에 공백을 추가하세요.
check.1104.use.not.just.for.the.shebang=shebang에는 \!만이 아닌 \#\!를 사용하세요.
check.1105.shells.disambiguate.differently.or.not.at.all.if.the.first.should.start.a.subshell.add.a.space.after.it=셸이 ((를 다르게 명확히 하거나 전혀 명확히 하고 있지 않습니다. 첫 번째 (가 하위 셸을 시작해야 하는 경우 그 뒤에 공백을 추가하세요.
check.1107.this.directive.is.unknown.it.will.be.ignored=이 지시문은 알 수 없습니다. 무시됩니다.
check.1108.you.need.a.space.before.and.after.the=\= 앞뒤에 공백이 필요합니다.
check.1109.this.is.an.unquoted.html.entity.replace.with.corresponding.character=이것은 따옴표로 묶이지 않은 HTML 엔티티입니다. 해당하는 문자로 바꾸세요.
check.1110.this.is.a.unicode.quote.delete.and.retype.it.or.quote.to.make.literal=이것은 유니코드 따옴표입니다. 삭제하고 다시 입력하세요(또는 리터럴로 만들려면 따옴표 사용).
check.1111.this.is.a.unicode.quote.delete.and.retype.it.or.ignore.singlequote.for.literal=이것은 유니코드 따옴표입니다. 삭제하고 다시 입력하세요(또는 리터럴의 경우 무시하거나 작은따옴표 사용).
check.1112.this.is.a.unicode.quote.delete.and.retype.it.or.ignore.doublequote.for.literal=이것은 유니코드 따옴표입니다. 삭제하고 다시 입력하세요(또는 리터럴의 경우 무시하거나 큰따옴표 사용).
check.1113.use.not.just.for.the.sheban=shebang에는 \#만이 아닌 \#\!를 사용하세요.
check.1114.remove.leading.spaces.before.the.shebang=shebang 앞의 선행 공백을 제거하세요.
check.1115.remove.spaces.between.and.in.the.shebang=shebang에서 \#과 \! 사이의 공백을 제거하세요.
check.1116.missing.on.a.expression.or.use.for.arrays=$((..)) 식에 $가 누락되었나요? (또는 배열의 경우 ( ( 사용)
check.1117.backslash.is.literal.in.prefer.explicit.escaping.n=백슬래시는 " " 내 리터럴입니다.\n명시적 이스케이프를 선호합니다\: "\\n".
check.1118.delete.whitespace.after.the.here.doc.end.token=here-doc 종료 토큰 뒤의 공백을 삭제하세요.
check.1119.add.a.linefeed.between.end.token.and.terminating=종료 토큰과 종료하는 '')'' 사이에 라인피드를 추가하세요.
check.1120.no.comments.allowed.after.here.doc.token.comment.the.next.line.instead=here-doc 토큰 뒤에 주석은 허용되지 않습니다. 대신 다음 줄에 주석을 추가하세요.
check.1121.add.terminators.and.other.syntax.on.the.line.with.the.not.here=여기가 아닌 <<가 있는 줄에 ;/\\& 종료자(및 기타 구문)를 추가하세요.
check.1122.nothing.allowed.after.end.token.to.continue.a.command.put.it.on.the.line.with.the=종료 토큰 뒤에는 아무것도 허용되지 않습니다. 명령어를 계속 작성하려면 `<<`가 있는 줄에 입력하세요.
check.1123.shellcheck.directives.are.only.valid.in.front.of.complete.compound.commands.like.if.not.e.g.individual.elif.branches=ShellCheck 지시문은 개별 `elif` 브랜치가 아닌 `if`와 같은 완전한 복합 명령어 앞에서만 유효합니다.
check.1124.shellcheck.directives.are.only.valid.in.front.of.complete.commands.like.case.statements.not.individual.case.branches=ShellCheck 지시문은 개별 case 브랜치가 아닌 ''case'' 문과 같은 완전한 명령어 앞에만 유효합니다.
check.1126.place.shellcheck.directives.before.commands.not.after=ShellCheck 지시문을 명령어 뒤가 아닌 앞에 배치하세요.
check.1127.was.this.intended.as.a.comment.use.in.sh=이것은 주석으로 작성된 것인가요? sh에서`\#`을 사용하세요.
check.1128.the.shebang.must.be.on.the.first.line.delete.blanks.and.move.comments=shebang은 첫 번째 줄에 있어야 합니다. 공백을 삭제하고 주석을 이동하세요.
check.1129.you.need.a.space.before.the=\! 앞에 공백이 필요합니다.
check.1130.you.need.a.space.before.the=\: 앞에 공백이 필요합니다.
check.1131.use.elif.to.start.another.branch=다른 브랜치를 시작하려면 `elif`를 사용하세요.
this.terminates.the.command.escape.it.or.add.space.after.to.silence=이 `\\&`는 명령어를 종료합니다. 이스케이프하거나, 경고를 표시하지 않으려면 `\\&` 뒤에 공백을 추가하세요.
unexpected.start.of.line.if.breaking.lines.should.be.at.the.end.of.the.previous.one=예기치 않은 줄의 시작입니다. 줄 바꿈을 하려는 경우 |/||/\\&\\&가 이전 줄의 끝에 있어야 합니다.
arrays.implicitly.concatenate.in.use.a.loop.or.explicit.instead.of=배열이 `[[ ]]`에서 묵시적으로 연결됩니다. 루프(또는 @이 아닌 명시적 *)를 사용하세요.
arrays.don.t.work.as.operands.in.use.a.loop.or.concatenate.with.instead.of=배열은 [ ]에서 피연산자로 작동하지 않습니다. 루프를 사용하세요(또는 @이 아닌 *로 연결).
fgrep.is.non.standard.and.deprecated.use.grep.f.instead=fgrep은 비표준이며 더 이상 사용되지 않습니다. 대신 grep -F를 사용하세요.
egrep.is.non.standard.and.deprecated.use.grep.e.instead=egrep은 비표준이며 더 이상 사용되지 않습니다. 대신 grep -E를 사용하세요.
this.pattern.will.never.match.the.case.statement.s.word.double.check.them=이 패턴은 case 문의 단어에 대응하지 않습니다. 다시 확인해 주세요.
this.word.is.constant.did.you.forget.the.on.a.variable=이 단어는 상수입니다. 변수에서 $를 잊으셨나요?
the.arguments.to.this.comparison.can.never.be.equal.make.sure.your.syntax.is.correct=이 비교의 인수는 절대 동일하면 안 됩니다. 구문이 올바른지 확인하세요.
this.array.element.has.no.value.remove.spaces.after.or.use.for.empty.string=이 배열 요소에는 값이 없습니다. \= 뒤의 공백을 제거하거나 빈 문자열에 ""를 사용하세요.
the.here.is.literal.to.assign.by.index.use.index.value.with.no.spaces.to.keep.as.literal.quote.it=여기에서 \=는 리터럴입니다. 색인으로 대입하려면 ([색인]\=값)을 사용하세요. 리터럴로 유지하려면 따옴표로 묶으세요.
elements.in.associative.arrays.need.index.e.g.array.index.value=연관 배열의 요소에는 색인이 필요합니다(예\: array\=([색인]\=값).
you.can.t.have.between.this.redirection.and.the.command.it.should.apply.to=이 리디렉션과 해당 리디렉션이 적용되어야 하는 명령어 사이에 |를 사용할 수 없습니다.
this.redirection.doesn.t.have.a.command.move.to.its.command.or.use.true.as.no.op=이 리디렉션에는 명령어가 없습니다. 해당 명령어로 이동하세요(또는 ''true''를 no-op로 사용).
ash.scripts.will.be.checked.as.dash.add.shellcheck.shell.dash.to.silence=Ash 스크립트는 Dash로서 확인됩니다. 경고를 표시하지 않으려면 ''\# shellcheck shell\=dash''를 추가하세요.
tempfile.is.deprecated.use.mktemp.instead=tempfile은 더 이상 사용되지 않습니다. 대신 mktemp를 사용하세요.
some.finds.don.t.have.a.default.path.specify.explicitly=일부 find에 디폴트 경로가 없습니다. ''.''를 명시적으로 지정하세요.
quote.arguments.to.unset.so.they.re.not.glob.expanded=설정 해제할 인수가 glob 확장이 되지 않도록 인수를 따옴표로 묶으세요.
this.format.string.has.2.variables.but.is.passed.1.arguments=이 형식 문자열에는 2개의 변수가 있지만 1개의 인수가 전달됩니다.
this.printf.format.string.has.no.variables.other.arguments.are.ignored=이 printf 형식 문자열에는 변수가 없습니다. 다른 인수는 무시됩니다.
check.exit.code.directly.with.e.g.if.mycmd.not.indirectly.with=종료 코드를 $?를 사용해 간접적으로 확인하지 말고 ''if mycmd;'' 등으로 직접적으로 확인하세요.
bash.does.not.support.multidimensional.arrays.use.1d.or.associative.arrays=Bash는 다차원 배열을 지원하지 않습니다. 1차원 또는 연관 배열을 사용하세요.
use.array.item.to.append.items.to.an.array=배열에 항목을 추가하려면 array+\=("item")을 사용하세요.
variable.was.used.as.an.array.but.is.now.assigned.a.string=변수가 배열로 사용되었지만 지금 문자열이 대입되었습니다.
time.is.undefined.for.compound.commands.time.sh.c.instead=''time''이 복합 명령어에 대해 정의되지 않았습니다. time sh -c를 사용하세요.
time.is.undefined.for.pipelines.time.single.stage.or.bash.c.instead=''time''이 파이프라인에 대해 정의되지 않았습니다. time 단일 단계 또는 bash -c를 사용하세요.
quote.this.invalid.brace.expansion.since.it.should.be.passed.literally.to.eval=이 잘못된 괄호 확장은 그대로 eval에 전달되어야 하므로 따옴표로 묶으세요.
when.used.with.p.m.only.applies.to.the.deepest.directory=-m은 -p와 함께 사용될 경우 최하단 디렉터리에만 적용됩니다.
sigkill.sigstop.can.not.be.trapped=SIGKILL/SIGSTOP을 트랩할 수 없습니다.
trapping.signals.by.number.is.not.well.defined.prefer.signal.names=시그널을 숫자로 트랩하는 것은 명확하게 정의되지 않습니다. 시그널 이름을 사용하는 것이 좋습니다.
numerical.eq.does.not.dereference.in.expand.or.use.string.operator=숫자 -eq는 [..]에서 역참조하지 않습니다. 문자열 연산자를 확장하거나 사용하세요.
in.dash.something.is.not.supported=dash에서는 *something*가 지원되지 않습니다.
local.is.only.valid.in.functions=''local''은 함수에서만 유효합니다.
this.parent.loop.has.its.index.variable.overridden=이 상위 루프에서 해당 색인 변수가 재정의되어 있습니다.
prefer.p.q.as.p.a.q.is.not.well.defined=[ p -a q ]가 명확하게 정의되지 않으므로 [ p ] && [ q ]를 사용하는 것이 좋습니다.
this.nested.loop.overrides.the.index.variable.of.its.parent=이 중첩 루프는 해당 상위 항목의 색인 변수를 재정의합니다.
use.cd.exit.in.case.cd.fails=cd가 실패할 경우 cd... || exit을 사용하세요.
this.does.not.export.foo.remove.for.that.or.use.var.to.quiet=이것은 ''FOO''를 내보내지 않습니다. 내보내려면 $/${}를 제거하거나 경고가 표시되지 않도록 ${var?}를 사용하세요.
read.without.r.will.mangle.backslashes=-r 없이 읽으면 백슬래시가 불분명해집니다.
instead.of.1.use.true=''[ 1 ]'' 대신 ''true''를 사용하세요.
instead.of.true.just.use.true=''[ true ]'' 대신 ''true''를 사용하세요.
0.is.true.use.false.instead=[ 0 ]은 true입니다. 대신 ''false''를 사용하세요
false.is.true.remove.the.brackets=[ false ]는 true입니다. 대괄호를 제거하세요
argument.to.implicit.n.is.always.true.due.to.literal.strings=묵시적 -n에 대한 인수는 리터럴 문자열로 인해 항상 true입니다.
injecting.filenames.is.fragile.and.insecure.use.parameters=파일 이름을 삽입하는 것은 불안정하고 안전하지 않습니다. 매개변수를 사용하세요.
declare.and.assign.separately.to.avoid.masking.return.values=반환 값을 마스킹하지 않으려면 별도로 선언하고 대입하세요.
var.is.referenced.but.not.assigned=var가 참조되었지만 대입되지 않았습니다.
possible.misspelling.myvariable.may.not.be.assigned.but.my.variable.is=철자 오류 가능성\: MYVARIABLE은 대입되지 않을 수 있지만 MY_VARIABLE은 대입됩니다.
can.only.return.0.255.other.data.should.be.written.to.stdout=0~255만 반환할 수 있습니다. 다른 데이터는 표준 출력으로 작성해야 합니다.
only.one.integer.0.255.can.be.returned.use.stdout.for.other.data=0~255의 정수 하나만 반환할 수 있습니다. 다른 데이터는 표준 출력을 사용하세요.
exec.does.not.automatically.invoke.a.shell.use.exec.sh.c.for.that=-exec는 셸을 자동으로 호출하지 않습니다. 자동 호출하려면 -exec sh -c ..를 사용하세요.
remove.for.numeric.index.or.escape.it.for.string=숫자 색인의 경우 $/${}를 제거하거나 문자열의 경우 이를 이스케이프하세요.
tips.depend.on.target.shell.and.yours.is.unknown.add.a.shebang=팁은 대상 셸에 따라 다르며 사용 중인 셸은 알 수 없습니다. shebang을 추가하세요.
literal.tilde.in.path.works.poorly.across.programs=PATH의 리터럴 물결표는 프로그램 전반에서 제대로 작동하지 않습니다.
this.action.ignores.everything.before.the.o.use.to.group=이 액션은 -o 앞의 모든 것을 무시합니다. 그룹화하려면 \\(\\)를 사용하세요.
argument.mixes.string.and.array.use.or.separate.argument=인수에 문자열과 배열이 혼재되어 있습니다. * 또는 별도의 인수를 사용하세요.
e.doesn.t.work.with.globs.use.a.for.loop=-e는 glob와 작동하지 않습니다. for 루프를 사용하세요.
use.grep.q.instead.of.comparing.output.with.n=[ -n .. ]으로 출력을 비교하는 대신 grep -q를 사용하세요.
aliases.can.t.use.positional.parameters.use.a.function=별칭은 위치 매개변수를 사용할 수 없습니다. 함수를 사용하세요.
did.you.mean.ifs=IFS\=$''\t''를 의도하셨나요?
word.is.on.the.form.a.b.c.b.indicated.did.you.mean.abc.or.a.b.c=\ 단어가 "A"B"C"(B 표시) 형식으로 되어 있습니다. "ABC" 또는 "A\"B\"C"를 의도하셨나요?
this.expands.when.defined.not.when.used.consider.escaping=이것은 사용될 때가 아니라 정의될 때 확장됩니다. 이스케이프하는 것이 좋습니다.
eq.is.for.integer.comparisons.use.instead=-eq는 정수 비교에 사용됩니다. 대신 \=를 사용하세요.
consider.using.cmd1.cmd2.file.instead.of.individual.redirects=개별 리디렉션 대신 { cmd1; cmd2; } >> 파일을 사용하는 것이 좋습니다.
expanding.an.array.without.an.index.only.gives.the.first.element=색인 없이 배열을 확장하면 첫 번째 요소만 제공됩니다.
consider.using.grep.c.instead.of.grep.wc=grep|wc 대신 grep -c를 사용하는 것이 좋습니다.
brace.expansions.and.globs.are.literal.in.assignments.quote.it.or.use.an.array=중괄호 확장 및 glob는 대입에서 리터럴입니다. 해당 항목을 따옴표로 묶거나 배열을 사용하세요.
assigning.an.array.to.a.string.assign.as.array.or.use.instead.of.to.concatenate=배열을 문자열에 대입하고 있습니다\! 배열로서 대입하거나 @ 대신 *를 사용하여 연결하세요.
path.is.the.shell.search.path.use.another.name=PATH는 셸 검색 경로입니다. 다른 이름을 사용하세요.
is.not.a.valid.operator.use.a.b.instead=>\=는 올바른 연산자가 아닙니다. 대신 ''\! a < b''를 사용하세요.
to.assign.a.variable.use.just.var.value.no.set=변수를 대입하려면 ''set ..''이 아닌 ''var\=value''를 사용하세요.
foo.references.arguments.but.none.are.ever.passed=foo는 인수를 참조하지만 아무것도 전달되지 않습니다.
use.foo.if.function.s.1.should.mean.script.s.1=함수의 $1이 스크립트의 $1을 의미해야 하는 경우 foo "$@"를 사용하세요.
to.run.commands.as.another.user.use.su.c.or.sudo=다른 사용자로서 명령어를 실행하려면 su -c 또는 sudo를 사용하세요.
useless.echo.instead.of.cmd.echo.foo.just.use.cmd.foo=무의미한 echo가 아닌가요? ''cmd $(echo foo)'' 대신 ''cmd foo''를 사용하세요.
use.var.to.ensure.this.never.expands.to="${var\:?}"를 사용하여 /*로 확장되지 않도록 하세요.
warning.deletes.a.system.directory=경고\: 시스템 디렉터리를 삭제합니다.
function.keyword.is.non.standard.delete.it=''function'' 키워드는 표준이 아닙니다. 삭제하세요.
in.use.instead.of.o=[\\[..]]에서 -o 대신 ||를 사용하세요.
instead.of.a.b.use.a.b=[ a || b ] 대신 [ a ] || [ b ]를 사용하세요.
in.use.instead.of.a=[\\[..]]에서 -a 대신 &&를 사용하세요.
instead.of.a.b.use.a.b2=[ a && b ] 대신 [ a ] && [ b ]를 사용하세요.
sc2106.this.only.exits.the.subshell.caused.by.the.pipeline=SC2106\: 파이프라인으로 발생한 하위 셸만 종료됩니다.
break.is.only.valid.in.loops=`break`는 루프에서만 유효합니다
in.functions.use.return.instead.of.break=함수에서는 break 대신 return을 사용하세요.
use.a.subshell.to.avoid.having.to.cd.back=cd를 되돌리지 않으려면 ( 하위 셸 )을 사용하세요.
ranges.can.only.match.single.chars.mentioned.due.to.duplicates=범위는 단일 문자(중복으로 인해 언급된)와만 대응합니다.
named.class.needs.outer.e.g.digit=이름 지정된 클래스는 바깥에 []가 필요합니다(예\: [[\:digit\:]\\]).
use.for.arithmetics.e.g.i.i.2=산술에 `$((..))`를 사용하세요(예\: `i\=$((i + 2))`)
this.expansion.will.not.see.the.mentioned.assignment=이 확장에는 언급된 대입이 표시되지 않습니다.
this.assignment.is.only.seen.by.the.forked.process=이 대입은 포크된 프로세스에서만 볼 수 있습니다.
on.most.os.shebangs.can.only.specify.a.single.parameter=대부분의 OS에서 shebang은 단일 매개변수만 지정할 수 있습니다.
add.dev.null.to.prevent.ssh.from.swallowing.stdin=ssh가 표준 입력을 읽지 않도록 < /dev/null을 추가하세요.
sc2094.make.sure.not.to.read.and.write.the.same.file.in.the.same.pipeline=SC2094 동일한 파이프라인에서 동일한 파일을 읽고 쓰지 않도록 하세요.
remove.exec.if.script.should.continue.after.this.command=이 명령어 이후 스크립트가 계속되어야 하는 경우 "exec "를 제거하세요.
remove.backticks.to.avoid.executing.output=출력을 실행하지 않으려면 백틱을 제거하세요.
remove.surrounding.to.avoid.executing.output=출력을 실행하지 않으려면 주위의 $()를 제거하세요.
quotes.backslashes.in.this.variable.will.not.be.respected=이 변수의 따옴표/백슬래시는 준수되지 않습니다.
quotes.backslashes.will.be.treated.literally.use.an.array=따옴표/백슬래시는 문자 그대로 처리됩니다. 배열을 사용하세요.
tilde.does.not.expand.in.quotes.use.home=물결표는 따옴표에서 확장되지 않습니다. $HOME을 사용하세요.
quote.eof.to.make.here.document.expansions.happen.on.the.server.side.rather.than.on.the.client=Si desea que la expansión del documento Here se produzca en el lado del servidor en lugar del lado del cliente, incluya ''EOF'' entre comillas.
double.quote.to.prevent.globbing.and.word.splitting=글로빙 및 단어 분할을 방지하려면 큰따옴표로 묶으세요.
remove.or.use.expr.to.avoid.executing.output=출력을 실행하지 않으려면 ''$''를 제거하거나 ''_\=$((expr))''를 사용하세요.
to.expand.via.indirection.use.name.foo.n.echo.name=간접적으로 확장하려면 name\="foo$n"; echo "${\!name}"을 사용하세요.
can.t.match.globs.use.or.grep=`[ .. ]`는 glob에 대응하지 않습니다. `[[ .. ]]`또는 grep을 사용하세요.
numbers.with.leading.0.are.considered.octal=앞에 0이 있는 숫자는 8진수로 간주됩니다.
doesn.t.support.decimals.use.bc.or.awk=(( ))는 소수를 지원하지 않습니다. bc 또는 awk를 사용하세요.
this.expression.is.constant.did.you.forget.a.somewhere=이 표현식은 상수입니다. 어딘가에서 `$`를 잊지 않으셨나요?
you.need.spaces.around.the.comparison.operator=비교 연산자 주위에 공백이 필요합니다.
don.t.quote.rhs.of.it.ll.match.literally.rather.than.as.a.regex=\=~의 rhs를 따옴표로 묶으면 안 됩니다. 정규식이 아닌 문자 그대로 대응합니다.
can.t.use.in.use.instead=`[ ]`에서 `\=~`를 사용할 수 없습니다. 대신 `[[..]]`를 사용하세요.
decimals.are.not.supported.either.use.integers.only.or.use.bc.or.awk.to.compare=소수는 지원되지 않습니다. 정수만 사용하거나 bc 또는 awk를 사용하여 비교하세요.
is.for.string.comparisons.use.gt.instead=>는 문자열 비교에 사용됩니다. 대신 -gt를 사용하세요.
n.doesn.t.work.with.unquoted.arguments.quote.or.use=`-n`은 따옴표로 묶이지 않은 인수와 함께 작동하지 않습니다. 따옴표로 묶거나 ``[[ ]]``를 사용하세요.
to.redirect.stdout.stderr.2.1.must.be.last.or.use.cmd.file.2.1.to.clarify=표준 출력+표준 오류를 리디렉션하려면 2>&1이 마지막에 와야 합니다(또는 명확히 구분 짓기 위해 ''{cmd > file;} 2>&1''을 사용).
double.quote.array.expansions.to.avoid.re.splitting.elements=요소 재분할을 방지하려면 배열 확장을 큰따옴표로 묶으세요.
missing.or.terminating.exec.you.can.t.use.and.has.to.be.a.separate.quoted.argument=-exec를 종료하는 '';'' 또는 +가 누락되었습니다. |/||/&&를 사용할 수 없으며 '';''은 별도의 따옴표로 묶인 인수여야 합니다.
since.you.double.quoted.this.it.will.not.word.split.and.the.loop.will.only.run.once=이것은 큰따옴표로 묶였으므로 단어 분할을 하지 않으며 루프는 한 번만 실행됩니다.
this.is.interpreted.as.a.shell.file.redirection.not.a.comparison=이것은 비교가 아니라 셸 파일 리디렉션으로 해석됩니다.
use.single.quotes.otherwise.this.expands.now.rather.than.when.signalled=작은따옴표를 사용하세요. 그러지 않으면 시그널을 받을 때가 아니라 지금 확장됩니다.
grep.uses.regex.but.this.looks.like.a.glob=grep은 정규식을 사용하지만 이것은 glob처럼 보입니다.
quote.the.grep.pattern.so.the.shell.won.t.interpret.it=grep 패턴을 셸이 해석하지 않도록 따옴표로 묶으세요.
quote.the.parameter.to.name.so.the.shell.won.t.interpret.it=-name에 대한 매개변수를 셸이 해석하지 않도록 따옴표로 묶으세요.
quote.parameters.to.tr.to.prevent.glob.expansion=glob 확장을 방지하기 위해 tr에 대한 매개변수를 따옴표로 묶으세요.
don.t.use.variables.in.the.printf.format.string.use.printf.s.foo=printf 형식 문자열에 변수를 사용하면 안 됩니다. printf "..%s.." "$foo"를 사용하세요.
unknown.unaryoperator=알 수 없는 단항 연산자입니다.
unknown.binary.operator=알 수 없는 이항 연산자입니다.
you.probably.wanted.here=여기에 &&를 의도하셨던 것 같습니다
use.spaces.not.commas.to.separate.array.elements=Separe los elementos de la matriz con espacios, no con comas.
quote.the.rhs.of.in.to.prevent.glob.matching=glob 대응을 방지하려면 [[ ]]에서 \=의 rhs를 따옴표로 묶으세요.
bash.doesn.t.support.variables.in.brace.range.expansions=Bash는 중괄호 범위 확장에서 변수를 지원하지 않습니다.
this.expression.is.constant.did.you.forget.the.on.a.variable=이 표현식은 상수입니다. 변수에서 `$`를 잊으셨나요?
is.for.regex.but.this.looks.like.a.glob.use.instead=\=~는 정규식에 사용되지만 이것은 glob처럼 보입니다. 대신 \=를 사용하세요.
use.with.quotes.to.prevent.whitespace.problems=공백 문제를 방지하려면 "$@"(따옴표 포함)를 사용하세요.
quote.this.to.prevent.word.splitting=단어 분할을 방지하려면 이것을 따옴표로 묶으세요.
iterating.over.ls.output.is.fragile.use.globs=ls 출력을 반복하는 것은 불안정합니다. glob을 사용하세요.
for.loops.over.find.output.are.fragile.use.find.exec.or.a.while.read.loop=find 출력에 대한 for 루프는 불안정합니다. find -exec 또는 while 읽기 루프를 사용하세요.
this.loop.will.only.ever.run.once.for.a.constant.value.did.you.perhaps.mean.to.loop.over.dir.var.or.cmd=이 루프는 상수 값에 대해 한 번만 실행됩니다. dir/*, $var 또는 $(cmd)를 반복하려고 하셨나요?
this.is.a.literal.string.to.run.as.a.command.use.instead.of=이것은 리터럴 문자열입니다. 명령어로 실행하려면 ''..'' 대신 $(..)를 사용하세요.
bin.sh.was.specified.so.is.not.supported.even.when.sh.is.actually.bash=\#\!/bin/sh가 지정되었으므로 sh가 실제로 bash인 경우에도 ____는 지원되지 않습니다.
in.posix.sh.something.is.undefined=POSIX sh에서 *something*이 정의되어 있지 않습니다.
use.print0.0.or.find.exec.to.allow.for.non.alphanumeric.filenames=영숫자가 아닌 파일 이름을 허용하려면 -print0/-0 또는 find -exec +를 사용하세요.
to.assign.the.output.of.a.command.use.var.cmd=명령어의 출력을 대입하려면 var\=$(cmd)를 사용하세요.
if.you.wanted.to.assign.the.output.of.the.pipeline.use.a.b.c=파이프라인의 출력을 대입하려면 a\=$(b | c)를 사용하세요.
use.glob.or.glob.so.names.with.dashes.won.t.become.options=대시가 있는 이름이 옵션이 되지 않도록 ./\\*glob* 또는 -- \\*glob*를 사용하세요.
foo.appears.unused.verify.it.or.export.it=foo는 사용되지 않는 것 같습니다. 확인하거나 내보내세요.
shell.functions.can.t.be.passed.to.external.commands=셸 함수는 외부 명령어에 전달할 수 없습니다.
use.own.script.or.sh.c.to.run.this.from.su=이것을 su에서 실행하려면 자체 스크립트 또는 sh -c ''..''를 사용하세요.
var.was.modified.in.a.subshell.that.change.might.be.lost=var가 하위 셸에서 수정되었습니다. 변경 내용이 손실될 수 있습니다.
modification.of.var.is.local.to.subshell.caused.by.pipeline=var 수정은 (파이프라인으로 생긴 하위 셸에) 국한됩니다.
note.that.unescaped.this.expands.on.the.client.side=이것은 이스케이프되지 않으면 클라이언트 측에서 확장됩니다.
echo.won.t.expand.escape.sequences.consider.printf=echo는 이스케이프 시퀀스를 확장하지 않습니다. printf를 고려해 보세요.
the.surrounding.quotes.actually.unquote.this.remove.or.escape.them=주위 따옴표가 실제로 따옴표를 해제합니다. 따옴표를 제거하거나 이스케이프하세요.
this.word.is.outside.of.quotes.did.you.intend.to.nest.single.quotes.instead=이 단어는 따옴표 외부에 있습니다. ''대신 ""작은따옴표""를 중첩''하려고 하셨나요?
make.sure.all.escape.sequences.are.enclosed.in.to.prevent.line.wrapping.issues=줄 바꿈 문제를 방지하기 위해 모든 이스케이프 시퀀스가 `\\[..\\]`로 묶여 있는지 확인하세요
sudo.doesn.t.affect.redirects.use.sudo.tee.file=''sudo''는 리디렉션에 영향을 주지 않습니다. `..| sudo tee file`을 사용하세요
note.that.unlike.globs.o.here.matches.ooo.but.not.oscar=glob와 달리 o*는 여기에서 ''ooo''에는 대응하지만 ''oscar''에는 대응하지 않습니다
don.t.use.around.ranges.in.tr.it.replaces.literal.square.brackets=tr의 범위 주위에 []를 사용하면 안 됩니다. 해당 괄호가 리터럴 대괄호를 대체합니다.
tr.replaces.sets.of.chars.not.words.mentioned.due.to.duplicates=tr은 단어가 아닌 문자 집합을 대체합니다(중복으로 인해 언급됨).
use.upper.to.support.accents.and.foreign.alphabets=악센트 및 외국어 자모를 지원하려면 ''[\:upper\:]''를 사용하세요.
use.lower.to.support.accents.and.foreign.alphabets=악센트 및 외국어 자모를 지원하려면 ''[\:lower\:]''를 사용하세요.
increase.precision.by.replacing.a.b.c.with.a.c.b=a/b\\*c를 a\\*c/b로 대체하여 정밀도를 높이세요.
expressions.don.t.expand.in.single.quotes.use.double.quotes.for.that=표현식은 작은따옴표로 확장되지 않습니다. 확장하려면 큰따옴표를 사용하세요.
note.that.a.b.c.is.not.if.then.else.c.may.run.when.a.is.true=A && B || C는 if-then-else가 아닙니다. C는 A가 true일 때 실행될 수 있습니다.
this.will.expand.once.before.find.runs.not.per.file.found=이것은 찾은 파일마다가 아니라 find 실행 전에 한 번 확장됩니다.
to.read.lines.rather.than.words.pipe.redirect.to.a.while.read.loop=단어가 아닌 행을 읽으려면 ''while read'' 루프로 파이프/리디렉션하세요.
use.find.instead.of.ls.to.better.handle.non.alphanumeric.filenames=영숫자가 아닌 파일 이름을 더 효과적으로 처리하려면 `ls` 대신 `find`를 사용하세요.
don.t.use.ls.grep.use.a.glob.or.a.for.loop.with.a.condition.to.allow.non.alphanumeric.filenames=ls | grep을 사용하면 안 됩니다. 비 영숫자 파일 이름을 허용하는 조건을 가진 glob 또는 for 루프를 사용하세요.
sc2009.consider.using.pgrep.instead.of.grepping.ps.output=SC2009 ps 출력을 grep하는 대신 pgrep을 사용하는 것이 좋습니다.
echo.doesn.t.read.from.stdin.are.you.sure.you.should.be.piping.to.it=echo가 표준 입력에서 읽지 않습니다. echo에 파이핑해야 하나요?
use.instead.of.deprecated=더 이상 사용되지 않는 $[..] 대신 $((..))를 사용하세요
use.notation.instead.of.legacy.backticked=기존에 백틱을 추가한 `` `...` `` 대신 $(...) 표기를 사용하세요.
useless.echo.instead.of.echo.cmd.just.use.cmd=무의미한 `echo`가 아닌가요? `echo $(cmd)` 대신 `cmd`를 사용하세요
is.unnecessary.on.arithmetic.variables=$/${}는 산술 변수에 필요하지 않습니다.
expr.is.antiquated.consider.rewriting.this.using.or=expr은 구식입니다. $((..)), ${} 또는 \\[\\[\\]\\]를 사용하여 이를 다시 작성하는 것이 좋습니다.
useless.cat.consider.cmd.file.or.cmd.file.instead=무의미한 cat입니다. 대신 ''cmd < file | ..'' 또는 ''cmd file | ..''을 사용하는 것이 좋습니다.
sc2001.see.if.you.can.use.variable.search.replace.instead=SC2001\: 대신 ${variable//search/replace}를 사용할 수 있는지 확인하세요.
consider.adding.a.default.case.even.if.it.just.exits.with.error=오류와 함께 종료되더라도 디폴트 *) case를 추가하는 것이 좋습니다.
flip.leading.and.if.this.should.be.a.quoted.substitution=이것이 따옴표로 묶인 대체여야 하는 경우 선행 $ 및 "를 뒤집으세요.
this.shebang.specifies.a.directory.ensure.the.interpreter.is.a.file=이 shebang은 디렉터리를 지정합니다. 인터프리터가 파일인지 확인하세요.
d.only.applies.to.the.first.expansion.of.this.glob.use.a.loop.to.check.any.all=-d는 이 glob의 첫 번째 확장에만 적용됩니다. 루프를 사용하여 모든 것을 확인하세요.
prefer.explicit.n.to.check.non.empty.string.or.use.ne.to.check.boolean.integer=비어 있지 않은 문자열을 확인하려면 명시적 -n을 사용하는 것이 좋습니다(부울/정수를 확인하려면 \=/-ne을 사용).
prefer.explicit.n.to.check.for.output.or.run.command.without.to.check.for.success=출력을 확인하려면 명시적 -n을 사용하는 것이 좋습니다(또는 성공 여부를 확인하려면 [/[[ 없이 명령어를 실행).
can.only.exit.with.status.0.255.other.data.should.be.written.to.stdout.stderr=0~255의 상태만 종료할 수 있습니다. 다른 데이터는 표준 출력/표준 오류로 작성해야 합니다.
the.exit.status.can.only.be.one.integer.0.255.use.stdout.for.other.data=종료 상태는 정수 0~255여야 합니다. 다른 데이터에는 표준 출력을 사용하세요.
the.dot.command.does.not.support.arguments.in.sh.dash.set.them.as.variables=dot 명령어는 sh/dash의 인수를 지원하지 않습니다. 해당 인수를 변수로 설정하세요.
ensure.the.shebang.uses.the.absolute.path.to.the.interpreter=shebang이 인터프리터의 절대 경로를 사용하는지 확인하세요.
redirecting.to.from.command.name.instead.of.file.did.you.want.pipes.xargs.or.quote.to.ignore=파일 대신 명령어 이름으로 또는 이름에서 리디렉션합니다. 파이프/xargs를 사용하시겠어요(또는 따옴표로 묶어 무시)?
use.n.instead.of.z=`\! [ -z .. ]` 대신 `[ -n .. ]`를 사용하세요.
use.n.instead.of.z2=`\! -z` 대신 `-n`을 사용하세요.
use.instead.of.to.avoid.subshell.overhead=하위 셸 오버헤드를 피하려면 `(..)` 대신 `{ ..; }`를 사용하세요.
remove.superfluous.around.test.command=테스트 명령어 주위에 불필요한 `(..)`를 제거하세요.
remove.superfluous.around.condition=조건 주위에 불필요한 `(..)`를 제거하세요.
can.t.use.sudo.with.builtins.like.cd.did.you.want.sudo.sh.c.instead=cd와 같은 기본 제공 기능과 함께 sudo를 사용할 수 없습니다. 대신 sudo sh -c ..를 사용하려 하셨나요?
quote.expansions.in.this.for.loop.glob.to.prevent.wordsplitting.e.g.dir.txt=단어 분할을 방지하려면 for 루프 glob에서 확장을 따옴표로 묶으세요(예\: "$dir"/*.txt).
which.is.non.standard.use.builtin.command.v.instead=which는 표준이 아닙니다. 대신 기본 제공되는 ''command -v''를 사용하세요.
this.does.not.read.foo.remove.for.that.or.use.var.to.quiet=이것은 ''foo''를 읽을 수 없습니다. 읽으려면 $/${}를 제거하거나 경고가 표시되지 않도록 ${var?}를 사용하세요.
redirection.applies.to.the.find.command.itself.rewrite.to.work.per.action.or.move.to.end=리디렉션은 find 명령어 자체에 적용됩니다. 액션별로 다시 작성하세요(또는 끝으로 이동).
this.ln.has.no.destination.check.the.arguments.or.specify.explicitly=이 ln에는 대상이 없습니다. 인수를 확인하거나 ''.''를 명시적으로 지정하세요.
this.cp.has.no.destination.check.the.arguments=이 cp에는 대상이 없습니다. 인수를 확인하세요.
this.mv.has.no.destination.check.the.arguments=이 mv에는 대상이 없습니다. 인수를 확인하세요.
this.default.assignment.may.cause.dos.due.to.globbing.quote.it=이 디폴트 대입은 글로빙으로 인해 DoS를 유발할 수 있습니다. 따옴표로 대입을 묶으세요.
this.pattern.never.matches.because.of.a.previous.pattern=이 패턴은 이전 패턴으로 인해 전혀 대응하지 않습니다.
this.pattern.always.overrides.a.later.one=이 패턴은 항상 이후 패턴을 재정의합니다.
invalid.flags.are.not.handled.add.a.case=잘못된 플래그는 처리되지 않습니다. `*)` case를 추가하세요.
instead.of.let.expr.prefer.expr=`let expr` 대신 `(( expr ))`를 사용하는 것이 좋습니다.
this.function.is.only.defined.later.move.the.definition.up=이 함수는 나중에만 정의됩니다. 정의를 위로 이동하세요.
redirecting.to.echo.a.command.that.doesn.t.read.stdin.bad.quoting.or.missing.xargs=표준 입력을 읽지 않는 명령어인 ''echo''로 리디렉션합니다. 따옴표 묶기가 잘못되었거나 xargs가 누락되지 않았나요?
piping.to.rm.a.command.that.doesn.t.read.stdin.wrong.command.or.missing.xargs=표준 입력을 읽지 않는 명령어인 ''rm''으로 파이핑합니다. 명령어가 잘못되었거나 xargs가 누락되지 않았나요?
this.flag.is.used.as.a.command.name.bad.line.break.or.missing=이 플래그는 명령어 이름으로 사용됩니다. 줄 바꿈이 잘못되었거나 `[..]`가 누락되지 않았나요?
this.case.is.not.specified.by.getopts=이 case는 getopts로 지정되지 않았습니다.
getopts.specified.n.but.it.s.not.handled.by.this.case=-n이 getopts로 지정되었지만 이 ''case''로 처리되지 않습니다.
use.false.instead.of.empty.conditionals=빈 [/[[ 조건 대신 ''false''를 사용하세요.
this.is.a.glob.used.as.a.command.name.was.it.supposed.to.be.in.array.or.is.it.missing.quoting=이것은 명령어 이름으로 사용되는 glob입니다. ${..}, 배열에 있어야 하지 않았나요? 아니면 따옴표가 누락되었나요?
this.is.a.file.redirection.was.it.supposed.to.be.a.comparison.or.fd.operation=이것은 파일 리디렉션입니다. 비교 또는 fd 작업이어야 했나요?
use.var.command.to.assign.output.or.quote.to.assign.string=출력을 대입하려면 var\=$(command)를 사용하세요(또는 문자열을 대입하려면 따옴표 사용).
use.or.quote.arguments.to.v.to.avoid.glob.expansion=glob 확장을 방지하려면 `[[ ]]`를 사용하거나 -v에 대한 인수를 따옴표로 묶으세요.
prefer.mapfile.or.read.a.to.split.command.output.or.quote.to.avoid.splitting=명령어 출력을 분할하려면 mapfile 또는 read -a를 사용하는 것이 좋습니다(또는 분할을 방지하려면 따옴표를 사용).
quote.to.prevent.word.splitting.or.split.robustly.with.mapfile.or.read.a=단어 분할을 방지하려면 따옴표로 묶거나 mapfile 또는 read -a로 강력하게 분할하세요.
is.a.subshell.did.you.mean.a.test.expression=(..)는 하위 셸입니다. 테스트 표현식인 [ .. ]을(를) 의도하셨나요?
globs.are.ignored.in.except.right.of.use.a.loop=\=/\!\=의 오른쪽을 제외하고 `[[ ]]`에서 glob은 무시됩니다. 루프를 사용하세요.
globs.don.t.work.as.operands.in.use.a.loop=glob는 [ ]에서 피연산자로 작동하지 않습니다. 루프를 사용하세요.
brace.expansion.doesn.t.happen.in.use.a.loop=중괄호 확장은 `[[ ]]`에서 발생하지 않습니다. 루프를 사용하세요.
brace.expansions.don.t.work.as.operands.in.use.a.loop=중괄호 확장은 [ ]에서 피연산자로 작동하지 않습니다. 루프를 사용하세요.
error.message.can.t.find.info.in.your.path=$PATH에서 정보를 찾을 수 없습니다
line.marker.run.0={0} 실행
i.do.mind.path.placeholder=신경 쓰임
display.name.shell.check=ShellCheck
