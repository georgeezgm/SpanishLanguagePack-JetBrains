language.groovy=Groovy
filetype.groovy.description=Groovy
filetype.dgm.description=Archivo descriptor del módulo de extensión Groovy
filetype.dgm.display.name=DGM
filetype.logback.description=Configuración de DSL de inicio de sesión de Groovy
filetype.logback.display.name=Groovy Logback DSL
filetype.gdsl.description=Configuración de IntelliJ Groovy DSL
filetype.gdsl.display.name=Groovy DSL
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.text=propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.description=La acción genera la propiedad Missing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.text=methodMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.description=La acción genera la propiedad Missing()
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.text=es igual a() y hashCode()
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.description=La acción ahora genera iguales y hashCode.
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.text=Captadores y definidores
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.description=crear captador
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.text=Setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.description=crear colocador
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.text=Getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.description=crear captador
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.text=constructor
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.description=creación del constructor
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.text=to_String()
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.description=Crea un método toString().
action.ExcludeFromStubGeneration.text=Excluir de la generación de resguardos
action.ExcludeFromStubGeneration.description=No genere resguardos de Java para archivos Groovy en el momento de la compilación
action.DumpGroovyControlFlowAction.text=Volcado de flujo de control maravilloso
action.ConvertToCompileStatic.text=Convertir a @CompileStatic
action.ConvertToCompileStatic.description=Convierta archivos Groovy a @CompileStatic
action.ConvertGroovyToJava.text=Convertir a Java
action.ConvertGroovyToJava.description=Convertir archivos Groovy a Java
action.Groovy.NewScript.text=Guión maravilloso
action.Groovy.NewScript.description=Crea un nuevo script Groovy
action.Groovy.NewClass.text=Clase maravillosa
action.Groovy.NewClass.description=Crea una nueva clase Groovy
action.Groovy.CheckResources.Rebuild.text=Reconstruir recurso (_R)
action.Groovy.CheckResources.Rebuild.description=Ejecute el compilador para todos los archivos Groovy en la raíz de recursos para verificar si hay problemas de compilación
action.Groovy.CheckResources.Make.text=Construcción de recursos (_B)
action.Groovy.CheckResources.Make.description=Ejecute el compilador incremental en archivos Groovy en la raíz de recursos para verificar si hay problemas de compilación.
group.Groovy.CheckResources.text=Recursos maravillosos (_O)
group.Groovy.CheckResources.description=Ejecute el compilador para todos los archivos Groovy en la raíz de recursos para verificar si hay problemas de compilación
file.template.group.title.groovy=Groovy
groovy.term.class=clase
groovy.term.interface=interfaz
groovy.term.trait=característica
groovy.term.enum=enumeración
groovy.term.annotation=anotación
groovy.term.method=método
groovy.term.field=campo
groovy.term.property=propiedades
groovy.term.parameter=parámetro
groovy.term.variable=variable local
groovy.term.binding=Variables de enlace de script
groovy.term.label=etiqueta
groovy.term.closure=cierre
groovy.term.expression=expresión
new.class.action.text=Clase maravillosa
new.class.action.description=Crea una nueva clase Groovy
new.class.dialog.title=Nueva clase Groovy
new.class.list.item.class=clase
new.class.list.item.interface=interfaz
new.class.list.item.trait=característica
new.class.list.item.enum=enumeración
new.class.list.item.annotation=anotación
invalid.qualified.name=No es un nombre válido y completo de Groovy
new.script.action.text=Guión maravilloso
new.script.action.description=Crea un nuevo script Groovy
new.script.dialog.title=Ingrese un nuevo nombre de script Groovy
new.script.list.item.script=Guión maravilloso
new.script.list.item.script.dsl=Guión GroovyDSL
new.gant.script.dialog.title=Nuevo guión de Gant
new.gant.script.dialog.message=Introduzca un nuevo nombre de secuencia de comandos Gant
debug.option=&Habilitar seguimiento de pila de depuración
groovy.debug.disable.specific.methods=&No entres en clases específicas de Groovy
groovy.debug.caption=Groovy
identifier.expected=Se requiere un identificador
identifier.or.block.expected=Se requiere un identificador o bloque de código.
string.end.expected=Se requiere el final de la cadena.
try.without.catch.finally=''intentar'' no contiene ''catch'' ni ''finalmente''.
expression.expected=se requiere expresión
duplicate.modifier=Controlador duplicado ''{0}''
cannot.resolve=El símbolo ''{0}'' no se puede resolver
cannot.access=El acceso a ''{0}'' excede sus permisos de acceso.
cannot.reference.non.static=No se puede hacer referencia al símbolo no estático ''{0}'' en un contexto estático.
cannot.return.from.constructor=No puedes devolver un objeto desde un constructor.
cannot.return.from.void.method=Un método que devuelve ''void'' no puede devolver un objeto.
cannot.return.type=El método que devuelve ''{1}'' no puede devolver ''{0}''
cannot.apply.method.or.closure=''{0}'' no se puede aplicar a ''{1}''
cannot.apply.method1=''{0}'' de ''{1}'' no se puede aplicar a ''{2}''
cannot.apply.constructor=El constructor ''{0}'' de ''{1}'' no se puede aplicar a ''{2}''.
cannot.apply.default.constructor=No se puede aplicar el constructor predeterminado para la clase ''{0}''.
cannot.instantiate.abstract.class=No se puede crear una instancia de la clase abstracta ''{0}''.
cannot.instantiate.interface=No se puede crear una instancia de la interfaz ''{0}''.
missing.required.named.parameter=Falta el parámetro requerido llamado ''{0}''.
loss.of.precision=Es posible que se pierda precisión de ''{0}'' a ''{1}''.
cannot.assign=''{0}'' no se puede asignar a ''{1}''.
cannot.cast=No se puede transmitir ''{0}'' a ''{1}''.
multiple.assignments.without.list.expr=No se admiten varias asignaciones sin una expresión de lista a la derecha en el modo de verificación de tipo estático.
spread.operator.is.not.available=La verificación de tipos estáticos no permite utilizar el operador de extensión como argumento.
replace.with.list.literal=Reemplace la lista con un literal.
replace.with.get.at=Reemplace con acceso al índice.
incorrect.number.of.values=El número de valores es incorrecto. Valor esperado\: {0}, Valor actual\: {1}
invalid.lvalue=El valor a sustituir es incorrecto.
duplicate.class=La clase ''{0}'' ya existe en ''{1}''.
duplicate.inner.class=Clase duplicada\: ''{0}''
script.generated.with.same.name=Hay una clase de integración generada ''{0}'' para su código de secuencia de comandos.
variable.already.defined=La variable ''{0}'' ya está definida.
field.already.defined=El campo ''{0}'' ya está definido.
create.class.family.name=crear clase
create.class.text=Crear clase {0}
create.interface.text=Crear interfaz {0}
create.annotation.text=Crear anotación {0}
constructors.are.not.allowed.in.anonymous.class=No se permiten constructores en clases anónimas.
no.such.property=La propiedad ''{0}'' no existe.
change.modifier=Hacer de ''{0}'' un {1}
change.modifier.not=Hacer ''{0}'' no {1}
change.modifier.family.name=cambiar controlador
parameter.cast.fix=Convierte el {0,número,ordinal}ésimo parámetro a {1}.
action.convert.lambda.to.closure=Convertir lambda en cierre
add.parenthesis.to.lambda.parameter.list=Agregar paréntesis a la lista de parámetros
packageLocal.visibility.presentation=visibilidad predeterminada
protected.visibility.presentation=protected
private.visibility.presentation=private
public.visibility.presentation=public
abstract.visibility.presentation=abstract
static.visibility.presentation=static
final.visibility.presentation=final
native.visibility.presentation=native
synchronized.visibility.presentation=synchronized
strictfp.visibility.presentation=strictfp
transient.visibility.presentation=transient
volatile.visibility.presentation=volatile
def.visibility.presentation=def
intention.family.name.convert.conditional.expression.to.elvis=Convertir expresión condicional a elvis
intention.family.name.replace.with.keyed.access=Reemplazar con acceso clave
intention.family.name.fix.range.class=Modificar clasificación de rango
intention.family.name.make.return.implicit=Establecer el retorno implícitamente
intention.family.name.simplify=arrasamiento
intention.family.name.remove.unnecessary.continue=Eliminar continuar innecesario
intention.family.name.remove.unnecessary.return=Eliminar devoluciones innecesarias
intention.family.name.add.parameter.cast=Agregar conversión de tipo de parámetro
intention.family.name.replace.for.each.operator=Reemplazo del operador para cada uno
intention.family.name.add.cast=Agregar conversión de tipo
intention.family.name.change.variable.type=Cambiar tipo de variable
intention.family.name.replace.with.conditional.call=Cambiar a llamada condicional
intention.family.name.collapse.conditional.expressions=Contraer expresiones condicionales
intention.family.name.remove.double.negation=eliminar doble negativo
intention.family.name.activate.dsl.descriptor=Habilitar descriptor DSL
intention.family.name.collapse.if.statement=Contraer la declaración ''si''
intention.family.name.replace.with.short.circuit.expression=Convertir a expresión de párrafo
intention.family.name.replace.something.with=Reemplace ''{0}'' con ''{1}''
intention.family.name.add.attributes.to.annotation=Agregar propiedades a las anotaciones
intention.family.name.fix.quotation=Editar cotizaciones
illegal.combination.of.modifiers=La combinación de controladores es incorrecta
illegal.combination.of.modifiers.abstract.and.final=La combinación de controladores ''abstracto'' y ''final'' no es válida
modifier.volatile.not.allowed.here=El controlador "volátil" no está permitido aquí.
modifier.transient.not.allowed.here=El controlador "transitorio" no está permitido aquí
modifier.0.not.allowed=El controlador ''{0}'' no está permitido aquí
interface.cannot.have.modifier.final=La interfaz no puede tener controlador "final"
script.method.cannot.have.modifier.abstract=El método de script no puede tener un controlador "abstracto"
script.cannot.have.modifier.native=El método de script no puede tener un controlador "nativo"
interface.must.have.no.static.method=Las interfaces no pueden tener métodos estáticos.
only.abstract.class.can.have.abstract.method=Sólo las clases abstractas pueden tener métodos abstractos.
anonymous.class.cannot.have.abstract.method=Las clases anónimas no pueden tener métodos abstractos.
illegal.combination.of.modifiers.volatile.and.final=La combinación de controladores ''abstracto'' y ''final'' no es válida
variable.cannot.be=La variable no puede tener controlador ''{0}''
remove.modifier=Eliminar ''{0}''
not.abstract.method.should.have.body=Los métodos abstractos no deben tener cuerpo.
cannot.create.class.error.text=No se puede crear la clase ''{0}''. {Uno}
cannot.create.class.error.title=No se puede crear la clase
no.class.in.file.template=Clase no encontrada en la plantilla de archivo.
Inner.methods.are.not.supported=El método interno no es compatible.
final.class.cannot.be.extended=Las clases finales no se pueden ampliar.
unsupported.inner.class.0=Las clases internas no son compatibles con Groovy {0}.
unsupported.anonymous.class.0=Groovy {0} no admite clases anónimas.
unsupported.diamonds.0=Los diamantes no son compatibles con Groovy {0}.
unsupported.command.syntax.0=La sintaxis de expresión de comando no es compatible con Groovy {0}.
unsupported.dollar.slashy.string.0=Las cadenas de barras en dólares no se admiten en Groovy {0}.
unsupported.multiline.slashy.string.0=Las cadenas de barras multilínea no se admiten en Groovy {0}.
unsupported.traits.0=El atributo no es compatible con Groovy {0}.
duplicating.named.parameter=El parámetro contiene el parámetro ''{0}'' con nombre duplicado. {Uno}
field.should.be.immutable=El campo ''{0}'' debe tener un tipo inmutable o declararse como un tipo inmutable mediante @ImmutableOptions.
immutable.options.property.not.exist=La propiedad ''{0}'' no existe.
explicit.includes.and.excludes=Solo se debe proporcionar uno de "incluye" y "excluye"
require.closure.as.attribute.value=Necesito un cierre como valor de la propiedad.
initializers.are.forbidden.with.defaults=Deshabilitar los ''valores predeterminados'' en @TupleConstructor significa que los valores predeterminados están prohibidos
super.is.not.allowed.in.pre.with.call.super=Las súper llamadas no están permitidas en ''pre'' con ''callSuper'' habilitado
illegal.default.modifier=El modificador ''predeterminado'' tiene significado sólo dentro de un método de interfaz
illegal.default.modifier.fix=Eliminar el controlador "predeterminado"
default.modifier.in.old.versions=El controlador "predeterminado" está disponible en Groovy 3.0 y posteriores.
unsupported.do.while.statement=''do while'' no es compatible con la versión actual.
unsupported.tuple.declaration.in.for=La declaración de tupla dentro de la inicialización ''for'' no es compatible con la versión actual
unsupported.multiple.variables.in.for=En la versión actual no se admiten múltiples variables dentro de la inicialización ''para''.
unsupported.expression.list.in.for.update=En la versión actual no se admiten varias expresiones dentro de la actualización ''para''.
unsupported.resource.list=''try'' no es compatible con la versión actual.
unsupported.array.initializers=Los inicializadores de matriz no son compatibles con la versión actual.
operator.is.not.supported.in=El operador ''{0}'' no es compatible con la versión actual.
unsupported.negated.in=La ''entrada'' negada no es compatible con la versión actual.
unsupported.negated.instanceof=La ''instancia de'' negada no es compatible con la versión actual.
unsupported.elvis.assignment=La asignación de Elvis no es compatible con la versión actual.
unsupported.safe.index.access=El acceso seguro al índice no es compatible con la versión actual.
unsupported.lambda=Lambda no es compatible con la versión actual.
unsupported.type.annotations=Las anotaciones de tipo no son compatibles con la versión actual.
unsupported.tuple.application.initializer=El inicializador de aplicaciones no es compatible con la versión actual
illegal.single.argument.lambda=Se puede utilizar un único argumento como argumento en la parte derecha de una expresión de asignación o dentro de una llamada a un método.
method.is.not.implemented=El método ''{0}'' no está implementado.
change.implements.and.extends.classes=Normalizar extiende e implementa listas
fix.package.name=Modificar el nombre del paquete
checkbox.delegate.via.overloading.method=Delegación mediante métodos sobrecargados
checkbox.ignore.conditional.operators=Ignorar operadores condicionales
checkbox.ignore.obscure.operators=Ignorar operadores ambiguos
checkbox.ignore.double.checked.locking.on.volatile.fields=Evite bloqueos de doble verificación en campos volátiles
checkbox.inspect.anonymous.closures=Comprobación de cierre anónimo
checkbox.only.warn.if.loop.empty=Advertir sólo si el bucle está vacío
add.dynamic.property=Agregar propiedad dinámica ''{0}''
duplicate.element.in.the.map=Elemento duplicado ''{0}'' en el mapa
dynamic.tool.window.id=números dinámicos
create.field.from.usage.family.name=Crea campos desde donde los usas
create.field.from.usage=Crear campo ''{0}''
create.method.from.usage.family.name=Crear método en el lugar de uso
create.method.from.usage=Crear método ''{0}''.
create.variable.from.usage.family.name=Crear variable en el punto de uso
create.variable.from.usage=Crear variable ''{0}''
create.parameter.from.usage.family.name=Crear parámetros en el punto de uso.
create.parameter.from.usage=Crear parámetro ''{0}''
add.dynamic.element=Agregar elementos dinámicos
add.dynamic.method=Agregar método dinámico
add.dynamic.method.0=Agregar método dinámico ''{0}''
dynamic.type=categoría
dynamic.name=Nombre
dynamic.properties.table.name=argumentos del método
dynamic.method.return.type=Tipo de devolución (&T)\:
dynamic.method.property.type=Tipo de propiedad (&T)\:
are.you.sure.to.delete.dynamic.property=¿Está seguro de que desea eliminar ''{0}''?
dynamic.property.deletion=Eliminar propiedades dinámicas
are.you.sure.to.delete.elements=¿Está seguro de que desea eliminar el elemento ''{0}''''?
dynamic.element.deletion=Eliminar elementos dinámicos
tuple.cant.be.placed.in.class=No se permiten asignaciones múltiples a campos
is.not.enclosing.class=''{0}'' no es una clase adjunta
package.definition.cannot.have.modifiers=Una definición de paquete no puede tener un controlador
import.statement.cannot.have.modifiers=las declaraciones de importación no pueden tener controladores
undefined.label=Etiqueta no definida ''{0}''
continue.outside.loop=La declaración de continuación sólo se permite dentro de un bucle.
break.outside.loop.or.switch=Las declaraciones de interrupción solo se permiten dentro de bucles o conmutadores.
label.already.used=La etiqueta ''{0}'' ya está en uso.
break.outside.loop=Las declaraciones de interrupción con etiquetas con nombre solo se permiten dentro de bucles.
Constructor=constructor
Getter=Getter
Setter=Setter
not.allowed.modifier.in.for.in=El controlador ''{0}'' no está permitido aquí
property.name.expected=El nombre de la propiedad es obligatorio
wildcards.are.not.allowed.in.extends.list=Un supertipo no puede especificar un tipo comodín.
method.does.not.override.super=El método no anula un método en la clase principal.
method.duplicate=El método con firma {0} ya está definido en la clase ''{1}''
ambiguous.code.block=Bloque de código ambiguo
cyclic.inheritance.involving.0=Herencia circular relacionada con ''{0}''
there.is.no.default.constructor.available.in.class.0=No hay ningún constructor predeterminado disponible para ''{0}''.
groovy.library.is.not.configured.for.module=Groovy SDK no está configurado para el módulo ''{0}''
configure.groovy.library=Configurar el SDK de Groovy...
create.instance.of.built-in.type=Crear instancias de un tipo primitivo
incorrect.variable.name=Nombre de variable no válido
no.interface.expected.here=No se necesita interfaz aquí
no.class.expected.here=Aquí no se necesitan clases.
invoke.completion.second.time.to.show.skipped.methods=Segunda llamada para completar el código para mostrar los métodos omitidos
groovy.file.extension.is.not.mapped.to.groovy.file.type=*El archivo .groovy está asignado a ''{0}''\n''{0}'' no es una anotación
method.call.is.ambiguous=La llamada al método es ambigua.
operator.call.is.ambiguous=La llamada al operador es ambigua.
duplicated.named.parameter=Se encontró un parámetro con un nombre duplicado ''{0}''.
no.super.classes.found=No se encontró ninguna clase principal.
no.super.method.found=Método principal no encontrado.
cannot.assign.string.to.enum.0=No se puede asignar la cadena a la enumeración ''{0}''.
cannot.find.enum.constant.0.in.enum.1=La constante de enumeración ''{0}'' no se encuentra en la enumeración ''{1}''.
recursive.constructor.invocation=Llamada de constructor recursivo
the.usage.of.a.map.entry.expression.to.initialize.an.enum.is.currently.not.supported=Actualmente no se admite el uso de expresiones de entrada de mapa para inicializar enumeraciones.
class.definition.is.not.expected.here=Aquí no se necesita ninguna definición de clase.
move.class.0.from.method=Mueva ''{0}'' a la ubicación correcta
move.class.from.method.family.name=Solución rápida para llevarlo a la ubicación correcta
cannot.infer.argument.types=No se pudo inferir el tipo de argumento.
Equals=igual
default.initializers.are.not.allowed.in.abstract.method=Los inicializadores predeterminados no están permitidos en métodos abstractos.
groovy.does.not.support.constructor.type.arguments=Groovy no admite argumentos de tipo constructor.
illegal.escape.character.in.string.literal=Carácter de escape no válido en literal de cadena
method.with.type.parameters.should.have.return.type=Los métodos con parámetros de tipo deben tener un tipo de retorno
primitive.type.parameters.are.not.allowed=Los parámetros de tipo predeterminados no están permitidos en la lista de parámetros de tipo.
primitive.bound.types.are.not.allowed=No se aceptan tipos de encuadernación predeterminados.
ellipsis.type.is.not.allowed.here=El tipo de puntos suspensivos no está permitido aquí.
method.0.is.too.complex.too.analyze=El método ''{0}'' es demasiado complejo para analizarlo.\nEl cierre es demasiado complejo para analizarlo.\n''{0}'' está en desuso
wrong.number.of.type.arguments=Número no válido de argumentos de tipo\: {0}; Requiere: {1}
type.argument.0.is.not.in.its.bound.should.extend.1=El parámetro de tipo ''{0}'' no está dentro de sus límites y debe extenderse a ''{1}''.
catch.statement.parameter.type.should.be.a.subclass.of.throwable=El tipo de parámetro de la declaración catch debe ser una subclase de Throwable.
exception.0.has.already.been.caught=La excepción ''{0}'' ya ha sido detectada
unnecessary.type=La excepción ''{0}'' no es necesaria. ''{1}'' ya ha sido declarado.
create.enum=Crear enumeración {0}
create.trait=Crear atributo {0}
annotation.field.can.only.be.used.within.a.script.body=La anotación @Field solo se puede utilizar dentro del cuerpo del script.
annotation.field.can.only.be.used.within.a.script=La anotación @Field solo se puede utilizar dentro de scripts.
return.type.is.incompatible=El tipo de devolución de {0} en {1} es incompatible con {3} en {2}
anonymous.class.derived.from.0=Clase anónima derivada de {0}
throws.clause.is.not.allowed.in.at.interface=La cláusula ''throws'' no está permitida en los miembros @interface
at.interface.0.does.not.contain.attribute=@interface ''{0}'' no tiene la propiedad ''{1}''.
duplicate.attribute=atributo duplicado
missed.attributes=Propiedad faltante\: {0}
unexpected.attribute.type.0=Tipo de propiedad inesperado\: ''{0}''
annotation.field.should.have.type.declaration=Los campos dentro de una anotación deben tener una declaración de tipo.
interface.members.are.not.allowed.to.be=El miembro de la interfaz no puede ser {0}.
abstract.methods.must.not.have.body=Los métodos abstractos no deben tener cuerpo.
method.has.incorrect.modifier.volatile=El controlador ''volatile'' en el método no es válido
native.methods.cannot.have.body=Los métodos nativos no pueden tener cuerpo.
top.level.class.may.not.have.private.modifier=Las clases de nivel superior no pueden tener modificadores "privados"
top.level.class.may.not.have.protected.modifier=Las clases de nivel superior no pueden tener modificadores "protegidos"
property.missing=propertyMissing
attribute.name.expected=El nombre de la propiedad es obligatorio.
java.style.for.each.statement.requires.a.type.declaration=Las declaraciones for-each de estilo Java requieren una declaración de tipo.
super.cannot.be.used.in.static.context=''super'' no se puede utilizar en un contexto estático.
qualified.0.is.allowed.only.in.nested.or.inner.classes=El {0} calificado solo se permite en clases anidadas/internas.
groovy.file.0=Archivo maravilloso ''{0}''
type.argument.list.is.not.allowed.here=Aquí no se permiten listas de argumentos de tipo.
initializers.are.not.allowed.in.interface=Inicializador no permitido en la interfaz.
initializer.cannot.have.annotations=Los inicializadores no pueden tener anotaciones.
initializer.cannot.be.0=El inicializador no puede ser {0}.
constructors.are.not.allowed.in.interface=Constructor no permitido en la interfaz.
type.parameters.are.unexpected=Parámetro de tipo inesperado
constructors.cannot.have.return.type=El elemento de tipo ''return'' no está permitido en el constructor
constructor.cannot.have.static.modifier=Los constructores no pueden ser estáticos.
annotation.types.may.not.have.extends.clause=Los tipos de anotaciones no pueden tener una cláusula "extiende".
annotation.types.may.not.have.implements.clause=Los tipos de anotaciones no pueden tener una cláusula de "implementos".
no.implements.clause.allowed.for.interface=Las interfaces no pueden tener una cláusula de "implementos".
enums.may.not.have.extends.clause=Las enumeraciones no pueden tener una cláusula "extiende".
method.0.cannot.override.method.1.in.2.overridden.method.is.final=El método ''{0}'' no puede anular el método ''{1}'' en ''{2}'' y el método anulado es final.
method.0.cannot.have.weaker.access.privileges.1.than.2.in.3.4=El método ''{0}'' tiene un acceso más débil (''{1}'') que ''{2}'' en ''{3}'' (''{4}''). tenerlo.
tuple.declaration.should.end.with.def.modifier=Las declaraciones de tuplas deben terminar con el modificador ''def''
injection.should.not.contain.line.feeds=Las inserciones de GString no deben incluir avances de línea.
collection.literal.contains.named.argument.and.expression.items=Los literales de colección contienen argumentos con nombre y expresión.
annotation.collector.cannot.have.attributes=Los tipos de anotaciones agregados con @AnnotationCollector no pueden tener propiedades
annotation.type.cannot.be.inner=Los tipos de anotaciones no pueden ser internos.
named.arguments.are.not.allowed.inside.index.operations=Los argumentos con nombre no están permitidos dentro de una operación de índice.
expected.0.to.be.inline.constant=''{0}'' debe ser una constante en línea.
cannot.assign.a.value.to.final.field.0=No se puede asignar un valor al campo final ''{0}''.
cannot.assign.a.value.to.final.parameter.0=No se puede asignar un valor al parámetro final ''{0}''.
variable.0.might.not.have.been.initialized=Es posible que la variable ''{0}'' no se haya inicializado
doc.end.expected=''*/'' se requiere
mixing.private.and.public.protected.methods.of.the.same.name=Tiene una combinación de métodos privados y públicos/protegidos con el mismo nombre.
explicit.constructors.are.not.allowed.in.immutable.class=No se permiten constructores explícitos en las clases @Immutable.
repetitive.method.name.0=El nombre del método ''{0}'' se repite.
declared.type.0.have.to.extend.script=El tipo declarado ''{0}'' no extiende la clase ''groovy.lang.Script''.
base.script.annotation.is.allowed.only.inside.scripts=La anotación @BaseScript solo se puede utilizar dentro de scripts.
delegate.annotation.is.only.for.methods.without.arguments=La anotación @Delegate se puede aplicar a métodos con argumentos.
builder.annotation.not.support.super.for.simple.strategy=La propiedad de anotación ''includeSuperProperties'' no se admite en groovy.transform.builder.SimpleStrategy.
0.expressions.on.trait.fields.properties.are.not.supported.in.traits=La expresión {0} en un campo de propiedad/propiedad no se admite en propiedades.
only.traits.expected.here=Aquí solo se necesitan las características.
anonymous.classes.cannot.be.created.from.traits=No se pueden crear clases anónimas a partir de atributos.
trait.method.cannot.be.protected=Los métodos de rasgos no se pueden proteger.
non.static.classes.not.allowed=No se permiten clases internas no estáticas en los rasgos.
selfType.class.does.not.inherit=@SelfType\: La clase ''{0}'' no hereda de ''{1}''.
illegal.type.void=Tipo no válido\: ''void''
illegal.method.name=Había un carácter no válido en el nombre del método. {0}
indexed.property.is.applicable.to.properties.only=@IndexedProperty no se puede aplicar solo a propiedades
listener.list.field.must.have.a.generic.collection.type=El campo @ListenerList requiere un tipo de colección genérico
listener.list.field.with.generic.wildcards.not.supported=No se admite el uso de comodines genéricos en los campos @ListenerList
synchronized.not.allowed.on.abstract.method=@Synchronized no está permitido en métodos abstractos
lock.field.0.must.be.static=El campo de bloqueo ''{0}'' debe ser estático
lock.field.0.must.not.be.static=El campo de bloqueo ''{0}'' no puede ser estático
lock.field.0.not.found=Campo de roca ''{0}'' no encontrado
select.module.action.text=Seleccionar módulo...
select.module.action.description=Seleccionar módulos para usar el classpath
select.module.popup.title=Usar classpath del módulo
inspection.annotations=Validación de anotaciones
inspection.assignments=cuestiones de admisión a la universidad
inspection.bugs=Errores que pueden ocurrir
inspection.confusing=La sintaxis del código puede resultar confusa.
inspection.control.flow=controlar problemas de flujo
inspection.data.flow=flujo de datos
inspection.error.handling=Manejo de errores
inspection.gpath=GPath
inspection.naming=Reglas de creación de nombres
inspection.method.metrics=métricas del método
inspection.redundancy=declaración de despido
inspection.threading=problema de roscado
inspection.validity=Problema de validez
inspection.style=estilo
inspection.other=Otros
inspection.display.name.result.of.assignment.used=Usar resultados de sustitución
inspection.display.name.assignment.can.be.operator.assignment=Asignación que puede ser reemplazada por asignación de operador
inspection.display.name.delegates.to=@DelegatesPara comprobar
inspection.display.name.unresolved.access=Accediendo a expresiones no resueltas
inspection.display.name.untyped.access=Accediendo a expresiones sin escribir
inspection.display.name.list.set.can.be.keyed.access=La llamada List.set puede ser un acceso clave
inspection.display.name.list.get.can.be.keyed.access=La llamada List.get puede ser un acceso clave
inspection.display.name.map.put.can.be.keyed.access=La llamada a Map.put puede ser un acceso clave
inspection.display.name.map.get.can.be.keyed.access=La llamada Map.get puede ser un acceso clave
inspection.display.name.parameter.naming.convention=Convención de nomenclatura de parámetros de método
inspection.display.name.constant.naming.convention=Convenciones de nomenclatura constantes
inspection.display.name.instance.variable.naming.convention=Convenciones de nomenclatura de variables de instancia
inspection.display.name.instance.method.naming.convention=Convención de nomenclatura de métodos de instancia
inspection.display.name.static.variable.naming.convention=convención de nomenclatura de variables estáticas
inspection.display.name.static.method.naming.convention=convención de nomenclatura de métodos estáticos
inspection.display.name.local.variable.naming.convention=Convenciones de nomenclatura de variables locales
inspection.display.name.class.naming.convention=Convención de nomenclatura de clases
inspection.display.name.groovydoc.check=Problema con GroovyDoc
inspection.display.name.constructor.named.arguments=Argumentos con nombre en la llamada al constructor
inspection.display.name.result.of.object.allocation.ignored=Se ignora el resultado de la asignación de objetos.
inspection.display.name.divide.by.zero=Dividir entre cero
inspection.display.name.infinite.recursion=recursividad infinita
inspection.display.name.infinite.loop.statement=declaración de bucle infinito
inspection.display.name.non.short.circuit.boolean=booleano sin cortocircuito
inspection.display.name.duplicate.switch.branch=redundancia de caja de interruptor
inspection.display.name.gstring.key=Clave del mapa GString
inspection.display.name.octal.integer=entero octal
inspection.display.name.overly.complex.boolean.expression=Expresión booleana demasiado compleja
inspection.display.name.clashing.trait.methods=conflicto de método de rasgo
inspection.display.name.overly.complex.arithmetic.expression=Expresiones aritméticas demasiado complejas
inspection.display.name.double.negation=doble negativa
inspection.display.name.pointless.arithmetic=expresiones aritméticas sin sentido
inspection.display.name.empty.statement.body=Frases con cuerpo vacío
inspection.display.name.reassigned.in.closure.local.var=La variable local ha sido reasignada a una clase de cierre o anónima
inspection.display.name.result.of.increment.or.decrement.used=Resultado del incremento o decremento utilizado
inspection.display.name.negated.if=Expresión de condición negada si
inspection.display.name.in.argument.check=Tipo de argumento ''in'' incompatible
inspection.display.name.negated.conditional=Expresión condicional negada
inspection.display.name.nested.conditional=Expresiones condicionales anidadas
inspection.display.name.conditional=expresión condicional
inspection.display.name.nested.switch=Declaración de cambio negado
inspection.display.name.multiple.return.points.per.method=Métodos con múltiples puntos de retorno.
inspection.display.name.method.with.more.than.three.negations=Métodos con 4 o más negaciones.
inspection.display.name.overly.nested.method=Métodos demasiado anidados
inspection.display.name.overly.long.method=método demasiado largo
inspection.display.name.overly.complex.method=método demasiado complejo
inspection.display.name.method.parameter.count=Método con demasiados parámetros.
inspection.display.name.while.loop.spins.on.field=mientras el bucle gira en el campo
inspection.display.name.unsynchronized.method.overrides.synchronized.method=Un método asincronizado anula un método sincronizado.
inspection.display.name.synchronization.on.variable.initialized.with.literal=Sincronización de variables inicializadas con literales
inspection.display.name.synchronization.on.non.final.field=Sincronización de campos no finales
inspection.display.name.wait.while.not.synchronized=''wait()'' mientras no está sincronizado
inspection.display.name.wait.call.not.in.loop=''espera()'' no en bucle
inspection.display.name.notify.while.not.synchronized=''esperar()'' o ''notificar()'' mientras no esté sincronizado
inspection.display.name.system.run.finalizers.on.exit=Llame a System.runFinalizersOnExit()
inspection.display.name.thread.stop.suspend.resume=Llamar a Thread.stop(), Thread.suspend() o Thread.resume()
inspection.display.name.nested.synchronized.statement=Declaraciones anidadas ''sincronizadas''
inspection.display.name.synchronized.method=método sincronizado
inspection.display.name.synchronization.on.this=''esta'' sincronización
inspection.display.name.empty.sync.block=Bloque ''sincronizado'' vacío
inspection.display.name.busy.wait=ocupado esperando
inspection.display.name.public.field.accessed.in.synchronized.context=Acceder a campos no privados en un contexto sincronizado
inspection.display.name.unconditional.wait=Llamada de ''espera'' incondicional
inspection.display.name.double.checked.locking=Bloqueo de doble control
inspection.display.name.access.to.static.field.locked.on.instance=El acceso a campos estáticos está bloqueado en los datos de la instancia.
inspection.display.name.change.to.method=cambiar al método
inspection.display.name.change.to.operator=cambiar de operador
inspection.display.name.unnecessary.alias=Alias de importación innecesarios
inspection.display.name.unnecessary.semicolon=Punto y coma innecesario
inspection.display.name.unnecessary.public.modifier=''Público'' innecesario
inspection.display.name.unnecessary.def.modifier=''definición'' innecesaria
inspection.display.name.java.style.properties.invocation=Acceso a propiedades estilo Java
inspection.display.name.trivial.if=Declaraciones ''si'' duplicadas
inspection.display.name.constant.if.statement=declaración si constante
inspection.display.name.constant.conditional=expresión condicional constante
inspection.display.name.trivial.conditional=Expresión condicional duplicada
inspection.display.name.return.from.closure.can.be.implicit=La declaración ''return'' puede ser implícita
inspection.display.name.switch.statement.with.no.default=declaración de cambio sin caso predeterminado
inspection.display.name.final.variable.access=acceso final a variables
inspection.display.name.unnecessary.return=Declaración de "devolución" innecesaria
inspection.display.name.unnecessary.continue=Declaración "continuar" innecesaria
inspection.display.name.fallthrough=Fallo de la declaración de cambio
inspection.display.name.if.statement.with.too.many.branches=Declaración If con demasiadas ramas
inspection.display.name.if.statement.with.identical.branches=Declaración If con ramas idénticas
inspection.display.name.conditional.can.be.conditional.call=La expresión condicional puede ser una llamada condicional
inspection.display.name.conditional.can.be.elvis=La expresión condicional puede ser elvis.
inspection.display.name.conditional.with.identical.branches=Expresiones condicionales con la misma rama.
inspection.display.name.loop.statement.that.doesnt.loop=Declaración de bucle que no ejecuta un bucle
inspection.display.name.unreachable.statement=sintaxis inalcanzable
inspection.display.name.continue=continuar declaración
inspection.display.name.break=declaración de ruptura
inspection.display.name.unused.catch.parameter=Parámetro de captura no utilizado
inspection.display.name.empty.try.block=bloque ''intentar'' vacío
inspection.display.name.annotation.references.unknown.identifier=Identificador desconocido en las propiedades ''incluye'' y ''excluye''
inspection.display.name.unresolved.labels.in.named.variant=Etiquetas no resueltas después de la conversión @NamedVariant/@NamedParam/@NamedDelegate
inspection.display.name.empty.finally.block=bloque vacío ''finalmente''
inspection.display.name.empty.catch.block=Bloque ''catch'' vacío
inspection.display.name.throw.from.finally.block=Bloque ''tirar finalmente''
inspection.display.name.return.from.finally.block=''regresar' en el bloque finalmente''
inspection.display.name.method.may.be.static=Los métodos pueden ser estáticos.
inspection.display.name.continue.or.break.from.finally.block=''continuar'' o ''interrumpir dentro de un bloque finalmente''
inspection.display.name.unchecked.assignment.of.member.of.raw.type=Asignación no validada en miembro de tipo primitivo
inspection.display.name.silly.assignment=sustitución incorrecta
inspection.display.name.nested.assignment=asignación anidada
inspection.display.name.assignment.to.method.parameter=Asignación al parámetro del método
inspection.display.name.assignment.to.for.loop.parameter=Asignación al parámetro de bucle for
inspection.display.name.assignability.check=Asignación de tipo incompatible
inspection.display.name.type.customizer=Tipo de verificación del personalizador
inspection.display.name.unused.declaration=declaración obsoleta
inspection.display.name.second.unsafe.call=Segunda llamada insegura
inspection.display.name.unused.assignment=Tarea no utilizada
inspection.display.name.unused.inc.dec=Incremento o decremento no utilizado
inspection.display.name.unassigned.access=La variable no está asignada
inspection.display.name.no.return=sentencia devuelta faltante
inspection.display.name.clashing.getters=conflicto getter
inspection.display.name.package.mismatch=paquete no coincide
inspection.display.name.deprecated.api.usage=Compruebe si hay API obsoletas
inspection.display.name.unnecessary.qualified.reference=Referencias totalmente calificadas innecesarias
inspection.display.name.pointless.boolean=expresión booleana sin sentido
inspection.display.name.access.to.inaccessible.element=Acceder a elementos inaccesibles
inspection.display.name.incorrect.range.argument=Argumento de rango no válido
inspection.display.name.new.instance.of.singleton=Se agregó una nueva instancia de la clase con la anotación @groovy.lang.Singleton.
inspection.display.name.check.labeled.statement=Comprobación de sintaxis etiquetada
inspection.display.name.variable.can.be.final=Las variables pueden ser finales.
inspection.display.name.equals.between.inconvertible.types=''es igual a()'' entre objetos de tipos no convertibles
inspection.display.name.singleton.constructor=@Constructor Singleton
inspection.display.name.implicit.null.argument=argumento nulo implícito
inspection.display.name.string.style.violation=Violación del estilo de cadena
inspection.message.access.to.static.field.locked.on.instance.data=El acceso al campo estático <code>\#ref</code> está bloqueado en los datos de instancia \#loc
inspection.message.assignment.replaceable.with.operator.assignment=<code>\#ref</code> se puede simplificar a ''{0}'' \#loc
inspection.message.assignment.to.for.loop.parameter=Asignación al parámetro de bucle for ''\#ref'' \#loc
inspection.message.assignment.to.method.parameter=Asignación al parámetro del método ''\#ref'' \#loc
inspection.message.ref.statement=\#ref declaración \#loc
inspection.message.call.to.thread.ref.in.a.loop=La llamada a <code>Thread.\#ref()</code> dentro del bucle puede estar ocupada esperando \#loc
inspection.message.conditional.expression.can.be.call=Una expresión condicional puede ser una llamada \#loc
inspection.message.conditional.expression.can.be.elvis=La expresión condicional puede ser elvis \#loc
inspection.message.conditional.expression=Expresión condicional \#loc
inspection.message.conditional.expression.with.identical.branches=Expresión condicional \#loc con la misma rama
inspection.message.ref.can.be.simplified=''\#ref'' se puede simplificar a \#loc
inspection.message.ref.statement.can.be.simplified=La declaración \#ref se puede simplificar a \#loc
inspection.message.constant.name.ref.too.short=El nombre de la constante ''\#ref'' es demasiado corto
inspection.message.constant.name.ref.too.long=El nombre de la constante ''\#ref'' es demasiado largo
inspection.message.constant.name.ref.doesnt.match.regex=El nombre de la constante ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
inspection.message.ref.inside.finally.block=''\#ref'' \#loc en el bloque ''finalmente''
inspection.message.divide.by.zero=Dividir por cero \#loc
inspection.message.double.checked.locking=Cerradura de doble verificación \#loc
inspection.message.double.negation.ref=Doble negación \#ref \#loc
inspection.message.duplicate.switch.case.ref=Caja de interruptor duplicada ''\#ref'' \#loc
inspection.message.empty.ref.block=Bloque ''\#ref'' vacío \#loc
inspection.message.ref.statement.has.empty.branch=La rama de la declaración ''\#ref'' está vacía
inspection.message.ref.statement.has.empty.body=El cuerpo de la declaración ''\#ref'' está vacío
inspection.message.fallthrough.in.switch.statement=Fallo de la declaración de cambio \#loc
inspection.message.gstring.used.as.maps.key=GString se usó como clave de mapa \#loc
inspection.message.ref.statement.cannot.complete.without.throwing.exception=La declaración <code>\#ref</code> no se completará sin generar una excepción \#loc
inspection.message.code.ref.code.recurses.infinitely.can.only.complete.by.throwing.exception=<code>\#ref</code> se repite infinitamente y debe generar una excepción para completar \#loc
inspection.message.instance.method.name.ref.too.short=El nombre del método de instancia ''\#ref'' es demasiado corto
inspection.message.instance.method.name.ref.too.long=El nombre del método de instancia ''\#ref'' es demasiado largo
inspection.message.instance.method.name.ref.doesnt.match.regex=El nombre del método de instancia ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
inspection.message.instance.variable.name.ref.too.short=El nombre de la variable de instancia ''\#ref'' es demasiado corto
inspection.message.instance.variable.name.ref.too.long=El nombre de la variable de instancia ''\#ref'' es demasiado largo
inspection.message.couldnt.find.property.field.with.this.name=No se puede encontrar el marco para la propiedad o campo con este nombre \#loc
inspection.message.instance.variable.name.ref.doesn.t.match.regex=El nombre de la variable de instancia ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
inspection.message.call.to.ref.can.be.keyed.access=La llamada ''\#ref'' puede ser una clave de acceso \#loc
inspection.message.ref.statement.with.identical.branches=Declaración ''\#ref'' con la misma rama \#loc
inspection.message.ref.statement.with.too.many.branches=La declaración ''\#ref'' tiene demasiadas ramas ({0}) \#loc
inspection.message.local.variable.name.ref.too.short=El nombre de la variable local ''\#ref'' es demasiado corto
inspection.message.local.variable.name.ref.too.long=El nombre de la variable local ''\#ref'' es demasiado largo
inspection.message.local.variable.name.ref.doesnt.match.regex=El nombre de la variable local ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
inspection.message.code.ref.code.statement.doesnt.loop=La declaración <code>\#ref</code> no se repite en \#loc
inspection.message.method.ref.contains.too.many.parameters.0.1=El módulo ''\#ref'' tiene demasiados parámetros ({0}>{1})
inspection.message.method.ref.has.too.many.negations=Demasiadas negaciones en el método ''\#ref'' ({0}>3)
inspection.message.ref.has.0.return.points=<code>\#ref</code> tiene {0} puntos de retorno \#loc
inspection.message.negated.conditional.expression=Expresión condicional negada \#loc
inspection.message.negated.if.condition.expression=Negado si la expresión de condición \#loc
inspection.message.nested.assignment.expression=Asignación anidada \#loc
inspection.message.nested.conditional.expression=Expresión condicional anidada \#loc
inspection.message.nested.ref.statement=Declaraciones ''\#ref'' anidadas \#loc
inspection.message.non.short.circuit.boolean.expression=Expresión booleana sin cortocircuito \#loc
inspection.message.call.to.ref.outside.synchronized.context=Llamar a ''\#ref'' fuera del contexto sincronizado \#loc
inspection.message.octal.integer.ref=entero octal \#ref \#loc
inspection.message.overly.complex.arithmetic.expression=Expresión aritmética demasiado compleja \#loc
inspection.message.overly.complex.boolean.expression=Expresión booleana demasiado compleja \#loc
inspection.message.method.ref.overly.complex.cyclomatic.complexity=El método ''\#ref'' es demasiado complejo (complejidad ciclomática \={0}>{1})
inspection.message.method.ref.too.long.statement.count=El método ''\#ref'' es demasiado largo (recuento de sintaxis \={0}>{1}})
inspection.message.method.ref.overly.nested.nesting.depth=El método ''\#ref'' está demasiado anidado (profundidad de anidamiento \={0}>{1})
inspection.message.method.parameter.name.ref.too.short=El nombre del parámetro del método ''\#ref'' es demasiado corto
inspection.message.method.parameter.name.ref.too.long=El nombre del parámetro del método ''\#ref'' es demasiado largo
inspection.message.method.parameter.name.ref.doesnt.match.regex=El nombre del parámetro del método ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
inspection.message.non.private.field.accessed.in.synchronized.context=Se accede al campo no privado <code>\#ref</code> en el contexto sincronizado \#loc
inspection.message.nested.assignment=El resultado de la expresión de asignación se utiliza \#loc
inspection.message.result.increment.or.decrement.expression.used=Resultado de la expresión de incremento o decremento utilizada \#loc
inspection.message.result.of.new.ref.is.ignored=<code>Resultado del nuevo \#ref{0}</code> ignorado \#loc
inspection.message.ref.statement.at.end.closure.can.be.made.implicit=Puede hacer que la declaración \#ref al final del cierre sea implícita \#loc
inspection.message.silly.assignment=Asignación no válida \#loc
inspection.message.static.method.name.ref.too.short=El nombre del método estático ''\#ref'' es demasiado corto
inspection.message.static.method.name.ref.too.long=El nombre del método estático ''\#ref'' es demasiado largo
inspection.message.static.method.name.ref.doesnt.match.regex=El nombre del método estático ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
inspection.message.static.variable.name.ref.too.short=El nombre de la variable estática ''\#ref'' es demasiado corto
inspection.message.label.name.ref.not.supported.by.0={0} no admite el nombre de etiqueta ''\#ref''
inspection.message.static.variable.name.ref.too.long=El nombre de la variable estática ''\#ref'' es demasiado largo
inspection.message.static.variable.name.ref.doesnt.match.regex=El nombre de la variable estática ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
inspection.message.property.0.is.final=La propiedad ''{0}'' es \#loc final
inspection.message.ref.statement.with.no.default.branch=\#ref declaración sin rama predeterminada \#loc
inspection.message.synchronization.on.non.final.field.ref=El campo no final ''\#ref'' sincroniza \#loc
inspection.message.synchronization.on.ref=\ ''\#ref'' Sincronizar \#loc
inspection.message.synchronization.on.variable.ref.which.was.initialized.with.literal=Sincronizar la variable ''\#ref'' inicializada con el literal \#loc
inspection.message.synchronized.method.ref=Método sincronizado ''\#ref'' \#loc
inspection.message.call.to.system.ref=''Sistema.\#ref'' llama a \#loc
inspection.message.call.to.thread.ref=''hilo.\#ref'' llamada \#loc
inspection.message.trivial.conditional.expression=Expresión condicional que se explica por sí misma #loc
inspection.message.property.0.is.ignored.by.map.constructor=La propiedad ''{0}'' fue ignorada por @MapConstructor \#loc
inspection.message.unconditional.call.to.ref=Llama a <code>\#ref()</code> incondicionalmente \#loc
inspection.message.ref.is.unnecessary.as.last.statement.in.loop=\#ref no es necesario como última declaración del bucle \#loc.
inspection.message.ref.is.unnecessary.as.last.statement.in.method.with.no.return.value=\#ref no es necesario como última declaración de un método sin valor de retorno \#loc.
inspection.message.unreachable.statement=Declaración inalcanzable \#loc
inspection.message.unsynchronized.method.ref.overrides.synchronized.method=El método asincronizado ''\#ref'' anula el método sincronizado \#loc
inspection.message.cannot.determine.type.ref=No se puede determinar el tipo de ''\#ref''
inspection.message.call.to.ref.outside.of.loop=Llamando a ''\#ref'' fuera del bucle \#loc
inspection.message.call.to.ref.outside.of.synchronized.context=Llamar a ''\#ref'' fuera del contexto sincronizado \#loc
inspection.message.ref.loop.spins.on.field=El bucle <code>\#ref</code> gira en el campo \#loc
inspection.message.package.name.mismatch=el nombre del paquete no coincide
inspection.message.dsl.descriptor.file.has.been.changed.and.isnt.currently.executed=El archivo descriptor DSL ha cambiado y no se está ejecutando actualmente.
inspection.message.dsl.descriptor.file.has.been.disabled.due.to.processing.error=Debido a un error de procesamiento, el archivo descriptor DSL ha sido deshabilitado.
inspection.message.traits.0.contain.clashing.methods.with.signature.1=El atributo {0} contiene un método en conflicto con la firma {1}
inspection.message.unused.catch.parameter.ref=Parámetro de captura no utilizado ''\#ref'' \#loc
inspection.message.package.name.mismatch.actual.0.expected.1=El nombre del paquete no coincide. real\: ''{0}'', requerido\: ''{1}''
inspection.message.property.not.indexable.type.must.be.array.or.list.but.found.0=Las propiedades no se pueden indexar. El tipo debe ser una matriz o una lista, pero se encontró {0}
inspection.message.type.argument.0.can.not.be.1=El argumento ''{0}'' no puede tener el tipo ''{1}''
inspection.message.method.called.with.implicit.null.argument=El método se llama con un argumento nulo implícito.
inspection.message.plain.string.should.be.double.quoted=Las cadenas simples deben estar entre comillas dobles.
inspection.message.plain.string.should.be.single.quoted=Las cadenas regulares deben estar entre comillas simples.
inspection.message.plain.string.should.be.slashy.quoted=Las cadenas simples deben estar entre barras
inspection.message.plain.string.should.be.dollar.slashy.quoted=Las cadenas simples deben estar encerradas entre barras diagonales.
inspection.message.plain.string.should.be.quoted.with.triple.quotes=Las cadenas regulares deben estar encerradas entre ''''
inspection.message.plain.string.should.be.quoted.with.triple.double.quotes=Las cadenas regulares deben estar encerradas entre '"""
inspection.message.multiline.string.should.be.quoted.with.triple.quotes=Las cadenas de varias líneas deben estar encerradas entre ''''
inspection.message.multiline.string.should.be.quoted.with.triple.double.quotes=Las cadenas de varias líneas deben estar encerradas entre """
inspection.message.multiline.string.should.be.slashy.quoted=Las cadenas de varias líneas deben estar entre barras
inspection.message.multiline.string.should.be.dollar.slashy.quoted=Las cadenas de varias líneas deben estar entre barras en dólares
inspection.message.string.escaping.could.be.minimized=Puedes minimizar el escape.
inspection.message.interpolated.string.should.be.double.quoted=Las cadenas interpoladas deben estar entre comillas dobles.
inspection.message.interpolated.string.should.be.dollar.slashy.quoted=Las cadenas interpoladas deben estar encerradas entre barras diagonales.
inspection.message.interpolated.string.should.be.slashy.quoted=Las cadenas interpoladas deben estar entre barras
inspection.message.interpolated.string.should.be.quoted.with.triple.double.quotes=Las cadenas interpoladas deben estar encerradas entre '"""
text.class.0.is.unused=La clase {0} está en desuso
text.constructor.0.is.unused=El constructor {0} está en desuso
text.method.0.is.unused=El método {0} está en desuso
text.property.0.is.unused=La propiedad {0} está en desuso
text.parameter.0.is.unused=El parámetro ''{0}'' está en desuso
intention.category.groovy=Groovy
intention.category.conversions=Conversión de expresión/groovy
intention.category.closures=Groovy/Cierre
intention.category.comments=Groovy/anotaciones
intention.category.groovy.style=Estilo maravilloso/Maravilloso
intention.category.control.flow=Flujo maravilloso/controlado
intention.category.groovy.declaration=Groovy/Declaración
intention.category.groovy.other=Groovy/Otros
configurable.GroovyCompilerConfigurable.display.name=Compilador maravilloso
configurable.GantConfigurable.display.name=Gant
settings.compiler.alternative=Alternativamente, puede especificar el compilador Groovy-Eclipse en la <a href\=\"\#\">página del compilador Java</a>.
settings.compiler.select.path.to.groovy.compiler.configscript=Seleccione la ruta del script de configuración para el compilador Groovy
settings.compiler.path.to.configscript=&Ruta del script de configuración\:
settings.compiler.invoke.dynamic.support=Ejecutar soporte dinámico
settings.compiler.exclude.from.stub.generation=Excluir de la generación de resguardos\:
settings.code.style.label.indent.style=Estilo de sangría de etiqueta\:
settings.code.style.label.indent.size=Tamaño de sangría de etiqueta\:
settings.code.style.indent.statements.after.label=Declaración de sangría después de la etiqueta
settings.code.style.absolute=nunca
settings.code.style.indent.labels=Sangría de etiqueta
settings.inlay.parameter.types=Tipo de parámetro
settings.inlay.inferred.parameter.types=Tipo de parámetro inferido
settings.inlay.type.parameter.list=Lista de parámetros de tipo
settings.inlay.show.type.hints.for=Mostrar sugerencias de tipo para\:
intention.name.replace.with.in=Cambie ''\:'' a ''en''
intention.name.activate.back=reactivar
intention.name.cast.to.0=Convertir a {0}
intention.name.replace.eq.with.0.eq=Cambie ''\='' por ''{0}\=''
intention.name.cast.operand.to.0=Transmitir operando a {0}
intention.name.add.required.attributes.to.map.constructor=Agregue las propiedades requeridas a @MapConstructor
intention.name.convert.to.single.quoted.string=Convertir a cadena entre comillas simples
intention.name.change.quotes.to.triple.single.quotes=Cambie las comillas a "
intention.name.convert.to.double.quoted.string=Convertir a cadena entre comillas dobles
intention.name.change.quotes.to.triple.double.quotes=Cambiar comillas a """
intention.name.convert.to.slashy.string=Convertir a cadena de barra
intention.name.convert.to.dollar.slashy.string=Convertir barra de dólar en cadena
intention.family.name.create.field=Crear campo
action.remove.dynamic.member.text=Eliminar
action.remove.dynamic.member.description=Eliminar miembro dinámico
action.collapse.all.text=Desplegar todo
action.collapse.all.description=Desplegar todo
action.expand.all.text=Expandir todo
action.expand.all.description=Expandir todo
dynamic.members.column.name.element=elementos dinámicos
dynamic.members.column.name.type=Categoría
command.name.add.dynamic.member=Agregar miembros dinámicos
popup.content.navigation.to.overriding.classes.unavailable=La navegación que anula una clase no es posible durante una actualización de índice
overriding.methods.of.0=Método de anulación ''{0}''
expression.type.no.expression=Expresión no encontrada
expression.type.unknown=<unknown>
add.class.to.extends.family.name=avatar
intention.family.name.rename=cambiar nombre
generated.stub.message=Este código auxiliar se genera para que las clases Groovy habiliten la compilación cruzada Groovy-Java.
generated.stub.navigate.link.label=Ir a la clase Groovy
generated.stub.exclude.link.label=Excluir de la generación de resguardos
module.with.groovy=Módulo simple con biblioteca Groovy adjunta
action.build.restart.text=Reiniciar después de la compilación
action.build.module.restart.description=Reiniciar después de crear el módulo ''{0}''
gdsl.investigate.link.label=Haga clic para investigar
gdsl.error.notification.title=Error de ejecución del script DSL
dialog.message.gant.not.configured=Gant no está configurado.
investigate.gdsl.error.intention.name=Ver detalles
investigate.gdsl.error.family.name=Comprobación de errores del proceso del descriptor DSL
grab.intention.name=Agarrar artefactos
grab.family.name=Grab
grab.progress.title=Procesando la anotación @Grab
grab.result.title={0} Dependencia de uva {0,choice, 0\#jar|1\#jar|2\#jar} agregada
grab.jar.count=<b>{0}</b>\: {1} {1, choice, 0\#jar|1\#jar|2\#jar}
grab.error.ivy.missing.title=falta hiedra
grab.error.ivy.missing.message=Lo sentimos, IDEA no puede @Grab dependencias sin Apache Ivy. Vuelva a ejecutar la acción agregando Apache Ivy a las dependencias de su módulo.
grab.error.0.title=@Grab no se pudo ejecutar\: {0}
this.super.completion.advertisement=Al presionar {0} dos veces sin un calificador de clase se mostrarán todos los métodos estáticos accesibles.
optimize.imports.progress.title=Optimizando declaraciones de importación en un archivo Groovy...
groovy.library.label=Biblioteca maravillosa
replace.all.occurrences.and.remove.variable.0=Reemplazar todos los usos y eliminar la variable ''{0}''
introduce.variable.declare.final.label=Declarar y final
introduce.variable.replace.all.occurrences=&Reemplazar todos los usos
introduce.variable.replace.all.0.occurrences=Reemplazar todos los usos ({0} ubicaciones)
introduce.parameter.delegate.via.overload=Delegación mediante métodos sobrecargados
introduce.parameter.replace.fields.border.title=Convertir campos utilizados en expresiones en captadores
introduce.parameter.do.not.replace.option.label=&No reemplazar
introduce.parameter.replace.inaccessible.fields.option.label=&Reemplazar campos que no son accesibles en el contexto de uso
introduce.parameter.replace.all.fields.option.label=&Reemplazar todos los campos
introduce.variable.type.label=Escriba &T\:
introduce.variable.name.label=&Nombre\:
introduce.parameter.explicit.return.statement.option.label=Utilice una declaración de devolución explícita (&X)
introduce.parameter.delegating.unavailable.tooltip=No se permite la delegación en contexto de cierre
introduce.variable.change.type.advertisement=Presione {0} para cambiar el tipo
framework.0.home.label={0} Inicio\:
select.framework.0.home.title={0} Seleccione Inicio
framework.0.sdk.chooser.title={0} SDK
framework.0.sdk.chooser.description=Seleccione el directorio que contiene la distribución {0}
framework.0.sdk.chooser.error.message=La distribución {0} en la ruta especificada parece estar rota. No se puede determinar la versión.
framework.0.sdk.chooser.error.title=Error al crear la clase
framework.0.library={0} biblioteca
framework.0.library.version.1={0} versión de biblioteca {1}
framework.gant=Gant
script.runner.display.name=Groovy
script.runner.description=Clase o guión maravilloso
script.runner.chooser.title=ruta del script
script.runner.chooser.description=Especifique la ruta del script\:
script.runner.module.not.specified.message=Módulo no especificado
script.runner.no.groovy.for.module=Groovy no está configurado para el módulo ''{0}''
script.runner.cant.find.script=Script ''{0}'' no encontrado
script.runner.unknown.script.type=Tipo de secuencia de comandos desconocido ''{0}''
script.runner.file.is.not.groovy.file=El archivo de script no es un archivo Groovy
script.runner.class.does.not.exist=No hay clases.
script.runner.class.cannot.be.executed=La clase no se puede ejecutar
dialog.title.refactoring.unavailable.in.current.scope=Refactorización no disponible en el alcance actual
parameter.list.owner.chooser.title=Insertar parámetros como
extract.closure.command.name=Extracción de cierre
introduce.constant.title=Insertar constante
undefined.library.version=No definida
method.parameters.count.max.parameters.option=Número máximo de parámetros\:
method.returns.max.returns.option=Límite de punto de retorno\:
overly.complex.method.complexity.limit.option=Límites de complejidad del método\:
overly.long.method.statements.limit.option=Número máximo de declaraciones por método\:
overly.nested.method.nesting.limit.option=Profundidad máxima de anidamiento\:
add.method.family=Agregar método
change.base.method.label=Cambiar el método predeterminado
change.usages.label=Cambia dónde lo usas
convert.parameter.to.map.entry.title=Convertir parámetros en elementos de mapa
live.template.context.declaration=Declaración
live.template.context.expression=expresión
live.template.context.statement=construcción
find.usages.method.0.of.class.1={0} de {1}
change.signature.type.column=categoría
change.signature.default.initializer.column=inicializador predeterminado
static.import.method.fix=método de importación estática...
static.import.method.0.fix=método de importación estática ''{0}''
groovy.consoles.type=Consola Groovy
getter.kind.gdk.method.0=Método GDK {0}
getter.kind.method.0=Método {0}
getter.kind.getter.0=getter {0}
parameter.hint.number.of.arguments={0,choice, 0\#|1\#{0} argumento|2\#{0} argumento}
surround.with.for=for
surround.with.if=if
surround.with.if.else=if/else
surround.with.if.expr=if (expr)
surround.with.if.else.expr=if (expr)/else
surround.with.parentheses=(expr)
surround.with.closure={ ->... }.call()
surround.with.try=try
surround.with.try.catch=try/catch
surround.with.try.finally=try/finally
surround.with.try.catch.finally=try/catch/finally
surround.with.while=while
surround.with.while.expr=while (expr)
surround.with.cast=((Type) expr)
surround.with.with=with () {...}
surround.with.with.expr=with (expr)
surround.with.shouldFail=shouldFail () {...}
code.style.group.list.map.literals=Literales de lista y mapa
code.style.option.align.when.multiple=Ordenar si son múltiples
code.style.option.wrap.after.dot=Salto de línea después del punto
code.style.option.align.multiline.named.arguments=Ordenar argumentos con nombre en varias líneas
code.style.option.use.flying.geese.braces=Coloque la llave de cierre en una línea.
code.style.option.import.annotations=Obtener anotaciones
code.style.option.simple.lambdas.closures.in.one.line=Lambda/cierre simple en una línea
code.style.option.relational.operators=Operadores relacionales (<, >, <\=, >\=, <\=>)
code.style.option.unary.operators=Operadores unarios (\!, -, +, ++, --, *)
code.style.option.in.named.argument.before.colon=Dentro de los argumentos con nombre antes de ''\:''
code.style.option.in.named.argument.after.colon=Dentro del argumento nombrado después de ''\:''
code.style.option.list.maps.literals=Literales de lista y mapa
code.style.option.closure.left.brace.in.method.calls=Cierre de llave izquierda dentro de la llamada al método
code.style.option.gstring.injection.braces=Tirantes de inserción GString
code.style.option.tuple.assignment.expression=Expresión de asignación de tupla
code.style.option.regexp.expression=Expresión regular (\=\=~, \=~)
code.style.option.before.assert.separator=Antes del delimitador ''afirmar''
code.style.option.after.assert.separator=Después del delimitador ''afirmar''
singleton.constructor.found=Las clases @Singleton no pueden contener constructores
singleton.constructor.remove=Eliminar constructor
singleton.constructor.makeNonStrict=Establecer @Singleton como no estricto
unused.import=Declaración de importación no utilizada
optimize.imports=Optimización de declaración import
optimize.all.imports=Optimice las declaraciones de importación no utilizadas
dialog.create.class.package.chooser.title=Seleccionar paquete de destino
create.directory.command=Crear directorio
destination.package=Paquete objetivo\:
second.unsafe.call=Segunda llamada insegura
call.can.throw.npe=La cadena de llamadas puede generar NullPointerException
unused.default.parameter.message=Los parámetros predeterminados no se utilizan
unused.default.parameter.fix=Eliminar inicializador
unused.assignment.tooltip=La tarea no se utiliza
unused.variable=La variable no se utiliza
variable.can.be.final.tooltip=La variable ''{0}'' puede ser final
parameter.can.be.final.tooltip=El parámetro ''{0}'' puede ser final
equals.between.inconvertible.types.tooltip=<code>{0}</code> está entre objetos de tipo ''{1}'' y ''{2}'' que no se pueden convertir
replace.with.operator.message=Puedes reemplazar ''{0}'' con un operador
replace.with.operator.fix=Reemplace ''{0}'' con operador
replace.with.operator.double.negation.option=Usar dobles negativos (por ejemplo, \: \!\!)
replace.with.operator.compareTo.equality.option=Cambiar la ecuación ''compareTo'' a igual (por ejemplo, \=\=)
replace.with.operator.parentheses=No sugiere reemplazar con operador si se necesitan paréntesis adicionales
replace.with.method.message=Se puede reemplazar con la llamada al método ''{0}''
replace.with.method.fix=Reemplazar con el método ''{0}''
unassigned.access.tooltip=Es posible que la variable ''{0}'' no esté asignada
no.return.message=Algunas rutas de ejecución no devuelven valores
unresolved.type.status=El tipo ''{0}'' no se resuelve
no.type.specified=No se especifica ningún tipo
dynamic.element=elementos dinámicos
pointless.boolean.problem.descriptor=\#ref se puede simplificar a ''{0}'' \#loc
pointless.arithmetic.error.message=Puedes reemplazar \#ref con ''{0}'' \#loc
pointless.boolean.quickfix=arrasamiento
Cannot.perform.undo.operation=Las operaciones no se pueden deshacer
Undo.disable=Deshacer deshabilitar
type.doesnt.contain.method=El tipo ''{0}'' no tiene el método ''{1}'', por lo que ese tipo no se puede iterar en su alcance.
type.doesnt.implement.comparable=El tipo ''{0}'' no implementa Comparable
add.method=Agregue el método ''{0}()'' a ''{1}''
implement.class={0} implementación
fix.class=Modificar clase {0}
rtype.cannot.contain.ltype=''{1}'' no puede contener ''{0}''
new.instance.of.singleton=Una nueva instancia de la clase anotada @groovy.lang.Singleton.
replace.new.expression.with.instance.access=Cambiar al acceso a la instancia
getter.0.clashes.with.getter.1=Se produjo un conflicto: ''{0}'' con ''{1}''
unused.0=sin usar {0}
remove.0=eliminar {0}
replace.postfix.0.with.prefix.0=Reemplace el sufijo {0} con el prefijo {0}
replace.0.with.1=Convertir {0} a binario {1}
local.var.0.is.reassigned=Se asignó la variable local ''{0}''
anonymous.class=clase anónima
closure=cierre
other.scope=Otra gama
method.may.be.static=El método puede ser estático.
method.may.be.static.option.ignore.trait.methods=Anulación del método de atributo
method.may.be.static.only.private.or.final.option=Inspeccionar solo métodos finales o privados.
method.may.be.static.ignore.empty.method.option=Ignorar métodos vacíos
ignore.boolean.expressions=Ignorar variables no asignadas al verificar booleano
highlight.if.groovy.object.methods.overridden=Resalte referencias en clases que anulan invokeMethod(), getProperty() o setProperty()
highlight.if.missing.methods.declared=Resalte referencias en clases que declaran MissingMethod() o MissingProperty()
gr.package.inspection.check.scripts=Inspección de guión
java.style.property.access=Llamadas de acceso al estilo Java
type.customizer.is.not.marked.as.a.resource.file=El script del personalizador de tipos no está marcado como recurso del compilador.
add.to.resources=Agregar al recurso
add.type.customizer.to.resources=Agregar script de personalizador de tipo al recurso
target.0.does.not.exist=El destino ''{0}'' no existe
target.annotation.is.unused=@Target está en desuso
change.lvalue.type=Cambiar el tipo de variable ''{0}'' a ''{1}''
replace.qualified.name.with.import=Reemplazo de nombres completos con declaraciones de importación
comments.count.as.content=Contar comentarios como contenido
ignore.when.catch.parameter.is.named.ignore.or.ignored=Se ignora si el parámetro catch se denomina ignorar o ignorar.
no.applicable.signature.found=No se encontró ninguna firma aplicable
expected.type.0=''{0}'' requerido pero ''{1}'' encontrado
declare.explicit.implementations.of.trait=Declaración de implementación explícita de un rasgo
unnecessary.modifier.description=El controlador ''{0}'' no es necesario
unnecessary.modifier.remove=Eliminar ''{0}'' innecesario
unnecessary.def.explicitly.typed.only=Informar solo sobre declaraciones escritas explícitamente
unnecessary.alias.fix=Eliminar alias innecesarios
unnecessary.alias.description=No se necesita alias
unnecessary.semicolon.description=No se requiere punto y coma
unnecessary.semicolon.fix=Quitar punto y coma
dynamic.dialog.class.label=&Clase\:
dynamic.dialog.type.label=Escriba &T\:
dynamic.dialog.static.checkbox=&silencio
find.method.ro.method.usages=Buscando la ubicación del uso del método adjunto en el archivo del proyecto
find.method.ro.closure.usages=Búsqueda del uso de cierres adjuntos en archivos de proyecto
conversion.method.not.allowed.in.non.groovy.files=La refactorización no está disponible para métodos utilizados en archivos que no sean Groovy\:
conversion.closure.not.allowed.in.non.groovy.files=La refactorización no está disponible para cierres utilizados en archivos que no sean Groovy\:
wrong.method.first.parameter.type=El método ''{0}'' se utiliza con argumentos con nombre, pero el primer argumento interno ''{1}'' no se ajusta al tipo de mapa.
wrong.closure.first.parameter.type=El cierre ''{0}'' se utiliza con argumentos con nombre, pero el primer argumento dentro de ''{1}'' no se ajusta al tipo de mapa.
map.parameter.dialog.create.new.checkbox=&Crear parámetros para argumentos con nombre
map.parameter.dialog.explicit.type.checkbox=Especificar el tipo explícitamente
convert.cannot.itself=La refactorización no se puede utilizar en el parámetro del mapa en sí.
map.param.name=Nombre del parámetro de mapa (&N)\:
convert.param.to.map.entry=Convertir parámetros en elementos de mapa
closure.used.as.variable=Se aprobó un cierre como argumento. La refactorización puede cambiar el significado.
do.you.want.to.change.method.return.type=¿Le gustaría cambiar el tipo de retorno del método ''{0}''?
do.you.want.to.change.variable.type=¿Quieres cambiar el tipo de ''{0}''?
closure.is.accessed.outside.of.groovy=Se accede al campo <b>{0}</b> fuera de Groovy
write.access.to.closure.variable=Acceso de escritura al campo <b>{0}</b>
field.is.used.in.argument.label=El campo <b>{0}</b> se utiliza en etiquetas de argumentos.
method.with.signature.already.exists=Ya existe un método con firma {0}
field.already.exists=El campo <b>{0}</b> ya existe
method.is.used.outside.of.groovy=El método se utiliza fuera de Groovy.
do.you.want.to.change.type.of.parameter.in.method=¿Quiere cambiar el tipo de parámetro ''{0}'' en el método ''{1}''?
file.exists=El archivo ''{0}'' ya existe en el directorio ''{1}''
move.to.correct.dir.family.name=Mover archivos al paquete correcto
move.to.correct.dir=Ir a ''{0}''
add.return.type=Agregar tipo de devolución
add.return.type.to.method.declaration=Agregar tipo de retorno a la declaración del método
infer.method.parameters.types=Agregar tipos explícitos a los parámetros
infer.method.parameters.types.for.method.declaration=Agregue tipos explícitos para todos los parámetros en la declaración del método
replace.with.wrapper=Reemplazar con {0}
replace.primitive.type.with.wrapper=Reemplazo de tipos de base con envoltorios
remove.parameter.0=Eliminar parámetro ''{0}''
remove.unused.parameter=Eliminar parámetros no utilizados
remove.exception=eliminar excepción
remove.catch.block=Quitar bloque de captura
try.catch.fix=arreglar try-catch
cannot.create.class=No se puede crear la clase
rename.file.to.0=Cambiar el nombre del archivo a ''{0}''
java.style.properties.invocation.intention.family.name=Cambie las llamadas de acceso al estilo Java a referencias de propiedades al estilo Groovy
java.style.properties.invocation.intention.name=Cambiar a la referencia de propiedad de estilo Groovy
generate.equals.and.hashcode.already.defined.warning.anonymous=equals() y hashCode() ya están definidos
generate.equals.and.hashcode.already.defined.warning=equals() y hashCode() ya están definidos
generate.equals.and.hashcode.already.defined.title=equals() y hashCode() ya están definidos
generate.equals.compare.nested.arrays.comment=// matriz anidada aquí {0} - comparar valores
generate.equals.compare.arrays.comment=// Comparar matrices Object[] con Arrays.equals puede ser incorrecta
generate.property.missing.already.defined.warning=propertyMissing() ya está definido
generate.property.missing.already.defined.title=propertyMissing() ya está definido
generate.method.missing.already.defined.warning=métodoMissing() ya está definido
generate.method.missing.already.defined.title=métodoMissing() ya está definido
action.Gant.NewScript.text=guión de gant
action.Gant.NewScript.description=Crear un nuevo script Gant
action.Groovy.Console.text=Consola Groovy
action.Groovy.Console.description=Inicia la consola Groovy
module.name.0.and.groovy.version.1={0} ({1})
groovy.version.0=Groovy {0}
groovy.version.bundled.0=Paquete maravilloso {0}
configurable.greclipse.border.title=Opciones de Groovy-Eclipse
configurable.greclipse.path.label=ruta del jar groovy-eclipse-batch\:
configurable.greclipse.path.chooser.description=Seleccione la ruta groovy-eclipse-batch-*.jar para la versión que coincida con su distribución Groovy
configurable.greclipse.command.line.params.label=Parámetros de línea de comando adicionales\:
configurable.greclipse.debug.checkbox=Generar información de depuración
configurable.hotswap.checkbox=Habilitación del agente de intercambio en caliente en código Groovy
configurable.hotswap.checkbox.description=Puede causar problemas de serialización en aplicaciones depuradas
run.configuration.script.path.label=Ruta del script\:
run.configuration.module.chooser.label=&Módulo\:
run.configuration.module.classpath.checkbox=Agregar classpath del módulo al corredor
pull.up.wont.be.accessible.from={1} no puede acceder a {0}
pull.up.wont.be.accessible.from.the.subclass={0} usa {1} al que no se puede acceder desde subclases.
pull.up.abstract.wont.be.accessible.from={0} no se puede hacer abstracto porque no se puede acceder a él desde las subclases.
settings.inlay.implicit.null.argument=argumento nulo implícito
settings.inlay.show.hints.for.implicit.null.argument=Mostrar sugerencias sobre argumentos nulos implícitos
header.extract.closure=Extracción de cierre
string.sort.default=Por defecto
string.sort.strings.with.escaping=Cadena que contiene caracteres de escape
string.sort.strings.with.interpolation=Una cadena que contiene una expresión de interpolación.
string.sort.multiline.string=cadena multilínea
separator.preferable.string.kind=tipo preferido
separator.domain.of.inspection.usage=Dónde usar el dominio
checkbox.inspect.gradle.files=Inspección de archivos Gradle
string.option.do.not.handle.specifically=Sin trato especial
string.option.double.quoted.string=Cadena entre comillas dobles
string.option.single.quoted.string=Cadena entre comillas simples
string.option.slashy.string=cadena de barra
string.option.triple.quoted.string=Cadena encerrada entre comillas simples triples
string.option.triple.double.quoted.string=Cadena encerrada entre comillas dobles triples
string.option.dollar.slashy.string=cadena de barra de dólar
gdsl.trusted.project.message=This project contains Groovy DSL (GDSL) scripts, which improve code insight experience when editing Groovy code. GDSL scripts might contain potentially malicious code, which will be executed within the IDE. Would you like to run them?
gdsl.trusted.project.answer.trust=Yes
gdsl.trusted.project.answer.dont.trust=No
label.groovy.library=Biblioteca maravillosa
radio.use.version.from.maven=Usando la versión de Maven:
radio.use.jar.file.from.disk=Usando el archivo .jar en el disco:
local.variable.types=tipo de variable local
settings.inlay.show.variable.type.hints=Mostrar sugerencia de tipo de variable local
settings.inlay.put.type.hint.before.identifier=Ponga una sugerencia de tipo antes del identificador.
