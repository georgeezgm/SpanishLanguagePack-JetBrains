dialog.message.no.inheritors.are.selected=선택된 상속자가 없습니다
progress.title.inplace.rename.appending.additional.elements=추가 요소 추가 중
progress.title.inplace.rename.collecting.references=참조 수집 중
progress.title.inplace.rename.preparing=이름 변경 준비 중
extract.invalid.name.for.class.type.error={0} 이름이 잘못되었습니다
refactoring.introduce.constant.name=상수 삽입
refactoring.introduce.define.name=Define 삽입
refactoring.introduce.typedef.name=Typedef 삽입
refactoring.introduce.variable.name=변수 삽입
refactoring.introduce.ivar.name=Ivar 삽입
refactoring.introduce.property.name=프로퍼티 삽입
refactoring.introduce.instance.variable.name=인스턴스 변수 삽입
refactoring.introduce.parameter.name=매개변수 삽입
refactoring.move.no.members.are.selected.error=선택된 멤버가 없습니다
refactoring.move.members.ok.button.text=이동(&M)
refactoring.move.pull.up.ok.button.text=풀(&U)
refactoring.move.push.down.ok.button.text=푸시(&U)
refactoring.move.escalate.visibility.declare.in.interface=인터페이스에서 선언
refactoring.move.namespace.has.no.members=네임스페이스 "{0}"에 이동할 멤버가 없습니다
refactoring.move.file.has.no.members=파일 "{0}"에 이동할 멤버가 없습니다
refactoring.symbol.has.no.members.to.move={0}에 이동할 멤버가 없습니다
refactoring.move.caret.position=캐럿이 클래스 내부에 있어야 합니다
refactoring.move.cant.find.symbol=선택한 클래스에 대한 심볼을 찾을 수 없습니다
refactoring.move.members.error.no.target.class.selected=선택된 대상 클래스가 없습니다
refactoring.move.members.error.class.name.invalid=클래스 이름이 잘못되었습니다
refactoring.move.members.error.not.in.project.sources={0}이(가) 프로젝트 내에 없습니다
refactoring.move.members.error.the.same.source.and.target=원본 및 대상 클래스는 서로 달라야 합니다
refactoring.move.members.message.target.does.not.exist=대상 클래스 "{0}"이(가) 아직 없습니다.
refactoring.extract.super.protocol.title=상위 프로토콜 추출
refactoring.extract.subclass.title=하위 클래스 추출
refactoring.extract.category.title=카테고리 추출
refactoring.introduce.block.expression.represent.error=선택한 블록이 {0}을(를) 나타내야 합니다
refactoring.introduce.expressions.choose.dialog.title=표현식
refactoring.introduce.put.to.header=헤더에 배치(&H)
refactoring.change.signature.target.symbols.panel=대상\:
refactoring.rename={0} 이름 변경(&R)
refactoring.rename.class.aliases=클래스 별칭 이름 변경(&R)
refactoring.rename.associated.file=관련 파일 이름 변경
refactoring.introduce.constant.static.declaration=static 선언(&S)
refactoring.ivar.inplace.introducer.generate.property=프로퍼티 생성(&P)
refactoring.ivar.inplace.introducer.declare.interface=인터페이스에서 선언(&I)
refactoring.introducer.declare.const=const 선언(&C)
refactoring.introducer.declare.auto=auto 선언(&A)
refactoring.parameter.introducer.refactor.super.method=상위 {0} 리팩터링(&S)
refactoring.property.introducer.make.readonly=readonly로 설정(&R)
refactoring.property.introducer.generate.synthesize=@synthesize 생성(&S)
refactoring.property.introducer.generate.instance.variable=인스턴스 변수 생성(&I)
refactoring.property.introducer.put.to.private.category=비공개 카테고리에 배치(&P)
dialog.title.choose.containing.class=포함 클래스 선택
dialog.message.variable.must.be.const=변수 "{0}"은(는) 상수여야 합니다
dialog.message.cannot.find.method.function=메서드/함수를 찾을 수 없습니다
dialog.message.cannot.inline.parameters.blocks=블록의 매개변수를 인라인화할 수 없습니다
dialog.message.cannot.inline.parameters.lambdas=람다의 매개변수를 인라인화할 수 없습니다
dialog.message.several.call.sites.with.different.parameter.initializers=매개변수 이니셜라이저가 서로 다른 여러 호출 사이트가 있습니다
dialog.message.there.are.no.usages={0}의 사용 위치가 없습니다
dialog.message.cannot.inline.blocks=블록을 인라인화할 수 없습니다
dialog.message.cannot.inline.protocol.method=프로토콜 메서드를 인라인화할 수 없습니다
dialog.message.interface.was.not.implemented=인터페이스 {0}이(가) 구현되지 않았습니다
dialog.message.cannot.inline.with.empty.body=본문이 비어 있는 {0}은(는) 인라인화할 수 없습니다
dialog.message.there.are.no.calls.in.project=프로젝트에 {0} 호출이 없습니다
dialog.message.cannot.inline.methods.with.return.statements.interrupting.execution.flow=실행 흐름을 방해하는 return 문이 있는 메서드는 인라인화할 수 없습니다
question.inline.usage={2}의 사용 위치 {0}개를{1, choice, 0\#|1\#} 인라인화하시겠어요?
message.never.used={0}은(는) 전혀 사용되지 않습니다
dialog.message.accessed.for.writing={0}은(는) 쓰기용으로 액세스됩니다
dialog.message.accessed.for.address=주소를 얻기 위해 {0}이(가) 액세스됩니다
dialog.title.inline={0} 인라인화
button.inline.current.usage=현재 사용 위치 인라인화(&C)
button.inline.all.usages.file={0, choice, 0\#파일 내|1\#} 모든 사용 위치 인라인화(&A)
button.view.usages=사용 위치 표시(&S)
button.cancel=취소(&C)
button.inline=인라인화(&I)
button.rename=이름 변경(&R)
button.rename.code=코드 사용 위치만 이름 변경(&C)
button.rename.all=모든 사용 위치의 이름 변경(&R)
dialog.message.must.have.initializer={0}에 이니셜라이저가 있어야 합니다
rename.reference.command.name=참조 이름 변경
rename.reference.invalid.dialog.title=잘못된 식별자
rename.reference.invalid.dialog.button.yes=계속 편집
rename.multiple.macro.usages.message={0}은(는) "{1}"에 대한 매핑이 서로 다른 여러 사용 위치를 가집니다. 이름을 변경하면 코드가 손상될 수 있습니다. 계속하시겠어요?
rename.non.code.usages.message=주석 및 비 코드 파일에서 {0}개의 {0, choice,1\#사용 위치가|2\#사용 위치가} 발견되었습니다.\n{0, choice,1\#해당 위치|2\#해당 위치}의 이름을 변경하시겠어요?
dialog.title.extract.method=메서드 추출
dialog.title.extract.function=함수 추출
dialog.title.extract.block.parameter=블록 매개변수 추출
dialog.title.extract.lambda.parameter=람다 매개변수 추출
dialog.message.lambdas.not.supported=람다는 현재 버전 표준에서 지원되지 않습니다
dialog.message.lambdas.cant.extract.initializer.list=이니셜라이저 목록을 람다 매개변수로 추출할 수 없습니다
dialog.message.lambdas.cant.extract.functional.type=함수 형식의 표현식을 람다 파라미터로 추출할 수 없습니다
dialog.message.lambdas.cant.extract.dependent.types=람다 파라미터에 의존하는 유형의 표현식을 추출할 수 없습니다
dialog.message.cant.refactor.operators=C++ 연산자 함수를 리팩터링할 수 없음
button.extract=추출
dialog.message.cannot.extract.there.are.multiple.exit.points.in.selected.code.fragment={0}을(를) 추출할 수 없습니다.\n선택한 코드 조각에 여러 종료점이 있습니다
dialog.message.selected.statements.should.be.inside.function.choice.or.method=선택된 구문이 함수{0, choice, 0\# 또는 메서드|1\#} 내에 있어야 합니다
dialog.message.can.t.refactor.with.variable.arguments=변수 인수가 있는 {0}은(는) 리팩터링할 수 없습니다
dialog.message.overrides.in.choice.which.out.project={0}이(가) {3, choice, 0\#프로젝트 외부의 |1\#}{2}에서 {1}을(를) 재정의합니다.
dialog.message.do.you.want.to.proceed.refactoring=리팩터링을 계속 진행하시겠어요?
dialog.message.do.you.want.to.refactor.base.s=기본 {0}을(를) 리팩터링하시겠어요?
label.declaration.place=선언 위치\:
refactoring.rename.command.name=이름 변경
trying.to.rename.0.to.existing.file.name.1={0}의 이름을 기존 파일 이름 {1}(으)로 변경하려 합니다
file.0.already.exists.in.the.project=파일 ''{0}''이(가) 프로젝트에 이미 있습니다
refactoring.rename.0.already.exists.in.1={0}이(가) {1}에 이미 있습니다
refactoring.rename.0.already.exists.in.the.scope={0}이(가) 범위에 이미 있습니다
dialog.message.name.invalid={0}의 이름이 잘못되었습니다
dialog.message.return.type.invalid={0}의 반환 유형이 잘못되었습니다
dialog.message.no.selector.parts.for={0}에 대한 선택자 부분이 없습니다
dialog.message.containing.class.invalid=포함 클래스 "{0}"이(가) 잘못되었습니다
dialog.message.containing.class.outside.project=포함 클래스 "{0}"이(가) 프로젝트 외부에 있습니다
dialog.message.selector.part.invalid=선택자 부분 ''{0}''이(가) 잘못되었습니다
dialog.message.parameter.name.invalid=매개변수 이름 ''{0}''이(가) 잘못되었습니다
selected.expression.should.be.inside.a.block.statement=선택한 표현식은 블록 구문 내에 있어야 합니다
can.t.refactor.the.compound.initializer=복합 이니셜라이저를 리팩터링할 수 없습니다
cannot.determine.type.of.the.selected.expression=선택한 표현식의 유형을 확인할 수 없습니다
cannot.perform.refactoring.selected.expression.has.void.type=리팩터링을 수행할 수 없습니다. 선택한 표현식에 void 변수가 있습니다.
selected.expression.cannot.be.a.constant.initializer=선택한 표현식은 상수 이니셜라이저가 될 수 없습니다
selected.expression.should.be.inside.an.instance.method=선택한 표현식은 인스턴스 메서드 내에 있어야 합니다
selected.expression.should.be.inside.a.function.or.method=선택한 표현식은 함수 또는 메서드 내에 있어야 합니다
can.t.introduce.parameter.to.a.function.with.default.parameter.values=기본 매개변수 값이 있는 함수에 매개변수를 삽입할 수 없습니다
selected.expression.should.be.inside.an.instance.method1=선택한 표현식은 인스턴스 메서드 내에 있어야 합니다
property.inplace.introducer.label.semantics=의미
declaration.must.have.one.declarator.to.introduce.the.type=선언에는 유형을 삽입하기 위한 선언자가 하나 있어야 합니다
namespace.qualifier.should.be.resolved.to.the.class=네임스페이스 한정자는 클래스로 해결되어야 합니다
the.type.is.empty=유형이 비어 있습니다
can.t.extract.type.of.0.definition={0} 정의의 유형을 추출할 수 없습니다
dialog.message.can.t.move.to.itself=''{0}''을(를) 자신으로 이동할 수 없습니다
dialog.message.can.t.copy.to.itself=''{0}''을(를) 자신으로 복사할 수 없습니다
dialog.message.directory.already.exists.at=디렉터리가 ''{0}''에 이미 있습니다
dialog.message.file.already.exists.at=파일이 ''{0}''에 이미 있습니다
dialog.message.file.already.exists=파일이 이미 있습니다
extract.dialog.button.extract=추출(&R)
escalate.visibility.member.column=멤버
escalate.visibility.current.visibility.column=현재 가시성
escalate.visibility.required.visibility.column=필요한 가시성
push.down.inheritor.column=상속자
text.parameter.initializer.not.available.in={0}에서 매개변수 이니셜라이저를 사용할 수 없습니다. {1}
cannot.inline.function.type=함수 유형을 인라인화할 수 없습니다
cannot.inline.constructor.expression=생성자 표현식을 인라인화할 수 없습니다
can.t.inline.definition={0} 정의를 인라인화할 수 없습니다
cannot.inline.the.macro.inside.another.macro.definition=다른 매크로 정의 내에 있는 매크로는 인라인화할 수 없습니다
cannot.find.the.method.function=메서드/함수를 찾을 수 없습니다
there.are.usages.in.other.blocks=다른 블록에 사용 위치가 있습니다
0.was.not.initialized={0}이(가) 초기화되지 않았습니다
there.are.several.definitions.of={0}의 정의가 여러 개 있습니다
the.address.of.is.taken={0}의 주소가 사용 중입니다
element.is.written.in.the.block={0}이(가) 블록에 작성되어 있습니다
several.definitions.of.0={0}의 정의가 여러 개 있습니다
element.is.accessed.for.writing={0}은(는) 쓰기용으로 액세스됩니다
cannot.inline.usages.inside.the.macro.substitutions=매크로 치환 내에 있는 사용 위치는 인라인화할 수 없습니다
element.has.inheritor={0}에 상속자 {1, choice, 0\#메서드|1\#함수}가 있습니다
element.inherits.method={0}이(가) {1}에서 메서드를 상속합니다
cannot.inline.method.reference.in.selector.expression=''@selector'' 표현식에 있는 메서드 참조는 인라인화할 수 없습니다
cannot.inline.method.reference.in.xml.file=XML 파일에 있는 메서드 참조는 인라인화할 수 없습니다
cannot.inline.method.reference.in.property.attribute=프로퍼티 속성에 있는 메서드 참조는 인라인화할 수 없습니다
cannot.inline.function.reference.in.non.call.expression=호출이 아닌 표현식에 있는 함수 참조는 인라인화할 수 없습니다
cannot.inline.usage.in.swift.code=Swift 코드에 있는 사용 위치는 인라인화할 수 없습니다
cannot.inline.recursive=재귀적 {0} 호출은 인라인화할 수 없습니다
dialog.message.elements.to={0}할 요소
top.level.namespace.placeholder=최상위 네임스페이스
