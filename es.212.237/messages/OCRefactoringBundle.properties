dialog.message.no.inheritors.are.selected=No hay heredero seleccionado
progress.title.inplace.rename.appending.additional.elements=Agregar elementos adicionales
progress.title.inplace.rename.collecting.references=Recopilación de referencias
progress.title.inplace.rename.preparing=Preparándose para cambiar de nombre
extract.invalid.name.for.class.type.error={0} nombre no es válido
refactoring.introduce.constant.name=Insertar constante
refactoring.introduce.define.name=Definir inserción
refactoring.introduce.typedef.name=Inserción de definición de tipo
refactoring.introduce.variable.name=Insertar variable
refactoring.introduce.ivar.name=Insertar Ivar
refactoring.introduce.property.name=Insertar propiedad
refactoring.introduce.instance.variable.name=Insertar variable de instancia
refactoring.introduce.parameter.name=Insertar parámetro
refactoring.move.no.members.are.selected.error=No hay miembros seleccionados
refactoring.move.members.ok.button.text=&Mover
refactoring.move.pull.up.ok.button.text=&Usar
refactoring.move.push.down.ok.button.text=&Empujar
refactoring.move.escalate.visibility.declare.in.interface=declarado en la interfaz
refactoring.move.namespace.has.no.members=No hay miembros para mover en el espacio de nombres "{0}"
refactoring.move.file.has.no.members=No hay miembros para mover en el archivo "{0}"
refactoring.symbol.has.no.members.to.move={0} no tiene miembros para mover
refactoring.move.caret.position=Caret debe estar dentro de una clase.
refactoring.move.cant.find.symbol=No se encontró ningún símbolo para la clase seleccionada
refactoring.move.members.error.no.target.class.selected=No se ha seleccionado ninguna clase objetivo
refactoring.move.members.error.class.name.invalid=El nombre de la clase no es válido.
refactoring.move.members.error.not.in.project.sources={0} no está en el proyecto
refactoring.move.members.error.the.same.source.and.target=Las clases de origen y de destino deben ser diferentes
refactoring.move.members.message.target.does.not.exist=La clase de destino "{0}" aún no existe.
refactoring.extract.super.protocol.title=Extracción del protocolo principal
refactoring.extract.subclass.title=Extracción de subclases
refactoring.extract.category.title=Extracción de categorías
refactoring.introduce.block.expression.represent.error=El bloque seleccionado debe representar {0}
refactoring.introduce.expressions.choose.dialog.title=expresión
refactoring.introduce.put.to.header=Colocar en el encabezado
refactoring.change.signature.target.symbols.panel=Objetivo\:
refactoring.rename=Cambiar nombre {0}
refactoring.rename.class.aliases=Cambiar nombre/cambiar nombre de alias de clase
refactoring.rename.associated.file=Cambiar nombres de archivos relacionados
refactoring.introduce.constant.static.declaration=& declaración estática
refactoring.ivar.inplace.introducer.generate.property=Crear &Propiedad
refactoring.ivar.inplace.introducer.declare.interface=&Declaración en la interfaz
refactoring.introducer.declare.const=& declaración constante
refactoring.introducer.declare.auto=declaración automática
refactoring.parameter.introducer.refactor.super.method=Refactorizar y padre {0}
refactoring.property.introducer.make.readonly=Establecer en &solo lectura
refactoring.property.introducer.generate.synthesize=Crear y sintetizar
refactoring.property.introducer.generate.instance.variable=&Crear variables de instancia
refactoring.property.introducer.put.to.private.category=&Colocar en categoría privada
dialog.title.choose.containing.class=Seleccionar clase contenedora
dialog.message.variable.must.be.const=La variable "{0}" debe ser una constante
dialog.message.cannot.find.method.function=Método/función no encontrado
dialog.message.cannot.inline.parameters.blocks=No se pueden insertar parámetros en el bloque
dialog.message.cannot.inline.parameters.lambdas=Los parámetros en lambda no se pueden insertar
dialog.message.several.call.sites.with.different.parameter.initializers=Hay varios sitios de llamadas con diferentes inicializadores de parámetros.
dialog.message.there.are.no.usages=No se utiliza {0}
dialog.message.cannot.inline.blocks=El bloque no se puede insertar
dialog.message.cannot.inline.protocol.method=El método de protocolo no se puede insertar
dialog.message.interface.was.not.implemented=La interfaz {0} no está implementada
dialog.message.cannot.inline.with.empty.body={0} con cuerpo vacío no se puede insertar
dialog.message.there.are.no.calls.in.project=No hay {0} llamadas en el proyecto
dialog.message.cannot.inline.methods.with.return.statements.interrupting.execution.flow=Los métodos con declaraciones de retorno que interrumpen el flujo de ejecución no se pueden incluir en línea
question.inline.usage=¿Quieres incorporar {0} usos de {2} {1,choice, 0\#|1\#}?
message.never.used={0} no se utiliza en absoluto
dialog.message.accessed.for.writing=Se accede a {0} para escribir
dialog.message.accessed.for.address=Se accede a {0} para obtener la dirección.
dialog.title.inline={0} en línea
button.inline.current.usage=&Uso actual en línea
button.inline.all.usages.file=Todos los usos en línea {0,choice, 0\#en archivo|1\#}
button.view.usages=Mo&strar usos
button.cancel=&Cancelar
button.inline=En línea y yo
button.rename=&Rebautizar
button.rename.code=Cambiar el nombre sólo donde se utiliza el código
button.rename.all=&Renombrar todos los usos
dialog.message.must.have.initializer={0} debe tener un inicializador
rename.reference.command.name=Cambiar nombre de referencia
rename.reference.invalid.dialog.title=identificador no válido
rename.reference.invalid.dialog.button.yes=Continua editando
rename.multiple.macro.usages.message={0} tiene múltiples usos con diferentes asignaciones a "{1}". Cambiar el nombre puede romper su código. ¿Quieres continuar?
rename.non.code.usages.message={0} {0,choice,1\#uses|2\#uses} encontrado en comentarios y archivos sin código.\n{0,choice,1\#places|2\#places of use|2\#places de uso} ¿Quieres cambiar el nombre de }?
dialog.title.extract.method=Extracción del método
dialog.title.extract.function=Extracción de funciones
dialog.title.extract.block.parameter=Extracción de parámetros de bloque
dialog.title.extract.lambda.parameter=Extracción de parámetros lambda
dialog.message.lambdas.not.supported=Lambda no es compatible con la versión estándar actual
dialog.message.lambdas.cant.extract.initializer.list=No se puede extraer la lista de inicializadores al parámetro lambda
dialog.message.lambdas.cant.extract.functional.type=La expresión del tipo de función no se puede extraer como parámetro lambda
dialog.message.lambdas.cant.extract.dependent.types=No se puede extraer la expresión de tipo que depende del parámetro lambda
dialog.message.cant.refactor.operators=No se pueden refactorizar las funciones del operador de C++
button.extract=extracción
dialog.message.cannot.extract.there.are.multiple.exit.points.in.selected.code.fragment=No se puede extraer {0}\nEl fragmento de código seleccionado tiene varios puntos de salida
dialog.message.selected.statements.should.be.inside.function.choice.or.method=La declaración seleccionada debe estar dentro de una función{0,choice, 0\# o método|1\#}
dialog.message.can.t.refactor.with.variable.arguments={0} con argumentos variables no se puede refactorizar
dialog.message.overrides.in.choice.which.out.project={0} anula {1} en |1\#}{2} fuera del proyecto {3,choice, 0\#.
dialog.message.do.you.want.to.proceed.refactoring=¿Le gustaría continuar con la refactorización?
dialog.message.do.you.want.to.refactor.base.s=¿Le gustaría refactorizar el {0} predeterminado?
label.declaration.place=Ubicación de la declaración\:
refactoring.rename.command.name=cambiar nombre
trying.to.rename.0.to.existing.file.name.1=Le gustaría cambiar el nombre de {0} al nombre de archivo existente {1}
file.0.already.exists.in.the.project=El archivo ''{0}'' ya existe en el proyecto
refactoring.rename.0.already.exists.in.1={0} ya existe en {1}
refactoring.rename.0.already.exists.in.the.scope={0} ya está dentro del alcance
dialog.message.name.invalid=El nombre de {0} no es válido
dialog.message.return.type.invalid={0} tiene un tipo de devolución no válido
dialog.message.no.selector.parts.for=No hay ninguna parte selectora para {0}
dialog.message.containing.class.invalid=La clase que contiene "{0}" no es válida
dialog.message.containing.class.outside.project=La clase que contiene "{0}" está fuera del proyecto
dialog.message.selector.part.invalid=La parte del selector ''{0}'' no es válida
dialog.message.parameter.name.invalid=El nombre del parámetro ''{0}'' no es válido
selected.expression.should.be.inside.a.block.statement=La expresión que elijas debe estar dentro de una sintaxis de bloque.
can.t.refactor.the.compound.initializer=El inicializador compuesto no se puede refactorizar
cannot.determine.type.of.the.selected.expression=No se puede determinar el tipo de expresión seleccionada
cannot.perform.refactoring.selected.expression.has.void.type=No se puede realizar la refactorización. La expresión que seleccionó contiene una variable nula.
selected.expression.cannot.be.a.constant.initializer=La expresión seleccionada no puede ser un inicializador constante.
selected.expression.should.be.inside.an.instance.method=La expresión seleccionada debe estar dentro de un método de instancia.
selected.expression.should.be.inside.a.function.or.method=La expresión que elijas debe estar dentro de una función o método
can.t.introduce.parameter.to.a.function.with.default.parameter.values=No se pueden insertar parámetros en funciones con valores de parámetros predeterminados
selected.expression.should.be.inside.an.instance.method1=La expresión seleccionada debe estar dentro de un método de instancia.
property.inplace.introducer.label.semantics=significado
declaration.must.have.one.declarator.to.introduce.the.type=La declaración debe tener un declarador para insertar el tipo.
namespace.qualifier.should.be.resolved.to.the.class=Los calificadores de espacios de nombres deben resolverse en clases.
the.type.is.empty=el tipo está vacío
can.t.extract.type.of.0.definition=No se puede extraer el tipo de definición {0}
dialog.message.can.t.move.to.itself=No se puede mover ''{0}'' hacia uno mismo
dialog.message.can.t.copy.to.itself=No se puede copiar ''{0}'' a uno mismo
dialog.message.directory.already.exists.at=El directorio ya existe en ''{0}''
dialog.message.file.already.exists.at=El archivo ya existe en ''{0}''
dialog.message.file.already.exists=El archivo ya existe
extract.dialog.button.extract=&Extracto
escalate.visibility.member.column=miembro
escalate.visibility.current.visibility.column=visibilidad actual
escalate.visibility.required.visibility.column=Visibilidad que necesitas
push.down.inheritor.column=heredero
text.parameter.initializer.not.available.in=El inicializador de parámetros no está permitido en {0}. {Uno}
cannot.inline.function.type=El tipo de función no se puede insertar
cannot.inline.constructor.expression=La expresión del constructor no se puede insertar
can.t.inline.definition=No se puede insertar la definición {0}
cannot.inline.the.macro.inside.another.macro.definition=Las macros dentro de otras definiciones de macros no se pueden insertar
cannot.find.the.method.function=Método/función no encontrado
there.are.usages.in.other.blocks=Otros bloques tienen ubicaciones de uso.
0.was.not.initialized={0} no se ha inicializado
there.are.several.definitions.of=Hay varias definiciones de {0}
the.address.of.is.taken=La dirección de {0} está en uso
element.is.written.in.the.block={0} está escrito en bloque
several.definitions.of.0=Hay varias definiciones de {0}
element.is.accessed.for.writing=Se accede a {0} para escribir
cannot.inline.usages.inside.the.macro.substitutions=Los usos dentro de macrosustituciones no se pueden incluir en línea
element.has.inheritor={0} tiene heredero {1,choice, 0\#método|1\#función}
element.inherits.method={0} hereda métodos de {1}
cannot.inline.method.reference.in.selector.expression=Las referencias a métodos en la expresión ''@selector'' no se pueden incluir entre líneas.
cannot.inline.method.reference.in.xml.file=Las referencias a métodos en archivos XML no se pueden insertar
cannot.inline.method.reference.in.property.attribute=Las referencias a métodos en los atributos de propiedad no se pueden incluir en línea
cannot.inline.function.reference.in.non.call.expression=Las referencias a funciones en expresiones que no son de llamada no se pueden insertar en línea
cannot.inline.usage.in.swift.code=Los usos en el código Swift no se pueden insertar
cannot.inline.recursive=La llamada recursiva {0} no se puede insertar
dialog.message.elements.to={0} elemento por hacer
top.level.namespace.placeholder=espacio de nombres de nivel superior
