plugin.settings.title=Lombok
config.warn.dependency.outdated.title=Las dependencias de Lombok pueden estar desactualizadas
config.warn.dependency.outdated.message=<br>El proyecto "{0}" y el módulo "{1}" parecen tener agregada una antigua dependencia de lombok.<br>La versión configurada es "{2}", pero ya se ha agregado una versión posterior a "{3}". ha sido lanzado Sí<br><a href="https://projectlombok.org/download">¿Quieres actualizar?</a><br>
replace.with.annotations.lombok=Reemplazar con anotaciones (Lombok)
replace.0.with.explicit.type.lombok=Convertir ''{0}'' a un tipo explícito (Lombok)
replace.explicit.type.with.0.lombok=Cambiar tipo explícito a ''{0}'' (Lombok)
dialog.message.logger.field.s.not.private.sfinal.field.named.s.refactor.anyway=Campo de registro: "{0}" no es un campo final privado {1,choice,0#|1 #static} con nombre "{2}". ¿Aún te gustaría refactorizarlo?
dialog.title.attention=¡precaución!
dialog.message.this.element.cannot.be.renamed=No puede cambiar el nombre de este elemento.
inspection.message.lombok.annotation.deprecated.not.supported=La anotación de Lombok ''{0}'' está obsoleta y no es compatible con el complemento de Lombok. Utilice ''{1}'' en su lugar.
inspection.message.default.constructor.doesn.t.exist=No hay un constructor predeterminado
inspection.message.slf4j.logger.defined.explicitly=El registrador Slf4j está definido explícitamente. Utilice la anotación Lombok @Slf4j en su lugar.
intention.name.replace.with.lombok=Cambiar a Lombok
attribute.descriptor.key=Clave
attribute.descriptor.separator=separador
attribute.descriptor.value=valor
configurable.name.lombok.config=Configuración de Lombok
filetype.lombok.config.description=Archivo de configuración de Lombok
inspection.message.annotation.not.lombok.copyable=Lombok no copia la anotación ''{0}'' al constructor
inspection.message.val.works.only.on.local.variables='val' solo funciona con variables locales y bucles foreach\n
inspection.message.var.works.only.on.local.variables.on.for.foreach.loops='var' sólo funciona con variables locales y bucles for/foreach
inspection.message.on.local.variable.requires.initializer.expression=La variable local ''{0}'' requiere una expresión inicializadora
inspection.message.not.compatible.with.array.initializer.expressions=''{0}'' no es compatible con expresiones de inicializador de matriz. Utilice el formulario completo (nuevo int[ ] '{'... '}', no '{'... '}')
inspection.message.not.allowed.with.lambda.expressions=''{0}'' no está permitido en la expresión lambda.
inspection.message.not.allowed.in.old.style.for.loops=''{0}'' no está permitido en bucles for antiguos
intention.name.remove.annotation.parameter.s=Eliminar el parámetro de anotación ''{0}''
intention.name.set.annotation.parameter.s.s=Establecer parámetro de anotación {0}="{1}"
intention.name.create.new.field.s=Crear nuevo campo ''{0}''
inspection.message.utility.class.already.marks.class.final=@UtilityClasss ya está marcando la clase como final.
inspection.message.utility.class.already.marks.fields.static=@UtilityClasss ya está marcando el campo como estático.
inspection.message.utility.class.already.marks.methods.static=@UtilityClasss ya está marcando el método como estático.
inspection.message.utility.class.already.marks.inner.classes.static=@UtilityClasss ya está marcando la clase interna como estática.
inspection.message.val.already.marks.variables.final='val' ya marca variable final.
inspection.message.value.already.marks.class.final=@Value ya está marcando la final de clase.
inspection.message.value.already.marks.non.static.fields.final=@Value ya está marcando un campo no estático como final.
inspection.message.value.already.marks.non.static.package.local.fields.private=@Value ya está marcando campos no estáticos y locales del paquete como privados.
inspection.message.cleanup.method.s.not.found.on.target.class='@Cleanup': método '%s()' no encontrado en la clase de destino
inspection.message.cleanup.legal.only.on.local.variable.declaration.inside.block='@Cleanup': sólo se puede utilizar en declaraciones de variables locales dentro de bloques
inspection.message.cleanup.variable.declarations.need.to.be.initialized=Se debe inicializar la declaración de la variable '@Cleanup'.
inspection.message.cleanup.value.cannot.be.empty.string='@Cleanup': el valor no puede ser una cadena vacía
inspection.message.cleanup.legal.only.on.local.variable.declarations='@Cleanup' solo se puede utilizar en declaraciones de variables locales
inspection.message.synchronized.legal.only.on.concrete.methods='@Synchronized' solo se puede utilizar en métodos concretos.
inspection.message.synchronization.on.non.final.field.s=Sincronizando en el campo no final %s.
inspection.message.field.s.does.not.exist=El campo %s no existe.
inspection.message.synchronized.legal.only.on.methods='@Synchronized' solo se puede utilizar en métodos.
inspection.message.field.s.does.not.exist.exclude=El campo ''{0}'' no existe
inspection.message.field.s.would.have.been.excluded.anyway=El campo ''{0}'' ha sido excluido por la fuerza
inspection.message.field.s.does.not.exist.field=El campo ''{0}'' no existe
inspection.message.data.only.supported.on.class.type='@Data' solo se admite en tipos de clase
inspection.message.exclude.are.mutually.exclusive.exclude.parameter.will.be.ignored=excluir y de son mutuamente excluyentes. El parámetro 'excluir' se ignora
inspection.message.equals.and.hashcode.only.supported.on.class.type=@EqualsAndHashCode solo se admite en tipos de clase
inspection.message.not.generating.equals.hashcode=No genera iguales ni hashCode. Ya existe un método con uno de estos nombres. (Todos estos métodos se generan o no se genera ninguno).
inspection.message.generating.equals.hashcode.with.super.call=Crear equals/hashCode usando una llamada principal java.lang.Object no tiene sentido.
inspection.message.generating.equals.hashcode.implementation=Incluso si esta clase no extiende java.lang.Object, generará una implementación igual/hashCode sin llamar a la clase principal. Si es intencional, agregue '(call Super=false)' al tipo.
inspection.message.lazy.not.supported.for.getter.on.type='lazy' no es compatible con @Getter especificado en el tipo
inspection.message.getter.only.supported.on.class.enum.or.field.type='@Getter' solo se admite en clases, enumeraciones o tipos de campos
inspection.message.s.only.supported.on.class.or.field.type='@%s' solo se admite en tipos de clase o campo
inspection.message.to.string.only.supported.on.class.or.enum.type=@ToString solo se admite en tipos de clase o enumeración
inspection.message.not.generated.s.method.with.same.name.already.exists='%s'() no fue creado. Ya existe un método con el mismo nombre.
inspection.message.utility.classes.cannot.have.declared.constructors=@UtilityClasses no puede tener un constructor declarado.
inspection.message.utility.class.only.supported.on.class=@UtilityClass solo se admite en clases (no en interfaces, enumeraciones o anotaciones).
inspection.message.utility.class.automatically.makes.class.static=@UtilityClass configura automáticamente una clase como estática, pero esta clase no se puede configurar como estática.
inspection.message.utility.class.cannot.be.placed=@UtilityClass no se puede colocar en métodos locales ni en clases internas anónimas ni en clases anidadas dentro de dichas clases.
inspection.message.value.only.supported.on.class.type='@Value' solo se admite en tipos de clase
inspection.message.wither.only.supported.on.class.or.field=@Wither solo se admite en clases o campos.
inspection.message.annotation.only.supported.on.class.or.enum.type=Las anotaciones solo se admiten en clases o enumeraciones.
inspection.message.lombok.needs.default.constructor.in.base.class=Lombok requiere un constructor predeterminado en la clase base
inspection.message.constructor.without.parameters.already.defined=Un constructor sin parámetros ya está definido.
inspection.message.constructor.with.d.parameters.already.defined=El constructor con el parámetro ''{0}'' ya está definido
inspection.message.method.s.matched.static.constructor.name.already.defined=El método ''{0}'' que coincide con staticConstructorName ya está definido
inspection.message.method.s.with.d.parameters.matched.static.constructor.name.already.defined=El método ''{0}'' con el parámetro ''{1}'' que coincide con staticConstructorName ya está definido
inspection.message.field.name.constants.only.supported.on.class.or.enum='@FieldNameConstants' solo se admite en clases o enumeraciones
inspection.message.field.name.constants.only.supported.on.class.enum.or.field.type='@FieldNameConstants' solo se admite en clases, enumeraciones o tipos de campos
inspection.message.field.name.constants.inner.type=El tipo interno @FieldNameConstants ya existe, pero asEnum={0} no coincide con un tipo existente
inspection.message.s.legal.only.on.classes.enums=@%s solo se puede usar en clases y enumeraciones
inspection.message.not.generating.field.s.field.with.same.name.already.exists=El campo %s no se creará. Ya existe un campo con el mismo nombre.
inspection.message.custom.log.not.configured.correctly=@CustomLog no está configurado correctamente. Establezca log.custom.declaration en lombok.config.
inspection.message.custom.log.does.not.allow.topic=@CustomLog no acepta temas.
inspection.message.custom.log.requires.topic=@CustomLog necesita un tema.
inspection.message.not.generating.constant=No cree una constante para este campo. El nombre de la constante es el mismo que el nombre del campo.
inspection.message.lazy.does.not.work.with.access.level.none='Lazy' no funciona en el nivel de acceso. NINGUNO.
inspection.message.lazy.requires.field.to.be.private.final='perezoso' requiere que los campos sean privados y finales
inspection.message.lazy.requires.field.initialization='lazy' requiere inicialización del campo.
inspection.message.annotation.copy.duplicate=La anotación ''{0}'' ya existe en el campo, por lo que es redundante con la configuración de onX.
inspection.message.not.generating.getter.for.this.field=No crea un captador para este campo. @Accessors no es adecuado para listas de prefijos.
inspection.message.not.generated.s.method.with.similar.name.s.already.exists=No genera '%s'(). Ya existe un método con nombre similar '%s'
inspection.message.not.generating.setter.for.this.field.it=No cree un definidor para este campo. @Accessors no es adecuado para listas de prefijos.
inspection.message.not.generating.setter.for.this.field.setters=No cree un definidor para este campo. No se puede crear un definidor para un campo final.
inspection.message.wither.needs.constructor.for.all.fields.d.parameters=@Wither requiere constructor para todos los campos (parámetro %d)
inspection.message.not.generating.s.method.with.that.name.already.exists=No produce %s(). Ya existe un método con el mismo nombre.
inspection.message.not.generating.wither.for.this.field.withers=No cree un marchitamiento para este campo. La cruz no se puede crear en campos que comiencen con $.
inspection.message.not.generating.wither=No cree un marchitamiento para este campo. La cruz no se puede crear en campos estáticos.
inspection.message.not.generating.wither.for.this.field.withers.cannot.be.generated=No cree un marchitamiento para este campo. Withers no se puede crear en campos finales inicializados.
inspection.message.s.can.be.used.on.classes.only=@%s solo se puede usar en clases
inspection.message.syntax.either.obtain.via.field=La sintaxis es @ObtainVia(fieldv= "fieldName") o @ObtainVia(method="methodName").
inspection.message.lombok.annotations.are.not.allowed.on.builder.class=No se permiten anotaciones de Lombok en las clases de constructor.
inspection.message.s.not.valid.identifier=%s no es un identificador válido.
inspection.message.can.t.singularize.this.name=Este nombre no se puede singularizar. "%s". Especifique el tipo singular explícitamente (por ejemplo, @Singular("oveja"))
inspection.message.lombok.does.not.know=Lombok no puede crear un método de construcción singular de tipo '%s'. El método constructor no se crea.
inspection.message.builder.default.requires.initializing.expression=@Builder.Default requiere una expresión de inicialización ('=algo;').
inspection.message.builder.default.singular.cannot.be.mixed=@Builder.Default y @Singular no se pueden usar juntos.
inspection.message.obtain.via.is.static.true.not.valid.unless.method.has.been.set=@ObtainVia(isStatic=true) no es válido si no se establece el 'método'.
inspection.message.delegate.does.not.support.recursion.delegating=@Delegate no admite la recursividad (delegar a tipos que a su vez tienen miembros @Delegate). El miembro "%s" es un @Delegate de tipo "%s"
inspection.message.delegate.legal.only.on.instance.fields=@Delegate solo se puede utilizar en campos de instancia o métodos de instancia que no toman argumentos.
inspection.message.delegate.can.only.use.concrete.class.types=@Delegate solo puede usar comodines, matrices, variables de tipo o tipos de clases concretos, no tipos primitivos. '%s' es un tipo de clase no válido
inspection.message.existing.builder.must.be.abstract.static.inner.class=El constructor existente debe ser una clase interna estática abstracta.
inspection.message.delegate.legal.only.on.no.argument.methods=@Delegate solo se puede utilizar en métodos de instancia que no toman argumentos.
action.defaultLombokData.text=@Datos predeterminados
action.defaultLombokData.description=Acción para reemplazar los métodos getter/setter/equals/hashcode/toString con la anotación Lombok @Data
action.defaultLombokSetter.text=@Setter predeterminado
action.defaultLombokSetter.description=Acción para reemplazar todos los métodos de establecimiento con la anotación @Setter de Lombok
action.defaultLombokEqualsAndHashcode.text=Predeterminado @EqualsAndHashCode
action.defaultLombokEqualsAndHashcode.description=Acción para reemplazar los métodos iguales/código hash con la anotación Lombok @EqualsAndHashcode
action.defaultLombokToString.text=@ToString predeterminado
action.defaultLombokToString.description=Acción para reemplazar el método toString con la anotación @ToString de Lombok
action.defaultLombokLogger.text=@Log (y amigos)
action.defaultLombokLogger.description=Acción para reemplazar todos los registradores con la anotación @Log de Lombok
group.DelombokActionGroup.text=Delombok
group.DelombokActionGroup.description=Refactorice su código eliminando las anotaciones de Lombok
action.delombokAny.text=Todas las anotaciones de Lombok
action.delombokAny.description=Acción para convertir todas las anotaciones de Lombok a métodos básicos de Java
action.delombokData.text=@Data
action.delombokData.description=Acción para convertir la anotación @Data de Lombok al método Java básico
action.delombokValue.text=@Value
action.delombokValue.description=Acción para convertir la anotación @Value de Lombok al método Java básico
action.delombokWither.text=@Wither
action.delombokWither.description=Acción para convertir la anotación Lombok @Wither al método Vanila Java
action.delombokDelegate.text=@Delegate
action.delombokDelegate.description=Acción para convertir la anotación @Delegate de Lombok al método Vanila Java
action.delombokBuilder.text=@Builder
action.delombokBuilder.description=Acción para convertir la anotación Lombok @Builder al método Vanila Java
action.delombokSuperBuilder.text=@SuperBuilder
action.delombokSuperBuilder.description=Acción para convertir la anotación Lombok @SuperBuilder al método Vanila Java
action.delombokConstructor.text=@Constructors
action.delombokConstructor.description=Acción para convertir las anotaciones @NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor de Lombok en métodos Java básicos
action.delombokGetter.text=@Getter
action.delombokGetter.description=Acción para convertir la anotación @Getter de Lombok al método getter de Vanila
action.delombokSetter.text=@Setter
action.delombokSetter.description=Acción para convertir la anotación @Setter de Lombok al método setter de Vanila
action.delombokEqualsAndHashCode.text=@EqualsAndHashCode
action.delombokEqualsAndHashCode.description=Acción para convertir la anotación Lombok @EqualsAndHashCode al método Vanila Java
action.delombokToString.text=@ToString
action.delombokToString.description=Acción para convertir la anotación Lombok @ToString al método Vanila Java
action.delombokLogger.text=@Log (y amigos)\n
action.delombokLogger.description=Acción para convertir las anotaciones @Log de Lombok (y otras) en campos de registro de Vanila
action.delombokFieldNameCostants.text=@FieldNameConstants
action.delombokFieldNameCostants.description=Acción para convertir la anotación @FieldNameConstants de Lombok en un campo Java básico
action.delombokUtilityClass.text=@UtilityClass
action.delombokUtilityClass.description=Acción para convertir la anotación @UtilityClass de Lombok al campo Vanila Java
action.defaultLombokGetter.text=@Getter predeterminado
action.defaultLombokGetter.description=Acción para reemplazar todos los métodos getter con la anotación @Getter de Lombok
group.LombokActionGroup.text=Lombok
group.LombokActionGroup.description=Refactorice su código con anotaciones de Lombok
inspection.redundant.modifiers.val.lombok.display.name=Final innecesario antes de 'val'
inspection.redundant.slf.4.j.definition.display.name=@Slf4j
inspection.redundant.modifiers.utility.class.lombok.display.name=Controlador @UtilityClass
inspection.redundant.modifiers.value.lombok.display.name=@Controlador de valor
inspection.springqualifiercopyable.lombok.display.name=@Qualifier no se puede copiar a Lombok
inspection.deprecated.lombok.display.name=Anotaciones de Lombok que pronto quedarán obsoletas
inspection.lombok.display.name=Anotaciones de Lombok
checkbox.settings.version.warning=Habilitar advertencia de versión de Lombok
inspection.lombok.group.name.lombok=Lombok
inspection.lombok.group.name.redundant.modifiers=controlador innecesario
inspection.lombok.group.name.redundant.definitions=definición innecesaria
intention.category.lombok=Java/Lombok
