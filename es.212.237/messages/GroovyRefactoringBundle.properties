introduce.variable.title=Insertar variable
only.in.groovy.files=Esta refactorización sólo está disponible para archivos Groovy.
selected.block.should.represent.an.expression=El bloque seleccionado debe representar una expresión.
refactoring.is.not.supported.in.the.current.context=La refactorización no es compatible en el contexto actual.
refactoring.is.not.supported.in.method.parameters=La refactorización no se admite en cierres o parámetros de métodos.
declare.final.checkbox=Declarar y final
press.escape.to.remove.the.highlighting=Para eliminar el resaltado, presione ESC.
selected.expression.has.void.type=La expresión seleccionada tiene tipo void
introduced.variable.conflicts.with.parameter.0=La variable insertada entra en conflicto con el parámetro {0}.
introduced.variable.conflicts.with.variable.0=La variable insertada entra en conflicto con la variable local {0}.
cannot.find.a.single.definition.to.inline.local.var=No puedo encontrar una definición única para insertar una variable local.
cannot.find.a.single.definition.to.inline.field=No existe un inicializador para ese campo.
local.variable.is.lvalue=La variable que se va a incluir se utiliza como valor l en la asignación.
inline.local.variable.prompt.0.1=¿Quiere incorporar la variable local ''{0}''?
extract.method.title=Extracción del método
selected.block.should.represent.a.statement.set=El bloque seleccionado debe representar una declaración o colección de expresiones.
multiple.output.values=El fragmento de código seleccionado tiene múltiples valores de salida.
selected.block.contains.invocation.of.another.class.constructor=El bloque seleccionado contiene una llamada a otro constructor de clase.
specify.type.label=Especifique explícitamente el tipo de devolución
signature.preview.border.title=Vista previa de firma
method.is.already.defined.in.class=El método {0} ya está definido en la clase {1}.
method.is.already.defined.in.script=El método {0} ya está definido en el script {1}.
inline.method.title=método en línea
inline.method.border.title=en línea
inline.method.label=Método {0}
all.invocations.and.remove.the.method=Incorporar todas las llamadas y eliminar métodos.
all.invocations.in.project=Integrar todas las llamadas dentro de un proyecto
this.invocation.only.and.keep.the.method=Insertar solo esta llamada y mantener el método.
refactoring.cannot.be.applied.to.abstract.methods=La refactorización no se puede aplicar a métodos abstractos.
refactoring.cannot.be.applied.no.sources.attached=No se puede aplicar la refactorización porque no hay ninguna fuente conectada.
refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=No se admite la refactorización cuando una declaración de devolución interrumpe el flujo de ejecución.
refactoring.cannot.be.applied.to.constructors=La refactorización no se puede aplicar a los constructores.
refactoring.is.not.supported.in.parameter.initializers=La refactorización no es compatible con los inicializadores de parámetros.
refactoring.is.available.only.for.method.calls=La refactorización solo está disponible en llamadas a métodos.
method.is.not.accessible.form.context.0=No se puede acceder al método {0} utilizado en el método incorporado desde el sitio de llamada.
field.is.not.accessible.form.context.0=No se puede acceder al campo {0} utilizado en el método en línea en el sitio de la llamada.
super.reference.is.used=Las llamadas a los padres utilizadas en un método integrado dejan de ser válidas después de la integración.
variable.conflicts.with.parameter.0=El nombre que seleccionó entra en conflicto con el parámetro {0}.
variable.conflicts.with.variable.0=El nombre que seleccionó entra en conflicto con la variable local {0}.
variable.conflicts.with.field.0=El nombre que seleccionó entra en conflicto con el campo {0}.
error.wrong.caret.position.method.name=El símbolo de intercalación debe colocarse sobre el nombre del método que se va a refactorizar.
method.duplicate=El método con firma {0} ya está definido en {1}
replace.setter.for.property=Se sobrescribirá el configurador predeterminado para la propiedad ''{0}''.
replace.getter.for.property=Se sobrescribe el captador predeterminado para la propiedad ''{0}''.
name.is.wrong=El nombre ''{0}'' no es válido.
return.type.is.wrong=El tipo de devolución no es válido.
type.for.parameter.is.incorrect=El parámetro ''{0}'' tiene un tipo no válido.
specify.default.value=Especificación de un valor predeterminado o inicializador para el parámetro ''{0}''
refactored.method.will.cover.closure.property=El método refactorizado anula la propiedad de cierre ''{0}'' dentro de {1}.
changeSignature.not.throwable.type=Tipo no válido\: ''{0}'' para la excepción debe extender java.lang.Throwable.
changeSignature.wrong.type.for.exception=Tipo no válido\: ''{0}'' en excepción
changeSignature.no.type.for.exception=Debe especificar un tipo para la excepción.
no.occurrences.found=No encuentro dónde usarlo.
class.does.not.exist.in.the.module=No hay clases en el módulo. ¿Quieres crear una clase?
closure.uses.external.variables=El cierre utiliza una variable externa que no es una constante.
class.language.is.not.groovy=El idioma de la clase de destino no es Groovy.
implicit.getter.will.by.overridden.by.method=El método {1} anula el captador implícito de la propiedad {0}
implicit.setter.will.by.overridden.by.method=El método {1} anula el definidor implícito de la propiedad {0}
usage.will.be.overridden.by.method=El método {1} anula el uso {0}
target.class.must.not.be.script=La clase de destino no debe ser un guión.
rename.is.not.applicable.to.implicit.elements=No se puede cambiar el nombre de un elemento implícito.
rename.member={0} cambio de nombre
rename.property=Cambiar el nombre de la propiedad ''{0}''
cannot.introduce.field.in.script=No hay clases en el alcance.
cannot.introduce.field.in.interface=No puede insertar campos en una interfaz.
expression.contains.errors=La expresión contiene un error.
field.0.is.already.defined=El campo {0} ya está definido.
access.to.created.field.0.will.be.overridden.by.method.1={1} anula el acceso al campo {0}
final.field.cant.be.initialized.in.cur.method=Los campos finales no se pueden inicializar en el método actual
Field.cannot.be.final.because.replaced.variable.has.lhs.usages=La variable seleccionada se utilizará para escribir.
field.cannot.be.initialized.in.field.declaration=Los campos no se pueden inicializar en la declaración.
field.cannot.be.initialized.in.constructor(s)=Los campos no se pueden inicializar en el constructor.
selected.variable.is.used.for.write=La variable seleccionada se utilizará para escribir.
there.is.no.method.or.closure=No hay métodos integrados ni cierres.
remove.parameter.0.no.longer.used=Eliminar el parámetro obsoleto ''{0}''
convert.to.java.refactoring.name=Convertir a Java
convert.to.java.can.work.only.with.groovy=La refactorización de Convertir a Java solo funciona con archivos Groovy.
files.to.be.converted=Archivo para convertir
converting.files.to.java=Convertir archivos a Java
converting.files.to.static=Convirtiendo archivo a @CompileStatic
intention.converting.to.static=Aplicar transformación con @CompileStatic
intention.converting.to.static.family=Convertir a @CompileStatic
rename.groovy.property=Cambiar el nombre de la propiedad Groovy
reference.to.accessor.0.is.used=La referencia al descriptor de acceso <bold>{0}<bold> no se puede incluir en línea.
variable.is.accessed.for.writing=Se accede a la variable ''{0}'' para escribir
introduce.closure.parameter.elements.header=Agregar parámetros al cierre
cannot.process.usage.in.language.{0}=No se pudo procesar mi ubicación de uso {0}.
you.cannot.pass.as.parameter.0.because.you.remove.1.from.base.method=''{0}'' no se puede pasar como parámetro porque elimina el parámetro asociado ''{1}'' del método. Debe desmarcar "Eliminar el parámetro ''{0}'' que ahora no se utiliza" o desmarcar el parámetro ''{1}'' en la tabla de parámetros.
selected.expression.should.not.be.lvalue=La expresión que elijas no debe estar en el lado izquierdo de la tarea.
cannot.inline.0.={0} no se puede incluir en línea.
ref.0.will.not.be.resolved.outside.of.current.context=La referencia ''{0}'' no se resuelve fuera del contexto actual.
cannot.rename.property.0=No se puede cambiar el nombre de la propiedad <bold>''{0}''</bold> que anula el método <bold>''{1}''</bold>.
cannot.inline.reference.0=La referencia ''{0}'' no se puede insertar.
cannot.rename.script.class.to.0=No se puede cambiar el nombre de la clase de secuencia de comandos ''{0}'' a ''{1}''.
extract.method.dialog.explicit.return.checkbox=Utilice una declaración de devolución explícita (&X)
inplace.introduce.constant.move.checkbox=Pasar a otra clase
type.label=Escriba &T\:
name.label=&Nombre\:
introduce.constant.class.label=Insertar como clase (nombre completo)\:
replace.all.occurrences.checkbox=&Reemplazar todos los usos
initialize.in.label=&Inicializar desde\:
initialize.in.border.title=Inicializar desde
initialize.in.current.method.choice=&Método actual
initialize.in.field.declaration.choice=&Declaración de campo
initialize.in.class.constructor.choice=Constructor de clase (&C)
initialize.in.setup.method.choice=método de configuración
visibility.border.title=visibilidad
visibility.private.choice=&Privado
visibility.public.choice=Public(&B)
visibility.protected.choice=&Protegido
visibility.property.choice=&Propiedades
