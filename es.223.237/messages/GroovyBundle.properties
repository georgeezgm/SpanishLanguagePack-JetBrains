language.groovy=Maravilloso
filetype.groovy.description=Maravilloso
filetype.dgm.description=Archivo descriptor del módulo de extensión Groovy
filetype.dgm.display.name=DGM
filetype.logback.description=Configuración de DSL de inicio de sesión de Groovy
filetype.logback.display.name=DSL de inicio de sesión maravilloso
filetype.gdsl.description=Configuración de IntelliJ Groovy DSL
filetype.gdsl.display.name=DSL maravilloso
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.text=PropiedadFalta()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.description=La acción genera la propiedad Missing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.text=MétodoFalta()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.description=La acción genera la propiedad Missing()
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.text=Es igual a() y hashCode()
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.description=La acción ahora genera iguales y hashCode.
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.text=Captadores y definidores
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.description=Crear captador
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.text=Conjuntos
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.description=Crear colocador
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.text=Adquiridor
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.description=Crear captador
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.text=Constructor
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.description=Creación del constructor
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.text=Encadenar()
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.description=Crea un método toString().
action.ExcludeFromStubGeneration.text=Excluir de la generación de resguardos
action.ExcludeFromStubGeneration.description=No genere resguardos de Java para archivos Groovy en el momento de la compilación
action.DumpGroovyControlFlowAction.text=Volcado de flujo de control maravilloso
action.ConvertToCompileStatic.text=Convertir a @CompileStatic
action.ConvertToCompileStatic.description=Convierta archivos Groovy a @CompileStatic
action.ConvertGroovyToJava.text=Convertir a Java
action.ConvertGroovyToJava.description=Convertir archivos Groovy a Java
action.Groovy.NewScript.text=Guión maravilloso
action.Groovy.NewScript.description=Crea un nuevo script Groovy
action.Groovy.NewClass.text=Clase maravillosa
action.Groovy.NewClass.description=Crea una nueva clase Groovy
action.Groovy.CheckResources.Rebuild.text=Reconstruir recurso (_R)
action.Groovy.CheckResources.Rebuild.description=Ejecute el compilador para todos los archivos Groovy en la raíz de recursos para verificar si hay problemas de compilación
action.Groovy.CheckResources.Make.text=Construcción de recursos (_B)
action.Groovy.CheckResources.Make.description=Ejecute el compilador incremental en archivos Groovy en la raíz de recursos para verificar si hay problemas de compilación.
group.Groovy.CheckResources.text=Recursos maravillosos (_O)
group.Groovy.CheckResources.description=Ejecute el compilador para todos los archivos Groovy en la raíz de recursos para verificar si hay problemas de compilación
file.template.group.title.groovy=Maravilloso
groovy.term.class=Clase
groovy.term.interface=Interfaz
groovy.term.trait=Característica
groovy.term.enum=Enumeración
groovy.term.annotation=Anotación
groovy.term.method=Método
groovy.term.field=Campo
groovy.term.property=Propiedades
groovy.term.parameter=Parámetro
groovy.term.variable=Variable local
groovy.term.binding=Variables de enlace de script
groovy.term.label=Etiqueta
groovy.term.closure=Cierre
groovy.term.expression=Expresión
new.class.action.text=Clase maravillosa
new.class.action.description=Crea una nueva clase Groovy
new.class.dialog.title=Nueva clase Groovy
new.class.list.item.class=Clase
new.class.list.item.interface=Interfaz
new.class.list.item.trait=Característica
new.class.list.item.enum=Enumeración
new.class.list.item.annotation=Anotación
invalid.qualified.name=No es un nombre válido y completo de Groovy
new.script.action.text=Guión maravilloso
new.script.action.description=Crea un nuevo script Groovy
new.script.dialog.title=Ingrese un nuevo nombre de script Groovy
new.script.list.item.script=Guión maravilloso
new.script.list.item.script.dsl=Guión GroovyDSL
new.gant.script.dialog.title=Nuevo guión de Gant
new.gant.script.dialog.message=Introduzca un nuevo nombre de secuencia de comandos Gant
debug.option=&Habilitar seguimiento de pila de depuración
groovy.debug.disable.specific.methods=&No entres en clases específicas de Groovy
groovy.debug.caption=Maravilloso
identifier.expected=Se requiere un identificador
identifier.or.block.expected=Se requiere un identificador o bloque de código.
string.end.expected=Se requiere el final de la cadena.
try.without.catch.finally=''intentar'' no contiene ''catch'' ni ''finalmente''.
expression.expected=Se requiere expresión
duplicate.modifier=Controlador duplicado ''{0}''
cannot.resolve=El símbolo ''{0}'' no se puede resolver
cannot.access=El acceso a ''{0}'' excede sus permisos de acceso.
cannot.reference.non.static=No se puede hacer referencia al símbolo no estático ''{0}'' en un contexto estático.
cannot.return.from.constructor=No puedes devolver un objeto desde un constructor.
cannot.return.from.void.method=Un método que devuelve ''void'' no puede devolver un objeto.
cannot.return.type=El método que devuelve ''{1}'' no puede devolver ''{0}''
cannot.apply.method.or.closure={0}'' no se puede aplicar a ''{1}
cannot.apply.method1={0}'' de ''{1}'' no se puede aplicar a ''{2}
cannot.apply.constructor=El constructor ''{0}'' de ''{1}'' no se puede aplicar a ''{2}''.
cannot.apply.default.constructor=No se puede aplicar el constructor predeterminado para la clase ''{0}''.
cannot.instantiate.abstract.class=No se puede crear una instancia de la clase abstracta ''{0}''.
cannot.instantiate.interface=No se puede crear una instancia de la interfaz ''{0}''.
missing.required.named.parameter=Falta el parámetro requerido llamado ''{0}''.
loss.of.precision=Es posible que se pierda precisión de ''{0}'' a ''{1}''.
cannot.assign=''{0}'' no se puede asignar a ''{1}''.
cannot.cast=No se puede transmitir ''{0}'' a ''{1}''.
multiple.assignments.without.list.expr=No se admiten varias asignaciones sin una expresión de lista a la derecha en el modo de verificación de tipo estático.
spread.operator.is.not.available=La verificación de tipos estáticos no permite utilizar el operador de extensión como argumento.
replace.with.list.literal=Reemplace la lista con un literal.
replace.with.get.at=Reemplace con acceso al índice.
incorrect.number.of.values=El número de valores es incorrecto. Valor esperado\: {0}, Valor actual\: {1}
invalid.lvalue=El valor a sustituir es incorrecto.
duplicate.class=La clase ''{0}'' ya existe en ''{1}''.
duplicate.inner.class=Clase duplicada\: ''{0}''
script.generated.with.same.name=Hay una clase de integración generada ''{0}'' para su código de secuencia de comandos.
variable.already.defined=La variable ''{0}'' ya está definida.
field.already.defined=El campo ''{0}'' ya está definido.
create.class.family.name=Crear clase
create.class.text=Crear clase {0}
create.interface.text=Crear interfaz {0}
create.annotation.text=Crear anotación {0}
constructors.are.not.allowed.in.anonymous.class=No se permiten constructores en clases anónimas.
no.such.property=La propiedad ''{0}'' no existe.
change.modifier=Hacer de ''{0}'' un {1}
change.modifier.not=Hacer ''{0}'' no {1}
change.modifier.family.name=Cambiar controlador
parameter.cast.fix=Convierte el {0,número,ordinal}ésimo parámetro a {1}.
action.convert.lambda.to.closure=Convertir lambda en cierre
add.parenthesis.to.lambda.parameter.list=Agregar paréntesis a la lista de parámetros
packageLocal.visibility.presentation=Visibilidad predeterminada
protected.visibility.presentation=Protegido
private.visibility.presentation=Privado
public.visibility.presentation=Público
abstract.visibility.presentation=Abstracto
static.visibility.presentation=Estático
final.visibility.presentation=Final
native.visibility.presentation=Nativo
synchronized.visibility.presentation=Sincronizado
strictfp.visibility.presentation=Estricto
transient.visibility.presentation=Transitorio
volatile.visibility.presentation=Volátil
def.visibility.presentation=Definición
intention.family.name.convert.conditional.expression.to.elvis=Convertir expresión condicional a elvis
intention.family.name.replace.with.keyed.access=Reemplazar con acceso clave
intention.family.name.fix.range.class=Modificar clasificación de rango
intention.family.name.make.return.implicit=Establecer el retorno implícitamente
intention.family.name.simplify=Arrasamiento
intention.family.name.remove.unnecessary.continue=Eliminar continuar innecesario
intention.family.name.remove.unnecessary.return=Eliminar devoluciones innecesarias
intention.family.name.add.parameter.cast=Agregar conversión de tipo de parámetro
intention.family.name.replace.for.each.operator=Reemplazo del operador para cada uno
intention.family.name.add.cast=Agregar conversión de tipo
intention.family.name.change.variable.type=Cambiar tipo de variable
intention.family.name.replace.with.conditional.call=Cambiar a llamada condicional
intention.family.name.collapse.conditional.expressions=Contraer expresiones condicionales
intention.family.name.remove.double.negation=Eliminar doble negativo
intention.family.name.activate.dsl.descriptor=Habilitar descriptor DSL
intention.family.name.collapse.if.statement=Contraer la declaración ''si''
intention.family.name.replace.with.short.circuit.expression=Convertir a expresión de párrafo
intention.family.name.replace.something.with=Reemplace ''{0}'' con ''{1}''
intention.family.name.add.attributes.to.annotation=Agregar propiedades a las anotaciones
intention.family.name.fix.quotation=Editar cotizaciones
illegal.combination.of.modifiers=La combinación de controladores es incorrecta
illegal.combination.of.modifiers.abstract.and.final=La combinación de controladores ''abstracto'' y ''final'' no es válida
modifier.volatile.not.allowed.here=El controlador "volátil" no está permitido aquí.
modifier.transient.not.allowed.here=El controlador "transitorio" no está permitido aquí
modifier.0.not.allowed=El controlador ''{0}'' no está permitido aquí
interface.cannot.have.modifier.final=La interfaz no puede tener controlador "final"
script.method.cannot.have.modifier.abstract=El método de script no puede tener un controlador "abstracto"
script.cannot.have.modifier.native=El método de script no puede tener un controlador "nativo"
interface.must.have.no.static.method=Las interfaces no pueden tener métodos estáticos.
only.abstract.class.can.have.abstract.method=Sólo las clases abstractas pueden tener métodos abstractos.
anonymous.class.cannot.have.abstract.method=Las clases anónimas no pueden tener métodos abstractos.
illegal.combination.of.modifiers.volatile.and.final=La combinación de controladores ''abstracto'' y ''final'' no es válida
variable.cannot.be=La variable no puede tener controlador ''{0}''
remove.modifier=Eliminar ''{0}''
not.abstract.method.should.have.body=Los métodos abstractos no deben tener cuerpo.
cannot.create.class.error.text=No se puede crear la clase ''{0}''. {Uno}
cannot.create.class.error.title=No se puede crear la clase
no.class.in.file.template=Clase no encontrada en la plantilla de archivo.
Inner.methods.are.not.supported=El método interno no es compatible.
final.class.cannot.be.extended=Las clases finales no se pueden ampliar.
unsupported.inner.class.0=Las clases internas no son compatibles con Groovy {0}.
unsupported.anonymous.class.0=Groovy {0} no admite clases anónimas.
unsupported.diamonds.0=Los diamantes no son compatibles con Groovy {0}.
unsupported.command.syntax.0=La sintaxis de expresión de comando no es compatible con Groovy {0}.
unsupported.dollar.slashy.string.0=Las cadenas de barras en dólares no se admiten en Groovy {0}.
unsupported.multiline.slashy.string.0=Las cadenas de barras multilínea no se admiten en Groovy {0}.
unsupported.traits.0=El atributo no es compatible con Groovy {0}.
duplicating.named.parameter=El parámetro contiene el parámetro ''{0}'' con nombre duplicado. {Uno}
field.should.be.immutable=El campo ''{0}'' debe tener un tipo inmutable o declararse como un tipo inmutable mediante @ImmutableOptions.
immutable.options.property.not.exist=La propiedad ''{0}'' no existe.
explicit.includes.and.excludes=Solo se debe proporcionar uno de "incluye" y "excluye"
require.closure.as.attribute.value=Necesito un cierre como valor de la propiedad.
initializers.are.forbidden.with.defaults=Deshabilitar los ''valores predeterminados'' en @TupleConstructor significa que los valores predeterminados están prohibidos
super.is.not.allowed.in.pre.with.call.super=Las súper llamadas no están permitidas en ''pre'' con ''callSuper'' habilitado
illegal.default.modifier=El modificador ''predeterminado'' tiene significado sólo dentro de un método de interfaz
illegal.default.modifier.fix=Eliminar el controlador "predeterminado"
default.modifier.in.old.versions=El controlador "predeterminado" está disponible en Groovy 3.0 y posteriores.
unsupported.do.while.statement=''do while'' no es compatible con la versión actual.
unsupported.tuple.declaration.in.for=La declaración de tupla dentro de la inicialización ''for'' no es compatible con la versión actual
unsupported.multiple.variables.in.for=En la versión actual no se admiten múltiples variables dentro de la inicialización ''para''.
unsupported.expression.list.in.for.update=En la versión actual no se admiten varias expresiones dentro de la actualización ''para''.
unsupported.resource.list=''try'' no es compatible con la versión actual.
unsupported.array.initializers=Los inicializadores de matriz no son compatibles con la versión actual.
operator.is.not.supported.in=El operador ''{0}'' no es compatible con la versión actual.
unsupported.negated.in=La ''entrada'' negada no es compatible con la versión actual.
unsupported.negated.instanceof=La ''instancia de'' negada no es compatible con la versión actual.
unsupported.elvis.assignment=La asignación de Elvis no es compatible con la versión actual.
unsupported.safe.index.access=El acceso seguro al índice no es compatible con la versión actual.
unsupported.lambda=Lambda no es compatible con la versión actual.
unsupported.type.annotations=Las anotaciones de tipo no son compatibles con la versión actual.
unsupported.tuple.application.initializer=El inicializador de aplicaciones no es compatible con la versión actual
illegal.single.argument.lambda=Se puede utilizar un único argumento como argumento en la parte derecha de una expresión de asignación o dentro de una llamada a un método.
method.is.not.implemented=El método ''{0}'' no está implementado.
change.implements.and.extends.classes=Normalizar extiende e implementa listas
fix.package.name=Modificar el nombre del paquete
checkbox.delegate.via.overloading.method=Delegación mediante métodos sobrecargados
checkbox.ignore.conditional.operators=Ignorar operadores condicionales
checkbox.ignore.obscure.operators=Ignorar operadores ambiguos
checkbox.ignore.double.checked.locking.on.volatile.fields=Evite bloqueos de doble verificación en campos volátiles
checkbox.inspect.anonymous.closures=Comprobación de cierre anónimo
checkbox.only.warn.if.loop.empty=Advertir sólo si el bucle está vacío
add.dynamic.property=Agregar propiedad dinámica ''{0}''
duplicate.element.in.the.map=Elemento duplicado ''{0}'' en el mapa
dynamic.tool.window.id=Números dinámicos
create.field.from.usage.family.name=Crea campos desde donde los usas
create.field.from.usage=Crear campo ''{0}''
create.method.from.usage.family.name=Crear método en el lugar de uso
create.method.from.usage=Crear método ''{0}''.
create.variable.from.usage.family.name=Crear variable en el punto de uso
create.variable.from.usage=Crear variable ''{0}''
create.parameter.from.usage.family.name=Crear parámetros en el punto de uso.
create.parameter.from.usage=Crear parámetro ''{0}''
add.dynamic.element=Agregar elementos dinámicos
add.dynamic.method=Agregar método dinámico
add.dynamic.method.0=Agregar método dinámico ''{0}''
dynamic.type=Categoría
dynamic.name=Nombre
dynamic.properties.table.name=Argumentos del método
dynamic.method.return.type=Tipo de devolución (&T)\:
dynamic.method.property.type=Tipo de propiedad (&T)\:
are.you.sure.to.delete.dynamic.property=¿Está seguro de que desea eliminar ''{0}''?
dynamic.property.deletion=Eliminar propiedades dinámicas
are.you.sure.to.delete.elements=¿Está seguro de que desea eliminar el elemento ''{0}''''?
dynamic.element.deletion=Eliminar elementos dinámicos
tuple.cant.be.placed.in.class=No se permiten asignaciones múltiples a campos
is.not.enclosing.class=''{0}'' no es una clase adjunta
package.definition.cannot.have.modifiers=Una definición de paquete no puede tener un controlador
import.statement.cannot.have.modifiers=Las declaraciones de importación no pueden tener controladores
undefined.label=Etiqueta no definida ''{0}''
continue.outside.loop=La declaración de continuación sólo se permite dentro de un bucle.
break.outside.loop.or.switch=Las declaraciones de interrupción solo se permiten dentro de bucles o conmutadores.
label.already.used=La etiqueta ''{0}'' ya está en uso.
break.outside.loop=Las declaraciones de interrupción con etiquetas con nombre solo se permiten dentro de bucles.
Constructor=Constructor
Getter=Adquiridor
Setter=Conjuntos
not.allowed.modifier.in.for.in=El controlador ''{0}'' no está permitido aquí
property.name.expected=El nombre de la propiedad es obligatorio
wildcards.are.not.allowed.in.extends.list=Un supertipo no puede especificar un tipo comodín.
method.does.not.override.super=El método no anula un método en la clase principal.
method.duplicate=El método con firma {0} ya está definido en la clase ''{1}''
ambiguous.code.block=Bloque de código ambiguo
cyclic.inheritance.involving.0=Herencia circular relacionada con ''{0}''
there.is.no.default.constructor.available.in.class.0=No hay ningún constructor predeterminado disponible para ''{0}''.
groovy.library.is.not.configured.for.module=Groovy SDK no está configurado para el módulo ''{0}''
configure.groovy.library=Configurar el SDK de Groovy...
create.instance.of.built-in.type=Crear instancias de un tipo primitivo
incorrect.variable.name=Nombre de variable no válido
no.interface.expected.here=No se necesita interfaz aquí
no.class.expected.here=Aquí no se necesitan clases.
invoke.completion.second.time.to.show.skipped.methods=Segunda llamada para completar el código para mostrar los métodos omitidos
groovy.file.extension.is.not.mapped.to.groovy.file.type=*El archivo .groovy está asignado a ''{0}''\n''{0}'' no es una anotación
class.is.not.annotation=''{0}'' no es una anotación
method.call.is.ambiguous=La llamada al método es ambigua.
operator.call.is.ambiguous=La llamada al operador es ambigua.
duplicated.named.parameter=Se encontró un parámetro con un nombre duplicado ''{0}''.
no.super.classes.found=No se encontró ninguna clase principal.
no.super.method.found=Método principal no encontrado.
cannot.assign.string.to.enum.0=No se puede asignar la cadena a la enumeración ''{0}''.
cannot.find.enum.constant.0.in.enum.1=La constante de enumeración ''{0}'' no se encuentra en la enumeración ''{1}''.
recursive.constructor.invocation=Llamada de constructor recursivo
the.usage.of.a.map.entry.expression.to.initialize.an.enum.is.currently.not.supported=Actualmente no se admite el uso de expresiones de entrada de mapa para inicializar enumeraciones.
class.definition.is.not.expected.here=Aquí no se necesita ninguna definición de clase.
move.class.0.from.method=Mueva ''{0}'' a la ubicación correcta
move.class.from.method.family.name=Solución rápida para llevarlo a la ubicación correcta
cannot.infer.argument.types=No se pudo inferir el tipo de argumento.
Equals=Igual
default.initializers.are.not.allowed.in.abstract.method=Los inicializadores predeterminados no están permitidos en métodos abstractos.
groovy.does.not.support.constructor.type.arguments=Groovy no admite argumentos de tipo constructor.
illegal.escape.character.in.string.literal=Carácter de escape no válido en literal de cadena
method.with.type.parameters.should.have.return.type=Los métodos con parámetros de tipo deben tener un tipo de retorno
primitive.type.parameters.are.not.allowed=Los parámetros de tipo predeterminados no están permitidos en la lista de parámetros de tipo.
primitive.bound.types.are.not.allowed=No se aceptan tipos de encuadernación predeterminados.
ellipsis.type.is.not.allowed.here=El tipo de puntos suspensivos no está permitido aquí.
method.0.is.too.complex.too.analyze=El método ''{0}'' es demasiado complejo para analizarlo.\nEl cierre es demasiado complejo para analizarlo.\n''{0}'' está en desuso
closure.is.too.complex.to.analyze=El cierre es complejo de analizar.\nLos tipos de variables locales no se infieren.
0.is.deprecated=''{0}'' está obsoleto
wrong.number.of.type.arguments=Número no válido de argumentos de tipo\: {0}; Requiere: {1}
type.argument.0.is.not.in.its.bound.should.extend.1=El parámetro de tipo ''{0}'' no está dentro de sus límites y debe extenderse a ''{1}''.
catch.statement.parameter.type.should.be.a.subclass.of.throwable=El tipo de parámetro de la declaración catch debe ser una subclase de Throwable.
exception.0.has.already.been.caught=La excepción ''{0}'' ya ha sido detectada
unnecessary.type=La excepción ''{0}'' no es necesaria. ''{1}'' ya ha sido declarado.
create.enum=Crear enumeración {0}
create.trait=Crear atributo {0}
annotation.field.can.only.be.used.within.a.script.body=La anotación @Field solo se puede utilizar dentro del cuerpo del script.
annotation.field.can.only.be.used.within.a.script=La anotación @Field solo se puede utilizar dentro de scripts.
return.type.is.incompatible=El tipo de devolución de {0} en {1} es incompatible con {3} en {2}
anonymous.class.derived.from.0=Clase anónima derivada de {0}
throws.clause.is.not.allowed.in.at.interface=La cláusula ''throws'' no está permitida en los miembros @interface
at.interface.0.does.not.contain.attribute=@interface ''{0}'' no tiene la propiedad ''{1}''.
duplicate.attribute=Atributo duplicado
missed.attributes=Propiedad faltante\: {0}
unexpected.attribute.type.0=Tipo de propiedad inesperado\: ''{0}''
annotation.field.should.have.type.declaration=Los campos dentro de una anotación deben tener una declaración de tipo.
interface.members.are.not.allowed.to.be=El miembro de la interfaz no puede ser {0}.
abstract.methods.must.not.have.body=Los métodos abstractos no deben tener cuerpo.
method.has.incorrect.modifier.volatile=El controlador ''volatile'' en el método no es válido
native.methods.cannot.have.body=Los métodos nativos no pueden tener cuerpo.
top.level.class.may.not.have.private.modifier=Las clases de nivel superior no pueden tener modificadores "privados"
top.level.class.may.not.have.protected.modifier=Las clases de nivel superior no pueden tener modificadores "protegidos"
property.missing=PropiedadFalta
attribute.name.expected=El nombre de la propiedad es obligatorio.
java.style.for.each.statement.requires.a.type.declaration=Las declaraciones for-each de estilo Java requieren una declaración de tipo.
super.cannot.be.used.in.static.context=''super'' no se puede utilizar en un contexto estático.
qualified.0.is.allowed.only.in.nested.or.inner.classes=El {0} calificado solo se permite en clases anidadas/internas.
groovy.file.0=Archivo maravilloso ''{0}''
type.argument.list.is.not.allowed.here=Aquí no se permiten listas de argumentos de tipo.
initializers.are.not.allowed.in.interface=Inicializador no permitido en la interfaz.
initializer.cannot.have.annotations=Los inicializadores no pueden tener anotaciones.
initializer.cannot.be.0=El inicializador no puede ser {0}.
constructors.are.not.allowed.in.interface=Constructor no permitido en la interfaz.
type.parameters.are.unexpected=Parámetro de tipo inesperado
constructors.cannot.have.return.type=El elemento de tipo ''return'' no está permitido en el constructor
constructor.cannot.have.static.modifier=Los constructores no pueden ser estáticos.
annotation.types.may.not.have.extends.clause=Los tipos de anotaciones no pueden tener una cláusula "extiende".
annotation.types.may.not.have.implements.clause=Los tipos de anotaciones no pueden tener una cláusula de "implementos".
no.implements.clause.allowed.for.interface=Las interfaces no pueden tener una cláusula de "implementos".
enums.may.not.have.extends.clause=Las enumeraciones no pueden tener una cláusula "extiende".
method.0.cannot.override.method.1.in.2.overridden.method.is.final=El método ''{0}'' no puede anular el método ''{1}'' en ''{2}'' y el método anulado es final.
method.0.cannot.have.weaker.access.privileges.1.than.2.in.3.4=El método ''{0}'' tiene un acceso más débil (''{1}'') que ''{2}'' en ''{3}'' (''{4}''). tenerlo.
tuple.declaration.should.end.with.def.modifier=Las declaraciones de tuplas deben terminar con el modificador ''def''
injection.should.not.contain.line.feeds=Las inserciones de GString no deben incluir avances de línea.
collection.literal.contains.named.argument.and.expression.items=Los literales de colección contienen argumentos con nombre y expresión.
annotation.collector.cannot.have.attributes=Los tipos de anotaciones agregados con @AnnotationCollector no pueden tener propiedades
annotation.type.cannot.be.inner=Los tipos de anotaciones no pueden ser internos.
named.arguments.are.not.allowed.inside.index.operations=Los argumentos con nombre no están permitidos dentro de una operación de índice.
expected.0.to.be.inline.constant=''{0}'' debe ser una constante en línea.
cannot.assign.a.value.to.final.field.0=No se puede asignar un valor al campo final ''{0}''.
cannot.assign.a.value.to.final.parameter.0=No se puede asignar un valor al parámetro final ''{0}''.
variable.0.might.not.have.been.initialized=Es posible que la variable ''{0}'' no se haya inicializado
doc.end.expected=''*/'' se requiere
mixing.private.and.public.protected.methods.of.the.same.name=Tiene una combinación de métodos privados y públicos/protegidos con el mismo nombre.
explicit.constructors.are.not.allowed.in.immutable.class=No se permiten constructores explícitos en las clases @Immutable.
repetitive.method.name.0=El nombre del método ''{0}'' se repite.
declared.type.0.have.to.extend.script=El tipo declarado ''{0}'' no extiende la clase ''groovy.lang.Script''.
base.script.annotation.is.allowed.only.inside.scripts=La anotación @BaseScript solo se puede utilizar dentro de scripts.
delegate.annotation.is.only.for.methods.without.arguments=La anotación @Delegate se puede aplicar a métodos con argumentos.
builder.annotation.not.support.super.for.simple.strategy=La propiedad de anotación ''includeSuperProperties'' no se admite en groovy.transform.builder.SimpleStrategy.
0.expressions.on.trait.fields.properties.are.not.supported.in.traits=La expresión {0} en un campo de propiedad/propiedad no se admite en propiedades.
only.traits.expected.here=Aquí solo se necesitan las características.
anonymous.classes.cannot.be.created.from.traits=No se pueden crear clases anónimas a partir de atributos.
trait.method.cannot.be.protected=Los métodos de rasgos no se pueden proteger.
non.static.classes.not.allowed=No se permiten clases internas no estáticas en los rasgos.
selfType.class.does.not.inherit=@SelfType\: La clase ''{0}'' no hereda de ''{1}''.
illegal.type.void=Tipo no válido\: ''void''
illegal.method.name=Había un carácter no válido en el nombre del método. {0}
indexed.property.is.applicable.to.properties.only=@IndexedProperty no se puede aplicar solo a propiedades
listener.list.field.must.have.a.generic.collection.type=El campo @ListenerList requiere un tipo de colección genérico
listener.list.field.with.generic.wildcards.not.supported=No se admite el uso de comodines genéricos en los campos @ListenerList
synchronized.not.allowed.on.abstract.method=@Synchronized no está permitido en métodos abstractos
lock.field.0.must.be.static=El campo de bloqueo ''{0}'' debe ser estático
lock.field.0.must.not.be.static=El campo de bloqueo ''{0}'' no puede ser estático
lock.field.0.not.found=Campo de roca ''{0}'' no encontrado
select.module.action.text=Seleccionar módulo...
select.module.action.description=Seleccionar módulos para usar el classpath
select.module.popup.title=Usar classpath del módulo
inspection.annotations=Validación de anotaciones
inspection.assignments=Cuestiones de admisión a la universidad
inspection.bugs=Errores que pueden ocurrir
inspection.confusing=La sintaxis del código puede resultar confusa.
inspection.control.flow=Controlar problemas de flujo
inspection.data.flow=Flujo de datos
inspection.error.handling=Manejo de errores
inspection.gpath=Ruta GP
inspection.naming=Reglas de creación de nombres
inspection.method.metrics=Métricas del método
inspection.redundancy=Declaración de despido
inspection.threading=Problema de roscado
inspection.validity=Problema de validez
inspection.style=Estilo
inspection.other=Otros
inspection.display.name.result.of.assignment.used=Usar resultados de sustitución
inspection.display.name.assignment.can.be.operator.assignment=Asignación que puede ser reemplazada por asignación de operador
inspection.display.name.delegates.to=@DelegatesPara comprobar
inspection.display.name.unresolved.access=Accediendo a expresiones no resueltas
inspection.display.name.untyped.access=Accediendo a expresiones sin escribir
inspection.display.name.list.set.can.be.keyed.access=La llamada List.set puede ser un acceso clave
inspection.display.name.list.get.can.be.keyed.access=La llamada List.get puede ser un acceso clave
inspection.display.name.map.put.can.be.keyed.access=La llamada a Map.put puede ser un acceso clave
inspection.display.name.map.get.can.be.keyed.access=La llamada Map.get puede ser un acceso clave
inspection.display.name.parameter.naming.convention=Convención de nomenclatura de parámetros de método
inspection.display.name.constant.naming.convention=Convenciones de nomenclatura constantes
inspection.display.name.instance.variable.naming.convention=Convenciones de nomenclatura de variables de instancia
inspection.display.name.instance.method.naming.convention=Convención de nomenclatura de métodos de instancia
inspection.display.name.static.variable.naming.convention=Convención de nomenclatura de variables estáticas
inspection.display.name.static.method.naming.convention=Convención de nomenclatura de métodos estáticos
inspection.display.name.local.variable.naming.convention=Convenciones de nomenclatura de variables locales
inspection.display.name.class.naming.convention=Convención de nomenclatura de clases
inspection.display.name.groovydoc.check=Problema con GroovyDoc
inspection.display.name.constructor.named.arguments=Argumentos con nombre en la llamada al constructor
inspection.display.name.result.of.object.allocation.ignored=Se ignora el resultado de la asignación de objetos.
inspection.display.name.divide.by.zero=Dividir entre cero
inspection.display.name.infinite.recursion=Recursividad infinita
inspection.display.name.infinite.loop.statement=Declaración de bucle infinito
inspection.display.name.non.short.circuit.boolean=Booleano sin cortocircuito
inspection.display.name.duplicate.switch.branch=Redundancia de caja de interruptor
inspection.display.name.gstring.key=Clave del mapa GString
inspection.display.name.octal.integer=Entero octal
inspection.display.name.overly.complex.boolean.expression=Expresión booleana demasiado compleja
inspection.display.name.clashing.trait.methods=Conflicto de método de rasgo
inspection.display.name.overly.complex.arithmetic.expression=Expresiones aritméticas demasiado complejas
inspection.display.name.double.negation=Doble negativa
inspection.display.name.pointless.arithmetic=Expresiones aritméticas sin sentido
inspection.display.name.empty.statement.body=Frases con cuerpo vacío
inspection.display.name.reassigned.in.closure.local.var=La variable local ha sido reasignada a una clase de cierre o anónima
inspection.display.name.result.of.increment.or.decrement.used=Resultado del incremento o decremento utilizado
inspection.display.name.negated.if=Expresión de condición negada si
inspection.display.name.in.argument.check=Tipo de argumento ''in'' incompatible
inspection.display.name.negated.conditional=Expresión condicional negada
inspection.display.name.nested.conditional=Expresiones condicionales anidadas
inspection.display.name.conditional=Expresión condicional
inspection.display.name.nested.switch=Declaración de cambio negado
inspection.display.name.multiple.return.points.per.method=Métodos con múltiples puntos de retorno.
inspection.display.name.method.with.more.than.three.negations=Métodos con 4 o más negaciones.
inspection.display.name.overly.nested.method=Métodos demasiado anidados
inspection.display.name.overly.long.method=Método demasiado largo
inspection.display.name.overly.complex.method=Método demasiado complejo
inspection.display.name.method.parameter.count=Método con demasiados parámetros.
inspection.display.name.while.loop.spins.on.field=Mientras el bucle gira en el campo
inspection.display.name.unsynchronized.method.overrides.synchronized.method=Un método asincronizado anula un método sincronizado.
inspection.display.name.synchronization.on.variable.initialized.with.literal=Sincronización de variables inicializadas con literales
inspection.display.name.synchronization.on.non.final.field=Sincronización de campos no finales
inspection.display.name.wait.while.not.synchronized=''wait()'' mientras no está sincronizado
inspection.display.name.wait.call.not.in.loop=''espera()'' no en bucle
inspection.display.name.notify.while.not.synchronized=''esperar()'' o ''notificar()'' mientras no esté sincronizado
inspection.display.name.system.run.finalizers.on.exit=Llame a System.runFinalizersOnExit()
inspection.display.name.thread.stop.suspend.resume=Llamar a Thread.stop(), Thread.suspend() o Thread.resume()
inspection.display.name.nested.synchronized.statement=Declaraciones anidadas ''sincronizadas''
inspection.display.name.synchronized.method=Método sincronizado
inspection.display.name.synchronization.on.this=''esta'' sincronización
inspection.display.name.empty.sync.block=Bloque ''sincronizado'' vacío
inspection.display.name.busy.wait=Ocupado esperando
inspection.display.name.public.field.accessed.in.synchronized.context=Acceder a campos no privados en un contexto sincronizado
inspection.display.name.unconditional.wait=Llamada de ''espera'' incondicional
inspection.display.name.double.checked.locking=Bloqueo de doble control
inspection.display.name.access.to.static.field.locked.on.instance=El acceso a campos estáticos está bloqueado en los datos de la instancia.
inspection.display.name.change.to.method=Cambiar al método
inspection.display.name.change.to.operator=Cambiar de operador
inspection.display.name.unnecessary.alias=Alias de importación innecesarios
inspection.display.name.unnecessary.semicolon=Punto y coma innecesario
inspection.display.name.unnecessary.public.modifier=''Público'' innecesario
inspection.display.name.unnecessary.def.modifier=''definición'' innecesaria
inspection.display.name.java.style.properties.invocation=Acceso a propiedades estilo Java
inspection.display.name.trivial.if=Declaraciones ''si'' duplicadas
inspection.display.name.constant.if.statement=Declaración si constante
inspection.display.name.constant.conditional=Expresión condicional constante
inspection.display.name.trivial.conditional=Expresión condicional duplicada
inspection.display.name.return.from.closure.can.be.implicit=La declaración ''return'' puede ser implícita
inspection.display.name.switch.statement.with.no.default=Declaración de cambio sin caso predeterminado
inspection.display.name.final.variable.access=Acceso final a variables
inspection.display.name.unnecessary.return=Declaración de "devolución" innecesaria
inspection.display.name.unnecessary.continue=Declaración "continuar" innecesaria
inspection.display.name.fallthrough=Fallo de la declaración de cambio
inspection.display.name.if.statement.with.too.many.branches=Declaración If con demasiadas ramas
inspection.display.name.if.statement.with.identical.branches=Declaración If con ramas idénticas
inspection.display.name.conditional.can.be.conditional.call=La expresión condicional puede ser una llamada condicional
inspection.display.name.conditional.can.be.elvis=La expresión condicional puede ser elvis.
inspection.display.name.conditional.with.identical.branches=Expresiones condicionales con la misma rama.
inspection.display.name.loop.statement.that.doesnt.loop=Declaración de bucle que no ejecuta un bucle
inspection.display.name.unreachable.statement=Sintaxis inalcanzable
inspection.display.name.continue=Continuar declaración
inspection.display.name.break=Declaración de ruptura
inspection.display.name.unused.catch.parameter=Parámetro de captura no utilizado
inspection.display.name.empty.try.block=Bloque ''intentar'' vacío
inspection.display.name.annotation.references.unknown.identifier=Identificador desconocido en las propiedades ''incluye'' y ''excluye''
inspection.display.name.unresolved.labels.in.named.variant=Etiquetas no resueltas después de la conversión @NamedVariant/@NamedParam/@NamedDelegate
inspection.display.name.empty.finally.block=Bloque vacío ''finalmente''
inspection.display.name.empty.catch.block=Bloque ''catch'' vacío
inspection.display.name.throw.from.finally.block=Bloque ''tirar finalmente''
inspection.display.name.return.from.finally.block=Regresar' en el bloque finalmente
inspection.display.name.method.may.be.static=Los métodos pueden ser estáticos.
inspection.display.name.continue.or.break.from.finally.block=Continuar'' o ''interrumpir dentro de un bloque finalmente
inspection.display.name.unchecked.assignment.of.member.of.raw.type=Asignación no validada en miembro de tipo primitivo
inspection.display.name.silly.assignment=Sustitución incorrecta
inspection.display.name.nested.assignment=Asignación anidada
inspection.display.name.assignment.to.method.parameter=Asignación al parámetro del método
inspection.display.name.assignment.to.for.loop.parameter=Asignación al parámetro de bucle for
inspection.display.name.assignability.check=Asignación de tipo incompatible
inspection.display.name.type.customizer=Tipo de verificación del personalizador
inspection.display.name.unused.declaration=Declaración obsoleta
inspection.display.name.second.unsafe.call=Segunda llamada insegura
inspection.display.name.unused.assignment=Tarea no utilizada
inspection.display.name.unused.inc.dec=Incremento o decremento no utilizado
inspection.display.name.unassigned.access=La variable no está asignada
inspection.display.name.no.return=Sentencia devuelta faltante
inspection.display.name.clashing.getters=Conflicto getter
inspection.display.name.package.mismatch=Paquete no coincide
inspection.display.name.deprecated.api.usage=Compruebe si hay API obsoletas
inspection.display.name.unnecessary.qualified.reference=Referencias totalmente calificadas innecesarias
inspection.display.name.pointless.boolean=Expresión booleana sin sentido
inspection.display.name.access.to.inaccessible.element=Acceder a elementos inaccesibles
inspection.display.name.incorrect.range.argument=Argumento de rango no válido
inspection.display.name.new.instance.of.singleton=Se agregó una nueva instancia de la clase con la anotación @groovy.lang.Singleton.
inspection.display.name.check.labeled.statement=Comprobación de sintaxis etiquetada
inspection.display.name.variable.can.be.final=Las variables pueden ser finales.
inspection.display.name.equals.between.inconvertible.types=''es igual a()'' entre objetos de tipos no convertibles
inspection.display.name.singleton.constructor=@Constructor Singleton
inspection.display.name.implicit.null.argument=Argumento nulo implícito
inspection.display.name.string.style.violation=Violación del estilo de cadena
inspection.message.access.to.static.field.locked.on.instance.data=El acceso al campo estático <code>\#ref</code> está bloqueado en los datos de instancia \#loc
inspection.message.assignment.replaceable.with.operator.assignment=<code>\#ref</code> se puede simplificar a ''{0}'' \#loc
inspection.message.assignment.to.for.loop.parameter=Asignación al parámetro de bucle for ''\#ref'' \#loc
inspection.message.assignment.to.method.parameter=Asignación al parámetro del método ''\#ref'' \#loc
inspection.message.ref.statement=\#ref declaración \#loc
inspection.message.call.to.thread.ref.in.a.loop=La llamada a <code>Thread.\#ref()</code> dentro del bucle puede estar ocupada esperando \#loc
inspection.message.conditional.expression.can.be.call=Una expresión condicional puede ser una llamada \#loc
inspection.message.conditional.expression.can.be.elvis=La expresión condicional puede ser elvis \#loc
inspection.message.conditional.expression=Expresión condicional \#loc
inspection.message.conditional.expression.with.identical.branches=Expresión condicional \#loc con la misma rama
inspection.message.ref.can.be.simplified=''\#ref'' se puede simplificar a \#loc
inspection.message.ref.statement.can.be.simplified=La declaración \#ref se puede simplificar a \#loc
inspection.message.constant.name.ref.too.short=El nombre de la constante ''\#ref'' es demasiado corto
inspection.message.constant.name.ref.too.long=El nombre de la constante ''\#ref'' es demasiado largo
inspection.message.constant.name.ref.doesnt.match.regex=El nombre de la constante ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
inspection.message.ref.inside.finally.block=\#ref'' \#loc en el bloque ''finalmente
inspection.message.divide.by.zero=Dividir por cero \#loc
inspection.message.double.checked.locking=Cerradura de doble verificación \#loc
inspection.message.double.negation.ref=Doble negación \#ref \#loc
inspection.message.duplicate.switch.case.ref=Caja de interruptor duplicada ''\#ref'' \#loc
inspection.message.empty.ref.block=Bloque ''\#ref'' vacío \#loc
inspection.message.ref.statement.has.empty.branch=La rama de la declaración ''\#ref'' está vacía
inspection.message.ref.statement.has.empty.body=El cuerpo de la declaración ''\#ref'' está vacío
inspection.message.fallthrough.in.switch.statement=Fallo de la declaración de cambio \#loc
inspection.message.gstring.used.as.maps.key=GString se usó como clave de mapa \#loc
inspection.message.ref.statement.cannot.complete.without.throwing.exception=La declaración <code>\#ref</code> no se completará sin generar una excepción \#loc
inspection.message.code.ref.code.recurses.infinitely.can.only.complete.by.throwing.exception=<code>\#ref</code> se repite infinitamente y debe generar una excepción para completar \#loc
inspection.message.instance.method.name.ref.too.short=El nombre del método de instancia ''\#ref'' es demasiado corto
inspection.message.instance.method.name.ref.too.long=El nombre del método de instancia ''\#ref'' es demasiado largo
inspection.message.instance.method.name.ref.doesnt.match.regex=El nombre del método de instancia ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
inspection.message.instance.variable.name.ref.too.short=El nombre de la variable de instancia ''\#ref'' es demasiado corto
inspection.message.instance.variable.name.ref.too.long=El nombre de la variable de instancia ''\#ref'' es demasiado largo
inspection.message.couldnt.find.property.field.with.this.name=No se puede encontrar el marco para la propiedad o campo con este nombre \#loc
inspection.message.instance.variable.name.ref.doesn.t.match.regex=El nombre de la variable de instancia ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
inspection.message.call.to.ref.can.be.keyed.access=La llamada ''\#ref'' puede ser una clave de acceso \#loc
inspection.message.ref.statement.with.identical.branches=Declaración ''\#ref'' con la misma rama \#loc
inspection.message.ref.statement.with.too.many.branches=La declaración ''\#ref'' tiene demasiadas ramas ({0}) \#loc
inspection.message.local.variable.name.ref.too.short=El nombre de la variable local ''\#ref'' es demasiado corto
inspection.message.local.variable.name.ref.too.long=El nombre de la variable local ''\#ref'' es demasiado largo
inspection.message.local.variable.name.ref.doesnt.match.regex=El nombre de la variable local ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
inspection.message.code.ref.code.statement.doesnt.loop=La declaración <code>\#ref</code> no se repite en \#loc
inspection.message.method.ref.contains.too.many.parameters.0.1=El módulo ''\#ref'' tiene demasiados parámetros ({0}>{1})
inspection.message.method.ref.has.too.many.negations=Demasiadas negaciones en el método ''\#ref'' ({0}>3)
inspection.message.ref.has.0.return.points=<code>\#ref</code> tiene {0} puntos de retorno \#loc
inspection.message.negated.conditional.expression=Expresión condicional negada \#loc
inspection.message.negated.if.condition.expression=Negado si la expresión de condición \#loc
inspection.message.nested.assignment.expression=Asignación anidada \#loc
inspection.message.nested.conditional.expression=Expresión condicional anidada \#loc
inspection.message.nested.ref.statement=Declaraciones ''\#ref'' anidadas \#loc
inspection.message.non.short.circuit.boolean.expression=Expresión booleana sin cortocircuito \#loc
inspection.message.call.to.ref.outside.synchronized.context=Llamar a ''\#ref'' fuera del contexto sincronizado \#loc
inspection.message.octal.integer.ref=Entero octal \#ref \#loc
inspection.message.overly.complex.arithmetic.expression=Expresión aritmética demasiado compleja \#loc
inspection.message.overly.complex.boolean.expression=Expresión booleana demasiado compleja \#loc
inspection.message.method.ref.overly.complex.cyclomatic.complexity=El método ''\#ref'' es demasiado complejo (complejidad ciclomática \={0}>{1})
inspection.message.method.ref.too.long.statement.count=El método ''\#ref'' es demasiado largo (recuento de sintaxis \={0}>{1}})
inspection.message.method.ref.overly.nested.nesting.depth=El método ''\#ref'' está demasiado anidado (profundidad de anidamiento \={0}>{1})
inspection.message.method.parameter.name.ref.too.short=El nombre del parámetro del método ''\#ref'' es demasiado corto
inspection.message.method.parameter.name.ref.too.long=El nombre del parámetro del método ''\#ref'' es demasiado largo
inspection.message.method.parameter.name.ref.doesnt.match.regex=El nombre del parámetro del método ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
inspection.message.non.private.field.accessed.in.synchronized.context=Se accede al campo no privado <code>\#ref</code> en el contexto sincronizado \#loc
inspection.message.nested.assignment=El resultado de la expresión de asignación se utiliza \#loc
inspection.message.result.increment.or.decrement.expression.used=Resultado de la expresión de incremento o decremento utilizada \#loc
inspection.message.result.of.new.ref.is.ignored=<code>Resultado del nuevo \#ref{0}</code> ignorado \#loc
inspection.message.ref.statement.at.end.closure.can.be.made.implicit=Puede hacer que la declaración \#ref al final del cierre sea implícita \#loc
inspection.message.silly.assignment=Asignación no válida \#loc
inspection.message.static.method.name.ref.too.short=El nombre del método estático ''\#ref'' es demasiado corto
inspection.message.static.method.name.ref.too.long=El nombre del método estático ''\#ref'' es demasiado largo
inspection.message.static.method.name.ref.doesnt.match.regex=El nombre del método estático ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
inspection.message.static.variable.name.ref.too.short=El nombre de la variable estática ''\#ref'' es demasiado corto
inspection.message.label.name.ref.not.supported.by.0={0} no admite el nombre de etiqueta ''\#ref''
inspection.message.static.variable.name.ref.too.long=El nombre de la variable estática ''\#ref'' es demasiado largo
inspection.message.static.variable.name.ref.doesnt.match.regex=El nombre de la variable estática ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
inspection.message.property.0.is.final=La propiedad ''{0}'' es \#loc final
inspection.message.ref.statement.with.no.default.branch=\#ref declaración sin rama predeterminada \#loc
inspection.message.synchronization.on.non.final.field.ref=El campo no final ''\#ref'' sincroniza \#loc
inspection.message.synchronization.on.ref=\ ''\#ref'' Sincronizar \#loc
inspection.message.synchronization.on.variable.ref.which.was.initialized.with.literal=Sincronizar la variable ''\#ref'' inicializada con el literal \#loc
inspection.message.synchronized.method.ref=Método sincronizado ''\#ref'' \#loc
inspection.message.call.to.system.ref=''Sistema.\#ref'' llama a \#loc
inspection.message.call.to.thread.ref=''hilo.\#ref'' llamada \#loc
inspection.message.trivial.conditional.expression=Expresión condicional que se explica por sí misma #loc
inspection.message.property.0.is.ignored.by.map.constructor=La propiedad ''{0}'' fue ignorada por @MapConstructor \#loc
inspection.message.unconditional.call.to.ref=Llama a <code>\#ref()</code> incondicionalmente \#loc
inspection.message.ref.is.unnecessary.as.last.statement.in.loop=\#ref no es necesario como última declaración del bucle \#loc.
inspection.message.ref.is.unnecessary.as.last.statement.in.method.with.no.return.value=\#ref no es necesario como última declaración de un método sin valor de retorno \#loc.
inspection.message.unreachable.statement=Declaración inalcanzable \#loc
inspection.message.unsynchronized.method.ref.overrides.synchronized.method=El método asincronizado ''\#ref'' anula el método sincronizado \#loc
inspection.message.cannot.determine.type.ref=No se puede determinar el tipo de ''\#ref''
inspection.message.call.to.ref.outside.of.loop=Llamando a ''\#ref'' fuera del bucle \#loc
inspection.message.call.to.ref.outside.of.synchronized.context=Llamar a ''\#ref'' fuera del contexto sincronizado \#loc
inspection.message.ref.loop.spins.on.field=El bucle <code>\#ref</code> gira en el campo \#loc
inspection.message.package.name.mismatch=El nombre del paquete no coincide
inspection.message.dsl.descriptor.file.has.been.changed.and.isnt.currently.executed=El archivo descriptor DSL ha cambiado y no se está ejecutando actualmente.
inspection.message.dsl.descriptor.file.has.been.disabled.due.to.processing.error=Debido a un error de procesamiento, el archivo descriptor DSL ha sido deshabilitado.
inspection.message.traits.0.contain.clashing.methods.with.signature.1=El atributo {0} contiene un método en conflicto con la firma {1}
inspection.message.unused.catch.parameter.ref=Parámetro de captura no utilizado ''\#ref'' \#loc
inspection.message.package.name.mismatch.actual.0.expected.1=El nombre del paquete no coincide. real\: ''{0}'', requerido\: ''{1}''
inspection.message.property.not.indexable.type.must.be.array.or.list.but.found.0=Las propiedades no se pueden indexar. El tipo debe ser una matriz o una lista, pero se encontró {0}
inspection.message.type.argument.0.can.not.be.1=El argumento ''{0}'' no puede tener el tipo ''{1}''
inspection.message.method.called.with.implicit.null.argument=El método se llama con un argumento nulo implícito.
inspection.message.plain.string.should.be.double.quoted=Las cadenas simples deben estar entre comillas dobles.
inspection.message.plain.string.should.be.single.quoted=Las cadenas regulares deben estar entre comillas simples.
inspection.message.plain.string.should.be.slashy.quoted=Las cadenas simples deben estar entre barras
inspection.message.plain.string.should.be.dollar.slashy.quoted=Las cadenas simples deben estar encerradas entre barras diagonales.
inspection.message.plain.string.should.be.quoted.with.triple.quotes=Las cadenas regulares deben estar encerradas entre ''''
inspection.message.plain.string.should.be.quoted.with.triple.double.quotes=Las cadenas regulares deben estar encerradas entre '"""
inspection.message.multiline.string.should.be.quoted.with.triple.quotes=Las cadenas de varias líneas deben estar encerradas entre ''''
inspection.message.multiline.string.should.be.quoted.with.triple.double.quotes=Las cadenas de varias líneas deben estar encerradas entre """
inspection.message.multiline.string.should.be.slashy.quoted=Las cadenas de varias líneas deben estar entre barras
inspection.message.multiline.string.should.be.dollar.slashy.quoted=Las cadenas de varias líneas deben estar entre barras en dólares
inspection.message.string.escaping.could.be.minimized=Puedes minimizar el escape.
inspection.message.interpolated.string.should.be.double.quoted=Las cadenas interpoladas deben estar entre comillas dobles.
inspection.message.interpolated.string.should.be.dollar.slashy.quoted=Las cadenas interpoladas deben estar encerradas entre barras diagonales.
inspection.message.interpolated.string.should.be.slashy.quoted=Las cadenas interpoladas deben estar entre barras
inspection.message.interpolated.string.should.be.quoted.with.triple.double.quotes=Las cadenas interpoladas deben estar encerradas entre '"""
text.class.0.is.unused=La clase {0} está en desuso
text.constructor.0.is.unused=El constructor {0} está en desuso
text.method.0.is.unused=El método {0} está en desuso
text.property.0.is.unused=La propiedad {0} está en desuso
text.parameter.0.is.unused=El parámetro ''{0}'' está en desuso
intention.category.groovy=Maravilloso
intention.category.conversions=Conversión de expresión/groovy
intention.category.closures=Groovy/Cierre
intention.category.comments=Groovy/anotaciones
intention.category.groovy.style=Estilo maravilloso/Maravilloso
intention.category.control.flow=Flujo maravilloso/controlado
intention.category.groovy.declaration=Groovy/Declaración
intention.category.groovy.other=Groovy/Otros
configurable.GroovyCompilerConfigurable.display.name=Compilador maravilloso
configurable.GantConfigurable.display.name=Gant
settings.compiler.alternative=Alternativamente, puede especificar el compilador Groovy-Eclipse en la <a href\=\"\#\">página del compilador Java</a>.
settings.compiler.select.path.to.groovy.compiler.configscript=Seleccione la ruta del script de configuración para el compilador Groovy
settings.compiler.path.to.configscript=&Ruta del script de configuración\:
settings.compiler.invoke.dynamic.support=Ejecutar soporte dinámico
settings.compiler.exclude.from.stub.generation=Excluir de la generación de resguardos\:
settings.code.style.label.indent.style=Estilo de sangría de etiqueta\:
settings.code.style.label.indent.size=Tamaño de sangría de etiqueta\:
settings.code.style.indent.statements.after.label=Declaración de sangría después de la etiqueta
settings.code.style.absolute=Nunca
settings.code.style.indent.labels=Sangría de etiqueta
settings.inlay.parameter.types=Tipo de parámetro
settings.inlay.inferred.parameter.types=Tipo de parámetro inferido
settings.inlay.type.parameter.list=Lista de parámetros de tipo
settings.inlay.show.type.hints.for=Mostrar sugerencias de tipo para\:
intention.name.replace.with.in=Cambie ''\:'' a ''en''
intention.name.activate.back=Reactivar
intention.name.cast.to.0=Convertir a {0}
intention.name.replace.eq.with.0.eq=Cambie ''\='' por ''{0}\=''
intention.name.cast.operand.to.0=Pasar operando a {0}
intention.name.add.required.attributes.to.map.constructor=Agregue las propiedades requeridas a @MapConstructor
intention.name.convert.to.single.quoted.string=Convertir a cadena entre comillas simples
intention.name.change.quotes.to.triple.single.quotes=Cambie las comillas a "
intention.name.convert.to.double.quoted.string=Convertir a cadena entre comillas dobles
intention.name.change.quotes.to.triple.double.quotes=Cambiar comillas a """
intention.name.convert.to.slashy.string=Convertir a cadena de barra
intention.name.convert.to.dollar.slashy.string=Convertir barra de dólar en cadena
intention.family.name.create.field=Crear campo
action.remove.dynamic.member.text=Eliminar
action.remove.dynamic.member.description=Eliminar miembro dinámico
action.collapse.all.text=Desplegar todo
action.collapse.all.description=Desplegar todo
action.expand.all.text=Expandir todo
action.expand.all.description=Expandir todo
dynamic.members.column.name.element=Elementos dinámicos
dynamic.members.column.name.type=Categoría
command.name.add.dynamic.member=Agregar miembros dinámicos
popup.content.navigation.to.overriding.classes.unavailable=La navegación que anula una clase no es posible durante una actualización de índice
overriding.methods.of.0=Método de anulación ''{0}''
expression.type.no.expression=Expresión no encontrada
expression.type.unknown=<desconocido>
add.class.to.extends.family.name=Avatar
intention.family.name.rename=Cambiar nombre
generated.stub.message=Este código auxiliar se genera para que las clases Groovy habiliten la compilación cruzada Groovy-Java.
generated.stub.navigate.link.label=Ir a la clase Groovy
generated.stub.exclude.link.label=Excluir de la generación de resguardos
module.with.groovy=Módulo simple con biblioteca Groovy adjunta
action.build.restart.text=Reiniciar después de la compilación
action.build.module.restart.description=Reiniciar después de crear el módulo ''{0}''
gdsl.investigate.link.label=Haga clic para investigar
gdsl.error.notification.title=Error de ejecución del script DSL
dialog.message.gant.not.configured=Gant no está configurado.
investigate.gdsl.error.intention.name=Ver detalles
investigate.gdsl.error.family.name=Comprobación de errores del proceso del descriptor DSL
grab.intention.name=Agarrar artefactos
grab.family.name=Grab
grab.progress.title=Procesando la anotación @Grab
grab.result.title={0} Dependencia de uva {0,choice, 0\#jar|1\#jar|2\#jar} agregada
grab.jar.count=<b>{0}</b>\: {1} {1, choice, 0\#jar|1\#jar|2\#jar}
grab.error.ivy.missing.title=Falta hiedra
grab.error.ivy.missing.message=Lo sentimos, IDEA no puede @Grab dependencias sin Apache Ivy. Vuelva a ejecutar la acción agregando Apache Ivy a las dependencias de su módulo.
grab.error.0.title=@Grab no se pudo ejecutar\: {0}
this.super.completion.advertisement=Al presionar {0} dos veces sin un calificador de clase se mostrarán todos los métodos estáticos accesibles.
optimize.imports.progress.title=Optimizando declaraciones de importación en un archivo Groovy...
groovy.library.label=Biblioteca maravillosa
replace.all.occurrences.and.remove.variable.0=Reemplazar todos los usos y eliminar la variable ''{0}''
introduce.variable.declare.final.label=Declarar y final
introduce.variable.replace.all.occurrences=&Reemplazar todos los usos
introduce.variable.replace.all.0.occurrences=Reemplazar todos los usos ({0} ubicaciones)
introduce.parameter.delegate.via.overload=Delegación mediante métodos sobrecargados
introduce.parameter.replace.fields.border.title=Convertir campos utilizados en expresiones en captadores
introduce.parameter.do.not.replace.option.label=&No reemplazar
introduce.parameter.replace.inaccessible.fields.option.label=&Reemplazar campos que no son accesibles en el contexto de uso
introduce.parameter.replace.all.fields.option.label=&Reemplazar todos los campos
introduce.variable.type.label=Escriba &T\:
introduce.variable.name.label=&Nombre\:
introduce.parameter.explicit.return.statement.option.label=Utilice una declaración de devolución explícita (&X)
introduce.parameter.delegating.unavailable.tooltip=No se permite la delegación en contexto de cierre
introduce.variable.change.type.advertisement=Presione {0} para cambiar el tipo
framework.0.home.label={0} Inicio\:
select.framework.0.home.title={0} Seleccione Inicio
framework.0.sdk.chooser.title={0} SDK
framework.0.sdk.chooser.description=Seleccione el directorio que contiene la distribución {0}
framework.0.sdk.chooser.error.message=La distribución {0} en la ruta especificada parece estar rota. No se puede determinar la versión.
framework.0.sdk.chooser.error.title=Error al crear la clase
framework.0.library={0} biblioteca
framework.0.library.version.1={0} versión de biblioteca {1}
framework.gant=Gant
script.runner.display.name=Maravilloso
script.runner.description=Clase o guión maravilloso
script.runner.chooser.title=Ruta del script
script.runner.chooser.description=Especifique la ruta del script\:
script.runner.module.not.specified.message=Módulo no especificado
script.runner.no.groovy.for.module=Groovy no está configurado para el módulo ''{0}''
script.runner.cant.find.script=Script ''{0}'' no encontrado
script.runner.unknown.script.type=Tipo de secuencia de comandos desconocido ''{0}''
script.runner.file.is.not.groovy.file=El archivo de script no es un archivo Groovy
script.runner.class.does.not.exist=No hay clases.
script.runner.class.cannot.be.executed=La clase no se puede ejecutar
dialog.title.refactoring.unavailable.in.current.scope=Refactorización no disponible en el alcance actual
parameter.list.owner.chooser.title=Insertar parámetros como
extract.closure.command.name=Extracción de cierre
introduce.constant.title=Insertar constante
undefined.library.version=No definida
method.parameters.count.max.parameters.option=Número máximo de parámetros\:
method.returns.max.returns.option=Límite de punto de retorno\:
overly.complex.method.complexity.limit.option=Límites de complejidad del método\:
overly.long.method.statements.limit.option=Número máximo de declaraciones por método\:
overly.nested.method.nesting.limit.option=Profundidad máxima de anidamiento\:
add.method.family=Agregar método
change.base.method.label=Cambiar el método predeterminado
change.usages.label=Cambia dónde lo usas
convert.parameter.to.map.entry.title=Convertir parámetros en elementos de mapa
live.template.context.declaration=Declaración
live.template.context.expression=Expresión
live.template.context.statement=Construcción
find.usages.method.0.of.class.1={0} de {1}
change.signature.type.column=Categoría
change.signature.default.initializer.column=Inicializador predeterminado
static.import.method.fix=Método de importación estática...
static.import.method.0.fix=Método de importación estática ''{0}''
groovy.consoles.type=Consola Groovy
getter.kind.gdk.method.0=Método GDK {0}
getter.kind.method.0=Método {0}
getter.kind.getter.0=Captador {0}
parameter.hint.number.of.arguments={0,choice, 0\#|1\#{0} argumento|2\#{0} argumento}
surround.with.for=Para
surround.with.if=Si
surround.with.if.else=Si/si no
surround.with.if.expr=Si (expr)
surround.with.if.else.expr=Si (expr)/si no
surround.with.parentheses=(expr)
surround.with.closure={ ->... }.llamar()
surround.with.try=Intentar
surround.with.try.catch=Trata de atraparlo
surround.with.try.finally=Intentar/finalmente
surround.with.try.catch.finally=Intentar/atrapar/finalmente
surround.with.while=Mientras
surround.with.while.expr=Mientras (expr)
surround.with.cast=((Tipo) expr)
surround.with.with=Con () {...}
surround.with.with.expr=Con (expr)
surround.with.shouldFail=Debería fallar () {...}
code.style.group.list.map.literals=Literales de lista y mapa
code.style.option.align.when.multiple=Ordenar si son múltiples
code.style.option.wrap.after.dot=Salto de línea después del punto
code.style.option.align.multiline.named.arguments=Ordenar argumentos con nombre en varias líneas
code.style.option.use.flying.geese.braces=Coloque la llave de cierre en una línea.
code.style.option.import.annotations=Obtener anotaciones
code.style.option.simple.lambdas.closures.in.one.line=Lambda/cierre simple en una línea
code.style.option.relational.operators=Operadores relacionales (<, >, <\=, >\=, <\=>)
code.style.option.unary.operators=Operadores unarios (\!, -, +, ++, --, *)
code.style.option.in.named.argument.before.colon=Dentro de los argumentos con nombre antes de ''\:''
code.style.option.in.named.argument.after.colon=Dentro del argumento nombrado después de ''\:''
code.style.option.list.maps.literals=Literales de lista y mapa
code.style.option.closure.left.brace.in.method.calls=Cierre de llave izquierda dentro de la llamada al método
code.style.option.gstring.injection.braces=Tirantes de inserción GString
code.style.option.tuple.assignment.expression=Expresión de asignación de tupla
code.style.option.regexp.expression=Expresión regular (\=\=~, \=~)
code.style.option.before.assert.separator=Antes del delimitador ''afirmar''
code.style.option.after.assert.separator=Después del delimitador ''afirmar''
singleton.constructor.found=Las clases @Singleton no pueden contener constructores
singleton.constructor.remove=Eliminar constructor
singleton.constructor.makeNonStrict=Establecer @Singleton como no estricto
unused.import=Declaración de importación no utilizada
optimize.imports=Optimización de declaración import
optimize.all.imports=Optimice las declaraciones de importación no utilizadas
dialog.create.class.package.chooser.title=Seleccionar paquete de destino
create.directory.command=Crear directorio
destination.package=Paquete objetivo\:
second.unsafe.call=Segunda llamada insegura
call.can.throw.npe=La cadena de llamadas puede generar NullPointerException
unused.default.parameter.message=Los parámetros predeterminados no se utilizan
unused.default.parameter.fix=Eliminar inicializador
unused.assignment.tooltip=La tarea no se utiliza
unused.variable=La variable no se utiliza
variable.can.be.final.tooltip=La variable ''{0}'' puede ser final
parameter.can.be.final.tooltip=El parámetro ''{0}'' puede ser final
equals.between.inconvertible.types.tooltip=<code>{0}</code> está entre objetos de tipo ''{1}'' y ''{2}'' que no se pueden convertir
replace.with.operator.message=Puedes reemplazar ''{0}'' con un operador
replace.with.operator.fix=Reemplace ''{0}'' con operador
replace.with.operator.double.negation.option=Usar dobles negativos (por ejemplo, \: \!\!)
replace.with.operator.compareTo.equality.option=Cambiar la ecuación ''compareTo'' a igual (por ejemplo, \=\=)
replace.with.operator.parentheses=No sugiere reemplazar con operador si se necesitan paréntesis adicionales
replace.with.method.message=Se puede reemplazar con la llamada al método ''{0}''
replace.with.method.fix=Reemplazar con el método ''{0}''
unassigned.access.tooltip=Es posible que la variable ''{0}'' no esté asignada
no.return.message=Algunas rutas de ejecución no devuelven valores
unresolved.type.status=El tipo ''{0}'' no se resuelve
no.type.specified=No se especifica ningún tipo
dynamic.element=Elementos dinámicos
pointless.boolean.problem.descriptor=\#ref se puede simplificar a ''{0}'' \#loc
pointless.arithmetic.error.message=Puedes reemplazar \#ref con ''{0}'' \#loc
pointless.boolean.quickfix=Arrasamiento
Cannot.perform.undo.operation=Las operaciones no se pueden deshacer
Undo.disable=Deshacer deshabilitar
type.doesnt.contain.method=El tipo ''{0}'' no tiene el método ''{1}'', por lo que ese tipo no se puede iterar en su alcance.
type.doesnt.implement.comparable=El tipo ''{0}'' no implementa Comparable
add.method=Agregue el método ''{0}()'' a ''{1}''
implement.class={0} implementación
fix.class=Modificar clase {0}
rtype.cannot.contain.ltype={1}'' no puede contener ''{0}
new.instance.of.singleton=Una nueva instancia de la clase anotada @groovy.lang.Singleton.
replace.new.expression.with.instance.access=Cambiar al acceso a la instancia
getter.0.clashes.with.getter.1=Se produjo un conflicto: ''{0}'' con ''{1}''
unused.0=Sin usar {0}
remove.0=Eliminar {0}
replace.postfix.0.with.prefix.0=Reemplace el sufijo {0} con el prefijo {0}
replace.0.with.1=Convertir {0} a binario {1}
local.var.0.is.reassigned=Se asignó la variable local ''{0}''
anonymous.class=Clase anónima
closure=Cierre
other.scope=Otra gama
method.may.be.static=El método puede ser estático.
method.may.be.static.option.ignore.trait.methods=Anulación del método de atributo
method.may.be.static.only.private.or.final.option=Inspeccionar solo métodos finales o privados.
method.may.be.static.ignore.empty.method.option=Ignorar métodos vacíos
ignore.boolean.expressions=Ignorar variables no asignadas al verificar booleano
highlight.if.groovy.object.methods.overridden=Resalte referencias en clases que anulan invokeMethod(), getProperty() o setProperty()
highlight.if.missing.methods.declared=Resalte referencias en clases que declaran MissingMethod() o MissingProperty()
gr.package.inspection.check.scripts=Inspección de guión
java.style.property.access=Llamadas de acceso al estilo Java
type.customizer.is.not.marked.as.a.resource.file=El script del personalizador de tipos no está marcado como recurso del compilador.
add.to.resources=Agregar al recurso
add.type.customizer.to.resources=Agregar script de personalizador de tipo al recurso
target.0.does.not.exist=El destino ''{0}'' no existe
target.annotation.is.unused=@Target está en desuso
change.lvalue.type=Cambiar el tipo de variable ''{0}'' a ''{1}''
replace.qualified.name.with.import=Reemplazo de nombres completos con declaraciones de importación
comments.count.as.content=Contar comentarios como contenido
ignore.when.catch.parameter.is.named.ignore.or.ignored=Se ignora si el parámetro catch se denomina ignorar o ignorar.
no.applicable.signature.found=No se encontró ninguna firma aplicable
expected.type.0=''{0}'' requerido pero ''{1}'' encontrado
declare.explicit.implementations.of.trait=Declaración de implementación explícita de un rasgo
unnecessary.modifier.description=El controlador ''{0}'' no es necesario
unnecessary.modifier.remove=Eliminar ''{0}'' innecesario
unnecessary.def.explicitly.typed.only=Informar solo sobre declaraciones escritas explícitamente
unnecessary.alias.fix=Eliminar alias innecesarios
unnecessary.alias.description=No se necesita alias
unnecessary.semicolon.description=No se requiere punto y coma
unnecessary.semicolon.fix=Quitar punto y coma
dynamic.dialog.class.label=&Clase\:
dynamic.dialog.type.label=Escriba &T\:
dynamic.dialog.static.checkbox=&silencio
find.method.ro.method.usages=Buscando la ubicación del uso del método adjunto en el archivo del proyecto
find.method.ro.closure.usages=Búsqueda del uso de cierres adjuntos en archivos de proyecto
conversion.method.not.allowed.in.non.groovy.files=La refactorización no está disponible para métodos utilizados en archivos que no sean Groovy\:
conversion.closure.not.allowed.in.non.groovy.files=La refactorización no está disponible para cierres utilizados en archivos que no sean Groovy\:
wrong.method.first.parameter.type=El método ''{0}'' se utiliza con argumentos con nombre, pero el primer argumento interno ''{1}'' no se ajusta al tipo de mapa.
wrong.closure.first.parameter.type=El cierre ''{0}'' se utiliza con argumentos con nombre, pero el primer argumento dentro de ''{1}'' no se ajusta al tipo de mapa.
map.parameter.dialog.create.new.checkbox=&Crear parámetros para argumentos con nombre
map.parameter.dialog.explicit.type.checkbox=Especificar el tipo explícitamente
convert.cannot.itself=La refactorización no se puede utilizar en el parámetro del mapa en sí.
map.param.name=Nombre del parámetro de mapa (&N)\:
convert.param.to.map.entry=Convertir parámetros en elementos de mapa
closure.used.as.variable=Se aprobó un cierre como argumento. La refactorización puede cambiar el significado.
do.you.want.to.change.method.return.type=¿Le gustaría cambiar el tipo de retorno del método ''{0}''?
do.you.want.to.change.variable.type=¿Quieres cambiar el tipo de ''{0}''?
closure.is.accessed.outside.of.groovy=Se accede al campo <b>{0}</b> fuera de Groovy
write.access.to.closure.variable=Acceso de escritura al campo <b>{0}</b>
field.is.used.in.argument.label=El campo <b>{0}</b> se utiliza en etiquetas de argumentos.
method.with.signature.already.exists=Ya existe un método con firma {0}
field.already.exists=El campo <b>{0}</b> ya existe
method.is.used.outside.of.groovy=El método se utiliza fuera de Groovy.
do.you.want.to.change.type.of.parameter.in.method=¿Quiere cambiar el tipo de parámetro ''{0}'' en el método ''{1}''?
file.exists=El archivo ''{0}'' ya existe en el directorio ''{1}''
move.to.correct.dir.family.name=Mover archivos al paquete correcto
move.to.correct.dir=Ir a ''{0}''
add.return.type=Agregar tipo de devolución
add.return.type.to.method.declaration=Agregar tipo de retorno a la declaración del método
infer.method.parameters.types=Agregar tipos explícitos a los parámetros
infer.method.parameters.types.for.method.declaration=Agregue tipos explícitos para todos los parámetros en la declaración del método
replace.with.wrapper=Reemplazar con {0}
replace.primitive.type.with.wrapper=Reemplazo de tipos de base con envoltorios
remove.parameter.0=Eliminar parámetro ''{0}''
remove.unused.parameter=Eliminar parámetros no utilizados
remove.exception=Eliminar excepción
remove.catch.block=Quitar bloque de captura
try.catch.fix=Try-catch irregular
cannot.create.class=No se puede crear la clase
rename.file.to.0=Cambiar el nombre del archivo a ''{0}''
java.style.properties.invocation.intention.family.name=Cambie las llamadas de acceso al estilo Java a referencias de propiedades al estilo Groovy
java.style.properties.invocation.intention.name=Cambiar a la referencia de propiedad de estilo Groovy
generate.equals.and.hashcode.already.defined.warning.anonymous=Equals() y hashCode() ya están definidos
generate.equals.and.hashcode.already.defined.warning=Equals() y hashCode() ya están definidos
generate.equals.and.hashcode.already.defined.title=Equals() y hashCode() ya están definidos
generate.equals.compare.nested.arrays.comment=// matriz anidada aquí {0} - comparar valores
generate.equals.compare.arrays.comment=// Comparar matrices Object[] con Arrays.equals puede ser incorrecta
generate.property.missing.already.defined.warning=PropertyMissing() ya está definido
generate.property.missing.already.defined.title=PropertyMissing() ya está definido
generate.method.missing.already.defined.warning=MétodoMissing() ya está definido
generate.method.missing.already.defined.title=MétodoMissing() ya está definido
action.Gant.NewScript.text=Guión de gant
action.Gant.NewScript.description=Crear un nuevo script Gant
action.Groovy.Console.text=Consola Groovy
action.Groovy.Console.description=Inicia la consola Groovy
module.name.0.and.groovy.version.1={0} ({1})
groovy.version.0=Maravilloso {0}
groovy.version.bundled.0=Paquete maravilloso {0}
configurable.greclipse.border.title=Opciones de Groovy-Eclipse
configurable.greclipse.path.label=Ruta del jar groovy-eclipse-batch\:
configurable.greclipse.path.chooser.description=Seleccione la ruta groovy-eclipse-batch-*.jar para la versión que coincida con su distribución Groovy
configurable.greclipse.command.line.params.label=Parámetros de línea de comando adicionales\:
configurable.greclipse.debug.checkbox=Generar información de depuración
configurable.hotswap.checkbox=Habilitación del agente de intercambio en caliente en código Groovy
configurable.hotswap.checkbox.description=Puede causar problemas de serialización en aplicaciones depuradas
run.configuration.script.path.label=Ruta del script\:
run.configuration.module.chooser.label=&Módulo\:
run.configuration.module.classpath.checkbox=Agregar classpath del módulo al corredor
pull.up.wont.be.accessible.from={1} no puede acceder a {0}
pull.up.wont.be.accessible.from.the.subclass={0} usa {1} al que no se puede acceder desde subclases.
pull.up.abstract.wont.be.accessible.from={0} no se puede hacer abstracto porque no se puede acceder a él desde las subclases.
settings.inlay.implicit.null.argument=Argumento nulo implícito
settings.inlay.show.hints.for.implicit.null.argument=Mostrar sugerencias sobre argumentos nulos implícitos
header.extract.closure=Extracción de cierre
string.sort.default=Por defecto
string.sort.strings.with.escaping=Cadena que contiene caracteres de escape
string.sort.strings.with.interpolation=Una cadena que contiene una expresión de interpolación.
string.sort.multiline.string=Cadena multilínea
separator.preferable.string.kind=Tipo preferido
separator.domain.of.inspection.usage=Dónde usar el dominio
checkbox.inspect.gradle.files=Inspección de archivos Gradle
string.option.do.not.handle.specifically=Sin trato especial
string.option.double.quoted.string=Cadena entre comillas dobles
string.option.single.quoted.string=Cadena entre comillas simples
string.option.slashy.string=Cadena de barra
string.option.triple.quoted.string=Cadena encerrada entre comillas simples triples
string.option.triple.double.quoted.string=Cadena encerrada entre comillas dobles triples
string.option.dollar.slashy.string=Cadena de barra de dólar
local.variable.types=Tipo de variable local
settings.inlay.show.variable.type.hints=Mostrar sugerencia de tipo de variable local
settings.inlay.put.type.hint.before.identifier=Ponga una sugerencia de tipo antes del identificador.
dialog.title.select.groovy.sdk=Seleccione el SDK de Groovy
label.groovy.sdk=SDK maravilloso:
groovy.term.type.parameter=Tipo de parámetro
documentation.cannot.infer.type.label=No se pudo inferir el tipo
documentation.inferred.type.label=Tipo de inferencia
documentation.gdk.label=GDK
inspection.message.modifier.sealed.available.with.groovy.or.later=El controlador 'sellado' está disponible en Groovy 4.0 y superiores
illegal.sealed.modifier.fix=Quitar el controlador 'sellado'
inspection.message.modifier.nonsealed.available.with.groovy.or.later=El controlador 'no sellado' está disponible en Groovy 4.0 y superiores
illegal.nonsealed.modifier.fix=Quitar el controlador 'no sellado'
inspection.message.permits.available.with.groovy.4.or.later='permisos' está disponible en Groovy 4.0 y superior.
inspection.message.only.one.final.sealed.non.sealed.should.be.applied.to.class=Solo se debe aplicar a la clase uno de 'final', 'sealed', 'non-sealed', @Sealed o @NonSealed
inspection.message.modifier.sealed.cannot.be.applied.to.enum.class=El modificador 'sellado' no se puede aplicar a una clase de enumeración
inspection.message.modifier.non.sealed.cannot.be.applied.to.enum.class=El modificador 'no sellado' no se puede aplicar a una clase de enumeración
inspection.message.invalid.permits.clause.must.be.sealed=Cláusula de permisos no válidos: ''{0}'' debe estar ''sellado''
inspection.message.invalid.permits.clause.must.directly.extend=Cláusula de ''permisos'' no válida: ''{0}'' debe extender ''{1}'' directamente
inspection.message.not.allowed.in.sealed.hierarchy=''{0}'' no está permitido en la jerarquía sellada
inspection.display.name.unnecessary.sealed.modifier=Controlador 'sellado' innecesario
inspection.display.name.unnecessary.non.sealed.modifier=Controlador 'no sellado' innecesario
inspection.message.interface.has.no.explicit.or.implicit.implementors=La interfaz ''{0}'' no tiene implementadores permitidos explícitos o implícitos.
inspection.message.class.has.no.explicit.or.implicit.subclasses=La clase ''{0}'' no tiene subclases permitidas explícita o implícitamente.
inspection.display.name.non.extending.permitted.subclasses=Subclases no extensibles
sealed.visibility.presentation=Sellado
non.sealed.visibility.presentation=No sellado
intention.family.name.add.class.to.clause=Agregar clase a la cláusula
inspection.message.interface.cannot.be.non.sealed.without.sealed.parent=La interfaz ''{0}'' no puede ser no sellada sin un padre sellado
inspection.message.class.cannot.be.non.sealed.without.sealed.parent=La clase ''{0}'' no puede ser no sellada sin un padre sellado
inspection.message.annotation.sealed.cannot.be.applied.to.enum.class=La anotación '@Sealed' no se puede aplicar a las clases de enumeración
inspection.message.annotation.non.sealed.cannot.be.applied.to.enum.class=La anotación '@NonSealed' no se puede aplicar a las clases de enumeración
dialog.title.specify.groovy.sdk=Especificar un hogar de Groovy SDK
dialog.title.no.jdk.specified.error=Groovy SDK no especificado
dialog.title.no.jdk.specified.title=Groovy SDK no especificado
dialog.title.no.jdk.specified.prompt=¿Le gustaría crear un proyecto sin un SDK asignado?
inspection.message.switch.expressions.are.available.with.groovy.4.or.later=Las expresiones de cambio están disponibles en Groovy 4.0 y superiores.
inspection.message.arrows.in.case.expressions.are.available.with.groovy.4.or.later=Las flechas en caso de que las expresiones estén disponibles en Groovy 4.0 y superiores.
inspection.message.multiple.expressions.in.case.section.are.available.with.groovy.4.or.later=Hay varias expresiones en etiquetas de casos disponibles en Groovy 4.0 y versiones posteriores.
inspection.message.keyword.yield.available.with.groovy.4.or.later=La palabra clave 'rendimiento' está disponible en Groovy 4.0 y superiores
inspection.message.mixing.arrows.colons.not.allowed=Las flechas y los dos puntos no se pueden usar juntos
inspection.message.yield.or.throw.expected.in.case.section=Se requiere 'ceder' o 'lanzar' en la sección del caso
inspection.message.switch.expressions.do.not.support.return=La expresión de cambio no admite 'retorno'
intention.family.name.replace.keywords=Cambiar palabra clave
inspection.message.case.or.default.branches.are.expected=Requiere rama 'caso' o 'predeterminada'
inspection.display.name.switch.exhaustiveness.check=Comprobación minuciosa de expresiones de cambio
inspection.message.switch.expression.does.not.cover.all.possible.outcomes=La expresión de cambio no incluye todos los resultados posibles
intention.family.name.add.missing.case.branches=Agregar rama de caso faltante
intention.name.insert.default.branch=Insertar rama 'predeterminada'
intention.name.insert.case.0=Insertar ''caso {0}''
intention.name.insert.case.0.case.1=Insertar ''caso {0}'', ''caso {1}''
intention.name.insert.missing.branches=Insertar rama faltante
checkbox.report.unmatched.null=Informes "nulos" inconsistentes
inspection.message.left.open.ranges.are.available.in.groovy.4.or.later=El rango abierto izquierdo está disponible en Groovy 4.0 y superiores
inspection.message.both.open.ranges.are.available.in.groovy.4.or.later=Ambos ámbitos abiertos están disponibles en Groovy 4.0 y superior.
inspection.message.fraction.literals.without.leading.zero.are.available.in.groovy.or.later=Los literales de fracciones sin ceros a la izquierda están disponibles en Groovy 4.0 y versiones posteriores.
inspection.message.cannot.resolve.method.call=El método 'llamada' no se puede resolver
intention.family.name.replace.modifiers=Cambiar controlador
leave.only.modifier.or.annotation.0=Deje solo ''{0}''
add.modifier.sealed=Agregar controlador 'sellado'
inlay.groovy.implicit.null.argument.hint.description=Una llamada que no pasa argumentos a un método que toma un argumento. Es decir, se pasa un nulo implícito como argumento.
inlay.groovy.parameters.hints.inferred.parameter.types=Tipos de parámetros inferidos del método.
inlay.groovy.parameters.hints.type.parameter.list=Un método con uno o más parámetros de tipo inferido.
inspection.display.name.pojo.without.compile.static=@POJO sin @CompileStatic
inspection.message.pojo.has.effect.only.with.compilestatic=@POJO sólo es efectivo con @CompileStatic
add.compilestatic=Agregar @CompileStatic
groovy.term.record=Registro
code.style.option.before.record.parameter.list=Antes de la lista de parámetros del historial
inspection.message.records.are.available.in.groovy.4.or.later=El historial está disponible en Groovy 4.0.0-beta-2 y superior
inspection.display.name.unnecessary.final.modifier='final' innecesario
inspection.message.0.not.allowed.for.record=''{0}'' no está permitido en el historial
intention.name.remove.wrong.modifiers.for.record=Eliminar el controlador de registro incorrecto
inspection.message.compact.constructor.should.have.explicit.visibility.modifier=Un constructor compacto debe tener un modificador de visibilidad implícito.
intention.name.make.compact.constructor.public=Establecer constructor compacto como 'público'
inspection.message.record.parameter.should.be.immutable=El parámetro de registro ''{0}'' debe tener un tipo inmutable o declararse como un tipo inmutable usando @ImmutableOptions
dialog.title.validation.path.should.not.be.empty=La ruta no puede estar en blanco
dialog.title.validation.path.does.not.contain.groovy.sdk=Groovy SDK no encontrado en la ruta
dialog.title.validation.invalid.sdk.specified.title=SDK de Groovy especificado no válido
dialog.title.validation.invalid.sdk.specified.error=SDK de Groovy especificado no válido
dialog.title.validation.directory.you.specified.does.not.contain.groovy.sdk.do.you.want.to.create.project.with.this.configuration=Especificó un directorio que no contiene el SDK de Groovy. ¿Le gustaría crear un proyecto con esta configuración?
inspection.separator.disable.in.file.types=Habilitar en tipo de archivo:
postfix.template.provider.name=Groovy
new.project.wizard.groovy.retrieving.has.failed=No se pudo obtener la versión Groovy
new.project.wizard.groovy.creating.main.file=Creando el archivo principal de Groovy…
new.class.list.item.record=Registro
create.record.text=Crear registro {0}
code.style.groovydoc.tab.name=GroovyDoc
notification.group.groovy.dsl=Error de DSL maravilloso
notification.group.grape=Groovy @Grab anotado
call.without.parentheses.are.supported.since.groovy.3=Las llamadas sin paréntesis en la lista de argumentos se admiten a partir de Groovy 3.0
newlines.here.are.available.since.groovy.3=Los caracteres de nueva línea dentro de las listas de argumentos están disponibles a partir de Groovy 3.0
ginq.error.message.expected.in.operator='... mi … ' es necesario
ginq.error.message.expected.alias=Se requiere el nombre de alias
ginq.error.message.expected.data.source=Se requiere una fuente de datos
ginq.error.message.expected.a.boolean.expression=Se requiere una expresión booleana
ginq.error.message.on.is.expected.after.join=Se requiere 'on' después de cláusulas similares a 'join'
ginq.error.message.groupby.expected.a.list.of.expressions=Necesito una lista de expresiones
ginq.error.message.orderby.expected.a.list.of.ordering.fields=Necesito una lista de campos para ordenar
ginq.error.message.expected.one.or.two.arguments.for.limit='límite' requiere uno o dos argumentos
ginq.error.message.unrecognized.query=Consulta no reconocida
ginq.error.message.0.must.be.before.1={0}'' debe estar antes de ''{1}
ginq.error.message.0.must.be.after.1={0}'' debe ir después de ''{1}
ginq.error.message.from.must.be.in.the.start.of.a.query='de' debe estar al principio de la consulta
ginq.error.message.query.should.start.from.from=Las consultas deben comenzar con 'de'
ginq.error.message.query.should.end.with.select=La consulta debe terminar con 'select'
ginq.error.message.boolean.condition.expected=Requiere condición booleana
ginq.error.message.container.expected=Requiere GINQ, Iterable, Stream o Array
ginq.error.message.on.should.not.be.provided.after.crossjoin=On' no debe aparecer después de 'crossjoin
ginq.code.style.group.ginq.clauses=Cláusula GINQ
ginq.code.style.option.wrap.on.clauses=Salto de línea de cláusula 'on'
ginq.code.style.option.indent.on.clauses=Sangrar la cláusula 'on'
ginq.code.style.option.wrap.having.clauses=Salto de línea de cláusula 'tener'
ginq.code.style.option.indent.having.clauses=Sangrar la cláusula "tener"
ginq.code.style.option.space.after.keyword=Pon un espacio después de las palabras clave.
inlay.groovy.variable.type.hints.description=Un tipo de variable local que no se especifica explícitamente en la declaración.
shows.parameter.names.at.function.call.sites=Muestra los nombres de los parámetros en el sitio de llamada a la función.
inspection.message.static.interface.methods.must.be.qualified.in.groovy.4=A partir de Groovy 4 deberías poder utilizar métodos de interfaz "estáticos".
intention.name.replace.with.qualified.expression=Reemplazar con nombre completo
intention.name.add.to.clause=Agregue ''{0}'' a la cláusula {1} de ''{2}''
declared.type.0.extends.1.which.is.circular.inheritance=El tipo declarado ''{0}'' extiende ''{1}''. Esta es la herencia circular.
intention.name.replace=Reemplace ''{0}'' con ''{1}''
intention.name.create.abstract.method.in.class=Crear método abstracto ''{0}'' en ''{1}''
intention.name.create.method.in.class=Crear método ''{0}'' en ''{1}''
intention.name.create.constant.field.in.class=Crear campo constante ''{0}'' en ''{1}''
intention.name.create.field.in.class=Crear campo ''{0}'' en ''{1}''
intention.name.create.enum.constant.0=Crear constante de enumeración ''{0}''
attribute.descriptor.annotations=anotación
attribute.descriptor.annotation.attribute.name=Nombre de propiedad de anotación
attribute.descriptor.annotation.name=nombre de la anotación
attribute.descriptor.braces.and.operators=Tirantes y operadores
attribute.descriptor.braces=abrazadera
attribute.descriptor.closure.expression.braces.and.arrow=Llaves y flechas de expresión de cierre
attribute.descriptor.lambda.expression.braces.and.arrow=Llaves y flechas de expresión lambda
attribute.descriptor.brackets=corchetes
attribute.descriptor.parentheses=paréntesis
attribute.descriptor.operator.sign=símbolo del operador
attribute.descriptor.comments=Comentario
attribute.descriptor.line.comment=comentarios de línea
attribute.descriptor.block.comment=Bloque de comentario
attribute.descriptor.groovydoc=GroovyDoc
attribute.descriptor.groovydoc.text=Texto
attribute.descriptor.groovydoc.tag=etiqueta
attribute.descriptor.classes.and.interfaces=clases e interfaces
attribute.descriptor.class=clase
attribute.descriptor.abstract.class=clase abstracta
attribute.descriptor.anonymous.class=clase anónima
attribute.descriptor.interface=interfaz
attribute.descriptor.trait=característica
attribute.descriptor.enum=enumeración
attribute.descriptor.type.parameter=tipo de parámetro
attribute.descriptor.methods=método
attribute.descriptor.method.declaration=declaración de método
attribute.descriptor.constructor.declaration=declaración del constructor
attribute.descriptor.instance.method.call=Llamada al método de instancia
attribute.descriptor.static.method.call=llamada a método estático
attribute.descriptor.constructor.call=Llamada de constructor
attribute.descriptor.fields=campo
attribute.descriptor.instance.field=campo de instancia
attribute.descriptor.static.field=campo estático
attribute.descriptor.variables.and.parameters=variables y parámetros
attribute.descriptor.local.variable=variable local
attribute.descriptor.reassigned.local.variable=variable local reasignada
attribute.descriptor.parameter=parámetro
attribute.descriptor.reassigned.parameter=Parámetros reasignados
attribute.descriptor.references=referencia
attribute.descriptor.instance.property.reference=Referencia de propiedad de instancia
attribute.descriptor.static.property.reference=Referencia de propiedad estática
attribute.descriptor.unresolved.reference=referencias no resueltas
attribute.descriptor.strings=cadena
attribute.descriptor.string=String
attribute.descriptor.gstring=GString
attribute.descriptor.valid.string.escape=Escape de cadena correcto
attribute.descriptor.invalid.string.escape=Escape de cadena no válido
attribute.descriptor.keyword=palabra clave
attribute.descriptor.number=número
attribute.descriptor.bad.character=carácter invalido
attribute.descriptor.list.map.to.object.conversion=Convertir de lista/mapa a objeto
attribute.descriptor.map.key.named.argument=Clave de mapa/parámetros con nombre
attribute.descriptor.label=etiqueta
