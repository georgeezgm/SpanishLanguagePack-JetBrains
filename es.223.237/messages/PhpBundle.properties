action.ChangePHPInterpreter.text=PHP 인터프리터 변경
action.ChangePHPInterpreter.description=프로젝트 PHP 인터프리터를 변경합니다
action.MessDetectorAddToIgnored.text=PHPMD 무시 목록에 추가
action.MessDetectorAddToIgnored.description=PHP Mess Detector 무시 목록에 추가합니다.
action.PhpCSFixerAddToIgnored.text=PHP CS 픽서 무시 목록에 추가
action.PhpCSFixerAddToIgnored.description=PHP CS Fixer 무시 목록에 추가합니다.
action.PhpCSAddToIgnored.text=PHPCS 무시 목록에 추가
action.PhpCSAddToIgnored.description=PHP_CodeSniffer 픽서 무시 목록에 추가합니다
group.PHPQualityToolsAddToIgnoredList.text=무시 목록에 추가…
action.ComposerShowLogAction.text=로그 표시
action.ComposerShowLogAction.description=Composer 액션 로그를 이 composer.json으로 표시합니다
action.ComposerClearCacheAction.text=캐시 지우기
action.ComposerClearCacheAction.description=컴포저의 캐시 디렉터리에서 모든 콘텐츠 삭제
action.ComposerSelfUpdateAction.text=자체 업데이트
action.ComposerSelfUpdateAction.description=Composer를 최신 버전으로 업데이트합니다
group.ComposerToolsGroup.text=Composer
action.com.jetbrains.php.composer.ComposerInitSupportAction.text=Composer 초기화…
action.com.jetbrains.php.composer.ComposerInitSupportAction.description=Composer를 초기화합니다
group.ComposerGroup.text=Composer
action.ComposerDiagnoseAction.text=진단
action.ComposerDiagnoseAction.description=공통된 Composer 문제를 확인합니다
action.ComposerLicensesAction.text=라이선스 목록 나열
action.ComposerLicensesAction.description=설치된 모든 패키지의 이름, 버전, 라이선스를 나열합니다
action.ComposerStatusAction.text=종속성 변경 내용 확인
action.ComposerStatusAction.description=종속성에 로컬 변경 내용이 있는지 확인
action.ComposerDryRunUpdate.text=업데이트 시뮬레이션
action.ComposerDryRunUpdate.description=실제로 업데이트하지 않고 시뮬레이션합니다
action.ComposerDumpAutoloadAction.text=오토로더 덤프…
action.ComposerDumpAutoloadAction.description=자동 로드된 클래스의 목록을 재생성합니다
action.ComposerValidateAction.text=유효성 검사…
action.ComposerValidateAction.description=composer.json이 올바른지 확인
action.ComposerAddDependencyAction.text=종속성 관리…
action.ComposerAddDependencyAction.description=컴포저 종속성 관리
action.ComposerUpdateAction.text=업데이트
action.ComposerUpdateAction.description=composer.json에서 적절한 최신 버전의 패키지를 설치합니다
action.ComposerInstallAction.text=설치
action.ComposerInstallAction.description=composer.lock을 참고하여 composer.json의 패키지를 설치합니다
action.com.jetbrains.php.internal.PhpViewControlFlowAction.text=현재 파일의 PHP 제어 흐름
action.com.jetbrains.php.internal.PhpShowFQNInternalAction.text=PHP FQN 표시
action.ProfilerJumpToSource.text=소스로 이동
action.ProfilerJumpToSource.description=소스로 이동
action.XdebugAnalyzeProfilerSnapshotAction.text=Xdebug 프로파일러 스냅샷 분석…
group.DBGPProxyGroup.text=DBGp 프록시
action.PhpDebuggerCopyType.text=타입 복사
action.XDebugger.CopyPath.text=경로 복사
action.PhpDetectPsroRoots.text=PSR-0 네임스페이스 루트 탐지
action.PhpDetectPsroRoots.description=소스 네임스페이스 루트를 감지합니다
action.PhpListenDebugAction.text=디버그 연결 리스닝
action.PhpListenDebugAction.description=디버그 연결을 듣습니다
action.PhpMakeStaticAction.text=을(를) 정적으로 설정
action.PhpMakeStaticAction.description=클래스 메서드를 정적으로 만들기
action.PhpExtractClassAction.text=클래스 추출…
action.PhpExtractClassAction.description=요소를 개별 클래스로 추출합니다.

action.PhpNewTest.text=PHP 테스트
action.PhpNewTest.description=새 PHP 테스트를 생성합니다
group.PhpNewTestGroup.text=PHP 테스트
action.PhpUnitGenerateTearDownMethod.text=TearDown 메서드
action.PhpUnitGenerateTearDownMethod.description=PHPUnit tearDown 메서드 생성
action.PhpUnitGenerateSetUpMethod.text=SetUp 메서드
action.PhpUnitGenerateSetUpMethod.description=PHPUnit setUp 메서드 생성
action.PhpUnitGenerateTestMethod.text=테스트 메서드
action.PhpUnitGenerateTestMethod.description=PHPUnit 테스트 메서드 생성
action.PhpGeneratePhpDocBlocks.text=PHPDoc 블록…
action.PhpGeneratePhpDocBlocks.description=함수, 클래스 및 필드에 PHPDoc 블록을 추가합니다.
action.PhpGenerateSetters.text=setter…
action.PhpGenerateSetters.description=private 클래스 필드에 대한 setter 생성.
action.PhpGenerateGettersAndSetters.text=getter 및 setter…
action.PhpGenerateGettersAndSetters.description=private 클래스 필드에 대한 getter 및 setter 생성
action.PhpGenerateGetters.text=getter…
action.PhpGenerateGetters.description=개인 클래스 필드에 대한 getter 생성
action.PhpGenerateConstructor.text=생성자…
action.PhpGenerateConstructor.description=생성자를 생성합니다.

# php colors page elements
color.settings.name=PHP
color.settings.php.scripting=PHP 코드//백그라운드
color.settings.php.tags=PHP 코드//태그
color.settings.keyword=키워드
color.settings.comment=주석
color.settings.number=숫자
color.settings.string=문자열//문자
color.settings.escape_sequence=문자열//이스케이프 시퀀스
color.settings.operation=괄호 및 연산자//연산자
color.settings.brackets=괄호 및 연산자//대괄호
color.settings.parentheses=괄호 및 연산자//소괄호
color.settings.braces=괄호 및 연산자//중괄호
color.settings.bad_character=알 수 없는 문자
color.settings.comma=괄호 및 연산자//쉼표
color.settings.semicolon=괄호 및 연산자//세미콜론
color.settings.heredoc_id=Heredoc//Heredoc ID
color.settings.heredoc_content=Heredoc//Heredoc 콘텐츠
color.settings.var=식별자//변수
color.settings.var_var=식별자//가변 변수
color.settings.this.var=식별자//'$this' 변수
color.settings.identifier=식별자//디폴트
color.settings.constant=식별자//상수
color.settings.function=함수 및 메서드/선언
color.settings.parameter=함수 및 메서드//매개변수
color.settings.function.call=함수 및 메서드//함수 호출
color.settings.instance.method=함수 및 메서드/인스턴스 메서드 호출
color.settings.instance.protected.method=함수 및 메서드//protected 인스턴스 메서드 호출
color.settings.instance.private.method=함수 및 메서드//private 인스턴스 메서드 호출
color.settings.static.method=함수 및 메서드//정적 메서드 호출
color.settings.magic.member=식별자//매직 멤버 액세스
color.settings.class=클래스 및 프로퍼티//클래스
color.settings.interface=클래스 및 프로퍼티//인터페이스
color.settings.static.field=클래스 및 프로퍼티//static 프로퍼티
color.settings.instance.field=클래스 및 프로퍼티//인스턴스 프로퍼티
color.settings.instance.protected.field=클래스 및 프로퍼티//protected 인스턴스 프로퍼티
color.settings.instance.private.field=클래스 및 프로퍼티//private 인스턴스 프로퍼티
color.settings.doccomment=PHPDoc//텍스트
color.settings.doctag=PHPDoc//태그
color.settings.docmarkup=PHPDoc//Markup
color.settings.doc.identifier=PHPDoc//식별자
color.settings.doc.parameter=PHPDoc//매개변수
color.settings.doc.var=PHPDoc//변수
color.settings.doc.method.identifier=PHPDoc//메서드 선언
color.settings.doc.property.identifier=PHPDoc//프로퍼티
color.settings.exec_command=셸 명령어
color.settings.concatenation=문자열//연결
color.settings.predefined.symbols=식별자//사전 정의된 심볼
color.settings.goto.label=식별자//Goto 라벨
color.settings.alias.reference=식별자//별칭 참조
color.settings.alias.primitive.type.hint=식별자//기본 타입 힌트
color.settings.named.arguments=이름 지정된 인수
color.settings.attributes=속성

# annotations
annotation.variable.variable=가변 변수
annotation.new.expression.interface=인터페이스 ''{0}''을(를) 인스턴스화할 수 없습니다
annotation.new.expression.trait=프로퍼티 ''{0}''을(를) 초기화할 수 없습니다.
annotation.new.expression.abstract=추상 클래스 ''{0}''을(를) 인스턴스화할 수 없습니다
annotation.expression.is.not.allowed.as.class.constant.value=표현식은 클래스 상수 값으로 허용되지 않습니다.

#folding
folding.checkbox.collapse.imports=Import 문
folding.checkbox.collapse.method.body=메서드 본문
folding.checkbox.collapse.function.body=함수 본문
folding.checkbox.collapse.php.tags=태그
folding.checkbox.collapse.heredocs.and.nowdocs=HEREDOC\\NOWDOC
folding.checkbox.collapse.classes=클래스 본문

#gutter
gutter.overriding.select.title=이동할 상위 메서드 선택
gutter.overriden.select.subclass.title={0}의 하위 클래스 선택
gutter.overriden.select.implementation.title={0}의 구현 선택
#gutter-pinned
gutter.pin.overriding.select.title={0}의 상위 항목
gutter.pin.overriden.select.subclass.title={0}의 구현
gutter.pin.overriden.select.implementation.title={0}의 구현

# inspections
inspection.group=PHP
inspection.group.general=일반
inspection.group.unused=사용되지 않음
inspection.group.unused.quickfix.label=사용되지 않는 요소
inspection.group.unused.quickfix.message=사용되지 않는 요소: ''{0}''
inspection.group.undefined=정의되지 않음
inspection.group.control.flow=제어 흐름
inspection.group.php.doc=PHPDoc
inspection.group.probably.bug=발생할 수 있는 버그
inspection.group.type.compatibility=타입 호환성
inspection.group.code.style=코드 스타일
inspection.group.code.smell=코드 스멜
inspection.group.naming.convention=이름 생성 규칙


inspection.dead.code.problem.empty.constant.synopsis=상수가 한 번도 사용되지 않습니다.
inspection.dead.code.problem.single.constant.synopsis=상수가 1곳에서 사용되지만 그곳에 도달할 수 없습니다.
inspection.dead.code.problem.multiple.constant.synopsis=상수가 {0, choice, 1#1곳|2#{0,number}곳}에서 사용되지만 진입점에서 그곳에 도달할 수 없습니다.
inspection.dead.code.problem.empty.function.synopsis=함수가 한 번도 사용되지 않습니다.
inspection.dead.code.problem.recursive.suspicious.function.synopsis=진입점에서 도달 가능한 멤버가 없는 호출 체인에 모든 함수의 사용 위치가 속해 있습니다.
inspection.dead.code.problem.suspicious.function.synopsis=진입점에서 함수에 도달할 수 없습니다.
inspection.dead.code.problem.trait.synopsis=특성이 사용되지 않습니다.
inspection.dead.code.problem.class.nousages.synopsis=클래스가 한 번도 사용되지 않습니다.
inspection.dead.code.problem.trait.additional.unreachable=특성에 도달 가능한 사용 위치가 없습니다.
inspection.dead.code.problem.trait.additional.reachable=특성에 도달 가능한 사용 위치가 있습니다.
inspection.dead.code.problem.class.abstract.several.implementations={0}에 {1, choice, 1#1개의 직접적 혹은 간접적 구현|2#{1,number}개의 직접적 혹은 간접적 구현}이 있지만 <ul><li>인스턴스화되지 않았거나</li><li>진입점에서 도달 가능한 인스턴스화된 항목이 없습니다.</li></ul>

inspection.hierarchyChecks=클래스 계층 구조 검사
inspection.hierarchyChecks.descr=클래스는 추상 또는 구현 {0}(으)로 선언되어야 합니다.
inspection.hierarchyChecks.should.implement=클래스는 {0}을(를) 구현해야 합니다
inspection.hierarchyChecks.field.type.redeclaration.must.not.be.defined=타입은 정의하면 안 됩니다(기본 클래스 ''{0}''와(과) 동일).
inspection.hierarchyChecks.field.type.redeclaration.match.super.type=타입은 ''{0}''이어야 합니다(기본 클래스 ''{1}''와(과) 동일).
inspection.wrong_param_type=타입 ''{1}''의 매개변수가 필요한데 ''{0}''이(가) 제공되었습니다.
inspection.missing_param=필수 매개변수 ''{0}''(이)가 누락되었습니다
inspection.optional.before.required=선택적 매개변수가 필수 매개변수 앞에 제공되었습니다.
#inspection -> Super class incompatible with interface
inspection.super.incompatible.with.interface.declaration.must.be.compatible=''{0}''의 선언은 ''{1}''와(과) 호환되어야 합니다.

#inspection -> Wrong Exception order
inspection.wrong.exception.order.problem.batch=예외 '#ref'이(가) 이미 포착되었습니다
inspection.wrong.exception.order.problem.same=예외 ''{0}''이(가) 이미 포착되었습니다.
inspection.wrong.exception.order.problem.super=예외 클래스 ''{1}''의 하위 클래스인 ''{0}''이(가) 이미 포착되었습니다.

inspection.wrong.exception.order.fix.move.display.name=''catch'' 절을 ''{0}'' 앞으로 이동
inspection.wrong.exception.order.fix.move.family.name='catch' 절 이동
#inspection -> Wrong Exception class
inspection.wrong.exception.type.problem.throw = 던져진 객체는 'Exception' 또는 'Throwable'의 인스턴스여야 합니다
inspection.wrong.exception.type.problem.catch = 'Exception' 또는 'Throwable' 기본 클래스에서 파생된 객체를 포착할 수 없습니다.

#inspection -> Assigned value never used
#inspection -> Wrong foreach argument
inspection.wrong.foreach.argument.type.problem.batch='foreach'로 잘못된 인수가 제공되었습니다.
inspection.wrong.foreach.argument.type.problem=''foreach''로 잘못된 인수가 제공되었습니다. 필요한 타입은 ''array'' 또는 ''object''인데 ''{0}''이(가) 제공되었습니다.

#inspection -> Redundant PHPDoc
inspection.redundant.phpdoc=중복 PHPDoc 주석

#inspection -> Unused local variable
inspection.unused.local.variable.problem=사용되지 않는 지역변수 ''{0}''. {1}
inspection.unused.local.variable.problem.batch=지역 변수 '#ref'이(가) 어디에도 사용되지 않습니다.
inspection.unused.local.variable.problem.case1=변숫값이 어디에도 사용되지 않습니다.
inspection.unused.local.variable.problem.case2=변숫값이 즉시 덮어쓰기 됩니다.
inspection.unused.local.variable.problem.case3=변수에 저장된 참조가 어디에도 사용되지 않습니다.
inspection.unused.local.variable.problem.case4=변수에 저장된 참조가 즉시 덮어쓰기 됩니다.
inspection.unused.local.variable.option.description.foreach='list()' 내에 있거나 'foreach' 키가 있을 경우 foreach 값 무시
inspection.unused.local.variable.option.description.list='list()' 내의 변수 무시
inspection.unused.local.variable.option.description.file.scope=전체 공간에서 검사 활성화
inspection.unused.local.variable.option.description.null='null'에 대한 대입 무시
inspection.unused.local.variable.option.indirect.access='get_defined_vars()'를 통해 액세스된 변수 무시
inspection.unused.local.variable.problem.fix.side.effects.found.dialog.title=부수 효과 발견
inspection.unused.local.variable.problem.fix.side.effects.found.dialog.message=''{0}''에 대입된 표현식에 부수 효과가 포함된 것 같습니다.\n\
해결 방법:\n\
- 변수 대입을 완전히 <b>제거</b>\n\
- 대입된 표현식을 별도의 구문으로 <b>변환</b>

#inspection -> Unused parameter
inspection.unused.parameter.problem=사용되지 않는 매개변수 ''{0}''. {1}
inspection.unused.parameter.problem.case1=매개변숫값이 어디에도 사용되지 않습니다.
inspection.unused.parameter.problem.case2=매개변숫값이 즉시 덮어쓰기 됩니다.
inspection.unused.parameter.problem.case3=매개변수에 저장된 참조가 어디에도 사용되지 않습니다.
inspection.unused.parameter.problem.case4=매개변수에 저장된 참조가 즉시 덮어쓰기 됩니다.
inspection.unused.parameter.option.description.empty.body=본문이 비어 있는 메서드/함수의 매개변수 무시
inspection.unused.parameter.option.description.empty.abstract=추상 클래스 메서드의 매개변수 무시
inspection.unused.parameter.option.description.empty.override=재정의 메서드의 매개변수 무시
inspection.unused.parameter.option.description.empty.anonymous=익명 함수의 매개변수 무시
inspection.unused.parameter.option.description.parameter.count='func_num_args()'를 통해 액세스된 매개변수를 보고 안 함

#inspection -> Unused private method
inspection.unused.private.method.problem.batch=사용되지 않는 private 메서드 '#ref'
inspection.unused.private.method.option.ignore.constructor=메서드 '__construct'의 사용 위치 무시
inspection.unused.private.method.option.ignore.clone=메서드 '__clone'의 사용 위치 무시

#inspection -> Undefined callback
inspection.undefined.callback.method=클래스 ''{1}''에서 메서드 ''{0}''을(를) 찾을 수 없습니다.
inspection.undefined.callback.field=클래스 ''{1}''에서 프로퍼티 ''{0}''을(를) 찾을 수 없습니다.
inspection.undefined.callback.class=정의되지 않은 클래스 ''{0}''
inspection.undefined.callback.function=정의되지 않은 함수 ''{0}''
inspection.undefined.callback.dont.report.exist.checkbox='*_exists' 및 'is_callable' 함수의 콜백 무시
inspection.undefined.callback.dont.report.ambiguity.checkbox=모호한 경우 보고 안 함

#inspection -> Missing parent call
inspection.missing.parent.call.message=상위 메서드 호출이 누락되었습니다.

#inspection -> Missing parent constructor call
inspection.missing.parent.constructor.call.message=상위 생성자 호출이 누락되었습니다.

#inspection - > Undefined variable
inspection.undefined.variable.problem1=정의되지 않은 변수 '#ref'
inspection.undefined.variable.problem2=변수 '#ref'이(가) 정의되지 않은 것 같습니다.
inspection.undefined.variable.option.description.enable.in.file.scope=전체 공간에서 검사 활성화
inspection.undefined.variable.option.description.report.can.be.undefined=변수가 정의되지 않았을 가능성 보고
inspection.undefined.variable.option.description.ignore.include=현재 파일 외부에 있는 변수 정의 검색

#inspection -> Wrong String concatenation operator
inspection.wrong.string.concatenation.operator.problem=잘못된 문자열 연결 연산자
inspection.wrong.string.concatenation.operator.problem.batch=잘못된 문자열 연결 연산자
inspection.wrong.string.concatenation.operator.option.ignore.magic=매직 메서드를 통해 액세스된 프로퍼티 무시

#inspection -> Dynamic method called as static
inspection.dynamic.method.called.as.static.problem=비 static 메서드 '#ref'을(를) static으로 호출해서는 안 됩니다.
inspection.dynamic.method.called.as.static.problem.magic=비 static 메서드 '#ref'을(를) static으로 호출해서는 안 되지만 클래스에 '__magic' 메서드가 있습니다.

#inspection -> Static method called as dynamic
inspection.static.method.called.as.dynamic.problem=static 메서드 '#ref'을(를) dynamic으로 호출해서는 안 됩니다.
inspection.static.method.called.as.dynamic.problem.magic=static 메서드 '#ref'을(를) dynamic으로 호출해서는 안 되지만 클래스에 '__magic' 메서드가 있습니다.

#inspection -> Assignment in condition
inspection.assignment.in.condition=조건 내 대입
inspection.assignment.in.condition.move.assignment.out.of.condition.fix.name=조건에서 대입 제거

#inspection -> Division by zero
inspection.division.by.zero=0으로 나누기

#inspection -> Dynamic namepsace
#inspection -> Unreachable Statement
inspection.unreachable.statement=도달할 수 없는 명령문
inspection.unreachable.statement.problem=도달할 수 없는 구문

#inspection -> Missing doc comment
inspection.missing.doc.comment.problem=PHPDoc 주석 누락
inspection.missing.doc.comment.problem.batch={0}에 대한 PHPDoc 주석 누락
inspection.missing.doc.comment.options.panel.constant=상수(&O)
inspection.missing.doc.comment.options.panel.function=함수(&F)
inspection.missing.doc.comment.options.panel.class=클래스(&C)
inspection.missing.doc.comment.options.panel.method=메서드(&M)
inspection.missing.doc.comment.options.panel.field=프로퍼티(&P)
inspection.missing.doc.comment.options.panel.class.constant=클래스 상수(&A)

#inspection -> Silly assignment
inspection.silly.assignment.problem=대입식의 왼쪽과 오른쪽이 동일하지 않습니다

#inspection -> Illegal array key type
inspection.illegal.array.key.type.problem=잘못된 배열 키 타입

#inspection -> Illegal string offset
inspection.illegal.string.offset.problem=잘못된 문자열 오프셋 {0}

#inspection -> Missing @return tag
inspection.doc.missing.return.tag.problem=함수/메서드 PHPDoc 주석에 @return 태그가 누락되었습니다

#inspection -> Doc signature inspection

#inspection -> Missing @throws tag
inspection.doc.throws.problem=PHPDoc 주석에 모든 필수 @throws 태그가 포함되어 있지 않습니다
inspection.doc.throws.option.skip.on.empty.phpdoc=@param/@return이 없는 PHPDoc 무시

#inspection -> Inconsistent return points
inspection.inconsistent.return.points.problem1='return' 문 누락
inspection.inconsistent.return.points.problem1.yield='yield' 문 누락
inspection.inconsistent.return.points.problem2=return 인수 누락
inspection.inconsistent.return.points.option.treat.return='return null' 및 'return'을 'void' 함수/메서드와 동일한 방식으로 취급

#inspection -> Redundant closing tag
inspection.redundant.closing.tag.problem=닫는 태그 중복
inspection.redundant.closing.tag.fix.remove=닫는 태그 제거

#inspection -> Void function result used
inspection.void.function.result.used.problem1=''void'' 함수 ''{0}''의 결과가 사용되었습니다
inspection.void.function.result.used.problem2=''void'' 메서드 ''{0}''의 결과가 사용되었습니다

#inspection -> Expression result unused
inspection.expression.result.unused.problem=표현식 결과가 어디에도 사용되지 않습니다

#inspection -> Missing 'break' statement
inspection.missing.break.statement.problem='break' 문 누락

#inspection -> Nested vs outer 'foreach' variables conflict
inspection.nested.vs.outer.foreach.variables.conflict.problem1=변수 ''{0}''이(가) 내부 및 외부 ''foreach'' 루프 모두에서 키로 사용되고 있습니다
inspection.nested.vs.outer.foreach.variables.conflict.problem2=변수 ''{0}''이(가) 내부 및 외부 ''foreach'' 루프 모두에서 값으로 사용되고 있습니다.

#inspection -> Foreach array is used as value
inspection.foreach.array.is.used.as.value.problem=변수 ''{0}''이(가) 이미 ''array expression''으로 사용되고 있습니다

#inspection -> Usage of a silence operator
inspection.usage.of.silence.operator.problem=사일런스 연산자가 사용되었습니다.

#inspection -> Language level
#switch language level quick fix
inspection.language.level.quick.fix.switch.language.level.name.0=PHP{0} 언어 수준으로 전환

#switch language level in composer file manually quick fix
inspection.language.level.quick.fix.switch.language.level.in.composer.manually.0=composer.json에서 PHP {0} 언어 수준으로 수동 전환합니다.
inspection.language.level.quick.fix.switch.language.level.in.composer.0=composer.json에서 PHP {0} 언어 수준으로 전환합니다.


inspection.disabled.quality.tool.inspection.fix=검사 활성화
inspection.disabled.quality.tool.inspection.open.fix=검사 설정을 엽니다.

inspection.disabled.quality.tool.inspection= {0} 검사가 비활성화되어 있습니다.

inspection.json.not.installed.packages=패키지가 설치되어 있지 않습니다.
inspection.json.all.not.installed.packages=패키지가 설치되어 있지 않습니다.
inspection.json.not.installed.packages.update.fix=모든 패키지를 업데이트합니다.
inspection.json.not.installed.package.update.fix=패키지를 업데이트합니다.
inspection.json.not.installed.packages.install.fix=패키지를 설치합니다.
inspection.json.duplicated.packages.0=require 및 require-dev에서 ''{0}''에 대한 항목이 중복되어 있습니다.
inspection.json.duplicated.packages.fix=require-dev에서 중복 항목을 제거합니다.

#inspection -> Duplicate array keys
inspection.duplicate.array.keys.display.name=배열 키 중복
inspection.duplicate.array.keys.problem=배열 키 중복
inspection.duplicate.array.keys.problem.0=값 ''{0}'' 배열 키 중복

#inspection -> Duplicate PhpDoc type
inspection.duplicate.phpdoc.type.problem=타입 ''{0}'' 중복
inspection.duplicate.phpdoc.type.fix=태그에서 중복 타입을 제거합니다.

#inspection -> Undefined constant
inspection.undefined.constant.problem1=정의되지 않은 상수 '#ref'
inspection.undefined.constant.problem2=상수 '#ref'이(가) 정의되지 않은 것 같습니다.

#inspection -> Undefined function
inspection.undefined.function.problem1=정의되지 않은 함수 '#ref'
inspection.undefined.function.problem2=함수 '#ref'이(가) 정의되지 않은 것 같습니다.

#inspection -> Undefined property
inspection.undefined.field.problem1=프로퍼티가 매직 메서드를 통해 액세스되었습니다.
inspection.undefined.field.notify.access.magic.method=매직 메서드를 통한 프로퍼티 액세스를 알림
inspection.undefined.field.notify.dynamic.declaration=dynamic 프로퍼티 선언을 알림

#inspection -> Undefined provider
inspection.undefined.phpunit.provider=정의되지 않은 PHPUnit 데이터 제공자 ''{0}''

#inspection -> PHPUnit missing target for test
inspection.phpunit.missing.target.element.ref='#ref'에 대한 테스트 대상 요소를 찾을 수 없습니다.

#inspection -> Covered function reference is provided without '::'
inspection.phpunit.covers.function.without.scope.resolution.operator=포함된 {0} 참조가 ''::'' 없이 제공되었습니다.

#inspection -> Deprecated assertEquals/assertNotEquals usage
inspection.phpunit.asserts.assertEquals.parameters.many=선택적 {0} 매개변수는 더 이상 사용되지 않습니다.
inspection.phpunit.asserts.assertEquals.parameters.single=선택적 {0} 매개변수는 더 이상 사용되지 않습니다.
inspection.phpunit.asserts.assertEquals.parameters.empty=그러한 매개변수가 있는 호출은 더 이상 사용되지 않습니다.

#inspection -> Usage assertCount/assertSameSize methods instead of assertEquals
inspection.phpunit.asserts.assert.with.count.function=메서드 {0}을(를) {1} 대신 사용할 수 있습니다.

#inspection -> Misordered assertEquals/assertNotEquals arguments
inspection.phpunit.asserts.assertEquals.misordered.arguments=잘못 정렬된 ''{0}()'' 인수

#inspection -> Method assertArrayHasKey/assertArrayNotHasKey can be used instead
inspection.phpunit.asserts.array.has.key.can.be.used.instead=메서드 ''{0}''을(를) 대신 사용 가능

#inspection -> Deprecated expectException usage
inspection.phpunit.expectException={0}이(가) 포함된 expectException()의 사용은 지원 중단되어 PHPUnit 10에서 제거될 예정입니다. 대신 {1}()을(를) 사용하세요.

#inspection -> Unnecessary fully qualified name
inspection.unnecessary.qualifier.already.imported.message=한정자가 불필요하며 제거할 수 있습니다
inspection.unnecessary.fully.qualified.name.option.enable.file.scope=파일 범위에서 활성화
inspection.unnecessary.fully.qualified.name.option.ignore.global.namespace=전역 네임스페이스 무시

#inspection -> Fully qualified name usage
inspection.fully.qualified.name.usage=한정자를 import 문으로 바꿀수 있습니다.
inspection.fully.qualified.name.usage.option.enable.file.scope=파일 범위에서 활성화
inspection.fully.qualified.name.usage.name.option.ignore.global.namespace=전역 네임스페이스 무시

#inspection -> Multiple classes declaration in one file
inspection.multiple.classes.declarations.in.one.file=이 파일에서 또 다른 클래스가 선언되어 있습니다.
#inspection -> Namespace name is not matched with project structure
inspection.illegal.psr.class.path.namespace.name.is.not.matched.to.psr0=네임스페이스 이름이 PSR-0/PSR-4 프로젝트 구조와 일치하지 않습니다.
inspection.illegal.psr.class.path.class.is.not.matched.to.psr0={0} 이름이 포함하는 파일 이름과 일치하지 않습니다.

#inspection -> Traditional Syntax Array Declaration Inspection
inspection.traditional.syntax.array.literal.detected=기존 구문 배열 리터럴이 사용되었습니다.

#inspection -> Too Many Parameters
inspection.too.many.parameters=매개변수 개수가 지정된 한도를 초과했습니다.
inspection.too.many.parameters.max.number.of.parameters=최대 매개변수 개수
inspection.too.many.parameters.ignore.constructors=생성자 무시

#inspection -> Parameters count mismatch
inspection.method.parameters.count.mismatch=메서드 호출에 {0} 개의 매개변수가 제공되었지만 메서드 시그니처는 {1} 개의 매개변수를 사용합니다
inspection.method.parameters.count.mismatch.option.ignore.underscore=마지막 매개변수가 $_인 함수/메서드 무시
inspection.method.parameters.count.mismatch.option.ignore.func.get.arg=func_get_arg/func_get_args 호출이 있는 함수/메서드 무시

#inspection -> Method __toString is not implemented
inspection.method.to.string.is.not.implemented.strict.mode=각 표현식 타입에 대해 __toString이 있는지 확인
inspection.method.to.string.is.not.implemented=''__toString'' 메서드가 ''{0}''에 대해 구현되지 않습니다.

#inspection -> Method or class is not case sensitive
inspection.codeSmell.function.call.is.not.casesensitive=함수/메서드 호출의 대/소문자가 선언의 대/소문자와 일치하지 않습니다.
inspection.codeSmell.class.call.is.not.casesensitive=클래스 사용 위치의 대/소문자가 선언의 대/소문자와 일치하지 않습니다.
inspection.codeSmell.namespace.reference.is.not.casesensitive=네임스페이스 참조의 대/소문자가 선언의 대/소문자와 일치하지 않습니다.

#inspection -> Method visibility shouldn't be overridden
inspection.codeSmell.overriding.method.visibility.description=메서드 가시성은 재정의하면 안 됩니다.

#inspection -> Usage of a variable variable
inspection.variable.variable=가변 변수가 사용되었습니다.

#inspection -> Strict type checking rules violation
inspection.strict.type.checking.parameter=타입 ''{0}''의 매개변수가 필요하나 ''{1}''이(가) 제공되었습니다
inspection.strict.type.checking.parameter.batch=매개변수 '#ref' 타입이 선언과 호환되지 않습니다.
inspection.strict.type.checking.return=반환값이 타입 ''{0}''이어야 하는데 ''{1}''이(가) 반환되었습니다.
inspection.strict.type.checking.return.batch=반환값 타입이 선언과 호환되지 않습니다.
inspection.strict.type.checking.option=모든 파일에서 활성화
inspection.strict.type.checking.field.assignment=프로퍼티가 타입 ''{0}''이어야 하는데 ''{1}''이(가) 제공되었습니다.
inspection.strict.type.checking.field.assignment.multi.resolve=대입된 값의 타입 ''{0}''이(가) 프로퍼티의 선언된 타입과 호환되지 않습니다

#inspection -> Incompatible return type
inspection.incompatible.return.type=기대되는 반환값은 ''{0}''인데 ''{1}''이(가) 반환되었습니다.
inspection.incompatible.return.type.batch=반환값 타입이 선언된 항목과 호환되지 않습니다.
inspection.incompatible.return.type.strict.type.checking=엄격한 타입 검사
#inspection -> Missing strict types declaration
inspection.missing.strict.types.declaration=엄격한 타입 선언이 누락되어 있습니다.
inspection.missing.strict.types.declaration.add.declaration=엄격한 타입 선언 추가

#inspection -> Magic method visibility
inspection.magic.method.visibility.must.be.public=매직 메서드 ''{0}''은(는) public이어야 합니다.
inspection.magic.method.visibility.must.be.static=매직 메서드 ''{0}''은(는) static이어야 합니다.
inspection.magic.method.visibility.cannot.be.static=매직 메서드 ''{0}''은(는) static일 수 없습니다.

#inspection -> Naming convention
inspection.naming.convention.problem.descriptor.short={0} 이름 <code>#ref</code>이(가) 너무 짧습니다({1} < {2}) #loc
inspection.naming.convention.problem.descriptor.long={0} 이름 <code>#ref</code>이(가) 너무 깁니다({1} > {2}) #loc
inspection.naming.convention.element.descriptor.regexp={0} 이름 <code>#ref</code>이(가) 정규식 ''{1}''와(과) 일치하지 않습니다 #loc
inspection.naming.convention.element.description.class=클래스
inspection.naming.convention.element.description.method=메서드
inspection.naming.convention.element.description.property=프로퍼티
inspection.naming.convention.element.description.variable=변수
inspection.naming.convention.element.description.function=함수
inspection.naming.convention.element.description.constant=상수

#inspection -> Replaceable assignment
inspection.assignment.replaceable.with=<code>#ref</code>을(를) ''{0}''(으)로 바꿀수 있습니다 #loc

#inspection -> Constructor style
inspection.constructor.style=예전 스타일의 생성자

#inspection -> Statement has empty body
inspection.statement.has.empty.body.comments.count.as.content=주석을 내용으로 간주
inspection.statement.has.empty.body.ignore.empty.while=본문이 없는 'while' 루프 무시
inspection.statement.has.empty.body.ignore.empty.for=본문이 없는 'for' 루프 무시

#inspection -> Convert loop to array_map
inspection.loop.can.be.converted.to.arraymap=루프를 'array_map()' 호출로 변환 가능

#inspection -> Convert loop to array_filter
inspection.loop.can.be.converted.to.arrayfilter=루프를 'array_filter()' 호출로 변환 가능

#inspection -> Convert loop to array_fill
inspection.loop.can.be.converted.to.arrayfill=루프를 'array_fill()' 호출로 변환 가능

#inspection -> Convert str_pos to str_contains
inspection.str.functions.strpos.call.can.be.converted.to.strcontains='strpos()' 호출을 'str_contains()'로 변환 가능
inspection.str.functions.substr.call.can.be.converted.to.strstartswith='substr()' 호출을 'str_starts_with()'로 변환 가능
inspection.str.functions.strpos.call.can.be.converted.to.strstartswith='strpos()' 호출을 'str_starts_with()'로 변환 가능
inspection.str.functions.substr.call.can.be.converted.to.strendswith='substr()' 호출을 'str_ends_with()'로 변환 가능
#inspection -> Convert array_map to loop
inspection.arraymap.can.be.converted.to.loop='array_map()' 호출을 루프로 변환 가능

#inspection -> Convert array_filter to loop
inspection.arrayfilter.can.be.converted.to.loop='array_filter()' 호출을 루프로 변환 가능

#inspection -> Convert array_fill to loop
inspection.arrayfill.can.be.converted.to.loop='array_fill()' 호출을 루프로 변환 가능

#inspection -> Ignored class alias declaration
inspection.ignored.class.alias.declaration=클래스 별칭 선언이 무시되었습니다.

#inspection -> Format function parameters mismatch
inspection.format.function.parameters.mismatch.parameter=매개변수가 어느 변환 사양으로도 매Ping되지 않았습니다.
inspection.format.function.parameters.mismatch.conversion.specification=변환 사양이 어느 매개변수로도 매Ping되지 않았습니다.

inspection.export.results.const=상수
inspection.export.results.back.traces=백트레이스

inspection.unused.symbol.check.fields=프로퍼티
inspection.unused.symbol.check.methods=메서드
inspection.unused.symbol.check.classes=클래스
inspection.unused.symbol.check.constants=상수
inspection.unused.symbol.check.anonymous_classes=익명
inspection.unused.symbol.check.functions=함수
inspection.unused.symbol.check.magic_method=매직 메서드
inspection.unused.symbol.export.calls=호출
inspection.unused.symbol.export.call=호출
inspection.unused.symbol.export.label=라벨
inspection.unused.symbol.export.reachable_element=도달 가능한
inspection.unused.symbol.export.entry=진입점
inspection.unused.symbol.export.abstract=추상
inspection.unused.symbol.export.closure=클로저
inspection.unused.symbol.export.test_method=테스트

inspection.composer.file.reference.problem=경로 ''{0}''을(를) 찾을 수 없습니다.

#inspection -> Method may be static
inspection.method.may.be.static=메서드를 'static'으로 만들 수 있습니다

#inspection -> Missing field type
inspection.missing.field.type=프로퍼티의 타입 선언 누락

inspection.unpacked.argument.type.mismatch=배열과 Traversable만 압축 해제할 수 있으나 {0}이(가) 전달되었습니다.

inspection.closure.can.be.converted.to.arrow.function=클로저를 화살표 함수로 변환할 수 있습니다.

inspection.field.assignment.type.mismatch=호환 불가능한 타입: 타입 ''{0}''의 프로퍼티가 필요한데 ''{1}''이(가) 제공되었습니다.
inspection.field.assignment.type.mismatch.multi.resolve=대입된 값의 타입 ''{0}''이(가) 프로퍼티의 선언된 타입과 호환되지 않습니다

inspection.duplicate.switch.case.body=''switch'' 내 브랜치가 ''{0}'' 브랜치와 중복됩니다.

inspection.duplicate.match.arm.body=''match'' arm은 ''{0}'' arm과 중복됩니다

inspection.switch.without.default.case='Switch'에 default 브랜치가 없습니다.

inspection.doc.field.type.mismatch=프로퍼티 타입이 일치하지 않습니다.

inspection.nested.ternary.expression=중첩된 삼항식은 PHP 7.4부터 더 이상 사용되지 않습니다.

inspection.statement.without.braces=중괄호가 없는 제어문 본문
inspection.statement.without.braces.fix.name=''{0}'' 문에 중괄호 추가

inspection.single.statement.with.braces=중괄호가 있는 단일 구문 본문
inspection.single.statement.with.braces.fix.name=''{0}'' 문의 중괄호 제거

inspection.curly.braces.access.syntax.usage=중괄호 액세스 구문은 PHP 7.4부터 더 이상 사용되지 않습니다.

inspection.expression.have.same.operands=표현식에 동일한 피연산자가 있습니다.

inspection.deprecated.cast={0} 형 변환은 PHP {1}부터 더 이상 사용되지 않습니다.
inspection.deprecated.implode.usage=인수(배열, 문자열)이 있는 {0} 호출은 PHP 7.4부터 더 이상 사용되지 않습니다. 

quickfix.replace.curly.braces.with.brackets=중괄호를 대괄호로 바꿉니다.

#quickfix
quickfix.is.not.available.in.dump.mode=''{0}'' 빠른 수정은 색인이 업데이트되는 동안 사용할 수 없습니다
quickfix.cannot.find.class.reference=해결할 클래스 참조를 찾을 수 없습니다.
quickfix.cannot.find.target.class=참조 ''{0}''의 클래스를 해결할 수 없습니다.
quickfix.multiple.target.class.resolve=클래스 ''{0}''에 여러 선언이 있습니다.
quickfix.import.base.no.candidates=가져올 후보를 찾을 수 없습니다.

#quickfix -> PhpCaseSensitiveQuickFix
quickfix.overriding.method.visibility=가시성 재정의를 제거합니다.

#quickfix -> PhpMoveClassToCorrespondingDirectoryQuickFix
quickfix.move.class.to.corresponding.directory=디렉터리 ''{0}''(으)로 이동합니다.
quickfix.move.class.to.corresponding.directory.error.file.exists=파일 {0}이(가) 이미 있습니다
quickfix.move.class.to.corresponding.directory.error.unable.create.directories=누락된 디렉터리를 생성할 수 없습니다. ''{0}''
quickfix.move.class.to.corresponding.directory.error.unable.move.file=디렉터리 ''{0}''으(로) 파일을 이동할 수 없습니다.

#quick fix for:
quickfix.create.class=클래스 생성
quickfix.failed.to.create.class=클래스 ''{0}''을(를) 생성하지 못했습니다.

#quic fix for:{PhpConstructorStyleInspection} -> Convert constructor to new style
quickfix.convert.to.new.style.constructor=생성자를 새로운 스타일로 변환합니다.

#quick fix for: {PhpUnderfinedVariableInspection} -> Create parameter
quickfix.create.parameter=매개변수를 생성합니다.
#quick fix for: {PhpUnderfinedVariableInspection} -> Add to use
quickfix.add.to.use=클로저 'use' 구문에 추가합니다

#quickfix -> PhpImportClassQuickFix
quickfix.import.class.name=클래스 가져오기
quickfix.import.class.popup.title=가져올 클래스

#quickfix -> PhpImportConstantQuickFix
quickfix.import.constant.name=상수를 가져옵니다.
quickfix.import.constant.popup.title=가져올 상수

#quickfix -> PhpImportFunctionQuickFix
quickfix.import.function.name=함수를 가져옵니다.
quickfix.import.function.popup.title=가져올 함수

#quickfix -> PhpAddFieldDeclarationQuickFix
#quickfix -> PhpAddMethodDeclarationQuickFix
#quickfix -> MakeCallDynamicQuickFix
quickfix.can.not.find.static.method.reference=static 메서드 참조를 찾을 수 없습니다

#quickfix -> MakeCallStaticQuickFix
quickfix.make.call.static.name=호출을 static으로 설정합니다.
quickfix.can.not.find.dynamic.method.reference=dynamic 메서드 참조를 찾을 수 없습니다.

#quickfix -> PhpAddFunctionFromCallback/PhpAddMethodFromCallback/PhpAddFieldFromCallback
quickfix.create.field.from.callback.name=콜백에서 프로퍼티 생성
quickfix.create.field.from.callback.invalid.element=콜백에서 프로퍼티 이름을 추출하지 못했습니다.
quickfix.create.field.from.callback.unresolved.class.ref=콜백에서 프로퍼티를 생성하지 못했습니다. 대상 클래스 참조를 해결할 수 없습니다.
quickfix.create.method.from.callback.name=콜백에서 메서드 생성
quickfix.create.function.from.callback.family.name=콜백에서 함수 생성
quickfix.create.function.from.callback.name=함수 추가

#quickfix -> PhpChangeParameterTypeQuickFix/PhpChangeReturnTypeQuickFix/PhpExtendReturnTypeQuickFix
quickfix.strict.type.checking.change.parameter.type.name={0, choice, 1#1번째|2#2번째|3#3번째|4#{0,number}번째} 매개변수의 타입을 ''{1}''에서 ''{2}''(으)로 변경합니다.
quickfix.strict.type.checking.change.parameter.type.family=매개변수 타입 변경
quickfix.strict.type.checking.change.return.type.name=반환 타입을 ''{0}''에서 ''{1}''(으)로 변경합니다.
quickfix.strict.type.checking.change.return.type.family=반환 타입 변경
quickfix.strict.type.checking.extend.return.type.name=반환 타입을 ''{0}''에서 ''{1}''(으)로 확장합니다.
quickfix.strict.type.checking.extend.return.type.family=반환 타입 확장

#quickfix -> PhpChangeTypeDeclarationQuickFix
quickfix.change.type=''{0}''(으)로 변경
quickfix.remove.type=타입 ''{0}''을(를) 제거합니다.
quickfix.change.type.declaration.family=타입 변경

#quickfix -> PhpCaseSensitiveQuickFix
quickfix.case.sensitive.name={0}의 대/소문자를 해당 선언과 일치하도록 변경합니다.

#quickfix -> Replace assignment with operator assignment
quickfix.replace.assignment.with.operator.assignment.family.name=대입을 연산자 대입으로 바꾸기
quickfix.replace.assignment.with.operator.assignment.name=''=''를 ''{0}=''로 바꿉니다.

#quickfix -> Replace assignment with prefix expression
quickfix.replace.assignment.with.prefix.expression.family.name=대입을 접두사 표현식으로 바꾸기
quickfix.replace.assignment.operator.with.prefix.expression.family.name=대입 연산자를 접두사 표현식으로 바꾸기

quickfix.replace.one.operator.with.another=''{0}''을(를) ''{1}''(으)로 바꾸기

#quickfix -> Convert loop to array_map
quickfix.convert.loop.to.arraymap=루프를 'array_map()' 호출로 변환

#quickfix -> Convert loop to array_filter
quickfix.convert.loop.to.arrayfilter=루프를 'array_filter()' 호출로 변환

#quickfix -> Convert loop to array_fill
quickfix.convert.loop.to.arrayfilll=루프를 'array_fill()' 호출로 변환

#quickfix -> Convert array_map to loop
quickfix.convert.arraymap.to.loop='array_map()' 호출을 루프로 변환

#quickfix -> Convert array_filter to loop
quickfix.convert.arrayfilter.to.loop='array_filter()' 호출을 루프로 변환

#quickfix -> Convert array_fill to loop
quickfix.convert.arrayfill.to.loop='array_fill()' 호출을 루프로 변환

#quickfix -> PHPUnit create missing target class
quickfix.phpunit.create.target.class.error.filename.exists=파일 {0}이(가) 있습니다.

#quickfix -> Replace current method with alternative 
quickfix.phpunit.replace.current.method.with.alternative=''{0}''(으)로 바꾸기

#quickfix -> Drop redundant optional parameters
quickfix.phpunit.drop.redundant.optional.parameters=중복 선택적 매개변수를 삭제합니다.

#quickfix -> Flip misordered assertEquals/assertNotEquals arguments
quickfix.phpunit.assert.equals.flip.compared.arguments=비교된 인수 반전

#quickfix -> Unnecessary qualifier
quickfix.remove.unnecessary.qualifier=불필요한 한정자 제거
quickfix.remove.unnecessary.qualifier.on.class.name=FQN을 단순화합니다.

#quickfix -> Disable for global namespace
quickfix.disable.inspection.for.global.namespace=전체 네임스페이스에서 검사를 비활성화합니다.

#quickfix -> Make method static
quickfix.make.method.static='static'으로 설정

#quickfix -> Change field type
quickfix.change.field.type.to.match.super=타입을 상위 항목과 일치하도록 변경
quickfix.change.field.type.add.inferred.type.family.name=추론 타입을 프로퍼티의 타입으로서 추가
quickfix.change.field.type.add.inferred.type.name=''{0}''을(를) 프로퍼티의 타입으로서 추가
quickfix.change.field.type.add.inferred.type.error.read.only=읽기 전용 파일 ''{0}''을(를) 수정할 수 없습니다.
quickfix.change.field.type.add.inferred.type.error.non.project=프로젝트 파일이 아닌 ''{0}''을(를) 수정할 수 없습니다.

#quickfix -> Remove redundant PHPDoc
quickfix.remove.phpdoc=중복 PHPDoc 주석을 제거합니다.

quickfix.remove.phpdoc.signature.tags=불필요한 @param 및 @return 태그 제거
quickfix.remove.phpdoc.param.tag=@param 태그 제거
quickfix.remove.phpdoc.return.tag=@return 태그 제거

quickfix.phpdoc.update.type=PHPDoc 타입을 업데이트합니다.
quickfix.phpdoc.update.field.type=PHPDoc 주석과 일치하도록 프로퍼티 타입을 ''{0}''(으)로 변경합니다.

quickfix.replace.nested.ternary.expression=삼항식을 {0} 결합 버전으로 바꿉니다.

quickfix.set.inheritance.between.classes={0} {1}을(를) {2}(으)로 만듭니다.

quickfix.navigate.to.duplicate.array.key=중복 키로 이동합니다.
quickfix.navigate.to.duplicate.condition=중복 조건으로 이동

#quickfix -> Delete return argument
quickfix.delete.return.argument=return 인수를 삭제합니다.

quickfix.remove.default.arm=중복된 'default' match arm 제거
#intentions

#intentions Replace ?: expression with If
intention.replace.ternary.expression.with.if='?:'을 if로 바꿉니다

#intentions Replace If with ?: expression
intention.replace.if.with.ternaryExpression='if' 단순화

#intentions -> Convert To Short Syntax
intention.convert.to.short.syntax=배열을 짧은 구문으로 변환
intention.convert.to.traditional.syntax=배열을 기존 구문으로 변환

#intentions -> Convert To Short Syntax (list)
intention.convert.to.short.syntax.list=목록을 짧은 구문으로 변환
intention.convert.to.traditional.syntax.list=목록을 기존 구문으로 변환

#intentions -> Declare Field
intention.declare.missing.field=프로퍼티 선언

#intentions -> Declare Property
intention.declare.missing.property=@property 추가

#intentions -> Flip Binary Expression
intention.flip.binary.expression.family.name=이진 표현식 반전
intention.flip.binary.expression.text1=''{0}'' 반전
intention.flip.binary.expression.text2=Flip ''{0}'' 반전(의미가 변경될 수 있음)
intention.flip.binary.expression.text3=''{0}'' 반전(의미 변경)

#intentions -> Namespace Bracing
intention.namespace.bracing=네임스페이스를 중괄호로 묶이도록 변환

#intentions -> Smart Line Split
intention.line.split=문자열을 2개의 문자열과 연결로 분할

#intentions -> Split comma-separated values
intention.split.comma.separated.values=쉼표로 구분된 값을 여러 줄로 분할
intention.join.comma.separated.values=쉼표로 구분된 값을 한 줄로 병합

#intentions -> Swap Call Arguments
intention.swap.call.arguments.family.name=호출 인수 스왑
intention.swap.call.arguments.text1=''{0}''와(과) ''{1}'' 스왑

#intention -> Add variable PHPDoc comment
intention.variable.add.phpdoc.comment.family.name=PHPDoc 주석 추가

#intention -> Import class
intention.import.class=클래스를 별칭으로 가져오기
intention.import.class.alias.name=별칭 이름:
intention.import.class.alias.already.exists=동일한 별칭 이름을 가진 클래스를 이미 가져왔습니다.

#intention -> Simplify FQN
#intention -> Generate PHPDoc
intention.generate.phpdoc=PHPDoc 생성

#intention -> Surround With Call
intention.can.not.find.statement.to.surround=둘러쌀 대상 구문을 찾을 수 없습니다.
intention.statement.to.surround.failed.message=구문을 ''{0}''(으)로 둘러싸지 못했습니다.

#intention -> Replace quotes
intention.replace.quotes=따옴표를 바꿀 수 없습니다. 잘못된 이스케이프 심볼이며 \\r 지원되지 않습니다

#intention -> Replace with alias
intention.replace.class.with.alias=별칭으로 바꾸기

#intention -> Inline alias
intention.inline.alias=별칭 인라인화

#intention -> Add constructor parameters
intention.add.constructor.parameters=생성자 매개변수 추가
intention.add.constructor.parameters.fields.chooser.dialog.title=생성자에서 초기화할 프로퍼티 선택

#intention -> Implement the interface
intention.implement.interface=인터페이스 구현

intention.merge.condition.with.outer=외부 조건과 병합

#navigation -> Goto Super Method
navigation.goto.super.method.is.not.available=색인 업데이트 중에는 여기에서 탐색을 사용할 수 없습니다

#run and debug
#dbgp debugging protocol
dbgp.invalid.packet=잘못된 패킷

#annotator
annotator.duplicate.use.statement=''{0}''(이)라는 이름은 이미 사용되고 있으므로 사용 불가합니다.
annotator.duplicate.default.match.condition=match 식은 단 하나의 'default' arm만 포함할 수 있습니다
annotator.unhandled.match.argument=처리되지 않은 'match'인수
annotator.reserved.class.name=''{0}''은(는) 예약되어 있으므로 클래스 이름으로서 사용할 수 없습니다.
annotator.invalid.class.name=''{0}''은(는) 잘못된 클래스 이름입니다.
annotator.special.class.name=''{1}''은(는) 특수 클래스 이름이므로 {0}을(를) {1}(으)로서 사용할 수 없습니다.
annotator.cannot.break.continue={0} 수준을 break/continue 할 수 없습니다.
annotator.jump.out.of.finally=finally 블록 외부로 이동하는 것은 허용되지 않습니다.
php.annotator.expecting.interface=인터페이스 참조가 필요합니다.
php.annotator.expecting.class=클래스 참조가 필요합니다
php.annotator.exchange.extends.implements.keyword=''{0} {2}''을(를) ''{1} {2}''(으)로 변경
php.annotator.strict.types.first.statement='strict_types' 선언은 구문에서 제일 첫 번째 구문이어야 합니다.
php.annotator.strict.types.block.mode='strict_types' 선언은 블록 모드를 사용해서는 안 됩니다.
php.annotator.heredoc.indent.validation.mixed.space.and.tab.characters=닫는 식별자 들여쓰기에 스페이스와 탭 문자가 혼합되어 있습니다.
php.annotator.heredoc.indent.validation.wrong.content.indent=잘못된 들여쓰기: 닫는 태그 들여쓰기와 동일해야 합니다.
php.annotator.typed.property.illegal.value=타입 ''{0}''의 프로퍼티에 디폴트 값이 없을 수 있습니다.
php.annotator.typed.property.type.mismatch=디폴트 값은 타입 ''{0}''이어야 합니다.
php.annotator.typed.property.type.mismatch.fix.nullable=프로퍼티 타입을 null 가능하도록 만듭니다.
php.annotator.typed.parameter.type.mismatch.fix.nullable=매개변수 타입을 null 가능으로 설정
php.annotator.typed.property.type.mismatch.fix.change=프로퍼티 타입을 ''{0}''(으)로 변경합니다.
php.annotator.typed.parameter.type.mismatch.fix.change=매개변수 타입을 ''{0}''(으)로 변경
php.annotator.typed.property.type.mismatch.fix.family=프로퍼티 타입을 디폴트 값의 타입과 일치하도록 변경
php.annotator.typed.parameter.type.mismatch.fix.family=매개변수 타입을 디폴트 값의 타입과 일치하도록 변경
php.annotator.typed.property.callable.is.illegal=프로퍼티는 타입 'callable'을 가질 수 없습니다.
php.annotator.return.type.non.nullable.null.returned='null'을 반환할 수 없습니다. 반환 타입은 null 가능해서는 안 됩니다.
php.annotator.return.type.make.nullable.fix=반환 타입을 null 가능하도록 만듭니다.
php.annotator.void.function.must.not.return.value=void 함수는 값을 반환해서는 안 됩니다.
php.surround.with.if=if

#quality tool
quality.tool.configuration.tool.path.is.empty=선택한 구성에서 {0} 경로가 비어 있습니다.
quality.tool.configuration.can.not.find.configuration.by.id={0} 구성을 id로 찾을 수 없습니다. ''{1}''
quality.tool.configuration.default.interpreter.is.not.found=디폴트 인터프리터에 따른 {0} 구성이 선택되었으나 지정된 인터프리터가 없습니다.
quality.tool.configuration.for.interpreter.is.not.found=인터프리터에 대한 {0} 구성을 찾을 수 없습니다. ''{1}''
quality.tool.configuration.interpreter.is.undefined={0} 구성에 대한 인터프리터가 지정되지 않았거나 유효하지 않습니다.
quality.tool.phpcs.custom.rules.warning=사용자 지정 규칙 집합을 선택하려면 '사용자 지정' 코딩 표준 타입을 선택하세요.
quality.tool.phpcs.custom.rules.validation.not.xml=선택한 규칙 집합이 XML이 아닙니다.
guality.tool.configuration.show.ignored.files=무시된 파일 표시
quality.tool.phpcs.installed.paths=설치된 표준 경로
quality.tool.empty.path.phpcs=빈 {0} 경로
quality.tool.phpcbf.location=PHPCBF 위치
quality.tool.phpcbf.location.descr=올바른 phpcbf 런처를 선택하세요.
quality.tool.phpcbf.settings=PHP Code Beautifier 및 Fixer 설정
quality.tool.phpcbf.path=phpcbf 경로:
quality.tool.phpcbf.reformat.action=PHP Code Beautifier 및 Fixer: 전체 파일 수정
quality.tool.phpcbf.name=PHP Code Beautifier 및 Fixer
quality.tool.selected.file.is.not.phpcbf=선택한 파일은 phpcbf 실행 파일이 아닙니다.
quality.tool.cs.fixer.custom.rules.warning=사용자 구성을 선택하려면 '사용자 지정' 타입을 선택하세요.
quality.tool.php_cs.custom.rules.validation.not.php_cs=선택한 규칙 집합은 PHP CS Fixer에서 지원되지 않습니다
quality.tool.php_cs.dir.does.not.contain.custom=디렉터리가 지원 파일 중 어느 것도 포함하지 않습니다. {0}
quality.tool.php.dir.does.not.contain=디렉터리에 {0}이(가) 없습니다.
quality.tool.can.not.determine.version=도구 버전을 파악할 수 없습니다. {0}이(가) 전달되었습니다.
quality.tool.file.not.found=파일을 찾을 수 없습니다.
quality.tool.path.must.not.be.empty=경로가 공백일 수 없습니다.
quality.tool.can.not.retrieve.standards=사용 가능한 규칙 집합을 찾을 수 없습니다. PHP CS Fixer 도구 구성을 확인하세요.
quality.tool.phpcs.can.not.retrieve.standards=사용 가능한 표준을 찾을 수 없습니다. PHP_CodeSniffer 도구 구성을 확인하세요.
quality.tool.stardards.has.been.updated=설치된 규칙 집합 목록이 업데이트되었습니다.
quality.tool.coding.stardards.has.been.updated=설치된 코딩 표준 목록이 업데이트되었습니다.
quality.tool.cs.fixer.allow.risky.rules=기본 제공 규칙 집합에 위험한 규칙 허용
quality.tool.cs.fixer.reformat.action=PHP CS Fixer: 전체 파일 수정
quality.tool.cs.fixer.ruleset=규칙 집합:

quality.tool.phpcs.required.phpcs.version=필수 PHP_CodeSniffer 버전은 1.5.0 이후 버전이나 {0}이(가) 발견되었습니다.
quality.tool.php.cs.fixer.required.phpcs.version=지원되는 PHP CS Fixer 버전은 2.8.0 이후 버전이나 {0}이(가) 발견되었습니다.

quality.tool.label.check.files.with.extensions=다음 확장자를 가진 파일을 확인:
quality.tool.label.coding.standard=코딩 표준:
quality.tool.checkbox.installed.standard.paths=설치된 표준 경로:
quality.tool.checkbox.show.sniff.name=sniff 이름 표시
quality.tool.checkbox.show.warning.as=경고를 다음으로 표시:
quality.tool.label.tool.path=도구 경로:
quality.tool.label.tool.process.timeout=도구 프로세스 시간 제한, [1...60]초:
quality.tool.button.validate=유효성 검사
quality.tool.label.validation.label=유효성 검사 라벨
quality.tool.label.custom.rulesets=사용자 지정 규칙 집합:
quality.tool.phpcs.label.path.to.ruleset=규칙 집합 경로:
quality.tool.label.label=라벨
quality.tool.label.configuration=구성:

#phpunit messages
php.unit.local.run.display.name=PHPUnit
php.unit.local.run.description=PHPUnit
php.not.test.method=클래스 ''{1}''의 메서드 ''{0}''은(는) 테스트 메서드가 아닙니다.
php.method.not.found=클래스 ''{1}''에서 메서드 ''{0}''을(를) 찾을 수 없습니다.
php.method.name.empty=테스트 메서드가 지정되지 않았습니다.
php.unit.radio.button.composite=복합
php.unit.test.runner.options=테스트 러너 옵션
php.unit.checkbox.use.alternative.patterns.base.path=대체 패턴 기반 경로 사용:
php.unit.optional=선택적
php.unit.label.test.file.template=테스트 파일 템플릿(&T):

choose.php.home=PHP 실행 파일 선택
cleaning.up=정리 중…
this.reassignment.is.not.allowed=$this을(를) 다시 대입할 수 없습니다.
cant.use.temporary.expression.in.write.context=쓰기 컨텍스트에서 임시 표현식을 사용할 수 없습니다.
parsing.error.statement.expected=구문이 필요합니다.
smarty.configurable.title=Smarty
analyzing.php.sdk=PHP 설치 확인 중…
include.path.column.info=경로
working.directory.invalid=작업 폴더 ''{0}''을(를) 찾을 수 없습니다.
#control flow
#validation common
validation.file.already.exists.in.dir=''{1}''에 이름이 ''{0}''인 파일이 이미 있습니다
validation.file.already.exists=파일 ''{0}''이(가) 이미 있습니다
validation.file.not.valid.name="{0}"은(는) 올바른 파일 이름이 아닙니다.
validation.class.not.valid.name="{0}"은(는) 올바른 클래스 이름이 아닙니다.
validation.namespace.not.valid.name="{0}"은(는) 올바른 네임스페이스 이름이 아닙니다.
validation.invalid.identifier="{0}"은(는) 올바른 식별자가 아닙니다.
validation.invalid.identifier.with.no.identifier=삽입된 식별자가 올바르지 않습니다
validation.invalid.alias="{0}"은(는) 올바른 별칭 이름이 아닙니다.
validation.value.is.not.specified.or.invalid={0}이(가) 지정되지 않았거나 유효하지 않습니다.
validation.value.path.to.value.should.be.specified={1}에서 {0} 경로를 지정해야 합니다.
validation.value.path.to.value.is.invalid={1}에 제공된 경로로 {0}을(를) 찾을 수 없습니다.
validation.value.path.to.value.is.invalid.press.fix.project.configuration={1}에 제공된 경로로 {0}을(를) 찾을 수 없습니다. ''수정''을 눌러 {2} 구성을 편집하세요.
validation.value.is.not.specified.or.invalid.press.fix.project.configuration={0} 은(는) 지정되지 않았거나 유효하지 않습니다. ''수정''을 눌러 프로젝트 구성을 편집하세요.
validation.value.is.not.specified.press.fix.project.configuration={0}이(가) {1} 구성에 지정되어 있지 않습니다. ''수정''을 눌러 {1} 구성을 편집하세요.
validation.press.fix.to.edit.project.configuration='수정'을 눌러 프로젝트 구성을 편집하세요.
validation.value.is.invalid={0}이(가) 유효하지 않습니다.
validation.0.not.found.at.1=''{1}''에서 ''{0}''을(를) 찾을 수 없습니다.
validation.0.is.not.a.directory=''{0}''은(는) 디렉터리가 아닙니다
validation.0.extension.is.not.installed=''{0}'' 확장 프로그램이 설치되어 있지 않습니다.
validation.debug.extension.is.updated=디버그 확장 프로그램 설정이 업데이트되었습니다. 새 값을 사용하려면 현재 구성을 다시 실행하세요.
validation.0.extension.is.installed.check.configuration.options=''{0}'' 확장 프로그램이 설치되어 있습니다. 구성 옵션을 확인하세요.
validation.no.debug.extension.is.installed=설치된 디버그 확장 프로그램이 없습니다.
validation.cannot.parse.value.of.0=''{0}'' 값을 구문 분석할 수 없습니다
validation.connection.was.not.established=연결이 구축되어 있지 않습니다.
validation.connection.was.not.established.0=''{0}''(으)로 디버거 세션을 시작할 수 없습니다.
validation.connection.was.not.established.no.debug=디버그 확장 프로그램이 설치되어 있지 않습니다.
validation.connection.was.not.established.update.info=인터프리터 정보 업데이트
validation.connection.was.not.established.validate.installation=설치 프로그램 유효성 검사
validation.function.already.exists = 이름이 동일한 함수가 현재 네임스페이스에 이미 정의되어 있습니다.
validation.namespace.already.exists = 이름이 ''{0}''인 네임스페이스가 {1}에 이미 정의되어 있습니다.
validation.class.already.exists = 이름이 동일한 클래스가 {0}에 이미 있습니다.
validation.class.cannot.be.overridden = 클래스 "{0}"을(를) 재정의할 수 없습니다.
validation.interface.cannot.be.overridden = 인터페이스 "{0}"은(는) 구현할 수 없습니다.
validation.test.no.test.patterns = 추가된 패턴이 없습니다.

validation.ssh.remote.debug.support=SSH를 통한 원격 디버그는 ''{0}'' 확장 프로그램에서 지원되지 않습니다.
validation.ssh.remote.code.coverage.support=SSH를 통한 코드 커버리지는 {0} 확장 프로그램에서 지원되지 않습니다.
remote.interpreter.path.mappings.validation.title=경로 매Ping이 선택된 인터프리터에 대해 구성되어 있지 않습니다.
remote.interpreter.path.mappings.validation.message=매Ping이 {0}에서 제대로 구성되어 있는지 확인하세요.
remote.interpreter.path.mappings.validation.php.section=<b><i><a href="php_mappings">설정 | PHP</a></i></b>
docker.compose.coverage.file.is.not.found=커버리지 파일을 찾을 수 없습니다
docker.compose.coverage.file.failed.to.copy=Docker 컨테이너의 커버리지 결과를 복사하지 못했습니다.
docker.compose.coverage.file.failed.to.extract=커버리지 결과를 추출하지 못했습니다.
docker.compose.radio.button.always.start.a.new.container.docker.compose.run=항상 새 컨테이너 시작('docker-compose run')
docker.compose.radio.button.connect.to.existing.container.docker.compose.exec=기존 컨테이너 연결('docker-compose exec')
docker.compose.failed.to.start.container=docker-compose 서비스를 시작하지 못했습니다. 명령줄에서 시작한 다음 다시 시도하세요

#errors common
error.template.unable.parse.internal.template=내부 템플릿 {0}을(를) 구문 분석할 수 없습니다.
error.template.unable.create.from.internal.template=내부 템플릿 {0}에서 파일을 생성할 수 없습니다.
error.file.unable.create.selected.directory=선택한 디렉터리에서 파일 {0}을(를) 생성할 수 없습니다.
error.cannot.connect.to.0.1=''{0}''에 연결할 수 없습니다. {1}
error.cannot.connect.to.0=''{0}''에 연결할 수 없습니다.

#messages common
0.completion.shortcut={0} 완성에 {1}을(를) 사용합니다.

#completion
completion.press.again.to.see.more.variants=더 많은 변수를 보려면 {0}을(를) 다시 누르세요.
completion.press.again.to.see.global.variants=전역 변수를 보려면 {0}을(를) 다시 누르세요.
completion.press.again.to.see.all.classes=모든 클래스를 보려면 {0}을(를) 다시 누르세요.

#unwrap
unwrap.if=if 줄 바꿈 해제…
unwrap.while=while 줄 바꿈 해제…
unwrap.for=for 줄 바꿈 해제…
unwrap.try=try 줄 바꿈 해제…
unwrap.else=else 줄 바꿈 해제…
unwrap.elseif=elseif 래핑 해제…
unwrap.dowhile=do-while 래핑 해제…
unwrap.foreach=foreach 래핑 해제…
unwrap.method=''{0}'' 줄바꿈 해제
remove.else=else 제거…


#refactoring
refactoring.common.not.supported.expression.in.scope=그러한 표현식에 대한 {0} 은(는) 현재 범위에서 지원되지 않습니다.
refactoring.common.not.supported.context={0} 은(는) 현재 컨텍스트에서 지원되지 않습니다.
refactoring.common.not.extractable.expression=그러한 표현식은 지원되지 않습니다.
refactoring.common.fail.to.extract.expression=선택한 코드 조각에서 표현식을 추출하지 못했습니다.

refactoring.common.ui.target.namespace.label=네임스페이스(&N):
refactoring.common.ui.target.directory.label=대상 디렉터리(&D):
refactoring.common.ui.target.directory.edit = 대상 디렉터리를 편집하려면 F2를 누르세요.

refactoring.common.validation.namespace.name="{0}"은(는) 올바른 네임스페이스 이름이 아닙니다.
refactoring.common.validation.class.psi=리팩터링을 수행할 수 없습니다. 대상 클래스 "{0}"이(가) 유효하지 않습니다.
refactoring.common.validation.target.directory.is.not.valid=디렉터리 "{0}"의 경로가 유효하지 않습니다.
refactoring.common.validation.target.directory.not.inside.project=디렉터리 "{0}"이(가) 프로젝트 내에 없습니다.

refactoring.parameter.reserved.name = 매개변수 이름 "{0}"은(는) 예약되어 있습니다.
refactoring.parameter.validation = 매개변수 {0}이(가) 유효하지 않습니다
refactoring.parameter.validation.duplicate.parameter=매개변수 이름 중복: {0}
refactoring.parameter.validation.initializer.last=선택적 매개변수 후에 필수 매개변수가 허용되지 않습니다
refactoring.parameter.validation.variadic.last=마지막 매개변수만 가변일 수 있습니다.
refactoring.parameter.validation.variadic.can.have.default.value=가변 매개변수는 디폴트 값을 가질 수 없습니다.
refactoring.parameter.validation.initializer.type=클래스 타입 힌트를 가진 매개변수의 디폴트 값만 NULL일 수 있습니다.
refactoring.parameter.validation.pass.by.reference=변수만 참조로 전달할 수 있습니다.
refactoring.parameter.validation.type=매개변수 타입 ''{0}''이(가) 올바르지 않습니다
refactoring.parameter.validation.default.value=디폴트 값 표현식 ''{0}''이(가) 유효하지 않습니다.
refactoring.parameter.validation.initializer=이니셜라이저 ''{0}''(이)가 유효하지 않습니다.
refactoring.parameter.validation.no.default.value=매개변수 ''{0}''에 이니셜라이저 또는 디폴트 값을 제공해야 합니다.
refactoring.parameter.validation.name.collision.with.use.list=매개변수 이름 ''{0}''(이)가 유효하지 않습니다. ''{0}''은(는) use 목록에 이미 가져와 있습니다.
refactoring.returnType.validation.type=반환 타입 ''{0}''이(가) 올바르지 않습니다

#refactoring - > extract base
refactoring.extract.base.validator.not.valid.identifier="{0}"은(는) 올바른 PHP 식별자가 아닙니다.
refactoring.extract.base.validator.reserved.keyword="{0}"은(는) 예약된 PHP 키워드입니다.
refactoring.extract.base.handler.no.expression.selected=선택 항목이 올바른 표현식을 형성하지 않습니다.
refactoring.extract.base.handler.not.supported.expression={0} 은(는) 그러한 표현식에서 지원되지 않습니다.
refactoring.extract.base.handler.not.supported.scope={0} 은(는) 현재 범위에서 지원되지 않습니다.
refactoring.extract.base.dialog.replace.all.occurrences=모든 찾은 항목 바꾸기({0}개 위치 발견)(&A)
#refactoring -> extract class
refactoring.extract.class.extract.to.class=클래스로 추출
refactoring.extract.class.extracting.from.file=파일에서 추출 중:
refactoring.extract.class.extracting.from.class=클래스에서 추출:
refactoring.extract.class.dialog.class=클래스 이름:
refactoring.extract.class.dialog.generate.accessors=접근자 생성
refactoring.extract.class.dialog.members.to.be.extracted=추출할 멤버
refactoring.extract.class.error.failed.to.create.file=파일을 생성하지 못했습니다.
refactoring.extract.class.preview=추출된 클래스 미리보기
refactoring.extract.class.conflicts.extract.class.refactoring.is.not.supported.for.dynamically.declared.properties.usages=클래스 추출 리팩터링은 동적으로 선언된 프로퍼티의 사용 위치에 지원되지 않습니다
refactoring.extract.class.conflicts.method.0.depends.on.property.1.which.needs.getters.in.2=메서드 "{0}"은(는) 프로퍼티 "${1}"에 종속되어 있으므로 "{2}"에 getter가 필요합니다
refactoring.extract.class.conflicts.method.0.depends.on.property.1.which.needs.setters.in.2=메서드 "{0}"은(는) 프로퍼티 "${1}"에 종속되어 있으므로 "{2}"에 setter가 필요합니다
refactoring.extract.class.conflicts.method.0.depends.on.1.method.2=메서드 ''{0}''이(가) {1} 메서드 ''{2}''에 종속되어 있습니다
refactoring.extract.class.conflicts.method.0.depends.on.1.constant.2=메서드 ''{0}''이(가) {1} 상수 ''{2}''에 종속되어 있습니다
refactoring.extract.class.conflicts.unable.to.add.delegate.property.initialization.to.constructor=클래스 생성자에 위임된 프로퍼티 초기화를 추가할 수 없습니다
refactoring.extract.class.conflicts.unable.to.add.delegate.property.initialization.to.constructor.trait.constructor.will.be.overridden=클래스 생성자에 위임된 프로퍼티 초기화를 추가할 수 없습니다. 특성 생성자가 재정의됩니다.
refactoring.extract.class.conflicts.using.write.access.for.non.public.properties.in.array.destructuring.expressions.is.not.supported.in.extract.class.refactoring=배열 구조 분해 표현식의 비 public 프로퍼티에 대한 쓰기 액세스는 클래스 추출 리팩터링에서 지원되지 않습니다
refactoring.extract.class.conflicts.using.write.access.for.non.public.properties.in.multiple.assignment.expressions.in.extract.class.refactoring=여러 대입식의 비 public 프로퍼티에 대한 쓰기 액세스는 클래스 추출 리팩터링에서 지원되지 않습니다
refactoring.extract.class.error.the.selected.function.should.belong.to.project.sources=선택한 함수는 프로젝트 소스에 속해 있어야 합니다.
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.anonymous.functions=클래스 추출 리팩터링은 익명 함수에 지원되지 않습니다.
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.anonymous.classes=클래스 추출 리팩터링은 익명 클래스에 지원되지 않습니다.
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.abstract.methods=클래스 추출 리팩터링은 추상 메서드에 지원되지 않습니다.
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.doc.methods=클래스 추출 리팩터링은 PHPDoc을 통해 정의된 매직 메서드에 지원되지 않습니다.
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.doc.properties=클래스 추출 리팩터링은 PHPDoc을 통해 정의된 매직 프로퍼티에 지원되지 않습니다.
refactoring.validation.class.error.property.with.name.0.is.already.exists=이름이 ''{0}''인 프로퍼티가 이미 있습니다

#refactoring -> extract variable
refactoring.extract.variable.name=변수 추출
refactoring.extract.variable.conflict.already.exists=이름이 "{0}"인 변수가 이미 범위에 있습니다.
#refactoring -> extract constant
refactoring.extract.constant.name=상수 추출
refactoring.extract.constant.conflict.already.exists=이름이 "{0}"인 상수가 이미 범위에 있습니다.
refactoring.extract.constant.conflict.exists.in.subclass.with.weaker.access="{0}"에 대한 액세스 수준은 "{1}"(클래스 "{2}"와(과) 동일)이거나 약해야 합니다.
refactoring.extract.constant.conflict.exists.in.subclass="{0}::{1}" 이(가) 이 상수로 재정의됩니다.
refactoring.extract.constant.conflict.cannot.override.interface.constant=인터페이스 "{1}"의 상수 "{0}"을(를) 재정의할 수 없습니다.
refactoring.extract.constant.unable.to.add.constant.declaration="상수 선언을 추가할 수 없습니다."

#refactoring -> extract field
refactoring.extract.field.name=프로퍼티 추출
refactoring.extract.field.validator.reserved.field.name="{0}"은(는) 예약된 프로퍼티 이름입니다.
refactoring.extract.field.conflict.already.exists=이름이 "{0}"인 프로퍼티가 이미 클래스에 있습니다.
refactoring.extract.field.visibility=가시성
refactoring.extract.field.visibility.public=public(&U)
refactoring.extract.field.visibility.protected=protected(&O)
refactoring.extract.field.visibility.private=private(&I)

#refactoring -> extract parameter
refactoring.extract.parameter.name=매개변수 추출

#refactoring -> rename - > element processor
conflict.method.with.same.name.already.exists=이름이 동일한 메서드가 이 클래스에 이미 정의되어 있습니다.
conflict.field.with.same.name.already.exists=이름이 동일한 프로퍼티가 이 클래스에 이미 정의되어 있습니다.
conflict.class.constant.with.same.name.already.exists=이름이 동일한 상수가 이 클래스에 이미 정의되어 있습니다.
conflict.variable.with.same.name.already.exists=이름이 동일한 변수가 이미 정의되어 있습니다.
conflict.parameter.with.same.name.already.exists=이름이 동일한 매개변수가 이미 정의되어 있습니다.
conflict.tag.name.contains.close.tag=텍스트에 "{0}" 이(가) 있습니다.
conflict.use.with.same.name.already.exists=이름이 동일한 'Use' 문이 이미 정의되어 있습니다
conflict.class.with.same.name.already.exists=이름이 동일한 클래스가 이미 정의되어 있습니다.
conflict.function.with.same.name.already.exists=이름이 동일한 함수가 이미 정의되어 있습니다.
conflict.constant.with.same.name.already.exists=이름이 동일한 상수가 이미 정의되어 있습니다.
refactoring.rename.search.in.global.scope=전체 범위에서 검색

#refactoring -> rename - > automatic renamers
refactoring.rename.automatic.renamer.accessors.name=접근자 이름 변경(&C)
refactoring.rename.automatic.renamer.field.accessors.dialog.title=접근자 이름 변경
refactoring.rename.automatic.renamer.field.accessors.dialog.description=다음 이름을 가진 프로퍼티 접근자의 이름 변경:
refactoring.rename.automatic.renamer.field.accessors.entity.name=접근자


refactoring.rename.automatic.renamer.class.name=클래스 이름 변경(&C)
refactoring.rename.automatic.renamer.class.dialog.title=클래스 이름 변경
refactoring.rename.automatic.renamer.class.dialog.description=다음 이름을 가진 클래스의 이름 변경:
refactoring.rename.automatic.renamer.class.entity.name=클래스

refactoring.rename.entity.name.inheritor=상속자/파일
refactoring.rename.inheritors.and.related.files.with.the.following.names.to=다음 이름을 가진 상속자 및 관련 파일의 이름 변경:


#refactoring->inline variable
refactoring.inline.variable.cannot.extract.value=변수 ''${0}''의 값을 추출할 수 없습니다.
refactoring.inline.cannot.find.variable.to.inline=인라인화할 변수를 찾을 수 없습니다.
refactoring.inline.variable.no.occurrences=안전하게 인라인화할 수 있는 찾은 항목이 없습니다.

#refactoring->inline function
refactoring.inline.function.title={0} 인라인화 리팩터링
refactoring.inline.function.all.invocations.and.remove.the.method=전체 인라인화 및 {0} 제거(&A)
refactoring.inline.function.all.invocations.keep.the.method=전체 인라인화 및 {0} 유지(&E)
refactoring.inline.function.this.invocation.only.and.keep.the.method=이 항목만 인라인화하고 {0} 유지(&K)
refactoring.inline.function.command={0} 인라인화 중
refactoring.inline.function.cannot.inline.function.with.global.usage=<code>global</code>이 사용된 {0} 은(는) 인라인화할 수 없습니다.
refactoring.inline.function.not.accessible.from.caller.site=호출자 사이트에서 멤버 참조 <code>{0}</code>에 액세스할 수 없습니다.
refactoring.inline.function.cannot.parse.function.body=함수 본문을 구문 분석할 수 없습니다.
refactoring.inline.function.cannot.inline.library.function=라이브러리 함수를 인라인화할 수 없습니다.
refactoring.inline.function.only.static.method.is.supported=static 메서드만 지원됩니다.
refactoring.inline.function.reference.is.recursive=재귀 호출은 지원되지 않습니다.
refactoring.inline.function.inline.function.refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=return 문이 실행 흐름을 중단할 때 함수 인라인화 리팩터링이 지원되지 않습니다.
refactoring.inline.function.parent.reference.unresolved=<code>parent</code> 클래스 참조가 {0}에서 해결되지 않습니다.
refactoring.inline.function.yield.found.in.function.body=함수 본문 내 <code>yield</code> 사용 위치

#refactoring->inline constant
refactoring.inline.constant.name=상수 인라인화
refactoring.inline.constant.command=상수 인라인화
refactoring.inline.constant.this.reference.only=이 참조만 인라인화하고 상수 유지
refactoring.inline.constant.all.references.and.remove=전체 인라인화 및 상수 제거
refactoring.inline.constant.all.references.and.keep=전체 인라인화 및 상수 유지
refactoring.inline.constant.cannot.extract.value=변숫값을 추출할 수 없습니다.
refactoring.inline.constant.is.never.used=상수 {0}이(가) 한 번도 사용되지 않습니다.
refactoring.inline.constant.multiple.declarations=같은 이름의 다른 상수 선언이 있습니다.

#refactoring -> extact method/function
refactoring.extract.method.name=함수/메서드 추출
refactoring.extract.method.error.selected.block.should.represent.a.set.of.statement.or.an.expression=선택한 블록은 구문 또는 표현식 모음을 나타내야 합니다.
refactoring.extract.method.error.a.set.of.statements.should.be.from.the.same.code.block=구문 모음은 동일한 코드 블록에서 나온 것이어야 합니다.
refactoring.extract.method.error.there.are.break.continue.operators.which.can.interrupt.execution=실행을 중단시키는 break/continue 연산자가 있습니다.
refactoring.extract.method.error.inconsistent.return.points.in.selected.code.fragment=선택한 코드 조각에 일관되지 않은 반환점이 있습니다.
refactoring.extract.method.tooltip=타입 $name = 'init'
PhpExtractMethodDialog.extract.method=메서드 추출
PhpExtractMethodDialog.extract.function=함수 추출
PhpExtractMethodDialog.visibility=가시성:
PhpExtractMethodDialog.public=Public(&B)
PhpExtractMethodDialog.protected=보호됨(&T)
PhpExtractMethodDialog.private=Private(&V)
PhpExtractMethodDialog.method=메서드:
PhpExtractMethodDialog.function=함수:
PhpExtractMethodDialog.name=이름(&A):
PhpExtractMethodDialog.declare.static=static 선언(&S)
PhpExtractMethodDialog.generate.php.doc=PhpDoc 생성(&G)
PhpExtractMethodDialog.parameters=매개변수
PhpExtractMethodDialog.signature.preview=시그니처 미리보기
PhpExtractMethodDialog.replace.tail.break.continue.with.return=꼬리의 "break/continue" 문을 "return" 문으로 바꾸기(&T)
PhpExtractMethodDialog.return.output.through=출력 변수를 다음을 통해 반환:
PhpExtractMethodDialog.return.output.through.return=return 문(&E)
PhpExtractMethodDialog.return.output.through.ref.parameters=참조에서 전달된 매개변수(&P)
PhpExtractMethodDialog.transformation.options=변환 옵션
PhpExtractMethodDialog.output.variables=출력 변수
PhpExtractMethodDialog.duplicates.count=중복 항목 검토 및 바꾸기({0}개 발견)
PhpExtractMethodDialog.duplicates.pending=중복 검색 중…
refactoring.extract.method.from.duplicate.code=중복 코드에서 메서드 추출

#find usages
find.options.include.child.methods.checkbox=재정의/구현하는 메서드 포함(&V)
find.field.accessors.title=접근자 검색
find.field.accessors.text=''{0}''의 접근자를 검색하시겠어요?
usages.show.this.self.references=$this/자기 참조 표시

#refactoring -> change signature
change.signature.find.usages.of.base.interface=클래스 {1}의 메서드 {0}이(가)\n\
인터페이스 {2}의 메서드를 구현합니다.\n\
기본 메서드를 {3}하시겠어요?
change.signature.find.usages.of.base.class=클래스 {1}의 메서드 {0}이(가)\n\
클래스 {2}의 메서드를 재정의합니다.\n\
기본 메서드를 {3}하시겠어요?
change.signature.tooltip.parameter=$name = 'init' or &...$array = 'init'
change.signature.tooltip.default.value=이 메서드의 모든 기존 호출에서 사용되는 값
change.signature.error.wrong.caret.position=캐럿이 리팩터링할 함수 이름의 위치에 있어야 합니다.
change.signature.usage.view.declarations.header=리팩터링할 함수
change.signature.column.name.parameter=매개변수:
change.signature.column.type.parameter=타입:
change.signature.initialize.new.parameters=클래스 프로퍼티 생성 및 초기화(&I)
change.signature.parameter.may.have.side.effect=매개변수 "{1}"으로 사용된 표현식 "{0}"에 부수 효과가 있을 수 있습니다.
change.signature.arg.type.miss.argument=타입 ''{0}''의 필요한 매개변수
change.signature.arg.type.incompatible=타입 ''{0}''의 매개변수가 필요하나 ''{1}''이(가) 제공되었습니다
change.signature.visibility.not.accessible={1} 가시성을 가진 {0} 은(는) {2}에서 액세스할 수 없습니다.

#refactoring -> pull up/push down
refactoring.pull.up.class.does.not.have.base.classes.interfaces.in.project.files=프로젝트 파일에서 {0}에 기본 클래스/인터페이스가 없습니다.
refactoring.pull.up.implement.method = 인터페이스를 구현하는 클래스에서 메서드 스텁 생성(&S)
refactoring.pull.up.validation.field.into.interface = 프로퍼티를 인터페이스로 가져올 수 없습니다
refactoring.pull.up.validation.static.method.into.interface = {0} 은(는) static이며 abstract일 수 없습니다.
refactoring.pull.up.private.access = {0} 액세스가 {1}(으)로 변경됩니다
refactoring.pull.up.abstract.method = 클래스 {0}이(가) abstract로 표시됩니다.
refactoring.pull.up.conflict.duplicate.constant = {0}이(가) {1}의 상수와 충돌합니다.
refactoring.pull.up.will.not.be.accessible.in.the.target.class={0} 은(는) 대상 클래스에서 액세스할 수 없게 됩니다.
refactoring.pull.up.static.reference.is.not.accessible.in.the.target.class=비 static 메서드 {0}을(를) 외부 클래스에서 static으로 호출해서는 안 됩니다.
refactoring.pull.up.may.not.be.accessible.in.the.target.class={0} 은(는) 대상 클래스에서 액세스 불가능할 수 있습니다.
refactoring.pull.up.is.1.and.will.not.be.accessible.in.the.target.class={0} 은(는) private이며 대상 클래스에서 액세스할 수 없게 됩니다.
refactoring.push.down.method.implemented.in.interface={0} 은(는) abstract로 선언되거나 {1}을(를) 구현해야 합니다.
refactoring.push.down.validation.magic.method=매직 메서드를 이동하면 부수 효과가 생길 수 있습니다.

#refactoring -> move class
refactoring.move.class.name = 클래스 이동
refactoring.move.class.title = 클래스 {0}을(를) 네임스페이스로 이동(&C):
refactoring.move.class.new.file = 클래스를 개별 파일로 추출(&E)
refactoring.move.class.in.non.code.message=주석 및 문자열 내 클래스 참조
refactoring.move.class.cannot.move.anonymous.class=익명 클래스를 이동할 수 없습니다.

#refactoring -> move namespace
refactoring.move.namespace.name=네임스페이스 이동
refactoring.move.namespace.title=네임스페이스 {0} 이동
refactoring.move.namespace.new.namespace=새 네임스페이스 이름(&N):
refactoring.move.related.namespace.description=관련 네임스페이스를 가진 파일을 새 디렉터리로 이동:
refactoring.move.related.namespace.title=관련 네임스페이스를 가진 파일 이동
refactoring.move.related.namespace.name.column=새 네임스페이스 이름
refactoring.move.related.namespace.directory.column=새 디렉터리
refactoring.move.related.namespace.collect.title=하위 네임스페이스 수집 중
refactoring.move.namespace.header.message=네임스페이스 이동
refactoring.move.namespace.message=이동할 네임스페이스
refactoring.move.namespace.in.non.code.message=주석 및 문자열 내 네임스페이스 참조

#refactoring -> move member
refactoring.move.method.label.text.field=클래스로 멤버 이동(&C)
refactoring.move.member.method.is.overridden.in.a.sublclass={0}이(가) 하위 클래스 {1}에서 재정의됩니다.
refactoring.move.members.there.are.several.classes.with.specified.name=지정된 이름이 {0}인 클래스가 여러 개 있습니다.
refactoring.move.members.is.not.a.valid.class.name=''{0}''은(는) 올바른 클래스 이름이 아닙니다
refactoring.move.member.title=정적 멤버 이동
refactoring.move.member.action.name=멤버 이동…
refactoring.move.members.to.be.moved=다른 클래스로 이동할 멤버(&B)
refactoring.move.members.preview.header=다른 클래스로 이동할 멤버
refactoring.move.members.unable.to.resolve.usage.callback.found=사용 위치를 해결할 수 없습니다. 콜백이 발견되었습니다. {0}
refactoring.move.members.unable.to.resolve.usage.late.static.binding.detected=사용 위치를 해결할 수 없습니다. 지연된 static 바인딩이 탐지되었습니다. {0}
refactoring.move.members.late.static.binding.detected=지연된 static 바인딩이 탐지되었습니다. {0}
refactoring.move.members.self.from.anonymous.class=익명 클래스에 대한 자기 참조는 처리할 수 없습니다.
refactoring.move.members.late.static.binding.detected.in.doc=지연된 static 바인딩이 doc에서 탐지되었습니다.
refactoring.move.members.is.not.accessible={1}에서 {0}에 액세스할 수 없습니다.
refactoring.move.members.cannot.find.target.class={0} 클래스를 찾을 수 없습니다
refactoring.move.members.member.will.change.visibility.to.public=멤버 {0}이(가) 가시성을 public으로 변경합니다.
refactoring.move.members.method.implements.abstract.method={0}이(가) {1}에서 abstract 메서드를 구현합니다.
refactoring.move.members.method.implements.method.in={0}이(가) {1}에서 메서드를 구현합니다.
refactoring.move.members.0.will.be.hidden.in.1=멤버 {0}이(가) {1}에서 숨겨집니다.
refactoring.move.members.only.constants.can.be.moved.to.interface = 상수만 인터페이스로 이동할 수 있습니다.

#refactoring -> move file constant
refactoring.move.constant.title=상수 이동
refactoring.move.constant.label.text.field=클래스로 상수 {0} 이동(&C)
refactoring.move.multiple.constant.label.text.field=클래스로 상수 {0}개 이동(&C)
refactoring.move.constant.unable.to.resolve={0}을(를) 해결할 수 없습니다.
refactoring.move.constant.class.already.contains.constant=클래스 {0}에 상수 {1}이(가) 이미 포함되어 있습니다

#refactoring -> move function
refactoring.move.function.title=함수 이동
refactoring.move.function.label.text.field=클래스로 함수 {0} 이동(&C)
refactoring.move.multiple.functions.label.text.field=클래스로 함수 {0}개 이동(&C)
refactoring.move.constant.class.already.contains.method=클래스 {0}에 메서드 {1}이(가) 이미 포함되어 있습니다
refactoring.move.function.interface.cant.contain.method=본문이 있는 메서드는 인터페이스에서 허용되지 않습니다.

#refactoring -> move instance
refactoring.move.method.cannot.move.constructor=생성자를 이동할 수 없습니다
refactoring.move.method.cannot.move.magic.method=매직 메서드를 이동할 수 없습니다.
refactoring.move.instance.method=인스턴스 메서드 이동
refactoring.move.instance.method.action.name=인스턴스 메서드 이동…
refactoring.move.instance.method.preview.header=다른 클래스로 이동할 메서드
refactoring.move.instance.method.this.parameter.label=클래스 {0}에 대한 $this 참조를 바꿀 매개변수 이름
refactoring.move.instance.method.usage.will.not.be.accessible=사용 위치 {0}에 액세스할 수 없게 됩니다. 메서드 가시성을 높여야 합니다.

#refactoring -> make static then move method
refactoring.make.static.then.move.method.select=메서드 ''{0}''을(를) 클래스로 이동
refactoring.make.static.then.move.method.message=메서드 ''{0}''이(가) ''public static''으로 설정됩니다.

#refactoring -> extract interface
refactoring.extract.interface.name=인터페이스 추출
refactoring.extract.interface.title=클래스 ''{0}''에서 인터페이스 추출
refactoring.extract.interface.invalid.caret.location=캐럿이 리팩터링할 클래스 이름의 위치에 있어야 합니다.
refactoring.extract.interface.invalide.extract.from.trait=특성에서 인터페이스를 추출할 수 없습니다.
refactoring.extract.interface.no.methods=인터페이스로 추출할 메서드가 없습니다.
refactoring.extract.interface.field=인터페이스 이름(&I):
refactoring.extract.replace.class.reference=가능한 경우 클래스 참조를 인터페이스로 바꾸기(&F)
refactoring.extract.interface.members.title=인터페이스를 형성하는 멤버(&B)
refactoring.extract.interface.phpdoc.title=PhpDoc
refactoring.extract.interface.phpdoc.do.nothing=그대로(&A)
refactoring.extract.interface.phpdoc.copy=복사(&C)
refactoring.extract.interface.phpdoc.move=이동(&M)
refactoring.extract.interface.validation.members.modifier=각 추출된 메서드에 대해 제어자가 public으로 변경됩니다
refactoring.extract.interface.fail.to.create.file=파일 ''{0}''을(를) 생성하지 못했습니다.

#refactoring -> make method static
refactoring.make.method.static=메서드를 static으로 만들기
refactoring.make.method.static.method.calls.found.in.static.context=메서드 호출이 static 컨텍스트에서 발견되었습니다.
refactoring.make.method.static.method.converts.method.to.static=메서드를 static으로 변환
refactoring.make.method.static.dynamic.method.call.found=인스턴스 객체는 매개변수로서 전달되어야 하는데 dynamic 메서드 호출이 발견되었습니다. {0}
refactoring.make.method.static.this.found=인스턴스 객체는 매개변수로서 전달되어야 하는데 $this이(가) 발견되었습니다.
refactoring.make.method.static.references.to.be.changed=변경된 {0}이(가) 되는 참조
refactoring.make.method.static.doc.method.is.not.supported=Doc 메서드가 지원되지 않습니다.
refactoring.make.method.static.method.is.overridden=메서드 {0}이(가) 재정의됩니다.
refactoring.make.method.static.object.is.needed=메서드 {0}이(가) 매개변수로서 전달되지 않는 프로퍼티 {1}을(를) 사용합니다.
refactoring.make.method.static.private.field.is.not.accessible=private 프로퍼티 {0}은(는) 클래스 외부에서 액세스할 수 없습니다.
refactoring.make.method.static.protected.field.is.not.accessible=protected 프로퍼티 {0}은(는) 클래스 및 해당 상속자 외부에서 액세스할 수 없습니다.
refactoring.make.method.static.writeAccess={0} 쓰기 액세스가 탐지되었습니다. 인스턴스 객체는 매개변수로서 전달되어야 합니다.
refactoring.make.method.static.magic.method=매직 메서드는 static일 수 없습니다.
refactoring.make.method.static.add.parameters.for.fields=프로퍼티 매개변수 추가(&P):

#actions
#action -> detect namespace roots
actions.detect.namespace.roots.notification.id=PHP PSR-0 네임스페이스 루트 탐지가 완료되었습니다
actions.detect.namespace.roots.notification.title=PSR-0 네임스페이스 루트 탐지
actions.detect.namespace.roots.title=PSR-0 네임스페이스 루트 탐지 중…
actions.detect.namespace.roots.finished=PSR-0 네임스페이스 루트 탐지가 완료되었습니다.
actions.detect.namespace.roots.no.new.roots.detected=탐지된 새로운 PSR-0 네임스페이스가 없습니다.
actions.detect.namespace.roots.view.configuration=구성 보기
actions.detect.namespace.roots.manual.configuration=수동으로 설정
actions.detect.namespace.roots.idea.view.configuration='프로젝트 구조 | 모듈'에서 설정을 수정할 수 있습니다.
actions.detect.namespace.roots.from.composer.title=PSR-0/PSR-4 루트
actions.detect.namespace.roots.from.composer.idea.title=소스 루트

#action -> detect language level
actions.detect.language.level.loaded.from.composer.title=PHP 언어 수준
actions.detect.language.level.loaded.from.composer.idea.title=언어 수준

#action --> common settings
actions.detect.common.setting.from.composer.suggest.title=composer와 설정을 동기화하시겠어요?
actions.detect.common.setting.from.composer.enable=동기화 활성화
actions.detect.common.setting.from.composer.disable=동기화 안 함
actions.detect.common.settings.updated.from.composer.title={0} 설정 업데이트 완료
actions.detect.common.settings.composer.sync.state.title=composer.json과의 동기화 {0}
actions.detect.common.setting.from.composer.show.settings=설정 표시

action.detect.user.settings.state.overwritten=동기화가 켜져 있는 경우 IDE 설정(PHP 언어 수준, PSR-0/PSR-4 루트)이 덮어쓰기 될 수 있습니다
action.detect.user.settings.state.supported=PSR-0/PSR-4 루트 및 PHP 언어 수준에 대한 동기화가 지원됩니다.
action.detect.user.settings.state.overwritten.short=PSR-0/PSR-4 루트 및 PHP 언어 수준 설정이 덮어쓰기 될 수 있습니다.
action.detect.settings.sync.turned.on.title=composer.json과 동기화 완료
action.detect.settings.sync.turned.on=PHP 언어 수준이 composer.json과 동기화됩니다.
action.detect.composer.json.not.found.title=composer.json을 찾을 수 없음
action.detect.composer.json.not.found=경로 {0}에서 composer.json을 찾을 수 없습니다.
action.detect.composer.json.open=에디터에서 열기

#action -> mark directory as namespace root
actions.mark.directory.as.psr.0.root.title=폴더를 {0} 루트로 표시하시겠어요?
actions.mark.directory.as.psr.0.root=<i>{0}</i>
actions.mark.directory.as.psr.0.root.with.prefix=접두사 "{1}"가 있는 <i>{0}</i>?
actions.mark.directory.as.psr.0.root.mark.psr={0} 루트로 표시

#action - > new php base
actions.new.php.base.dialog.label.file.name=파일 이름:
actions.new.php.base.dialog.label.extension=파일 확장자:
actions.new.php.base.arrows.extension.tooltip=에디터에서 위쪽 또는 아랫쪽 방향키를 누르면 파일 확장자가 변경됩니다.
actions.new.php.base.arrows.template.tooltip=에디터에서 위쪽 또는 아랫쪽 방향키를 누르면 템플릿이 변경됩니다.

#action -> new php file
actions.new.php.file.action.name=PHP 파일
actions.new.php.file.action.description=새 PHP 파일을 생성합니다
actions.new.php.file.dialog.title=새 PHP 파일 생성

#action -> new php class
actions.new.php.class.action.name=PHP 클래스
actions.new.php.class.action.description=새 PHP 클래스를 생성합니다
actions.new.php.class.dialog.title=새 PHP 클래스 생성
actions.new.php.class.dialog.label.class.name=이름:
actions.new.php.class.dialog.label.namespace=네임스페이스:
actions.new.php.class.dialog.label.directory=경로:
actions.new.php.class.dialog.label.template=템플릿:
actions.new.php.class.dialog.label.superclasses.container=상위 클래스
actions.new.php.class.dialog.label.superclasses.super.fqn=확장자:
actions.new.php.class.dialog.label.superinterfaces.add.interface=인터페이스 추가…
actions.new.php.class.dialog.label.superinterfaces.to.implement=구현:
actions.new.php.class.dialog.label.superinterfaces.to.implement.empty=구현할 인터페이스 선택
actions.new.php.class.dialog.label.superinterfaces.to.extend.empty=확장할 인터페이스 선택
actions.new.php.class.dialog.border.title.class=클래스

#action -> new php test
actions.new.test.class.action.name=새 PHP 테스트
actions.new.test.class.action.description=새 PHP 테스트 생성
actions.new.test.class.dialog.title=새 PHP 테스트 생성
actions.new.test.class.dialog.title.named={0}에 대한 새 PHP 테스트 생성
actions.new.test.class.dialog.label.name=이름:
actions.new.test.class.dialog.label.namespace=네임스페이스:
actions.new.test.class.dialog.label.directory=경로:
actions.new.test.class.dialog.label.fqn=완전히 정규화된 이름:
actions.new.test.class.dialog.border.title.class.to.test=테스트할 클래스(선택 사항)
actions.new.test.class.dialog.border.title.test.class=테스트 클래스
actions.new.test.class.dialog.border.title.target.class.file.path=파일 경로:
actions.new.test.class.dialog.arrows.libraries.hint=에디터에서 위쪽 또는 아랫쪽 방향키를 누르면 테스트 라이브러리가 변경됩니다.
actions.new.test.class.dialog.select.methods.show.inherited.methods=상속된 메서드 표시(&I)

#action -> new PHPUnit test
actions.new.phpunit.class.action.name=PHPUnit 테스트
actions.new.phpunit.class.action.description=새 PHPUnit 테스트를 생성합니다

#action -> generate php doc
actions.generate.php.doc.is.not.available=색인 업데이트 중에는 PHP Doc를 사용할 수 없습니다.

unnamed.variable=(이름이 지정되지 않음)
server=서버
#Connection -> Server Connection
connection.port.is.busy=포트 {0}이(가) 사용 중입니다

#Server configuration
debug.server.import.configuration.dialog.title=배포 설정에서 가져오기
debug.server.import.configuration.preview.border.title=미리보기
debug.server.import.configuration.path.to.remote.root=절대 배포 루트 경로(&R):
debug.server.import.configuration.path.to.remote.root.sftp=절대 원격 루트: ''{0}''
debug.server.import.configuration.path.to.remote.root.sftp.tooltip=절대 원격 파일 경로:<br>"절대 원격 루트 경로". "루트 경로"(배포 설정에 있음). "서버 상의 상대 배포 경로"(배포 경로 매Ping에 있음)
debug.server.import.configuration.path.to.remote.root.mounted=로컬: ''{0}'' -> 원격: ''{1}''
debug.server.import.configuration.path.to.remote.root.mounted.label=마운트된 원격 폴더 경로(&R):
debug.server.import.configuration.path.to.remote.root.mounted.tooltip=절대 원격 파일 경로:<br>"마운트된 폴더의 원격 경로". "서버 상의 상대 배포 경로"(배포 경로 매Ping에 있음)
debug.server.import.configuration.deployment=배포(&D):
debug.server.import.configuration.local=로컬(&L):
debug.server.import.configuration.mounted=마운트된 항목(&M)

debug.server.import.configuration.local.file.path=로컬 파일 경로:
debug.server.import.configuration.project=프로젝트(&P):
debug.server.import.from.deployment.deployment.configurations.message=적절한 경로 매Ping을 가진 배포 구성을 발견했습니다.
debug.server.import.from.deployment.no.deployment.configurations.message=적합한 배포 구성을 찾을 수 없습니다.
debug.server.import.from.deployment.no.deployment.configurations.tooltip=비어 있지 않은 경우 배포 루트를 구성합니다.
debug.server.import.from.deployment.deployment.root.label=배포 루트(&R):
debug.server.import.from.deployment.radio=배포에서 매Ping 가져오기(&I)
debug.server.manually.select.file.or.project=로컬 파일 또는 프로젝트를 직접 선택(&M)
debug.server.manually.select.file.message=디버그할 프로젝트 또는 파일을 선택하세요.
debug.server.select.file.mapping=로컬 파일 경로 구성
debug.server.detect.path.mappings.from.deployment.progress=''{0}'' 프로젝트에 대한 경로 매Ping 분석 중
debug.server.detect.path.mappings.from.deployment=기존 경로 매핑 탐지 중…
debug.server.can.not.detect.path.mappings.from.deployment=경로 매Ping을 평가할 수 없습니다. 대상 배포 서버가 선택되지 않았습니다.

#Debug
debug.accept.connection=수락
debug.ignore.connection=무시
debug.incoming.connection.title.0={0}에서 오는 연결
debug.path.on.server=서버 상의 절대 경로
debug.error.cannot.modify.value=값을 수정할 수 없습니다.
debug.error.cannot.evaluate.variables=변수를 평가할 수 없습니다.
debug.error.cannot.evaluate.expression0=표현식 ''{0}''을(을) 평가할 수 없습니다.
debug.error.cannot.evaluate.expression=표현식을 평가할 수 없습니다.
debug.process.cannot.find.file.in.project=프로젝트에서 경로가 ''{0}''인 파일을 찾을 수 없습니다.
debug.process.cannot.find.server.name=소스 위치를 찾을 수 없습니다. 이름이 ''{0}''인 서버가 없습니다.
debug.process.status.disconnected=연결 해제됨
debug.process.status.wait={0} ''{1}''와(과)의 수신 연결 대기 중
debug.process.status.connected=연결됨
debug.process.console.error.format={0}: 줄 {3}에 있는 {2}의 {1}\n\

debug.mapping.resolve.dialog.stop.debugger=디버거 중지
debug.zend.error.title.cannot.accept.external.xdebug.connection=외부 Xdebug 연결을 수락할 수 없음
debug.zend.required.protocol.version.0.or.higher=필수 프로토콜 버전은 ''{0}'' 이상입니다.
debug.error.title.cannot.accept.external.0.connection=외부 {0} 연결을 수락할 수 없음
debug.zend.cannot.accept.incoming.connection=Zend 디버거에서 오는 연결을 수락할 수 없습니다.
debug.zend.debugger.settings.broadcasting=Zend 디버거 설정 브로드캐스트
debug.zend.debugger=Zend 디버거
debug.xdebug=Xdebug
debug.not.installed=<설치되지 않음>
debug.process.cannot.find.file.link=자세한 정보
debug.process.cannot.find.file=파일 ''{0}''을(를) 로컬에서 찾을 수 없습니다.\n\
수정하려면 서버 이름을 환경 변수 PHP_IDE_CONFIG로 설정한 후 디버그 세션을 다시 시작하세요.
debug.process.cannot.find.local.file=서버 {0}에서 파일의 로컬 사본을 찾을 수 없습니다.\n\
로컬 경로는 {1}입니다.
debug.process.cannot.find.path.mapping=원격 파일 경로 ''{0}''이(가) 프로젝트에서 파일 경로에 매Ping되지 않았습니다.
debug.process.script.outside.project=스크립트 ''{0}''은(는) 프로젝트 외부에 있습니다.\n\

debug.process.cant.compute.source.position=소스 위치를 계산할 수 없습니다. 스크립트 ''{0}''이(가) 텍스트 파일 타입과 연결되어 있지 않습니다.
debug.edit.path.mappings=클릭하여 경로 매Ping을 설정하세요.
debug.configure.servers=서버 구성
debug.settings.broadcasting.port=설정 브로드캐스트 포트:
debug.settings.auto.detect.ide.host=IDE IP 자동 탐지:
debug.debug.port=디버그 포트:
debug.error=오류
debug.process.cannot.find.remote.copy.local.file=프로젝트 ''{0}'' 내 파일 경로가 서버 상의 파일 경로에 매Ping되지 않았습니다.
debug.cannot.map.local.file=파일 경로가 서버 상의 파일 경로에 매Ping되지 않았습니다. 문제를 수정하려면 경로 매Ping을 편집하세요.
debug.resolve.mapping.problem=경로 매Ping 문제 해결
debug.cannot.start.listening.for.connections.from.0=''{0}''(으)로부터의 연결을 리스닝할 수 없습니다.
debug.cannot.start=''{0}''을(를) 시작할 수 없습니다.
debug.stop.listen.debug.connections=PHP 디버그 연결 리스닝 중지
debug.start.listen.debug.connections=PHP 디버그 연결 리스닝 시작
debug.breakpoint.was.resolved=''{0}''의 중단점이 이 위치로 해결되었으므로 디버그 세션이 일지 중지되었습니다.<br/>중단점 해결을 <a href="disable">비활성화</a>하거나 이에 관해 <a href="more">자세히 읽어보세요</a>. <a href="dontshow">다시 표시 안 함</a>
debug.breakpoint.resolved.disabled=중단점 해결이 비활성화되어 중단점이 다음 디버그 세션부터 해결되지 않습니다. 이 설정은 나중에 <a href="open">PHP | 디버그</a>에서 활성화할 수 있습니다.
debug.breakpoint.resolved.notify.disabled=중단점 해결 알림이 비활성화되었습니다. 이 설정은 <a href="open">PHP | 디버그 | 고급 설정</a>에서 활성화할 수 있습니다.
debug.log.invalid.xdebug.message=Xdebug 메시지가 유효하지 않아 중단점에서 정지하지 못했습니다.\n\
수정하려면 Xdebug의 안정 버전으로 전환하거나 'xdebug.remote_log' 옵션을 사용해 로그를 수집한 후 버그 보고서를 생성하세요. 
debug.log.stop=정지 위치(''{0}'':{1})
debug.log.path.mapping.remote.local=원격: ''{0}'' <-> 로컬: ''{1}''
debug.log.path.mapping.remote.extracted=원격: ''{0}'' <-> 추출됨: ''{1}''
debug.log.stack.frame=프레임: {0}:{1}, {2}
debug.log.connection.was.terminated=디버그 연결이 ''{0}'':''{1}''에서 예기치 않게 종료되었습니다.
debug.log.cant.register.breakpoint.no.remote=중단점을 등록할 수 없습니다. 로컬 경로 ''{0}''에 대한 경로 매Ping이 없습니다.
debug.log.cant.register.breakpoint.no.template.mapping=중단점을 등록할 수 없습니다. PHP 줄 ''{0}''에 대한 매Ping이 없습니다.
debug.log.exception.break=예외 중단: {0} ({1})
debug.file.is.ignored=파일 ''{0}''을(를) 건너뛰었습니다.
debug.edit.ignored.paths.list=건너뛴 경로를 <a href="#a">편집</a>하세요.
debug.composite.value.presentation=[{0}]
debug.error.unknown.debugger.id=디버거 확장 프로그램이 탐지되지 않습니다.
debug.error.wrong.debugger.id={0} 은(는) 지원되지 않습니다.
debug.type.resource=리소스
debug.type.int=int
debug.type.float=float
debug.xdebug.error.unsupported.protocol.version=지원되지 않는 Xdebug 프로토콜 버전
debug.php.line.breakpoint.title=PHP 줄 중단점
debug.php.exception.breakpoint.title=PHP 예외 중단점
debug.php.exception.breakpoint.not.supported=예외 중단점이 로드된 디버그 확장 프로그램에서 지원되지 않습니다.
debug.php.exception.breakpoint.zend.not.supported=예외 중단점이 Zend 디버거에서 지원되지 않습니다.
debug.php.exception.breakpoint.dialog.title=예외 중단점 추가
debug.php.exception.breakpoint.exception.name=예외 이름:
debug.php.method.breakpoint.title=PHP 메서드 중단점
debug.php.method.breakpoint.dialog.title=메서드 중단점 추가
debug.php.method.breakpoint.zend.not.supported=메서드 중단점이 Zend 디버거에서 지원되지 않습니다.
debug.php.breakpoint.failed.to.register=중단점을 등록하지 못했습니다. 비활성화 후 다시 활성화하세요.
debug.error.cannot.parse.ssh.connection=Can''t parse port from $_SERVER[''SSH_CONNECTION'']의 포트를 분석하지 못했습니다. ''{0}''
debug.error.cannot.parse.server.name.for.external.connection=외부 {0} 연결에 대한 서버 이름을 분석할 수 없습니다.
debug.error.cannot.parse.server.name=수정하려면 환경 변수 <i><b>PHP_IDE_CONFIG</b></i>를 원격 서버에서 생성하세요.<br/><br/><i>Windows:</i> PHP_IDE_CONFIG="serverName=SomeName" 설정<br/> <i>Linux/Mac OS X:</i> PHP_IDE_CONFIG="serverName=SomeName" 내보내기
debug.error.server.name.is.empty=<i><b>$_SERVER["SERVER_NAME"]</i></b>이(가) 비어 있습니다. 이는 웹 서버 구성이 잘못되었기 때문일 수 있습니다.<br/><br/><i>Nginx:</i> fastcgi 매개변수를 nginx 구성에 추가(<a href="http://wiki.nginx.org/PHPFcgiExample">자세한 정보</a>)<br/><i>Apache:</i> 현재 VirtualHost에 대한 ServerName 구성(<a href="https://httpd.apache.org/docs/2.4/vhosts/name-based.html">자세한 정보</a>)

debug.php.external.connection.finished.warning.title=디버그 세션이 일시 중지 없이 완료됨
debug.php.external.connection.finished.warning=경로 매Ping이 잘못 구성되었거나 로컬 및 원격 프로젝트가 동기화되지 않았기 때문일 수 있습니다.<br/><br/>문제를 파악하려면 <b><i><a href="servers">PHP | 서버</a></i></b>에서 ''{0}'' 서버에 대한 경로 매Ping 구성을 확인하거나 <b><i><a href="break">PHP 스크립트의 첫 번째 줄에서 중단''</a></i></b> 옵션(<i>실행</i> 메뉴)을 활성화하세요.<br/><a href="ignore">다시 표시 안 함</a>
debug.php.external.connection.finished.break.at.first.line.title=PHP 디버그 구성
debug.php.external.connection.finished.break.at.first.line=<b><i>'첫 번째 줄에서 중단'</i></b> 옵션이 활성화되었습니다.

debug.process.smart.step.into.popup=함수에 스텝인투
debug.process.smart.step.into.function.evaluation.error =대상 함수를 평가할 수 없습니다. 스텝인투가 수행됩니다.
debug.process.smart.step.into.function.was.not.executed=선택된 함수가 호출되지 않았습니다.

#rest client
debug.rest.client.error.cannot.evaluate.server.name.title=서버 이름에 해당하는 PHP | 서버를 찾을 수 없습니다
debug.rest.client.error.cannot.evaluate.server.name='$_SERVER['SERVER_NAME']'을(를) 평가할 수 없습니다. 웹 서버의 서버 이름이 올바르게 구성되었는지 확인하세요. <br>자세한 정보는 이 <a href="help">링크</a>를 참조하세요.

# custom actions
debug.function.was.added.to.skip.list=''{0}''이(가) 건너뛰기 목록에 추가되었습니다.
debug.action.copy.as.title=변수를 ''{0}''로 복사
debug.action.copy.as.was.fail.can.not.get.full.name=변수를 ''{0}''(으)로서 복사하지 못했습니다. 전체 변수 이름을 평가할 수 없습니다.
debug.action.copy.value.as.text=다음으로 값 복사…

debug.label.select.a.project.or.a.file.to.debug=디버그할 프로젝트 또는 파일 선택
debug.label.select.a.project.to.debug=디버그할 프로젝트 선택
debug.label.file.path.on.server=서버 상의 파일 경로:
debug.label.file.path.in.project=프로젝트 내 파일 경로:
debug.checkbox.can.accept.external.connections=외부 연결 수락할 수 있음
debug.checkbox.ignore.z.ray.system.requests=Z-Ray 시스템 요청 무시
debug.label.max.simultaneous.connections=최대 동시 연결:

# templates
template.debug.path.to.output.folder.descr=캐시 디렉터리 경로를 지정합니다.
template.debug.path.to.output.folder=캐시 디렉터리 경로
template.debug.cache.path=캐시 경로:
template.debug.cache.dir.is.incorrect=템플릿 디버그: 설정에 지정된 캐시 디렉터리 경로가 유효하지 않습니다.
template.debug.cache.dir.is.not.specified=템플릿 디버그: 캐시 디렉터리 경로가 설정에 지정되어 있지 않습니다.
template.debug.php.file.not.found=템플릿 디버그: {0}에 해당하는 PHP 파일을 찾을 수 없습니다.

postfix.template.provider.display.name=PHP

template.smart.completion.function.parameters.description=스마트 함수 매개변수 완성

debug.expression.evaluation.fail=알 수 없는 반환값으로 인해 표현식을 평가하지 못했습니다.

dbgp.proxy=Xdebug 프록시
dbgp.proxy.port=프록시 포트
dbgp.proxy.host=프록시 호스트
dbgp.proxy.ide.key=IDE 키
dbgp.proxy.ide.register.success=IDE가 IDE 키 ''{0}''(으)로 성공적으로 등록되었습니다.
dbgp.proxy.ide.unregister.success=IDE가 성공적으로 등록 해제되었습니다.
dbgp.proxy.ide.register.error=IDE 키 ''{0}''(으)로 IDE를 등록할 수 없습니다.
dbgp.proxy.cannot.connect.to.host=호스트 ''{0}''에 연결할 수 없습니다.
dbgp.proxy.cannot.connect.to.xdebug.proxy=''{0}:{1}''에서 Xdebug 프록시에 연결할 수 없습니다.
dbgp.proxy.sending.request.to.xdebug.proxy=Xdebug 프록시로 요청 전송 중…

profiler.xdebug.task.title=Xdebug 프로파일러 스냅샷 분석
profiler.xdebug.task.parsing=''{0}'' 구문 분석 중
profiler.xdebug.file.chooser.title=Xdebug 프로파일러 스냅샷 선택

profiler.view.execution.statistics.title=실행 통계
profiler.view.call.tree.title=호출 트리
profiler.view.callees.title=피호출자
profiler.view.callers.title=호출자
profiler.column.time.title=시간
profiler.column.memory.title=메모리(B)
profiler.column.own.memory.title=자체 메모리(B)
profiler.column.own.time.title=자체 시간
profiler.column.invocation.count.title=호출
profiler.column.invocation.callable=호출 가능
profiler.column.script=스크립트

profiler.measurement.unit.second=초
profiler.measurement.unit.second.short=초
profiler.measurement.unit.millisecond=밀리초
profiler.measurement.unit.millisecond.short=밀리초
profiler.measurement.unit.microsecond=마이크로초
profiler.measurement.unit.microsecond.short=µs
profiler.button.refresh=새로고침
profiler.label.time=시간:

#phpunit
php.uml.provider.presentable.name=PHP 클래스 다이어그램

#coverage
coverage.is.not.supported.for.selected.run.profile=코드 커버리지가 선택한 실행 프로파일과 호환되지 않습니다

#UI

#run configurations -> components -> command line
PhpCommandLineConfigurationEditor.interpreter.options.editor.dialog.caption=인터프리터 옵션
PhpCommandLineConfigurationEditor.command.line=명령줄
PhpCommandLineConfigurationEditor.field.interpreter.options=인터프리터 옵션:
PhpCommandLineConfigurationEditor.field.custom.working.directory=사용자 지정 작업 디렉터리:
PhpCommandLineConfigurationEditor.field.environment.variables=환경 변수:

#run configurations -> components -> test runner
PhpUnitTestRunnerConfigurationEditor.test.runner=테스트 러너
PhpUnitTestRunnerConfigurationEditor.scope=테스트 범위:
PhpUnitTestRunnerConfigurationEditor.scope.directory=디렉터리
PhpUnitTestRunnerConfigurationEditor.scope.class=클래스
PhpUnitTestRunnerConfigurationEditor.scope.method=메서드
PhpUnitTestRunnerConfigurationEditor.scope.xml=구성 파일에서 정의됨
PhpUnitTestRunnerConfigurationEditor.field.directory=디렉터리:
PhpUnitTestRunnerConfigurationEditor.field.method=메서드:
PhpUnitTestRunnerConfigurationEditor.field.class=클래스:
PhpUnitTestRunnerConfigurationEditor.field.file=파일:
PhpUnitTestRunnerConfigurationEditor.use.alt.configuration.file=대체 구성 파일 사용(&U):
PhpUnitTestRunnerConfigurationEditor.use.alt.bootstrap.file=대체 부트스트랩 파일 사용(&U):
PhpUnitTestRunnerConfigurationEditor.field.test.runner.options=테스트 러너 옵션(&O):
PhpUnitTestRunnerConfigurationEditor.field.test.runner.coverage.engine=기본 커버리지 엔진:
PhpUnitTestRunnerConfigurationEditor.dialog.caption.test.runner.options=테스트 러너 옵션

# run configurations
PhpScripRunConfigurationEditor.configuration.display.name=PHP 스크립트
PhpScripRunConfigurationEditor.configuration.description=PHP 스크립트 구성
PhpScripRunConfigurationEditor.file=파일:
PhpScripRunConfigurationEditor.arguments=인수:
PhpScripRunConfigurationEditor.arguments.caption=인수

PhpHttpRequestRunConfiguration.configuration.display.name=PHP HTTP 요청
PhpHttpRequestRunConfiguration.configuration.description=HTTP 요청 구성
PhpHttpRequestRunConfiguration.error.fetch.result=응답 본문을 사용할 수 없습니다.
PhpHttpRequestRunConfiguration.error.server.is.not.specified=이름이 ''{0}''인 원격 서버를 찾을 수 없습니다.
PhpHttpRequestRunConfiguration.error.host.is.not.specified=서버 ''{0}''에 대한 호스트가 지정되지 않았거나 유효하지 않습니다.
PhpHttpRequestRunConfiguration.error.url.is.not.specified=URL이 지정되지 않았거나 유효하지 않습니다. ''{0}''
PhpHttpRequestRunConfiguration.error.server.configuration=HTTP 요청을 실행할 수 없습니다. ''{0}''. PHP | 서버에서 서버 구성을 확인하세요.

RunConfigurationEditor.configuration=구성
RunConfigurationEditor.server=서버(&S):
RunConfigurationEditor.error.server.is.not.selected=서버가 선택되지 않았습니다.
RunConfigurationEditor.error.server.is.not.exist=이름이 ''{0}''인 서버가 없습니다.

PhpWebAppRunConfigurationEditor.configuration.display.name=PHP 웹 페이지
PhpWebAppRunConfigurationEditor.configuration.description=PHP 웹 페이지 구성
PhpWebAppRunConfigurationEditor.startUrl=시작 URL(&U):
PhpWebAppRunConfigurationEditor.browser=브라우저(&B):
PhpWebAppRunConfigurationEditor.malformed.start.url=잘못된 시작 URL - {0}

PhpRemoteDebugRunConfigurationEditor.configuration.display.name=PHP 원격 디버그
PhpRemoteDebugRunConfigurationEditor.configuration.description=PHP 디버그 구성
PhpRemoteDebugRunConfigurationEditor.server.label=서버(&E):
PhpRemoteDebugRunConfigurationEditor.session.id.label=IDE 키(세션 ID)(&K):
PhpRemoteDebugRunConfigurationEditor.auto.config=IDE 키로 디버그 연결 필터링
PhpRemoteDebugRunConfigurationEditor.session.id.cannot.be.empty=IDE 키(세션 ID)는 비워둘 수 없습니다.
PhpRemoteDebugRunConfigurationEditor.zero.configuration.used.title=수신되는 PHP 디버그 연결 리스닝 시작
PhpRemoteDebugRunConfigurationEditor.filter.connections.help.title=고급 옵션
PhpRemoteDebugRunConfigurationEditor.filter.connections.help=복잡한 서버 설정(예: 동일한 호스트 포트에 있는 여러 애플리케이션)에 유용합니다.<p/>구성 자동 탐지를 선택하지 않은 상태로 남겨두거나 <i>"디버그 연결 리스닝"</i> 액션을 사용하세요.
PhpRemoteDebugRunConfigurationEditor.filter.connections.help.link=자세히 읽어보기
PhpRemoteDebugRunConfigurationEditor.zero.configuration.used=<i>서버</i>가 <i>''{0}''</i> 실행 구성에 대해 지정되어 있지 않으므로 수신되는 모든 디버그 연결을 PhpStorm에서 리스닝합니다.<br/>자세한 정보는 <a href="zero_config">제로 구성 디버그</a>를 참조하세요.<br/><br/>디버그 연결 리스닝을 중지하려면 <a href="stop">실행 | PHP 디버그 연결 리스닝 중지</a>를 사용하세요.
PhpRemoteDebugRunConfigurationEditor.zero.configuration.is.already.used="수신되는 디버그 연결 리스닝"이 이미 활성화되어 있으므로 아무 일도 일어나지 않습니다.<br/>자세한 정보는 <a href="zero_config">제로 구성 디버그</a>를 참조하세요.<br/><br/>디버그 연결 리스닝을 중지하려면 <a href="stop">실행 | PHP 디버그 연결 리스닝 중지</a>를 사용하세요.
PhpRemoteDebugRunConfigurationEditor.stop.zero.configuration.title=수신되는 PHP 디버그 연결 리스닝 중지
PhpRemoteDebugRunConfigurationEditor.stop.zero.configuration=PhpStorm에서 수신되는 PHP 디버그 연결 리스닝을 중지했습니다.

PhpBuiltInWebServerRunConfigurationEditor.configuration.display.name=PHP 기본 웹 서버
PhpBuiltInWebServerRunConfigurationEditor.configuration.description=PHP 기본 웹 서버 구성
PhpBuiltInWebServerRunConfigurationEditor.title=서버 구성
PhpBuiltInWebServerRunConfigurationEditor.host=호스트:
PhpBuiltInWebServerRunConfigurationEditor.port=포트:
PhpBuiltInWebServerRunConfigurationEditor.document.root=문서 루트:
PhpBuiltInWebServerRunConfigurationEditor.use.router.script=라우터 스크립트 사용:

PhpDebugConfigurable.ignore.external.connections.through.unregistered.server.configurations.label=등록되지 않은 서버 구성을 통한 외부 연결 무시
PhpDebugConfigurable.xdebug.resolve.breakpoints=현재 줄에서 사용할 수 없는 경우 중단점 해결(Xdebug 2.8 이상)
PhpDebugConfigurable.xdebug.force.break.no.path.mapping=지정된 경로 매Ping이 없을 경우 첫 번째 줄에서 강제 중단
PhpDebugConfigurable.xdebug.force.break.when.outside.project=지정된 경로 매Ping이 없을 경우 첫 번째 줄에서 강제 중단
PhpDebugConfigurable.xdebug.debug.port=Xdebug 디버그 포트
PhpDebugConfigurable.zend.debug.port=Zend 디버거 디버그 포트
PhpDebugConfigurable.zend.settings.broadcasting.port=Zend 디버거 설정 브로드캐스트 포트
PhpDebugConfigurable.zend.settings.ide.hosts=Zend 디버거 IDE 호스트
PhpDebugConfigurable.zend.settings.ide.hosts.detect=탐지 중…
PhpDebugConfigurable.zend.settings.ide.hosts.detect.progress=Zend 디버거 IP 탐지 중…
PhpDebugConfigurable.xdebug=Xdebug
PhpDebugConfigurable.zend.debugger=Zend 디버거
PhpDebugConfigurable.safe.evaluation.mode=값 힌트 및 감시 프레임에서 안전한 평가 모드
PhpDebugConfigurable.import.use.statements=평가 컨텍스트에서 네임스페이스 및 'use' 문 가져오기
PhpDebugConfigurable.show.array.children.in.repl=디버그 콘솔에서 배열 및 객체 하위 항목 표시
PhpDebugConfigurable.external.connections=외부 연결
PhpDebugConfigurable.pass.required.configuration.options=통과하려면 명령줄에서 구성 옵션을 입력해야 합니다(여전히 디버그 확장 기능을 수동으로 활성화해야 합니다)
PhpDebugConfigurable.advanced.settings=고급 설정
PhpDebugConfigurable.notify.session.stopped.without.pause=디버그 세션이 일시 중지 없이 완료될 때 알림
PhpDebugConfigurable.notify.resolved.breakpoint=중단점이 다른 줄로 해결되었을 경우 알림(Xdebug 2.8 이상)
PhpDebugConfigurable.detect.path.mappings.from.deployment=배포 설정에서 경로 매Ping 탐지
PhpDebugConfigurable.break.at.first.line=PHP 스크립트 첫 번째 줄에서 중단
PhpDebugConfigurable.evaluation=평가판
PhpDebugConfigurable.zero.configuration=사전 구성
PhpDebugConfigurable.zero.configuration.install.debugger.php.instruction=1. 웹 서버에서
PhpDebugConfigurable.zero.configuration.install.xdebug.php.instruction=Xdebug
PhpDebugConfigurable.zero.configuration.install.php.instruction=또는
PhpDebugConfigurable.zero.configuration.install.zend.debugger.php.action=Zend 디버거
PhpDebugConfigurable.zero.configuration.install.zend.debugger.php.instruction=설치합니다.
PhpDebugConfigurable.zero.configuration.install.php.validate.action=유효성 검사
PhpDebugConfigurable.zero.configuration.install.php.validate=웹 서버에서 디버거 구성을 설치합니다.
PhpDebugConfigurable.zero.configuration.install.toolbar.instruction.label=2. 브라우저 도구 모음 또는 북마크를
PhpDebugConfigurable.zero.configuration.install.toolbar.instruction=설치합니다.
PhpDebugConfigurable.zero.configuration.listen.for.connections=PHP 디버그 연결 리스닝을 활성화합니다.
PhpDebugConfigurable.zero.configuration.start.session=4. 도구 모음 또는 북마크가 있는 브라우저에서 디버그 세션을시작합니다.
PhpDebugConfigurable.zero.configuration.tutorial=자세한 정보는
PhpDebugConfigurable.zero.configuration.tutorial.action=제로 구성 디버그 튜토리얼을 참조하세요.

PhpDebugConfigurable.zero.configuration.listen.for.connections.action=리스닝 시작
PhpDebugConfigurable.zero.configuration.stop.listen.for.connections.action=리스닝 중지
PhpDebugConfigurable.remote.debug.listen.for.connections=3. "PHP 원격 디버그" 실행 구성을 시작합니다.
PhpDebugConfigurable.web.page.pre.config.title=사전 구성 디버그
PhpDebugConfigurable.web.page.listen.for.connections=2. "PHP 웹 페이지" 실행 구성을 시작합니다.

PhpDebugSkippedPathsConfigurable.display.name=건너뛴 경로
PhpDebugSkippedPathsConfigurable.notify.about.skipped.files=건너뛴 파일 알림
PhpDebugSkippedPathsConfigurable.column.title=건너뛴 경로

PhpFrameworksCommonConfigurable.display.name=프레임워크

PhpStepFiltersConfigurable.title.methods=메서드
PhpStepFiltersConfigurable.specify.method.name=메서드 이름 지정
PhpStepFiltersConfigurable.add.method=메서드 추가
PhpStepFiltersConfigurable.skip.magic.methods=매직 메서드 건너뛰기
PhpStepFiltersConfigurable.skip.constructors=생성자 건너뛰기
PhpStepFiltersConfigurable.skipped.methods=건너뛴 메서드
PhpStepFiltersConfigurable.title.files=파일
PhpStepFiltersConfigurable.skipped.files=건너뛴 파일
PhpStepFilters.log.frame=프레임을 건너뛰었습니다. 함수 이름: {0}. 원격 파일 URL: {1}  

PhpServerConfigurable.shared=공유됨(&S)
PhpServerConfigurable.host=호스트
PhpServerConfigurable.host.label=호스트(&H)
PhpServerConfigurable.port=포트
PhpServerConfigurable.port.label=포트(&P)
PhpServerConfigurable.debugger.label=디버거(&D)

# web server validation for debug
php.web.server.validation.title=웹 서버에 있는 디버거 구성의 유효성 검사
php.web.server.validation.action.text=웹 서버 디버그 유효성 검사
php.web.server.validation.local.web.server.radio=로컬 웹 서버 또는 공유 폴더(&L)
php.web.server.validation.remote.web.server.radio=원격 웹 서버(&R)
php.web.server.validation.local.path.to.script=유효성 검사 스크립트를 생성할 경로(&P):
php.web.server.validation.local.path.to.script.tooltip=선택된 경로는 웹 서버를 통해 액세스 가능해야 합니다.
php.web.server.validation.url.to.validation.script=유효성 검사 스크립트 URL(&U):
php.web.server.validation.url.to.validation.script.tooltip=선택된 웹 경로는 유효성 검사 스크립트를 실행하는 데 사용됩니다.
php.web.server.validation.deployment.server=배포 서버(&D):
php.web.server.validation.deployment.server.tooltip=선택된 서버는 유효성 검사 스크립트를 원격 서버로 배포하는 데 사용됩니다.
php.web.server.validation.process.title=웹 서버 유효성 검사
php.web.server.validation.dialog.validate.button=유효성 검사(&V)
php.web.server.validation.chose.path.to.script=유효성 검사 경로 선택
php.web.server.validation.chose.path.to.script.description=유효성 검사 스크립트를 생성할 로컬 경로를 선택합니다.
php.web.server.validation.invalid.path.to.script=유효성 검사 디렉터리 경로가 유효하지 않습니다.
php.web.server.validation.configure.local=유효성 검사 스크립트의 로컬 및 웹 경로를 구성해 주세요.
php.web.server.validation.configure.remote=유효성 검사 스크립트의 경로를 구성하고 배포 서버를 선택해 주세요.
php.web.server.validation.failed.to.find.web.path=유효성 검사 스크립트의 웹 경로를 구성해 주세요.
php.web.server.validation.failed.to.find.deployment.settings=서버에 대한 배포 설정을 찾지 못했습니다.
php.web.server.validation.failed.to.map.deployment.folder=유효성 검사 디렉터리에 대한 원격 경로 매핑을 구성해 주세요.
php.web.server.validation.failed.to.map.deployment.folder.to.web=유효성 검사 디렉터리에 대한 웹 경로 매핑을 구성해 주세요.
php.web.server.validation.uploading.validation.script=유효성 검사 스크립트를 {0}(으)로 업로드 중
php.web.server.validation.failed.to.deploy.validation.script=유효성 검사 스크립트를 서버로 배포하지 못했습니다.
php.web.server.validation.failed.to.fetch.script.result=유효성 검사 스크립트의 결과를 가져오지 못했습니다.
php.web.server.validation.script.result.is.empty=유효성 검사 스크립트의 결과가 비어 있습니다.
php.web.server.validation.script.result.wrong.format=유효성 검사 스크립트의 결과가 예상치 못한 형식입니다.
php.web.server.validation.script.local.result.path.mapping.check=<b>''{0}''</b> 디렉터리에 대한 유효성 검사 스크립트의 웹 경로가 올바르게 구성되었는지 확인해 주세요.
php.web.server.validation.script.result.path.mapping.check=배포 설정에서 <b>''{0}''</b> 디렉터리에 대한 원격 및 웹 경로 매핑이 올바르게 구성되었는지 확인해 주세요.
php.web.server.validation.failed.to.execute.script=지정된 UR에 도달할 수 없습니다. 원인: ''{0}''
php.web.server.validation.configuration.files=<b>로드된 php.ini:</b> {0}
php.web.server.validation.additional.configuration.files=<b>구문 분석된 추가 .ini 파일:</b> {0}
php.web.server.validation.no.configuration.files=php.ini 파일을 찾을 수 없습니다.
php.web.server.validation.server.name=<b>서버 이름:</b> {0}
php.web.server.validation.server.name.is.empty=서버 이름이 비어 있습니다.
php.web.server.validation.server.name.is.empty.description=PhpStorm 내에서 식별하려면 서버 이름이 필요합니다.<br> 웹 서버 구성 파일에서 서버 이름을 구성해 주세요.
php.web.server.validation.no.debugger.extension=로드된 디버그 확장 프로그램이 없습니다.
php.web.server.validation.multi.debugger.extension=Xdebug 및 Zend 디버거 확장 프로그램이 모두 로드되었습니다.
php.web.server.validation.multi.debugger.extension.description=php.ini 파일에는 단 하나의 디버거 확장 프로그램만 로드할 수 있습니다.
php.web.server.validation.loaded.debugger.extension=<b>디버거 확장 프로그램:</b> {0}
php.web.server.validation.xdebug.debugger.host=<b>원격 호스트:</b> {0}
php.web.server.validation.xdebug.debugger.localhost=서버 호스트가 로컬이 아닐 가능성이 있음에도 원격 호스트가 ''{0}''(으)로 구성되어 있습니다.
php.web.server.validation.xdebug.debugger.host.remote.addr=<br/><br/>php.ini 파일에서 <b>''{0}''</b>을(를) 웹 서버에 표시되는 로컬 시스템의 <i>''{1}''</i> 또는 IP 주소로 설정하세요.
php.web.server.validation.xdebug.debugger.host.description=디버거 <b>클라이언트</b>가 실행되는 호스트입니다.
php.web.server.validation.xdebug.zend.extension.load=Xdebug는 'extension'이 아닌 'zend_extension'으로 로드해야 합니다.
php.web.server.validation.xdebug.zend.extension.load.description=Xdebug 확장 프로그램을 로드하려면 php.ini 파일에서 <b>'zend_extension=path_to_xdebug.so'</b> 줄을 사용하세요.
php.web.server.validation.xdebug.port=<b>원격 포트:</b> {0}
php.web.server.validation.xdebug.port.require.sudo=<b>원격 포트:</b> {0}. 사용하려면 루트 권한이 필요합니다.
php.web.server.validation.xdebug.port.require.sudo.description=Linux 및 Mac에서 1024 미만인 포트를 사용하려면 루트 권한이 필요합니다.
php.web.server.validation.xdebug.wrong.port.format=<b>Xdebug 포트가 유효하지 않음:</b> ''{0}''
php.web.server.validation.xdebug.wrong.port=Xdebug 포트(''{0}'')가 PHP -> 디버그 IDE 설정(''{1}'')과 다릅니다.
php.web.server.validation.xdebug.wrong.port.description=php.ini의 Xdebug 포트(<b>{0}</b>)는 IDE 내에서 구성된 포트(<b>PHP -> 디버그</b>)와 동일해야 합니다.
php.web.server.validation.xdebug.remote.is.not.enable=원격 디버그가 활성화되지 않았습니다.
php.web.server.validation.xdebug.remote.is.not.enable.description=<b>''{0}''</b> 줄을 php.ini 파일에 추가하세요.
php.web.server.validation.xdebug3.option.in.invalid.mode=''{0}'' 옵션이 xdebug3에서 잘못된 모드인 ''{1}''(으)로 설정되어 있습니다.
php.web.server.validation.xdebug.remote.autostart.description=각 요청에 대한 디버그 세션이 시도됩니다.
php.web.server.validation.xdebug3.start.with.request.description=디버그 세션이 해당하는 구성에 따라 자동 시작을 시도합니다.
php.web.server.validation.xdebug3.option.is.enabled.message=<b>{0}:</b> 옵션이 ''{1}''(으)로 설정되어 있습니다.
php.web.server.validation.xdebug.option.is.not.enabled.description=<b>{0}:</b> 옵션이 활성화되어 있지 않습니다
php.web.server.validation.xdebug3.start.upon.error.description=디버그 세션이 해당하는 구성에 따라 오류 시 자동 시작을 시도합니다.
php.web.server.validation.xdebug.option.is.enabled=<b>{0}:</b> 옵션이 활성화되어 있습니다
php.web.server.validation.xdebug3.discover.client.with.discover.header=Xdebug가 <b>$_SERVER[''{0}'']</b>의 값에 따라 클라이언트에 자동 연결을 시도합니다. 실패하면 <b>''xdebug.client_discovery_header''</b>가 비어 있는 <b>''xdebug.discover_client_host''</b>로 폴백합니다.
php.web.server.validation.xdebug3.discover.client=Xdebug가 <b>$_SERVER['HTTP_X_FORWARDED_FOR']</b> 및 <b>$_SERVER['REMOTE_ADDR']</b>의 값에 따라 클라이언트에 자동 연결을 시도합니다. 실패하면 <b>'xdebug.client_host'</b>로 폴백합니다.
php.web.server.validation.xdebug3.discover.client.message=<b>클라이언트 호스트 검색:</b> xdebug가 클라이언트의 호스트를 자동으로 가져오려고 시도합니다.
php.web.server.validation.xdebug.option.is.ignored.description=<b>{0}:</b> 옵션이 무시됩니다.
php.web.server.validation.xdebug.remote.mode.jit=<b>원격 모드:</b> 'jit'
php.web.server.validation.xdebug.remote.mode.jit.description=디버그 세션은 오류가 발생한 후에만 초기화됩니다.
php.web.server.validation.xdebug.remote.mode.req=<b>원격 모드:</b> 'req'
php.web.server.validation.xdebug.remote.mode.req.description=디버그 세션은 스크립트 시작 시 초기화됩니다.
php.web.server.validation.xdebug3.remote.mode.emulation.description=디버그 세션이 xdebug2의 <b>remote_mode=''{0}''</b>와(과) 마찬가지로 스크립트 시작 시 시작됩니다.
php.web.server.validation.xdebug3.remote.mode.emulation.message=<b>원격 모드:</b> xdebug2의 ''{0}''이(가) 에뮬레이션되었습니다. 
php.web.server.validation.xdebug3.cloud.xdebug.doesnt.accept.connections.message=Xdebug는 현재 외부 연결을 허용하지 않습니다
php.web.server.validation.xdebug3.cloud.xdebug.wrong.cloud.id.message=<b>IDE 내 클라우드 ID:</b> 서버상의 클라우드 ID와 동일하지 않습니다
php.web.server.validation.xdebug3.cloud.xdebug.wrong.cloud.id.description=<b>IDE 내 클라우드 ID:</b> {0}<br><b>서버상의 클라우드 ID:</b> {1}
php.web.server.validation.xdebug3.cloud.xdebug.disabled.message=<b>Xdebug Cloud를 통한 연결:</b> 비활성화되어 있습니다. IDE 설정에서 활성화하세요. <b>PHP->디버그->Xdebug Cloud </b>
php.web.server.validation.xdebug3.cloud.php.ini.xdebug.disabled.message=<b>Php.ini 클라우드 디버그:</b> 비활성화되어 있습니다. 
php.web.server.validation.xdebug3.cloud.xdebug.correct.cloud.id.message=<b>IDE 내 클라우드 ID:</b> 서버상의 클라우드 ID와 동일합니다
php.web.server.validation.xdebug.mode.is.not.supported=원격 모드 ''{0}''은(는) 지원되지 않습니다.
php.web.server.validation.xdebug.remote.log=<b>{0}:</b> {1}
php.web.server.validation.xdebug.protocol.is.not.supported=디버그 프로토콜 ''{0}''은(는) 지원되지 않습니다.
php.web.server.validation.zend.debugger.host=<b>원격 호스트:</b> {0}
php.web.server.validation.zend.debugger.localhost=디버그 세션은 서버가 로컬에 없어도 로컬 호스트에 대해서만 허용됩니다.
php.web.server.validation.zend.debugger.localhost.description=디버거 <b>클라이언트</b>가 실행되는 호스트를 <b>'zend_debugger.allow_hosts'</b> 옵션에 추가하세요.
php.web.server.validation.zend.debugger.deny.host=<b>거부 호스트:</b> {0}
php.web.server.validation.zend.debugger.deny.host.description=거부 호스트가 있는 클라이언트로부터는 디버그할 수 없습니다.
php.web.server.validation.zend.expose.remotely=<b>Property ''expose_remotely''</b>가 ''{0}''(으)로 설정되어 있습니다
php.web.server.validation.zend.expose.remotely.allowed.hosts.description=디버거 세션이 <b>'zend_debugger.allow_hosts'</b> 옵션에 있는 호스트에 대해 시도됩니다.
php.web.server.validation.zend.expose.remotely.always.description=각 클라이언트에 대한 디버그 세션이 시도됩니다.
php.web.server.validation.zend.expose.remotely.never.description=디버거 세션이 초기화되지 않으며 <b>'zend_debugger.allow_hosts'</b> 옵션이 무시됩니다.<br> <b>'zend_debugger.expose_remotely'</b> 옵션을 'allowed_hosts' 또는 'always'로 설정하여 웹 서버 디버그를 활성화하세요.
php.web.server.validation.reference.to.documentation=자세한 정보는 <a href="{0}">{0}</a>을(를) 참조하세요.

PhpPathMappingsConfigurable.use.path.mappings.label=경로 매Ping 사용(서버가 원격이거나 심볼릭 링크가 사용된 경우 선택)


DBGPProxyConfigurable.display.name=DBGp 프록시
DBGPProxyConfigurable.ide.key=IDE 키:
DBGPProxyConfigurable.host=호스트:
DBGPProxyConfigurable.port=포트:

xdebug.initializing.debugger.connection={0}에 연결 중…
xdebug.initializing.connection.failed.with.timeout={0}에 연결할 수 없습니다. 시간 제한 초과
xdebug.initializing.connection.debugger=디버거
xdebug.initializing.connection.xdebug.cloud=Xdebug Cloud

XdebugCloudConfigurable.display.name=Xdebug Cloud
XdebugCloudConfigurable.connect.via.xdebug.cloud=Xdebug Cloud에 연결
XdebugCloudConfigurable.cloud.id=Cloud ID:
XdebugCloudConfigurable.custom.server=온프레미스 Xdebug Cloud로 연결
XdebugCloudConfigurable.base.host=Cloud 호스트:
XdebugCloudConfigurable.port=Cloud 포트:

xdebug.cloud.validation.cloud.id.not.defined=Cloud ID가 정의되지 않았습니다
xdebug.cloud.validation.host.not.defined=온프레미스 Xdebug Cloud 호스트가 정의되지 않았습니다
xdebug.cloud.validation.port.invalid=온프레미스 Xdebug Cloud 포트가 잘못되었습니다

xdebug.cloud.cannot.connect=Xdebug Cloud에 연결할 수 없습니다
xdebug.cloud.cannot.connect.unknown.host=Xdebug Cloud에 도달할 수 없습니다. {0}
xdebug.cloud.cannot.register.cloud.id=Xdebug Cloud에서 Cloud ID를 등록할 수 없습니다
xdebug.cloud.cannot.register.cloud.id.unexpected.response=예기치 않은 응답으로 인해 Cloud ID를 등록할 수 없습니다
xdebug.cloud.cannot.open.new.debug.connection=새 디버그 연결을 열 수 없습니다

PhpIncomingLocalConnectionDialog.file.path=파일 경로:

PhpIncomingConnectionDialog.server.name=서버 이름:
PhpIncomingConnectionDialog.server.port=서버 포트:
PhpIncomingConnectionDialog.request.uri=요청 URI:
PhpIncomingConnectionDialog.file.path.on.server=서버 상의 파일 경로:

PhpInterpreter.php.sdk.type=PHP 인터프리터
PhpInterpreter.php.dependent.configuration.exists.title=PHP 인터프리터 종속 구성
PhpInterpreter.php.dependent.configuration.exists=선택된 PHP 인터프리터에 대한 {0} 구성이 있습니다. 이 인터프리터를 삭제하시겠어요?
PhpInterpreter.php.home.path.label=PHP 실행 파일:
PhpInterpreter.php.debugger.label=디버거:
PhpInterpreter.php.general.title=일반
PhpInterpreter.configuration.in.project.settings.title=PHP 인터프리터 구성
PhpInterpreter.configuration.in.project.settings.message=PHP 인터프리터는 기본 SDK로서 지정할 수 없습니다. 현재 프로젝트에 대한 구성은 "설정 | PHP"에서 설정할 수 있습니다.
PhpInterpreter.configuration.duplicate.interpreter.name=고유한 이름이 아닌 ''{0}''(이)라는 PHP 인터프리터가 발견되었습니다.
PhpInterpreter.configuration.selection.list.title=CLI 인터프리터 선택
PhpInterpreter.configuration.interpreter.is.invalid="PHP 원격 인터프리터" 플러그인을 활성화하여 인터프리터를 편집하세요.
PhpInterpreterConfigurable.configuration.title=추가
PhpInterpreterConfigurable.reload.phpinfo=phpinfo 다시 로드
PhpInterpreterConfigurable.show.phpinfo=phpinfo 표시
PhpInterpreterConfigurable.updated.phpinfo=phpinfo가 성공적으로 업데이트되었습니다.
PhpInterpreterConfigurable.can.not.updated.phpinfo=phpinfo를 업데이트할 수 없습니다.
PhpInterpreterConfigurable.php.version=PHP 버전: {0}
PhpInterpreterConfigurable.not.installed=설치되지 않음
PhpInterpreterConfigurable.configuration.project.level=이 프로젝트에 대해서만 표시
PhpInterpreterConfigurable.configuration.project.tooltip=인터프리터를 프로젝트 간 공유하지 않으려는 경우 선택합니다.
PhpInterpreterConfigurable.configuration.default.project.tooltip=인터프리터를 디폴트 프로젝트에 대해서만 저장할 수 없습니다.
PhpInterpreterConfigurable.debugger.extension.label=디버거 확장 프로그램:
PhpInterpreterConfigurable.debugger.extension.title=디버거 확장 프로그램 경로 선택
PhpInterpreterConfigurable.debugger.extension.description=디버거 확장 프로그램은 CLI 실행 구성에서 시작된 디버그 세션에서만 로드됩니다.
PhpInterpreterConfigurable.configuration.options.table.empty.text=php.ini에서 허용된 구성 지시문의 사용자 지정 값을 설정합니다.
PhpInterpreterConfigurable.configuration.options.with.empty.name.are.not.allowed=이름이 비어 있는 구성 옵션은 허용되지 않습니다.
PhpInterpreterConfigurable.configuration.options.dialog.caption=구성 옵션
PhpInterpreterConfigurable.configuration.options.label=구성 옵션:
PhpInterpreterConfigurable.configuration.options.table.name=구성 지시문
PhpInterpreterConfigurable.configuration.options.table.value=값
PhpInterpreterConfigurable.configuration.options.description=이러한 옵션은 '-d' 명령줄 옵션을 사용하여 전달됩니다
PhpInterpreterConfigurable.configuration.file.path=구성 파일: {0}
PhpInterpreterConfigurable.configuration.file.path.not.found=구성 php.ini 파일이 없습니다.
PhpInterpreterConfigurable.configuration.file.evaluate.dir=구성 파일 디렉터리 평가 중…
PhpInterpreterConfigurable.configuration.file.fix.title=구성 php.ini 파일이 없습니다.
PhpInterpreterConfigurable.configuration.file.hhvm.fix=<b>/etc/hhvm</b> 디렉터리에서 php.ini 파일을 생성하세요.<br><br>자세한 정보는 이 <a href="http://docs.hhvm.com/manual/en/configuration.file.php">링크</a>를 참조해 주세요.
PhpInterpreterConfigurable.configuration.file.fix={0} 디렉터리에서 php.ini 파일을 생성하세요.<br><br>구성 파일 템플릿은 php 루트 폴더에서 찾을 수 있습니다.<br>"php.ini-development" - 디폴트 설정<br>"php.ini-production" - 권장 설정<br>
PhpInterpreterConfigurable.configuration.file.fix.failed.to.detect=구성 파일 디렉터리를 결정하려면 "{0} --ini" 명령어를 사용하세요.<br>
PhpInterpreterConfigurable.configuration.file.fix.link=<br>자세한 정보는 이 <a href="http://php.net/manual/en/configuration.file.php">링크</a>를 참조하세요.
PhpInterpreterConfigurable.configuration.file.can.not.find.title=구성 파일을 찾을 수 없음
PhpInterpreterConfigurable.configuration.file.can.not.find=경로로 파일을 찾을 수 없습니다. ''{0}''
php.info.parse.exception=PHP 정보를 분석할 수 없습니다. {0}이(가) 비어 있습니다
PhpInterpreterConfigurable.update.helpers.title=헬퍼 디렉터리 업데이트 중…
PhpInterpreter.php.interpreter.name.conflict.title=인터프리터 이름 충돌
PhpInterpreter.php.interpreter.name.conflict=프로젝트 수준 및 애플리케이션 수준의 인터프리터 이름에서 충돌이 발견되었습니다. 문제를 해결하려면 이러한 프로젝트 수준 인터프리터의 이름을 변경하세요.
remote.interpreter.browse.action.is.not.supported.for.docker=찾아보기 액션은 Docker 기반 원격 인터프리터에 대해 지원되지 않습니다
php.interpreter.info.failed.to.parse.validation.script=유효성 검사 스크립트 출력을 분석하지 못했습니다.

php.interpreter.base.configuration.interpreter.is.invalid={1} 구성에 대한 인터프리터가 유효하지 않아 {0}을(를) 실행하지 못했습니다.
php.interpreter.base.configuration.is.not.provided.or.empty={1}에 대한 {0} 경로가 구성되지 않았습니다. 이는 "PHP | {0}"에서 수정할 수 있습니다.
php.interpreter.base.configuration.working.directory=작업 디렉터리를 탐지할 수 없습니다. 실행 구성에서 구성하세요.
php.interpreter.base.configuration.fix.interpreter={0}. 수정하려면 프로젝트 인터프리터를 <a href=''{1}''>변경</a>하거나 설정을 <a href=''{2}''>확인</a>하세요.

PhpProjectConfigurable.language.level=PHP 언어 수준:
PhpProjectConfigurable.interpreter=CLI 인터프리터:
PhpProjectConfigurable.include.path=Include 경로
PhpProjectConfigurable.0.interpreter.include.path=''{0}''인터프리터 include 경로
PhpProjectConfigurable.specify.other=기타 지정…
PhpProjectConfigurable.all=모두
PhpProjectConfigurable.provide.include.path=include 경로 제공
PhpProjectConfigurable.docker.default.project.error.tooltip=프로젝트를 열거나 생성하여 Docker 컨테이너를 구성하세요.
PhpProjectConfigurable.php.runtime=PHP 런타임
PhpProjectConfigurable.advanced.settings=고급 설정(&V)
PhpProjectConfigurable.default.stubs.path=디폴트 스텁 경로(&D):
PhpProjectConfigurable.select.default.stubs.path.title=디폴트 스텁 경로 선택
PhpProjectConfigurable.select.default.stubs.path.description=디폴트 스텁 경로를 선택합니다.
PhpProjectConfigurable.analysis=분석
PhpProjectConfigurable.exception.analysis=예외 분석
PhpProjectConfigurable.exception.analysis.depth=호출 트리 분석 깊이:
PhpProjectConfigurable.exception.analysis.unchecked.exceptions=검사되지 않은 예외
PhpProjectConfigurable.analysis.custom.format.functions=사용자 지정 형식 함수
PhpProjectConfigurable.include.analysis=Include 분석
PhpProjectConfigurable.select.document.root.path.title=$_SERVER['DOCUMENT_ROOT'] 경로 선택
PhpProjectConfigurable.select.document.root.path.description=$_SERVER['DOCUMENT_ROOT'] 경로를 선택합니다.

custom.format.functions.dialog.validation.class.not.found=클래스 {0}을(를) 찾을 수 없습니다
custom.format.functions.dialog.validation.function.not.found=함수 {0}을(를) 찾을 수 없습니다.
custom.format.functions.dialog.validation.method.not.found={1}에서 메서드 {0}을(를) 찾을 수 없습니다.
custom.format.functions.dialog.validation.format.index=색인은 음수가 아니어야 합니다.
custom.format.functions.dialog.format.index.title=서식 문자열 템플릿의 색인
custom.format.functions.dialog.class.placeholder=일반 함수를 추가하려면 비워 두세요.

PhpUnitConfigurableForm.phpunit.library=PHPUnit 라이브러리
PhpUnitConfigurableForm.use.custom.loader=Composer 자동 로더 사용
PhpUnitConfigurableForm.custom.loader.is.empty=자동 로더 파일의 경로가 비어 있습니다.
PhpUnitConfigurableForm.can.not.find.custom.loader=자동 로더 스크립트를 ''{0}''에서 찾을 수 없습니다.
PhpUnitConfigurableForm.phpunit.phar.is.empty=phpunit.phar 경로가 비어 있습니다.
PhpUnitConfigurableForm.can.not.find.phpunit.phar=''{0}''에서 phpunit.phar를 찾을 수 없습니다.
PhpUnitConfigurableForm.custom.loader.is.directory=자동 로더는 디렉터리여서는 안 됩니다. 디폴트 composer 구성은 "vendor/autoload.php" 경로로 설정하세요.
PhpUnitConfigurableForm.download.phpunit.phar.link.text={0}에서 phpunit.phar 다운로드
PhpUnitConfigurableForm.path.to.script=스크립트 경로:
PhpUnitConfigurableForm.path.to.phpunit.phar=phpunit.phar 경로
PhpUnitConfigurableForm.test.runner=테스트 러너
PhpUnitConfigurableForm.use.configuration.file=디폴트 구성 파일:
PhpUnitConfigurableForm.use.bootstrap.file=디폴트 부트스트랩 파일:
PhpUnitConfigurableForm.use.configuration.file.validation.warning=''{0}''에 대한 구성 파일 경로를 제공하거나 "디폴트 구성 파일" 옵션을 비활성화하세요.
PhpUnitConfigurableForm.use.bootstrap.file.validation.warning=''{0}''에 대한 부트스트랩 파일 경로를 제공하거나 "디폴트 부트스트랩 파일" 옵션을 비활성화하세요.

phpunit.config.label=테스트 루트
phpunit.config.directory.label=경로:
phpunit.config.empty.pattern=빈 패턴
phpunit.getting.phpunit.version=PhpUnit 버전 업데이트 중…
phpunit.not.tests.was.executed.title=PHPUnit이 구성되지 않았습니다.
phpunit.not.tests.was.executed.message=수정하려면 자동 로드 파일 또는 <i>{0}</i>에 대한 PHPUnit phar 경로를 <a href="config">구성</a>하세요.
phpunit.can.not.rerun.failed.tests.title=실패한 PHPUnit 테스트를 실행할 수 없습니다.
frameworks.settings.none.installed=<html>사용할 수 있는 프레임워크 설정 제공자가 없습니다.<br/>Drupal Support, Joomla! Support 또는 WordPress Support 플러그인을 설치해 보세요.</html>
framework.composer.packages.were.changed.0.test.config.title=Composer 패키지가 변경됨
framework.composer.packages.were.changed.0.test.config.popup={0} 구성이 composer.json에 따라 업데이트되었습니다.

PhpUnitConfiguration.interpreter.conflict=애프릴케이션 수준의 PHPUnit 구성에서 충돌이 발견되었습니다. 이 문제를 해결하기 위해 이러한 구성의 프로젝트 수준 복사본이 생성되었습니다.
PhpUnitConfiguration.interpreter.conflict.title=PHPUnit 구성 충돌

# php test framework
php.test.framework.select.type.of.settings.popup.title=구성 타입 선택
php.test.framework.configuration.ui.library={0} 라이브러리
php.test.framework.configuration.ui.test.runner=테스트 러너
php.test.framework.configuration.ui.path.to.exe={0} 실행 파일 경로:
php.test.framework.configuration.ui.use.configuration.file=디폴트 구성 파일:
php.test.framework.download.hyperlink={0} 릴리스: <a href={1}>{1}</a>
php.test.framework.configuration.ui.version={0} 버전: {1}
php.test.framework.configuration.ui.not.installed=설치되지 않음
php.test.framework.configuration.ui.select.interpreter={0} 버전을 로드하려면 PHP 인터프리터를 선택하세요.
php.test.framework.configuration.ui.select.local.interpreter={0} 버전을 로드하려면 로컬 PHP 인터프리터를 선택하세요.
php.test.framework.configuration.updated.version={0} 버전에 성공적으로 업데이트되었습니다.
php.test.framework.configuration.can.not.update={0} 버전을 업데이트할 수 없습니다.
php.test.framework.default.interpreter.is.not.local={0} 버전을 탐지할 수 없습니다. 디폴트 PHP 인터프리터가 로컬이 아닙니다.

php.test.framework.version.getting.version.title={0} 버전 가져오는 중…
php.test.framework.version.path.to.exe.is.invalid={0} 실행 파일 경로가 비어 있거나 유효하지 않습니다.
php.test.framework.version.detector.empty.output=''{0}'' 명령어 출력이 비어 있습니다.
php.test.framework.version.configuration.ui.can.not.parse.version=버전 명령어 출력을 분석할 수 없습니다.\n\
{0}

php.test.framework.by.sdk.new.settings.dialog.title=원격 인터프리터에 따른 {0}
php.test.framework.by.sdk.dialog.label=인터프리터(&I):
php.test.framework.by.sdk.settings.select.server=원격 {0}을(를) 구성하려면 원격 인터프리터를 선택하세요.
php.test.framework.by.sdk.settings.already.exist=선택한 인터프리터의 {0} 설정이 이미 있습니다.
php.test.framework.by.sdk.settings.remote.path.title=서버 상의 경로 선택

php.test.framework.run.configuration.ui.scope=테스트 범위:
php.test.framework.run.configuration.ui.type.radio.button=타입(&T)
php.test.framework.run.configuration.ui.directory.radio.button=디렉터리(&D)
php.test.framework.run.configuration.ui.file.radio.button=파일(&F)
php.test.framework.run.configuration.ui.scenario.radio.button=메서드(&M)
php.test.framework.run.configuration.ui.configuration.radio.button=구성 파일에서 정의됨(&C)
php.test.framework.run.configuration.ui.type.combo.box=타입:
php.test.framework.run.configuration.ui.directory.text.field=경로:
php.test.framework.run.configuration.ui.file.text.field=파일:
php.test.framework.run.configuration.ui.scenario.text.field=메서드:
php.test.framework.run.configuration.ui.alternative.configuration.file=대체 구성 파일 사용(&U):
php.test.framework.run.confuguration.ui.dialog.caption.test.runner.options=테스트 러너 옵션
php.test.framework.field.test.runner.options=테스트 러너 옵션(&O):
php.test.framework.run.configuration.ui.custom.file.radio.button={0}에서 정의됨
php.test.framework.run.configuration.ui.alternative.custom.file=대체 {0} 사용(&U)
php.test.framework.settings.is.not.provided.or.empty={1}에 대한 {0} 경로가 구성되어 있지 않습니다. ''수정''을 눌러 {0} 구성을 편집하세요.

php.test.framework.interpreter.conflict=애프릴케이션 수준의 {0} 구성에서 충돌이 발견되었습니다. 이 문제를 해결하기 위해 이러한 구성의 프로젝트 수준 복사본이 생성되었습니다.
php.test.framework.interpreter.conflict.title={0} 구성 충돌
php.test.framework.project.level=(현재 프로젝트)
php.test.framework.no.configuration.types.are.available=사용 가능한 추가 구성 타입이 없습니다.

# validation
php.test.framework.validation.run.configuration.no.type=타입을 선택하지 않으면 테스트를 실행할 수 없습니다.
php.test.framework.validation.run.configuration.unsupported.type=''{0}'' 명령어로 테스트를 실행할 수 없습니다.
php.test.framework.validation.run.configuration.working.directory=디렉터리는 작업 디렉터리의 하위 폴더여야 합니다. ''{0}''
php.test.framework.validation.run.configuration.file.working.directory=파일은 작업 디렉터리의 하위 항목이어야 합니다. ''{0}''
php.test.framework.validation.run.configuration.method=''{0}''을(를) ''{1}''에서 찾을 수 없습니다.

php.executable.macro.description=프로젝트 설정에서 구성된 PHP 실행 파일
inspection.undefined.class.ignore.phpdoc=PHPDoc 무시

inspection.missing.ext.composer.json=composer.json에서 ''{0}''이(가) 누락되어 있습니다.
inspection.ext.is.specified.in.require.dev.but.used.outside.tests=''{0}''이(가) ''require-dev'' 섹션에 지정되어 있으나 테스트 밖에서 사용되었습니다
inspection.ext.is.specified.in.suggest=''{0}''이(가) ''suggest'' 안에 지정되어 있으므로 사용이 불가능할 수 있습니다.
inspection.missing.ext.require.bundled=PHP 번들 확장 기능이 필요합니다.
add.to.composer.json.quick.fix=''{0}''을(를) composer.json에 추가

configure.php.include.paths=PHP Include 경로 구성(&O)…

interpreter=인터프리터

XdebugShowUserDefinedConstantsToggleAction.text=사용자 정의 상수 표시
XdebugShowUserDefinedConstantsToggleAction.description=비활성화하면 사용자 정의 상수 정보를 받는 작업이 중단되어 디버거 성능이 향상됩니다. 
XdebugAddMethodToSkipListToggleAction.text=목록을 건너뛰는 메서드 추가
PhpDebugHideEmptySuperGlobalsToggleAction.text=비어 있는 상위 전역 변수 표시
PhpDebugBreakAtFirstLineToggleAction.text=PHP 스크립트 첫 번째 줄에서 중단
PhpUserDefinedConstantsGroup.name=상수

PhpLanguageLevel.5.3.0.presentable.name=5.3
PhpLanguageLevel.5.3.0.short.description=네임스페이스, 클로저
PhpLanguageLevel.5.4.0.presentable.name=5.4
PhpLanguageLevel.5.4.0.short.description=특성, 짧은 배열 구문
PhpLanguageLevel.5.5.0.presentable.name=5.5
PhpLanguageLevel.5.5.0.short.description=finally, 제너레이터
PhpLanguageLevel.5.6.0.presentable.name=5.6
PhpLanguageLevel.5.6.0.short.description=가변 함수, 인수 압축 풀기
PhpLanguageLevel.7.0.0.presentable.name=7.0
PhpLanguageLevel.7.0.0.short.description=반환 타입, scalar 타입 힌트
PhpLanguageLevel.7.1.0.presentable.name=7.1
PhpLanguageLevel.7.1.0.short.description=상수 가시성, null 가능 항목, 여러 개의 예외
PhpLanguageLevel.7.2.0.presentable.name=7.2
PhpLanguageLevel.7.2.0.short.description=객체 타입 힌트, 추상 함수 재정의
PhpLanguageLevel.7.3.0.presentable.name=7.3
PhpLanguageLevel.7.3.0.short.description=목록 대입 내 참조, 유연한 heredoc
PhpLanguageLevel.7.4.0.presentable.name=7.4
PhpLanguageLevel.7.4.0.short.description=타입 지정된 프로퍼티, 짧은 클로저, null 병합 연산자
PhpLanguageLevel.8.0.0.presentable.name=8.0
PhpLanguageLevel.8.0.0.short.description=공용체 타입, 이름 지정된 인수, 속성, match 식

PhpLanguageFeature.traits.not.supported=특성 사용은 PHP 5.4 이후 버전에서만 허용됩니다
PhpLanguageFeature.short.array.syntax.not.supported=짧은 배열 구문은 PHP 5.4 이후 버전에서만 허용됩니다
PhpLanguageFeature.array.dereferencing.not.supported=호출에서의 배열 역참조는 PHP 5.4 이후 버전에서만 허용됩니다
PhpLanguageFeature.class.member.access.on.instantiation.not.supported=인스턴스화에서의 클래스 멤버 액세스는 PHP 5.4 이후 버전에서만 허용됩니다
PhpLanguageFeature.this.in.closure.not.supported=클로저 내 $this는 PHP 5.4 이후 버전에서만 허용됩니다
PhpLanguageFeature.self.in.closure.not.supported=클로저 내 self는 PHP 5.4 이후 버전에서만 허용됩니다
PhpLanguageFeature.parent.in.closure.not.supported=클로저 내 parent는 PHP 5.4 이후 버전에서만 허용됩니다
PhpLanguageFeature.static.in.closure.not.supported=클로저 내 static은 PHP 5.4 이후 버전에서만 허용됩니다
PhpLanguageFeature.binary.literal.not.supported=2진 리터럴은 PHP 5.4 이후 버전에서만 허용됩니다
PhpLanguageFeature.literal.in.static.call.not.supported=static 호출 내 리터럴은 PHP 5.4 이후 버전에서만 사용할 수 있습니다.
PhpLanguageFeature.built.in.web.server=기본 웹 서버는 PHP 5.4 이후부터만 사용할 수 있습니다.
PhpLanguageFeature.var.break.argument.not.supported=상수가 아닌 피연산자가 있는 'break' 연산자는 PHP 5.4에서 더 이상 지원되지 않습니다.
PhpLanguageFeature.var.break.zero.argument.not.supported='break' 연산자는 PHP 5.4 이후부터 양수만 허용합니다.
PhpLanguageFeature.var.continue.not.supported=상수가 아닌 피연산자가 있는 'continue' 연산자는 PHP 5.4에서 더 이상 지원되지 않습니다.
PhpLanguageFeature.var.continue.zero.not.supported='continue' 연산자는 PHP 5.4 이후부터 양수만 허용합니다.
PhpLanguageFeature.call.time.pass.by.reference.not.supported=호출 시 참조를 통한 전달은 PHP 5.4에서 제거되었습니다.

PhpLanguageFeature.finally.not.supported='Finally' 절은 PHP 5.5 이후 버전에서만 허용됩니다
PhpLanguageFeature.generators.not.supported=제너레이터는 PHP 5.5 이후 버전에서만 허용됩니다
PhpLanguageFeature.foreach.list.not.supported=foreach 내 리스트는 PHP 5.5 이후 버전에서만 허용됩니다
PhpLanguageFeature.empty.any.expression.not.supported='empty' 내 임의 표현식은 PHP 5.5 이후 버전에서만 허용됩니다
PhpLanguageFeature.immediate.dereferencing.not.supported=즉시 역참조는 PHP 5.5 이후 버전에서만 허용됩니다
PhpLanguageFeature.class.name.const.not.supported=클래스 이름 상수는 PHP 5.5 이후 버전에서만 허용됩니다

PhpLanguageFeature.constant.scalar.expressions=상수 scalar 표현식은 PHP 5.6 이후 버전에서만 허용됩니다
PhpLanguageFeature.variadic.functions=가변 함수는 PHP 5.6 이후 버전에서만 허용됩니다
PhpLanguageFeature.argument.unpacking=인수 패킹 해제는 PHP 5.6 이후 버전에서만 허용됩니다
PhpLanguageFeature.exponentiation=지수식은 PHP 5.6 이후 버전에서만 허용됩니다
PhpLanguageFeature.use.function.and.const=use 함수 및 상수는 PHP 5.6 이후 버전에서만 허용됩니다

PhpLanguageFeature.return.types=반환 타입 선언은 PHP 7.0 이후 버전에서만 허용됩니다
PhpLanguageFeature.scalar.type.hints=scalar 타입 힌트는 PHP 7.0 이후 버전에서만 허용됩니다
PhpLanguageFeature.spaceship.operator=우주선 연산자는 PHP 7.0 이후 버전에서만 허용됩니다
PhpLanguageFeature.coalesce.operator=병합 연산자는 PHP 7.0 이후 버전에서만 허용됩니다
PhpLanguageFeature.grouped.use=그룹화된 use 선언은 PHP 7.0 이후 버전에서만 허용됩니다
PhpLanguageFeature.keyword.names=키워드는 PHP 7.0에서 이름으로 사용될 수 있습니다
PhpLanguageFeature.uniform.variable.syntax=균일 변수 구문은 PHP 7.0 이후 버전에서만 허용됩니다
PhpLanguageFeature.anonymous.classes=익명 클래스는 PHP 7.0 이후 버전에서만 허용됩니다

PhpLanguageFeature.return.void=반환 타입 'void'는 PHP 7.1 이후 버전에서만 허용됩니다
PhpLanguageFeature.nullables=nullable은 PHP 7.1 이후 버전에서만 허용됩니다
PhpLanguageFeature.iterable.type.hint=Iterable 타입 힌트는 PHP 7.1 이후 버전에서만 허용됩니다
PhpLanguageFeature.catch.multiple=여러 구문 포착은 PHP 7.1 이후 버전에서만 허용됩니다
PhpLanguageFeature.class.constant.visibility=클래스 상수 가시성은 PHP 7.1 이후 버전에서만 허용됩니다
PhpLanguageFeature.list.keys=list 패킹 해제 시 키 사용은 PHP 7.1 이후 버전에서만 허용됩니다
PhpLanguageFeature.list.assign=list 패킹 해제 시 [] 사용은 PHP 7.1 이후 버전에서만 허용됩니다
PhpLanguageFeature.negative.numeric.indices=음수 색인은 PHP 7.1 이후 버전에서만 허용됩니다

PhpLanguageFeature.object.type.hint=object 타입 힌트는 PHP 7.2 이후 버전에서만 허용됩니다
PhpLanguageFeature.abstract.function.override=추상 함수 재정의는 PHP 7.2 이후 버전에서만 허용됩니다

PhpLanguageFeature.literal.in.instanceof=첫 번째 피연산자로서 리터럴 사용은 PHP 7.3 이후 버전에서만 허용됩니다
PhpLanguageFeature.references.in.list=[] 및 list() 대입 내 참조는 PHP 7.3 이후 버전에서만 허용됩니다
PhpLanguageFeature.trailing.comma.in.function.calls=함수 호출 내 후행 쉼표는 PHP 7.3 이후 버전에서만 사용할 수 있습니다
PhpLanguageFeature.trailing.comma.in.parameter.list=매개변수 목록 내 후행 쉼표는 PHP 8.0 이후 버전에서만 사용할 수 있습니다
PhpLanguageFeature.trailing.comma.in.closure.use.list=클로저 use 목록의 후행 쉼표는 PHP 8.0 이후 버전에서만 사용할 수 있습니다
PhpLanguageFeature.flexible.heredocs=유연한 heredoc/nowdoc 구문

PhpLanguageFeature.typed.properties=타입이 지정된 프로퍼티는 PHP 7.4 이후 버전에서만 허용됩니다
PhpLanguageFeature.spread.operator.in.array=배열 내 스프레드 연산자는 PHP 7.4 이후 버전에서만 허용됩니다
PhpLanguageFeature.coalesce.assign='??='는 PHP 7.4 이후 버전에서만 허용됩니다
PhpLanguageFeature.arrow.function=화살표 함수 구문은 PHP 7.4 이후 버전에서만 허용됩니다
PhpLanguageFeature.numeric.literals.separators=숫자 리터럴 구분 기호는 PHP 7.4 이후 버전에서만 허용됩니다
PhpLanguageFeature.exception.throw.from.toString=''__toString''의 예외 던지기는 PHP 7.4 이후 버전에서만 허용되므로 ''{0}.__toString''은 예외를 던질 수 있습니다

PhpLanguageFeature.union.types=공용체 타입은 PHP 8.0 이후 버전에서만 허용됩니다
PhpLanguageFeature.namespaced.name.as.single.token=네임스페이스의 일부로서 키워드 사용은 PHP 8.0 이후 버전에서만 허용됩니다
PhpLanguageFeature.nullsafe.dereferencing=nullsafe 연산자는 PHP 8.0 이후 버전에서만 허용됩니다
PhpLanguageFeature.abstract.private.trait.methods=abstract private 특성 메서드는 PHP 8.0 이후 버전에서만 허용됩니다
PhpLanguageFeature.mixed.type.hint='mixed' 타입 힌트는 PHP 8.0 이후 버전에서만 허용됩니다
PhpLanguageFeature.static.type.hint='static' 반환 타입 선언은 PHP 8.0 이후 버전에서만 허용됩니다
PhpLanguageFeature.named.arguments=명명된 인수는 PHP 8.0 이후 버전에서만 허용됩니다
PhpLanguageFeature.match.expression=match 식은 PHP 8.0 이후 버전에서만 허용됩니다
PhpLanguageFeature.throw.expression=throw 식은 PHP 8.0 이후 버전에서만 허용됩니다
PhpLanguageFeature.non.capturing.catches=예외를 변수에 캡처하지 않고 캐치하는 것은 PHP 8.0에서만 가능합니다
PhpLanguageFeature.class.name.literal.on.object=객체에서 '::class' 사용은 PHP 8.0 이후 버전에서만 허용됩니다
PhpLanguageFeature.attributes=속성은 PHP 8.0 이후 버전에서 허용됩니다
PhpLanguageFeature.property.promotion=생성자 프로퍼티 승격은 PHP 8.0 이후 버전에서만 허용됩니다

#Empty project generation
php.empty.project.generator.name=PHP 빈 프로젝트
php.empty.project.generator.description=PHP의 빈 프로젝트를 생성합니다.

#UML
error.cant.create.edge=관계 링크를 생성할 수 없습니다
relationship.already.exists={0} 및 {1} 간 관계가 이미 있습니다
this.will.remove.relationship.link.between.classes=이를 실행하면 클래스 간 관계 링크가 제거되고 클래스 {0}이(가) 수정됩니다. 계속하시겠어요?
remove.relationship.link=관계 링크 제거
final.class.cant.be.inherited={0} 클래스는 final 클래스입니다
node.is.interface=인터페이스는 인터페이스만 확장할 수 있습니다
inspection.undefined.member.downgrade=__magic 메서드가 클래스에 있는 경우 심각도 다운그레이드(&D)

#Phar
phar.include.into.project.action.title=phar을 프로젝트에 포함
phar.exclude.from.project.action.title=프로젝트에서 phar 제외
phar.exclude.or.include.into.project.action.title=phar를 프로젝트에서 포함하거나 제외
phar.failed.to.parse=구문 분석 실패
filetype.phar.description=PHP Phar
filetype.phar.display.name=PHP Phar

#Composer

framework.composer.name.composer=Composer
framework.composer.path.dialog.path.to.composer=Composer 경로
framework.composer.path.dialog.path.to.composer.json=composer.json 경로
framework.composer.path.dialog.specify.composer.phar=Composer phar 지정:
framework.composer.path.dialog.specify.composer.executable=Composer 실행 파일 지정:
framework.composer.path.dialog.specify.composer.json=composer.json 지정:
framework.composer.configurable.title=Composer
framework.composer.init.dialog.title.composer.settings=Composer 설정
framework.composer.file.0.is.not.found=파일 ''{0}''을(를) 찾을 수 없습니다.

framework.composer.add.dependency.task.title=종속성 추가 중
framework.composer.add.dependency.install.button=설치
framework.composer.add.dependency.update.button=업데이트
framework.composer.add.dependency.close.button=닫기(&C)
framework.composer.failed.to.0={0} 실패
framework.composer.0.1.version.2={0} {1}, 버전 {2}
framework.composer.add.dependency.show.output=출력 표시
framework.composer.add.dependency.hide.tooltip=숨기기
framework.composer.add.dependency.successfully.installed.0.version.1={0}, 버전 {1}이(가) 성공적으로 설치되었습니다.
framework.composer.add.dependency.running=실행 중
framework.composer.add.composer.dependency.title=Composer 종속성 관리
frameworks.composer.could.not.get.packages.info.0=패키지 정보를 가져오지 못했습니다. {0}
frameworks.composer.could.not.get.package.info=패키지 정보를 가져오지 못했습니다.
framework.composer.label.version.to.install=설치할 버전(&V):
framework.composer.empty.package.name.in.0={0}에 빈 패키지 이름이 있습니다.
framework.composer.no.package.versions.in.0={0}에 패키지 버전이 없습니다.
framework.composer.expected.name.0.versions.0.description.got.1=<name> {0} <versions> {0} <description>이(가) 필요하나 {1}이(가) 전달되었습니다.
framework.composer.add.dependency.available.packages.label=이용 가능한 패키지
framework.composer.package.default.version=<디폴트>
framework.composer.add.dependency.no.package.selected=선택된 패키지가 없습니다.
framework.composer.add.dependency.no.such.package=packagist에 해당 패키지가 없습니다.
framework.composer.path.form.execution.validation.wrapper=<html>실행이 설정되지 않았습니다.<br/>{0}</html>
framework.composer.path.form.empty.path.to.composer.phar=빈 composer.phar 경로
framework.composer.path.form.empty.path.to.composer.executable=composer 실행 파일 경로가 비어 있습니다.
framework.composer.project.generator.name=Composer 패키지 프로젝트
framework.composer.project.generator.description=Composer 명령어로 프로젝트를 생성합니다.
framework.composer.failed.to.download.composer.phar=composer-stable.phar을 다운로드하지 못했습니다
framework.composer.project.generator.failed.to.copy.temp.directory.0.content.to.project.root=임시 디렉터리 ''{0}''의 내용을 프로젝트 루트로 복사하지 못했습니다.
framework.composer.project.generation.error.title=Composer 프로젝트 생성 실패
framework.composer.project.generator.notification.content.failed.to.find={0}을(를) 찾지 못했습니다.
framework.composer.project.generator.notification.content.failed.to.find.composer.json=프로젝트 루트에서 composer.json을 찾지 못했습니다.
framework.composer=Composer
framework.composer.create.project.progress.title=프로젝트 생성 중
framework.composer.create.project.from=다음에서 프로젝트 생성
framework.composer.install.action.name=설치
framework.composer.path.validation.0.is.a.directory={0}은(는) 디렉터리입니다
framework.composer.path.form.empty.path.to.composer.json=빈 composer.json 경로
framework.composer.vendors.library.name=Composer 벤더
framework.composer.selected.file.is.not.composer.json=선택한 파일은 composer.json이 아닙니다.
framework.composer.notification.title.init.composer=Init composer
framework.composer.file.0.set.as.composer.config.change.setting.a.href.here.a=파일 ''{0}''이(가) Composer 구성으로 설정되어 있습니다.
framework.composer.failed.to.parse.package.names=패키지 이름을 분석하지 못했습니다.
framework.composer.failed.to.load.package.names=패키지 이름 지정을 로드하지 못했습니다.
framework.composer.failed.to.parse.package.description=패키지 설명을 분석하지 못했습니다.
framework.composer.add.dependency.no.version.selected=선택된 버전이 없습니다.
framework.composer.add.dependency.settings.cl.dialog.title=매개변수
framework.composer.add.dependency.settings.cl.label=명령줄 매개변수(&P):
framework.composer.add.dependency.settings.interpreter.label=PHP 인터프리터:
framework.composer.add.dependency.settings.title=설정(&S)
framework.composer.no.description.available=사용할 수 있는 설명이 없습니다.
framework.composer.packages.were.moved.to.0.php.include.paths.popup=Composer 패키지가 Composer 외부 라이브러리에서 PHP include 경로로 이동되었습니다.
framework.composer.packages.were.changed.0.excluded.folders.popup=Composer 패키지가 변경되어 제외된 폴더가 업데이트 되었습니다
framework.composer.packages.were.changed.0.php.include.paths.popup=Composer 패키지가 변경되어 PHP include 경로가 업데이트되었습니다.
framework.composer.packages.were.removed.0.excluded.folders.popup=Composer 패키지가 제외된 폴더에서 제거되었습니다.
framework.composer.packages.were.removed.0.php.include.paths.popup=Composer 패키지가 PHP include 경로에서 제거되었습니다.
framework.composer.packages.were.added.0.excluded.folders.popup=Composer 패키지가 제외된 폴더에 추가되었습니다.
framework.composer.packages.were.added.0.php.include.paths.popup=Composer 패키지가 PHP include 경로에 추가되었습니다.
framework.composer.failed.to.0.1.script.was.cancelled={0} {1}이(가) 실패했습니다. 스크립트가 취소되었습니다.
framework.composer.add.dependency.successfully.updated.0={0}이(가) 성공적으로 업데이트되었습니다.
framework.composer.add.dependency.no.new.version.found.for.0={0}의 새로운 버전이 없습니다.
framework.composer.add.dependency.successfully.removed.0={0}이(가) 성공적으로 제거되었습니다.
framework.composer.updating.package.task.title=패키지 업데이트 중
framework.composer.removing.package.task.title=패키지 제거 중
framework.composer.update.action.name=업데이트
framework.composer.remove.action.name=제거
framework.composer.self.update.action.name=자체 업데이트
framework.composer.label.installed.version=설치된 버전:
framework.composer.path.to.php.executable.titled=PHP 실행 파일 경로
framework.composer.specify.php.executable.0=PHP 실행 파일 {0} 지정
framework.composer.empty.path.to.0=빈 {0} 경로
framework.composer.default.project.interpreter=디폴트 프로젝트 인터프리터
framework.composer.default.interpreter.is.not.configured=이 프로젝트에 대해 구성된 디폴트 인터프리터가 없습니다.
framework.composer.default.interpreter.for.this.project.is.remote=이 프로젝트에 대한 디폴트 인터프리터가 원격이므로 사용될 수 없습니다.
framework.composer.default.composer.interpreter.name=Composer의 인터프리터
framework.composer.interpreters.combo.default.interpreter=< 디폴트 인터프리터 >
framework.composer.interpreters.combo.default.project.interpreter=< 디폴트 프로젝트 인터프리터 >
framework.composer.interpreters.combo.no.default.interpreter=디폴트 설정에 디폴트 인터프리터가 없습니다.
framework.composer.interpreters.combo.no.default.interpreter.in.project=이 프로젝트에 디폴트 인터프리터가 없습니다.
framework.composer.interpreters.combo.default.interpreter.no.php.path=디폴트 인터프리터에 PHP 경로가 제공되지 않았습니다.
framework.composer.initialize.popup=Composer 구성 파일 {0}이(가) 발견되었습니다. 프로젝트 설정이 해당 파일과 동기화됩니다.
framework.composer.install.task.title=패키지 설치 중
framework.composer.update.task.title=패키지 업데이트 중
framework.composer.self.update.task.title=Composer 업데이트 중
framework.composer.script.run.configuration.name=Composer 스크립트
framework.composer.script.run.configuration.description=Composer 스크립트 실행 구성
framework.composer.run.path.to.composer.json=composer.json 경로:
framework.composer.run.script=스크립트:
framework.composer.run.script.missing=Composer 스크립트가 지정되지 않았습니다.
framework.composer.available.version=사용 가능한 버전:
framework.composer.package.version.available.0={0}(으)로 업데이트
framework.composer.failed.check.for.update='update --dry-run' 명령어를 실행하지 못했습니다.
framework.composer.checking.for.update=업데이트 확인 중…
framework.composer.loading.packages=Composer 패키지 업데이트 중
framework.composer.loading.package.description=패키지 설명 로드 중
framework.composer.load.update.availability=사용 가능한 플러그인 업데이트를 확인합니다.
framework.composer.loading.update.availability=Composer 패키지 업데이트 확인 중

# Guzzle
guzzle.name=Guzzle
guzzle.http.request.gutter.name=Guzzle HTTP 요청
guzzle.open.http.request=HTTP 요청 에디터에서 열기
guzzle.unable.to.add.new.request.to.file=''{0}'' 파일에 새 요청을 추가할 수 없습니다
guzzle.invalid.http.request.file=파일 ''{0}''은(는) 잘못된 HTTP 요청 파일입니다
guzzle.unable.to.extract.request.parameters=요청 매개변수를 추출할 수 없습니다
http.client.request.init.debug.connection.title=디버그 연결 초기화

php.interpreter.not.configured.title=PHP 인터프리터가 구성되지 않았습니다.
php.interpreter.not.configured=기본 웹 서버를 사용하려면 <a href="">PHP 인터프리터를 구성</a>하세요.
php.interpreter.is.remote.title=원격 PHP 인터프리터가 구성되었습니다.
php.interpreter.is.remote.message=기본 웹 서버를 사용하려면 <a href="">로컬 PHP 인터프리터를 선택</a>하세요.

php.cgi.not.found.title={0}을(를) 찾을 수 없습니다
php.cgi.not.found=<a href="">구성된 PHP 인터프리터</a>가 CGI 프로그램으로 빌드되었는지 확인하세요(--enable-fastcgi가 지정됨).

php.smart.indent.codestyle.indent.in.php=PHP 태그 코드 들여쓰기

phpdoc.code.style.title=PHPDoc

phpdoc.code.style.generated.doc.blocks=생성된 PHPDoc 태그
phpdoc.code.style.sort.doc.blocks=PHPDoc 태그 정렬

phpdoc.code.style.force.null.position=타입 내 ‘null' 배치:
phpdoc.code.style.in.beginning.position=시작
phpdoc.code.style.in.end.position=끝

phpdoc.code.style.convert.true.false.to=다음으로 True/False 상수 변환:
phpdoc.code.style.convert.null.to=Null 상수를 다음으로 변환:
php.code.style.convert.keyword.to.lowercase=키워드를 소문자로 변환
php.code.style.convert.lower.case=소문자
php.code.style.convert.upper.case=대문자
php.code.style.sort.use.stmt='use' 문 정렬:
php.code.style.sort.alphabetically=알파벳순
php.code.style.sort.by.length=길이순

phpdoc.code.style.convert.else.if.to=다음으로 else if/elseif 변환:
phpdoc.code.style.convert.else.if.separate=else if
phpdoc.code.style.convert.else.if.combine=elseif

phpdoc.code.style.throws.analysis.depth.performance.note.title=성능 관련 주의사항
phpdoc.code.style.throws.analysis.depth.performance.note.message=2개 수준 이상을 분석하면 IDE 성능에 영향을 미칠 수 있으므로 좋지 않습니다. 계속 진행하시겠어요?

phpdoc.code.style.param.spaces.panel=PHPDoc '@param' 공백
phpdoc.code.style.param.spaces.between.tag.and.type=태그 및 타입 사이:
phpdoc.code.style.param.spaces.between.type.and.name=타입 및 이름 사이:
phpdoc.code.style.param.spaces.between.name.and.description=이름과 설명 사이:

php.conversion.code.style.title=코드 변환

php.generation.code.style.title=코드 생성

array.declaration.style=배열/목록 선언 스타일

variable.naming.style.panel=변수 이름 지정 스타일
variable.naming.style.mixed=혼합
variable.naming.style.camel.case=낙타 표기법
variable.naming.style.snake.case=snake 표기법

php.prefdefined.codestyle.psr12.chosen.title=PSR-12 코드 스타일
php.prefdefined.codestyle.psr12.chosen.message=현재 비활성화되어 있는 추가 PSR-12 검사를 활성화할 수 있습니다.
php.prefdefined.codestyle.psr12.enabled.message=PSR-12 검사가 활성화되었습니다.

fields.default.visibility.panel=프로퍼티 디폴트 가시성
fields.default.visibility.private=private
fields.default.visibility.protected=protected
fields.default.visibility.public=public

getters.setters.style=getter/setter 스타일
getters.setters.order=getter/setter 순서:
getters.setters.getters.first=getter 먼저
getters.setters.setters.first=setter 먼저
getters.setters.naming.style=이름 지정 스타일:
getters.setters.configure=구성…

php.embedded.stubs.incorrect.path.warning.title=잘못된 디폴트 스텁 경로
php.embedded.stubs.incorrect.path.warning.message=구성된 디폴트 스텁 경로 ''{0}''이(가) 없으므로 포함된 스텁이 대신 사용됩니다.
php.embedded.stubs.notification.provider.notification=불변 임베디드 스텁을 보고 있습니다. 이를 편집하려면 스텁 프로젝트를 복제한 다음, PHP / PHP 런타임 / 고급 설정을 통해 디폴트 스텁 경로를 제공해야 합니다.
php.embedded.stubs.notification.provider.clone=GitHub에서 복제
php.embedded.stubs.notification.provider.provide=디폴트 스텁 경로 제공
php.embedded.stubs.notification.provider.do.not.show.again=다시 표시 안 함

auto.import.in.file.scope=파일 범위에서 자동 가져오기 활성화
auto.import.in.namespace.scope=네임스페이스 범위에서 자동 가져오기 활성화
auto.import.from.global.space=전역 공간의 심볼 처리
auto.import.from.global.space.class=클래스:
auto.import.from.global.space.function=함수:
auto.import.from.global.space.constant=상수:
auto.import.from.global.space.prefer.fallback=폴백 선호
auto.import.from.global.space.prefer.import=가져오기 선호
auto.import.from.global.space.prefer.fqn=FQN 선호
# non-strict
quickfix.non.strict.object.equality=엄격하지 않은 객체 상등 비교
inspection.non.strict.object.equality=엄격하지 않은 객체 상등 비교

exception.analysis.settings.path=PHP / 분석
inspection.severity.with.magic=__magic이 있는 경우 표시

import.references.on.paste.dialog.title=가져올 {0} 선택
import.references.on.paste.dialog.message=<html>붙여넣은 코드 조각은 대상 범위에서 import 문이 액세스할 수 없는 {0}을(를) 사용합니다.<br/>해당 범위로 가져올 {0}을(를) 선택하세요.</html>
skip.constant.params=상수 매개변수를 가진 호출 건너뛰기
inspection.unused.declaration.option.test.entry_points=테스트 선언을 진입점으로 상정
inspection.unused.declaration.option.show.unused_from_entries=모든 선언 표시
inspection.unused.declaration.option.show_strictly_unused=사용되지 않는 항목만 표시
inspection.unused.declaration.option.test.suppressGettersAndSetters=getter/setter 억제
inspection.code.patterns.panel.errors.class = 패턴은 올바른 php fqn여야 하며, '*'만이 자리표시자로 허용됩니다.
inspection.code.patterns.panel.errors.member = 메서드 패턴 {0}은(는) 올바른 php 식별자여야 하며, ''*''만이 자리표시자로 허용됩니다.
inspection.code.patterns.panel.description.label = fqn 이름이 일치하는 경우 코드를 진입점으로 표시
inspection.code.patterns.panel.description.text = 생성자를 표시하려면 메서드를 공백으로 남겨두세요. \n\
 *가 fqn 이름 내 1개 이상의 문자와 일치하게 됩니다.
inspection.unusedd.description.code.patterns.button.label=코드 패턴
inspection.unused.description.code.suppressed.annotations=억제된 어노테이션
inspection.undefined.member.warnOnMixed=혼합된 멤버, 객체, stdClass, 정의되지 않은 타입, null에 대한 액세스 발생 시 알림
configurable.PhpServerConfigurable.display.name=서버
configurable.PhpDebugConfigurable.display.name=디버그
configurable.PhpProjectConfigurable.display.name=PHP
configurable.PhpSmartKeysConfigurable.display.name=PHP
configurable.QualityToolCommonConfigurable.display.name=품질 도구
class.implements.solely.traversable=클래스 ''{0}''은(는) 인터페이스 Traversable을 Iterator 또는 IteratorAggregate의 일부로 구현해야 합니다.
configurable.PhpServersConfigurable.display.name=서버
configurable.PhpTestFrameworksConfigurable.display.name=테스트 프레임워크
configurable.PhpTemplatesCommonConfigurable.display.name=템플릿
PhpStepFiltersConfigurable.display.name=단계별 실행 필터
remote.connection.settings.interpreter.is.not.remote=현재 프로젝트 인터프리터가 원격이 아닙니다
remote.connection.settings.default.remote.interpreter=디폴트 원격 인터프리터
php.element.is.available.starting.with.php.version=''{0}''은(는) {1} PHP 버전부터 사용할 수 있습니다.
php.element.was.removed.in.php.version=''{0}''은(는) {1} PHP 버전에서 제거되었습니다.
settings.smart.keys.title=PHP
settings.smart.keys.enable.smart.function.parameters.completion=스마트 함수 매개변수 완성 활성화
settings.smart.keys.select.variable.name.without.dollar.sign.on.double.click=두 번 클릭 시 '$' 기호가 없는 변수 이름을 선택
settings.smart.keys.remove.php.open.close.tags.while.pasting.in.php.context=PHP 컨텍스트에서 붙여넣는 동안 PHP의 여는 태그 및 닫는 태그 제거
settings.smart.keys.escape.symbols.on.paste.in.string.literals=문자열 리터럴에 붙여넣을 때 심볼 이스케이프
settings.smart.keys.auto.insert.tag.after.typing='<?'가 입력된 다음에 '<?php' 태그 자동 삽입
settings.smart.keys.find.usages.of.base.method.prompt=메서드 사용 위치 검색 시 추가 옵션 표시
settings.smart.keys.replace.unnecessary.double.quotes.on.paste=붙여넣을 때 불필요한 큰따옴표 바꾸기
php.exception.is.never.thrown=예외 ''{0}''이(가) 함수에서 한 번도 던져지지 않습니다.
php.remove.exception.from.throws=''{0}''을(를) @throws 태그에서 제거
php.remove.throws.tag=@throws 태그 제거
php.add.exception=''{0}''을(를) 기존 @throws 태그에 추가
ternary.condition.can.be.replaced.with.condition.expression=표현식을 안전하게 ''{0}''(으)로 바꿀수 있습니다.
php.replace.with=''{0}''(으)로 바꾸기
php.tag.is.deprecated={0} 은(는) 더 이상 사용되지 않으며 PHPUnit 9에서 제거될 예정입니다.
potentially.polymorphic.call.multiple.subclasses=다형성 호출일 수 있습니다. 인수로서 전달된 실제 클래스 인스턴스에 따라 코드가 작동하지 않을 수 있습니다.
trait.already.contains.method=특성 {0}에 메서드 {1}이(가) 이미 포함되어 있습니다.
potentially.polymorphic.call.single.subclass=다형성 호출일 수 있습니다. {0}의 계층 구조에 멤버가 없습니다
navigate.to.meta.declaration=''{0}''(으)로 이동
meta.declaration.exists=''{1}''에 대한 메타 선언 ''{0}''이(가) 있습니다.
meta.multiple.declaration.exists=''{0}''에 대한 메타 선언이 여러 개 있습니다.
meta.declaration.line.marker.name=메타 선언이 있음
unnecessary.local.variable=불필요한 지역 변수
phpunit.10.won.t.support.classname.annotations=PHPUnit 10에서는 ClassName::<*> 어노테이션이 지원 중단됩니다.
returned.by.iterator.aggregate.should.be.traversable=\\IteratorAggregate::getIterator()로 반환된 객체는 traversable이거나 인터페이스 Iterator를 구현해야 합니다.
inspection.probably.undefined.property=프로퍼티 '#ref'은(는) dynamic으로 선언되었으며 정의되지 않았을 가능성이 있습니다.
find.classes.without.member=멤버가 없는 클래스 찾기
classes.without.member=계층 구조에서 ''{0}''이(가) 없는 클래스 
remove.pass.by.ref='\\&' 제거
pass.by.ref.is.not.effectively.used.inside.body=인수가 참조에 의해 대입되거나 더 전달되지 않으므로 참조가 필요하지 않습니다
suppress.if.annotated.by.tag=''{0}''(으)로 어노테이션이 추가된 경우 억제
configure.suppressed.annotations=억제된 어노테이션 구성
enter.annotation=어노테이션 입력
suppressed.annotation.title=억제된 어노테이션
move.class.to.separate.file.text.family=클래스를 개별 파일로 이동
primitive.hints.name.are.forbidden.in.php.7='int', 'string', 'float', 'bool', 'true', 'false', 'null'로 이름 지정된 클래스는 PHP 7에서 금지됩니다.
classes.named.void.and.iterable.are.forbidden.in.php.7.1='void' 및 'iterable'로 이름 지정된 클래스는 PHP 7.1에서 금지됩니다.
classes.named.object.are.forbidden.in.php.7.2='object'로 이름 지정된 클래스는 PHP 7.2에서 금지됩니다.
switch.statements.may.only.contain.one.default.clause.in.php.7=switch 문은 PHP 7에서 단 하나의 'default' 절만 포함할 수 있습니다.
show.composer.settings.action.name=Composer 설정 표시
composer.change.setting.action.name=설정 변경
composer.diagnose.task.title=진단 중
composer.simulating.update.task.title=업데이트 시뮬레이션 중
composer.generating.autoloader.task.title=자동 로더 생성 중
composer.autoloader.generation.settings.name=자동 로더 생성 설정
composer.generate.list.popup.title=\ 생성
install.composer.packages.task.title=Composer 패키지 설치
composer.listing.licenses.task.title=라이선스 목록 나열 중
composer.update.composer.task.title=Composer 업데이트
composer.checking.for.changes.in.code.of.dependencies.task.title=종속성의 코드 내 변경 내용 확인 중
composer.update.composer.packages.task.title=Composer 패키지 업데이트
composer.validating.task.title=유효성 검사 중
composer.validation.settings.name=유효성 검사 설정
composer.validate.dialog.action.button.title=유효성 검사
composer.revert.action.name=되돌리기
composer.clearing.cache.action.name=캐시 지우기
composer.remove.action.name=제거(&R)
composer.checkbox.download.composer.phar.from.getcomposer.org=getcomposer.org에서 composer-stable.phar 다운로드
composer.label.phar=composer.phar
composer.label.executable='composer' 실행 파일
composer.checkbox.check.if.composer.lock.is.up.to.date=composer.lock이 최신 상태인지 확인
composer.checkbox.autoload.classes.from.the.classmap.only=클래스 맵의 클래스만 자동 로드
composer.label.can.be.time.consuming=시간이 소요될 수 있습니다.
composer.checkbox.disable.autoload.dev.dependencies=autoload-dev 종속성 비활성화
composer.checkbox.optimize.autoloader.convert.psr.0.4.rules.to.a.classmap=자동 로더 최적화(PSR-0/4 규칙을 클래스맵으로 변환)
composer.checkbox.skip.scripts.execution=스크립트 실행 건너뛰기
composer.checkbox.use.apcu.to.cache.found.not.found.classes=APCu를 사용해 발견되거나 발견되지 않은 클래스 캐시
composer.checkbox.allow.unbound.version.constraints=바인드되지 않은 버전 조건 허용
composer.checkbox.check.if.the.package.is.packagist.ready=패키지에서 Packagist를 사용할 수 있는 경우 확인
composer.checkbox.validate.package.dependencies=패키지 종속성의 유효성 검사
composer.checkbox.synchronize.ide.settings.with.composer.json=IDE 설정을 composer.json과 동기화(&S)
composer.label.path.to.composer.json=composer.json 경로(&C):
composer.label.the.settings.php.language.level.directories.may.be.updated=설정(PHP 언어 수준, 디렉터리)이 업데이트될 수 있습니다
composer.border.title.package=패키지
composer.label.package=패키지:
composer.label.version.to.install=설치할 버전:
composer.label.filter.packages=필터 패키지(&F):
composer.label.label=라벨
composer.border.title.execution=실행
php.run.label.server=서버:
php.run.label.https=HTTP:
php.run.label.url=URL:
php.run.label.query.string=쿼리 문자열:
php.run.label.request.body=요청 본문:
php.run.label.request.method=요청 메서드:
php.run.label.send.request.body.as=요청 본문을 다음으로서 전송:
php.run.radio.button.key.value=키-값
php.run.http.border.title.configuration=구성
php.run.label.interpreter=인터프리터:
php.run.radio.button.text=텍스트
replace.with.alias.from.target.scope=대상 범위에 있는 별칭으로 바꾸기
php.information.dialog.title=PHP 정보
extract.method.parameter.name.column.title=매개변수
constant.with.same.name.already.exists.in.0=이름이 동일한 상수가 {0}에 이미 있습니다
path.0.is.invalid=경로 ''{0}''이(가) 올바르지 않습니다
rename.parameters.dialog.title=매개변수 이름 변경
rename.parameter.dialog.description=계층 구조에서 매개변수 이름을 다음으로 변경:
quality.tools.custom.coding.standard=사용자 지정 코딩 표준
quality.tools.0.added.to.ignored.files.list={0}이(가) 무시된 파일 목록에 추가되었습니다.
exclude.0.from.1.analysis.a={1} 분석에서 {0} 제외
create.new.field.dialog.title=새 필드 생성
uml.wrong.name=잘못된 이름
uml.0.already.exists.in.class.1=''{0}''이(가) 클래스 {1}에 이미 있습니다
rename.filename.quick.fix=파일 ''{0}''의 이름을 ''{1}''(으)로 변경합니다.
rename.psi.element.quick.fix={0} ''{1}''의 이름을 ''{2}''(으)로 변경합니다.
fix.package.text=네임스페이스 ''{0}''을(를) ''{1}''(으)로 바꿉니다.
fix.package.text.family=네임스페이스 수정 
variable.always.have.value.0=변수는 도달 시 항상 '{0,, choice, 0#false|1#true}'입니다
introduce.named.constant.for.value.0=값 ''{0}''에 대해 이름 지정된 상수 삽입


checkbox.add.packages.as.libraries=패키지를 라이브러리로서 추가(&A)
phpunit.label.data.set=데이터 집합: 
label.insert.imports.on.paste=붙여넣을 때 import 문 삽입:
border.title.php=PHP
label.class.fqn=클래스 FQN
label.method.name=메서드 이름
checkbox.move.to.another.class=다른 클래스로 이동(&M)
label.visibility=가시성(&V):
label.initialize.in=다음에서 초기화(&I)
radio.button.const=const(&C)
radio.button.define=정의(&D)
border.title.constant.syntax=상수 구문
border.title.visibility=가시성
radio.button.default=디폴트(&F)
radio.button.public=public(&U)
radio.button.private=private(&I)
radio.button.protected=protected(&O)
radio.button.by.concatenation=연결로(&C)
radio.button.by.embeding=임베딩 사용(&E)
radio.button.class.constructor=클래스 생성자(&S)
radio.button.current.method=현재 메서드(&T)
radio.button.field.declaration=프로퍼티 선언(&D)
border.title.initialize.in=다음에서 초기화
border.title.introduce.field=프로퍼티 삽입
radio.button.setup=설정(&U)
border.title.introduce.variable=변수 삽입
label.name=이름:
label.visibility2=가시성:
checkbox.static=static
checkbox.check.clone.method='__clone' 메서드 확인
checkbox.check.destruct.method='__destruct' 메서드 확인
checkbox.check.sleep.method='__sleep' 메서드 확인
checkbox.check.wakeup.method='__wakeup' 메서드 확인
checkbox.align.parameter.property.names=매개변수/프로퍼티 이름 정렬
checkbox.align.tag.comments=태그 주석 정렬
checkbox.blank.line.before.the.first.tag=첫 번째 태그 앞에 빈 줄
checkbox.blank.lines.around.parameters=매개변수 주변에 빈 줄
checkbox.keep.blank.lines=빈 줄 유지
checkbox.sort.phpdoc.tags=PHPDoc 태그 분류
checkbox.use.fully.qualified.class.names=정규화된 클래스 이름 사용
checkbox.wrap.long.lines=긴 줄 줄 바꿈
checkbox.use.as.a.default.template=디폴트 템플릿으로서 사용
label.server.document.root=$_SERVER['DOCUMENT_ROOT']
tooltip.defaults.to.project.folder=프로젝트 폴더의 디폴트 값
border.title.include.analysis=Include 분석
button.sync.extensions.with.interpreter=인터프리터와 확장 프로그램 동기화
checkbox.add.a.comma.after.last.element.in.multiline.array=여러 줄 배열에서 마지막 요소 뒤에 쉼표 추가
checkbox.force.short.declaration.style=짧은 선언 스타일 강제 적용
checkbox.add.phpdoc=PHPDoc 추가(&D):
radio.button.copy.from.base.class=기본 클래스에서 복사(&P)
radio.button.default.empty.template=디폴트/빈 템플릿(&E)
radio.button.with.inheritdoc.tag=@inheritDoc 태그 추가(&I)
label.constant.syntax=상수 구문(&C)
php.interpreter.label.label=라벨
no.expression.found=표현식을 찾을 수 없습니다
empty.type=빈 타입
add.catch.clause.quick.fix='catch' 절 추가
php.delete.catch.clause.quick.fix='catch' 절 삭제
php.delete.exception.quick.fix=예외를 삭제합니다.
php.surround.with.try.catch.quick.fix='try-catch'로 둘러싸기
trait.use.rule.type.name=특성 use 규칙 메서드
member.has.0.access.but.class.has.magic.method.1=멤버가 {0} 가시성을 가지고 있으나 ''{1}'' 매직 메서드를 통해 액세스할 수 있습니다
member.has.0.access=멤버가 {0} 가시성을 가지고 있습니다
declaration.must.be.compatible.with.0=선언은 {0}와(과) 호환되어야 합니다.
declaration.must.be.compatible.with.super=선언은 상위와 호환되어야 합니다
return.type.declaration.must.be.compatible.with.super=반환 타입 선언은 상위 클래스와 호환되어야 합니다
array.only.updated.but.never.queried=배열은 업데이트만 되고 쿼리되지 않습니다.
composer.json.open.tool.settings.intention=도구 설정 열기
composer.json.path.not.configured=사용자 지정 저장소를 로드할 수 없습니다. composer.json 경로가 구성되지 않았습니다.
composer.json.exec.not.configured=사용자 지정 저장소를 로드할 수 없습니다. Composer 실행 파일 경로가 구성되지 않았습니다.
composer.json.custom.packages.done=사용자 지정 저장소가 로드됩니다
composer.json.custom.packages.empty=패키지를 찾을 수 없습니다. 저장소를 확인하세요.
composer.json.custom.invalid.json=잘못된 json
composer.json.packagist.packages.done=packagist 저장소만 로드됩니다.
composer.json.packages.loading.error=패키지가 다시 로드되지 않았습니다.
composer.json.packages.refresh=패키지를 다시 새로 고치는 중입니다.
cant.save.interpreter=''{0}''을(를) 저장할 수 없습니다. {1}
method.is.undefined.in.class=메서드 ''#ref''은(는) {0}에서 {1,choice,0#찾을 수 없습니다|1#정의되어 있지 않을 수 있습니다}
method.is.undefined=메서드 '#ref'이(가) {0,choice,0#정의되어 있지 않습니다|1#정의되어 있지 않을 수 있습니다}.
property.is.undefined.in.class=프로퍼티 ''#ref''은(는) {0}에서 {1,choice,0#찾을 수 없습니다|1#정의되어 있지 않을 수 있습니다}.
property.is.undefined=프로퍼티 '#ref'이(가) {0,choice,0#정의되어 있지 않습니다|1#정의되어 있지 않을 수 있습니다}.
find.cause=원인 찾기
find.exception.cause.table.title=예외 절
php.find.clause.throws=던질 수 있는 가능성이 있음: {0}
action.PhpStanAddToIgnored.text=PHPStan 무시 목록에 추가
action.PhpStanAddToIgnored.description=PHPStan 무시 목록에 추가
inspection.php.unused.display.name=사용되지 않는 선언
inspection.php.expression.always.constant.inspection.display.name=변수는 도달될 시 항상 true/false입니다.
inspection.composer.json.file.references.inspection.display.name=해결되지 않은 파일 참조
inspection.php.doc.duplicate.type.inspection.display.name=타입이 PHPDoc 태그에 이미 있음
inspection.php.class.implements.solely.traversable.inspection.display.name=클래스가 Traversable을 직접 구현하지 못함
inspection.php.array.used.only.for.write.inspection.display.name=배열이 쓰기 액세스를 통해서만 사용됨
inspection.php.private.field.can.be.local.variable.inspection.display.name=private 프로퍼티가 로컬일 수 있음
inspection.php.foreach.variable.overwrite.already.defined.variable='foreach' 변수는 이미 정의된 변수를 덮어씁니다
inspection.php.inappropriate.inherit.doc.usage.inspection.display.name=부적절한 @inheritDoc 사용 위치
inspection.php.expression.with.same.operands.inspection.display.name=논리 표현식에 동일한 피연산자가 있음
inspection.php.traits.use.list.inspection.display.name=줄당 하나의 특성 use
inspection.php.long.type.form.inspection.display.name=짧은 타입 키워드 형식
inspection.php.compound.namespace.depth.inspection.display.name=복합 네임스페이스 깊이가 2수준 이상임
inspection.php.separate.else.if.inspection.display.name=Else if
inspection.php.new.class.missing.parameter.list.inspection.display.name=매개변수 목록 누락
inspection.php.var.usage.inspection.display.name=변수의 사용 위치
inspection.php.modifier.order.inspection.display.name=제어자 순서
inspection.php.missing.visibility.inspection.display.name=가시성 누락
inspection.php.parameter.by.ref.is.not.used.as.reference.inspection.display.name=불필요한 참조로 전달
inspection.php.accessed.array.is.always.empty=배열은 액세스 지점에서 항상 공백입니다
inspection.php.if.can.be.merged.with.sequential.condition='if'를 후속 조건과 병합할 수 있습니다
inspection.php.instanceof.is.always.true='instanceof'의 결과는 항상 'true'입니다.
inspection.php.in.array.can.be.replaced.with.comparison='in_array'를 비교로 바꿀 수 있습니다
inspection.php.func.get.arg.can.be.replaced.with.parameter.access='func_get_arg()' 호출을 매개변수 액세스로 바꿀 수 있음
inspection.php.format.function.call.with.single.argument=단일 인수를 가진 형식 함수 호출
inspection.php.invalid.instanceof.argument.type='instanceof'의 인수는 객체 또는 문자열이어야 합니다.
inspection.php.condition.always.evaluates.to.constant=조건은 항상 'true/false'로 평가됩니다
inspection.php.condition.checked.by.next.condition=후속 조건으로 확인되는 논리식 내부의 조건
inspection.php.array.write.access.is.not.used=배열 쓰기 액세스가 사용되지 않습니다
inspection.php.redundant.optional.argument=중복 optional 인수
inspection.php.property.only.written=프로퍼티 사용 위치에 동일한 액세스 권한이 있는지 여부
inspection.php.to.string.may.produce.exception='__toString'이 예외를 던질 수 있습니다
inspection.php.loop.never.iterates.name=루프가 반복되지 않습니다
inspection.php.loop.never.iterates=''{0}'' 문이 루프되지 않습니다
inspection.php.ternary.expression.can.be.replaced.with.condition.inspection.display.name=삼항식을 조건식과 바꾸기 가능
inspection.php.ternary.expression.can.be.replaced.with.short.version=삼항식을 짧은 버전으로 바꿀 수 있습니다
inspection.php.unnecessary.local.variable.inspection.display.name=불필요한 지역 변수
inspection.php.unnecessary.semicolon.inspection.display.name=불필요한 세미콜론
inspection.php.curly.brace.access.syntax.usage.inspection.display.name=중괄호 액세스 구문 사용 위치
inspection.php.single.statement.with.braces.inspection.display.name=중괄호가 있는 단일 구문 본문
inspection.php.statement.without.braces.inspection.display.name=중괄호가 없는 제어문 본문
inspection.php.str.functions.inspection.display.name='str*()' 호출을 PHP 8 'str_*()' 호출로 바꿀 수 있음
inspection.php.nested.ternary.expression.usage.inspection.display.name=중첩 삼항 연산자 사용 위치
inspection.php.doc.field.type.mismatch.inspection.display.name=타입이 프로퍼티의 선언된 타입과 일치하지 않음
inspection.php.switch.case.without.default.branch.inspection.display.name=default 브랜치가 없는 switch 문
inspection.php.strict.comparison.of.operands.with.different.types=호환되지 않는 피연산자의 엄격한 비교
inspection.php.suspicious.name.combination.inspection.name=의심스러운 이름 조합
inspection.php.duplicate.switch.case.body.inspection.display.name=switch 문의 중복 브랜치
inspection.php.duplicate.switch.catch.body.inspection.display.name='catch' 문 내 중복 브랜치
inspection.php.exception.is.immediately.rethrown=예외가 즉시 다시 던져짐
inspection.php.continue.targeting.switch='continue'가 'switch' 문을 대상으로 함
inspection.php.redundant.continue.break.argument=불필요한 'continue/break'인수
inspection.php.duplicate.match.arm.body.inspection.display.name='match' 식 내 중복 arm
inspection.php.field.assignment.type.mismatch.inspection.display.name=프로퍼티 대입의 타입 불일치
inspection.php.closure.can.be.converted.to.short.arrow.function.inspection.display.name=클로저를 화살표 함수로 변환할 수 있음
inspection.php.concatenation.with.arithmetic.usage=산술 사용 위치와 연결
inspection.php.parameter.always.have.same.value=매개변숫값이 항상 같습니다
inspection.php.method.return.value.is.never.used=메서드의 반환값이 한 번도 사용되지 않음
inspection.php.isset.can.be.replaced.with.coalesce='isset'을 병합으로 바꿀 수 있음
inspection.php.cast.is.unnecessary=형 변환이 불필요
inspection.php.unnecessary.curly.variable.syntax=변수의 불필요한 중괄호 구문
inspection.php.unpacked.argument.type.mismatch.inspection.display.name=압축 해제된 인수의 잘못된 타입
inspection.php.missing.return.type.inspection.display.name=반환 타입 선언 누락
inspection.php.missing.parameter.type.inspection.display.name=매개변수의 타입 선언 누락
inspection.php.missing.field.type.inspection.display.name=프로퍼티의 타입 선언 누락
inspection.php.expression.without.clarifying.parentheses.inspection.display.name=명확히 구분 짓는 소괄호가 없는 표현식
inspection.php.unnecessary.parentheses.inspection.display.name=불필요한 소괄호
inspection.php.method.may.be.static.inspection.display.name=메서드를 'static'으로 만들 수 있음
inspection.php.format.function.parameters.mismatch.inspection.display.name=형식 함수 매개변수 불일치
inspection.php.ignored.class.alias.declaration.display.name=무시된 클래스 별칭 선언
inspection.php.composer.duplicated.requirement.inspection.display.name=composer.json 내 중복 패키지 항목
inspection.php.not.installed.packages.inspection.display.name=설치되지 않은 Composer 패키지
inspection.php.disabled.quality.tool.composer.inspection.display.name=품질 도구 검사가 비활성화됨
inspection.php.composer.extension.stubs.inspection.display.name=composer.json에서 확장 누락
inspection.php.disabled.extension.stubs.inspection.display.name=비활성화된 확장 스텁
inspection.php.array.fill.can.be.converted.to.loop.inspection.display.name='array_fill'을 루프로 변환 가능
inspection.php.loop.can.be.converted.to.array.fill.inspection.display.name=루프를 'array_fill()' 호출로 변환 가능
inspection.php.get.class.can.be.replaced.with.class.name.literal.inspection.display.name='get_class()' 호출을 '::class'로 바꿀 수 있음
inspection.php.array.filter.can.be.converted.to.loop.inspection.display.name='array_filter()' 호출을 루프로 변환 가능
inspection.php.loop.can.be.converted.to.array.filter.inspection.display.name=루프를 'array_filter()' 호출로 변환 가능
inspection.php.loop.can.be.converted.to.array.map.inspection.display.name=루프를 'array_map()' 호출로 변환 가능
inspection.php.array.map.can.be.converted.to.loop.inspection.display.name='array_map()' 호출을 루프로 변환 가능
inspection.php.short.open.tag.inspection.display.name=짧은 여는 태그 사용 위치
inspection.php.constructor.style.inspection.display.name=예전 스타일의 생성자
inspection.php.assignment.replaceable.with.prefix.expression.inspection.display.name=대입을 증분 또는 감소로 바꿀 수 있음
inspection.php.assignment.replaceable.with.operator.assignment.inspection.display.name=대입을 연산자 대입으로 바꿀 수 있습니다
inspection.php.invalid.magic.method.modifiers.inspection.display.name=잘못된 매직 메서드 제어자
inspection.php.incorrect.magic.method.signature.inspection.display.name=잘못된 매직 메서드 시그니처
inspection.php.array.access.on.illegal.type.display.name=잘못된 타입에서의 배열 오프셋 액세스
inspection.php.parameter.name.chaged.during.inhertiance=매개변수 이름이 상속 도중 변경됨
inspection.php.named.argument.may.be.unresolved=이름이 지정된 인수는 해결되지 않을 수 있습니다
inspection.php.argument.without.name.identifier=이름 식별자가 없는 인수
inspection.php.named.argument.usage=이름 식별자가 있는 인수
inspection.php.named.arguments.with.changed.order=이름 지정된 인수의 순서가 매개변수의 순서와 일치하지 않습니다
inspection.php.mixed.return.type.can.be.reduced='mixed' 반환 타입을 좁힐 수 있음
inspection.php.null.is.not.compatible.with.parameter='null'이 매개변수의 선언된 타입과 호환되지 않음
inspection.php.nested.dirname.call.can.be.replaced.with.levels.usage=중첩된 'dirname()' 호출을 'levels' 매개변수 사용으로 바꿀 수 있음
inspection.php.trait.method.use.is.located.inside.different.target.class=포함 클래스가 다른 메서드에 해결되어 있는 특성 use 규칙 
inspection.php.trait.usage=특성 사용이 허용되지 않음
inspection.php.class.cant.be.used.as.attribute=클래스를 속성으로 사용할 수 없음
inspection.php.redundant.match.expression='match' 식은 default arm만 포함하므로 단순화되어야 함
inspection.php.loop.can.be.replaced.with.str.repeat=루프를 'str_repeat'으로 바꿀 수 있음
inspection.php.concatenation.with.empty.string.can.be.merged=빈 문자열로의 연결을 대입과 병합할 수 있음
inspection.php.match.expression.can.be.replaced.with.ternary='match' 식을 삼항식으로 바꿀 수 있음
inspection.php.switch.can.be.replaced.with.match.expression='switch'를 'match' 식으로 바꿀 수 있음
inspection.php.inapplicable.attribute.target.declaration=적용할 수 없는 속성 대상 선언
inspection.php.expected.values.should.be.used=기댓값 사용 필요
inspection.php.immutable.property.is.written.in.invalid.scope=잘못된 범위에 작성된 불변 프로퍼티
inspection.php.attribute.is.not.repeatable=반복할 수 없는 속성
inspection.php.attribute.no.return.can.be.added=NoReturn 속성을 추가할 수 있습니다
inspection.php.pure.contract.attribute.can.be.added='#[Pure]' 속성을 추가할 수 있습니다
inspection.php.pure.function.may.produce.side.effect=순수 함수가 부수 효과를 일으킬 수 있습니다
inspection.php.attribute.array.shape.can.be.added='#[ArrayShape]' 속성을 추가할 수 있습니다
inspection.php.attribute.can.be.overridden=속성을 재정의 멤버에 추가할 수 있습니다 
inspection.php.array.key.does.not.match.array.shape=배열 키가 배열 모양에 대응하지 않습니다 
inspection.php.missing.strict.types.declaration.inspection.display.name=엄격한 타입 선언 누락
inspection.php.incompatible.return.type.inspection.display.name=호환되지 않는 반환 타입
inspection.php.strict.type.checking.inspection.display.name=엄격한 타입 검사 규칙 위반
inspection.php.non.canonical.elements.order.inspection.display.name=요소의 비표준 순서
inspection.php.null.safe.operator.can.be.used=nullsafe 연산자 '?->' 사용 가능
inspection.php.variable.variable.inspection.display.name=가변 변수의 사용 위치
inspection.php.traditional.syntax.array.literal.inspection.display.name=기존 구문 배열 리터럴이 탐지됨
inspection.php.illegal.psr.class.path.inspection.display.name=클래스 경로가 프로젝트 구조와 일치하지 않음
inspection.php.multiple.classes.declarations.in.one.file.display.name=한 파일 내 여러 개의 클래스 선언
inspection.php.redundant.catch.clause.inspection.display.name=중복 catch 절
inspection.php.unhandled.exception.inspection.display.name=처리되지 않은 예외
inspection.php.non.strict.object.equality.inspection.display.name=엄격하지 않은 객체 상등
inspection.php.duplicate.case.inspection.display.name=switch 문의 중복 case
inspection.php.duplicate.match.condition.inspection.display.name=중복 조건
inspection.php.unused.match.arm.condition.inspection.display.name=사용되지 않는 'match' 조건
inspection.php.comment.will.be.parsed.as.attribute=주석은 PHP 8.0에서 속성으로 분석됨
inspection.php.redundant.attribute.parenthesis=속성 내 불필요한 소괄호
inspection.php.fully.qualified.name.usage.inspection.display.name=정규화된 이름 사용 위치
inspection.php.unnecessary.fully.qualified.name.inspection.display.name=불필요한 정규화된 이름
inspection.mess.detector.validation.inspection.display.name=PHP Mess Detector 유효성 검사
inspection.php.CS.fixer.validation.inspection.display.name=PHP CS Fixer 유효성 검사
inspection.php.CS.validation.inspection.display.name=PHP_CodeSniffer 유효성 검사
inspection.php.usage.of.silence.operator.inspection.display.name=사일런스 연산자의 사용 위치
inspection.php.useless.trailing.comma.inspection.display.name=불필요한 후행 쉼표
inspection.php.useless.trailing.comma.inspection.desc=불필요한 후행 쉼표
inspection.php.remove.useless.trailing.comma=불필요한 후행 쉼표 제거
inspection.php.add.line.break.after.trailing.comma=후행 쉼표 뒤에 줄 바꿈 추가
inspection.php.foreach.array.is.used.as.value.inspection.display.name=foreach 배열이 값으로 사용됨
inspection.php.foreach.nested.outer.key.value.variables.conflict.inspection.display.name=중첩 및 외부 'foreach' 변수의 충돌
inspection.php.missing.break.statement.inspection.display.name='break' 문 누락
inspection.php.unit.covers.by.access.modifier.is.deprecated.inspection.display.name=액세스 제어자 어노테이션에의한 @covers/@uses는 더 이상 사용되지 않음
inspection.php.unit.expected.exception.doc.tag.is.deprecated.inspection.display.name=doc 태그를 통한 예외 처리는 더 이상 사용되지 않음
inspection.php.unit.deprecated.expect.exception.inspection.display.name=expectException은 더 이상 사용되지 않음
inspection.php.unit.assert.array.has.key.inspection.display.name=메서드 'assertArrayHasKey/assertArrayNotHasKey'를 대신 사용 가능
inspection.php.unit.misordered.assert.equals.arguments.inspection.display.name=잘못 정렬된 PHPUnit 상등 어설션 메서드 인수
inspection.php.unit.assert.count.inspection.display.name=assertEquals 대신 'assertCount/assertSameSize' 메서드 사용
inspection.php.unit.assert.contains.inspection.display.name='assertContains/assertNotContains'는 곧 사용할 수 없게 됨
inspection.php.unit.assert.can.be.replaced.with.fail=어설션을 'fail'로 바꿀 수 있습니다
inspection.php.unit.assert.empty.inspection.display.name=어설션을 'assertEmpty/assertNotEmpty'로 바꿀 수 있음
inspection.php.unit.assert.file.equals.inspection.display.name='assertFileEquals/assertStringEqualsFile'은 곧 사용할 수 없게 됨
inspection.php.unit.assert.equals.inspection.display.name='assertEquals/assertNotEquals'는 곧 사용할 수 없게 됨
inspection.php.unit.covers.function.without.scope.resolution.operator.inspection.display.name=포함된 함수 참조가 '::' 없이 제공됨
inspection.php.unit.undefined.data.provider.inspection.display.name=정의되지 않은 PHPUnit 데이터 제공자
inspection.php.unit.missing.target.for.test.inspection.display.name=PHPUnit 테스트의 대상 요소 누락
inspection.php.constant.naming.convention.inspection.display.name=상수 이름이 코딩 규칙을 준수하지 않음
inspection.php.variable.naming.convention.inspection.display.name=변수 이름이 코딩 규칙을 준수하지 않음
inspection.php.property.naming.convention.inspection.display.name=프로퍼티 이름이 코딩 규칙을 준수하지 않음
inspection.php.method.naming.convention.inspection.display.name=메서드 이름이 코딩 규칙을 준수하지 않음
inspection.php.function.naming.convention.inspection.display.name=함수 이름이 코딩 규칙을 준수하지 않음
inspection.php.class.naming.convention.inspection.display.name=클래스 이름이 코딩 규칙을 준수하지 않음
inspection.php.overriding.method.visibility.inspection.display.name=메서드 가시성은 재정의할 수 없음
inspection.php.method.or.class.call.is.not.case.sensitive.inspection.display.name=메서드 호출 또는 클래스 사용 위치 내 대/소문자 불일치
inspection.php.expression.result.unused.inspection.display.name=표현식 결과가 사용되지 않음
inspection.php.throwable.not.thrown.inspection.display.name=Throwable이 던져지지 않음
inspection.php.void.function.result.used.inspection.display.name=void 함수 결과가 사용됨
inspection.php.redundant.closing.tag.inspection.display.name=불필요한 닫는 태그
inspection.php.too.many.parameters.inspection.display.name=함수 선언 내 너무 많은 매개변수
inspection.php.method.parameters.count.mismatch.inspection.display.name=매개변수 수가 선언과 불일치
inspection.php.inconsistent.return.points.inspection.display.name=일관되지 않은 반환점
inspection.php.redundant.variable.doc.type.inspection.display.name=@var 태그 중복
inspection.php.doc.redundant.throws.inspection.display.name=@throws 태그 중복
inspection.php.doc.missing.throws.inspection.display.name=@throws 태그 누락
inspection.php.redundant.doc.comment.inspection.display.name=불필요한 PHPDoc 주석
inspection.php.doc.signature.inspection.display.name=PHPDoc 주석이 함수/메서드 시그니처와 일치합니다
inspection.php.doc.is.not.complete.inspection.display.name=PHPDoc 주석 시그니처가 완전하지 않음
inspection.php.return.doc.type.mismatch.inspection.display.name=PHPDoc 주석 내 반환 타입이 실제 반환 타입과 일치하지 않음
inspection.php.illegal.string.offset.inspection.display.name=잘못된 문자열 오프셋
inspection.php.illegal.array.key.type.inspection.display.name=잘못된 배열 키 타입
inspection.php.silly.assignment.inspection.display.name=불필요한 대입
inspection.php.missing.doc.comment.inspection.display.name=PHPDoc 주석 누락
inspection.php.unused.parameter.inspection.display.name=사용되지 않는 매개변수
inspection.php.wrong.foreach.argument.type.inspection.display.name='foreach()'에 제공된 잘못된 인수
inspection.php.division.by.zero.inspection.display.name=0으로 나누기
inspection.php.assignment.in.condition.inspection.display.name=조건 내 대입
inspection.php.wrong.catch.clauses.order.inspection.display.name=잘못된 catch 절 순서
inspection.php.wrong.string.concatenation.inspection.display.name=잘못된 문자열 연결
inspection.php.constant.reassignment.inspection.display.name=상수 재대입
inspection.php.non.compound.use.inspection.display.name=불필요한 구문 사용
inspection.php.to.string.implementation.inspection.display.name=메서드 '__toString' 구현
inspection.php.to.string.return.inspection.display.name=메서드 '__toString' 반환 타입
inspection.php.internal.entity.used.inspection.display.name=내부 엔티티의 사용
inspection.php.deprecated.implode.usage.inspection.display.name='implode/join'은 곧 사용할 수 없게 됨
inspection.php.expression.always.null.inspection.display.name=표현식이 항상 'null'입니다.
inspection.php.deprecated.cast.inspection.display.name=곧 사용할 수 없게 될 형 변환
inspection.php.define.constant.name.with.leading.slash=선행 슬래시로 상수 이름이 정의됨
inspection.php.define.constant.can.be.replaced.with.const.syntax=상수 이름 정의는 'const' 구문으로 바꿀수 있습니다
inspection.php.element.is.not.available.in.current.php.version.inspection.display.name=구성된 PHP 버전에서 요소를 사용할 수 없음
inspection.php.deprecation.inspection.display.name=중단된 기능
inspection.php.plural.mixed.can.be.replaced.with.array='mixed' 타입을 'array'로 바꿀 수 있습니다
inspection.php.language.level.inspection.display.name=언어 수준
inspection.php.unused.field.default.value.inspection.display.name=중복 프로퍼티 초기화
inspection.php.unused.alias.inspection.display.name=사용하지 않는 import
inspection.php.unused.local.variable.inspection.display.name=사용되지 않는 지역변수
inspection.php.write.access.to.referenced.array.value.without.unset='unset' 없이 참조된 배열 값에 대한 쓰기 액세스
inspection.php.boolean.expression.can.be.simplified=bool 표현식을 단순화할 수 있음
inspection.array.access.can.be.replaced.with.foreach.value=배열 액세스를 'foreach' 값으로 바꿀 수 있습니다
inspection.php.unused.private.field.inspection.display.name=사용되지 않는 private 프로퍼티
inspection.php.unused.private.method.inspection.display.name=사용되지 않는 private 메서드
inspection.php.goto.into.loop.inspection.display.name=루프 문으로 이동
inspection.php.pass.by.ref.inspection.display.name=참조로 매개변수 전달
inspection.php.optional.before.required.parameters.inspection.display.name=필수 매개변수 앞에 선택적 매개변수
inspection.php.params.inspection.display.name=매개변수 타입
inspection.php.include.inspection.display.name=해결되지 않은 Include
inspection.php.undefined.constant.inspection.display.name=정의되지 않은 상수
inspection.php.undefined.field.inspection.display.name=정의되지 않은 프로퍼티
inspection.php.statement.has.empty.body.inspection.display.name=본문이 비어 있는 구문
inspection.php.missing.parent.call.magic.inspection.display.name=매직 메서드에 대한 상위 호출 누락
inspection.php.missing.parent.call.common.inspection.display.name=메서드에 대한 상위 호출 누락
inspection.php.missing.parent.constructor.inspection.display.name=생성자에 대한 상위 호출 누락
inspection.php.undefined.class.constant.inspection.display.name=정의되지 않은 클래스 상수
inspection.php.super.class.incompatible.with.interface.inspection.display.name=상위 클래스의 메서드 선언이 구현된 인터페이스와 호환되지 않음
inspection.php.signature.mismatch.during.inheritance.inspection.display.name=재정의된 메서드의 선언은 상위 클래스와 호환되어야 함
inspection.php.abstract.static.method.inspection.display.name=static 함수가 추상이어서는 안 됨
inspection.php.static.as.dynamic.method.call.inspection.display.name=static 메서드가 dynamic으로서 호출됨
inspection.php.dynamic.as.static.method.call.inspection.display.name=dynamic 메서드가 static으로서 호출됨
inspection.php.possible.polymorphic.invocation.inspection.display.name=잠재적인 다형성 호출
inspection.php.promoted.field.usage=승격된 프로퍼티 사용 위치
inspection.field.can.be.promoted=프로퍼티를 승격할 수 있음
inspection.php.redundant.assignment.to.promoted.field=승격된 프로퍼티로의 불필요한 대입
inspection.php.undefined.callback.inspection.display.name=정의되지 않은 콜백
inspection.php.undefined.function.inspection.display.name=정의되지 않은 함수
inspection.php.undefined.class.inspection.display.name=정의되지 않은 클래스
inspection.php.multiple.class.declarations.inspection.display.name=다중 클래스 선언
inspection.php.undefined.namespace.inspection.display.name=정의되지 않은 네임스페이스
inspection.php.undefined.method.inspection.display.name=정의되지 않은 메서드
inspection.php.undefined.variable.inspection.display.name=정의되지 않은 변수
inspection.php.undefined.goto.label.inspection.display.name=정의되지 않은 라벨
inspection.php.group.undefined=정의되지 않은 심볼
inspection.php.group.probable.bugs=발생할 수 있는 버그
inspection.php.group.general=일반
inspection.php.group.strict.standards=PHP Strict 표준
inspection.php.group.type.compatibility=타입 호환성
inspection.php.group.control.flow=제어 흐름
inspection.php.group.code.smell=코드 스멜
inspection.php.group.psr.12=PSR-12
inspection.php.group.phpdoc=PHPDoc
inspection.php.group.code.style=코드 스타일
inspection.php.group.composer=Composer
inspection.php.group.unused=사용하지 않는 심볼
inspection.php.group.naming.conventions=이름 지정 규칙
inspection.php.group.phpunit=PHPUnit
inspection.php.group.quality.tools=품질 도구
inspection.php.group.replacable.assignments=바꾸기 가능한 대입
inspection.php.group.error.handling=오류 처리
inspection.php.group.attributes=속성
list.item.update.phpdoc.comment=PHPDoc 주석 업데이트
inspection.php.unnecessary.return.inspection.display.name=불필요한 'return/continue' 문
inspection.php.unnecessary.else.inspection.display.name=불필요한 'else' 브랜치
inspection.php.unnecessary.return.function=함수의 마지막 구문으로서 'return'은 불필요합니다
inspection.php.unnecessary.return.method=메서드의 마지막 구문으로서 'return'은 불필요합니다
inspection.php.unnecessary.continue=루프 안의 마지막 구문으로서 'continue'는 불필요
php.unit.create.target.method.quick.fix.family.name=누락된 대상 메서드 생성
inspection.php.missing.return.type.description=함수의 반환 타입 선언이 누락되었습니다.
inspection.php.missing.param.type.description=매개변수 타입 선언이 누락되었습니다
quickfix.php.missing.param.type.description=''{0}''을(를) 매개변수 타입으로 추가합니다
quickfix.php.missing.param.type.batch.description=추론 타입을 매개변수 타입으로서 추가
php.add.method.declaration.quick.fix.text=메서드 추가
php.add.tag.base.quick.fix.family.name={0} 태그 추가
inspection.php.unused.field.default.value.description=프로퍼티 이니셜라이저가 중복되었습니다.
php.change.function.signature.manually.quick.fix.family.name=시그니처를 수동으로 변경
php.change.function.signature.from.usage.quick.fix.family.name=사용 위치에서 함수 시그니처 변경
searching.for.usages=사용 위치 검색 중…
php.replace.with.local.variable.quick.fix.family.name=프로퍼티를 지역 변수로 바꾸기
inspection.php.private.field.can.be.local.variable.description=프로퍼티를 지역 변수로 바꿀수 있습니다.
inspection.php.abstract.static.method.description=PHP Strict 표준: static 메서드 '#ref'이(가) 추상이어서는 안 됩니다.
php.replace.argument.with.cast.quick.fix.family.name=인수를 {0}(으)로 형 변환
php.change.cast.operation.quick.fix.family.name=형 변환을 {0}(으)로 변경
php.replace.with.null.quick.fix.family.name='null'로 바꾸기
inspection.php.expression.always.null.description='#ref'이(가) 항상 'null'입니다.
inspection.unnecessary.static.reference=final 클래스 내 불필요한 'static'
inspection.unnecessary.string.cast=문자열로의 불필요한 형 변환
inspection.unnecessary.bool.cast=불필요한 부울로의 형 변환
php.configure.extensions.quick.fix.family.name=확장 스텁 구성
php.enable.extension.quick.fix.family.name=확장 스텁 활성화
php.enable.extension.quick.fix.text=''{0}'' 확장 스텁을 활성화합니다.
inspection.php.disabled.extension.stubs.description=''{0}'' 확장 스텁을 비활성화합니다.
inspection.php.unnecessary.semicolon.description=;이 불필요합니다.
inspection.php.inappropriate.inherit.doc.usage.description=doc 주석을 가진 상위 멤버가 없는 멤버에 대해 @inheritDoc이 사용됨
inspection.php.inappropriate.inherit.doc.usage.description2=@inheritDoc는 클래스 멤버에서만 사용되어야 합니다.
php.inline.variable.quick.fix.family.name=변수 인라인화
update.php.doc.type.family.name=PHPDoc 타입을 업데이트합니다.
update.php.doc.type.comment=''{0}''(으)로 바꾸기
inspection.php.return.doc.type.mismatch=PHPDoc 내 반환 타입이 실제 반환 타입과 일치하지 않음
inspection.php.doc.signature.description=인수 PHPDoc가 중복되었습니다.
inspection.php.doc.signature.description2=반환 타입이 선언된 타입과 일치하지 않습니다.
inspection.php.doc.signature.description3=존재하지 않는 인수에 대한 PHPDoc입니다.
inspection.php.doc.signature.description5=인수 타입이 선언된 타입과 일치하지 않습니다.
php.flip.variable.and.type.quick.fix.family.name=변수 및 타입 반전
inspection.php.non.canonical.elements.order.description=변수 및 해당 타입이 비표준 순서로 나열되어 있습니다.
php.make.class.abstract.quick.fix.family.name=클래스를 abstract로 설정
php.remove.doc.tag.quick.fix.family.name={0} 제거
php.make.method.non.final.quick.fix.family.name=메서드를 비 final로 설정
inspection.php.short.open.tag.description=짧은 여는 태그 사용 위치
php.make.method.non.static.quick.fix.family.name=메서드를 비 static으로 설정
php.flip.arguments.quick.fix.family.name=첫 번째 및 두 번째 인수 반전
inspection.php.unused.alias.description=import 문 '#ref'은(는) 불필요합니다.
inspection.php.unused.alias.description2=import 문 '#ref'이(가) 한 번도 사용되지 않습니다.
php.rename.wrong.reference.quick.fix.family.name=참조 이름 변경
php.append.doc.static.fix.family.name=함수 참조 앞에 '::' 추가
inspection.php.include.description=표현식 ''{0}''의 대상을 해결할 수 없습니다.
inspection.php.include.description2=경로 ''{0}''을(를) 찾을 수 없습니다.
make.call.dynamic.quick.fix.family.name=호출을 dynamic으로 설정
inspection.php.undefined.class.description=클래스 '#ref'의 정의가 여러 개 있습니다.
inspection.php.undefined.class.description2=클래스 '#ref'은(는) 정의되지 않았습니다.
inspection.php.undefined.class.description5=클래스 '#ref'의 다른 선언이 있습니다.
php.dead.code.entries=PHP 불필요한 코드 항목
inspection.php.redundant.variable.doc.type.description=@var 태그가 소스 코드에서 이미 추론된 타입을 지정합니다.
php.remove.all.unused.parameters.quick.fix.text=사용되지 않는 매개변수를 모두 제거합니다.
transform=변환
remove=제거
php.remove.unused.local.variable.without.successor.quick.fix.family.name=변수 ''{0}'' 제거
php.replace.with.float.cast.quick.fix.family.name='(float)' 형 변환으로 바꾸기
php.create.data.provider.quick.fix.family.name=데이터 공급자 생성
inspection.php.undefined.namespace.description=네임스페이스 '#ref'이(가) 정의되지 않았습니다.
fix.not.available=수정할 수 없습니다.
php.unit.create.target.class.quick.fix.family.name=누락된 대상 클래스 생성
initialize.var.quick.fix.family.name=값으로 초기화
inspection.php.statement.has.empty.body.description=구문의 본문이 비어 있습니다.
php.replace.with.interface.quick.fix.family.name={0}(으)로 바꾸기
remove.redundant.suppression.quick.fix.family.name=''{0}'' 억제 제거
php.change.method.modifiers.quick.fix.family.name=제어자 변경
php.change.method.modifiers.quick.fix.text=제어자를 제거합니다
php.remove.statement.fix.family.name=제거
php.make.method.non.abstract.quick.fix.family.name=메서드를 비 abstract로 설정
replace.plus.asgn.to.concat.asgn.quick.fix.family.name='+='를 '.='로 바꾸기
replace.plus.to.concat.quick.fix.family.name='+'를 '.'로 바꾸기
replace.with.0={0}(으)로 바꾸기
php.remove.ref.from.function.declaration.quick.fix.family.name=함수 선언에서 '&' 제거
php.remove.ref.from.assignment.quick.fix.family.name='=\\&'를 '='로 바꾸기
php.remove.pass.by.ref.from.parameter.quick.fix.family.name=매개변수에서 '&' 제거
inspection.php.pass.by.ref.description=변수만 참조로 반환할 수 있습니다.
php.non.strict.object.equality.quick.fix.text=동일성 비교로 바꿉니다.
php.add.field.declaration.quick.fix.text=프로퍼티 추가
quick.fix.error=빠른 수정 오류
the.original.class.0.does.not.belong.to.the.project.and.cannot.be.modified=원본 클래스 {0} 은(는) 프로젝트에 속해 있지 않아\n\
수정할 수 없습니다.
add.constant.declaration.quick.fix.text=상수를 추가합니다.
constant.ref.not.found.in={0}에서 상수 ''#ref''을(를) 찾을 수 없습니다
php.remove.parameters.quick.fix.text=사용되지 않는 매개변수 제거
replace.extends.implements='extends'/'implements' 바꾸기
inspection.php.undefined.class.other.declaration.exists=클래스 ''#ref''의 다른 선언이 {0}에 있습니다.
inspection.php.undefined.class.other.declaration.exists.and=클래스 ''#ref''의 다른 선언이 {0} 및 {1} 등에 있습니다.
show.implementations.for.0={0}의 구현
show.super.types.for.0={0}의 상위 타입 표시
display.name.directory.0=디렉터리 ''{0}''
hint.text.element.doesn.t.have.fqn=요소에 FQN이 없습니다
instanceof.is.always.true={0}이(가) {1}의 계층 구조에 이미 있습니다.
dialog.message.server.host.cannot.be.empty=서버 호스트는 비워둘 수 없습니다.
dialog.message.port.cannot.be.negative.number=포트 번호는 음수일 수 없습니다
dialog.message.query.string.cannot.start.with=쿼리 문자열은 '?'로 시작할 수 없습니다
inspection.message.code.fragment.too.complex.to.parse.this.piece.code.will.be.treated.as.plain.text=코드 조각이 너무 복잡해서 분석할 수 없으므로 일반 텍스트로 취급됩니다
inspection.message.control.flow.too.big.to.analyze=제어 흐름이 너무 커서 분석할 수 없습니다.
remove.variable=변수 제거
annotator.fix.remove=''{0}'' 제거
inspection.message.class.may.inherit.from.final.class=클래스는 final 클래스에서 상속할 수 없습니다.
inspection.message.key.element.cannot.be.reference=키 요소는 참조일 수 없습니다.
inspection.message.absolute.method.reference.should.be.specified.for.insteadof.trait.use.rule=절대 메서드 참조는 'insteadof' 특성 use 규칙에 대해 지정되어야 합니다.
inspection.message.generators.may.only.declare.return.type.generator.iterator.or.traversable.or.iterable.permitted=제너레이터는 ''Generator'', ''Iterator'', ''Traversable'' 또는 ''iterable''의 반환 타입만 선언할 수 있습니다. {0}은(는) 허용되지 않습니다
find.usages.button.base.method=기본 메서드
find.usages.button.current.method=현재 메서드
find.usages.prompt.dialog.implements=클래스 ''{1}''의 메서드 ''{0}()''이(가) ''{2}''에서 {3,choice,0#메서드|1#메서드}를 구현합니다.\n\
기본 {3,choice,0#메서드|1#메서드}의 사용 위치를 검색하시겠어요?
find.usages.prompt.dialog.overrides=클래스 ''{1}''의 메서드 ''{0}()''이(가) ''{2}''에서 {3,choice,0#메서드|1#메서드}를 재정의합니다.\n\
기본 {3,choice,0#메서드|1#메서드}의 사용 위치를 검색하시겠어요?
more.actions=액션 더보기…
show.log.of.composer.related.actions=Composer 관련 액션 로그 표시
show.log=로그 표시
members.to.report=보고할 멤버
entry.points=진입점
constructors=생성자
inspection.message.type.mismatch.should.be.conditional.expression=타입 불일치: 조건식이어야 합니다.
filetype.doctrine.query.description=Doctrine 쿼리 언어
inspection.php.typed.property.might.be.uninitialized.inspection.display.name=타입 지정된 프로퍼티가 초기화되지 않을 수 있습니다
inspection.php.typed.property.might.be.uninitialized.inspection.problem=타입 지정된 프로퍼티 ''{0}''이(가) 초기화되지 않을 수 있습니다
inspection.message.primitive.types.can.t.be.used.as.instanceof.argument=객체 또는 문자열만 ''instanceof''인수로서 사용되어야 합니다. 현재: ''{0}''
another.definition.with.same.name.exists.in.this.file=이 파일에 이름이 같은 다른 정의가 있습니다.
method.with.same.name.already.defined.in.this.class=이름이 동일한 메서드가 이 클래스에 이미 정의되어 있습니다
global.code.should.be.enclosed.in.global.namespace.declaration=전역 코드는 전역 네임스페이스 선언으로 둘러싸야 합니다.
static.property.cannot.be.unset=static 속성은 unset일 수 없습니다.
the.yield.expression.can.only.be.used.inside.a.function='yield' 표현식은 함수 내에서만 사용할 수 있습니다.
multiple.modifiers.are.not.allowed=여러 개의 제어자는 허용되지 않습니다
access.type.for.interface.member.must.be.omitted=인터페이스 멤버에 대한 액세스 타입은 생략되어야 합니다.
final.modifier.is.not.allowed.here='Final' 제어자는 여기에서 허용되지 않습니다
fields.cannot.be.declared.final=프로퍼티는 final로 선언할 수 없습니다
abstract.modifier.is.not.allowed.here='Abstract' 제어자는 여기에서 허용되지 않습니다
fields.cannot.be.declared.abstract=프로퍼티는 abstract로 선언할 수 없습니다
static.modifier.is.not.allowed.here='Static' 제어자는 여기에서 허용되지 않습니다
jump.into.a.finally.block.is.disallowed='finally' 블록으로 이동하는 것은 허용되지 않습니다
cannot.use.static.as.function.return.type.declaration='static'은 클래스 범위 밖에서 반환 타입 선언으로 허용되지 않습니다
void.type.cannot.be.nullable=void 타입은 null 가능할 수 없습니다.
can.only.be.used.as.standalone.type={0}은(는) 독립실행형으로만 사용할 수 있습니다
void.can.only.be.used.as.return.type=Void는 반환 타입으로만 사용할 수 있습니다
static.is.not.allowed.in.parameter.type.declaration='static'은 매개변수 타입 선언에서 허용되지 않습니다.
cannot.use.this.as.parameter=$this을(를) 매개변수로 사용할 수 없습니다.
only.the.last.parameter.can.be.variadic=마지막 매개변수만 가변일 수 있습니다
expression.is.not.allowed.as.parameter.default.value=표현식은 매개변수 디폴트 값으로 허용되지 않습니다.
argument.passed.must.be.of.the.type.0.1.given=전달된 인수는 타입 {0}이어야만 하지만 {1}이(가) 제공되었습니다.
variadic.parameter.cannot.have.a.default.value=가변 매개변수는 디폴트 값을 가질 수 없습니다
only.simple.expressions.are.allowed=단순한 표현식만 허용됩니다.
target.trait.should.be.specified=대상 특성을 지정해야 합니다.
call.to.0.1.construct.from.invalid.context=잘못된 컨텍스트에서 ''{0} {1}::__construct()'' 호출
constants.defined.using.the.const.keyword.must.be.declared.at.the.top.level.scope='const' 키워드를 사용하여 정의된 상수는 최상위 범위에서 선언되어야 합니다
expression.is.not.allowed.as.constant.value=표현식은 상수 값으로 허용되지 않습니다
cannot.redeclare.constant.0=상수 ''{0}''을(를) 다시 선언할 수 없습니다
expression.is.not.allowed.as.field.default.value=표현식은 필드 디폴트 값으로 허용되지 않습니다.
cannot.declare.self.referencing.constant=자기 참조 상수는 선언할 수 없습니다.
a.class.constant.must.not.be.called.class.it.is.reserved.for.class.name.fetching=클래스 상수의 이름을 'class'로 지정해서는 안 됩니다. 해당 이름은 클래스 이름을 가져올 때에 예약됩니다.
redefinition.of.parameters.is.not.allowed=매개변수 재정의는 허용되지 않습니다.
method.0.clone.cannot.accept.any.arguments=메서드 ''{0}::__clone()''에는 인수가 허용되지 않습니다
return.type.declaration.is.not.allowed=반환 타입 선언은 허용되지 않습니다.
method.should.not.be.finished.with=메서드는 ';'으로 끝내면 안 됩니다.
method.should.either.have.body.or.be.abstract=메서드는 본문이 있거나 abstract여야 합니다.
interface.method.can.t.have.body=인터페이스 메서드는 본문을 가질 수 없습니다
anonymous.function.expected=익명 함수가 필요합니다.
label.with.same.name.already.defined.in.current.scope=이름이 동일한 라벨이 현재 범위에 이미 정의되어 있습니다.
interfaces.may.not.include.member.variables=인터페이스는 멤버 변수를 포함할 수 없습니다.
0.with.same.name.already.defined.in.this.class=이름이 동일한 {0}이(가) 이 클래스에 이미 정의되어 있습니다
field=필드
cannot.redeclare.static.0.1.as.non.static.2.3=static ''{0}::${1}''은(는) 비 static ''{2}::${3}''(으)로서 다시 선언할 수 없습니다
cannot.redeclare.non.static.0.1.as.static.2.3=비 static ''{0}::${1}''은(는) static ''{2}::${3}''(으)로서 다시 선언할 수 없습니다
0.and.1.define.the.same.property.2=''{0}'' 및 ''{1}''이(가) 동일한 프로퍼티 ''{2}''을(를) 정의합니다
access.level.to.0.1.must.be.2.as.in.class.3.or.weaker=''{0}::${1}''에 대한 액세스 수준은 ''{2}''(클래스 ''{3}''와(과) 동일)이거나 약해야 합니다
access.level.to.0.1.must.be.2.as.in.class.3.or.weaker2=''{0}::{1}''에 대한 액세스 수준은 ''{2}''(클래스 ''{3}''와(과) 동일)이거나 약해야 합니다
cannot.inherit.previously.inherited.or.override.constant.0.from.interface.1=이전에 상속한 항목을 상속하거나 인터페이스 ''{1}''의 상수 ''{0}''을(를) 재정의할 수 없습니다
empty.implements.list=빈 구현 목록
a.trait.cannot.implement.an.interface=특성은 인터페이스를 구현할 수 없습니다.
class.cannot.implement.previously.implemented.interface=클래스는 이전에 구현된 인터페이스를 구현할 수 없습니다.
class.should.not.implement.itself=클래스는 자신을 구현해서는 안 됩니다.
empty.extends.list=빈 확장 목록
a.trait.cannot.extend.a.class=특성은 클래스를 확장할 수 없습니다.
interface.cannot.extend.previously.extended.interface=인터페이스는 이전에 확장된 인터페이스를 확장할 수 없습니다.
class.cannot.extend.from.trait=클래스는 특성으로부터 확장할 수 없습니다.
0.should.not.extend.itself={0} 은(는) 자신을 확장해서는 안 됩니다.
class=클래스
class.declarations.may.not.be.nested=클래스 선언은 중첩할 수 없습니다.
cannot.use.traits.inside.of.interfaces=특성은 인터페이스 내에서 사용할 수 없습니다.
trait.expected.class.found=특성이 필요한데 클래스가 발견되었습니다.
absolute.reference.is.not.allowed=절대 참조가 허용되지 않습니다.
cannot.use.0.as.lexical.variable=''${0}''을(를) 어휘적 변수로 사용할 수 없습니다
duplicate.variable.0=변수 ''{0}'' 중복
trailing.comma.is.not.allowed=후미 쉼표는 허용되지 않습니다.
the.use.keyword.must.be.declared.in.the.outermost.scope.of.a.file.the.global.scope.or.inside.namespace.declarations='use' 키워드는 파일의 최대 범위(전역 범위) 또는 네임스페이스 선언 내에서 선언되어야 합니다.
static.is.not.allowed.in.compile.time.constants='static::'은 컴파일 시간 상수에서 허용되지 않습니다
multiple.namespaces.in.a.file.should.use.same.preferably.braced.syntax=파일 내 여러 개의 네임스페이스는 동일한 구문(중괄호로 묶는 것이 좋음)을 사용해야 합니다.
no.content.allowed.before.namespace.declaration=네임스페이스 선언 앞에는 어떤 내용도 올 수 없습니다.
an.object.s.clone.method.cannot.be.called.directly=객체의 '__clone()' 메서드는 직접 호출할 수 없습니다
property.write=@property-write
property.read=@property-read
isset.only.works.with.variables.and.arrays=isset은 변수 및 배열과만 작동합니다.
cannot.use.positional.argument.after.argument.unpacking=인수 압출 해제 뒤에 위치 인수를 사용할 수 없습니다.
function.name.must.be.callable.a.string.closure.or.class.implementing.invoke.currently.0=함수 이름은 ''__invoke''를 구현하는 클래스 또는 문자열, 클로저처럼 호출 가능해야 하지만 현재 ''{0}''입니다
using.this.when.not.in.object.context=객체 컨텍스트가 아닐 경우, '$this' 사용
array.can.t.be.used.for.array.destructuring.assignment='array()'는 배열의 구조 분해 대입에 사용할 수 없습니다
function.call.is.not.allowed.here=함수 호출은 여기에서 허용되지 않습니다.
expression.is.not.assignable=표현식은 대입할 수 없습니다.
call.to.method.clone.from.invalid.context=잘못된 컨텍스트에서 메서드 '__clone' 호출
cannot.use.for.reading=읽기에 '[]'를 사용할 수 없습니다
it.s.not.possible.to.unpack.array.argument.by.reference=배열 인수를 참조로 압축 해제할 수 없습니다
spread.operators.in.arrays.are.not.supported.for.multiassignments.variables=배열 내 스프레드 연산자는 여러 개의 대입 변수에서 지원되지 않습니다
it.s.not.possible.to.unpack.array.value.with.associated.key=배열 값을 연결 키로 압축 해제할 수 없습니다
it.s.not.possible.to.unpack.array.key=배열 키를 압축 해제할 수 없습니다
cannot.use.empty.array.elements.in.arrays=배열에서 빈 배열 요소를 사용할 수 없습니다.
invalid.octal.literal.won.t.be.reported.by.php.but.will.work.incorrectly=잘못된 8진 리터럴: PHP에서 보고하지 않으나 올바르게 작동하지 않습니다
multiple.subsequent.underscores.in.a.numeric.literal.are.not.allowed=숫자 리터럴에서 여러 개의 연속 밑줄은 허용되지 않습니다.
expression.is.not.allowed.as.static.initializer=표현식은 static 이니셜라이저로서 허용되지 않습니다.
namespace.declarations.cannot.be.nested=네임스페이스 선언은 중첩할 수 없습니다.
global.namespace.should.use.braced.syntax=전역 네임스페이스는 중괄호로 묶인 구문을 사용해야 합니다.
halt.compiler.can.only.be.used.from.the.outermost.scope='__halt_compiler()'는 최대 범위에서만 사용할 수 있습니다
cannot.use.match.as.identifier='match'는 식별자로 사용할 수 없습니다. PHP 8.0 이후부터 예약된 키워드입니다
cannot.use.class.on.primitive.type='::class'는 객체에서만 허용됩니다
intention.name.replace.nullable.notation.with.null.as.part.union.type='?'를 공용체 타입의 일부로서 '|null'로 바꾸기
intention.name.replace.null.as.part.union.type.with.nullable.notation=공용체 타입의 일부로서의 '|null'을 '?'로 바꾸기
union.types.and.the.nullable.type.notation.cannot.be.mixed=공용체 타입 및 null 가능 타입 표기는 혼합할 수 없습니다.
union.types.mixed.cannot.be.nullable='null'이 이미 혼합 타입에 포함되어 있으므로 혼합 타입은 nullable이 될 수 없습니다
quick.fix.delete=''{0}''을(를) 삭제합니다.
is.duplicated.by.0=타입이 ''{0}''(으)로 중복됩니다.
intention.name.remove.duplicated.type=중복된 타입 제거
popup.title.select.reference.to.remove=제거할 타입 선택
intention.family.name.append=''{0}'' 뒤에 추가
intention.family.name.change.to.mixed=타입을 'mixed'로 변경
inspection.php.redundant.type.in.union.type=타입 선언이 중복되어 있으며 이를 단순화할 수 있습니다.
inspection.php.redundant.type.in.union.type.template=타입 선언을 ''{0}''(으)로 단순화할 수 있습니다.
inspection.php.redundant.type.in.union.type.fix.name=중복 타입을 단순화합니다.

inspection.message.always.true.because=''{1}''이(가) 이 지점에서 이미 ''{2,choice,0#false|1#true}''이므로 조건이 항상 ''{0,choice,0#false|1#true}''입니다
inspection.nullsafe.deref.unnecessary.because=이 지점에서 ''{1}''이(가) 이미 ''{2,choice,0#false|1#true}''이므로 nullsafe 연산자가 {0,choice,0#항상 ''null''을 생성합니다|1#불필요합니다}
inspection.nullsafe.deref.unnecessary.because.evaluated=이 지점에서 ''{1}''이(가) 평가되므로 nullsafe 연산자가 {0,choice,0#항상 ''null''을 생성합니다|1#불필요합니다}
inspection.message.always.true.because.evaluated=''{1}''이(가) 이 지점에서 평가되므로 조건이 항상 ''{0,choice,0#false|1#true}''입니다
hint.evaluation.makes.subsequent.condition.always.true=평가는 후속 조건을 항상 'true'로 만듭니다.
hint.evaluation.fully.contains=평가 결과에 ''{0}''의 가능한 결과가 모두 포함됩니다
hint.evaluation.makes.array.always.empty=평가 시 배열이 항상 공백이 됩니다
intention.family.name.navigate.to.cause=원인으로 이동
intention.family.name.replace.ternary.expression.with.true.branch=삼항식을 ''{0}'' 브랜치로 바꾸기
intention.family.name.replace.elseif.with.else='elseif'를 'else'로 바꾸기
extract.condition=조건 추출
delete.if='if' 삭제
delete.elseif='elseif' 삭제
action.show.in.log.text=로그에 표시
action.add.file.s.to.list.text=목록에 파일 추가
quality.tool.action.remove.file.s.from.list.text=목록에서 파일 제거
quality.tool.action.clean.list.text=목록 정리
quality.tool.border.title.ignored.files=무시된 파일
quality.tool.ignored.files={0} 무시된 파일
intention.family.name.remove.redundant.arguments=불필요한 {0,choice,0#인수|1#인수} 제거
inspection.message.redundant.argument={0,choice,0#인수|1#인수}가 {0,choice,0#매개변수|1#매개변수}의 디폴트 {0,choice,0#값|1#값}과 {0,choice,0#일치합니다|1#일치합니다}
plural.types.are.not.allowed.in.real.types=복수 타입은 doc 타입에서만 허용됩니다
intention.name.remove.brackets=대괄호 삭제
intention.name.replace.brackets.with.types='array'로 바꾸기
inspection.message.only.variables.can.be.passed.by.reference=변수만 참조로 전달할 수 있습니다
expression.0=표현식 {0}
expression=표현식
notification.content.language.level.was.changed.to.based.on.project.usage=언어 수준이 프로젝트에서 사용된 기능에 따라 {0}(으)로 설정되었습니다
action.revert.back.to.text={0}(으)로 되돌리기
expected.class.reference=필요 항목: 클래스 참조
expected.expression=필요 항목: 표현식
parser.unexpected=예기치 않은 항목: {0}
parser.expected=필요: {0}
namespace.cannot.start.with.namespace.due.to.conflict.with.ns.relative.names=네임스페이스가 ns 관련 이름과 충돌하여 "namespace"로 시작되지 않습니다
inspection.php.language.level.description='fn'은 PHP 7.4에서 예약된 키워드입니다
incorrect.null.safe.operator=올바르지 않은 nullsafe 연산자
replace.with.quest='?'로 바꾸기
required.parameters.missing=필수 매개변수 ''{0}''(이)가 누락되었습니다
parameter.ref.type.is.not.compatible.with.declaration=매개변수 '#ref' 타입이 선언과 호환되지 않습니다.
add.remote.interpreter=원격 인터프리터 추가
the.remote.hosts.access.plugin.is.missing.please.enable.the.plugin.in.0.plugins=Remote Hosts Access 플러그인이 없습니다. ''{0} | 플러그인''에서 플러그인을 활성화하세요.
extract.side.effect=부수 효과 추출
delete.unused.element=사용되지 않는 요소 삭제
suppress.all.for.file=파일에 대해 모두 억제
callers=호출자
callees=피호출자
call.tree=호출 트리
execution.statistics=실행 통계
suppress.for.method=메서드에 대해 억제
suppress.for.function=함수에 대해 억제
delete.redundant.switch.branch=불필요한 'switch' 브랜치 삭제
suppress.for.phpdoc.comment=PhpDoc 주석에 대해 억제
dynamically.declared.field=동적으로 선언된 필드
convert.closure.to.arrow.function=클로저를 화살표 함수로 변환
suppress.for.file=파일에 대해 억제
choose.a.valid.0.launcher=올바른 {0} 런처 선택
0.location={0} 위치
0.path={0} 경로:
configure=구성
file.0.does.not.exists=파일 {0}이(가) 없습니다
expressions=표현식
target=대상
creates.a.composer.json.file=composer.json 파일 생성
composer.json.file=composer.json 파일
implement.method=메서드 구현
split.elseif='else if' 문 분할
add.setter=setter 추가
php=PHP
filetype.php.description=PHP
remove.redundant.initializer=불필요한 이니셜라이저 제거
delete.assignment=대입 삭제
in.0=\ {0} 내
merge.nested.conditions=중첩된 조건 병합
replace.quotes=따옴표 바꾸기
variable.dereferenced=역참조된 변수
0.1={0}, {1}
declaration.in.parent.class.is.incompatible.with.interface=상위 클래스의 메서드 선언이 인터페이스와 호환되지 않습니다
copy.switch.branch='switch' 브랜치 복사
default=디폴트:
replace.if.with.switch='if'를 'switch'로 바꾸기
choose.an.alias.to.use=사용할 별칭 선택
update.signature.to.match.phpdoc.comment=PHPDoc 주석과 일치하도록 시그니처 업데이트
no.members.to.pull.up.found=위로 이동할 멤버를 찾을 수 없습니다
inject.language.using.phpdoc=PHPDoc를 사용하는 언어 삽입
negate.boolean.expression=bool 표현식 부정
no.members.to.push.down.found=아래로 이동할 멤버를 찾을 수 없습니다
replace.if.clause.with.ternary.expression=if 절을 삼항식으로 바꾸기
0.pushing.members.down.will.result.in.them.being.deleted={0}\n\
멤버를 아래로 이동하면 해당 멤버가 삭제됩니다
remove.pass.by.ref.sign='\\&' 제거
make.non.nullable=null 가능하지 않도록 설정
reference=참조
function=함수
foreach=foreach
while=while
0=\ ({0})
for=for
filetype.composer.log.description=Composer 로그
clear.log=로그 지우기
align.composer.log.console=Composer 로그 콘솔 정렬
all.0=모두({0})
choose.executable.class.to.run.0={0}을(를) 실행할 실행 파일 클래스 선택
show.settings=설정 표시
enable=활성화
composite.test.patterns=복합 테스트 패턴
add.test.class.method=테스트 클래스/메서드 추가…
empty.pattern=빈 패턴
ignore.imports.and.formatting=import 문 및 서식 지정 무시
sort.the.elements.by.visibility.public.protected.private=가시성별(public, protected, private) 요소 정렬
sort.by.visibility=가시성별 정렬
copy=복사
add=추가
replace.ternary.expression.with.if.clause=삼항식을 if 절로 바꾸기
information=정보
always.show.pass.by.reference=항상 참조로 전달 표시
show.name.for.all.arguments=모든 인수에 대해 이름 표시
composer.packages.versions=Composer 패키지 버전
constructor.field=생성자 필드
inspection.php.illegal.array.key.type.description={0} {1}
edit.template=템플릿 편집
remove.rule=규칙 제거
add.rule=규칙 추가
choose.super.class.or.interface=상위 클래스 또는 인터페이스 선택
choose.super.method=상위 메서드 선택
extends.implements.overrides=확장/구현/재정의
remove.unnecessary.semicolon=불필요한 세미콜론 제거
choose.properties=프로퍼티 선택
composer=composer
composer.executable='composer' 실행 파일
0.12={0}:{1}
label=라벨
namespace=네임스페이스
alias=별칭
constant=상수
field1=필드
class.constant=클래스 상수
function2=함수
method=메서드
class1=클래스
interface=인터페이스
parameter=매개변수
variable=변수
cancel=취소
do.not.override=재정의 안 함
override=재정의
method.name=메서드 이름
proceed=진행
add.custom.format.function=사용자 지정 형식 함수 추가…
02={0}::
add.class=클래스 추가…
all.exceptions.considered.checked=검사된 것으로 간주되는 모든 예외
html.note.core.extensions.are.part.of.the.php.core.and.cannot.be.left.out.of.a.php.binary.with.compilation.options.html=<html>참고: 코어 확장은 PHP 코어의 일부이므로, 컴파일 옵션을 사용해 PHP 바이너리에서 제외할 수 없습니다.</html>
choose.elements.to.generate.phpdoc.for=PHPDoc를 생성할 요소 선택
no.elements.to.generate.phpdoc.for=PHPDoc를 생성할 요소가 없습니다
invalid.class.name=잘못된 클래스이름
target.class=대상 클래스: 
03=({0})
constant.0=상수 {0}
usage.in.return.type=반환 타입 내 사용 위치
usage.in.import.statement=import 문 내 사용 위치
overriding.implementing.methods=메서드 재정의/구현
usage.in.type.hinting=타입 힌트 내 사용 위치
usage.in.implements.clause=implements 절 내 사용 위치
usage.in.extends.clause=extends 절 내 사용 위치
method.call=메서드 호출
function.call=함수 호출
04={0}:
field.ref.not.found=필드 '#ref'을(를) 찾을 수 없습니다
method.ref.not.found=메서드 '#ref'을(를) 찾을 수 없습니다
0.extends.1={0}이(가) {1}을(를) 확장합니다
0.1.choice.0.extends.1.implements.2={0}이(가) {2}을(를){1, choice, 0# 확장합니다|1# 구현합니다}
remove.link.between.0.and.1={0} 및 {1} 간 링크 제거
import.from.deployment.configuration=배포 구성에서 가져오기
import=가져오기
php.control.flow.viewer.0=PHP 제어 흐름 뷰어: {0}
php.control.flow.viewer=PHP 제어 흐름 뷰어
close=닫기(&C)
build.control.flow=제어 흐름 빌드(&B)
change.member.access=멤버 액세스 변경
php.make.class.non.final.quick.fix.family.name=클래스를 비 final로 설정
squash.repetitive.underscores=반복 밑줄 스쿼시
replace.with.01={0}(으)로 바꾸기
filetype.profiler.snapshot.description=프로파일러 스냅샷
proxy.configuration=프록시 구성
surround.with.0=''{0}''(으)로 둘러싸기
rename.constructor=생성자 이름 변경
rename=이름 변경
replace.with.alias=별칭으로 바꾸기
strict.type.declaration.is.available.in.php.7.only=엄격한 타입 선언은 PHP 7.0 이후 버전에서만 허용됩니다
recursive.call=재귀적 호출
smarty=Smarty
add.property=@property 추가
all.scripts=<모든 스크립트>
summary=요약
can.t.use.nullsafe.operator.in.write.context=쓰기 컨텍스트에서는 nullsafe 연산자를 사용할 수 없습니다
intention.family.name.collapse.whitespaces=공백 접기
inspection.message.qualified.name.can.t.contain.whitespaces=정규화된 이름에 공백이 있으면 안 됩니다
php.language.level.widget=PHP 언어 수준
tooltip.configured.php.language.level.widget=구성된 PHP 언어 수준
tooltip.configured.php.language.level.widget.composer=Composer를 통해 구성된 PHP 언어 수준
change.php.language.level=PHP 언어 수준 변경
function.fqn=함수 FQN
choose.class=클래스 선택
older=이전…
intention.family.name.replace.with=''{0}''(으)로 바꾸기
inspection.message.redundant.static.in.final.class=final 클래스 내 불필요한 'static'
link.label.inspection={0} 검사
intention.name.add.as.function.s.return.type=''{0}''을(를) 함수의 반환 타입으로서 추가
add.return.type=반환 타입 추가
php.class=클래스
php.interface=인터페이스
php.trait=특성
clearing.cache=캐시 지우는 중
diagnosing=진단 중
simulating.update=업데이트 시뮬레이션 중
generating.autoloader=자동 로더 생성 중
listing.licenses=라이선스 목록 나열 중
checking.for.changes.in.code.of.dependencies=종속성의 코드 내 변경 내용 확인 중
validating=유효성 검사 중
add.custom.format.function1=사용자 지정 형식 함수 추가
edit.custom.format.function=사용자 지정 형식 함수 편집
no.item=항목이 없습니다
no.interpreter=<인터프리터 없음>
open.in.editor=에디터에서 열기
how.to.fix=수정 방법
path.to.php=<php 경로>
constructor.already.exists=생성자가 이미 있습니다
fluent.setters=Fluent setter
no.private.fields.to.generate.getters.for=getter를 생성할 private 필드가 없습니다
no.private.fields.to.generate.both.getters.and.setters.for=getter 및 setter를 모두 생성할 private 필드가 없습니다
no.private.fields.to.generate.setters.for=setter를 생성할 private 필드가 없습니다
choose.methods.to.implement=구현할 메서드 선택
make.0.1=''{0}''을(를) {1}(으)로 만들기
arrays.are.not.supported.as.operands.for.0=''{0}''에 대한 피연산자로서의 배열은 지원되지 않습니다
types.not.supported.as.operands.for.0.1.2=''{1} {0} {2}''에서 지원되지 않는 피연산자 타입을 사용하면 PHP 8 TypeError가 발생합니다 
trait.method.0.will.not.be.applied.because.it.collides.with.1=특성 메서드 ''{0}''은(는) ''{1}''와(과) 충돌하므로 적용되지 않습니다
method.0.can.t.be.overridden.with.same.trait.1=메서드 ''{0}''을(를) 동일한 특성 ''{1}''(으)로 재정의할 수 없습니다
intention.name.make.non.final=''{0}''을(를) final로 만들기
replace.with.absolute.reference=절대 참조로 바꾸기
debug.output=출력
no.candidate.methods.to.implement=구현할 후보 메서드가 없습니다
choose.methods.to.implement1=구현할 메서드 선택
choose.methods.to.override=재정의할 메서드 선택
no.candidate.methods.to.override=재정의할 후보 메서드가 없습니다
cannot.call.abstract.method.0.1=추상 메서드 ''{0}::{1}''을(를) 호출할 수 없습니다
intention.name.flip={0} 및 {1} 반전
method.ref.is.deprecated=메서드 '#ref'은(는) 더 이상 사용되지 않습니다
parameter.is.deprecated=매개변수 ''{0}''은(는) 더 이상 사용되지 않습니다
function.ref.is.deprecated=함수 '#ref'은(는) 더 이상 사용되지 않습니다
class.ref.is.deprecated=클래스 '#ref'은(는) 더 이상 사용되지 않습니다
constant.ref.is.deprecated=상수 '#ref'은(는) 더 이상 사용되지 않습니다
field.ref.is.deprecated=필드 '#ref'은(는) 더 이상 사용되지 않습니다
constant.ref.is.deprecated1=상수 '#ref'은(는) 더 이상 사용되지 않습니다
inspection.message.duplicate.case.expression=중복 case 표현식
inspection.message.duplicate.case.expression.ref=중복 case 표현식: #ref
replace.qualifier.with.an.import=한정자를 import 문으로 바꾸기
inspection.message.method.ref.marked.as.internal=메서드 '#ref'이(가) @internal로 표시되었습니다
inspection.message.function.ref.marked.as.internal=함수 '#ref'이(가) @internal로 표시되었습니다
inspection.message.class.ref.marked.as.internal=클래스 '#ref'이(가) @internal로 표시되었습니다
inspection.message.constant.ref.marked.as.internal=상수 '#ref'이(가) @internal로 표시되었습니다
inspection.message.field.ref.marked.as.internal=필드 '#ref'이(가) @internal로 표시되었습니다
remove.from.the.parameter.0=매개변수 ''{0}''에서 ''\\&'' 제거
remove.from.function.0.declaration=함수 ''{0}'' 선언에서 ''\\&'' 제거
remove.numeric.literals.separators=숫자 리터럴 구분 기호 제거
intention.name.remove={0} 제거
intention.name.convert.array.syntax.to.short=배열을 짧은 구문으로 변환
inspection.message.call.chain.too.long.to.analyse.break.it.into.fragments.up.to.calls=호출 체인이 너무 길어서 분석할 수 없습니다. 체인을 최대 {0}개의 호출로 분할하세요
inspection.message.undefined.goto.label.ref=정의되지 않은 goto 라벨 '#ref'
inspection.message.unused.private.property.ref=사용되지 않는 private 프로퍼티 '#ref'
intention.name.add.method.stubs=메서드 스텁 추가
inspection.message.from.php.this.allowed={0}. 이는 PHP {1} 이후 버전에서만 허용됩니다.
intention.name.make.abstract={0}을(를) abstract로 설정
inspection.message.expression.without.parentheses=소괄호가 없는 표현식
add.clarifying.parentheses=명확히 구분 짓는 소괄호 추가
replace.all.occurrences.with.php=모든 찾은 항목을 '<?php'로 바꾸기
inspection.message.parentheses.are.unnecessary=소괄호가 불필요합니다
remove.unnecessary.parentheses=불필요한 소괄호 제거
inspection.message.goto.labels.inside.loops.or.switch.statements.are.not.allowed=루프 또는 switch 문 내 'goto' 라벨은 허용되지 않습니다
dialog.title.configure.code.patterns=코드 패턴 구성…
intention.family.name.generate.phpdoc.comment=PHPDoc 주석 생성
intention.family.name.copy.phpdoc.from.parent=상위 항목에서 PHPDoc 복사
inspection.message.constant.reassignment=상수 재대입
merge.with.0.branch=''{0}'' 브랜치와 병합
inspection.message.use.statement.with.non.compound.name.ref.has.no.effect=비 복합 이름이 '#ref'인 'use' 문은 효과가 없습니다
insert.default.branch='default' 브랜치 삽입
inspection.message.tostring.method.must.return.string='__toString' 메서드는 문자열을 반환해야 합니다
inspection.message.psr.compound.namespace.with.depth.more.than.two.levels=PSR-12: 깊이가 3개 수준 이상인 복합 네임스페이스
psr.12.extract.namespace=PSR-12: 네임스페이스 추출
inspection.message.psr.short.form.type.keywords.should.be.used=PSR-12: 짧은 형식의 키워드를 사용해야 합니다
psr.12.convert.to.short.form=PSR-12: 짧은 형식으로 변환
inspection.message.psr.missing.visibility.definition=PSR-12: 가시성 정의 누락
psr.12.add.public.visibility=PSR-12: 'public' 가시성 추가
inspection.message.psr.order.modifiers.incorrect=PSR-12: 제어자 순서가 올바르지 않습니다
psr.12.fix.modifiers.order=PSR-12: 제어자 순서 수정
inspection.message.psr.missing.parameter.list=PSR-12: 매개변수 목록 누락
psr.12.add.missing.parameter.list=PSR-12: 매개변수 목록 추가
inspection.message.psr.usage.else.if.construct=PSR-12: 'else if' 문의 사용 위치
inspection.message.psr.traits.must.be.included.one.per.line=PSR-12: 특성은 한 줄에 하나만 포함되어야 합니다
psr.12.split.to.several.use.statements=PSR-12: 여러 'use' 문으로 분할
inspection.message.psr.usage.var=PSR-12: 'var' 사용 위치
psr.12.replace.var.with.public=PSR-12: 'var'를 'public'으로 바꾸기
change.method.modifiers.to.0=메서드 제어자를 ''{0}''(으)로 변경
intention.family.name.remove={0} 제거
create.new.class.quickfix=새 클래스 생성
add.class1=클래스 추가
intention.name.suppress.for.statement=구문에 대해 억제
intention.name.change.cast.to={0} 형 변환을 {1}(으)로 변경
intention.name.cast.to={0}을(를) {1}(으)로 형 변환
add.fluent.setter=fluent setter 추가
intention.family.name.add.getter.setter=getter 및 setter 추가
intention.family.name.add.getter=getter 추가
intention.family.name.add.number.separators=숫자 구분 기호 추가
convert.the.arrow.function.to.a.traditional.closure=화살표 함수를 기존 클로저로 변환
intention.name.extract.if=if ({0}) 추출
intention.family.name.initialize.properties=프로퍼티 초기화
merge.into.elseif='elseif'로 병합
intention.family.name.replace.switch.with.if='switch'를 'if'로 바꾸기
make.01=''{0}''(으)로 설정
group.use.statements.by.selected.prefix=선택한 접두사별로 'use' 문을 그룹화
intention.family.name.convert.heredoc.nowdoc.to.string.literal=HEREDOC/NOWDOC을 문자열 리터럴로 변환
intention.family.name.convert.heredoc.to.string.literal=HEREDOC을 문자열 리터럴로 변환
intention.family.name.convert.nowdoc.to.string.literal=NOWDOC을 문자열 리터럴로 변환
convert.concatenation.to.sprintf.call=연결을 'sprintf()' 호출로 변환
convert.string.interpolation.to.concatenation=문자열 보간을 연결로 변환
convert.string.interpolation.to.sprintf.call=문자열 보간을 'sprintf()' 호출로 변환
intention.name.convert.sprintf.call.to.concatenation='sprintf()' 호출을 연결로 변환
copy.concatenated.string.to.clipboard=연결된 문자열을 클립보드에 복사
extract.selected.string.part.as.concatenation.operand=선택된 문자열 부분을 연결 피연산자로서 추출
extract.selected.string.part.as.format.function.argument=선택된 문자열 부분을 형식 함수 인수로서 추출
surround.with.if.0.1=''if({0}({1}))'{'...'}'''(으)로 둘러싸기
command.name.new.file=새 파일
dialog.title.inline.variable=변수 인라인화
property.declaration=프로퍼티 선언
class.constructor=클래스 생성자
label.global.namespace=<전역 네임스페이스>
cannot.use.positional.argument.after.named.argument=이름 지정된 인수 뒤에 위치 인수를 사용할 수 없습니다
named.parameter.overwrites.previous.argument=이름 지정된 매개변수가 이전 인수를 덮어씁니다
unknown.named.parameter=알 수 없는 이름 지정된 매개변수 ''{0}''
docker.compose.border.title.lifecycle=수명 주기
action.configuration.text=구성…
inspection.message.constructor.cannot.be.static=생성자는 static일 수 없습니다
inspection.message.destructor.cannot.be.static=소멸자는 static일 수 없습니다
inspection.message.clone.method.cannot.be.static='Clone' 메서드는 static일 수 없습니다
inspection.message.cannot.make.non.abstract.method.abstract=비 abstract 메서드를 abstract로 만들 수 없습니다
inspection.message.cannot.override.final.method=final 메서드를 재정의할 수 없습니다
inspection.message.cannot.make.method.visibility.lower.than.super.s=메서드 가시성을 상위 항목보다 낮게 설정할 수 없습니다
parsing.error.not.allowed=''{0}''은(는) 허용되지 않습니다
parsing.error.unexpected.token=예기치 않은 토큰: {0}
parsing.error.expression.not.assignable=표현식은 대입할 수 없습니다
live.template.name.comment=주석
php.remote.debug.name=PHP 원격 디버그
php.web.application.name=PHP 웹 애플리케이션
live.template.name.statement=구문
live.template.name.string.literal=문자열 리터럴
live.template.name.expression=표현식
cli.interpreters.name=CLI 인터프리터
code.style.option.group.use='use' 그룹화
code.style.option.attributes=속성
code.style.option.parameter.attributes=매개변수의 속성
code.style.option.in.namespace=네임스페이스에서
code.style.option.php.opening.tag=PHP 여는 태그
code.style.option.new.line.after.php.tag='<?php' 태그 뒤에 새 줄
code.style.option.align.inline.comments=인라인 주석 정렬
code.style.option.function.return.type=함수 반환 타입
code.style.option.return.type.on.new.line=새 줄에 반환 타입
code.style.option.align.key.value.pairs=key-value 쌍 정렬
code.style.option.match.expression='match' 식
code.style.option.match.expression.align.match.arm.bodies='match' arm 본문 정렬
code.style.option.place.on.new.line=새 줄에 ';' 배치
code.style.option.class.field.constant.groups=클래스 프로퍼티/상수 그룹
code.style.option.align.properties.in.columns=열에 프로퍼티 정렬
code.style.option.align.constants=상수 정렬
code.style.option.align.consecutive.assignments=연속 대입 정렬
code.style.option.keep.and.on.one.line=')' 및 '{'를 한 줄에 유지
code.style.option.for.foreach.statements=for()/foreach() 구문
code.style.option.place.for.constructor=생성자에 '()' 배치
code.style.option.in.anonymous.class.declaration=익명 클래스 선언에서
code.style.option.function.constructor.call.arguments=함수/생성자 호출 인수
code.style.option.function.declaration.parameters=함수 선언 매개변수
code.style.option.in.closure.declaration=클로저 선언에서
code.style.option.in.function.declaration=함수 선언에서
code.style.option.place.on.new.line2=마지막 요소 뒤 새 줄
code.style.option.new.line.after=첫 번째 요소 앞 새 줄
code.style.option.after='{:' 뒤
code.style.option.before.return.statement='return' 문 앞:
code.style.option.after.function=함수 뒤:
code.style.option.after.opening.tag=여는 태그 뒤:
code.style.option.between.group.use.statements=그룹 'use' 문 사이:
code.style.option.around.class.constants=클래스 상수 주위:
code.style.option.after.class.body=클래스 본문 뒤:
code.style.option.before.class.body=클래스 본문 앞:
code.style.option.after.use.statements='use' 문 뒤:
code.style.option.before.use.statements='use' 문 앞:
code.style.option.after.namespace=네임스페이스 뒤:
code.style.option.before.namespace=네임스페이스 앞:
code.style.option.around.property=프로퍼티 주위:
code.style.option.multiplicative.operators=곱셈 연산자(*, /, %, **)
code.style.option.arrow.function.parentheses=화살표 함수 소괄호
code.style.option.anonymous.function.parentheses=익명 함수 소괄호
code.style.option.shift.operators=시프트 연산자(<<, >>)
code.style.option.and=<?= 및 ?>
code.style.option.brackets.around.variable.expression=변수/표현식 주위에 대괄호
code.style.option.between.and='?' 및 ':' 사이
code.style.option.unary.additive.operators=단항 덧셈 연산자(+,-,++,--)
code.style.option.after.unary.not=단항 Not (!) 뒤
code.style.option.before.unary.not=단항 Not (!) 앞
code.style.option.array.initializer.parentheses=배열 이니셜라이저 소괄호
code.style.option.function.left.brace=함수 왼쪽 중괄호
code.style.option.function.declaration.parentheses=함수 선언 소괄호
code.style.option.function.call.parentheses=함수 호출 소괄호
code.style.option.after.colon.in.return.type=반환 타입 내 콜론 뒤
code.style.option.space.around.pipe.in.union.types=공용체 타입의 | 주위
code.style.option.before.colon.in.return.type=반환 타입 내 콜론 앞
code.style.option.before.colon.in.named.argument=이름 지정된 인수 내 콜론 앞
code.style.option.after.colon.in.named.argument=이름 지정된 인수 내 콜론 뒤
code.style.option.assignment.in.declare.statement=declare 구문 내 대입
code.style.option.null.coalescing.operator=null 병합 연산자 (??)
code.style.option.object.access.operator=객체 액세스 연산자 (->)
code.style.option.concatenation=연결 (.)
code.style.option.relational.operators=관계 연산자 (<, >, <=, >=, <=>)
link.label.languages.frameworks.php=PHP
inspection.message.cannot.make.static.method.non.static=static 메서드 {0}은(는) 비 static으로 만들 수 없습니다
inspection.message.cannot.make.non.static.method.static=비 static 메서드 {0}은(는) static으로 만들 수 없습니다
dialog.title.select.properties.to.initialize=초기화할 프로퍼티 선택
split.selected.group.use.statement=선택한 그룹 'use' 문 분할
intention.family.name.convert.string.literal.to.heredoc.nowdoc=문자열 리터럴을 HEREDOC/NOWDOC으로 변환
intention.name.convert.string.literal.to.heredoc=문자열 리터럴을 HEREDOC으로 변환
intention.name.convert.string.literal.to.nowdoc=문자열 리터럴을 NOWDOC으로 변환
intention.name.convert.concatenation.to.string.interpolation=연결을 문자열 보간으로 변환
intention.name.convert.concatenation.to.scalar.value=연결을 scalar 값으로 변환
intention.name.convert.sprintf.call.to.string.interpolation='sprintf()' 호출을 문자열 보간으로 변환
intention.name.convert.sprintf.call.to.scalar.value='sprintf()' 호출을 scalar 값으로 변환
parsing.error,at.expected='@'이 필요합니다
parsing.error.method.label.expected=메서드 라벨이 필요합니다
live.template.class.member=클래스 멤버
live.template.interface.member=인터페이스 멤버
live.template.trait.member=특성 멤버
dialog.error.title.php.extract.class=PHP 클래스 추출
quality.tools.label.by.default.project.interpreter=디폴트 프로젝트 인터프리터별
file.0.does.not.exist=파일 {0}이(가) 없습니다
languages.frameworks.php.php.runtime=PHP/PHP 런타임
do.not.ask.again=다시 묻지 않음
enable.support=지원 활성화
validating1=유효성 검사 중…
cache.creating=psalm 캐시 생성 중…
can.not.parse.phpunit.version.output.0=PHPUnit 버전 출력을 분석할 수 없습니다. {0}
zend.debugger.settings.broadcasting.is.already.launched=Zend 디버거 설정 브로드캐스트가 이미 시작되었습니다
directories=디렉터리
can.not.run.command.composer.execution.plugin.was.unloaded=Composer 실행 플러그인이 언로드되어 명령어를 실행할 수 없습니다
can.not.find.specified.interpreter=지정된 인터프리터를 찾을 수 없습니다
no.response.from.0.after.1.ms={1}밀리초가 경과한 후에도 {0}(으)로부터 응답이 없습니다
cannot.register.handler=핸들러를 등록할 수 없습니다
handler.with.the.same.session.id.is.already.registered=동일한 세션 ID를 가진 핸들러가 이미 등록되어 있습니다
unknown.debugger.type=알 수 없는 디버거 타입
functions.to.be.extracted=추출할 함수
failed.to.parse.php.ini.output.0=php --ini 출력을 분석하지 못했습니다. {0}
can.not.find.0.helper.script=''{0}'' 헬퍼 스크립트를 찾을 수 없습니다
can.not.execute.tests=테스트를 실행할 수 없습니다
failed.to.run.interpreter=인터프리터를 실행하지 못했습니다
failed.to.find.interpreter=인터프리터를 찾지 못했습니다
set=설정
proxy.init=프록시 초기화
register.ide=IDE 등록
0.for.1.run.configuration={1} 실행 구성에 대한 {0}
project.is.already.disposed=프로젝트가 이미 폐기되었습니다
can.not.execute.transfer.task.project.is.already.disposed=전송 작업을 실행할 수 없습니다. 프로젝트가 이미 폐기되었습니다
proxy.stop=프록시 중지
cancel.ide.registration=IDE 등록 취소
getting.installed.standards=설치된 표준 가져오는 중…
php.remote.interpreter.plugin.is.not.installed=PHP Remote Interpreter 플러그인이 설치되지 않았습니다
execution.result.is.null=실행 결과가 null입니다
can.not.delete.temporary.file.because.it.was.not.created=임시 파일이 생성되지 않았으므로 삭제할 수 없습니다
0.inspection={0} 검사
failed.to.find.valid.interpreter.path=올바른 인터프리터 경로를 찾지 못했습니다
with.data.set.0=데이터 집합 {1}이(가) 있는 {0}
add.phpunit.test.pattern=PHPUnit 테스트 패턴 추가
unused.code.rules=사용되지 않는 코드 규칙
naming.rules=이름 지정 규칙
design.rules=설계 규칙
controversial.rules=논란이 되는 규칙
code.size.rules=코드 크기 규칙
remote.interpreter.can.t.be.executed.please.enable.the.php.remote.interpreter.plugin=원격 인터프리터를 실행할 수 없습니다. PHP Remote Interpreter 플러그인을 활성화하세요.
create.target.class.quick.fix=대상 클래스 생성 빠른 수정
create.missing.target.method.fix=누락된 대상 메서드 생성 수정
php.extract.class=PHP 클래스 추출
local=로컬
project.files=프로젝트 파일
include.path=Include 경로
inspection.message.parameter.name.changed.from.to=매개변수 이름이 ''{0}''에서 ''{1}''(으)로 변경되었습니다
intention.family.name.rename.parameter.to.match.super=상위 항목과 일치하도록 매개변수 이름 변경
intention.name.rename.to=''{0}''(으)로 이름 변경
inspection.message.name.parameter.may.be.different.depending.on.instance.class=이름이 지정된 인수는 ''{0}.{1}''에서 해결되지 않을 수 있습니다 
tooltip.update={0} 업데이트
inspection.message.constant.ref.not.found=상수 '#ref'을(를) 찾을 수 없습니다
hint.text.can.not.find.target.class.for.modification=수정할 대상 클래스를 찾을 수 없습니다.
hint.text.target.class.not.writable=대상 클래스 {0}은(는) 쓰기 가능하지 않습니다
hint.text.target.class.does.not.belong.to.project.can.not.be.modified=대상 클래스 {0}은(는) 프로젝트에 속해 있지 않으므로\n\
수정할 수 없습니다.
inspection.message.cannot.make.non.abstract.method.abstract.1=비 abstract 메서드 {0}을(를) abstract로 만들 수 없습니다
inspection.message.cannot.override.final.method.1=final 메서드 {0}을(를) 재정의할 수 없습니다
inspection.message.return.type.declaration.must.be.compatible.with=반환 타입 선언은 {0}와(과) 호환되어야 합니다. {1}
inspection.message.cannot.make.method={0} 메서드 {1}을(를) {2}(으)로 만들 수 없습니다
inspection.message.declaration.should.be.compatible.with=선언은 {0}와(과) 호환되어야 합니다
inspection.message.declaration.should.be.compatible.with.super=선언은 상위 항목과 호환되어야 합니다
command.name.make.method.static=메서드를 static으로 설정
show.constants=상수 표시
show.properties=프로퍼티 표시
show.includes=인클루드 표시
show.private.members=private 멤버 표시
show.protected.members=protected 멤버 표시
undefined.interpreter=정의되지 않은 인터프리터
column.name.annotation.name=어노테이션 이름
inspection.message.exception.never.thrown.in.corresponding.try.block=예외 ''{0}''은(는) 해당 ''try'' 블록에서 한 번도 던져지지 않습니다
dialog.title.edit.phpunit.test.pattern=PHPUnit 테스트 패턴 편집
notification.title.incorrect.profiler.snapshot.format=잘못된 프로파일러 스냅샷 형식
notification.title.cannot.read.snapshot=스냅샷을 읽을 수 없습니다
label.lt.no.server=<서버 없음>
executable.0.was.not.found.in.path.please.make.sure.it.s.there.possible.solutions=실행 파일 ''{0}''을(를) %PATH%에서 찾을 수 없습니다. 올바른 경로가 지정되어 있는지 확인하세요. 가능한 해결 방법:
if.you.ve.changed.the.path.recently.restart.the.ide=%PATH%을(를) 최근 변경한 경우 IDE를 다시 시작하세요.
provide.the.full.path.to.executable=실행 파일의 전체 경로를 제공하세요.
select.composer.phar.and.provide.the.full.path.to.it.or.select.download.composer.stable.phar.from.getcomposer.org='composer.phar'을 선택하고 해당 파일의 전체 경로를 제공하거나 'getcomposer.org에서 composer-stable.phar 다운로드'를 선택하세요.
executable.0.was.not.found.in.path.please.make.sure.it.s.there.possible.solutions1=실행 파일 ''{0}''을(를) $PATH에서 찾을 수 없습니다. 올바른 경로가 지정되어 있는지 확인하세요. 가능한 해결 방법:
if.you.ve.changed.the.path.recently.restart.the.ide1=$PATH을(를) 최근 변경한 경우 IDE를 다시 시작하세요.
select.composer.phar.and.provide.the.full.path.to.it.or.select.download.composer.stable.phar.from.getcomposer.org1='composer.phar'을 선택하고 해당 파일의 전체 경로를 제공하거나 'getcomposer.org에서 composer-stable.phar 다운로드'를 선택하세요.
label.authentication.data.not.specified=인증 데이터가 지정되지 않았습니다
configured.is.incorrect=구성된 {0}이(가) 올바르지 않습니다
validation.script.was.created.but.it.cannot.be.executed.check.possible.reasons=유효성 검사 스크립트가 생성되었지만 해당 스크립트를 실행할 수 없습니다. 가능한 원인:
validated.web.server.is.not.running=유효성이 검사된 웹 서버가 실행되고 있지 않습니다.
target.directory.for.validation.script.is.not.public=유효성 검사 스크립트의 대상 디렉터리가 public이 아닙니다.
url.to.validation.script='유효성 검사 스크립트 URL'
follow.this.links.to.install.and.configure.0.or.1=이 링크로 이동하여 {0} 또는 {1}을(를) 설치 및 구성하세요.
if.you.have.already.configured.debug.extension.in.php.ini.file.check.possible.reasons.why.it.was.not.loaded=php.ini 파일에서 이미 디버그 확장 기능을 구성한 경우, 다음 가능한 로드 실패 원인을 확인하세요.
you.did.not.reload.web.server.after.changes.in.php.ini.file=php.ini 파일을 변경한 후 웹 서버를 다시 로드하지 않았습니다.
you.are.configuring.debug.extension.in.the.wrong.php.ini.see.the.loaded.php.ini.files.below=잘못된 php.ini에서 디버그 확장 기능을 구성하고 있습니다(아래 로드된 php.ini 파일 참조).
there.are.errors.on.attempt.to.load.debug.extension.e.g.version.incompatibility=디버그 확장 기능을 로드하려는 시도에 오류가 있습니다(예: 버전이 호환되지 않음).
intention.name.change.signature={0}({1})의 시그니처 변경
dialog.title.enter.tag.name=태그 이름 입력
method1=메서드
open.inspection.settings={0} 검사 설정 열기 
popup.content.enabled.disabled.extensions=확장 기능 {0}개 활성화, {1}개 비활성화
popup.content.configuration.remains.unchanged=현재 구성이 인터프리터와 동기화되어 있습니다
unhandled.0=처리되지 않는 {0}
unhandled.exceptions=처리되지 않은 예외
label.docker.container=Docker 컨테이너:
dialog.message.docker.account.not.specified=Docker 계정이 지정되지 않았습니다
dialog.message.docker.account.not.found=Docker 계정을 찾을 수 없습니다
dialog.message.could.not.find.network.interface={0} 네트워크 인터페이스를 찾을 수 없습니다
dialog.message.no.interface.addresses.for.network.interface={0} 네트워크 인터페이스의 인터페이스 주소가 없습니다
validation.script.will.be.created.in.0.directory={0} 디렉터리에 유효성 검사 스크립트가 생성됩니다.
files.in.the.directory.should.be.accessible.by.0.request=디렉터리 내 파일이 {0} 요청으로 액세스 가능해야 합니다.
caused.by.0=원인: "{0}"
validation.script.will.be.created.in.0.directory.and.deployed.to.the.1.server={0} 디렉터리에 유효성 검사 스크립트가 생성되고 {1} 서버로 배포됩니다.
files.in.the.remote.directory.should.be.accessible.by.0.request=원격 디렉터리 내 파일이 {0} 요청으로 액세스 가능해야 합니다.
follow.this.0.for.more.information.about.path.mappings=경로 매핑에 관한 자세한 정보는 이 {0}을(를) 참조하세요.
validation.script.will.be.created.locally.and.the.result.will.be.fetched.by.http.request=유효성 검사 스크립트가 로컬에서 생성되고 결과는 HTTP 요청으로 가져오게 됩니다.
validation.script.will.be.created.locally.and.deployed.to.the.remote.server=유효성 검사 스크립트가 로컬에서 생성되고 원격 서버로 배포됩니다.
the.result.of.validation.will.be.fetched.by.http.request=유효성 검사의 결과는 HTTP 요청으로 가져오게 됩니다.
follow.this.0.for.more.information.about.deployment=배포에 관한 자세한 정보는 이 {0}을(를) 참조하세요.
link=링크
no.type=NO_TYPE
in=위치
action.configure.php.runtime.text=PHP 런타임 구성…
action.configure.project.directories.text=프로젝트 디렉터리 구성
inspection.message.interpolated.string.dereferencing.available.in.php.only=보간된 문자열 역참조는 PHP 8.0 이후 버전에서만 허용됩니다
inspection.message.magic.constant.dereferencing.available.in.php.only=매직 상수 역참조는 PHP 8.0 이후 버전에서만 허용됩니다
intention.family.name.add.name.identifiers.to.all.arguments.starting.from.current=이름 식별자를 현재 위치에서 시작하는 모든 인수에 추가
intention.name.add.name.identifier=이름 식별자 ''{0}'' 추가
inspection.message.argument.without.name.identifier=이름 식별자가 없는 인수
tooltip.wsl2.mappings=WSL2 매핑
name=이름
file=파일
tooltip.from={0}에서:
tooltip.from.volumes={0} 볼륨에서:
intention.family.name.sort.arguments=인수 정렬
open.tool.settings={0} 설정 열기
init.cache=Init 캐시
or.disable.inspection=또는
inspection.message.type.can.be.reduced.to=타입을 ''{0}''(으)로 좁힐 수 있습니다
an.alias.was.defined.for.method.0.which.exists.in.1={1}에 있는 메서드 {0}()에 대해 별칭이 정의되어 있습니다
intention.family.name.append.absolute.trait=''{0}::'' 추가
intention.family.name.remove.argument.name=인수 이름 제거
intention.name.remove.argument.names.from.all.arguments.up.to.current=현재 위치까지의 모든 인수에서 인수 이름 제거
frameworl.composer.show.quick.actions=빠른 액션이 있는 composer.json 상단 패널 표시
framework.composer.notify.about.missing.vendor='vendor' 디렉터리 누락을 알림
cannot.make.interface.method.non.static=인터페이스 메서드는 비 static으로 만들 수 없습니다
cannot.make.interface.method.static=인터페이스 메서드는 static으로 만들 수 없습니다
access.must.be.public=액세스는 public이어야 합니다
inspection.message.method.reference.resolves.to.method.with.containing.class=''use'' 규칙은 포함하는 클래스 ''{0}''의 메서드로 해결됩니다
intention.name.move.trait.use.rule.to.use.list=특성 ''use'' 규칙을 ''{0}'' ''use'' 목록으로 이동
intention.family.name.move.trait.use.rule.to.resolved.class.use.list=특성 'use' 규칙을 해결된 클래스 'use' 목록으로 이동
required.trait.0.wasn.t.added.to.1=필수 특성 ''{0}''이(가) ''{1}''에 추가되어 있지 않습니다
intention.family.name.add.trait.to.use.list=use 목록에 특성 추가
intention.name.add.trait.to.use.list=use 목록에 특성 ''{0}'' 추가
intention.family.name.add.break.as.last.statement='break'를 마지막 구문으로 추가
inspection.message.class.does.not.have.attribute=클래스 ''{0}''에 ''Attribute'' 어노테이션이 추가되지 않았습니다
intention.family.name.add.attribute.attribute='Attribute' 어노테이션 추가
constant.expression.contains.invalid.operations=상수식에 잘못된 연산이 있습니다
attribute.must.be.first.child.of.parent.element=속성은 상위 요소의 첫 하위 항목이어야 합니다
intention.family.name.move.attribute.to.start.element=속성을 요소의 시작 위치로 이동
quickfix.remove.match.arm='match' arm 제거
quickfix.remove.duplicate.condition=중복 조건 제거
quickfix.remove.unused.condition=사용되지 않는 조건 제거
inspection.duplicate.match.condition.message=중복 조건
inspection.message.attribute.can.t.be.applied.to.because.it.doest.contains=속성은 ''{1}'' 플래그를 포함하지 않으므로 {0}에 적용될 수 없습니다
inspection.message.attribute.is.not.repeatable=속성은 'Attribute::IS_REPEATABLE' 플래그를 포함하지 않으므로 반복될 수 없습니다
class2=클래스
class.constant1=클래스 상수
property=프로퍼티
parameter1=매개변수
inspection.message.comment.will.be.parsed.as.attribute.starting.with.php=주석은 PHP 8.0부터 속성으로 분석됩니다
intention.family.name.insert.space.after='#' 뒤에 공백 삽입
inspection.message.condition.is.never.matched=조건이 전혀 일치하지 않습니다
inspection.php.arithmetic.type.check=지원되지 않는 피연산자가 포함된 산술 연산
introduce.variable.fix=변수 삽입
hint.text.use.statement.choice.s.removed={0} ''use'' 구문{1, choice, 0#|1#}이 제거되었습니다
hint.text.use.statements.checked.nothing.was.removed={0} ''use'' 구문을 확인했으나 아무것도 제거되지 않았습니다
no.name=이름 없음
debugger.method=메서드
inspection.message.named.argument.usage=이름 지정된 인수의 사용 위치
percentage.lines={0}% 줄
column.name.parameter=매개변수
column.name.file.directory=파일/디렉터리
unknown=알 수 없음
intention.family.name.replace.with.get.class.call='get_class()' 호출로 바꾸기
intention.family.name.replace.with.class.name.literal='::class'로 바꾸기
inspection.message.get.class.call.can.be.replaced.with.class.name.literal='get_class()' 호출을 '::class'로 바꿀 수 있습니다
intention.family.name.remove.parenthesis=소괄호 제거
inspection.message.redundant.parenthesis=불필요한 소괄호
intention.family.name.simplify.expression=표현식 단순화
intention.family.name.replace.match.with.ternary=삼항식으로 바꾸기
attribute.can.be.added.to.overridden.method=속성을 재정의 메서드에 추가할 수 있습니다
attribute.can.be.added.to.overridden.parameter=속성을 재정의 매개변수에 추가할 수 있습니다
intention.family.name.add.attribute.to.overridden.method=속성을 재정의 메서드에 추가
intention.family.name.add.attribute.to.overridden.method.of.abstract.method=속성을 추상 메서드의 재정의 메서드에 추가
intention.family.name.add.attribute.to.overridden.parameter=속성을 재정의 매개변수에 추가
inspection.message.match.can.be.replaced.with.ternary='match' 식을 삼항식으로 바꿀 수 있습니다
intention.family.name.replace.with.traditional.property.declaration=기존 프로퍼티 선언으로 바꾸기
cannot.declare.promoted.property.outside.a.constructor=승격된 프로퍼티를 생성자 외부에서 선언할 수 없습니다
only.visibility.modifiers.can.be.applied.to.promoted.property=승격된 프로퍼티에는 가시성 제어자만 적용할 수 있습니다
intention.family.name.replace.with.public='public'으로 바꾸기
cannot.declare.variadic.promoted.property=승격된 가변 프로퍼티를 선언할 수 없습니다
cannot.declare.promoted.property.in.an.abstract.constructor=승격된 프로퍼티를 abstract 생성자에서 선언할 수 없습니다
inspection.message.promoted.field.usage=승격된 프로퍼티 사용 위치
inspection.message.redundant.assignment=승격된 프로퍼티로의 불필요한 대입
remove.assignment=대입 제거
inspection.message.switch.can.be.replaced.with.match='switch' 문을 'match' 식으로 변환할 수 있습니다
intention.family.name.replace.switch.with.match.expression='switch'를 'match' 식으로 바꾸기
intention.family.name.split.into.multiple.catch.statements=여러 'catch' 문으로 분할
exception.class=예외 클래스
variable1=변수
identifier=식별자
field.name=필드 이름
object.property=객체 프로퍼티
class.reference=클래스 참조
array.index=배열 색인
line.separator=줄 구분 기호
initializer=이니셜라이저
label1=라벨
expression1=표현식
type=타입
static.value=static 값
property.or.function=프로퍼티 또는 함수
default.value=디폴트 값
extends=확장
interface.name=인터페이스 이름
extends.or.implements=확장 또는 구현
class.name=클래스 이름
modifier=제어자
return.type=반환 타입
inspection.message.duplicates.catch.statement=''{0}'' 문 중복
intention.name.merge.with=''{0}''와(과) 병합
intention.family.name.merge.with.duplicated.catch.statement=중복된 'catch' 문과 병합
intention.name.merge.with.match.arm=''{0}'' arm과 병합
intention.family.name.merge.with.duplicated.match.arm=중복된 'match' arm과 병합
intention.family.name.add.default.match.arm='default' 'match' arm 추가
intention.family.name.add.attribute=''#[{0}]'' 추가
inspection.message.exitpoint.attribute.can.be.added=#[NoReturn] 속성을 추가할 수 있습니다
intention.family.name.convert.to.promoted.field=승격된 프로퍼티로 변환
intention.family.name.convert.to.promoted.field.remove.doc.comment=승격된 프로퍼티로 변환 및 프로퍼티 PHPDoc 주석 제거
inspection.message.field.assignment.can.be.converted.to.promoted.field=프로퍼티를 승격할 수 있습니다
cannot.use.unpacking.in.attribute.argument.list=속성 인수 목록에서 패킹 해제를 사용할 수 없음
spread.operator.on.named.arguments.is.forbidden=명명된 인수에서 스프레드 연산자 사용이 금지됩니다
inspection.message.should.be.one=값이 다음 중 하나여야 합니다. {0}
0.by.remote.interpreter=원격 인터프리터에 따른 {0}
0.local={0} 로컬
inspection.message.double.quotes.are.unnecessary=큰따옴표가 불필요합니다
inspection.php.unnecessary.double.quotes.display.name=불필요한 큰따옴표
inspection.php.unnecessary.leading.backslash.in.use.statement='use' 문 내 불필요한 선행 '\'
replace.unnecessary.double.quotes=불필요한 큰따옴표 바꾸기
quality.tool.can.not.create.temporary.file=PhpStorm이 임시 파일을 생성하지 못했습니다
dialog.message.cannot.create.file.because.project.already.disposed=프로젝트가 이미 폐기되어 파일을 생성할 수 없습니다
dead.code.commented.out=주석 처리됨
dead.code.deleted=삭제됨
intention.family.name.add.arrayshape.attribute='#[ArrayShape]' 속성 추가
inspection.message.arrayshape.can.be.added='#[ArrayShape]'을(를) 추가할 수 있습니다
inspection.option.label.php8.severity=PHP 8 심각도:
inspection.message.pure.can.be.added=''{0}''을(를) 추가할 수 있습니다
intention.name.add.to.parameter=''\\&''를 매개변수 ''{0}''에 추가
intention.family.name.add.to.parameter='\\&'를 매개변수에 추가
inspection.message.array.write.access.unused=배열 쓰기 액세스가 사용되지 않습니다
inspection.message.function.may.produce.side.effects=함수가 부수 효과를 일으킬 수 있습니다
inspection.message.method.may.produce.side.effects=메서드가 부수 효과를 일으킬 수 있습니다
inspection.message.immutable.property.write.scope.does.not.allow.write.access.here=불변 프로퍼티 쓰기가 잘못되었습니다. 범위 ''{0}''은(는) 여기에서 쓰기 액세스를 허용하지 않습니다
php.console=PHP 콘솔
inspection.message.illegal.array.offset.access=타입 ''{0}''의 값에서 배열 오프셋에 액세스하려고 합니다
attributes.are.inapplicable.for.constants=상수에는 속성을 적용할 수 없습니다
intention.family.name.replace.with.define.call='define()' 호출로 바꾸기
inspection.message.leading.slash.in.constant.fqn.will.not.be.trimmed.by.php=상수 FQN의 선행 슬래시는 PHP에 의해 잘리지 않습니다
intention.family.name.remove.leading=선행 '\' 제거
intention.family.name.replace.with.const.syntax='const' 구문으로 바꾸기
inspection.message.can.be.replaced.with.const.syntax='const' 구문으로 바꿀수 있습니다
intention.family.name.force.fqcn.for.references.in.phpdoc=PHPDoc 내 참조에 대해 FQCN 강제 적용
constants.may.only.evaluate.to.scalar.values.arrays.or.resources=상수는 Scalar 값, 배열 또는 리소스로만 평가할 수 있습니다
intention.family.name.merge.with.following.attribute.list=속성 목록을 다음 항목과 병합
intention.family.name.extract.attribute.into.separate.list=속성을 별도의 목록으로 추출
intention.family.name.flip.attributes.lists=속성 목록 뒤집기
inspection.message.too.many.messages.per.line=한 줄당 메시지가 너무 많음
inspection.message.too.many.messages.per.file.only.first.errors.warnings.are.shown=한 줄당 메시지가 너무 많습니다. 첫 번째 {0} 만 표시됩니다.
can.not.correctly.run.the.tool.with.parameters=매개변수가 있는 도구를 올바르게 실행할 수 없음:
possible.tool.process.hangup.after.0.sec=도구 프로세스가 {0}초 후에 중단될 수 있습니다.
inspection.message.write.access.to.variable.that.still.references.array.value='foreach'에서 이전에 사용된 배열 값을 계속 참조하는 변수에 대한 쓰기 액세스
if.with.common.parts=공통 부분이 있는 'if'
switch.with.common.parts=공통 부분이 있는 'switch'
intention.family.name.insert.unset.before=다음 앞에 ''unset(${0});'' 삽입
intention.family.name.collapse.if.statement=''{0}'' 문 접기
intention.family.name.extract.common.parts.with.removing.branch=공통 부분 추출 및 브랜치 제거
intention.family.name.extract.common.parts=공통 부분 추출
inspection.message.if.statement.with.common.parts=공통 부분이 있는 ''{0}'' 문
intention.name.replace.with=''{0}''을(를) ''{1}''(으)로 바꾸기
inspection.message.property.only.written.but.never.read=프로퍼티가 쓰기만 되고 읽기가 되지 않습니다
inspection.message.property.only.read.but.never.written=프로퍼티가 읽기만 되고 쓰기가 되지 않습니다
intention.family.name.delete.field=프로퍼티 삭제
intention.family.name.replace.with.class.constant=클래스 상수로 바꾸기
invalid.condition.to.body.separator.should.be.used=조건과 본문 사이에 잘못된 구분 기호가 있습니다. 대신 '=>'를 사용하세요
intention.family.name.invert.if.statement='if' 문 반전
intention.family.name.unwrap.else='else' 래핑 해제
inspection.message.unnecessary.else=불필요한 'else'
inspection.message.array.always.empty.at.this.point=배열은 이 지점에서 항상 공백입니다
intention.family.name.can.be.merged.with.sequential=''if''를 후속 ''{0}''와(과) 병합할 수 있습니다
intention.family.name.merge.with.sequential=후속 ''{0}''와(과) 병합
inspection.message.behavior.unparenthesized.expressions.containing.both.will.change.in.php=괄호가 없는 표현식에 ''.''가 포함되어 있으므로 ''{0}''(으)로 인해 예기치 못한 결과가 발생할 수 있습니다
intention.name.wrap.left.operand.in.parentheses=소괄호로 왼쪽 피연산자 래핑
intention.name.wrap.right.operand.in.parentheses=소괄호로 오른쪽 피연산자 래핑
parameter.type.is.not.convertible.from.null=매개변수 타입을 'null'에서 변환할 수 없습니다
inspection.message.value.parameter.always=매개변숫값이 항상 ''{0}''입니다
intention.family.inline.value.for.parameter=매개변숫값 인라인화
intention.name.inline.value=값 ''{0}''인라인화
inspection.message.can.be.replaced.with.version=표현식을 '??' 버전으로 바꿀 수 있습니다
inspection.message.if.can.be.replaced.with.version='if' 표현식을 '??' 버전으로 바꿀 수 있습니다
intention.family.name.replace.with.version='??' 버전으로 바꾸기
intention.family.name.replace.with.ternary.expression=삼항식으로 바꾸기
popup.title.multiple.write.scopes.found=여러 쓰기 범위가 발견됨
closest.scope=가장 가까운 범위의 변수
all.values=모든 변수
checkbox.rename.only.nearest.scope=가장 가까운 범위 내 변수만 이름 변경
intention.family.name.make.method.void=메서드를 'void'로 만들기
inspection.message.return.value.method.never.used=메서드의 반환값이 한 번도 사용되지 않습니다
inspection.message.unnecessary.leading.slash=불필요한 선행 '\'
inspection.message.cast.redundant=형 변환이 불필요합니다
inspection.message.unnecessary.curly.braces=불필요한 중괄호
intention.family.name.unwrap.curly.braces=중괄호 래핑 해제
command.name.disable.synchronisation.with.composer=composer.json과 동기화 비활성화
navigate.to.composer.json=composer.json으로 이동
notification.content.language.level.synchronisation.with.composer.was.disabled=composer.json과의 언어 수준 동기화가 비활성화되었습니다
inspection.message.can.be.replaced.with.direct.parameter.access='func_get_arg'를 직접 매개변수 액세스로 바꿀 수 있습니다
intention.family.name.replace.with.parameter.access=매개변수 액세스로 바꾸기
intention.family.name.unwrap.function.call=함수 호출 래핑 해제
inspection.message.with.single.string.argument=단일 문자열 인수가 있는 ''{0}''
inspection.message.for.loop.can.be.replaced.with.str.repeat='for' 루프를 'str_repeat'으로 바꿀 수 있습니다
intention.family.name.replace.with.str.repeat.call='str_repeat()' 호출로 바꾸기
inspection.message.for.loop.can.be.replaced.with.implode='foreach' 루프를 'implode()'로 바꿀 수 있음
intention.family.name.replace.with.implode.call='implode()' 호출로 바꾸기
intention.family.name.unwrap.cast=형 변환 래핑 해제
inspection.message.unnecessary.cast.to.string=''{0}''(으)로의 불필요한 형 변환
intention.family.name.merge.with.assignment=대입과 병합
inspection.message.concatenation.can.be.merged.with.assignment.empty.string.literal=연결을 빈 문자열 리터럴 대입과 병합할 수 있습니다
inspection.message.operands.have.incompatible.types=피연산자에 호환되지 않는 타입이 있습니다
short.arrow.function.cannot.return.void=화살표 함수는 'void' 반환 타입을 가질 수 없습니다
delete.void.return.type='void' 반환 타입 삭제
array.callback.must.have.exactly.two.elements=배열 콜백은 정확히 두 요소를 포함해야 합니다
intention.family.name.split.into.separate.case.statements=개별 'case' 문으로 분할
invalid.syntax.for.multiple.case.expressions=여러 'case' 식의 잘못된 구문
cannot.mix.keyed.and.unkeyed.array.entries.in.assignments=대입에서 키가 있는 배열과 키가 없는 배열 항목을 혼용할 수 없습니다
cannot.use.empty.array.entries.in.keyed.array.assignment=키가 있는 배열 대입에서는 빈 배열 항목을 사용할 수 없습니다
cannot.use.empty.list=빈 목록을 사용할 수 없습니다
unsupported.declare.0=지원되지 않는 선언 ''{0}''
inspection.message.continue.targeting.switch.equivalent.to.break='switch' 문을 대상으로 하는 'continue'는 'break'와 동등합니다
inspection.message.redundant.expression=불필요한 표현식
strict.types.declaration.must.have.0.or.1.as.its.value='strict_types' 선언의 값은 0 또는 1이어야 합니다
private.methods.cannot.be.final=private 메서드는 다른 클래스에서 재정의되지 않았으므로 final일 수 없습니다
cannot.use.yield.from.inside.a.by.reference.generator=참조 전달 제너레이터 안에는 'yield from'을 사용할 수 없습니다
intention.family.name.replace.with.check='!==' 검사로 바꾸기
dialog.title.select.methods.to.propagate.safe.delete=안전한 삭제를 전달할 메서드 선택
dialog.title.select.parameters.to.propagate.safe.delete=안전한 삭제를 전달할 매개변수 선택
referenced.calls=참조된 호출
cannot.mix.and.list=[] 및 list()를 혼용할 수 없습니다
intention.family.name.replace.with.array=배열로 바꾸기
intention.family.name.replace.with.list='list'로 바꾸기
inspection.message.can.be.replaced.with=''{0}''(으)로 바꿀 수 있습니다
intention.family.name.remove.unused.postfix.operation=사용되지 않는 접미사 연산 제거
inspection.message.results.postfix.expression.unused=접미사 표현식의 결과가 사용되지 않았습니다
intention.family.name.add.doc.tag.with.throws.tags=@throws 태그로 PHPDoc 주석 추가
replace.variable.assignment.with.named.argument=변수 대입을 이름이 지정된 인수로 바꾸기
action.run.composer.install.text='composer Install' 실행
notification.content.vendor.directory.not.found='vendor' 디렉터리를 찾을 수 없습니다
intention.family.name.move.from.to.composer.json.section=''{1}''에서 ''{2}'' composer.json 섹션으로 ''{0}'' 이동
intention.family.name.flip='?:' 반전
inspection.message.can.be.removed=''{0}''이(가) 제거됩니다
intention.family.name.remove.unused.property=사용하지 않는 프로퍼티 제거
intention.family.name.simplify.ternary.expression=단순화 '?:'
inspection.message.should.probably.not.be.passed.as.parameter=''{0}''을(를) 매개변수 ''{1}''(으)로 전달할 수 없습니다
inspection.message.should.probably.not.be.assigned=''{0}''을(를) ''{1}''에 할당할 수 없습니다
extract.method.selector.title=추출할 코드
intention.family.name.replace.with.operator='?->' 연산자로 바꾸기
inspection.message.can.be.replaced.with.operator='?->' 연산자로 바꿀 수 있습니다
add.throw.before.exception=예외 앞에 'throw' 추가
intention.family.name.replace.with.dirname.call='dirname()' 호출로 바꾸기
inspection.php.redundant.method.override=불필요한 메서드 재정의
inspection.php.loop.can.be.replaced.with.implode=루프를 'implode()'로 바꿀 수 있습니다
inspection.message.redundant.method.override=메서드 재정의가 불필요합니다
delete.redundant.method.override=메서드 제거
intention.family.name.replace.if.with.version='if'를 '??' 버전으로 바꾸기
anonymous.class=익명 클래스
anonymous.0=익명 {0}
lambda=람다
checkbox.anonymous.classes=익명 클래스
checkbox.lambdas=람다
inspection.message.trait.usage=특성 사용이 허용되지 않습니다
inspection.message.will.be.covered.by=조건은 ''{0}''에 의해 확인되므로 불필요합니다
inspection.message.can.be.replaced.with.fail=''{0}''(으)로 바꿀수 있습니다
intention.name.replace.coalesce.expression.with.operand=병합 표현식을 피연산자로 바꾸기
intention.name.replace.coalesce.expression.with=병합 표현식을 ''{0}''(으)로 바꾸기
label.align.named.arguments=이름이 지정된 인수 정렬
delete.catch.statement='catch' 문 삭제
inspection.message.exception.immediately.rethrown=예외가 즉시 다시 던져집니다
inspection.message.dangerous.array.initialization=위험한 배열 초기화
replace.with.array=직접 대입 '$array = array($value)'로 바꾸기
intention.family.name.replace.with.comparison=비교로 바꾸기
quickfix.undefined.function.add.function=함수 추가
PhpLanguageLevel.8.1.0.presentable.name=8.1
PhpLanguageLevel.8.1.0.short.description=열거형, 'never' 반환 타입, 교차 타입, 'readonly' 프로퍼티
PhpLanguageFeature.enum.classes=열거형은 PHP 8.1 이후 버전에서만 허용됩니다
annotation.new.expression.enum=열거형 ''{0}''을(를) 인스턴스화할 수 없습니다
enum.may.not.include.0=열거형은 ''{0}''을(를) 포함할 수 없습니다
enum.may.not.include.extend=열거형은 다른 클래스를 확장할 수 없습니다
enums.may.not.include.properties=열거형은 프로퍼티를 포함할 수 없습니다
enums.may.not.be.cloned=열거형은 복제할 수 없습니다
intention.family.name.make.containing.class.enum=포함하는 클래스를 열거형으로 만들기
enum.properties.are.immutable=열거형 프로퍼티는 변경할 수 없습니다
enum.backing.type.must.be.int.or.string=열거형 백킹 타입은 'int' 또는 'string'이어야 합니다
enum.case.type.0.does.not.match.enum.backing.type.1=열거형 case 타입 ''{0}''은(는) 열거형 백킹 타입 ''{1}''와(과) 일치해야 합니다
all.cases.of.backed.enum.must.have.a.value=백킹된 열거형의 모든 case는 값을 가져야 합니다
case.of.non.backed.enum.must.not.have.a.value=백킹되지 않은 열거형의 case는 값을 가질 수 없습니다
intention.family.name.delete.initializer=이니셜라이저 삭제
intention.family.name.add.to.containing.enum=포함하는 열거형에 '' : {0}'' 추가
intention.family.name.remove.backed.type.from.containing.enum=포함하는 열거형에서 백킹된 타입 제거
enum.case.should.be.located.only.inside.enum.classes=열거형 case는 열거형 클래스 내부에만 있어야 합니다
enum.case.value.must.be.constant=열거형 case 값은 상수여야 합니다
enum.backing.type.must.be.int.or.string.0.given=열거형 백킹 타입은 ''int'' 또는 ''string''이어야 하지만 ''{0}''이(가) 지정되어 있습니다
code.style.option.before.colon.in.enum.backed.type=백킹된 열거형 내 타입 선언 옆의 콜론 앞
code.style.option.after.colon.in.enum.backed.type=백킹된 열거형 내 타입 선언 옆의 콜론 뒤
enum.case=열거형 case
enums.may.not.implement.the.serializable.interface=열거형은 'Serializable' 인터페이스를 구현할 수 없습니다
cannot.redeclare.methods.from.enum.implicit.interfaces=열거형 묵시적 인터페이스의 메서드를 다시 선언할 수 없습니다
cannot.implement.interface.0=인터페이스 ''{0}''을(를) 구현할 수 없습니다
cannot.implement.interface.0.directly=인터페이스 ''{0}''을(를) 직접 구현할 수 없습니다
non.enum.class.cannot.implement.interface=열거형이 아닌 클래스는 인터페이스 ''{0}''을(를) 구현할 수 없습니다
non.backed.enum.cannot.implement.interface.backedenum=백킹되지 않은 열거형은 인터페이스 'BackedEnum'을 구현할 수 없습니다
intention.family.name.count.comments.as.content=주석을 내용으로 간주
inspection.php.class.constant.accessed.via.child.class=하위 클래스를 통해 참조된 클래스 상수
inspection.message.constant.from.base.class.referenced.via.child.class=하위 클래스를 참조된 기본 클래스 ''{0}''의 상수
intention.family.name.replace.with.class.reference.with.base.class=기본 클래스에 대한 클래스 참조로 바꾸기
intention.replace.with.method.call=기존 메서드 호출로 바꾸기
inspection.php.uncovered.enum.cases=일부 enum case가 다뤄지지 않습니다
inspection.message.uncovered.enum.cases='match' 식에 다뤄지지 않는 enum case가 있습니다
intention.family.name.add.remaining.enum.cases=남아 있는 enum case 추가
add.enum.declaration.quick.fix.text=열거형 case 추가
intention.family.name.split.into.two.separate.match.arms=조건을 별도의 'match' arm으로 추출
multiple.enum.identifiers.should.be.stated.in.different.cases=여러 열거형 식별자는 별도의 case에 명시되어야 합니다
replace.with.array.short.syntax=직접 대입 '$array = [$value]'로 바꾸기
intention.family.name.split.into.multiple.enum.cases=여러 열거형 case로 분할
inspection.message.uncovered.enum.cases.switch='switch' 문에 다뤄지지 않는 열거형 case가 있습니다
inspection.php.unused.switch.case.inspection.display.name=사용되지 않는 'switch' 브랜치
inspection.message.branch.is.unused='switch' 브랜치가 한 번도 실행되지 않았습니다
inspection.php.enum.case.with.value.not.found=값이 지정된 case를 열거형에서 찾을 수 없습니다
inspection.message.not.valid.backing.value.for.enum={0}은(는) 열거형에 대해 올바른 백킹 값이 아닙니다
intention.name.add.enum.case.with.value=''{0}'' 값을 가진 열거형 case 추가
inspection.php.empty.index.operator.not.supported.for.strings.display.name=빈 색인 연산자는 문자열에서 지원되지 않음
inspection.php.empty.index.operator.not.supported.for.strings='[]' 연산자는 문자열에서 지원되지 않습니다
intention.family.name.replace.with.concatenation=연결로 바꾸기
intention.family.name.remove.empty.index.operator='[]' 연산자 제거
refactoring.move.class.action.name = 클래스 이동…
refactoring.move.namespace.action.name=네임스페이스 이동…
refactoring.move.constant.action.name=상수 이동…
refactoring.move.function.action.name=함수 이동…
refactoring.inline.function.cannot.inline.magic.method=매직 메서드를 인라인화할 수 없습니다
refactoring.inline.function.cannot.inline.constructor=생성자를 인라인화할 수 없습니다
inspection.missing.doc.comment.options.panel.ignore.private.members=private 멤버 무시
code.style.option.place.braces.for.constructor.as.is=그대로
code.style.option.place.braces.for.constructor.always=항상
code.style.option.place.braces.for.constructor.never=안 함
settings.smart.keys.auto.insert.semicolon=함수 호출 내 입력 시 세미콜론 자동 삽입 
inspection.php.foreach.over.single.element=하나의 요소를 가진 배열 리터럴에 대한 foreach
intention.family.name.unwrap.foreach='foreach' 래핑 해제
inspection.message.foreach.over.array.literal.with.single.element=하나의 요소를 가진 배열 리터럴에 대한 'foreach'
inspection.php.condition.can.be.replaced.with.min.max.call=조건을 'min()'/'max()' 호출로 바꿀 수 있습니다
inspection.message.can.be.replaced.with.min.max.call=''{0}'' 호출로 바꿀 수 있습니다
intention.family.name.replace.with.min.max.call='min()'/'max()' 호출로 바꾸기
intention.name.replace.with.min.max.call=''{0}'' 호출로 바꾸기
quickfix.navigate.to.duplicate.case.value=중복 case 값으로 이동
duplicate.value.in.enum.for.cases.0.and.1=case ''{0}'' 및 ''{1}''의 열거형 내 중복 값
inspection.php.idempotent.operation=이항식 내 멱등 연산
inspection.message.expression.not.changed.after.applying=표현식은 ''{0}'' 적용 후 변경되지 않습니다
inspection.php.array.push.with.single.element=하나의 요소를 가진 'array_push()'
inspection.message.array.push.with.single.element=하나의 요소를 가진 'array_push'
unwrap.switch=switch 래핑 해제…
inspection.switch.with.single.case=하나의 'case'를 가진 'switch'
inspection.message.switch.has.only.default.case=switch에 'default' case만 있습니다
inspection.message.switch.has.only.single.case=switch 문에 하나의 case만 있습니다
intention.family.name.replace.with.if='if'로 바꾸기
PhpLanguageFeature.return.never=반환 타입 'never'는 PHP 8.1 이후 버전에서만 허용됩니다
classes.named.never.is.forbidden.in.php.8.1='never'로 이름 지정된 클래스는 PHP 8.1에서 금지됩니다
inspection.php.never.typed.function.returning.value='never' 타입의 함수가 값을 반환합니다
never.can.only.be.used.as.return.type='never'는 반환 타입으로만 사용될 수 있습니다
inspection.message.never.returning.function.must.not.return='never' 반환 함수는 반환할 수 없습니다
delete.case='case' 삭제
inspection.php.internal.array.index.reset.is.unnecessary=배열 내부 포인터 재설정은 불필요합니다
inspection.php.enforce.doc.comment.inspection.display.name=PHPDoc 주석 강제 적용
remove.unnecessary.reset=불필요한 'reset' 제거
refactoring.inline.function.cannot.inline.overridden.method=재정의된 메서드를 인라인화할 수 없습니다
intention.family.name.replace.with.array.assignment=배열 대입으로 바꾸기
inspection.php.array.search.can.be.replaced.with.in.array='array_search()'를 'in_array()' 호출로 바꿀 수 있습니다
intention.family.name.replace.with.in.array.call='in_array()' 호출로 바꾸기
inspection.message.can.be.replaced.with.in.array.call=''{0}'' 호출로 바꿀 수 있습니다
inspection.php.preg.match.without.regular.expression='preg_match'를 'str_contains'로 바꿀 수 있습니다
inspection.message.can.be.replaced.with.str.function=''{0}''(으)로 바꿀수 있습니다.
intention.family.name.replace.with.str.function.call=''{0}'' 호출로 바꾸기
inspection.php.group.regexp=정규식
PhpLanguageFeature.final.class.constants='final' 클래스 상수는 PHP 8.1 이후 버전에서만 허용됩니다
intention.family.name.replace.in.array.with.disjunction='in_array()'를 '||'로 바꾸기
intention.message.replace.in.array.with.disjunction=''in_array()''를 ''{0}''(으)로 바꿉니다
intersection.types.and.the.nullable.type.notation.cannot.be.mixed=교차 타입 및 null 가능 타입 표기는 혼용할 수 없습니다
cannot.mix.amp.and.pipe.in.type.declaration=타입 선언에 '\\&'와 '|'를 혼용할 수 없습니다
PhpLanguageFeature.intersection.types=교차 타입은 PHP 8.1 이후 버전에서만 허용됩니다
intention.family.name.evaluate.cast=''{0}''(으)로 바꾸기
intention.name.evaluate.cast=형 변환 평가
inspection.message.cast.evaluable=형 변환을 ''{0}''(으)로 바꿀 수 있습니다
inspection.php.cast.is.evaluable=scalar 값의 형 변환
cannot.use.readonly.as.identifier='readonly'는 식별자로 사용할 수 없습니다. PHP 8.1 이후부터 예약된 키워드입니다
PhpLanguageFeature.readonly.properties='readonly' 프로퍼티는 PHP 8.1 이후 버전에서만 허용됩니다
PhpLanguageFeature.new.in.init=이니셜라이저 내 'new'는 PHP 8.1 이후 버전에서만 허용됩니다
globals.can.only.be.modified.using.the.globals.name.value.syntax='$GLOBALS'은(는) '$GLOBALS[$name] = $value' 구문으로만 수정할 수 있습니다
inspection.php.match.can.be.replaced.with.switch.statement='match' 문을 'switch' 문으로 바꿀 수 있습니다
inspection.message.match.can.be.replaced.with.switch='match' 식을 'switch' 문으로 변환할 수 있습니다.
intention.family.name.replace.match.with.switch.statement='match'를 'switch' 문으로 바꾸기
intention.family.name.replace.match.with.switch.statement.changing.semantics='match'를 'switch' 문으로 바꾸기(비교 의미가 변경될 수 있음)
PhpLanguageFeature.explicit.octal.literal=명시적 8진 리터럴은 PHP 8.1 이후 버전에서만 허용됩니다
inspection.php.acessing.static.trait.members=static 특성 멤버 액세스 중
inspection.message.calling.static.trait.member=static 특성 멤버를 직접 호출하는 것은 더는 사용되지 않습니다. 특성을 사용하여 클래스에서만 액세스해야 합니다.
intention.family.name.replace.with.self.access='self::' 액세스로 바꾸기
inspection.message.returning.by.reference.from.void.function.deprecated=void 함수를 참조로 반환하는 것은 더는 사용되지 않습니다
intention.family.name.collapse.statement.into.parameter.default.value=구문을 매개변수의 디폴트 값으로 접기
inspection.message.statement.can.be.collapsed.into.parameter.default.value=구문은 매개변수의 기본값으로 접힐 수 있습니다
label.successors=후속 항목
label.predecessors=선행 항목
inspection.php.covered.element.in.class=클래스의 요소가 이미 포함되었습니다
inspection.message.element.already.covered.by=''{0}''은(는) 이미 ''{1}''이(가) 포함하고 있습니다
intention.family.name.delete.covered.element=포함된 요소 삭제
inspection.php.ranges.in.class.can.re.merged=클래스 내의 범위는 병합할 수 있습니다
inspection.message.can.be.merged.with=''{0}''와(과) 병합할 수 있습니다
intention.family.name.merge.with.adjustment.range=조정된 범위로 병합
intention.name.prepend.default.case=앞에 'default' 추가
popup.title.select.target.code.block=대상 코드 블록 선택
popup.select.target.code.block.closure=화살표 함수 본문(클로저로 변환)
popup.select.target.code.block.containing.block=포함하는 블록
refactoring.inline.function.cannot.find.function.declaration=함수 선언을 찾을 수 없습니다
private.constant.cannot.be.final='private' 상수는 다른 함수에서 볼 수 없으므로 'final'일 수 없습니다
cannot.override.final.constant=''{1}''에서 final 상수 ''{0}''을(를) 재정의할 수 없습니다
intention.family.name.replace.with.implicit.octal.notation=묵시적 8진수 표기로 바꾸기
inspection.message.match.can.be.replaced.with.switch.changing.semantics='match' 표현식은 'switch' 구문으로 변환될 수 있습니다. 'switch' 구문은 대략적인 비교에 의존하며 표현식의 의미가 변경될 수 있습니다.
php.intention.category=PHP
inspection.php.deprecated.stdlib.call=지원 중단된 표준 라이브러리 호출
inspection.message.argument.with.type.deprecated.for.this.call=종류가 ''{0}''인 인자는 해당 호출에 대해 더 이상 사용되지 않습니다
inspection.message.call.without.arguments.deprecated=인자가 없는 ''{0}'' 호출은 더는 사용되지 않습니다
inspection.php.array.index.immediately.rewritten=배열 색인은 즉시 다시 쓰기됩니다 
intention.family.name.navigate.to.rewrite.expression=이동하여 표현식 다시 쓰기
inspection.message.array.index.immediately.rewritten.before.accessing=배열 색인은 액세스 전에 덮어쓰기 됩니다.
inspection.php.implicit.octal.literal.can.be.replaced.with.explicit.one=묵시적 8진 리터럴은 명시적 리터럴로 바꿀 수 있습니다
inspection.message.replace.implicit.octal.literal.with.explicit.one=묵시적 8진 리터럴은 명시적인 리터럴로 바꿀 수 있습니다
inspection.family.name.replace.implicit.octal.literal.with.explicit.one=묵시적 8진 리터럴을 명시적 리터럴로 바꾸기
inspection.php.object.fields.are.only.written=지역 객체가 프로퍼티를 쓰는 데에만 사용됩니다
inspection.message.local.object.used.only.for.writing.properties=로컬 객체는 프로퍼티를 쓰는 용으로만 사용됩니다
inspection.php.redundant.array.call.in.foreach.iterated.value='foreach'에서 값에 대한 불필요한 'array_values' 호출이 반복되었습니다
intention.family.name.replace.with.argument=인수로 바꾸기
inspection.message.array.values.call.redundant='array_values' 호출이 중복됩니다
readonly.property.must.have.type='readonly' 프로퍼티는 타입이 지정되어야 합니다
inspection.php.unit.assert.always.execute.to.same.result=인수 타입이 호환되지 않는 'assertTrue()'
inspection.message.assert.always.will.be.false='assertTrue()'이 'true'에 대한 엄격한 비교를 수행하므로 이 종류의 인수는 호환되지 않습니다
expected.property=프로퍼티
inspection.array.to.string.conversion=배열에서 문자열로 변환
inspection.message.array.to.string.conversion=배열에서 문자열로 변환
inspection.php.invalid.string.offset.usage=잘못된 문자열 오프셋 사용
inspection.message.cannot.use.string.offset.as.object=문자열 오프셋을 객체로 사용할 수 없습니다
inspection.message.cannot.use.assign.op.operators.with.string.offsets=조합된 연산자 대입을 문자열 오프셋과 같이 쓸 수 없습니다
inspection.message.cannot.unset.string.offsets=설정 해제된 문자열 오프셋을 사용할 수 없습니다
inspection.message.cannot.increment.decrement.string.offsets=문자열 오프셋을 증가/감소할 수 없습니다
inspection.message.cannot.create.references.to.from.string.offsets=문자열 오프셋으로부터/에 대한 참조를 생성할 수 없습니다
inspection.message.cannot.use.string.offset.as.array=문자열 오프셋을 배열로 사용할 수 없습니다
intention.inline.method.family.name=메서드 인라인화
inspection.message.cannot.assign.empty.string.to.string.offset=빈 문자열을 문자열 오프셋에 할당할 수 없습니다
inspection.message.only.first.byte.will.be.assigned.to.string.offset=첫 번째 바이트만 문자열 오프셋으로 할당됩니다
static.property.cannot.be.readonly='static' 프로퍼티는 'readonly'일 수 없습니다
inspection.message.second.write.to.readonly.property='readonly' 프로퍼티를 수정할 수 없습니다
inspection.php.second.write.to.readonly.property='readonly' 프로퍼티에 두 번째로 쓰기
inspection.php.unnecessary.spread.operator.for.function.call.argument=함수 호출 인수에 대해 불필요한 스프레드 연산자
inspection.message.spread.operator.can.be.unwrapped=스프레드 연산자의 래핑을 해제할 수 있습니다
inspection.message.spread.operator.over.literal.unnecessary.for.arguments.resolved.to.variadic.parameter=리터럴에 대한 스프레드 연산자는 가변 매개변수로 해결되는 인수에 필요하지 않습니다
intention.family.name.unwrap.spread.operator=스프레드 연산자 래핑 해제
inspection.message.write.access.to.readonly.property.outside.declaration.scope=선언 범위 밖에서 'readonly' 프로퍼티를 쓸 수 없습니다
inspection.php.write.access.to.readonly.property.outside.declaration.scope=선언 범위 밖에서 'readonly' 프로퍼티 대한 쓰기 액세스
build.control.flow.with.exit.points=종료점을 포함한 제어 흐름 빌드(&E)
inspection.message.comment.can.be.replaced.with.named.argument=주석은 이름이 지정된 인수로 대체될 수 있습니다
intention.family.name.replace.with.named.argument=명명된 인수로 바꾸기
inspection.message.can.be.replaced.with.named.argument=이름이 지정된 인수로 대체될 수 있습니다
PhpLanguageFeature.first.class.callable.syntax=일급 callable 구문은 PHP 8.1 이후 버전에서만 사용할 수 있습니다
intention.family.name.replace.with.closure.fromCallable='Closure::fromCallable(...)'로 바꾸기
cannot.create.closure.for.new.expression='new' 표현식에 대해 'Closure'를 생성할 수 없습니다
replace.with.arrow.function=화살표 함수로 바꾸기
replace.with.anonymous.function=익명 함수로 바꾸기
label.interpreter=인터프리터: {0}
cannot.combine.nullsafe.operator.with.closure.creation=nullsafe 연산자를 'Closure' 생성과 결합할 수 없습니다
replace.with.coalesce.operator=병합 연산자와 바꾸기
intention.family.name.initialize.property.in.constructor=생성자에서 프로퍼티 초기화
inspection.php.field.immediately.rewritten=프로퍼티가 즉시 다시 쓰기됩니다 
inspection.message.field.immediately.rewritten.before.accessing=프로퍼티는 액세스 전에 덮어쓰기 됩니다.
inspection.redundant.intersection.type=불필요한 교차 타입
inspection.redundant.intersection.type.fix=교차 타입을 ''{0}''(으)로 단순화할 수 있습니다
inspection.redundant.intersection.type.fix.name=교차 타입 단순화
anonymous.function=익명 함수
expected.expression.after.spread.operator=필요: 스프레드 연산자 뒤에 표현식
action.com.jetbrains.php.internal.PhpCreateYoutrackIssueFromFileAction.text=파일 내용에서 WI(PhpStorm) 프로젝트에 YouTrack 이슈 생성 
action.com.jetbrains.php.internal.PhpCreateYoutrackIssueFromSelectionAction.text=선택한 내용에서 WI(PhpStorm) 프로젝트에 YouTrack 이슈 생성
inspection.php.nested.min.max.call=중첩된 'min/max' 호출
inspection.message.nested.call.can.be.unwrapped=중첩된 ''{0}'' 호출은 래핑 해제할 수 있습니다
intention.family.name.unwrap.call=호출 래핑 해제
type.0.cannot.be.part.of.an.intersection.type=''{0}'' 타입은 교차 타입의 일부일 수 없습니다
inspection.closure.can.be.converted.to.first.class.callable='Closure::fromCallable()'은 일급 호출 가능 구문으로 변환할 수 있습니다.
inspection.php.closure.can.be.converted.to.first.class.callable.inspection.display.name='Closure::fromCallable()'은 일급 호출 가능 구문으로 변환할 수 있음
replace.with.first.class.callable.family.name=일급 callable 구문으로 바꾸기
inspection.php.duplicate.character.in.str.function.call=함수 호출 내 중복 문자
inspection.message.duplicate.character=중복 문자
quickfix.remove.condition.from.default.arm='default' arm에서 'default'가 아닌 조건 제거
annotator.only.default.condition.allowed=단일 'default' 조건만 'default' arm에서 사용할 수 있습니다 
inspection.php.autovivification.on.false.values='false'를 배열로 자동 변환하는 것은 더 이상 지원되지 않습니다
inspection.message.write.access.to.readonly.property.outside.declaration.scope.ret.by.ref='readonly' 프로퍼티는 참조로 반환되며 선언 범위 밖에서는 누수될 수 있습니다
inspection.message.array.key.unused=배열 키가 사용되지 않습니다
refactoring.inline.variable.unary.operation=증가 혹은 감소 작연산으로 인라인화할 수 없습니다
inspection.message.variable.already.equal.to.assigned.value=변수가 이미 대입된 값과 같습니다
inspection.php.modulo.operation.with.one=피연산자가 '1'인 나머지 연산
intention.family.name.replace.with.zero=''{0}''(으)로 바꾸기
inspection.message.expression.always.choice=표현식이 항상 ''{0}''입니다
intention.family.name.replace.with.compile.time.result=컴파일타임 결과로 바꾸기
inspection.php.deprecated.serializable.interface.usage.inspection.display.name=지원 중단된 'Serializable' 인터페이스 사용
class.implements.the.serializable.interface.which.is.deprecated='Serializable' 인터페이스를 '__serialize()'/'__unserialize()' 메서드 없이 구현하는 것은 더 이상 지원되지 않습니다
add.serialize.magic.methods={0} 메서드 추가
add.serialize.magic.method={0} 메서드 추가
refactoring.move.classes.dnd.name=클래스 이동
refactoring.move.classes.dnd.title=선택한 {0,choice,0#클래스|1#네임스페이스|2#클래스 및 네임스페이스}를 다음의 네임스페이스로 이동:
group.advanced.settings.php=PHP
advanced.setting.php.max.chain.resolve.depth=멤버 참조 해결 시 최대 깊이
function.has.parameter.with.incompatible.default.value.type=디폴트 값이 선언된 타입과 호환되지 않는 매개변수가 함수에 있습니다
inspection.php.unit.deprecated.call.in.phpunit.10=메서드는 PHPUnit 10에서 지원 중단되었습니다
intention.family.name.replace.with.suggested.call.in.phpunit=PHPUnit 10에서 제안되는 호출로 대체
inspection.message.function.deprecated.will.be.removed.in.phpunit=메서드가 더 이상 사용되지 않으며 PHPUnit 10에서 제거되었습니다
code.style.option.force.empty.functions.braces.in.one.line=빈 함수/메서드에 중괄호를 한 줄로 배치
inspection.php.autovivification.on.false.values.possible=지원 중단된 'false'가 배열로 변환될 수 있습니다
php.change.signature.conflict.with.local.var=매개변수 ''{0}''이(가) ''{1}'' 함수 내 지역 변수와 충돌합니다
php.change.signature.conflict.with.local.var.method=매개변수 ''{0}''이(가) ''{2}''의 ''{1}'' 메서드 내 지역 변수와 충돌합니다
refactoring.move.classes.dnd.files.with.the.same.name.error=단일 대상에서 같은 이름을 가진 파일은 여러 개일 수 없습니다.
dialog.message.execution.quality.tools.in.untrusted.project.prohibited=신뢰할 수 없는 프로젝트에서 품질 도구를 실행하는 것은 금지되어 있습니다
untrusted.composer.dialog.text=종속성 설치 및 업데이트 혹은 Composer 명령어 실행은 잠재적으로 악성 코드를 실행할 수 있습니다.
inspection.undefined.field.notify.dynamic.read=동적 프로퍼티에 대한 읽기 액세스 알림
inspection.php.too.long.member.reference.chain=멤버 참조 체인이 분석하기에 너무 깁니다
php.test.framework.untrusted.reload=안전 모드에서는 테스트 프레임워크의 버전을 새로 고칠 수 없습니다
inspection.message.instanceof.checks.in.catch.can.be.replaced.with.specific.catches='catch' 블록 내의 'instanceof' 확인을 특정 catch로 바꿀 수 있습니다
inspection.php.instanceof.checks.in.catch.can.be.replaced.with.specific.catches='catch' 블록 내의 'instanceof' 확인을 특정 catch로 바꿀 수 있습니다
intention.family.name.replace.instanceof.checks.in.catch.with.specific.catches='catch' 블록 내의 'instanceof' 확인을 특정 catch로 바꾸기
no.in.line.parameter.name.hints.will.be.shown.for.methods.matching.any.of.these.patterns=이러한 패턴 중 하나라도 일치하는 메서드에 대해서는 인레이 매개변수 이름 힌트가 표시되지 않습니다.
patterns.are.matched.on.fully.qualified.name.parameter.count.and.parameter.names=패턴은 완전히 정규화된 이름, 매개변수 개수 및 매개변수 이름에 대해 일치합니다.
you.can.always.add.a.precise.exclusion.via.alt.enter.and.then.edit.it.to.broaden.as.needed=언제든지 Alt-Enter를 눌러 정확하게 제외하고 필요에 따라 편집하여 확장할 수 있습니다.
code.global.code.matches.function.with.two.parameters={0}은(는) 매개변수가 2개 있는 함수와 일치합니다.
code.info.code.matches.all.single.parameter.methods.where.the.parameter.name.ends.with.em.info.em={0}은(는) 매개변수 이름이 {1}(으)로 끝나는 모든 단일 매개변수와 일치합니다.
code.key.value.code.matches.all.methods.with.parameters.em.key.em.and.em.value.em={0}은(는) 매개변수 {1} 및 {2}이(가) 있는 모든 메서드와 일치합니다.
code.fully.qualified.classname.methodname.key.value.code.example.precise.match={0}은(는) 정확한 제외의 예시입니다.
key=키
value=값
inspection.php.if.can.be.replaced.with.match.expression='if'를 'match' 식으로 바꿀 수 있습니다
intention.family.name.replace.if.with.match.expression='if'를 'match' 식으로 바꾸기
inspection.message.can.be.replaced.with.match.expression='if' 문을 'match' 식으로 바꿀 수 있습니다
inspection.php.duplicate.operand.in.comparison=비교에서 중복되는 피연산자
intention.family.name.remove.duplicate.operand=중복 피연산자 제거
inspection.message.expression.have.duplicate.operand=표현식에 피연산자 {0}이(가) 중복됩니다
refactoring.inline.function.cannot.inline.first.class.callable.declaration=일급 callable 선언을 인라인화할 수 없습니다
php.replace.try.from.with.null.quick.fix.family.name='tryFrom()' 호출을 'null'로 바꾸기
replace.all.occurrences.without.side.effects=모든 찾은 위치를 부수효과 없이 바꾸기
inspection.php.class.constant.can.be.final=클래스 상수는 'final'일 수 있습니다
inspection.message.can.be.final='final'일 수 있습니다
intention.family.name.make.final='final'로 만들기
inspection.php.array.append.using.count=배열에 값을 추가할 때 'count()'를 색인으로 사용
inspection.message.count.used.as.array.index.to.append.element=요소를 추가할 때 'count'가 배열 색인으로 사용됩니다
inspection.php.pointless.boolean.expression='if' 조건문 내의 의미 없는 bool 표현식
inspection.message.pointless.boolean.expression=bool 표현식을 단순화할 수 있습니다
inspection.php.rand.arguments.in.revers.order=잘못 정렬된 'rand' 함수 인수
inspection.message.max.must.be.greater.than.or.equal.to.argument.min='max' 인수는 'min' 이상이어야 합니다
info=정보
quickfix.change.field.type.to.match.super.0=상위 항목과 일치하도록 타입을 ''{0}''(으)로 변경
quickfix.change.field.type.to.match.super.remove=상위 항목과 일치하도록 타입 선언 제거
inspection.message.readonly.property.non.readonly='readonly' 프로퍼티를 'readonly'가 아닌 것으로 다시 선언할 수 없습니다
inspection.message.non.readonly.property.readonly='readonly'가 아닌 프로퍼티를 'readonly'로 다시 선언할 수 없습니다
intention.family.name.remove.readonly.modifier='readonly' 제어자 제거
intention.family.name.add.readonly.modifier='readonly' 제어자 추가
inspection.php.unit.invalid.mocking.target=잘못된 PHPUnit 모의 시험 대상
inspection.message.methods.cannot.be.mocked=''{0}'' 메서드는 모의 시험할 수 없습니다
final=final
enum=열거형
inspection.message.classes.cannot.be.doubled=''{0}'' 클래스는 이중화할 수 없습니다
inspection.message.cannot.stub.or.mock.using.method.list.that.contains.duplicates=중복이 있는 메서드 목록으로 스텁 혹은 모의 시험할 수 없습니다
intention.family.name.navigate.to.duplicate.method.name=중복 메서드로 이동
inspection.php.property.can.be.readonly=프로퍼티는 'readonly'일 수 있습니다
inspection.message.property.can.be.readonly=프로퍼티는 'readonly'일 수 있습니다
text.plain=텍스트/일반
enum.value.cannot.referer.to.enum.cases=열거형 값은 열거형 case를 참조할 수 없습니다
inspection.php.internal.array.index.reset.is.unnecessary.navigate.to.function=\ 배열 내부 포인터를 초기화하는 함수로 이동
inspection.php.pow.call.can.be.replace.with.pow.operator='pow()' 호출을 '**' 연산자로 바꿀 수 있습니다
replace.with.pow.operator='**' 연산자로 바꾸기
group.methods.by.type=유형으로 메서드 그룹화
inspection.php.private.method.may.be.inaccessible.in.late.static.binding.call=Private 메서드는 지연 정적 바인딩 호출 중에 액세스가 불가할 수 있습니다
inspection.message.existing.overriding.private.method.may.be.inaccessible=기존의 재정의하는 private 메서드는 액세스가 불가할 수 있습니다
inspection.message.existing.overriding.private.method.may.be.inaccessible.method=재정의하는 private 메서드 ''{0}''은(는) 액세스가 불가할 수 있습니다
intention.family.name.navigate.to.possibly.inaccessible.methods=액세스가 불가할 수 있는 메서드로 이동
overriding.private.methods=재정의하는 private 메서드
refactoring.inplace.extract.method.name=인플레이스 함수/메서드 추출
PhpExtractMethodDialog.generate.php.doc.inplace=PHPDoc 생성
extract.method.link.label.more.options=기타 옵션
inspection.php.short.echo.open.tag.description=짧은 echo 여는 태그 사용 위치
replace.all.occurrences.with.php.echo=모든 찾은 항목을 '<?php echo'로 바꾸기
inspection.php.short.open.echo.tag.inspection.display.name=짧은 여는 'echo' 태그 사용 위치
inspection.php.autoload.declaration.is.deprecated=더는 사용되지 않는 '__autoload()' 함수 선언
intention.family.name.replace.with.spl.autoload.register.call='spl_autoload_register()' 호출로 대체
inspection.message.deprecated.autoload.declaration='__autoload()' 선언은 더는 사용되지 않습니다
inspection.message.prohibited.autoload.declaration='__autoload()' 선언은 금지되었습니다
inspection.option.label.php73.severity=PHP 7.3 심각도:
inspection.php.assert.declaration.is.deprecated=더는 사용되지 않는 'assert()' 함수 선언
inspection.message.defining.custom.assert.function.forbidden=사용자 지정 'assert()' 함수를 정의하는 것은 금지되었습니다
inspection.message.defining.custom.assert.function.deprecated=사용자 지정 'assert()' 함수를 정의하는 것은 더는 사용되지 않습니다
inspection.php.preg.match.can.be.replaced.with.comparison='preg_match()'은(는) 비교로 바꿀 수 있습니다
checkbox.use.composer='composer.json' 추가
border.title.require.dependencies='require' 종속성
border.title.require.dev.dependencies='require-dev' 종속성
require='필수'
status.text.no.dependencies=종속성 없음
border.title.additional.dependencies=추가적인 종속성
inspection.php.redundant.modifier.key=불필요한 제어자
inspection.php.redundant.modifier=불필요한 ''{0}'' 제어자
inspection.php.remove.modifier=''{0}'' 제어자를 제거합니다
inspection.php.unsupported.modifier.key=지원되지 않는 제어자
inspection.php.unsupported.modifier=제어자 ''{0}''은(는) PHP {1}부터 지원되지 않습니다
inspection.php.unknown.modifier=알 수 없는 제어자 ''{0}''
action.enable.plugin.text=''{0}'' 플러그인 활성화
inspection.php.deprecated.modifier=제어자 ''{0}''은(는) PHP {1}부터 사용되지 않습니다
inspection.php.type.tag.without.variable.name=변수 이름 없이 태그를 입력하세요
inspection.message.doc.tag.without.variable.name.doesn.t.provide.type.information.for.any.expression=변수 이름이 없는 문서 태그는 그 어떠한 표현식에 관한 타입 정보도 제공하지 않습니다
intention.family.name.add=''${0}'' 추가
intention.family.name.add.variable.name=변수 이름 추가
inspection.php.int.ranges.mismatch=숫자 범위 불일치
inspection.message.value.ranges.mismatch.expected.actual=값 범위가 불일치합니다. 필요: {0}, 실제: {1}
notification.content.usage.found.in.project=프로젝트에서 {0} 사용 위치를 찾을 수 없습니다
inspection.php.inappropriate.inherit.doc.usage.class.description=doc 주석을 가진 상위 클래스가 없는 클래스에 대해 @inheritDoc이 사용됨
code.style.option.multiline.arrays.lambdas=여러 줄인 배열/익명 함수를 여러 줄의 인수로 간주
composer.version.update.hint=현재 버전과 설치된 패키지에서 사용할 수 있는 업데이트입니다.
inspection.static.member.accessed.via.instance.reference=static 멤버 ''{0}''이(가) 인스턴스 참조를 통해 액세스됩니다
quickfix.access.static.via.class.reference=''{0}''(으)로 바꾸기
quickfix.can.not.find.class.reference.name=이름으로 클래스르 찾을 수 없음
inspection.php.class.static.member.accessed.via.instance.inspection.display.name=클래스의 static 멤버가 인스턴스를 통해 액세스되었습니다
inspection.php.loop.can.be.replaced.with.in.array=루프를 'in_array()' 또는 'array_key_exists()' 호출로 바꿀 수 있습니다.
inspection.message.loop.can.be.replaced.with.0=루프를 ''{0}()''(으)로 바꿀 수 있습니다.
PhpInterpreterConfigurable.php.ini.title=구성 디렉터리 파일 혹은 선택
php.interpreter.custom.ini.label=구성 파일:
label.system.php=시스템 PHP
checkbox.add.a.comma.after.last.parameter=매개변수 목록의 마지막 매개변수 뒤에 쉼표 추가
checkbox.add.a.comma.after.last.var.in.closure.use.list=클로저 사용 목록의 마지막 변수 뒤에 쉼표 추가
inspection.php.preg.split.can.be.replaced.with.explode='preg_split'은 'explode'로 대체될 수 있습니다
intention.family.name.replace.array.traversable.with.iterable='array|Traversable'을 'iterable'로 대체
inspection.message.array.traversable.can.be.replaced.with.iterable=타입 힌트 'array|Traversable'은 'iterable'로 대체될 수 있습니다
inspection.php.array.traversable.can.be.replaced.with.iterable=타입 힌트 'array|Traversable'은 'iterable'로 대체될 수 있습니다
intention.family.name.combine.multiple.isset.calls.into.one=여러 'isset' 호출을 하나로 합치기
inspection.message.multiple.isset.calls.can.be.combined.into.one=여러 'isset' 호출은 하나로 합쳐질 수 있습니다
inspection.php.multiple.isset.calls.can.be.replaced.with.one=여러 'isset' 호출은 하나로 대체될 수 있습니다
checkbox.add.a.comma.after.last.argument.in.function.call=함수 호출의 마지막 인수 뒤에 쉼표 추가
php.enum=열거형
inspection.php.unit.failed.line=테스트에서 불합격한 줄
inspection.php.mockery.invalid.mocking.target=잘못된 Mockery 모의 시험 대상
inspection.mockery.protected.method.cannot.be.mocked='protected' 메서드는 'Mock.shouldAllowMockingProtectedMethods'를 호출하지 않고 모의 시험할 수 없습니다
intention.family.name.add.should.allow.mocking.protected.methods.call='shouldAllowMockingProtectedMethods' 호출 추가
inspection.php.open.echo.tag.inspection.display.name='echo' 태그 사용 위치 열기
replace.all.occurrences.with.short.php.echo=모든 찾은 항목을 '<?='로 바꾸기
php.external.formatter.title=외부 서식 지정 도구
external.formatter.phpcsfixer=PHP CS Fixer
external.formatter.phpcbf=PHP Code Beautifier 및 Fixer
no.external.formatter=외부 서식 지정 도구 없음
external.formatter.couldnt.run.tool={0}을(를) 시작할 수 없습니다. 구성을 확인하세요. 
php.external.formatter=PHP 외부 서식 지정 도구
notification.content.formatter.couldn.t.apply.result.external.tool=서식 지정 도구가 외부 도구의 결과를 적용할 수 없습니다
notification.content.process.exited.with.non.zero.code=0이 아닌 코드와 함께 프로세스가 종료되었습니다
notification.group.composer.language.level=Composer 언어 수준 동기화가 비활성화되었습니다
notification.group.php=PHP
notification.group.php.interpreters=PHP 인터프리터 문제
notification.group.php.profiler=PHP 프로파일러 문제
notification.group.php.code.style=PHP 코드 스타일 검사가 제안되었습니다
notication.group.php.debugger=PHP 디버거
notification.group.phpunit=PHPUnit
notification.group.default.stubs=PHP 디폴트 스텁 경로가 올바르지 않음
notification.group.debug.listener=PHP 디버그 리스너
notification.group.quality.tools=PHP 외부 품질 도구
notification.group.dbgp.proxy=PHP 디버거 프록시
notification.group.php.cgi=PHP-CGI 서버
notification.group.composer.install=Composer 'install' 명령어가 제안됨
inspection.php.invalid.delimiter.key=잘못된 구분자
inspection.php.regexp.delimiter.is.alphanumeric.or.backslash=구분자는 알파벳, 숫자 혹은 백슬래시이어야 합니다
inspection.php.regexp.delimiter.is.used.in.reg.exp=구분자가 정규식에 사용되었습니다
inspection.php.regexp.replace.with.valid.delimiter=올바른 구분자로 바꾸기
bit.shift.by.negative.number=음수로 비트 시프트
shows.dialog.with.methods.from.implemented.interface.selected.methods.will.be.inserted.into.the.class.after.dialog.confirmation=구현된 인터페이스의 메서드가 있는 대화상자를 표시합니다. 선택한 메서드는 대화상자에서 확인되면 클래스에 삽입됩니다.
inspection.php.preg.replace.with.empty.replacement.name='preg_replace()'를 '(l|r)trim' 호출로 대체 가능
rerun.with.ignore.platform.reqs=--ignore-platform-reqs로 다시 실행
platform.reqs.are.missing=플랫폼 요구 사항이 누락되었습니다.
notification.content.composer.executable.was.automatically.set.to.global.composer=Composer 실행 파일이 자동으로 전역 'composer'로 설정되었습니다
notification.content.configure.manually=수동으로 설정
border.title.options=옵션
the.button.shows.whether.inspection.is.on.or.off=이 버튼은 검사가 켜져 있는지 여부를 표시합니다
config.file.doesnt.exist=구성 파일이 없습니다
robo=Robo
robo.task.method=Robo 작업 메서드
turn.off.external.formatter=외부 서식 지정 도구 끄기
add.to.excluded.files.action=''{0}''을(를) 무시되는 파일에 추가
inspection.php.preg.match.redundant.closure=불필요한 클로저 '.*'
quality.inspection.button.tooltip=해당하는 검사가 켜져 있는지 아닌지 표시하는 버튼입니다
inspection.php.dynamic.field.declaration=동적 프로퍼티 선언
PhpLanguageLevel.8.2.0.presentable.name=8.2
PhpLanguageLevel.8.2.0.short.description='readonly' 클래스, 'true' 타입, 단독 'null' 및 'false'
inspection.option.label.php.severity=PHP {0} 심각도:
inspection.property.declared.dynamically=프로퍼티가 dynamic으로 선언되었습니다.
inspection.property.declared.dynamically.deprecated=프로퍼티가 동적으로 선언되었으나 이는 PHP 8.2부터 더는 사용되지 않습니다
intention.family.name.add.attribute.to=''#[{0}]''을(를) ''{1}''에 추가
intention.family.name.remove.attribute=''#[{0}]'' 제거
cannot.apply.0.to.trait={0}을(를) 특성에 적용할 수 없습니다
cannot.apply.0.to.interface={0}을(를) 인터페이스에 적용할 수 없습니다
php.title.docker.compose.settings=Docker Compose 설정
PhpLanguageFeature.readonly.classes='readonly' 클래스는 PHP 8.2 이후 버전에서만 허용됩니다
inspection.message.non.readonly.class.cannot.extend.readonly.class=''readonly''가 아닌 클래스는 ''readonly''인 클래스 ''{0}''을(를) 확장할 수 없습니다
inspection.message.readonly.class.cannot.extend.non.readonly.class=''readonly'' 클래스는 ''readonly''가 아닌 클래스 ''{0}''을(를) 확장할 수 없습니다
cannot.apply.0.to.readonly.class={0}을(를) ''readonly'' 클래스에 적용할 수 없습니다
intention.family.name.replace.readonly.with.public='readonly'를 'public'으로 대체
intention.family.name.delete.readonly='readonly' 삭제
inspection.message.readonly.modifier.redundant='readonly' 제어자는 불필요합니다
cannot.declare.static.properties.in.readonly.class='readonly' 클래스에서 'static' 프로퍼티를 선언할 수 없습니다
type.primitive.false.null.hints.names.are.forbidden=이름이 'false' 및 'null'인 타입 힌트는 PHP 8.0 이후에서만 허용됩니다
type.primitive.true.hints.names.are.forbidden=이름이 'true'인 타입 힌트는 PHP 8.2부터 허용됩니다
type.contains.both.true.and.false.bool.should.be.used.instead=타입에 true 및 false가 모두 포함되어 있습니다. bool을 대신 사용하세요
inspection.message.class.can.be.readonly=클래스는 'readonly'일 수 있습니다
intention.family.name.make.class.readonly=클래스를 'readonly'로 만들기
PhpLanguageFeature.standalone.null.false='null'과 'false'를 독립적인 타입으로 사용하는 것은 PHP 8.2 이후에서 허용됩니다
PhpLanguageFeature.true.type=이름이 'true'인 타입 힌트는 PHP 8.2부터 허용됩니다
flip.key.value.intention.family.name=키와 값 바꾸기
flip.key.value.intention.message.all.in.array=배열 내 모든 키와 값을 바꾸기
flip.key.value.intention.message.single=키와 값 바꾸기
PhpLanguageFeature.intersection.and.union.in.same.type=교차 및 공용체 타입은 PHP 8.2부터만 혼용할 수 있습니다
intention.family.name.unwrap.intersection.type=교차 타입 래핑 해제
usage.of.intersection.types.grouping.is.allowed.only.as.part.of.union.type=교차 타입 그룹화는 공용체 타입의 일부로만 가능합니다
intention.family.name.replace.with.union.type=공용체 타입으로 바꾸기
only.intersection.type.can.be.used.for.grouping=교차 타입만 그룹화에 사용할 수 있습니다
only.intersection.type.can.be.used.for.grouping1=교차 타입만 그룹화에 사용할 수 있습니다
nested.type.groups.are.not.allowed=중첩 타입 그룹화는 허용되지 않습니다
intention.family.name.group.intersection.types=교차 타입 그룹화
type.0.is.redundant.as.it.is.more.restrictive.than.type.1=타입 ''{0}''은(는) 타입 ''{1}''보다 더 제한적이므로 불필요합니다
action.quality.tools.provider.description=파일이 외부 품질 도구 분석 및 서식 지정 도구에서 배제되었습니다
action.quality.tools.provider=품질 도구
quality.tools.provider.tooltip=이 파일은 외부 품질 도구 분석 및 서식 지정에서 배제되었습니다. 파일을 무시되는 파일 목록에서 제거할 수 있습니다.
remove.from.ignored.list=제거
php.debug.state.widget=디버그 리스닝 중단/시작
inspection.php.deprecated.dollar.brace.string.interpolation=더는 사용되지 않는 '${' 문자열 보간
inspection.message.using.in.strings.deprecated.use.instead=문자열에서 {0}을(를) 사용하는 것은 더는 지원되지 않으므로 대신 {1} 을(를) 사용하세요
inspection.message.using.variable.variables.in.strings.deprecated.use.instead=가변 변수 {0}을(를) 문자열에서 사용하는 것은 더는 지원되지 않으므로 {1}을(를) 대신 사용하세요
intention.family.name.replace.with.interpolation='{$' 보간으로 대체
PhpLanguageFeature.constants.in.traits=특성 내 상수는 PHP 8.2 이후 버전에서만 허용됩니다
inspection.php.deprecated.partially.supported.callables.display.name=부분적으로 지원되는 callable은 더 이상 사용되지 않음
use.0.in.callables.is.deprecated=callable 내에서 ''{0}''을(를) 사용하는 것은 더는 지원되지 않습니다
deprecated.form.of.callables=지원이 중단된 형태의 callable
replace.deprecated.from.of.callable=지원이 중단된 형태의 callable을 대체
action.synonym.listening=리스닝
action.synonym.stop.listening=PHP Xdebug 연결 리스닝 중지
action.synonym.start.listening=PHP Xdebug 연결 리스닝 시작
null.cannot.be.marked.as.nullable='null'을 nullable로 지정할 수 없습니다
intention.family.name.unwrap.type=타입 래핑 해제
add.constant.0.to.class.1.and.opens.containing.file.in.editor=상수 ''{0}''을(를) 클래스 ''{1}''에 추가하고 이를 포함하는 파일을 에디터에서 엽니다
PhpUnitConfigurableForm.phpunit.paratest.is.empty=ParaTest의 경로가 비어있습니다
PhpUnitConfigurableForm.can.not.find.paratest=''{0}''에서 ParaTest를 찾을 수 없습니다''
PhpUnitConfigurableForm.paratest.path=기본 ParaTest 바이너리
PhpUnitConfigurableForm.use.paratest=ParaTest 사용:
creates.new.class.0.in.a.separate.file=별도의 파일에 이름이 ''{0}''인 새로운 클래스를 만듭니다
creates.new.class.method.0.in.a.separate.file=별도의 파일에 이름이 ''{0}''이고 메서드 ''{1}''이(가) 있는 새로운 클래스를 만듭니다
cannot.declare.dynamic.properties.in.readonly.class='readonly' 클래스에서 동적 프로퍼티를 선언할 수 없습니다
paratest=ParaTest
run.with.paratest=ParaTest를 사용하여 실행
run.with.paratest.mnemonic=%s을(를) ParaTest를 사용하여 실행
paratest.is.not.supported.for.selected.run.profile=ParaTest가 선택한 실행 프로파일과 호환되지 않습니다
PhpUnitConfigurableForm.default.paratest.binary=기본 ParaTest 바이너리:
paratest.runner.description=ParaTest로 선택한 구성을 실행합니다
inspection.php.var.export.used.without.return.argument='var_export' 혹은 'print_r' 호출이 'return' 인수 없이 사용되었습니다
intention.family.name.replace.true.argument.with.false='true' 인수를 'false'로 대체
intention.family.name.add.true.argument.to.var.export.call='var_export' 호출에 'true' 인수 추가
inspection.message.var.export.with.return.argument.equals.false.always.returns.null=''return'' 인수를 받은 ''{0}''는 ''false''와 같다는 항상 ''{1}''을(를) 반환합니다
inspection.message.var.export.without.return.argument.always.returns.null=''return'' 인수 없는 ''{0}''은(는) 항상 ''{1}''을(를) 반환합니다
inspection.php.name.variable.is.used.only.inside.closure=변수는 클로저 내에서만 사용됩니다
inspection.php.move.variable.inside.closure=클로저 내에서 변수 대입 이동
inspection.php.navigate.to.variable.assignment=변수 대입으로 이동
inspection.php.highlight.only.closures.with.multiple.statements.option=여러 구문이 있는 클로저만 강조 표시
label.configured.as.external.formatter={0}(으)로 구성됨
label.can.be.configured.as.external.formatter={0}(으)로 구성될 수 있음
opens.composer.json.to.change.php.property='php' 프로퍼티를 변경하기 위해 'composer.json' 열기
checkbox.add.a.comma.after.last.match.arm=마지막으로 일치하는 arm 뒤에 쉼표 추가
checkbox.show.class.namespace.separators=PHP 클래스 및 네임스페이스 구분자 표시
inspection.php.unpacking.arrays.with.string.keys.inspection=문자열 키가 있는 배열 패킹 해제는 PHP 8.1 이전 버전에서 금지됩니다
intention.family.name.replace.with.array.merge.expression='array_merge' 식으로 바꾸기
intention.family.name.show.example.date.time.output=예시 날짜 시간 출력 표시
refactoring.move.members.enum.0.already.contains.case.with.name.0=열거형 {0}은(는) 이미 이름이 ''{1}''인 케이스를 포함하고 있습니다
refactoring.move.members.enum.0.already.contains.case.with.value.1=열거형 {0}은(는) 이미 값이 ''{1}''인 케이스를 포함하고 있습니다
refactoring.move.members.class.0.does.not.exist=클래스 {0}이(가) 없습니다.\n\
생성하시겠어요?
refactoring.move.members.properties.can.not.be.moved.to.enum=프로퍼티를 enum으로 이동할 수 없습니다
refactoring.php.extract.enum=열거형 추출
refactoring.php.create.class=새 클래스 생성
refactoring.move.members.no.members.are.selected=선택된 멤버가 없습니다
php.debug.action.include.return.value.breakpoint.step.description=추가적으로 '함수에서 반환' 디버그 과정을 추가합니다
php.debug.action.watches.method.return.value.enable=함수 반환 값 디버그 켜기
php.debug.action.watches.method.return.value.unavailable.reason=반환 값 디버그는 Xdebug 3.2 이상에서만 지원됩니다
enable.return.function.value.debugging.xdebug.3.2=반환 함수 값 디버그 켜기(Xdebug 3.2+)
shows.list.of.child.classes.without.without.resolved.member=해결된 멤버가 없는 하위 클래스의 목록을 표시합니다
shows.list.of.child.classes.with.inaccessible.methods=액세스할 수 없는 메서드가 있는 하위 클래스의 목록을 표시합니다
add.slash.to.the.start=시작 부분에 '/' 추가
classes.can.not.have.backed.type=클래스는 백킹된 타입을 가질 수 없습니다
set.the.following.option=다음의 옵션을 설정: 
enables.inspection.0=검사 ''{0}''을(를) 활성화합니다
show.0.settings.window=''{0}'' 설정 창을 표시합니다
reformats.file.with.0={0}(으)로 파일 서식 다시 지정
enable.the.following.extension=PHP 런타임 옵션에서 다음의 확장 스텁을 활성화합니다.
shows.0.dialog=''{0}'' 대화상자를 표시합니다
list.of.causes.0=// 예외를 던질 수 있는 위치 목록:\n\
{0}
suppress.unused.preview=''{0}''(으)로 어노테이션된 엔티티에 대해 사용되지 않는 선언'' 조사를 억제합니다
navigate=... 이동
enable.navigate.links.for.class.and.member.references=클래스 및 멤버 추론에 '... 이동' 링크를 활성화
seconds.since.the.unix.epoch.january.1.1970.00.00.00.gmt=Unix 에포크, 1970년 1월 1일 00:00:00 GMT ({0}) 이후 시간(초)
rfc.2822.rfc.5322.formatted.date=RFC 2822/RFC 5322 형식 지정 날짜({0})
iso.8601.date=ISO 8601 날짜({0})
timezone.offset.in.seconds=시간대 오프셋(초)(-43200 ~ 50400)
timezone.abbreviation.if.known.otherwise.the.gmt.offset=시간대 약어(알려진 경우), 그렇지 않으면 GMT 오프셋(EST, MDT, +05)
the.same.as.p.but.returns.z.instead.of.00.00.available.as.of.php.8.0=P와 같지만, +00:00 대신 Z를 반환합니다. PHP 8.0 기준으로 사용 가능합니다(+02:00).
difference.to.greenwich.time.gmt.with.colon.between.hours.and.minutes=시간과 분 사이에 콜론을 사용하는 그리니치 시간(GMT)과의 차이(+02:00)
difference.to.greenwich.time.gmt.without.colon.between.hours.and.minutes=시간과 분 사이에 콜론을 사용하지 않는 그리니치 시간(GMT)과의 차이(+0200)
whether.or.not.the.date.is.in.daylight.saving.time.1.or.0=날짜가 일광 절약 시간제인지 여부(1 또는 0)
timezone.identifier=시간대 식별자(UTC, GMT, 대서양/아조레스)
milliseconds=밀리초 (654)
microseconds=마이크로초(654321)
seconds.with.leading.zeros=선행 0이 있는 초(00 ~ 59)
minutes.with.leading.zeros=선행 0이 있는 분(00 ~ 59)
24.hour.format.of.an.hour.with.leading.zeros=선행 0이 있는 24시간 형식 시간(00 ~ 23)
12.hour.format.of.an.hour.with.leading.zeros=선행 0이 있는 12시간 형식 시간(01 ~ 12)
24.hour.format.of.an.hour.without.leading.zeros=선행 0이 없는 24시간 형식 시간(0 ~ 23)
12.hour.format.of.an.hour.without.leading.zeros=선행 0이 없는 12시간 형식 시간(1 ~ 12)
swatch.internet.time=Swatch 인터넷 시간(000 ~ 999)
uppercase.ante.meridiem.and.post.meridiem.am.pm=대문자 오전과 오후(AM/PM)
lowercase.ante.meridiem.and.post.meridiem.am.pm=소문자 오전과 오후(am/pm)
a.two.digit.representation.of.a.year=두 자리 표시 연도(22)
a.full.numeric.representation.of.a.year.at.least.4.digits.with.for.years.bce=연도의 전체 숫자 표현, 최소 4자리, - 사용, BC 연도(2022)
an.expanded.full.numeric.representation.if.requried.or.a.full.numeral.representation.like.y=필요한 경우 확장된 전체 숫자 표현 또는 전체 숫자 표현(2022)
an.expanded.full.numeric.representation.of.a.year.at.least.4.digits.with.or=연도의 확장된 전체 숫자 표현, 최소 4자리, - 또는 + 사용(+2022)
iso.8601.week.numbering.year=ISO 8601 주 번호 연도(2022)
whether.it.s.a.leap.year.1.or.0=윤년인지 여부(1 또는 0)
number.of.days.in.the.given.month=지정된 월의 일 수(28 ~ 31)
numeric.representation.of.a.month.without.leading.zeros=월의 숫자 표현, 선행 0 없음(1 ~ 12)
a.short.textual.representation.of.a.month.three.letters=월의 짧은 텍스트 표현, 3자(Jan ~ Dec)
numeric.representation.of.a.month.with.leading.zeros=월의 숫자 표현, 선행 0 있음(01 ~ 12)
a.full.textual.representation.of.a.month.such.as.january.or.march=월의 전체 텍스트 표현(January ~ December)
iso.8601.week.number.of.year.weeks.starting.on.monday=ISO 8601 연도의 주 번호, 주는 월요일에 시작됨(42)
the.day.of.the.year.starting.from.0=연도의 일(0 ~ 365)
numeric.representation.of.the.day.of.the.week=요일의 일에 대한 숫자 표현(0 ~ 6)
english.ordinal.suffix.for.the.day.of.the.month.2.characters=월의 일에 대한 영어 서수 접미사, 2자(st, nd, rd, th)
iso.8601.numeric.representation.of.the.day.of.the.week=ISO 8601 주의 일에 대한 숫자 표현(1 ~ 7)
a.full.textual.representation.of.the.day.of.the.week=주의 일에 대한 전체 텍스트 표현(Sunday ~ Saturday)
day.of.the.month.without.leading.zeros=선행 0이 없는 월의 일(1 ~ 31)
a.textual.representation.of.a.day.three.letters=일의 텍스트 표현, 3자(Mon ~ Sun)
day.of.the.month.2.digits.with.leading.zeros=월의 일, 선행 0이 있는 2자리(01 ~ 31)
code.style.option.align.enum.cases=열거형 케이스 정렬
code.style.option.around.enum.cases=열거형 케이스 주변:
inspection.php.regexp.n.modifier.can.be.replaced.with.non.capturing.groups='n' 제어자는 비 캡처링 그룹으로 바꿀 수 있습니다
inspection.php.regexp.replace.n.modifier.with.non.capturing.groups='n' 제어자를 비 캡처링 그룹으로 바꾸기
refactoring.move.members.move.as.enum.cases=열거형 케이스 이동
readonly.property.cannot.have.default.value='readonly' 프로퍼티는 기본값을 가질 수 없습니다
debug.cannot.find.port=빈 포트를 찾을 수 없습니다
debug.check.firewall=방화벽 설정을 확인하세요
debug.port.is.updated=설정에서 지정된 포트 {0}이(가) 사용 중입니다. 포트 {1}은(는) 사용 가능하며 Xdebug에서 사용할 수 있습니다. {2}(으)로 php.ini를 업데이트하세요. 
action.copy.to.clipboard.text=클립보드에 복사
debug.ports.is.updated=설정에서 지정된 모든 포트가 사용 중입니다. 포트 {0}은(는) 사용 가능하며 Xdebug에서 사용할 수 있습니다. {1}(으)로 php.ini를 업데이트하세요. 
action.copy.port.to.clipboard.text=포트 값을 클립보드에 복사
php.web.server.validation.configure.phpinfo=<i>phpinfo()</i>의 전체 출력을 붙여넣으세요
php.web.server.validation.synonym=디버그 검증
PhpUnitConfigurableForm.specified.wrong.paratest.binary=잘못된 ParaTest 바이너리가 지정되었습니다. 대신 'paratest_for_phpstorm'을 사용하세요.
PhpUnitConfigurableForm.unsupported.paratest.version=<html>설치된 버전의 ParaTest는 PHPStorm과의 통합을 지원하지 않습니다.<br> ParaTest를 6.5.0 이상으로 업데이트하세요.</html>
php.web.server.validation.xdebug3.discover.client.no=<b>클라이언트 호스트 검색:</b> 끄기
inlay.hints.usages.text={0,choice, 0#0개의 사용 위치|1#1개의 사용 위치|2#{0,number}'{1,choice, |1#+}' 개의 사용 위치}
code.vision.implementations.hint={0, choice, 1#1개 구현|2#{0,number}'{1,choice, |1#+}'개 구현}
code.vision.overrides.hint={0, choice, 1#1개 재정의|2#{0,number}'{1,choice, |1#+}'개 재정의}
code.vision.inheritors.hint={0, choice, 1#1개 상속자|2#{0,number}'{1,choice, |1#+}'개 상속자}
debug.port.is.updated.descr=설정에서 지정된 포트 {0}이(가) 사용 중입니다. 포트 {1}은(는) 사용 가능하며 Xdebug에서 사용할 수 있습니다. 
php.web.server.validation.client.host.is.unreachable=<b>디버그 클라이언트 호스트:<b> 연결 불가능
php.web.server.validation.client.host.is.unreachable.descr=<i>xdebug.remote_host</i>(Xdebug 2의 경우), <i>xdebug.client_host</i>(Xdebug 3의 경우) 또는 zend_debugger가 제대로 구성되었는지 확인하세요. 값은 호스트 이름(예: localhost) 또는 PhpStorm이 실행되고 있는 시스템의 IP 주소일 수 있으며, 서버에서 ping할 수 있어야 합니다. Xdebug를 사용하는 경우, <i>xdebug.remote_connect_back</i>(Xdebug 2의 경우) 또는 <i>xdebug.discover_client_host</i>(Xdebug 3의 경우)를 문제 해결에 사용할 수 있습니다.
inspection.message.enum.field.reference.in.constant.expression.allowed.only.from.php=상수 표현식의 열거형 필드 참조는 PHP 8.2 이상에서만 허용됩니다
notification.group.php.plugin.suggestion=PHP 플러그인 제안
code.vision.used.in.hint={0}{1, choice, |1#+}에서 사용
inspection.message.always.true=조건은 항상 '{0,choice,0#false|1#true}'입니다.
checkbox.always.enable.php.code.background.highlighting=항상 PHP 코드 배경 강조 표시 활성화
add.port.in.ide.settings=설정에 포트 {0} 추가
php.web.server.validation.client.host.is.reachable=<b>디버그 클라이언트 호스트:<b> 연결 가능
php.web.server.validation.configure.phpinfo.desc=HTML 버전 복사 및 붙여넣기, HTML 소스 또는 <i>php -i</i> 출력 중 하나
refactoring.copy.class.name=클래스 복사
copy.to.namespace=대상 네임스페이스:
label.new.name=새 이름:
global.variable.from.globals.array.assignment=$GLOBALS 배열 대입의 전역 변수
php.web.server.validation.configure.validation.script=유효성 검사 스크립트 아카이브를 다운로드하고 웹 경로를 스크립트 디렉터리에 지정하세요
php.web/server.validation.validation.script=디버그 유효성 검사 스크립트
label.failed=실패
download.validation.script=Xdebug 유효성 검사 스크립트 다운로드
link.label.go.to.documentation=문서로 이동
php.web.server.validation.failed.to.unzip={0}에서 데이터를 추출할 수 없음 
cannot.use.positional.argument.after.argument.unpacking.named.argument.81=인수 압축 풀기 뒤 위치 인수는 PHP 8.1 이상에서만 사용할 수 있습니다
php.web.server.validation.client.phpstorm.is.reachable=<b>PhpStorm:</b> Xdebug 연결을 수신할 준비가 되었습니다
php.web.server.validation.client.phpstorm.is.unreachable=<b>PhpStorm:</b> Xdebug 연결을 수신할 수 없음
intention.php.replace.class.with.enum=클래스를 열거형으로 바꾸기
intention.php.replace.class.with.enum.title=클래스를 열거형으로 바꾸기
intention.php.replace.class.with.enum.error.message=생성자 호출로 인해 클래스를 열거형으로 바꿀 수 없습니다
inspection.php.redeclaration.stdlib.function=표준 라이브러리 함수 다시 선언
inspection.php.redeclaration.stdlib.function.description=표준 라이브러리 함수 ''{0}''을(를) 다시 선언할 수 없습니다
notification.title.paratest.doesn.t.support.filter.option=ParaTest는 --filter 옵션을 지원하지 않습니다
notification.content.tests.have.been.run.without.paratest=테스트가 ParaTest 없이 실행되었습니다
notification.content.disable.paratest=ParaTest 비활성화
notification.paratest.mute=끄기
xdebug.validation.download.script.label=스크립트 명령어 다운로드:
xdebug.validation.ip.not.found={0}을(를) 자동 탐지 IDE IP에서 찾을 수 없습니다
xdebug.validation.ip.not.found.descr=자동 탐지된 IDE IP: {0}
php.debug.validate.got.it=디버그 유효성 검사
php.debug.validate.got.it.descr=디버그 유효성 검사 대화상자에서 해당 설정에 대한 유효성 검사를 할 수 있습니다 
show.validation.dialog=Xdebug 유효성 검사 대화상자 표시
php.web.server.validation.client.phpstorm.is.unreachable.descr=수신되는 디버그 연결 리스닝이 비활성화되었거나, 수신되는 연결에 대한 잘못된 포트가 설정에 지정되었을 수 있습니다
add.global.variable.quick.fix.family.name=전역 변수 추가
add.global.variable.quick.fix.text=''global ${0}'' 추가
docker.host.name.error=호스트 이름이 <i>host.docker.internal</i>과 다릅니다
docker.host.name.error.descr=<i>host.docker.internal</i>은 호스트에서 사용하는 내부 IP 주소로 확인됩니다.
php.web.server.validation.os=<b>클라이언트 호스트 운영 체제:</b> {0}
php.web.server.validation.os.server=<b>서버 호스트 운영 체제:</b> {0}
switching.from.another.vs.code.sublime.text.or.another.ide.check.out.our.migration.guides.to.get.started.faster=VS Code, Sublime Text 또는 다른 IDE에서 전환하시겠습니까? 더 빠르게 시작하려면 마이그레이션 가이드를 확인하세요.
choose.test.method.to.run.dataset.0=데이터세트 {0}을(를) 실행할 테스트 메서드 선택
advanced.setting.php.code.vision.limit=Code Vision: 검색할 최대 사용 위치 수
actions.detect.namespace.roots.progress.title=PSR-0 네임스페이스 루트 탐지 중…
php.web.server.validation.synonym2=Xdebug 유효성 검사