jvm.inspections.group.name=Lenguaje JVM
jvm.inspections.unstable.api.usage.display.name=Usando API inestable
jvm.inspections.unstable.api.usage.annotations.list=Anotaciones API inestables
jvm.inspections.unstable.api.usage.ignore.inside.imports=ignorar dentro de la declaración de importación
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=이 프로젝트에서 선언된 API 무시
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' está marcado como inestable en @ {1}.
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}''이(가) @{3}(으)로 표시된 불안정한 {1} ''{2}''에서 선언되었습니다.
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=El método anulado ''{0}'' está marcado como inestable en @ {1}.
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=Método anulado ''{0}'' marcado como inestable {1 como @ {3}} Declarado en '' {2 } ''.
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' marcado como @ {3} inestable {1} ''{2}'' se hace referencia por su firma y, por lo tanto, es inestable
jvm.inspections.scheduled.for.removal.future.version=Versiones futuras
jvm.inspections.scheduled.for.removal.predefined.version=versión {0}
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' está a punto de eliminarse de {1}.
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' está programado para ser eliminado de {3} ''{2}'' ha sido declarado en
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=El método anulado ''{0}'' está a punto de ser eliminado de {1}.
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=El método reemplazado ''{0}'' programado para ser eliminado de {3} {1} ''{2}'' fue declarado.
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' se eliminará de {3} {1 } ''{2}'' se hace referencia en su firma y se eliminará
jvm.inspections.unstable.type.used.in.signature.display.name=Tipo inestable utilizado en la firma
jvm.inspections.unstable.type.used.in.class.signature.description=Anotado ''@{0} '' porque la clase hace referencia al tipo inestable ''{1}'' en su declaración, debería ser
jvm.inspections.unstable.type.used.in.method.signature.description=Anotado ''@{0} '' porque el método hace referencia al tipo inestable ''{1}'' en su firma debe ser
jvm.inspections.unstable.type.used.in.field.signature.description=El campo está anotado con ''@{0} '' porque hace referencia al tipo inestable ''{1}'' debería ser
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=Falta la anotación '' @Deprecated '' en la API que se eliminará
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=Las API que se eliminarán también deben estar marcadas con la anotación '' @Deprecated ''.
jvm.inspections.must.already.be.removed.api.display.name=La API ya ha sido eliminada.
jvm.inspections.must.already.be.removed.api.earlier.version.description=La API se ha eliminado de {0} pero la versión actual es {1}.
jvm.inspections.must.already.be.removed.api.current.version.description=La API se ha eliminado de la versión actual {0}.
jvm.inspections.blocking.method.problem.descriptor=Llamada al método de bloqueo no válida.
jvm.inspections.blocking.method.display.name=Llamada al método de bloqueo de subprocesos no válida
jvm.inspections.blocking.method.annotation.blocking=Bloqueo de anotaciones
jvm.inspections.blocking.method.annotation.non-blocking=Non-Blocking 어노테이션
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=Agregar anotación de bloqueo
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=Non-Blocking 어노테이션 추가
jvm.inspections.blocking.method.annotation.configure.empty.text=No se agregaron anotaciones.
jvm.inspections.api.no.extension.display.name=La clase, la interfaz o el método no deben extenderse
jvm.inspections.api.no.extension.class.description=La clase ''{0}'' no debe extenderse.
jvm.inspections.api.no.extension.interface.implement.description=La interfaz ''{0}'' no debe implementarse.
jvm.inspections.api.no.extension.interface.extend.description=La interfaz ''{0}'' no debe extenderse.
jvm.inspections.api.no.extension.method.overriding.description=El método ''{0}'' no debe anularse.
jvm.inspections.api.override.only.display.name=Los métodos solo se pueden anular
jvm.inspections.api.override.only.description=El método ''{0}'' solo se puede anular.
jvm.inspections.dependency.display.name=잘못된 패키지 종속성
jvm.inspections.dependency.edit.rules.text=종속성 규칙 "{0}" 편집
jvm.inspections.dependency.edit.rules.family=종속성 규칙 편집
jvm.inspections.dependency.configure.button.text=종속성 규칙 구성
jvm.inspections.dependency.violator.problem.descriptor=종속성 규칙 ''{0}.''이(가) 위반되었습니다
jvm.inspections.testonly.display.name=프로덕션 코드 내 테스트 전용 사용 위치
jvm.inspections.testonly.class.reference=테스트 전용 클래스가 프로덕션 코드에서 참조됩니다
jvm.inspections.testonly.field.reference=테스트 전용 필드가 프로덕션 코드에서 참조됩니다
jvm.inspections.testonly.method.call=테스트 전용 메서드가 프로덕션 코드에서 호출됩니다
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting은 @TestOnly 코드에서 의미가 없습니다
jvm.inspections.string.touppercase.tolowercase.without.locale.description=<code> String. Se llama a {0} ()</code> sin especificar una configuración regional que utilice una cadena internacionalizada.\#loc
can.t.build.uast.tree.for.file=No se pudo construir el árbol UAST para el archivo.
title.uast=UAST
current.version=Versión actual
dialog.title.choose.annotation=Seleccione {0}
jvm.inspection.test.failed.line.display.name=테스트에서 실패한 줄
jvm.inspections.source.to.sink.flow.display.name=안전하지 않은 문자열이 안전한 메서드로 전달됨
jvm.inspections.junit5.converter.display.name=JUnit 4 테스트가 JUnit 5가 될 수 있음
jvm.inspections.junit5.converter.problem.descriptor=#ref이(가) JUnit 5 테스트일 수 있습니다
jvm.inspections.junit5.converter.quickfix=JUnit 5로 마이그레이션
jvm.inspections.junit5.converter.quickfix.presentation.text=어설션 변환
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=호환되지 않는 상속자가 있으므로 클래스 {0}을(를) JUnit 5로 변환할 수 없습니다. {1}
jvm.inspections.thread.run.display.name='Thread.run()' 호출
jvm.inspections.serializable.class.without.serialversionuid.display.name='serialVersionUID'가 없는 serializable 클래스
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code>이(가) 'serialVersionUID' 필드를 정의하지 않습니다 #loc
jvm.inspections.source.to.sink.flow.passed.unsafe=안전하지 않은 문자열이 안전한 매개변수로 사용됨
jvm.inspections.source.to.sink.flow.passed.unknown=알 수 없는 문자열이 안전한 매개변수로 사용됨
jvm.inspections.source.to.sink.flow.returned.unsafe=안전하지 않은 문자열이 안전한 메서드에서 반환됨
jvm.inspections.source.to.sink.flow.returned.unknown=알 수 없는 문자열이 안전한 메서드에서 반환됨
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=검증 필요로 표시
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=''{0}''을(를) 검증 필요로 표시
jvm.inspections.blocking.method.consider.unknown.context.blocking=알 수 없는 컨텍스트를 블로킹으로 고려
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=안전한 어노테이션 전달
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=''{0}''(으)로부터 안전한 어노테이션 전달
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=안전하다고 어노테이션을 추가할 멤버 선택
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=제외된 것만 빼고 모두 어노테이션 추가
propagated.from=안전하다고 표시할 사유:
propagated.to=안전하다고 표시할 대상:
propagate.from.empty.text=안전함으로 표시할 사유가 여기에 표시됩니다
propagate.to.empty.text=안전함으로 표시할 대상이 여기에 표시됩니다
jvm.inspections.blocking.method.problem.wildcard.descriptor={0}에서 호출을 블로킹하면 스레드에서 기아 상태를 일으킬 수 있습니다
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=안전하지 않은 흐름
jvm.inspections.source.to.sink.flow.assigned.unsafe=안전하지 않은 문자열이 안전한 변수에 대입됨
jvm.inspections.source.to.sink.flow.assigned.unknown=알 수 없는 문자열이 안전한 변수에 대입됨
jvm.inspections.source.to.sink.flow.common.unsafe=안전하지 않은 문자열이 안전한 컨텍스트에 사용됨
jvm.inspections.source.to.sink.flow.common.unknown=알 수 없는 문자열이 안전한 컨텍스트에 사용됨
jvm.inspections.api.display.name=구성된 언어 수준에서 사용할 수 없는 API 사용
jvm.inspections.1.5.problem.descriptor=@since {0}+로 기록된 API 사용
jvm.inspections.1.7.problem.descriptor=JDK {0}에 컴파일 문제를 일으킬 수 있는 1.6 이후에 일반화된 API 사용
jvm.inspections.1.8.problem.descriptor=디폴트 {0, choice, 0#|1#메서드가|2#메서드가} 재정의되지 않았습니다. JDK {1)에 컴파일 문제를 일으킬 수 있습니다.
jvm.inspections.1.8.problem.single.descriptor=디폴트 메서드 ''{0}''이(가) 재정의되지 않았습니다. 이로 인해 JDK {1}에 컴파일 문제가 발생할 수 있습니다
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=검증 필요로 표시
jvm.inspections.source.unsafe.to.sink.flow.preview.multiple.files={0}에 ''@Untainted'' 어노테이션 추가
jvm.inspections.dependency.on.internal.display.name=내부 패키지에 유효하지 않은 종속 요소
inspection.message.illegal.dependency.module.doesn.t.export=유효하지 않은 종속 요소: 모듈 ''{0}''은(는) 패키지 ''{1}''을(를) 내보내지 않습니다
jvm.inspections.test.frameworks.group.name=테스트 프레임워크
assertequals.between.inconvertible.types.display.name=변환할 수 없는 타입의 객체 간의 'assertequals()'
jvm.inspections.assertequals.between.inconvertible.types.problem.descriptor=<code>#ref()</code>이(가) 변환할 수 없는 타입인 ''{0}'' 및 ''{1}''의 객체 사이에 있습니다. #loc
jvm.inspections.assertnotsame.between.inconvertible.types.problem.descriptor=어설션이 불필요합니다. 호환되지 않는 타입, ''{0}'' 및 ''{1}''이(가) 비교됩니다
jvm.inspections.assertnotequals.between.inconvertible.types.problem.descriptor=어설션이 불필요할 수 있습니다. 호환되지 않는 타입, ''{0}'' 및 ''{1}''이(가) 비교됩니다
jvm.inspections.junit.malformed.declaration.name=JUnit 잘못된 형식의 선언
jvm.inspections.junit.malformed.option.ignore.test.parameter.if.annotated.by=다음 어노테이션이 추가된 경우 테스트 매개변수 무시:
jvm.inspections.junit.malformed.test.combination.descriptor={0}와 ''@{1}''의 의심스러운 조합
jvm.inspections.junit.malformed.repetition.number.descriptor=반복 횟수는 0보다 커야 합니다
jvm.inspections.junit.malformed.nested.class.descriptor=''@Nested''로 어노테이션된 클래스 <code>#ref</code>는 {0, choice, 1#{1}|2#{1} 및 {2}}이어야 합니다
jvm.inspections.junit.malformed.extension.registration.descriptor=''{0}''은(는) ''{1}''을(를) 구현해야 합니다
jvm.inspections.junit.malformed.extension.class.level.descriptor={0}은(는) 클래스 수준에서 등록되어야 합니다
jvm.inspections.junit.malformed.param.method.source.unresolved.descriptor=대상 메서드 소스를 확인할 수 없습니다. ''{0}''
jvm.inspections.junit.malformed.param.wrapped.in.arguments.descriptor=여러 매개변수는 'Arguments'로 감싸야 합니다
jvm.inspections.junit.malformed.param.method.source.return.type.descriptor=메서드 소스 ''{0}''에는 다음 반환 타입 중 하나가 포함되어야 합니다. ''Stream<?>'', ''Iterator<?>'', ''Iterable<?>'' 또는 ''Object[]''
jvm.inspections.junit.malformed.param.method.source.no.params.descriptor=메서드 소스 ''{0}''에는 매개변수가 포함될 수 없습니다
jvm.inspections.junit.malformed.param.method.source.static.descriptor=메서드 소스 ''{0}''은(는) static이어야 합니다
jvm.inspections.junit.malformed.param.method.source.assignable.descriptor=''{0}''을(를) ''{1}''(으)로 변환하는 묵시적 변환을 찾지 못했습니다
jvm.inspections.junit.malformed.param.duplicated.enum.descriptor='enum' 상수 이름 중복
jvm.inspections.junit.malformed.param.unresolved.enum.descriptor='enum' 상수 참조를 해결할 수 없습니다.
jvm.inspections.junit.malformed.param.no.value.source.is.defined.descriptor=정의된 값 소스가 없습니다
jvm.inspections.junit.malformed.param.exactly.one.type.of.input.must.be.provided.descriptor=입력 타입은 정확히 하나만 제공되어야 합니다
jvm.inspections.junit.malformed.param.file.source.descriptor=파일 소스를 해결할 수 없습니다. ''{0}''
jvm.inspections.junit.malformed.param.no.sources.are.provided.descriptor=제공된 소스가 없어 스위트가 공백으로 남습니다
jvm.inspections.junit.malformed.annotated.method.param.single.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) 매개변수 ''{1}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.method.typed.param.single.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) ''{1}'' 타입이어야 하며 매개변수 ''{2}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.method.single.param.single.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) {1}이어야 하며 매개변수 ''{2}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.method.double.param.single.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) {1} 및 {2}이어야 하며 매개변수 ''{3}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.method.single.typed.param.single.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) {1}이고 ''{2}'' 타입이어야 하며 매개변수 ''{3}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.method.double.typed.param.single.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) {1} 및 {2}이고 ''{3}'' 타입이어야 하며 매개변수 ''{4}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.method.param.double.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) 매개변수 {1} 및 ''{2}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.method.typed.param.double.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) ''{1}'' 타입이어야 하며 매개변수 {2} 및 ''{3}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.method.single.param.double.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) {1}이어야 하며 매개변수 ''{2}'' 및 ''{3}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.method.double.param.double.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) {1} 및 {2}이어야 하며 매개변수 ''{3}'' 및 ''{4}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.method.single.typed.param.double.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) {1}이고 ''{2}'' 타입이어야 하며 매개변수 {3} 및 ''{4}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.annotated.method.double.typed.param.double.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) {1} 및 {2}이고 ''{3}'' 타입이어야 하며 매개변수 {4} 및 ''{5}''을(를) 선언하면 안 됩니다
jvm.inspections.junit.malformed.fix.method.signature=메서드 시그니처 수정
jvm.inspections.junit.malformed.fix.method.signature.descriptor=''{0}'' 메서드 시그니처 수정
jvm.inspections.junit.malformed.fix.field.signature=필드 시그니처 수정
jvm.inspections.junit.malformed.fix.field.signature.descriptor=''{0}'' 필드 시그니처 수정
jvm.inspections.junit3.super.teardown.display.name=JUnit 3 'super.tearDown()'이 'finally' 블록에서 호출되지 않음
jvm.inspections.junit3.super.teardown.problem.descriptor=<code>#ref()</code>이(가) 'finally' 블록에서 호출되지 않습니다 #loc
jvm.inspections.junit.assertequals.on.array.display.name=배열에서 'assertEquals()' 호출
jvm.inspections.junit.assertequals.on.array.problem.descriptor=<code>#ref()</code>이(가) 배열에서 호출됩니다 #loc
jvm.inspections.junit.assertequals.may.be.assertsame.display.name='assertEquals()'가 'assertSame()'이 될 수 있음
jvm.inspections.junit.assertequals.may.be.assertsame.problem.descriptor=<code>#ref</code>이(가) 'assertSame()'이 될 수 있습니다 #loc
jvm.inspections.junit.malformed.annotated.suspend.function.descriptor=''@{0}'' 어노테이션이 추가된 메서드 <code>#ref</code>은(는) 일시 중지하는 함수가 아니어야 합니다
jvm.inspections.junit.malformed.suspend.function.descriptor=메서드 <code>#ref</code>은(는) 일시 중지하는 함수가 아니어야 합니다
jvm.inspections.migrate.assertion.name=JUnit 어설션은 'assertThat()' 호출이 될 수 있음
jvm.inspections.migrate.assert.to.matcher.option=매처 메서드를 정적으로 가져오기
jvm.inspections.migrate.assert.to.matcher.description=어설션 표현식 <code>#ref</code>을(를) ''{0}'' 호출로 바꿀 수 있습니다 #loc
jvm.inspections.junit.ignored.test.display.name=JUnit 테스트에 '@Ignore'/'@Disabled' 어노테이션 추가
jvm.inspections.junit.ignored.test.ignore.reason.option=이유 없이 사용된 어노테이션만 보고
jvm.inspections.junit.ignored.test.class.problem.descriptor=테스트 클래스 ''{0}''이(가) 무시/비활성화되었습니다. 이유: {1, choice, 1#|2#없음} #loc
jvm.inspections.junit.ignored.test.method.problem.descriptor=테스트 메서드 ''{0}''이(가) 무시/비활성화되었습니다. 이유: {1, choice, 1#|2#없음} #loc
jvm.inspections.test.method.without.assertion.display.name=어설션이 없는 테스트 메서드
jvm.inspections.test.method.without.assertion.problem.descriptor=테스트 메서드 <code>#ref()</code>에 어설션이 없습니다 #loc
jvm.inspections.test.case.with.constructor.display.name=사소하지 않은 생성자가 있는 TestCase
jvm.inspections.test.case.with.constructor.problem.descriptor=생명주기 메서드 'setup()'이 아닌 생성자 <code>#ref()</code>의 초기화 논리 #loc
jvm.inspections.test.case.with.constructor.problem.descriptor.initializer=생명주기 메서드 'setup()'이 아닌 이니셜라이저의 초기화 논리
jvm.inspections.unconstructable.test.case.display.name=생성할 수 없는 JUnit 테스트 케이스
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.preview=안전한 어노테이션의 전달을 구성하기 위한 도구 창을 엽니다
jvm.inspections.test.case.in.product.source.display.name=제품 소스 내 테스트
jvm.inspections.test.case.in.product.source.problem.descriptor=테스트 케이스 <code>#ref</code>은(는) 테스트 소스 트리에 배치해야 할 수 있습니다 #loc
jvm.inspections.test.method.in.product.source.problem.descriptor=테스트 메서드 <code>#ref()</code>은(는) 테스트 소스 트리에 배치해야 할 수 있습니다 #loc
jvm.inspections.junit.malformed.no.arg.descriptor=메서드 <code>#ref</code>는 {0}, {1}이고 {2, choice, 0#매개변수가 없어야|1#, 매개변수가 없고 void 타입이어야} 합니다
jvm.inspections.junit.malformed.annotated.single.descriptor=''@{1}'' 어노테이션이 추가된 {0, choice, 0#필드|1#메서드} <code>#ref</code>은(는) {2}이어야 합니다
jvm.inspections.junit.malformed.annotated.double.descriptor=''@{1}'' 어노테이션이 추가된 {0, choice, 0#필드|1#메서드} <code>#ref</code>은(는) {2} 및 {3}이어야 합니다
jvm.inspections.junit.malformed.annotated.typed.descriptor=''@{1}'' 어노테이션이 추가된 {0, choice, 0#필드|1#메서드} <code>#ref</code>은(는) ''{2}'' 타입이어야 합니다
jvm.inspections.junit.malformed.annotated.single.typed.descriptor=''@{1}'' 어노테이션이 추가된 {0, choice, 0#필드|1#메서드} <code>#ref</code>은(는) {2}이고 ''{3}'' 타입이어야 합니다
jvm.inspections.junit.malformed.annotated.double.typed.descriptor=''@{1}'' 어노테이션이 추가된 {0, choice, 0#필드|1#메서드} <code>#ref</code>은(는) {2} 및 {3}이고 ''{4}'' 타입이어야 합니다
jvm.inspections.junit.malformed.fix.class.signature=필드 시그니처 수정
jvm.inspections.junit.malformed.fix.class.signature.descriptor=''{0}'' 클래스 시그니처 수정
jvm.inspections.junit.malformed.source.without.params.descriptor=\n메서드에 매개변수가 없으므로 ''@{0}''은(는) 메서드에 인수를 제공할 수 없습니다
jvm.inspections.junit.malformed.param.empty.source.unsupported.descriptor=메서드에 지원되지 않는 ''{1}'' 유형의 매개변수가 있으므로 ''@{0}''은(는) 메서드에 인수를 제공할 수 없습니다
jvm.inspections.junit.malformed.param.multiple.parameters.descriptor=이 소스는 여러 매개변수를 지원하지 않습니다
