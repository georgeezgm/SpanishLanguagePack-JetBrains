jvm.inspections.group.name=Lenguaje JVM
jvm.inspections.unstable.api.usage.display.name=Usando API inestable
jvm.inspections.unstable.api.usage.annotations.list=Anotaciones API inestables
jvm.inspections.unstable.api.usage.ignore.inside.imports=Ignorar dentro de la declaración de importación
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=Ignore API declared in this project
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' está marcado como inestable en @ {1}.
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}'' is declared in unstable {1} ''{2}'' marked with @{3}
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=El método anulado ''{0}'' está marcado como inestable en @ {1}.
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=Método anulado ''{0}'' marcado como inestable {1 como @ {3}} Declarado en '' {2 } ''.
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' marcado como @ {3} inestable {1} ''{2}'' se hace referencia por su firma y, por lo tanto, es inestable
jvm.inspections.scheduled.for.removal.future.version=Versiones futuras
jvm.inspections.scheduled.for.removal.predefined.version=Versión {0}
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' está a punto de eliminarse de {1}.
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' está programado para ser eliminado de {3} ''{2}'' ha sido declarado en
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=El método anulado ''{0}'' está a punto de ser eliminado de {1}.
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=El método reemplazado ''{0}'' programado para ser eliminado de {3} {1} ''{2}'' fue declarado.
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' se eliminará de {3} {1 } ''{2}'' se hace referencia en su firma y se eliminará
jvm.inspections.unstable.type.used.in.signature.display.name=Tipo inestable utilizado en la firma
jvm.inspections.unstable.type.used.in.class.signature.description=Anotado ''@{0} '' porque la clase hace referencia al tipo inestable ''{1}'' en su declaración, debería ser
jvm.inspections.unstable.type.used.in.method.signature.description=Anotado ''@{0} '' porque el método hace referencia al tipo inestable ''{1}'' en su firma debe ser
jvm.inspections.unstable.type.used.in.field.signature.description=El campo está anotado con ''@{0} '' porque hace referencia al tipo inestable ''{1}'' debería ser
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=Falta la anotación '' @Deprecated '' en la API que se eliminará
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=Las API que se eliminarán también deben estar marcadas con la anotación '' @Deprecated ''.
jvm.inspections.must.already.be.removed.api.display.name=La API ya ha sido eliminada.
jvm.inspections.must.already.be.removed.api.earlier.version.description=La API se ha eliminado de {0} pero la versión actual es {1}.
jvm.inspections.must.already.be.removed.api.current.version.description=La API se ha eliminado de la versión actual {0}.
jvm.inspections.blocking.method.problem.descriptor=Llamada al método de bloqueo no válida.
jvm.inspections.blocking.method.display.name=Llamada al método de bloqueo de subprocesos no válida
jvm.inspections.blocking.method.annotation.blocking=Bloqueo de anotaciones
jvm.inspections.blocking.method.annotation.non-blocking=Non-Blocking Annotations
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=Agregar anotación de bloqueo
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=Add non-blocking annotation
jvm.inspections.blocking.method.annotation.configure.empty.text=No se agregaron anotaciones.
jvm.inspections.api.no.extension.display.name=La clase, la interfaz o el método no deben extenderse
jvm.inspections.api.no.extension.class.description=La clase ''{0}'' no debe extenderse.
jvm.inspections.api.no.extension.interface.implement.description=La interfaz ''{0}'' no debe implementarse.
jvm.inspections.api.no.extension.interface.extend.description=La interfaz ''{0}'' no debe extenderse.
jvm.inspections.api.no.extension.method.overriding.description=El método ''{0}'' no debe anularse.
jvm.inspections.api.override.only.display.name=Los métodos solo se pueden anular
jvm.inspections.api.override.only.description=El método ''{0}'' solo se puede anular.
jvm.inspections.dependency.display.name=Illegal package dependencies
jvm.inspections.dependency.edit.rules.text=Edit dependency rule \"{0} \"
jvm.inspections.dependency.edit.rules.family=Edit dependency rules
jvm.inspections.dependency.configure.button.text=Configure dependency rules
jvm.inspections.dependency.violator.problem.descriptor=Dependency rule ''{0}.'' is violated
jvm.inspections.testonly.display.name=Test-only usage in production code
jvm.inspections.testonly.class.reference=Test-only class is referenced in production code
jvm.inspections.testonly.field.reference=Test-only field is referenced in production code
jvm.inspections.testonly.method.call=Test-only method is called in production code
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting makes little sense on @TestOnly code
jvm.inspections.string.touppercase.tolowercase.without.locale.description=<code> String. Se llama a {0} ()</code> sin especificar una configuración regional que utilice una cadena internacionalizada.\#loc
can.t.build.uast.tree.for.file=No se pudo construir el árbol UAST para el archivo.
title.uast=UAST
current.version=Versión actual
dialog.title.choose.annotation=Seleccione {0}
jvm.inspection.test.failed.line.display.name=Failed line in test
jvm.inspections.source.to.sink.flow.display.name=Cadena insegura pasada a un método seguro
jvm.inspections.junit5.converter.display.name=Las pruebas JUnit 4 pueden convertirse en JUnit 5
jvm.inspections.junit5.converter.problem.descriptor=#ref puede ser una prueba JUnit 5
jvm.inspections.junit5.converter.quickfix=Migrar a JUnit 5
jvm.inspections.junit5.converter.quickfix.presentation.text=Conversión de afirmaciones
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=La clase {0} no se puede convertir a JUnit 5 porque tiene herederos incompatibles. {Uno}
jvm.inspections.thread.run.display.name=Llamar a 'Thread.run()'
jvm.inspections.serializable.class.without.serialversionuid.display.name=Clase serializable sin 'serialVersionUID'
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code>no define el campo 'serialVersionUID' #loc
jvm.inspections.source.to.sink.flow.passed.unsafe=Cadena insegura pasada a un método seguro
jvm.inspections.source.to.sink.flow.passed.unknown=Cadena insegura pasada a un método seguro
jvm.inspections.source.to.sink.flow.returned.unsafe=Cadena insegura devuelta por un método seguro
jvm.inspections.source.to.sink.flow.returned.unknown=Cadena desconocida devuelta por un método seguro
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=Marcar como que requiere verificación
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=Marcar ''{0}'' como que requiere verificación
jvm.inspections.blocking.method.consider.unknown.context.blocking=Considere bloquear contextos desconocidos
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=Entrega segura de anotaciones
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=Entrega segura de anotaciones desde ''{0}''
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=Seleccione miembros para anotar como seguros
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=Agregue anotaciones a todo excepto a los excluidos.
propagated.from=Razones para marcar como seguro:
propagated.to=Marcar como seguro:
propagate.from.empty.text=Los motivos para marcar como seguro se mostrarán aquí
propagate.to.empty.text=Todo lo que quieras marcar como seguro aparecerá aquí
jvm.inspections.blocking.method.problem.wildcard.descriptor=Bloquear llamadas en {0} puede causar falta de hilo en el hilo
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=Flujo inseguro
jvm.inspections.source.to.sink.flow.assigned.unsafe=Cadena insegura asignada a variable segura
jvm.inspections.source.to.sink.flow.assigned.unknown=Cadena desconocida asignada a variable segura
jvm.inspections.source.to.sink.flow.common.unsafe=Cadena insegura utilizada en un contexto seguro
jvm.inspections.source.to.sink.flow.common.unknown=Cadena desconocida utilizada en contexto seguro
jvm.inspections.api.display.name=Usar una API que no está disponible en el nivel de idioma configurado
jvm.inspections.1.5.problem.descriptor=Uso de API registrado como @since {0}+
jvm.inspections.1.7.problem.descriptor=Uso de API generalizada posterior a 1.6 que puede causar problemas de compilación en JDK {0}
jvm.inspections.1.8.problem.descriptor=El valor predeterminado {0,choice, 0#|1#method|2#method} no se ha anulado. Esto puede causar problemas de compilación en JDK {1).
jvm.inspections.1.8.problem.single.descriptor=El método predeterminado ''{0}'' no ha sido anulado. Esto puede causar problemas de compilación con JDK {1}
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=Marcar como que requiere verificación
jvm.inspections.source.unsafe.to.sink.flow.preview.multiple.files=Agregue la anotación ''@Untainted'' a {0}
jvm.inspections.dependency.on.internal.display.name=Dependencia no válida para el paquete interno
inspection.message.illegal.dependency.module.doesn.t.export=Dependencia no válida: el módulo ''{0}'' no exporta el paquete ''{1}''
jvm.inspections.test.frameworks.group.name=Marco de prueba
assertequals.between.inconvertible.types.display.name='assertequals()' entre objetos de tipos no convertibles
jvm.inspections.assertequals.between.inconvertible.types.problem.descriptor=<code>#ref()</code> está entre objetos de tipo ''{0}'' y ''{1}'', que no se pueden convertir. #loc
jvm.inspections.assertnotsame.between.inconvertible.types.problem.descriptor=Afirmación duplicada. Se comparan los tipos incompatibles, ''{0}'' y ''{1}''.
jvm.inspections.assertnotequals.between.inconvertible.types.problem.descriptor=Puede haber afirmaciones duplicadas. Se comparan los tipos incompatibles, ''{0}'' y ''{1}''.
jvm.inspections.junit.malformed.declaration.name=Declaración incorrecta de JUnit
jvm.inspections.junit.malformed.option.ignore.test.parameter.if.annotated.by=Ignore los parámetros de prueba si están anotados con:
jvm.inspections.junit.malformed.test.combination.descriptor=Combinación sospechosa de {0} y ''@{1}''
jvm.inspections.junit.malformed.repetition.number.descriptor=El número de iteraciones debe ser mayor que 0.
jvm.inspections.junit.malformed.nested.class.descriptor=Sólo se pueden utilizar clases anidadas no estáticas como clases de prueba '@Nested'
jvm.inspections.junit.malformed.extension.registration.descriptor={0}'' debe implementar ''{1}
jvm.inspections.junit.malformed.extension.class.level.descriptor={0} debe estar registrado a nivel de clase
jvm.inspections.junit.malformed.param.method.source.unresolved.descriptor=El origen del método de destino no se puede resolver. ''{0}''
jvm.inspections.junit.malformed.param.wrapped.in.arguments.descriptor=Se deben incluir varios parámetros en 'Argumentos'
jvm.inspections.junit.malformed.param.method.source.return.type.descriptor=La fuente del método ''{0}'' debe contener uno de los siguientes tipos de devolución: ''Flujo<?>'', ''Iterador<?>'', ''Iterable<?>'' u ''Objeto[]''
jvm.inspections.junit.malformed.param.method.source.no.params.descriptor=La fuente del método ''{0}'' no puede contener parámetros
jvm.inspections.junit.malformed.param.method.source.static.descriptor=Para el método fuente ''{0}'' siempre debe ser estático
jvm.inspections.junit.malformed.param.method.source.assignable.descriptor=No se encontró ninguna conversión implícita para convertir ''{0}'' a ''{1}''
jvm.inspections.junit.malformed.param.duplicated.enum.descriptor=Nombre constante 'enum' duplicado
jvm.inspections.junit.malformed.param.unresolved.enum.descriptor=No se puede resolver la referencia constante 'enum'.
jvm.inspections.junit.malformed.param.no.value.source.is.defined.descriptor=No hay fuente de valor definida
jvm.inspections.junit.malformed.param.exactly.one.type.of.input.must.be.provided.descriptor=Se debe proporcionar exactamente un tipo de entrada
jvm.inspections.junit.malformed.param.file.source.descriptor=No se pudo resolver el origen del archivo. ''{0}''
jvm.inspections.junit.malformed.param.no.sources.are.provided.descriptor=La suite se deja en blanco debido a que no se proporcionaron fuentes
jvm.inspections.junit.malformed.annotated.method.param.single.descriptor=El método <code>#ref</code> anotado con ''@{0}'' no debe declarar el parámetro ''{1}''
jvm.inspections.junit.malformed.annotated.method.typed.param.single.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser del tipo ''{1}'' y toma el parámetro ''{2}''. No debe declararse.
jvm.inspections.junit.malformed.annotated.method.single.param.single.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1} y no debe declarar el parámetro ''{2}''
jvm.inspections.junit.malformed.annotated.method.double.param.single.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1} y {2} y toma el parámetro ''{3}''. No debes declararlo.
jvm.inspections.junit.malformed.annotated.method.single.typed.param.single.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1} y escriba ''{2}'', con el parámetro ''{3}'' no debe declararse
jvm.inspections.junit.malformed.annotated.method.double.typed.param.single.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1} y {2} y escriba ''{3}'', con el parámetro '' {4}'' debe no ser declarado
jvm.inspections.junit.malformed.annotated.method.param.double.descriptor=Un método <code>#ref</code> anotado con ''@{0}'' declara los parámetros {1} y ''{2}''.
jvm.inspections.junit.malformed.annotated.method.typed.param.double.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser del tipo ''{1}'' y tiene los parámetros {2} y ''{ 3}'' no debe declararse.
jvm.inspections.junit.malformed.annotated.method.single.param.double.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1} y tiene los parámetros ''{2}'' y ''{3 }'' no debe declararse
jvm.inspections.junit.malformed.annotated.method.double.param.double.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1} y {2} con el parámetro ''{3}'' ''{4}'' no debe declararse
jvm.inspections.junit.malformed.annotated.method.single.typed.param.double.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1} y escriba ''{2}'' con los parámetros {3} y ) ''{4}'' debe no ser declarado
jvm.inspections.junit.malformed.annotated.method.double.typed.param.double.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1} y {2} y escribir ''{3}'', con parámetro {4 } y ''{5 }'' no debe ser declarado
jvm.inspections.junit.malformed.fix.method.signature=Editar firma del método
jvm.inspections.junit.malformed.fix.method.signature.descriptor=Modificar la firma del método ''{0}''
jvm.inspections.junit.malformed.fix.field.signature=Editar firma de campo
jvm.inspections.junit.malformed.fix.field.signature.descriptor=Modificar la firma del campo ''{0}''
jvm.inspections.junit3.super.teardown.display.name=JUnit 3 'super.tearDown()' no llamado en el bloque 'finalmente'
jvm.inspections.junit3.super.teardown.problem.descriptor=<code>#ref()</code> no se llama en el bloque 'finalmente' #loc
jvm.inspections.junit.assertequals.on.array.display.name=Llamar a 'assertEquals()' en una matriz
jvm.inspections.junit.assertequals.on.array.problem.descriptor=<code>#ref()</code> se llama en la matriz #loc
jvm.inspections.junit.assertequals.may.be.assertsame.display.name='assertEquals()' puede convertirse en 'assertSame()'
jvm.inspections.junit.assertequals.may.be.assertsame.problem.descriptor=<code>#ref</code>puede ser 'assertSame()' #loc
jvm.inspections.junit.malformed.annotated.suspend.function.descriptor=El método <code>#ref</code> anotado con ''@{0}'' no debe ser una función de pausa
jvm.inspections.junit.malformed.suspend.function.descriptor=El método <code>#ref</code> no debe ser una función de pausa
jvm.inspections.migrate.assertion.name=Las afirmaciones de JUnit pueden ser llamadas a 'assertThat()'
jvm.inspections.migrate.assert.to.matcher.option=Importar el método de comparación estáticamente
jvm.inspections.migrate.assert.to.matcher.description=La expresión de aserción <code>#ref</code> se puede reemplazar con una llamada a ''{0}'' #loc
jvm.inspections.junit.ignored.test.display.name=Agregue anotaciones '@Ignore'/'@Disabled' a las pruebas JUnit
jvm.inspections.junit.ignored.test.ignore.reason.option=Informar únicamente de las anotaciones utilizadas sin motivo
jvm.inspections.junit.ignored.test.class.problem.descriptor=La clase de prueba ''{0}'' ha sido ignorada/deshabilitada. Motivo: {1,choice, 1#|2#ninguno} #loc
jvm.inspections.junit.ignored.test.method.problem.descriptor=El método de prueba ''{0}'' se ignora/deshabilita. Motivo: {1,choice, 1#|2#ninguno} #loc
jvm.inspections.test.method.without.assertion.display.name=Método de prueba sin afirmaciones.
jvm.inspections.test.method.without.assertion.problem.descriptor=Sin aserción en el método de prueba <code>#ref()</code> #loc
jvm.inspections.test.case.with.constructor.display.name=TestCase con constructor no trivial
jvm.inspections.test.case.with.constructor.problem.descriptor=Lógica de inicialización #loc en el constructor <code>#ref()</code> distinta del método de ciclo de vida 'setup()'
jvm.inspections.test.case.with.constructor.problem.descriptor.initializer=Lógica de inicialización en inicializadores distintos del método de ciclo de vida 'setup()'
jvm.inspections.unconstructable.test.case.display.name=No se pueden crear casos de prueba JUnit
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.preview=Abre una ventana de herramientas para configurar la entrega de anotaciones seguras.
jvm.inspections.test.case.in.product.source.display.name=Pruebas del producto en origen
jvm.inspections.test.case.in.product.source.problem.descriptor=Es posible que sea necesario colocar los casos de prueba <code>#ref</code> en el árbol de fuentes de prueba con #loc
jvm.inspections.test.method.in.product.source.problem.descriptor=Es posible que sea necesario colocar el método de prueba <code>#ref()</code> en el árbol de fuentes de prueba con #loc
jvm.inspections.junit.malformed.no.arg.descriptor=El método <code>#ref</code> debe ser {0}, {1} y {2,choice, 0#sin parámetros|1#, sin parámetros y de tipo void}
jvm.inspections.junit.malformed.annotated.single.descriptor={0,choice, 0#field|1#method} <code>#ref</code> anotado con ''@{1}'' debe ser {2}
jvm.inspections.junit.malformed.annotated.double.descriptor=''@{1}'' anotado {0,choice, 0#campo|1#método} <code>#ref</code> debe ser {2} y {3}
jvm.inspections.junit.malformed.annotated.typed.descriptor={0,choice, 0#field|1#method} <code>#ref</code> anotado con ''@{1}'' debe ser del tipo ''{2}''
jvm.inspections.junit.malformed.annotated.single.typed.descriptor={0,choice, 0#field|1#method} <code>#ref</code> anotado con ''@{1}'' es {2} y el tipo ''{3}'' debe ser
jvm.inspections.junit.malformed.annotated.double.typed.descriptor=''@{1}'' anotado {0,choice, 0#field|1#method} <code>#ref</code> es {2} y {3} y ''{4 Debe ser de tipo }' '
jvm.inspections.junit.malformed.fix.class.signature=Editar firma de campo
jvm.inspections.junit.malformed.fix.class.signature.descriptor=Modificar firma de clase ''{0}''
jvm.inspections.junit.malformed.source.without.params.descriptor=\n''@{0}'' no puede proporcionar argumentos al método porque el método no tiene parámetros.
jvm.inspections.junit.malformed.param.empty.source.unsupported.descriptor=''@{0}'' no puede proporcionar argumentos al método porque el método tiene un parámetro de tipo ''{1}'', que no es compatible
jvm.inspections.junit.malformed.param.multiple.parameters.descriptor=Esta fuente no admite múltiples parámetros.
